LavaPack.loadBundle([
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/stream-to-pull-stream/index.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","looper":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/looper/index.js","pull-stream/pull":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/stream-to-pull-stream/index.js
      return function (require, module, exports) {
(function (process){(function (){
var pull = require('pull-stream/pull')
var looper = require('looper')

function destroy (stream) {
  if(!stream.destroy)
    console.error(
      'warning, stream-to-pull-stream: \n'
    + 'the wrapped node-stream does not implement `destroy`, \n'
    + 'this may cause resource leaks.'
    )
  else stream.destroy()

}

function write(read, stream, cb) {
  var ended, closed = false, did
  function done () {
    if(did) return
    did = true
    cb && cb(ended === true ? null : ended)
  }

  function onClose () {
    if(closed) return
    closed = true
    cleanup()
    if(!ended) read(ended = true, done)
    else       done()
  }
  function onError (err) {
    cleanup()
    if(!ended) read(ended = err, done)
  }
  function cleanup() {
    stream.on('finish', onClose)
    stream.removeListener('close', onClose)
    stream.removeListener('error', onError)
  }
  stream.on('close', onClose)
  stream.on('finish', onClose)
  stream.on('error', onError)
  process.nextTick(function () {
    looper(function (next) {
      read(null, function (end, data) {
        ended = ended || end
        //you can't "end" a stdout stream, so this needs to be handled specially.
        if(end === true)
          return stream._isStdio ? done() : stream.end()

        if(ended = ended || end) {
          destroy(stream)
          return done(ended)
        }

        //I noticed a problem streaming to the terminal:
        //sometimes the end got cut off, creating invalid output.
        //it seems that stdout always emits "drain" when it ends.
        //so this seems to work, but i have been unable to reproduce this test
        //automatically, so you need to run ./test/stdout.js a few times and the end is valid json.
        if(stream._isStdio)
          stream.write(data, function () { next() })
        else {
          var pause = stream.write(data)
          if(pause === false)
            stream.once('drain', next)
          else next()
        }
      })
    })
  })
}

function first (emitter, events, handler) {
  function listener (val) {
    events.forEach(function (e) {
      emitter.removeListener(e, listener)
    })
    handler(val)
  }
  events.forEach(function (e) {
    emitter.on(e, listener)
  })
  return emitter
}

function read2(stream) {
  var ended = false, waiting = false
  var _cb

  function read () {
    var data = stream.read()
    if(data !== null && _cb) {
      var cb = _cb; _cb = null
      cb(null, data)
    }
  }

  stream.on('readable', function () {
    waiting = true
    _cb && read()
  })
  .on('end', function () {
    ended = true
    _cb && _cb(ended)
  })
  .on('error', function (err) {
    ended = err
    _cb && _cb(ended)
  })

  return function (end, cb) {
    _cb = cb
    if(ended)
      cb(ended)
    else if(waiting)
      read()
  }
}

function read1(stream) {
  var buffer = [], cbs = [], ended, paused = false

  var draining
  function drain() {
    while((buffer.length || ended) && cbs.length)
      cbs.shift()(buffer.length ? null : ended, buffer.shift())
    if(!buffer.length && (paused)) {
      paused = false
      stream.resume()
    }
  }

  stream.on('data', function (data) {
    buffer.push(data)
    drain()
    if(buffer.length && stream.pause) {
      paused = true
      stream.pause()
    }
  })
  stream.on('end', function () {
    ended = true
    drain()
  })
  stream.on('close', function () {
    ended = true
    drain()
  })
  stream.on('error', function (err) {
    ended = err
    drain()
  })
  return function (abort, cb) {
    if(!cb) throw new Error('*must* provide cb')
    if(abort) {
      function onAbort () {
        while(cbs.length) cbs.shift()(abort)
        cb(abort)
      }
      //if the stream happens to have already ended, then we don't need to abort.
      if(ended) return onAbort()
      stream.once('close', onAbort)
      destroy(stream)
    }
    else {
      cbs.push(cb)
      drain()
    }
  }
}

var read = read1

var sink = function (stream, cb) {
  return function (read) {
    return write(read, stream, cb)
  }
}

var source = function (stream) {
  return read1(stream)
}

exports = module.exports = function (stream, cb) {
  return (
    (stream.writable && stream.write)
    ? stream.readable
      ? function(_read) {
          write(_read, stream, cb);
          return read1(stream)
        }
      : sink(stream, cb)
    : source(stream)
  )
}

exports.sink = sink
exports.source = source
exports.read = read
exports.read1 = read1
exports.read2 = read2
exports.duplex = function (stream, cb) {
  return {
    source: source(stream),
    sink: sink(stream, cb)
  }
}
exports.transform = function (stream) {
  return function (read) {
    var _source = source(stream)
    sink(stream)(read); return _source
  }
}










}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"stream-to-pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/stream-to-pull-stream/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/values.js", {"../util/abort-cb":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/util/abort-cb.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/values.js
      return function (require, module, exports) {
'use strict'
var abortCb = require('../util/abort-cb')

module.exports = function values (array, onAbort) {
  if(!array)
    return function (abort, cb) {
      if(abort) return abortCb(cb, abort, onAbort)
      return cb(true)
    }
  if(!Array.isArray(array))
    array = Object.keys(array).map(function (k) {
      return array[k]
    })
  var i = 0
  return function (abort, cb) {
    if(abort)
      return abortCb(cb, abort, onAbort)
    if(i >= array.length)
      cb(true)
    else
      cb(null, array[i++])
  }
}

      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/values.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/async-map.js", {"../util/prop":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/util/prop.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/async-map.js
      return function (require, module, exports) {
'use strict'

function id (e) { return e }
var prop = require('../util/prop')

module.exports = function asyncMap (map) {
  if(!map) return id
  map = prop(map)
  var busy = false, abortCb, aborted
  return function (read) {
    return function next (abort, cb) {
      if(aborted) return cb(aborted)
      if(abort) {
        aborted = abort
        if(!busy) read(abort, function (err) {
          //incase the source has already ended normally,
          //we should pass our own error.
          cb(abort)
        })
        else read(abort, function (err) {
          //if we are still busy, wait for the mapper to complete.
          if(busy) abortCb = cb
          else cb(abort)
        })
      }
      else
        read(null, function (end, data) {
          if(end) cb(end)
          else if(aborted) cb(aborted)
          else {
            busy = true
            map(data, function (err, data) {
              busy = false
              if(aborted) {
                cb(aborted)
                abortCb && abortCb(aborted)
              }
              else if(err) next (err, cb)
              else cb(null, data)
            })
          }
        })
    }
  }
}








      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/async-map.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/flatten.js", {"../sources/once":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/once.js","../sources/values":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/values.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/flatten.js
      return function (require, module, exports) {
'use strict'

var values = require('../sources/values')
var once = require('../sources/once')

//convert a stream of arrays or streams into just a stream.
module.exports = function flatten () {
  return function (read) {
    var _read
    return function (abort, cb) {
      if (abort) { //abort the current stream, and then stream of streams.
        _read ? _read(abort, function(err) {
          read(err || abort, cb)
        }) : read(abort, cb)
      }
      else if(_read) nextChunk()
      else nextStream()

      function nextChunk () {
        _read(null, function (err, data) {
          if (err === true) nextStream()
          else if (err) {
            read(true, function(abortErr) {
              // TODO: what do we do with the abortErr?
              cb(err)
            })
          }
          else cb(null, data)
        })
      }
      function nextStream () {
        _read = null
        read(null, function (end, stream) {
          if(end)
            return cb(end)
          if(Array.isArray(stream) || stream && 'object' === typeof stream)
            stream = values(stream)
          else if('function' != typeof stream)
            stream = once(stream)
          _read = stream
          nextChunk()
        })
      }
    }
  }
}


      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/flatten.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/src/supports.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/src/supports.js
      return function (require, module, exports) {
'use strict'

module.exports = {
  supportsFileReader: typeof self !== 'undefined' && 'FileReader' in self
}

      };
    };
  }
}, {package:"ipfs-utils",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/src/supports.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/src/streams/stream-from-filereader.js", {"../supports":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/src/supports.js","readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/src/streams/stream-from-filereader.js
      return function (require, module, exports) {
'use strict'
const { Readable } = require('readable-stream')
const { supportsFileReader } = require('../supports')

const streamFromFileReader = (file, options) => {
  if (!supportsFileReader) {
    throw new Error('FileReader DOM API is not supported.')
  }
  class FileStream extends Readable {
    constructor (file, options = {}) {
      super(options)
      this.file = file
      this.offset = options.offset || 0
      this.chunkSize = options.chunkSize || 1024 * 1024
      this.fileReader = new self.FileReader(file)
      this.fileReader.onloadend = (event) => {
        const data = event.target.result
        if (data.byteLength === 0) {
          this.push(null)
        }
        this.push(new Uint8Array(data))
      }
      this.fileReader.onerror = (err) => this.destroy(err)
    }

    _read (size) {
      const end = this.offset + this.chunkSize
      const slice = file.slice(this.offset, end)
      this.fileReader.readAsArrayBuffer(slice)
      this.offset = end
    }
  }

  return new FileStream(file, options)
}

module.exports = streamFromFileReader

      };
    };
  }
}, {package:"ipfs-utils",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/src/streams/stream-from-filereader.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/index.js", {"./dag-builder":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/index.js","./tree-builder":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/tree-builder.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js","superstruct":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/superstruct/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/index.js
      return function (require, module, exports) {
'use strict'

const { superstruct } = require('superstruct')
const dagBuilder = require('./dag-builder')
const treeBuilder = require('./tree-builder')
const mh = require('multihashes')

const struct = superstruct({
  types: {
    codec: v => ['dag-pb', 'dag-cbor', 'raw'].includes(v),
    hashAlg: v => Object.keys(mh.names).includes(v),
    leafType: v => ['file', 'raw'].includes(v)
  }
})

const ChunkerOptions = struct({
  minChunkSize: 'number?',
  maxChunkSize: 'number?',
  avgChunkSize: 'number?',
  window: 'number?',
  polynomial: 'number?'
}, {
  maxChunkSize: 262144,
  avgChunkSize: 262144,
  window: 16,
  polynomial: 17437180132763653 // https://github.com/ipfs/go-ipfs-chunker/blob/d0125832512163708c0804a3cda060e21acddae4/rabin.go#L11
})

const BuilderOptions = struct({
  maxChildrenPerNode: 'number?',
  layerRepeat: 'number?'
}, {
  maxChildrenPerNode: 174,
  layerRepeat: 4
})

const Options = struct({
  chunker: struct.enum(['fixed', 'rabin']),
  rawLeaves: 'boolean?',
  hashOnly: 'boolean?',
  strategy: struct.enum(['balanced', 'flat', 'trickle']),
  reduceSingleLeafToSelf: 'boolean?',
  codec: 'codec?',
  format: 'codec?',
  hashAlg: 'hashAlg?',
  leafType: 'leafType?',
  cidVersion: 'number?',
  progress: 'function?',
  wrapWithDirectory: 'boolean?',
  shardSplitThreshold: 'number?',
  onlyHash: 'boolean?',
  chunkerOptions: ChunkerOptions,
  builderOptions: BuilderOptions,

  wrap: 'boolean?',
  pin: 'boolean?',
  recursive: 'boolean?',
  ignore: 'array?',
  hidden: 'boolean?',
  preload: 'boolean?'
}, {
  chunker: 'fixed',
  strategy: 'balanced',
  rawLeaves: false,
  reduceSingleLeafToSelf: true,
  codec: 'dag-pb',
  hashAlg: 'sha2-256',
  leafType: 'file',
  cidVersion: 0,
  progress: () => () => {},
  shardSplitThreshold: 1000
})

module.exports = async function * (source, ipld, options = {}) {
  const opts = Options(options)

  if (options.cidVersion > 0 && options.rawLeaves === undefined) {
    // if the cid version is 1 or above, use raw leaves as this is
    // what go does.
    opts.rawLeaves = true
  }

  if (options.hashAlg !== undefined && options.rawLeaves === undefined) {
    // if a non-default hash alg has been specified, use raw leaves as this is
    // what go does.
    opts.rawLeaves = true
  }

  // go-ifps trickle dag defaults to unixfs raw leaves, balanced dag defaults to file leaves
  if (options.strategy === 'trickle') {
    opts.leafType = 'raw'
    opts.reduceSingleLeafToSelf = false
  }

  if (options.format) {
    options.codec = options.format
  }

  for await (const entry of treeBuilder(dagBuilder(source, ipld, opts), ipld, opts)) {
    yield {
      cid: entry.cid,
      path: entry.path,
      unixfs: entry.unixfs,
      size: entry.size
    }
  }
}

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/util/prop.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/util/prop.js
      return function (require, module, exports) {
module.exports = function prop (key) {
  return key && (
    'string' == typeof key
    ? function (data) { return data[key] }
    : 'object' === typeof key && 'function' === typeof key.exec //regexp
    ? function (data) { var v = key.exec(data); return v && v[0] }
    : key
  )
}

      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/util/prop.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/end-of-stream.js", {"../../../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/errors-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
      return function (require, module, exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/end-of-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/pipeline.js", {"../../../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/errors-browser.js","./end-of-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/pipeline.js
      return function (require, module, exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/pipeline.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_duplex.js", {"./_stream_readable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_writable.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_duplex.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_duplex.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_passthrough.js", {"./_stream_transform":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_transform.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_passthrough.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_passthrough.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_transform.js", {"../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_duplex.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_transform.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_transform.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_writable.js", {"../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_duplex.js","./internal/streams/destroy":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/state":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/state.js","./internal/streams/stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/stream-browser.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","util-deprecate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/util-deprecate/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_writable.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_writable.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_readable.js", {"../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_duplex.js","./internal/streams/async_iterator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/async_iterator.js","./internal/streams/buffer_list":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/buffer_list.js","./internal/streams/destroy":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/from":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/from-browser.js","./internal/streams/state":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/state.js","./internal/streams/stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/stream-browser.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","string_decoder/":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/string_decoder/lib/string_decoder.js","util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_readable.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/_stream_readable.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/readable-browser.js", {"./lib/_stream_duplex.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_passthrough.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_passthrough.js","./lib/_stream_readable.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_transform.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_writable.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_writable.js","./lib/internal/streams/end-of-stream.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","./lib/internal/streams/pipeline.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/readable-browser.js
      return function (require, module, exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/readable-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/index.js", {"./cp":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/cp.js","./flush":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/flush.js","./ls":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/ls.js","./mkdir":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/mkdir.js","./mv":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/mv.js","./read":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/read.js","./rm":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/rm.js","./stat":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/stat.js","./utils/create-lock":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/create-lock.js","./write":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/write.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/index.js
      return function (require, module, exports) {
'use strict'

const assert = require('assert')
const promisify = require('promisify-es6')
const createLock = require('./utils/create-lock')

// These operations are read-locked at the function level and will execute simultaneously
const readOperations = {
  stat: require('./stat')
}

// These operations are locked at the function level and will execute in series
const writeOperations = {
  cp: require('./cp'),
  flush: require('./flush'),
  mkdir: require('./mkdir'),
  mv: require('./mv'),
  rm: require('./rm')
}

// These operations are asynchronous and manage their own locking
const unwrappedOperations = {
  write: require('./write'),
  read: require('./read'),
  ls: require('./ls')
}

const wrap = ({
  options, mfs, operations, lock
}) => {
  Object.keys(operations).forEach(key => {
    mfs[key] = lock(operations[key](options))
  })
}

const defaultOptions = {
  repoOwner: true,
  ipld: null,
  repo: null
}

module.exports = (options) => {
  const {
    repoOwner
  } = Object.assign({}, defaultOptions || {}, options)

  assert(options.ipld, 'MFS requires an IPLD instance')
  assert(options.blocks, 'MFS requires an BlockStore instance')
  assert(options.datastore, 'MFS requires a DataStore instance')

  // should be able to remove this when async/await PRs are in for datastore, blockstore & repo
  options.repo = {
    blocks: {
      get: promisify(options.blocks.get, {
        context: options.blocks
      })
    },
    datastore: {
      open: promisify(options.datastore.open, {
        context: options.datastore
      }),
      get: promisify(options.datastore.get, {
        context: options.datastore
      }),
      put: promisify(options.datastore.put, {
        context: options.datastore
      })
    }
  }

  const lock = createLock(repoOwner)

  const readLock = (operation) => {
    return lock.readLock(operation)
  }

  const writeLock = (operation) => {
    return lock.writeLock(operation)
  }

  const mfs = {}

  wrap({
    options, mfs, operations: readOperations, lock: readLock
  })
  wrap({
    options, mfs, operations: writeOperations, lock: writeLock
  })

  Object.keys(unwrappedOperations).forEach(key => {
    mfs[key] = unwrappedOperations[key](options)
  })

  return mfs
}

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/snaps/index.js", {"./SnapController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/snaps/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./SnapController"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/snaps/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/subject-metadata/index.js", {"./SubjectMetadataController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/subject-metadata/SubjectMetadataController.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/subject-metadata/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./SubjectMetadataController"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/subject-metadata/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/services/index.js", {"./ExecutionEnvironmentService":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/services/ExecutionEnvironmentService.js","./WebWorkerExecutionEnvironmentService":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/services/WebWorkerExecutionEnvironmentService.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/services/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./ExecutionEnvironmentService"), exports);
__exportStar(require("./WebWorkerExecutionEnvironmentService"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/services/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/resource/index.js", {"./ExternalResourceController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/resource/ExternalResourceController.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/resource/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./ExternalResourceController"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/resource/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/index.js", {"./Caveat":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/Caveat.js","./Permission":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/Permission.js","./PermissionController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/PermissionController.js","./rpc-methods":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/index.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.permissionRpcMethods = void 0;
__exportStar(require("./Caveat"), exports);
__exportStar(require("./Permission"), exports);
__exportStar(require("./PermissionController"), exports);
__exportStar(require("./utils"), exports);
// TODO: Move these to the appropriate package
exports.permissionRpcMethods = __importStar(require("./rpc-methods"));
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/constants.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BIP_39_PATH_REGEX = exports.BIP_32_PATH_REGEX = exports.BIP44PurposeNodeToken = exports.MAX_BIP_44_DEPTH = exports.MIN_BIP_44_DEPTH = exports.BASE_64_REGEX = exports.HEXADECIMAL_KEY_LENGTH = exports.BASE_64_ZERO = exports.BASE_64_KEY_LENGTH = exports.BUFFER_KEY_LENGTH = void 0;
exports.BUFFER_KEY_LENGTH = 64;
exports.BASE_64_KEY_LENGTH = 88;
exports.BASE_64_ZERO = 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==';
exports.HEXADECIMAL_KEY_LENGTH = 128;
// Source: https://stackoverflow.com/a/475217
exports.BASE_64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?$/u;
exports.MIN_BIP_44_DEPTH = 0;
exports.MAX_BIP_44_DEPTH = 5;
exports.BIP44PurposeNodeToken = `bip32:44'`;
/**
 * e.g.
 * -  bip32:0
 * -  bip32:0'
 */
exports.BIP_32_PATH_REGEX = /^bip32:\d+'?$/u;
/**
 * bip39:<SPACE_DELMITED_SEED_PHRASE>
 *
 * The seed phrase must consist of 12 <= 24 words.
 */
exports.BIP_39_PATH_REGEX = /^bip39:([a-z]+){1}( [a-z]+){11,23}$/u;
//# sourceMappingURL=constants.js.map
      };
    };
  }
}, {package:"@metamask/key-tree",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.js", {"./BIP44Node":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/BIP44Node.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBIP44AddressKeyDeriver = exports.deriveBIP44AddressKey = exports.BIP44CoinTypeNode = exports.BIP_44_COIN_TYPE_DEPTH = void 0;
const BIP44Node_1 = require("./BIP44Node");
const utils_1 = require("./utils");
exports.BIP_44_COIN_TYPE_DEPTH = 2;
/**
 * Used to conceal the inner {@link BIP44Node} from consumers.
 */
const InnerNode = Symbol('_node');
/**
 * A wrapper object for BIP-44 `coin_type` keys. `coin_type` is the index
 * specifying the protocol for which deeper keys are intended. For the
 * authoritative list of coin types, please see
 * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).
 *
 * Recall that a BIP-44 HD tree path consists of the following nodes:
 *
 * `m / 44' / coin_type' / account' / change / address_index`
 *
 * With the following depths:
 *
 * `0 / 1 / 2 / 3 / 4 / 5`
 *
 */
class BIP44CoinTypeNode {
    /**
     * Constructs a BIP-44 `coin_type` node. `coin_type` is the index
     * specifying the protocol for which deeper keys are intended. For the
     * authoritative list of coin types, please see
     * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param nodeOrPathTuple - The {@link BIP44Node} or derivation path for the
     * key of this `coin_type` node.
     * @param coin_type - The coin_type index of this node. Must be a non-negative
     * integer.
     */
    constructor(nodeOrPathTuple, coin_type) {
        if (Array.isArray(nodeOrPathTuple)) {
            if (coin_type !== undefined) {
                throw new Error('Invalid parameters: May not specify both coin type and a derivation path. The coin type will be computed from the derivation path.');
            }
            validateCoinTypeNodeDepth(nodeOrPathTuple.length - 1);
            this[InnerNode] = new BIP44Node_1.BIP44Node({
                derivationPath: nodeOrPathTuple,
            });
            // Split the bip32 string token and extract the coin_type index
            this.coin_type = Number.parseInt(nodeOrPathTuple[exports.BIP_44_COIN_TYPE_DEPTH].split(':')[1].replace(`'`, ''), 10);
        }
        else {
            validateCoinTypeNodeDepth(nodeOrPathTuple.depth);
            validateCoinTypeParentKey(nodeOrPathTuple.key);
            const keyBuffer = nodeOrPathTuple instanceof BIP44Node_1.BIP44Node
                ? nodeOrPathTuple.keyBuffer
                : utils_1.base64StringToBuffer(nodeOrPathTuple.key);
            if (typeof coin_type !== 'number' ||
                !Number.isInteger(coin_type) ||
                coin_type < 0) {
                throw new Error('Invalid coin type: The specified coin type must be a non-negative integer number.');
            }
            this.coin_type = coin_type;
            this[InnerNode] =
                nodeOrPathTuple instanceof BIP44Node_1.BIP44Node
                    ? nodeOrPathTuple
                    : new BIP44Node_1.BIP44Node({
                        depth: exports.BIP_44_COIN_TYPE_DEPTH,
                        key: keyBuffer,
                    });
        }
        this.path = utils_1.getBIP44CoinTypePathString(this.coin_type);
        Object.freeze(this);
    }
    get depth() {
        return this[InnerNode].depth;
    }
    get key() {
        return this[InnerNode].key;
    }
    get keyBuffer() {
        return this[InnerNode].keyBuffer;
    }
    /**
     * Derives a BIP-44 `address_index` key corresponding to the path of this
     * node and the specified `account`, `change`, and `address_index` values.
     * `address_index` keys are normally the keys used to generate user account
     * addresses.
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param indices - The BIP-44 index values to use in key derivation.
     * @param indices.account - The `account` index. Default: `0`
     * @param indices.change - The `change` index. Default: `0`
     * @param indices.address_index - The `address_index` index.
     * @returns
     */
    deriveBIP44AddressKey({ account = 0, change = 0, address_index, }) {
        return this[InnerNode].derive(utils_1.getBIP44CoinTypeToAddressPathTuple({ account, change, address_index })).keyBuffer;
    }
    toJSON() {
        return Object.assign(Object.assign({}, this[InnerNode].toJSON()), { coin_type: this.coin_type, path: this.path });
    }
}
exports.BIP44CoinTypeNode = BIP44CoinTypeNode;
/**
 * Validates the depth of a `coin_type` node. Simply, ensures that it is the
 * number `2`. An error is thrown if validation fails.
 *
 * @param depth - The depth to validate.
 */
function validateCoinTypeNodeDepth(depth) {
    if (depth !== exports.BIP_44_COIN_TYPE_DEPTH) {
        throw new Error(`Invalid depth: Coin type nodes must be of depth ${exports.BIP_44_COIN_TYPE_DEPTH}. Received: "${depth}"`);
    }
}
/**
 * Validates a `coin_type` Base64 string key. "Parent" is in the name because
 * it's also in the message that's thrown on validation failure.
 *
 * @param parentKey The `coin_type` key to validate.
 */
function validateCoinTypeParentKey(parentKey) {
    if (!utils_1.isValidBase64StringKey(parentKey)) {
        throw new Error('Invalid parent key: Must be a non-zero 64-byte key.');
    }
}
/**
 * Derives a BIP-44 address key corresponding to the specified derivation path,
 * given either by a {@link BIP44CoinTypeNode} or derivation path tuple.
 *
 * Recall that a BIP-44 HD tree path consists of the following nodes:
 *
 * `m / 44' / coin_type' / account' / change / address_index`
 *
 * With the following depths:
 *
 * `0 / 1 / 2 / 3 / 4 / 5`
 *
 * @param parentKeyOrNode - The `coin_type` parent key to derive from.
 * @param indices - The `account`, `change`, and `address_index` used for
 * derivation.
 * @returns The derived `address_index` key for the specified derivation path.
 */
function deriveBIP44AddressKey(parentKeyOrNode, { account = 0, change = 0, address_index }) {
    if (typeof parentKeyOrNode === 'string') {
        validateCoinTypeParentKey(parentKeyOrNode);
    }
    else {
        validateCoinTypeNodeDepth(parentKeyOrNode.depth);
        validateCoinTypeParentKey(parentKeyOrNode.key);
    }
    let keyBuffer;
    if (parentKeyOrNode instanceof BIP44CoinTypeNode) {
        keyBuffer = parentKeyOrNode.keyBuffer;
    }
    else {
        keyBuffer = utils_1.base64StringToBuffer(typeof parentKeyOrNode === 'string'
            ? parentKeyOrNode
            : parentKeyOrNode.key);
    }
    return BIP44Node_1.deriveChildNode(keyBuffer, exports.BIP_44_COIN_TYPE_DEPTH, utils_1.getBIP44CoinTypeToAddressPathTuple({ account, change, address_index })).keyBuffer;
}
exports.deriveBIP44AddressKey = deriveBIP44AddressKey;
/**
 * Creates a function that derives BIP-44 address keys corresponding to the
 * specified derivation path, given either by a {@link BIP44CoinTypeNode} or
 * derivation path tuple.
 *
 * Recall that a BIP-44 HD tree path consists of the following nodes:
 *
 * `m / 44' / coin_type' / account' / change / address_index`
 *
 * With the following depths:
 *
 * `0 / 1 / 2 / 3 / 4 / 5`
 *
 * @param node - The {@link BIP44CoinTypeNode} to derive address keys from.
 * This node contains a BIP-44 key of depth 2, `coin_type`.
 * @param accountAndChangeIndices - The `account` and `change` indices that
 * will be used to derive addresses.
 * @returns The deriver function for the derivation path specified by the
 * `coin_type` node, `account`, and `change` indices.
 */
function getBIP44AddressKeyDeriver(node, accountAndChangeIndices) {
    const { account = 0, change = 0 } = accountAndChangeIndices || {};
    const { key, depth } = node;
    validateCoinTypeNodeDepth(depth);
    validateCoinTypeParentKey(key);
    const parentKeyBuffer = node instanceof BIP44CoinTypeNode
        ? node.keyBuffer
        : utils_1.base64StringToBuffer(key);
    const accountNode = utils_1.getHardenedBIP32NodeToken(account);
    const changeNode = utils_1.getUnhardenedBIP32NodeToken(change);
    const bip44AddressKeyDeriver = (address_index) => {
        return BIP44Node_1.deriveChildNode(parentKeyBuffer, exports.BIP_44_COIN_TYPE_DEPTH, [
            accountNode,
            changeNode,
            utils_1.getUnhardenedBIP32NodeToken(address_index),
        ]).keyBuffer;
    };
    bip44AddressKeyDeriver.coin_type = node.coin_type;
    bip44AddressKeyDeriver.path = utils_1.getBIP44ChangePathString(node.path, {
        account,
        change,
    });
    Object.freeze(bip44AddressKeyDeriver);
    return bip44AddressKeyDeriver;
}
exports.getBIP44AddressKeyDeriver = getBIP44AddressKeyDeriver;
//# sourceMappingURL=BIP44CoinTypeNode.js.map
      };
    };
  }
}, {package:"@metamask/key-tree",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/BIP44Node.js", {"../../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/constants.js","./derivation":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/derivation.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/BIP44Node.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deriveChildNode = exports.BIP44Node = void 0;
const derivation_1 = require("./derivation");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
/**
 * A wrapper for BIP-44 Hierarchical Deterministic (HD) tree nodes, i.e.
 * cryptographic keys used to generate keypairs and addresses for cryptocurrency
 * protocols.
 *
 * This class contains methods and fields that may not serialize well. Use
 * {@link BIP44Node.toJSON} to get a JSON-compatible representation.
 */
class BIP44Node {
    /**
     * Initializes a BIP-44 node. Accepts either:
     * - An existing 64-byte BIP-44 key, and its **0-indexed** BIP-44 path depth.
     *   - The key may be in the form of a hexadecimal string, Base64 string, or a
     *     {@link Buffer}.
     * - A BIP-44 derivation path starting with an `m` node.
     *   - At present, the `m` node must be a BIP-39 node, given as a string of
     *     the form `bip39:MNEMONIC`, where `MNEMONIC` is a space-separated list
     *     of BIP-39 seed phrase words.
     *
     * All parameters are stringently validated, and an error is thrown if
     * validation fails.
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param options - Options bag.
     * @param options.depth - The 0-indexed BIP-44 tree depth of the `key`, if
     * specified.
     * @param options.key - The key of this node. Mutually exclusive with
     * `derivationPath`, and requires a `depth` to be specified.
     * @param options.derivationPath - The rooted HD tree path that will be used
     * to derive the key of this node. Mutually exclusive with `key`.
     */
    constructor({ depth, key, derivationPath }) {
        const _key = BIP44Node._parseKey(key);
        if (derivationPath) {
            if (_key) {
                throw new Error('Invalid parameters: May not specify a derivation path if a key is specified. Initialize the node with just the parent key and its depth, then call BIP44Node.derive() with your desired path.');
            }
            if (depth) {
                throw new Error('Invalid parameters: May not specify a depth if a derivation path is specified. The depth will be calculated from the path.');
            }
            if (derivationPath.length === 0) {
                throw new Error('Invalid derivation path: May not specify an empty derivation path.');
            }
            const _depth = derivationPath.length - 1;
            validateBIP44Depth(_depth);
            this.depth = _depth;
            validateBIP44DerivationPath(derivationPath, constants_1.MIN_BIP_44_DEPTH);
            this.keyBuffer = derivation_1.deriveKeyFromPath(derivationPath, undefined, this.depth);
        }
        else if (_key) {
            validateBIP44Depth(depth);
            this.depth = depth;
            this.keyBuffer = _key;
        }
        else {
            throw new Error('Invalid parameters: Must specify either key or derivation path.');
        }
        Object.freeze(this);
    }
    get key() {
        return utils_1.bufferToBase64String(this.keyBuffer);
    }
    /**
     * Constructor helper for validating and parsing the `key` parameter. An error
     * is thrown if validation fails.
     *
     * @param key - The key to parse.
     * @returns A {@link Buffer}, or `undefined` if no key parameter was
     * specified.
     */
    static _parseKey(key) {
        if (key === undefined || key === null) {
            return undefined;
        }
        let bufferKey;
        if (Buffer.isBuffer(key)) {
            if (!utils_1.isValidBufferKey(key)) {
                throw new Error('Invalid buffer key: Must be a 64-byte, non-empty Buffer.');
            }
            bufferKey = key;
        }
        else if (typeof key === 'string') {
            if (utils_1.isValidHexStringKey(key)) {
                bufferKey = utils_1.hexStringToBuffer(key);
            }
            else if (utils_1.isValidBase64StringKey(key)) {
                bufferKey = utils_1.base64StringToBuffer(key);
            }
            else {
                throw new Error('Invalid string key: Must be a 64-byte hexadecimal or Base64 string.');
            }
        }
        else {
            throw new Error(`Invalid key: Must be a Buffer or string if specified. Received: "${typeof key}"`);
        }
        return bufferKey;
    }
    /**
     * Derives a child of the key contains be this node and returns a new
     * {@link BIP44Node} containing the child key.
     *
     * The specified path must be a valid HD path from this node, per BIP-44.
     * At present, this means that the path must consist of no more than 5 BIP-32
     * nodes, depending on the depth of this node.
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param path - The partial (non-rooted) BIP-44 HD tree path will be used
     * to derive a child key from the parent key contained within this node.
     * @returns The {@link BIP44Node} corresponding to the derived child key.
     */
    derive(path) {
        if (this.depth === constants_1.MAX_BIP_44_DEPTH) {
            throw new Error('Illegal operation: This HD tree node is already a leaf node.');
        }
        return deriveChildNode(this.keyBuffer, this.depth, path);
    }
    // This is documented in the interface of this class.
    toJSON() {
        return {
            depth: this.depth,
            key: this.key,
        };
    }
}
exports.BIP44Node = BIP44Node;
/**
 * Derives a child key from the given parent key, as a {@link BIP44Node}.
 * @param parentKey - The parent key to derive from.
 * @param parentDepth - The depth of the parent key.
 * @param pathToChild - The path to the child node / key.
 * @returns The {@link BIP44Node} corresponding to the derived child key.
 */
function deriveChildNode(parentKey, parentDepth, pathToChild) {
    if (pathToChild.length === 0) {
        throw new Error('Invalid HD tree derivation path: Deriving a path of length 0 is not defined');
    }
    // Note that we do not subtract 1 from the length of the path to the child,
    // unlike when we calculate the depth of a rooted path.
    const newDepth = (parentDepth + pathToChild.length);
    validateBIP44Depth(newDepth);
    validateBIP44DerivationPath(pathToChild, (parentDepth + 1));
    return new BIP44Node({
        depth: newDepth,
        key: derivation_1.deriveKeyFromPath(pathToChild, parentKey),
    });
}
exports.deriveChildNode = deriveChildNode;
/**
 * Validates a BIP-44 path depth. Effectively, asserts that the depth is an
 * integer `number` N such that 0 <= N <= 5. Throws an error if validation
 * fails.
 *
 * @param depth - The depth to validate.
 */
function validateBIP44Depth(depth) {
    if (typeof depth !== 'number' ||
        !Number.isInteger(depth) ||
        depth < constants_1.MIN_BIP_44_DEPTH ||
        depth > constants_1.MAX_BIP_44_DEPTH) {
        throw new Error(`Invalid HD tree path depth: The depth must be a positive integer N such that 0 <= N <= 5. Received: "${depth}"`);
    }
}
/**
 * Ensures that the given derivation is valid by BIP-44.
 *
 * Recall that a BIP-44 HD tree path consists of the following nodes:
 *
 * `m / 44' / coin_type' / account' / change / address_index`
 *
 * With the following depths:
 *
 * `0 / 1 / 2 / 3 / 4 / 5`
 *
 * @param path - The path to validate.
 * @param startingDepth - The depth of the first node of the derivation path.
 */
function validateBIP44DerivationPath(path, startingDepth) {
    path.forEach((nodeToken, index) => {
        const currentDepth = startingDepth + index;
        switch (currentDepth) {
            case constants_1.MIN_BIP_44_DEPTH:
                if (!constants_1.BIP_39_PATH_REGEX.test(nodeToken)) {
                    throw new Error('Invalid derivation path: The "m" / seed node (depth 0) must be a BIP-39 node.');
                }
                break;
            case 1:
                if (nodeToken !== constants_1.BIP44PurposeNodeToken) {
                    throw new Error(`Invalid derivation path: The "purpose" node node (depth 1) must be the string "${constants_1.BIP44PurposeNodeToken}".`);
                }
                break;
            case 2:
                if (!constants_1.BIP_32_PATH_REGEX.test(nodeToken) || !utils_1.isHardened(nodeToken)) {
                    throw new Error('Invalid derivation path: The "coin_type" node (depth 2) must be a hardened BIP-32 node.');
                }
                break;
            case 3:
                if (!constants_1.BIP_32_PATH_REGEX.test(nodeToken) || !utils_1.isHardened(nodeToken)) {
                    throw new Error('Invalid derivation path: The "account" node (depth 3) must be a hardened BIP-32 node.');
                }
                break;
            case 4:
                if (!constants_1.BIP_32_PATH_REGEX.test(nodeToken) || utils_1.isHardened(nodeToken)) {
                    throw new Error('Invalid derivation path: The "change" node (depth 4) must be an unhardened BIP-32 node.');
                }
                break;
            case constants_1.MAX_BIP_44_DEPTH: // 5
                if (!constants_1.BIP_32_PATH_REGEX.test(nodeToken) || utils_1.isHardened(nodeToken)) {
                    throw new Error('Invalid derivation path: The "address_index" node (depth 5) must be an unhardened BIP-32 node.');
                }
                break;
            /* istanbul ignore next: should be impossible in our usage */
            default:
                throw new Error(`Invalid derivation path: The path exceeds the maximum BIP-44 depth.`);
        }
    });
}

}).call(this)}).call(this,{"isBuffer":require("../../../is-buffer/index.js")})

      };
    };
  }
}, {package:"@metamask/key-tree",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/BIP44Node.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/isAbsoluteURL.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/isAbsoluteURL.js
      return function (require, module, exports) {
'use strict';

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/isAbsoluteURL.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/combineURLs.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/combineURLs.js
      return function (require, module, exports) {
'use strict';

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/combineURLs.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/der.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/der.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE
Object.defineProperty(exports, "__esModule", { value: true });
var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
    // begin
    0x30,
    0x81,
    0xd3,
    0x02,
    0x01,
    0x01,
    0x04,
    0x20,
    // private key
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    // middle
    0xa0,
    0x81,
    0x85,
    0x30,
    0x81,
    0x82,
    0x02,
    0x01,
    0x01,
    0x30,
    0x2c,
    0x06,
    0x07,
    0x2a,
    0x86,
    0x48,
    0xce,
    0x3d,
    0x01,
    0x01,
    0x02,
    0x21,
    0x00,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xfe,
    0xff,
    0xff,
    0xfc,
    0x2f,
    0x30,
    0x06,
    0x04,
    0x01,
    0x00,
    0x04,
    0x01,
    0x07,
    0x04,
    0x21,
    0x02,
    0x79,
    0xbe,
    0x66,
    0x7e,
    0xf9,
    0xdc,
    0xbb,
    0xac,
    0x55,
    0xa0,
    0x62,
    0x95,
    0xce,
    0x87,
    0x0b,
    0x07,
    0x02,
    0x9b,
    0xfc,
    0xdb,
    0x2d,
    0xce,
    0x28,
    0xd9,
    0x59,
    0xf2,
    0x81,
    0x5b,
    0x16,
    0xf8,
    0x17,
    0x98,
    0x02,
    0x21,
    0x00,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xfe,
    0xba,
    0xae,
    0xdc,
    0xe6,
    0xaf,
    0x48,
    0xa0,
    0x3b,
    0xbf,
    0xd2,
    0x5e,
    0x8c,
    0xd0,
    0x36,
    0x41,
    0x41,
    0x02,
    0x01,
    0x01,
    0xa1,
    0x24,
    0x03,
    0x22,
    0x00,
    // public key
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
]);
var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
    // begin
    0x30,
    0x82,
    0x01,
    0x13,
    0x02,
    0x01,
    0x01,
    0x04,
    0x20,
    // private key
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    // middle
    0xa0,
    0x81,
    0xa5,
    0x30,
    0x81,
    0xa2,
    0x02,
    0x01,
    0x01,
    0x30,
    0x2c,
    0x06,
    0x07,
    0x2a,
    0x86,
    0x48,
    0xce,
    0x3d,
    0x01,
    0x01,
    0x02,
    0x21,
    0x00,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xfe,
    0xff,
    0xff,
    0xfc,
    0x2f,
    0x30,
    0x06,
    0x04,
    0x01,
    0x00,
    0x04,
    0x01,
    0x07,
    0x04,
    0x41,
    0x04,
    0x79,
    0xbe,
    0x66,
    0x7e,
    0xf9,
    0xdc,
    0xbb,
    0xac,
    0x55,
    0xa0,
    0x62,
    0x95,
    0xce,
    0x87,
    0x0b,
    0x07,
    0x02,
    0x9b,
    0xfc,
    0xdb,
    0x2d,
    0xce,
    0x28,
    0xd9,
    0x59,
    0xf2,
    0x81,
    0x5b,
    0x16,
    0xf8,
    0x17,
    0x98,
    0x48,
    0x3a,
    0xda,
    0x77,
    0x26,
    0xa3,
    0xc4,
    0x65,
    0x5d,
    0xa4,
    0xfb,
    0xfc,
    0x0e,
    0x11,
    0x08,
    0xa8,
    0xfd,
    0x17,
    0xb4,
    0x48,
    0xa6,
    0x85,
    0x54,
    0x19,
    0x9c,
    0x47,
    0xd0,
    0x8f,
    0xfb,
    0x10,
    0xd4,
    0xb8,
    0x02,
    0x21,
    0x00,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xfe,
    0xba,
    0xae,
    0xdc,
    0xe6,
    0xaf,
    0x48,
    0xa0,
    0x3b,
    0xbf,
    0xd2,
    0x5e,
    0x8c,
    0xd0,
    0x36,
    0x41,
    0x41,
    0x02,
    0x01,
    0x01,
    0xa1,
    0x44,
    0x03,
    0x42,
    0x00,
    // public key
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
]);
exports.privateKeyExport = function (privateKey, publicKey, compressed) {
    if (compressed === void 0) { compressed = true; }
    var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
    privateKey.copy(result, compressed ? 8 : 9);
    publicKey.copy(result, compressed ? 181 : 214);
    return result;
};
exports.privateKeyImport = function (privateKey) {
    var length = privateKey.length;
    // sequence header
    var index = 0;
    if (length < index + 1 || privateKey[index] !== 0x30)
        return null;
    index += 1;
    // sequence length constructor
    if (length < index + 1 || !(privateKey[index] & 0x80))
        return null;
    var lenb = privateKey[index] & 0x7f;
    index += 1;
    if (lenb < 1 || lenb > 2)
        return null;
    if (length < index + lenb)
        return null;
    // sequence length
    var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
    index += lenb;
    if (length < index + len)
        return null;
    // sequence element 0: version number (=1)
    if (length < index + 3 ||
        privateKey[index] !== 0x02 ||
        privateKey[index + 1] !== 0x01 ||
        privateKey[index + 2] !== 0x01) {
        return null;
    }
    index += 3;
    // sequence element 1: octet string, up to 32 bytes
    if (length < index + 2 ||
        privateKey[index] !== 0x04 ||
        privateKey[index + 1] > 0x20 ||
        length < index + 2 + privateKey[index + 1]) {
        return null;
    }
    return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
};
exports.signatureImportLax = function (signature) {
    var r = Buffer.alloc(32, 0);
    var s = Buffer.alloc(32, 0);
    var length = signature.length;
    var index = 0;
    // sequence tag byte
    if (signature[index++] !== 0x30) {
        return null;
    }
    // sequence length byte
    var lenbyte = signature[index++];
    if (lenbyte & 0x80) {
        index += lenbyte - 0x80;
        if (index > length) {
            return null;
        }
    }
    // sequence tag byte for r
    if (signature[index++] !== 0x02) {
        return null;
    }
    // length for r
    var rlen = signature[index++];
    if (rlen & 0x80) {
        lenbyte = rlen - 0x80;
        if (index + lenbyte > length) {
            return null;
        }
        for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1)
            ;
        for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
            rlen = (rlen << 8) + signature[index];
    }
    if (rlen > length - index) {
        return null;
    }
    var rindex = index;
    index += rlen;
    // sequence tag byte for s
    if (signature[index++] !== 0x02) {
        return null;
    }
    // length for s
    var slen = signature[index++];
    if (slen & 0x80) {
        lenbyte = slen - 0x80;
        if (index + lenbyte > length) {
            return null;
        }
        for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1)
            ;
        for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
            slen = (slen << 8) + signature[index];
    }
    if (slen > length - index) {
        return null;
    }
    var sindex = index;
    index += slen;
    // ignore leading zeros in r
    for (; rlen > 0 && signature[rindex] === 0x00; rlen -= 1, rindex += 1)
        ;
    // copy r value
    if (rlen > 32) {
        return null;
    }
    var rvalue = signature.slice(rindex, rindex + rlen);
    rvalue.copy(r, 32 - rvalue.length);
    // ignore leading zeros in s
    for (; slen > 0 && signature[sindex] === 0x00; slen -= 1, sindex += 1)
        ;
    // copy s value
    if (slen > 32) {
        return null;
    }
    var svalue = signature.slice(sindex, sindex + slen);
    svalue.copy(s, 32 - svalue.length);
    return { r: r, s: s };
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/der.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js", {"bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bn.js/lib/bn.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","elliptic":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/elliptic/lib/elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE
Object.defineProperty(exports, "__esModule", { value: true });
var BN = require("bn.js");
var EC = require('elliptic').ec;
var ec = new EC('secp256k1');
var ecparams = ec.curve;
exports.privateKeyExport = function (privateKey, compressed) {
    if (compressed === void 0) { compressed = true; }
    var d = new BN(privateKey);
    if (d.ucmp(ecparams.n) >= 0) {
        throw new Error("couldn't export to DER format");
    }
    var point = ec.g.mul(d);
    return toPublicKey(point.getX(), point.getY(), compressed);
};
exports.privateKeyModInverse = function (privateKey) {
    var bn = new BN(privateKey);
    if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
        throw new Error('private key range is invalid');
    }
    return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);
};
exports.signatureImport = function (sigObj) {
    var r = new BN(sigObj.r);
    if (r.ucmp(ecparams.n) >= 0) {
        r = new BN(0);
    }
    var s = new BN(sigObj.s);
    if (s.ucmp(ecparams.n) >= 0) {
        s = new BN(0);
    }
    return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);
};
exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
    if (compressed === void 0) { compressed = true; }
    var point = ec.keyFromPublic(publicKey);
    var scalar = new BN(privateKey);
    if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
        throw new Error('scalar was invalid (zero or overflow)');
    }
    var shared = point.pub.mul(scalar);
    return toPublicKey(shared.getX(), shared.getY(), compressed);
};
var toPublicKey = function (x, y, compressed) {
    var publicKey;
    if (compressed) {
        publicKey = Buffer.alloc(33);
        publicKey[0] = y.isOdd() ? 0x03 : 0x02;
        x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
    }
    else {
        publicKey = Buffer.alloc(65);
        publicKey[0] = 0x04;
        x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
        y.toArrayLike(Buffer, 'be', 32).copy(publicKey, 33);
    }
    return publicKey;
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/iso-url/src/url-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/iso-url/src/url-browser.js
      return function (require, module, exports) {
'use strict';

const defaultBase = self.location ?
    self.location.protocol + '//' + self.location.host :
    '';
const URL = self.URL;

class URLWithLegacySupport {
    constructor(url = '', base = defaultBase) {
        this.super = new URL(url, base);
        this.path = this.pathname + this.search;
        this.auth =
            this.username && this.password ?
                this.username + ':' + this.password :
                null;

        this.query =
            this.search && this.search.startsWith('?') ?
                this.search.slice(1) :
                null;
    }

    get hash() {
        return this.super.hash;
    }
    get host() {
        return this.super.host;
    }
    get hostname() {
        return this.super.hostname;
    }
    get href() {
        return this.super.href;
    }
    get origin() {
        return this.super.origin;
    }
    get password() {
        return this.super.password;
    }
    get pathname() {
        return this.super.pathname;
    }
    get port() {
        return this.super.port;
    }
    get protocol() {
        return this.super.protocol;
    }
    get search() {
        return this.super.search;
    }
    get searchParams() {
        return this.super.searchParams;
    }
    get username() {
        return this.super.username;
    }

    set hash(hash) {
        this.super.hash = hash;
    }
    set host(host) {
        this.super.host = host;
    }
    set hostname(hostname) {
        this.super.hostname = hostname;
    }
    set href(href) {
        this.super.href = href;
    }
    set origin(origin) {
        this.super.origin = origin;
    }
    set password(password) {
        this.super.password = password;
    }
    set pathname(pathname) {
        this.super.pathname = pathname;
    }
    set port(port) {
        this.super.port = port;
    }
    set protocol(protocol) {
        this.super.protocol = protocol;
    }
    set search(search) {
        this.super.search = search;
    }
    set searchParams(searchParams) {
        this.super.searchParams = searchParams;
    }
    set username(username) {
        this.super.username = username;
    }

    createObjectURL(o) {
        return this.super.createObjectURL(o);
    }
    revokeObjectURL(o) {
        this.super.revokeObjectURL(o);
    }
    toJSON() {
        return this.super.toJSON();
    }
    toString() {
        return this.super.toString();
    }
    format() {
        return this.toString();
    }
}

function format(obj) {
    if (typeof obj === 'string') {
        const url = new URL(obj);

        return url.toString();
    }

    if (!(obj instanceof URL)) {
        const userPass =
            obj.username && obj.password ?
                `${obj.username}:${obj.password}@` :
                '';
        const auth = obj.auth ? obj.auth + '@' : '';
        const port = obj.port ? ':' + obj.port : '';
        const protocol = obj.protocol ? obj.protocol + '//' : '';
        const host = obj.host || '';
        const hostname = obj.hostname || '';
        const search = obj.search || (obj.query ? '?' + obj.query : '');
        const hash = obj.hash || '';
        const pathname = obj.pathname || '';
        const path = obj.path || pathname + search;

        return `${protocol}${userPass || auth}${host ||
            hostname + port}${path}${hash}`;
    }
}

module.exports = {
    URLWithLegacySupport,
    URLSearchParams: self.URLSearchParams,
    defaultBase,
    format
};

      };
    };
  }
}, {package:"iso-url",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/iso-url/src/url-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/iso-url/src/relative.js", {"./url":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/iso-url/src/url-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/iso-url/src/relative.js
      return function (require, module, exports) {
'use strict';

const { URLWithLegacySupport, format } = require('./url');

module.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {
    let protocol = location.protocol ?
        location.protocol.replace(':', '') :
        'http';

    // Check protocol map
    protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ':';
    let urlParsed;

    try {
        urlParsed = new URLWithLegacySupport(url);
    } catch (err) {
        urlParsed = {};
    }

    const base = Object.assign({}, location, {
        protocol: protocol || urlParsed.protocol,
        host: location.host || urlParsed.host
    });

    return new URLWithLegacySupport(url, format(base)).toString();
};

      };
    };
  }
}, {package:"iso-url",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/iso-url/src/relative.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/node_modules/uuid/lib/rng-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/node_modules/uuid/lib/rng-browser.js
      return function (require, module, exports) {
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

      };
    };
  }
}, {package:"uuid",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/node_modules/uuid/lib/rng-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/node_modules/uuid/lib/bytesToUuid.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/node_modules/uuid/lib/bytesToUuid.js
      return function (require, module, exports) {
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;

      };
    };
  }
}, {package:"uuid",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/node_modules/uuid/lib/bytesToUuid.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs/lib/lib/getTransactionSuccess.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs/lib/lib/getTransactionSuccess.js
      return function (require, module, exports) {
"use strict";

module.exports = function (eth) {
  return function (txHash, callback) {
    var count = 0;

    var timeout = eth.options.timeout || 800000;
    var interval = eth.options.interval || 7000;

    var prom = new Promise(function (resolve, reject) {
      var txInterval = setInterval(function () {
        eth.getTransactionReceipt(txHash, function (err, result) {
          if (err) {
            clearInterval(txInterval);
            reject(err);
          }

          if (!err && result) {
            clearInterval(txInterval);
            resolve(result);
          }
        });

        if (count >= timeout) {
          clearInterval(txInterval);
          var errMessage = "Receipt timeout waiting for tx hash: " + txHash;
          reject(errMessage);
        }

        count += interval;
      }, interval);
    });

    if (callback) {
      prom.then(function (res) {
        return callback(null, res);
      })["catch"](function (err) {
        return callback(err, null);
      });
    }

    return callback ? null : prom;
  };
};
      };
    };
  }
}, {package:"ethjs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs/lib/lib/getTransactionSuccess.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/bn.js/lib/bn.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/bn.js/lib/bn.js
      return function (require, module, exports) {
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = require('buf' + 'fer').Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      r.strip();
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

      };
    };
  }
}, {package:"bn.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/bn.js/lib/bn.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/js-sha3/src/sha3.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/js-sha3/src/sha3.js
      return function (require, module, exports) {
(function (process){(function (){
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.5.5
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2016
 * @license MIT
 */
(function (root) {
  'use strict';

  var NODE_JS = typeof process == 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  }
  var COMMON_JS = !root.JS_SHA3_TEST && typeof module == 'object' && module.exports;
  var HEX_CHARS = '0123456789abcdef'.split('');
  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
  var KECCAK_PADDING = [1, 256, 65536, 16777216];
  var PADDING = [6, 1536, 393216, 100663296];
  var SHIFT = [0, 8, 16, 24];
  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
            0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 
            2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 
            2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
            2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  var BITS = [224, 256, 384, 512];
  var SHAKE_BITS = [128, 256];
  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array'];

  var createOutputMethod = function (bits, padding, outputType) {
    return function (message) {
      return new Keccak(bits, padding, bits).update(message)[outputType]();
    }
  };

  var createShakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits) {
      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
    }
  };

  var createMethod = function (bits, padding) {
    var method = createOutputMethod(bits, padding, 'hex');
    method.create = function () {
      return new Keccak(bits, padding, bits);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0;i < OUTPUT_TYPES.length;++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(bits, padding, type);
    }
    return method;
  };

  var createShakeMethod = function (bits, padding) {
    var method = createShakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits) {
      return new Keccak(bits, padding, outputBits);
    };
    method.update = function (message, outputBits) {
      return method.create(outputBits).update(message);
    };
    for (var i = 0;i < OUTPUT_TYPES.length;++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createShakeOutputMethod(bits, padding, type);
    }
    return method;
  };

  var algorithms = [
    {name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod},
    {name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod},
    {name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod}
  ];

  var methods = {};

  for (var i = 0;i < algorithms.length;++i) {
    var algorithm = algorithms[i];
    var bits  = algorithm.bits;
    for (var j = 0;j < bits.length;++j) {
      methods[algorithm.name +'_' + bits[j]] = algorithm.createMethod(bits[j], algorithm.padding);
    }
  }

  function Keccak(bits, padding, outputBits) {
    this.blocks = [];
    this.s = [];
    this.padding = padding;
    this.outputBits = outputBits;
    this.reset = true;
    this.block = 0;
    this.start = 0;
    this.blockCount = (1600 - (bits << 1)) >> 5;
    this.byteCount = this.blockCount << 2;
    this.outputBlocks = outputBits >> 5;
    this.extraBytes = (outputBits & 31) >> 3;

    for (var i = 0;i < 50;++i) {
      this.s[i] = 0;
    }
  };

  Keccak.prototype.update = function (message) {
    var notString = typeof message != 'string';
    if (notString && message.constructor == root.ArrayBuffer) {
      message = new Uint8Array(message);
    }
    var length = message.length, blocks = this.blocks, byteCount = this.byteCount, 
        blockCount = this.blockCount, index = 0, s = this.s, i, code;
    
    while (index < length) {
      if (this.reset) {
        this.reset = false;
        blocks[0] = this.block;
        for (i = 1;i < blockCount + 1;++i) {
          blocks[i] = 0;
        }
      }
      if (notString) {
        for (i = this.start;index < length && i < byteCount;++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start;index < length && i < byteCount;++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }
      this.lastByteIndex = i;
      if (i >= byteCount) {
        this.start = i - byteCount;
        this.block = blocks[blockCount];
        for (i = 0;i < blockCount;++i) {
          s[i] ^= blocks[i];
        }
        f(s);
        this.reset = true;
      } else {
        this.start = i;
      }
    }
    return this;
  };

  Keccak.prototype.finalize = function () {
    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
    blocks[i >> 2] |= this.padding[i & 3];
    if (this.lastByteIndex == this.byteCount) {
      blocks[0] = blocks[blockCount];
      for (i = 1;i < blockCount + 1;++i) {
        blocks[i] = 0;
      }
    }
    blocks[blockCount - 1] |= 0x80000000;
    for (i = 0;i < blockCount;++i) {
      s[i] ^= blocks[i];
    }
    f(s);
  };

  Keccak.prototype.toString = Keccak.prototype.hex = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, 
        extraBytes = this.extraBytes, i = 0, j = 0;
    var hex = '', block;
    while (j < outputBlocks) {
      for (i = 0;i < blockCount && j < outputBlocks;++i, ++j) {
        block = s[i];
        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
               HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
               HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
               HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
      }
      if (j % blockCount == 0) {
        f(s);
        i = 0;
      }
    }
    if (extraBytes) {
      block = s[i];
      if (extraBytes > 0) {
        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
      }
      if (extraBytes > 1) {
        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
      }
      if (extraBytes > 2) {
        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
      }
    }
    return hex;
  };

  Keccak.prototype.arrayBuffer = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, 
        extraBytes = this.extraBytes, i = 0, j = 0;
    var bytes = this.outputBits >> 3;
    var buffer;
    if (extraBytes) {
      buffer = new ArrayBuffer((outputBlocks + 1) << 2);
    } else {
      buffer = new ArrayBuffer(bytes);
    }
    var array = new Uint32Array(buffer);
    while (j < outputBlocks) {
      for (i = 0;i < blockCount && j < outputBlocks;++i, ++j) {
        array[j] = s[i];
      }
      if (j % blockCount == 0) {
        f(s);
      }
    }
    if (extraBytes) {
      array[i] = s[i];
      buffer = buffer.slice(0, bytes);
    }
    return buffer;
  };

  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

  Keccak.prototype.digest = Keccak.prototype.array = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, 
        extraBytes = this.extraBytes, i = 0, j = 0;
    var array = [], offset, block;
    while (j < outputBlocks) {
      for (i = 0;i < blockCount && j < outputBlocks;++i, ++j) {
        offset = j << 2;
        block = s[i];
        array[offset] = block & 0xFF;
        array[offset + 1] = (block >> 8) & 0xFF;
        array[offset + 2] = (block >> 16) & 0xFF;
        array[offset + 3] = (block >> 24) & 0xFF;
      }
      if (j % blockCount == 0) {
        f(s);
      }
    }
    if (extraBytes) {
      offset = j << 2;
      block = s[i];
      if (extraBytes > 0) {
        array[offset] = block & 0xFF;
      }
      if (extraBytes > 1) {
        array[offset + 1] = (block >> 8) & 0xFF;
      }
      if (extraBytes > 2) {
        array[offset + 2] = (block >> 16) & 0xFF;
      }
    }
    return array;
  };

  var f = function (s) {
    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, 
        b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, 
        b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, 
        b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
    for (n = 0;n < 48;n += 2) {
      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
      s[0] ^= h;
      s[1] ^= l;
      s[10] ^= h;
      s[11] ^= l;
      s[20] ^= h;
      s[21] ^= l;
      s[30] ^= h;
      s[31] ^= l;
      s[40] ^= h;
      s[41] ^= l;
      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
      s[2] ^= h;
      s[3] ^= l;
      s[12] ^= h;
      s[13] ^= l;
      s[22] ^= h;
      s[23] ^= l;
      s[32] ^= h;
      s[33] ^= l;
      s[42] ^= h;
      s[43] ^= l;
      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
      s[4] ^= h;
      s[5] ^= l;
      s[14] ^= h;
      s[15] ^= l;
      s[24] ^= h;
      s[25] ^= l;
      s[34] ^= h;
      s[35] ^= l;
      s[44] ^= h;
      s[45] ^= l;
      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
      s[6] ^= h;
      s[7] ^= l;
      s[16] ^= h;
      s[17] ^= l;
      s[26] ^= h;
      s[27] ^= l;
      s[36] ^= h;
      s[37] ^= l;
      s[46] ^= h;
      s[47] ^= l;
      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
      s[8] ^= h;
      s[9] ^= l;
      s[18] ^= h;
      s[19] ^= l;
      s[28] ^= h;
      s[29] ^= l;
      s[38] ^= h;
      s[39] ^= l;
      s[48] ^= h;
      s[49] ^= l;

      b0 = s[0];
      b1 = s[1];
      b32 = (s[11] << 4) | (s[10] >>> 28);
      b33 = (s[10] << 4) | (s[11] >>> 28);
      b14 = (s[20] << 3) | (s[21] >>> 29);
      b15 = (s[21] << 3) | (s[20] >>> 29);
      b46 = (s[31] << 9) | (s[30] >>> 23);
      b47 = (s[30] << 9) | (s[31] >>> 23);
      b28 = (s[40] << 18) | (s[41] >>> 14);
      b29 = (s[41] << 18) | (s[40] >>> 14);
      b20 = (s[2] << 1) | (s[3] >>> 31);
      b21 = (s[3] << 1) | (s[2] >>> 31);
      b2 = (s[13] << 12) | (s[12] >>> 20);
      b3 = (s[12] << 12) | (s[13] >>> 20);
      b34 = (s[22] << 10) | (s[23] >>> 22);
      b35 = (s[23] << 10) | (s[22] >>> 22);
      b16 = (s[33] << 13) | (s[32] >>> 19);
      b17 = (s[32] << 13) | (s[33] >>> 19);
      b48 = (s[42] << 2) | (s[43] >>> 30);
      b49 = (s[43] << 2) | (s[42] >>> 30);
      b40 = (s[5] << 30) | (s[4] >>> 2);
      b41 = (s[4] << 30) | (s[5] >>> 2);
      b22 = (s[14] << 6) | (s[15] >>> 26);
      b23 = (s[15] << 6) | (s[14] >>> 26);
      b4 = (s[25] << 11) | (s[24] >>> 21);
      b5 = (s[24] << 11) | (s[25] >>> 21);
      b36 = (s[34] << 15) | (s[35] >>> 17);
      b37 = (s[35] << 15) | (s[34] >>> 17);
      b18 = (s[45] << 29) | (s[44] >>> 3);
      b19 = (s[44] << 29) | (s[45] >>> 3);
      b10 = (s[6] << 28) | (s[7] >>> 4);
      b11 = (s[7] << 28) | (s[6] >>> 4);
      b42 = (s[17] << 23) | (s[16] >>> 9);
      b43 = (s[16] << 23) | (s[17] >>> 9);
      b24 = (s[26] << 25) | (s[27] >>> 7);
      b25 = (s[27] << 25) | (s[26] >>> 7);
      b6 = (s[36] << 21) | (s[37] >>> 11);
      b7 = (s[37] << 21) | (s[36] >>> 11);
      b38 = (s[47] << 24) | (s[46] >>> 8);
      b39 = (s[46] << 24) | (s[47] >>> 8);
      b30 = (s[8] << 27) | (s[9] >>> 5);
      b31 = (s[9] << 27) | (s[8] >>> 5);
      b12 = (s[18] << 20) | (s[19] >>> 12);
      b13 = (s[19] << 20) | (s[18] >>> 12);
      b44 = (s[29] << 7) | (s[28] >>> 25);
      b45 = (s[28] << 7) | (s[29] >>> 25);
      b26 = (s[38] << 8) | (s[39] >>> 24);
      b27 = (s[39] << 8) | (s[38] >>> 24);
      b8 = (s[48] << 14) | (s[49] >>> 18);
      b9 = (s[49] << 14) | (s[48] >>> 18);

      s[0] = b0 ^ (~b2 & b4);
      s[1] = b1 ^ (~b3 & b5);
      s[10] = b10 ^ (~b12 & b14);
      s[11] = b11 ^ (~b13 & b15);
      s[20] = b20 ^ (~b22 & b24);
      s[21] = b21 ^ (~b23 & b25);
      s[30] = b30 ^ (~b32 & b34);
      s[31] = b31 ^ (~b33 & b35);
      s[40] = b40 ^ (~b42 & b44);
      s[41] = b41 ^ (~b43 & b45);
      s[2] = b2 ^ (~b4 & b6);
      s[3] = b3 ^ (~b5 & b7);
      s[12] = b12 ^ (~b14 & b16);
      s[13] = b13 ^ (~b15 & b17);
      s[22] = b22 ^ (~b24 & b26);
      s[23] = b23 ^ (~b25 & b27);
      s[32] = b32 ^ (~b34 & b36);
      s[33] = b33 ^ (~b35 & b37);
      s[42] = b42 ^ (~b44 & b46);
      s[43] = b43 ^ (~b45 & b47);
      s[4] = b4 ^ (~b6 & b8);
      s[5] = b5 ^ (~b7 & b9);
      s[14] = b14 ^ (~b16 & b18);
      s[15] = b15 ^ (~b17 & b19);
      s[24] = b24 ^ (~b26 & b28);
      s[25] = b25 ^ (~b27 & b29);
      s[34] = b34 ^ (~b36 & b38);
      s[35] = b35 ^ (~b37 & b39);
      s[44] = b44 ^ (~b46 & b48);
      s[45] = b45 ^ (~b47 & b49);
      s[6] = b6 ^ (~b8 & b0);
      s[7] = b7 ^ (~b9 & b1);
      s[16] = b16 ^ (~b18 & b10);
      s[17] = b17 ^ (~b19 & b11);
      s[26] = b26 ^ (~b28 & b20);
      s[27] = b27 ^ (~b29 & b21);
      s[36] = b36 ^ (~b38 & b30);
      s[37] = b37 ^ (~b39 & b31);
      s[46] = b46 ^ (~b48 & b40);
      s[47] = b47 ^ (~b49 & b41);
      s[8] = b8 ^ (~b0 & b2);
      s[9] = b9 ^ (~b1 & b3);
      s[18] = b18 ^ (~b10 & b12);
      s[19] = b19 ^ (~b11 & b13);
      s[28] = b28 ^ (~b20 & b22);
      s[29] = b29 ^ (~b21 & b23);
      s[38] = b38 ^ (~b30 & b32);
      s[39] = b39 ^ (~b31 & b33);
      s[48] = b48 ^ (~b40 & b42);
      s[49] = b49 ^ (~b41 & b43);

      s[0] ^= RC[n];
      s[1] ^= RC[n + 1];
    }
  }

  if (COMMON_JS) {
    module.exports = methods;
  } else if (root) {
    for (var key in methods) {
      root[key] = methods[key];
    }
  }
}(this));

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"js-sha3",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/js-sha3/src/sha3.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs/node_modules/ethjs-util/lib/index.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","is-hex-prefixed":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-hex-prefixed/src/index.js","strip-hex-prefix":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/strip-hex-prefix/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs/node_modules/ethjs-util/lib/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + padToEven(hex);
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return Buffer.from(hex.slice(2), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs/node_modules/ethjs-util/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-abi/lib/index.js", {"./utils/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-abi/lib/utils/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-abi/lib/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

/* eslint-disable */

var utils = require('./utils/index.js');
var uint256Coder = utils.uint256Coder;
var coderBoolean = utils.coderBoolean;
var coderFixedBytes = utils.coderFixedBytes;
var coderAddress = utils.coderAddress;
var coderDynamicBytes = utils.coderDynamicBytes;
var coderString = utils.coderString;
var coderArray = utils.coderArray;
var paramTypePart = utils.paramTypePart;
var getParamCoder = utils.getParamCoder;

function Result() {}

function encodeParams(types, values) {
  if (types.length !== values.length) {
    throw new Error('[ethjs-abi] while encoding params, types/values mismatch, Your contract requires ' + types.length + ' types (arguments), and you passed in ' + values.length);
  }

  var parts = [];

  types.forEach(function (type, index) {
    var coder = getParamCoder(type);
    parts.push({ dynamic: coder.dynamic, value: coder.encode(values[index]) });
  });

  function alignSize(size) {
    return parseInt(32 * Math.ceil(size / 32));
  }

  var staticSize = 0,
      dynamicSize = 0;
  parts.forEach(function (part) {
    if (part.dynamic) {
      staticSize += 32;
      dynamicSize += alignSize(part.value.length);
    } else {
      staticSize += alignSize(part.value.length);
    }
  });

  var offset = 0,
      dynamicOffset = staticSize;
  var data = new Buffer(staticSize + dynamicSize);

  parts.forEach(function (part, index) {
    if (part.dynamic) {
      uint256Coder.encode(dynamicOffset).copy(data, offset);
      offset += 32;

      part.value.copy(data, dynamicOffset);
      dynamicOffset += alignSize(part.value.length);
    } else {
      part.value.copy(data, offset);
      offset += alignSize(part.value.length);
    }
  });

  return '0x' + data.toString('hex');
}

// decode bytecode data from output names and types
function decodeParams(names, types, data) {
  var useNumberedParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  // Names is optional, so shift over all the parameters if not provided
  if (arguments.length < 3) {
    data = types;
    types = names;
    names = [];
  }

  data = utils.hexOrBuffer(data);
  var values = new Result();

  var offset = 0;
  types.forEach(function (type, index) {
    var coder = getParamCoder(type);

    if (coder.dynamic) {
      var dynamicOffset = uint256Coder.decode(data, offset);
      var result = coder.decode(data, dynamicOffset.value.toNumber());
      offset += dynamicOffset.consumed;
    } else {
      var result = coder.decode(data, offset);
      offset += result.consumed;
    }

    if (useNumberedParams) {
      values[index] = result.value;
    }

    if (names[index]) {
      values[names[index]] = result.value;
    }
  });
  return values;
}

// create an encoded method signature from an ABI object
function encodeSignature(method) {
  var signature = method.name + '(' + utils.getKeys(method.inputs, 'type').join(',') + ')';
  var signatureEncoded = '0x' + new Buffer(utils.keccak256(signature), 'hex').slice(0, 4).toString('hex');

  return signatureEncoded;
}

// encode method ABI object with values in an array, output bytecode
function encodeMethod(method, values) {
  var paramsEncoded = encodeParams(utils.getKeys(method.inputs, 'type'), values).substring(2);

  return '' + encodeSignature(method) + paramsEncoded;
}

// decode method data bytecode, from method ABI object
function decodeMethod(method, data) {
  var outputNames = utils.getKeys(method.outputs, 'name', true);
  var outputTypes = utils.getKeys(method.outputs, 'type');

  return decodeParams(outputNames, outputTypes, utils.hexOrBuffer(data));
}

// decode method data bytecode, from method ABI object
function encodeEvent(eventObject, values) {
  return encodeMethod(eventObject, values);
}

function eventSignature(eventObject) {
  var signature = eventObject.name + '(' + utils.getKeys(eventObject.inputs, 'type').join(',') + ')';

  return '0x' + utils.keccak256(signature);
}

// decode method data bytecode, from method ABI object
function decodeEvent(eventObject, data, topics) {
  var useNumberedParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  var nonIndexed = eventObject.inputs.filter(function (input) {
    return !input.indexed;
  });
  var nonIndexedNames = utils.getKeys(nonIndexed, 'name', true);
  var nonIndexedTypes = utils.getKeys(nonIndexed, 'type');
  var event = decodeParams(nonIndexedNames, nonIndexedTypes, utils.hexOrBuffer(data), useNumberedParams);
  var topicOffset = eventObject.anonymous ? 0 : 1;

  eventObject.inputs.filter(function (input) {
    return input.indexed;
  }).map(function (input, i) {
    var topic = new Buffer(topics[i + topicOffset].slice(2), 'hex');
    var coder = getParamCoder(input.type);
    event[input.name] = coder.decode(topic, 0).value;
  });

  event._eventName = eventObject.name;

  return event;
}

// Decode a specific log item with a specific event abi
function decodeLogItem(eventObject, log) {
  var useNumberedParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  if (eventObject && log.topics[0] === eventSignature(eventObject)) {
    return decodeEvent(eventObject, log.data, log.topics, useNumberedParams);
  }
}

// Create a decoder for all events defined in an abi. It returns a function which is called
// on an array of log entries such as received from getLogs or getTransactionReceipt and parses
// any matching log entries
function logDecoder(abi) {
  var useNumberedParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  var eventMap = {};
  abi.filter(function (item) {
    return item.type === 'event';
  }).map(function (item) {
    eventMap[eventSignature(item)] = item;
  });
  return function (logItems) {
    return logItems.map(function (log) {
      return decodeLogItem(eventMap[log.topics[0]], log, useNumberedParams);
    }).filter(function (i) {
      return i;
    });
  };
}

module.exports = {
  encodeParams: encodeParams,
  decodeParams: decodeParams,
  encodeMethod: encodeMethod,
  decodeMethod: decodeMethod,
  encodeEvent: encodeEvent,
  decodeEvent: decodeEvent,
  decodeLogItem: decodeLogItem,
  logDecoder: logDecoder,
  eventSignature: eventSignature,
  encodeSignature: encodeSignature
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethjs-abi",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-abi/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-query/lib/index.js", {"babel-runtime/core-js/json/stringify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/babel-runtime/core-js/json/stringify.js","babel-runtime/core-js/object/assign":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/babel-runtime/core-js/object/assign.js","babel-runtime/core-js/object/define-property":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/babel-runtime/core-js/object/define-property.js","babel-runtime/core-js/object/keys":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/babel-runtime/core-js/object/keys.js","babel-runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/babel-runtime/helpers/asyncToGenerator.js","babel-runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/babel-runtime/regenerator/index.js","ethjs-format":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethjs-format/lib/index.js","ethjs-rpc":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethjs-rpc/lib/index.js","promise-to-callback":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promise-to-callback/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-query/lib/index.js
      return function (require, module, exports) {
'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _defineProperty = require('babel-runtime/core-js/object/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var format = require('ethjs-format');
var EthRPC = require('ethjs-rpc');
var promiseToCallback = require('promise-to-callback');

module.exports = Eth;

function Eth(provider, options) {
  var self = this;
  var optionsObject = options || {};

  if (!(this instanceof Eth)) {
    throw new Error('[ethjs-query] the Eth object requires the "new" flag in order to function normally (i.e. `const eth = new Eth(provider);`).');
  }
  if (typeof provider !== 'object') {
    throw new Error('[ethjs-query] the Eth object requires that the first input \'provider\' must be an object, got \'' + typeof provider + '\' (i.e. \'const eth = new Eth(provider);\')');
  }

  self.options = (0, _assign2['default'])({
    debug: optionsObject.debug || false,
    logger: optionsObject.logger || console,
    jsonSpace: optionsObject.jsonSpace || 0
  });
  self.rpc = new EthRPC(provider);
  self.setProvider = self.rpc.setProvider;
}

Eth.prototype.log = function log(message) {
  var self = this;
  if (self.options.debug) self.options.logger.log('[ethjs-query log] ' + message);
};

(0, _keys2['default'])(format.schema.methods).forEach(function (rpcMethodName) {
  (0, _defineProperty2['default'])(Eth.prototype, rpcMethodName.replace('eth_', ''), {
    enumerable: true,
    value: generateFnFor(rpcMethodName, format.schema.methods[rpcMethodName])
  });
});

function generateFnFor(rpcMethodName, methodObject) {
  return function outputMethod() {
    var performCall = function () {
      var _ref = (0, _asyncToGenerator3['default'])( /*#__PURE__*/_regenerator2['default'].mark(function _callee() {
        var result, methodOutputs, outputError;
        return _regenerator2['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(args.length < methodObject[2])) {
                  _context.next = 2;
                  break;
                }

                throw new Error('[ethjs-query] method \'' + protoMethodName + '\' requires at least ' + methodObject[2] + ' input (format type ' + methodObject[0][0] + '), ' + args.length + ' provided. For more information visit: https://github.com/ethereum/wiki/wiki/JSON-RPC#' + rpcMethodName.toLowerCase());

              case 2:
                if (!(args.length > methodObject[0].length)) {
                  _context.next = 4;
                  break;
                }

                throw new Error('[ethjs-query] method \'' + protoMethodName + '\' requires at most ' + methodObject[0].length + ' params, ' + args.length + ' provided \'' + (0, _stringify2['default'])(args, null, self.options.jsonSpace) + '\'. For more information visit: https://github.com/ethereum/wiki/wiki/JSON-RPC#' + rpcMethodName.toLowerCase());

              case 4:

                // set default block
                if (methodObject[3] && args.length < methodObject[3]) {
                  args.push('latest');
                }

                // format inputs
                this.log('attempting method formatting for \'' + protoMethodName + '\' with inputs ' + (0, _stringify2['default'])(args, null, this.options.jsonSpace));
                _context.prev = 6;

                inputs = format.formatInputs(rpcMethodName, args);
                this.log('method formatting success for \'' + protoMethodName + '\' with formatted result: ' + (0, _stringify2['default'])(inputs, null, this.options.jsonSpace));
                _context.next = 14;
                break;

              case 11:
                _context.prev = 11;
                _context.t0 = _context['catch'](6);
                throw new Error('[ethjs-query] while formatting inputs \'' + (0, _stringify2['default'])(args, null, this.options.jsonSpace) + '\' for method \'' + protoMethodName + '\' error: ' + _context.t0);

              case 14:
                _context.next = 16;
                return this.rpc.sendAsync({ method: rpcMethodName, params: inputs });

              case 16:
                result = _context.sent;
                _context.prev = 17;

                this.log('attempting method formatting for \'' + protoMethodName + '\' with raw outputs: ' + (0, _stringify2['default'])(result, null, this.options.jsonSpace));
                methodOutputs = format.formatOutputs(rpcMethodName, result);

                this.log('method formatting success for \'' + protoMethodName + '\' formatted result: ' + (0, _stringify2['default'])(methodOutputs, null, this.options.jsonSpace));
                return _context.abrupt('return', methodOutputs);

              case 24:
                _context.prev = 24;
                _context.t1 = _context['catch'](17);
                outputError = new Error('[ethjs-query] while formatting outputs from RPC \'' + (0, _stringify2['default'])(result, null, this.options.jsonSpace) + '\' for method \'' + protoMethodName + '\' ' + _context.t1);
                throw outputError;

              case 28:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this, [[6, 11], [17, 24]]);
      }));

      return function performCall() {
        return _ref.apply(this, arguments);
      };
    }();

    var callback = null; // eslint-disable-line
    var inputs = null; // eslint-disable-line
    var inputError = null; // eslint-disable-line
    var self = this;
    var args = [].slice.call(arguments); // eslint-disable-line
    var protoMethodName = rpcMethodName.replace('eth_', ''); // eslint-disable-line

    if (args.length > 0 && typeof args[args.length - 1] === 'function') {
      callback = args.pop();
    }

    var promise = performCall.call(this);

    // if callback provided, convert promise to callback
    if (callback) {
      return promiseToCallback(promise)(callback);
    }

    // only return promise if no callback provided
    return promise;
  };
}
      };
    };
  }
}, {package:"ethjs-query",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-query/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/lib/index.js", {"./contract":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/lib/contract.js","./has-tx-object":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/lib/has-tx-object.js","babel-runtime/core-js/object/assign":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/babel-runtime/core-js/object/assign.js","ethjs-abi":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/node_modules/ethjs-abi/lib/index.js","ethjs-filter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethjs-filter/lib/index.js","ethjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/node_modules/ethjs-util/lib/index.js","js-sha3":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/js-sha3/src/sha3.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/lib/index.js
      return function (require, module, exports) {
'use strict';

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var abi = require('ethjs-abi'); // eslint-disable-line
var keccak256 = require('js-sha3').keccak_256; // eslint-disable-line
var EthFilter = require('ethjs-filter'); // eslint-disable-line
var getKeys = require('ethjs-util').getKeys; // eslint-disable-line
var Contract = require('./contract');
var hasTransactionObject = require('./has-tx-object');

module.exports = EthContract;

function EthContract(query) {
  return function contractFactory(contractABI, contractBytecode, contractDefaultTxObject) {
    // validate params
    if (!Array.isArray(contractABI)) {
      throw new Error('[ethjs-contract] Contract ABI must be type Array, got type ' + typeof contractABI);
    }
    if (typeof contractBytecode !== 'undefined' && typeof contractBytecode !== 'string') {
      throw new Error('[ethjs-contract] Contract bytecode must be type String, got type ' + typeof contractBytecode);
    }
    if (typeof contractDefaultTxObject !== 'undefined' && typeof contractDefaultTxObject !== 'object') {
      throw new Error('[ethjs-contract] Contract default tx object must be type Object, got type ' + typeof contractABI);
    }

    // build contract object
    var output = {};
    output.at = function contractAtAddress(address) {
      return new Contract({
        address: address,
        query: query,
        contractBytecode: contractBytecode,
        contractDefaultTxObject: contractDefaultTxObject,
        contractABI: contractABI
      });
    };

    output['new'] = function newContract() {
      var providedTxObject = {}; // eslint-disable-line
      var newMethodCallback = null; // eslint-disable-line
      var newMethodArgs = [].slice.call(arguments); // eslint-disable-line
      if (typeof newMethodArgs[newMethodArgs.length - 1] === 'function') newMethodCallback = newMethodArgs.pop();
      if (hasTransactionObject(newMethodArgs)) providedTxObject = newMethodArgs.pop();
      var constructorMethod = getConstructorFromABI(contractABI);
      var assembleTxObject = (0, _assign2['default'])({}, contractDefaultTxObject, providedTxObject);

      // set contract deploy bytecode
      if (contractBytecode) {
        assembleTxObject.data = contractBytecode;
      }

      // append encoded constructor arguments
      if (constructorMethod) {
        var constructorBytecode = abi.encodeParams(getKeys(constructorMethod.inputs, 'type'), newMethodArgs).substring(2); // eslint-disable-line
        assembleTxObject.data = '' + assembleTxObject.data + constructorBytecode;
      }

      return newMethodCallback ? query.sendTransaction(assembleTxObject, newMethodCallback) : query.sendTransaction(assembleTxObject);
    };

    return output;
  };
}

function getConstructorFromABI(contractABI) {
  return contractABI.filter(function (json) {
    return json.type === 'constructor';
  })[0];
}
      };
    };
  }
}, {package:"ethjs-contract",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_writable.js", {"./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_duplex.js","./internal/streams/destroy":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","core-util-is":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/core-util-is/lib/util.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","process-nextick-args":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process-nextick-args/index.js","safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/safe-buffer/index.js","timers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/timers-browserify/main.js","util-deprecate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/util-deprecate/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_writable.js
      return function (require, module, exports) {
(function (process,setImmediate){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/
var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = _isUint8Array(chunk) && !state.objectMode;

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    processNextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    processNextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      processNextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this)}).call(this,require('_process'),require("timers").setImmediate)

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_writable.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_duplex.js", {"./_stream_readable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_writable.js","core-util-is":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/core-util-is/lib/util.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","process-nextick-args":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process-nextick-args/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_duplex.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  processNextTick(cb, err);
};

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_duplex.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_transform.js", {"./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_duplex.js","core-util-is":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/core-util-is/lib/util.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_transform.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return stream.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_transform.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_passthrough.js", {"./_stream_transform":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_transform.js","core-util-is":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/core-util-is/lib/util.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_passthrough.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_passthrough.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_readable.js", {"./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_duplex.js","./internal/streams/BufferList":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/internal/streams/BufferList.js","./internal/streams/destroy":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","core-util-is":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/core-util-is/lib/util.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","isarray":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/isarray/index.js","process-nextick-args":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process-nextick-args/index.js","safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/safe-buffer/index.js","string_decoder/":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/string_decoder/lib/string_decoder.js","util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_readable.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

// TODO(bmeurer): Change this back to const once hole checks are
// properly optimized away early in Ignition+TurboFan.
/*<replacement>*/
var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/_stream_readable.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-typedarray/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/is-typedarray/index.js
      return function (require, module, exports) {
module.exports      = isTypedArray
isTypedArray.strict = isStrictTypedArray
isTypedArray.loose  = isLooseTypedArray

var toString = Object.prototype.toString
var names = {
    '[object Int8Array]': true
  , '[object Int16Array]': true
  , '[object Int32Array]': true
  , '[object Uint8Array]': true
  , '[object Uint8ClampedArray]': true
  , '[object Uint16Array]': true
  , '[object Uint32Array]': true
  , '[object Float32Array]': true
  , '[object Float64Array]': true
}

function isTypedArray(arr) {
  return (
       isStrictTypedArray(arr)
    || isLooseTypedArray(arr)
  )
}

function isStrictTypedArray(arr) {
  return (
       arr instanceof Int8Array
    || arr instanceof Int16Array
    || arr instanceof Int32Array
    || arr instanceof Uint8Array
    || arr instanceof Uint8ClampedArray
    || arr instanceof Uint16Array
    || arr instanceof Uint32Array
    || arr instanceof Float32Array
    || arr instanceof Float64Array
  )
}

function isLooseTypedArray(arr) {
  return names[toString.call(arr)]
}

      };
    };
  }
}, {package:"is-typedarray",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-typedarray/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/mutation.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/mutation.js
      return function (require, module, exports) {
'use strict';
//based off rsvp https://github.com/tildeio/rsvp.js
//license https://github.com/tildeio/rsvp.js/blob/master/LICENSE
//https://github.com/tildeio/rsvp.js/blob/master/lib/rsvp/asap.js

var Mutation = global.MutationObserver || global.WebKitMutationObserver;

exports.test = function () {
  return Mutation;
};

exports.install = function (handle) {
  var called = 0;
  var observer = new Mutation(handle);
  var element = global.document.createTextNode('');
  observer.observe(element, {
    characterData: true
  });
  return function () {
    element.data = (called = ++called % 2);
  };
};
      };
    };
  }
}, {package:"immediate",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/mutation.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/messageChannel.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/messageChannel.js
      return function (require, module, exports) {
'use strict';

exports.test = function () {
  if (global.setImmediate) {
    // we can only get here in IE10
    // which doesn't handel postMessage well
    return false;
  }
  return typeof global.MessageChannel !== 'undefined';
};

exports.install = function (func) {
  var channel = new global.MessageChannel();
  channel.port1.onmessage = func;
  return function () {
    channel.port2.postMessage(0);
  };
};
      };
    };
  }
}, {package:"immediate",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/messageChannel.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/stateChange.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/stateChange.js
      return function (require, module, exports) {
'use strict';

exports.test = function () {
  return 'document' in global && 'onreadystatechange' in global.document.createElement('script');
};

exports.install = function (handle) {
  return function () {

    // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
    // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
    var scriptEl = global.document.createElement('script');
    scriptEl.onreadystatechange = function () {
      handle();

      scriptEl.onreadystatechange = null;
      scriptEl.parentNode.removeChild(scriptEl);
      scriptEl = null;
    };
    global.document.documentElement.appendChild(scriptEl);

    return handle;
  };
};
      };
    };
  }
}, {package:"immediate",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/stateChange.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/timeout.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/timeout.js
      return function (require, module, exports) {
'use strict';
exports.test = function () {
  return true;
};

exports.install = function (t) {
  return function () {
    setTimeout(t, 0);
  };
};
      };
    };
  }
}, {package:"immediate",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/timeout.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/nextTick.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/nextTick.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict';
exports.test = function () {
  // Don't get fooled by e.g. browserify environments.
  return (typeof process !== 'undefined') && !process.browser;
};

exports.install = function (func) {
  return function () {
    process.nextTick(func);
  };
};

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"immediate",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/immediate/lib/nextTick.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/deferred-leveldown/deferred-iterator.js", {"abstract-leveldown":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/index.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/deferred-leveldown/deferred-iterator.js
      return function (require, module, exports) {
var AbstractIterator = require('abstract-leveldown').AbstractIterator
var inherits = require('inherits')

function DeferredIterator (options) {
  AbstractIterator.call(this, options)

  this._options = options
  this._iterator = null
  this._operations = []
}

inherits(DeferredIterator, AbstractIterator)

DeferredIterator.prototype.setDb = function (db) {
  var it = this._iterator = db.iterator(this._options)
  this._operations.forEach(function (op) {
    it[op.method].apply(it, op.args)
  })
}

DeferredIterator.prototype._operation = function (method, args) {
  if (this._iterator) return this._iterator[method].apply(this._iterator, args)
  this._operations.push({ method: method, args: args })
}

'next end'.split(' ').forEach(function (m) {
  DeferredIterator.prototype['_' + m] = function () {
    this._operation(m, arguments)
  }
})

// Must defer seek() rather than _seek() because it requires db._serializeKey to be available
DeferredIterator.prototype.seek = function () {
  this._operation('seek', arguments)
}

module.exports = DeferredIterator

      };
    };
  }
}, {package:"deferred-leveldown",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/deferred-leveldown/deferred-iterator.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/errno/errno.js", {"./custom":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/errno/custom.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/errno/errno.js
      return function (require, module, exports) {
var all = module.exports.all = [
  {
    errno: -2,
    code: 'ENOENT',
    description: 'no such file or directory'
  },
  {
    errno: -1,
    code: 'UNKNOWN',
    description: 'unknown error'
  },
  {
    errno: 0,
    code: 'OK',
    description: 'success'
  },
  {
    errno: 1,
    code: 'EOF',
    description: 'end of file'
  },
  {
    errno: 2,
    code: 'EADDRINFO',
    description: 'getaddrinfo error'
  },
  {
    errno: 3,
    code: 'EACCES',
    description: 'permission denied'
  },
  {
    errno: 4,
    code: 'EAGAIN',
    description: 'resource temporarily unavailable'
  },
  {
    errno: 5,
    code: 'EADDRINUSE',
    description: 'address already in use'
  },
  {
    errno: 6,
    code: 'EADDRNOTAVAIL',
    description: 'address not available'
  },
  {
    errno: 7,
    code: 'EAFNOSUPPORT',
    description: 'address family not supported'
  },
  {
    errno: 8,
    code: 'EALREADY',
    description: 'connection already in progress'
  },
  {
    errno: 9,
    code: 'EBADF',
    description: 'bad file descriptor'
  },
  {
    errno: 10,
    code: 'EBUSY',
    description: 'resource busy or locked'
  },
  {
    errno: 11,
    code: 'ECONNABORTED',
    description: 'software caused connection abort'
  },
  {
    errno: 12,
    code: 'ECONNREFUSED',
    description: 'connection refused'
  },
  {
    errno: 13,
    code: 'ECONNRESET',
    description: 'connection reset by peer'
  },
  {
    errno: 14,
    code: 'EDESTADDRREQ',
    description: 'destination address required'
  },
  {
    errno: 15,
    code: 'EFAULT',
    description: 'bad address in system call argument'
  },
  {
    errno: 16,
    code: 'EHOSTUNREACH',
    description: 'host is unreachable'
  },
  {
    errno: 17,
    code: 'EINTR',
    description: 'interrupted system call'
  },
  {
    errno: 18,
    code: 'EINVAL',
    description: 'invalid argument'
  },
  {
    errno: 19,
    code: 'EISCONN',
    description: 'socket is already connected'
  },
  {
    errno: 20,
    code: 'EMFILE',
    description: 'too many open files'
  },
  {
    errno: 21,
    code: 'EMSGSIZE',
    description: 'message too long'
  },
  {
    errno: 22,
    code: 'ENETDOWN',
    description: 'network is down'
  },
  {
    errno: 23,
    code: 'ENETUNREACH',
    description: 'network is unreachable'
  },
  {
    errno: 24,
    code: 'ENFILE',
    description: 'file table overflow'
  },
  {
    errno: 25,
    code: 'ENOBUFS',
    description: 'no buffer space available'
  },
  {
    errno: 26,
    code: 'ENOMEM',
    description: 'not enough memory'
  },
  {
    errno: 27,
    code: 'ENOTDIR',
    description: 'not a directory'
  },
  {
    errno: 28,
    code: 'EISDIR',
    description: 'illegal operation on a directory'
  },
  {
    errno: 29,
    code: 'ENONET',
    description: 'machine is not on the network'
  },
  {
    errno: 31,
    code: 'ENOTCONN',
    description: 'socket is not connected'
  },
  {
    errno: 32,
    code: 'ENOTSOCK',
    description: 'socket operation on non-socket'
  },
  {
    errno: 33,
    code: 'ENOTSUP',
    description: 'operation not supported on socket'
  },
  {
    errno: 34,
    code: 'ENOENT',
    description: 'no such file or directory'
  },
  {
    errno: 35,
    code: 'ENOSYS',
    description: 'function not implemented'
  },
  {
    errno: 36,
    code: 'EPIPE',
    description: 'broken pipe'
  },
  {
    errno: 37,
    code: 'EPROTO',
    description: 'protocol error'
  },
  {
    errno: 38,
    code: 'EPROTONOSUPPORT',
    description: 'protocol not supported'
  },
  {
    errno: 39,
    code: 'EPROTOTYPE',
    description: 'protocol wrong type for socket'
  },
  {
    errno: 40,
    code: 'ETIMEDOUT',
    description: 'connection timed out'
  },
  {
    errno: 41,
    code: 'ECHARSET',
    description: 'invalid Unicode character'
  },
  {
    errno: 42,
    code: 'EAIFAMNOSUPPORT',
    description: 'address family for hostname not supported'
  },
  {
    errno: 44,
    code: 'EAISERVICE',
    description: 'servname not supported for ai_socktype'
  },
  {
    errno: 45,
    code: 'EAISOCKTYPE',
    description: 'ai_socktype not supported'
  },
  {
    errno: 46,
    code: 'ESHUTDOWN',
    description: 'cannot send after transport endpoint shutdown'
  },
  {
    errno: 47,
    code: 'EEXIST',
    description: 'file already exists'
  },
  {
    errno: 48,
    code: 'ESRCH',
    description: 'no such process'
  },
  {
    errno: 49,
    code: 'ENAMETOOLONG',
    description: 'name too long'
  },
  {
    errno: 50,
    code: 'EPERM',
    description: 'operation not permitted'
  },
  {
    errno: 51,
    code: 'ELOOP',
    description: 'too many symbolic links encountered'
  },
  {
    errno: 52,
    code: 'EXDEV',
    description: 'cross-device link not permitted'
  },
  {
    errno: 53,
    code: 'ENOTEMPTY',
    description: 'directory not empty'
  },
  {
    errno: 54,
    code: 'ENOSPC',
    description: 'no space left on device'
  },
  {
    errno: 55,
    code: 'EIO',
    description: 'i/o error'
  },
  {
    errno: 56,
    code: 'EROFS',
    description: 'read-only file system'
  },
  {
    errno: 57,
    code: 'ENODEV',
    description: 'no such device'
  },
  {
    errno: 58,
    code: 'ESPIPE',
    description: 'invalid seek'
  },
  {
    errno: 59,
    code: 'ECANCELED',
    description: 'operation canceled'
  }
]

module.exports.errno = {}
module.exports.code = {}

all.forEach(function (error) {
  module.exports.errno[error.errno] = error
  module.exports.code[error.code] = error
})

module.exports.custom = require('./custom')(module.exports)
module.exports.create = module.exports.custom.createError

      };
    };
  }
}, {package:"errno",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/errno/errno.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/readable-browser.js", {"./lib/_stream_duplex.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_passthrough.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_passthrough.js","./lib/_stream_readable.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_transform.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_writable.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_writable.js","./lib/internal/streams/end-of-stream.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","./lib/internal/streams/pipeline.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/pipeline.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/readable-browser.js
      return function (require, module, exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/readable-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/queue.js", {"./DoublyLinkedList":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/DoublyLinkedList.js","./onlyOnce":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/onlyOnce.js","./setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/setImmediate.js","./wrapAsync":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/wrapAsync.js","lodash/_baseIndexOf":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/_baseIndexOf.js","lodash/isArray":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/isArray.js","lodash/noop":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/noop.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/queue.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = queue;

var _baseIndexOf = require('lodash/_baseIndexOf');

var _baseIndexOf2 = _interopRequireDefault(_baseIndexOf);

var _isArray = require('lodash/isArray');

var _isArray2 = _interopRequireDefault(_isArray);

var _noop = require('lodash/noop');

var _noop2 = _interopRequireDefault(_noop);

var _onlyOnce = require('./onlyOnce');

var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

var _setImmediate = require('./setImmediate');

var _setImmediate2 = _interopRequireDefault(_setImmediate);

var _DoublyLinkedList = require('./DoublyLinkedList');

var _DoublyLinkedList2 = _interopRequireDefault(_DoublyLinkedList);

var _wrapAsync = require('./wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function queue(worker, concurrency, payload) {
    if (concurrency == null) {
        concurrency = 1;
    } else if (concurrency === 0) {
        throw new Error('Concurrency must not be zero');
    }

    var _worker = (0, _wrapAsync2.default)(worker);
    var numRunning = 0;
    var workersList = [];

    var processingScheduled = false;
    function _insert(data, insertAtFront, callback) {
        if (callback != null && typeof callback !== 'function') {
            throw new Error('task callback must be a function');
        }
        q.started = true;
        if (!(0, _isArray2.default)(data)) {
            data = [data];
        }
        if (data.length === 0 && q.idle()) {
            // call drain immediately if there are no tasks
            return (0, _setImmediate2.default)(function () {
                q.drain();
            });
        }

        for (var i = 0, l = data.length; i < l; i++) {
            var item = {
                data: data[i],
                callback: callback || _noop2.default
            };

            if (insertAtFront) {
                q._tasks.unshift(item);
            } else {
                q._tasks.push(item);
            }
        }

        if (!processingScheduled) {
            processingScheduled = true;
            (0, _setImmediate2.default)(function () {
                processingScheduled = false;
                q.process();
            });
        }
    }

    function _next(tasks) {
        return function (err) {
            numRunning -= 1;

            for (var i = 0, l = tasks.length; i < l; i++) {
                var task = tasks[i];

                var index = (0, _baseIndexOf2.default)(workersList, task, 0);
                if (index === 0) {
                    workersList.shift();
                } else if (index > 0) {
                    workersList.splice(index, 1);
                }

                task.callback.apply(task, arguments);

                if (err != null) {
                    q.error(err, task.data);
                }
            }

            if (numRunning <= q.concurrency - q.buffer) {
                q.unsaturated();
            }

            if (q.idle()) {
                q.drain();
            }
            q.process();
        };
    }

    var isProcessing = false;
    var q = {
        _tasks: new _DoublyLinkedList2.default(),
        concurrency: concurrency,
        payload: payload,
        saturated: _noop2.default,
        unsaturated: _noop2.default,
        buffer: concurrency / 4,
        empty: _noop2.default,
        drain: _noop2.default,
        error: _noop2.default,
        started: false,
        paused: false,
        push: function (data, callback) {
            _insert(data, false, callback);
        },
        kill: function () {
            q.drain = _noop2.default;
            q._tasks.empty();
        },
        unshift: function (data, callback) {
            _insert(data, true, callback);
        },
        remove: function (testFn) {
            q._tasks.remove(testFn);
        },
        process: function () {
            // Avoid trying to start too many processing operations. This can occur
            // when callbacks resolve synchronously (#1267).
            if (isProcessing) {
                return;
            }
            isProcessing = true;
            while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
                var tasks = [],
                    data = [];
                var l = q._tasks.length;
                if (q.payload) l = Math.min(l, q.payload);
                for (var i = 0; i < l; i++) {
                    var node = q._tasks.shift();
                    tasks.push(node);
                    workersList.push(node);
                    data.push(node.data);
                }

                numRunning += 1;

                if (q._tasks.length === 0) {
                    q.empty();
                }

                if (numRunning === q.concurrency) {
                    q.saturated();
                }

                var cb = (0, _onlyOnce2.default)(_next(tasks));
                _worker(data, cb);
            }
            isProcessing = false;
        },
        length: function () {
            return q._tasks.length;
        },
        running: function () {
            return numRunning;
        },
        workersList: function () {
            return workersList;
        },
        idle: function () {
            return q._tasks.length + numRunning === 0;
        },
        pause: function () {
            q.paused = true;
        },
        resume: function () {
            if (q.paused === false) {
                return;
            }
            q.paused = false;
            (0, _setImmediate2.default)(q.process);
        }
    };
    return q;
}
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/queue.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/keytransform.js", {"pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/keytransform.js
      return function (require, module, exports) {
/* @flow */
'use strict'

const pull = require('pull-stream')

/* ::
import type {Key, Datastore, Batch, Query, QueryResult, Callback} from 'interface-datastore'
*/

/**
 * An object with a pair of functions for (invertibly) transforming keys
 */
/* ::
type KeyTransform = {
  convert: KeyMapping,
  invert: KeyMapping
}
*/

/**
 * Map one key onto another key.
 */
/* ::
type KeyMapping = (Key) => Key
*/

/**
 * A datastore shim, that wraps around a given datastore, changing
 * the way keys look to the user, for example namespacing
 * keys, reversing them, etc.
 */
class KeyTransformDatastore /* :: <Value> */ {
  /* :: child: Datastore<Value> */
  /* :: transform: KeyTransform */

  constructor (child /* : Datastore<Value> */, transform /* : KeyTransform */) {
    this.child = child
    this.transform = transform
  }

  open (callback /* : Callback<void> */) /* : void */ {
    this.child.open(callback)
  }

  put (key /* : Key */, val /* : Value */, callback /* : Callback<void> */) /* : void */ {
    this.child.put(this.transform.convert(key), val, callback)
  }

  get (key /* : Key */, callback /* : Callback<Value> */) /* : void */ {
    this.child.get(this.transform.convert(key), callback)
  }

  has (key /* : Key */, callback /* : Callback<bool> */) /* : void */ {
    this.child.has(this.transform.convert(key), callback)
  }

  delete (key /* : Key */, callback /* : Callback<void> */) /* : void */ {
    this.child.delete(this.transform.convert(key), callback)
  }

  batch () /* : Batch<Value> */ {
    const b = this.child.batch()
    return {
      put: (key /* : Key */, value /* : Value */) /* : void */ => {
        b.put(this.transform.convert(key), value)
      },
      delete: (key /* : Key */) /* : void */ => {
        b.delete(this.transform.convert(key))
      },
      commit: (callback /* : Callback<void> */) /* : void */ => {
        b.commit(callback)
      }
    }
  }

  query (q /* : Query<Value> */) /* : QueryResult<Value> */ {
    return pull(
      this.child.query(q),
      pull.map(e => {
        e.key = this.transform.invert(e.key)
        return e
      })
    )
  }

  close (callback /* : Callback<void> */) /* : void */ {
    this.child.close(callback)
  }
}

module.exports = KeyTransformDatastore

      };
    };
  }
}, {package:"datastore-core",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/keytransform.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/namespace.js", {"./keytransform":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/keytransform.js","interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/namespace.js
      return function (require, module, exports) {
/* @flow */
'use strict'

const Key = require('interface-datastore').Key
const KeytransformDatastore = require('./keytransform')

/* ::
import type {Callback, Datastore, Query, QueryResult} from 'interface-datastore'
*/

/**
 * Wraps a given datastore into a keytransform which
 * makes a given prefix transparent.
 *
 * For example, if the prefix is `new Key(/hello)` a call
 * to `store.put(new Key('/world'), mydata)` would store the data under
 * `/hello/world`.
 *
 */
class NamespaceDatastore/* :: <Value> */ extends KeytransformDatastore /* :: <Value> */ {
  /* :: prefix: Key */

  constructor (child/* : Datastore<Value> */, prefix/* : Key */) {
    super(child, {
      convert (key/* : Key */)/* : Key */ {
        return prefix.child(key)
      },
      invert (key/* : Key */)/* : Key */ {
        if (prefix.toString() === '/') {
          return key
        }

        if (!prefix.isAncestorOf(key)) {
          throw new Error(`Expected prefix: (${prefix.toString()}) in key: ${key.toString()}`)
        }

        return new Key(key.toString().slice(prefix.toString().length), false)
      }
    })

    this.prefix = prefix
  }

  query (q /* : Query<Value> */)/* : QueryResult<Value> */ {
    if (q.prefix && this.prefix.toString() !== '/') {
      return super.query(Object.assign({}, q, {
        prefix: this.prefix.child(new Key(q.prefix)).toString()
      }))
    }
    return super.query(q)
  }
}

module.exports = NamespaceDatastore

      };
    };
  }
}, {package:"datastore-core",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/namespace.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/shard.js", {"./shard-readme":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/shard-readme.js","interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/shard.js
      return function (require, module, exports) {
/* @flow */
'use strict'

const Key = require('interface-datastore').Key

const readme = require('./shard-readme')

// eslint-disable-next-line
/*:: import type {Datastore, Callback} from 'interface-datastore'

export interface ShardV1 {
  name: string;
  param: number;
  fun(string): string;
  toString(): string;
}
*/

const PREFIX = exports.PREFIX = '/repo/flatfs/shard/'
const SHARDING_FN = exports.SHARDING_FN = 'SHARDING'
exports.README_FN = '_README'

class Shard {
  /* :: name: string */
  /* :: param: number */
  /* :: _padding: string */

  constructor (param /* : number */) {
    this.param = param
  }

  fun (str /* : string */) /* : string */ {
    throw new Error('implement me')
  }

  toString () /* : string */ {
    return `${PREFIX}v1/${this.name}/${this.param}`
  }
}

class Prefix extends Shard {
  constructor (prefixLen /* : number */) {
    super(prefixLen)
    this._padding = ''.padStart(prefixLen, '_')
    this.name = 'prefix'
  }

  fun (noslash /* : string */) /* : string */ {
    return (noslash + this._padding).slice(0, this.param)
  }
}

class Suffix extends Shard {
  constructor (suffixLen /* : number */) {
    super(suffixLen)
    this._padding = ''.padStart(suffixLen, '_')
    this.name = 'suffix'
  }

  fun (noslash /* : string */) /* : string */ {
    const s = this._padding + noslash
    return s.slice(s.length - this.param)
  }
}

class NextToLast extends Shard {
  constructor (suffixLen /* : number */) {
    super(suffixLen)
    this._padding = ''.padStart(suffixLen + 1, '_')
    this.name = 'next-to-last'
  }

  fun (noslash /* : string */) /* : string */ {
    const s = this._padding + noslash
    const offset = s.length - this.param - 1
    return s.slice(offset, offset + this.param)
  }
}

/**
 * Convert a given string to the matching sharding function.
 *
 * @param {string} str
 * @returns {ShardV1}
 */
function parseShardFun (str /* : string */) /* : ShardV1 */ {
  str = str.trim()

  if (str.length === 0) {
    throw new Error('empty shard string')
  }

  if (!str.startsWith(PREFIX)) {
    throw new Error(`invalid or no path prefix: ${str}`)
  }

  const parts = str.slice(PREFIX.length).split('/')
  const version = parts[0]

  if (version !== 'v1') {
    throw new Error(`expect 'v1' version, got '${version}'`)
  }

  const name = parts[1]

  if (!parts[2]) {
    throw new Error('missing param')
  }

  const param = parseInt(parts[2], 10)

  switch (name) {
    case 'prefix':
      return new Prefix(param)
    case 'suffix':
      return new Suffix(param)
    case 'next-to-last':
      return new NextToLast(param)
    default:
      throw new Error(`unkown sharding function: ${name}`)
  }
}

exports.readShardFun = (path /* : string */, store /* : Datastore<Buffer> */, callback /* : Callback<ShardV1> */) /* : void */ => {
  const key = new Key(path).child(new Key(SHARDING_FN))
  const get = typeof store.getRaw === 'function' ? store.getRaw.bind(store) : store.get.bind(store)

  get(key, (err, res) => {
    if (err) {
      return callback(err)
    }

    let shard
    try {
      shard = parseShardFun((res || '').toString().trim())
    } catch (err) {
      return callback(err)
    }

    callback(null, shard)
  })
}

exports.readme = readme
exports.parseShardFun = parseShardFun
exports.Prefix = Prefix
exports.Suffix = Suffix
exports.NextToLast = NextToLast

      };
    };
  }
}, {package:"datastore-core",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/shard.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/sharding.js", {"./keytransform":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/keytransform.js","./shard":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/shard.js","async/parallel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/parallel.js","async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/sharding.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/* @flow */
'use strict'

const waterfall = require('async/waterfall')
const parallel = require('async/parallel')
const Key = require('interface-datastore').Key

const sh = require('./shard')
const KeytransformStore = require('./keytransform')

const shardKey = new Key(sh.SHARDING_FN)
const shardReadmeKey = new Key(sh.README_FN)

/* ::
import type {Datastore, Batch, Query, QueryResult, Callback} from 'interface-datastore'

import type {ShardV1} from './shard'
*/

/**
 * Backend independent abstraction of go-ds-flatfs.
 *
 * Wraps another datastore such that all values are stored
 * sharded according to the given sharding function.
 */
class ShardingDatastore {
  /* :: shard: ShardV1 */
  /* :: child: Datastore<Buffer> */

  constructor (store /* : Datastore<Buffer> */, shard /* : ShardV1 */) {
    this.child = new KeytransformStore(store, {
      convert: this._convertKey.bind(this),
      invert: this._invertKey.bind(this)
    })
    this.shard = shard
  }

  open (callback /* : Callback<void> */) /* : void */ {
    this.child.open(callback)
  }

  _convertKey (key/* : Key */)/* : Key */ {
    const s = key.toString()
    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {
      return key
    }

    const parent = new Key(this.shard.fun(s))
    return parent.child(key)
  }

  _invertKey (key/* : Key */)/* : Key */ {
    const s = key.toString()
    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {
      return key
    }
    return Key.withNamespaces(key.list().slice(1))
  }

  static createOrOpen (store /* : Datastore<Buffer> */, shard /* : ShardV1 */, callback /* : Callback<ShardingDatastore> */) /* : void */ {
    ShardingDatastore.create(store, shard, err => {
      if (err && err.message !== 'datastore exists') {
        return callback(err)
      }

      ShardingDatastore.open(store, callback)
    })
  }

  static open (store /* : Datastore<Buffer> */, callback /* : Callback<ShardingDatastore> */) /* : void */ {
    waterfall([
      (cb) => sh.readShardFun('/', store, cb),
      (shard, cb) => {
        cb(null, new ShardingDatastore(store, shard))
      }
    ], callback)
  }

  static create (store /* : Datastore<Buffer> */, shard /* : ShardV1 */, callback /* : Callback<void> */) /* : void */ {
    store.has(shardKey, (err, exists) => {
      if (err) {
        return callback(err)
      }

      if (!exists) {
        const put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store)
        return parallel([
          (cb) => put(shardKey, Buffer.from(shard.toString() + '\n'), cb),
          (cb) => put(shardReadmeKey, Buffer.from(sh.readme), cb)
        ], err => callback(err))
      }

      sh.readShardFun('/', store, (err, diskShard) => {
        if (err) {
          return callback(err)
        }

        const a = (diskShard || '').toString()
        const b = shard.toString()
        if (a !== b) {
          return callback(new Error(`specified fun ${b} does not match repo shard fun ${a}`))
        }

        callback(new Error('datastore exists'))
      })
    })
  }

  put (key /* : Key */, val /* : Buffer */, callback /* : Callback<void> */) /* : void */ {
    this.child.put(key, val, callback)
  }

  get (key /* : Key */, callback /* : Callback<Buffer> */) /* : void */ {
    this.child.get(key, callback)
  }

  has (key /* : Key */, callback /* : Callback<bool> */) /* : void */ {
    this.child.has(key, callback)
  }

  delete (key /* : Key */, callback /* : Callback<void> */) /* : void */ {
    this.child.delete(key, callback)
  }

  batch () /* : Batch<Buffer> */ {
    return this.child.batch()
  }

  query (q /* : Query<Buffer> */) /* : QueryResult<Buffer> */ {
    const tq/* : Query<Buffer> */ = {
      keysOnly: q.keysOnly,
      offset: q.offset,
      limit: q.limit,
      filters: [
        (e, cb) => cb(null, e.key.toString() !== shardKey.toString()),
        (e, cb) => cb(null, e.key.toString() !== shardReadmeKey.toString())
      ]
    }

    if (q.prefix != null) {
      tq.filters.push((e, cb) => {
        cb(null, this._invertKey(e.key).toString().startsWith(q.prefix))
      })
    }

    if (q.filters != null) {
      const filters = q.filters.map((f) => (e, cb) => {
        f(Object.assign({}, e, {
          key: this._invertKey(e.key)
        }), cb)
      })
      tq.filters = tq.filters.concat(filters)
    }

    if (q.orders != null) {
      tq.orders = q.orders.map((o) => (res, cb) => {
        res.forEach((e) => { e.key = this._invertKey(e.key) })
        o(res, (err, ordered) => {
          if (err) {
            return cb(err)
          }
          ordered.forEach((e) => { e.key = this._convertKey(e.key) })
          cb(null, ordered)
        })
      })
    }

    return this.child.query(tq)
  }

  close (callback /* : Callback<void> */) /* : void */ {
    this.child.close(callback)
  }
}

module.exports = ShardingDatastore

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"datastore-core",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/sharding.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/mount.js", {"./keytransform":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/keytransform.js","async/each":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/each.js","interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js","pull-many":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-many/index.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/mount.js
      return function (require, module, exports) {
/* @flow */
'use strict'

const each = require('async/each')
const many = require('pull-many')
const pull = require('pull-stream')

const Key = require('interface-datastore').Key
const Errors = require('interface-datastore').Errors
const utils = require('interface-datastore').utils
const asyncFilter = utils.asyncFilter
const asyncSort = utils.asyncSort
const replaceStartWith = utils.replaceStartWith

const Keytransform = require('./keytransform')

/* ::
import type {Datastore, Callback, Batch, Query, QueryResult} from 'interface-datastore'

type Mount<Value> = {
  prefix: Key,
  datastore: Datastore<Value>
}
*/

/**
 * A datastore that can combine multiple stores inside various
 * key prefixs.
 */
class MountDatastore /* :: <Value> */ {
  /* :: mounts: Array<Mount<Value>> */

  constructor (mounts /* : Array<Mount<Value>> */) {
    this.mounts = mounts.slice()
  }

  open (callback /* : Callback<void> */) /* : void */ {
    each(this.mounts, (m, cb) => {
      m.datastore.open(cb)
    }, callback)
  }

  /**
   * Lookup the matching datastore for the given key.
   *
   * @private
   * @param {Key} key
   * @returns {{Datastore, Key, Key}}
   */
  _lookup (key /* : Key */) /* : ?{datastore: Datastore<Value>, mountpoint: Key, rest: Key} */ {
    for (let mount of this.mounts) {
      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {
        const s = replaceStartWith(key.toString(), mount.prefix.toString())
        return {
          datastore: mount.datastore,
          mountpoint: mount.prefix,
          rest: new Key(s)
        }
      }
    }
  }

  put (key /* : Key */, value /* : Value */, callback /* : Callback<void> */) /* : void */ {
    const match = this._lookup(key)
    if (match == null) {
      return callback(
        Errors.dbWriteFailedError(new Error('No datastore mounted for this key'))
      )
    }

    match.datastore.put(match.rest, value, callback)
  }

  get (key /* : Key */, callback /* : Callback<Value> */) /* : void */ {
    const match = this._lookup(key)
    if (match == null) {
      return callback(
        Errors.notFoundError(new Error('No datastore mounted for this key'))
      )
    }

    match.datastore.get(match.rest, callback)
  }

  has (key /* : Key */, callback /* : Callback<bool> */) /* : void */ {
    const match = this._lookup(key)
    if (match == null) {
      callback(null, false)
      return
    }

    match.datastore.has(match.rest, callback)
  }

  delete (key /* : Key */, callback /* : Callback<void> */) /* : void */ {
    const match = this._lookup(key)
    if (match == null) {
      return callback(
        Errors.dbDeleteFailedError(new Error('No datastore mounted for this key'))
      )
    }

    match.datastore.delete(match.rest, callback)
  }

  close (callback /* : Callback<void> */) /* : void */ {
    each(this.mounts, (m, cb) => {
      m.datastore.close(cb)
    }, callback)
  }

  batch () /* : Batch<Value> */ {
    const batchMounts = {}
    const lookup = (key /* : Key */) /* : {batch: Batch<Value>, rest: Key} */ => {
      const match = this._lookup(key)
      if (match == null) {
        throw new Error('No datastore mounted for this key')
      }

      const m = match.mountpoint.toString()
      if (batchMounts[m] == null) {
        batchMounts[m] = match.datastore.batch()
      }

      return {
        batch: batchMounts[m],
        rest: match.rest
      }
    }

    return {
      put: (key /* : Key */, value /* : Value */) /* : void */ => {
        const match = lookup(key)
        match.batch.put(match.rest, value)
      },
      delete: (key /* : Key */) /* : void */ => {
        const match = lookup(key)
        match.batch.delete(match.rest)
      },
      commit: (callback /* : Callback<void> */) /* : void */ => {
        each(Object.keys(batchMounts), (p, cb) => {
          batchMounts[p].commit(cb)
        }, callback)
      }
    }
  }

  query (q /* : Query<Value> */) /* : QueryResult<Value> */ {
    const qs = this.mounts.map(m => {
      const ks = new Keytransform(m.datastore, {
        convert: (key /* : Key */) /* : Key */ => {
          throw new Error('should never be called')
        },
        invert: (key /* : Key */) /* : Key */ => {
          return m.prefix.child(key)
        }
      })

      let prefix
      if (q.prefix != null) {
        prefix = replaceStartWith(q.prefix, m.prefix.toString())
      }

      return ks.query({
        prefix: prefix,
        filters: q.filters,
        keysOnly: q.keysOnly
      })
    })

    let tasks = [many(qs)]

    if (q.filters != null) {
      tasks = tasks.concat(q.filters.map(f => asyncFilter(f)))
    }

    if (q.orders != null) {
      tasks = tasks.concat(q.orders.map(o => asyncSort(o)))
    }

    if (q.offset != null) {
      let i = 0
      tasks.push(pull.filter(() => i++ >= q.offset))
    }

    if (q.limit != null) {
      tasks.push(pull.take(q.limit))
    }

    return pull.apply(null, tasks)
  }
}

module.exports = MountDatastore

      };
    };
  }
}, {package:"datastore-core",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/mount.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/tiered.js", {"async/each":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/each.js","async/whilst":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/whilst.js","interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/tiered.js
      return function (require, module, exports) {
/* @flow */
'use strict'

const each = require('async/each')
const whilst = require('async/whilst')
const Errors = require('interface-datastore').Errors

/* ::
import type {Key, Datastore, Callback, Batch, Query, QueryResult} from 'interface-datastore'
*/

/**
 * A datastore that can combine multiple stores. Puts and deletes
 * will write through to all datastores. Has and get will
 * try each store sequentially. Query will always try the
 * last one first.
 *
 */
class TieredDatastore /* :: <Value> */ {
  /* :: stores: Array<Datastore<Value>> */

  constructor (stores /* : Array<Datastore<Value>> */) {
    this.stores = stores.slice()
  }

  open (callback /* : Callback<void> */) /* : void */ {
    each(this.stores, (store, cb) => {
      store.open(cb)
    }, (err) => {
      if (err) {
        return callback(Errors.dbOpenFailedError())
      }
      callback()
    })
  }

  put (key /* : Key */, value /* : Value */, callback /* : Callback<void> */) /* : void */ {
    each(this.stores, (store, cb) => {
      store.put(key, value, cb)
    }, (err) => {
      if (err) {
        return callback(Errors.dbWriteFailedError())
      }
      callback()
    })
  }

  get (key /* : Key */, callback /* : Callback<Value> */) /* : void */ {
    const storeLength = this.stores.length
    let done = false
    let i = 0
    whilst(() => !done && i < storeLength, cb => {
      const store = this.stores[i++]
      store.get(key, (err, res) => {
        if (err == null) {
          done = true
          return cb(null, res)
        }
        cb()
      })
    }, (err, res) => {
      if (err || !res) {
        return callback(Errors.notFoundError())
      }
      callback(null, res)
    })
  }

  has (key /* : Key */, callback /* : Callback<bool> */) /* : void */ {
    const storeLength = this.stores.length
    let done = false
    let i = 0
    whilst(() => !done && i < storeLength, cb => {
      const store = this.stores[i++]
      store.has(key, (err, exists) => {
        if (err == null) {
          done = true
          return cb(null, exists)
        }
        cb()
      })
    }, callback)
  }

  delete (key /* : Key */, callback /* : Callback<void> */) /* : void */ {
    each(this.stores, (store, cb) => {
      store.delete(key, cb)
    }, (err) => {
      if (err) {
        return callback(Errors.dbDeleteFailedError())
      }
      callback()
    })
  }

  close (callback /* : Callback<void> */) /* : void */ {
    each(this.stores, (store, cb) => {
      store.close(cb)
    }, callback)
  }

  batch () /* : Batch<Value> */ {
    const batches = this.stores.map(store => store.batch())

    return {
      put: (key /* : Key */, value /* : Value */) /* : void */ => {
        batches.forEach(b => b.put(key, value))
      },
      delete: (key /* : Key */) /* : void */ => {
        batches.forEach(b => b.delete(key))
      },
      commit: (callback /* : Callback<void> */) /* : void */ => {
        each(batches, (b, cb) => {
          b.commit(cb)
        }, callback)
      }
    }
  }

  query (q /* : Query<Value> */) /* : QueryResult<Value> */ {
    return this.stores[this.stores.length - 1].query(q)
  }
}

module.exports = TieredDatastore

      };
    };
  }
}, {package:"datastore-core",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/tiered.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/reject.js", {"./filter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/filter.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/reject.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = reject;

var _filter = require('./filter');

var _filter2 = _interopRequireDefault(_filter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function reject(eachfn, arr, iteratee, callback) {
    (0, _filter2.default)(eachfn, arr, function (value, cb) {
        iteratee(value, function (err, v) {
            cb(err, !v);
        });
    }, callback);
}
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/reject.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/encoding-down/index.js", {"abstract-leveldown":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/index.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","level-codec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-codec/index.js","level-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-errors/errors.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/encoding-down/index.js
      return function (require, module, exports) {
'use strict'

var AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN
var AbstractChainedBatch = require('abstract-leveldown').AbstractChainedBatch
var AbstractIterator = require('abstract-leveldown').AbstractIterator
var inherits = require('inherits')
var Codec = require('level-codec')
var EncodingError = require('level-errors').EncodingError

module.exports = DB.default = DB

function DB (db, opts) {
  if (!(this instanceof DB)) return new DB(db, opts)
  AbstractLevelDOWN.call(this, '')

  opts = opts || {}
  if (typeof opts.keyEncoding === 'undefined') opts.keyEncoding = 'utf8'
  if (typeof opts.valueEncoding === 'undefined') opts.valueEncoding = 'utf8'

  this.db = db
  this.codec = new Codec(opts)
}

inherits(DB, AbstractLevelDOWN)

DB.prototype._serializeKey =
DB.prototype._serializeValue = function (datum) {
  return datum
}

DB.prototype._open = function (opts, cb) {
  this.db.open(opts, cb)
}

DB.prototype._close = function (cb) {
  this.db.close(cb)
}

DB.prototype._put = function (key, value, opts, cb) {
  key = this.codec.encodeKey(key, opts)
  value = this.codec.encodeValue(value, opts)
  this.db.put(key, value, opts, cb)
}

DB.prototype._get = function (key, opts, cb) {
  var self = this
  key = this.codec.encodeKey(key, opts)
  opts.asBuffer = this.codec.valueAsBuffer(opts)
  this.db.get(key, opts, function (err, value) {
    if (err) return cb(err)
    try {
      value = self.codec.decodeValue(value, opts)
    } catch (err) {
      return cb(new EncodingError(err))
    }
    cb(null, value)
  })
}

DB.prototype._del = function (key, opts, cb) {
  key = this.codec.encodeKey(key, opts)
  this.db.del(key, opts, cb)
}

DB.prototype._chainedBatch = function () {
  return new Batch(this)
}

DB.prototype._batch = function (ops, opts, cb) {
  ops = this.codec.encodeBatch(ops, opts)
  this.db.batch(ops, opts, cb)
}

DB.prototype._iterator = function (opts) {
  opts.keyAsBuffer = this.codec.keyAsBuffer(opts)
  opts.valueAsBuffer = this.codec.valueAsBuffer(opts)
  return new Iterator(this, opts)
}

DB.prototype.approximateSize = function (start, end, opts, cb) {
  start = this.codec.encodeKey(start, opts)
  end = this.codec.encodeKey(end, opts)
  return this.db.approximateSize(start, end, opts, cb)
}

function Iterator (db, opts) {
  AbstractIterator.call(this, db)
  this.codec = db.codec
  this.keys = opts.keys
  this.values = opts.values
  this.opts = this.codec.encodeLtgt(opts)
  this.it = db.db.iterator(this.opts)
}

inherits(Iterator, AbstractIterator)

Iterator.prototype._next = function (cb) {
  var self = this
  this.it.next(function (err, key, value) {
    if (err) return cb(err)
    try {
      if (self.keys && typeof key !== 'undefined') {
        key = self.codec.decodeKey(key, self.opts)
      } else {
        key = undefined
      }

      if (self.values && typeof value !== 'undefined') {
        value = self.codec.decodeValue(value, self.opts)
      } else {
        value = undefined
      }
    } catch (err) {
      return cb(new EncodingError(err))
    }
    cb(null, key, value)
  })
}

Iterator.prototype._seek = function (key) {
  key = this.codec.encodeKey(key, this.opts)
  this.it.seek(key)
}

Iterator.prototype._end = function (cb) {
  this.it.end(cb)
}

function Batch (db, codec) {
  AbstractChainedBatch.call(this, db)
  this.codec = db.codec
  this.batch = db.db.batch()
}

inherits(Batch, AbstractChainedBatch)

Batch.prototype._put = function (key, value) {
  key = this.codec.encodeKey(key)
  value = this.codec.encodeValue(value)
  this.batch.put(key, value)
}

Batch.prototype._del = function (key) {
  key = this.codec.encodeKey(key)
  this.batch.del(key)
}

Batch.prototype._clear = function () {
  this.batch.clear()
}

Batch.prototype._write = function (opts, cb) {
  this.batch.write(opts, cb)
}

      };
    };
  }
}, {package:"encoding-down",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/encoding-down/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/index.js", {"./iterator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/iterator.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","abstract-leveldown":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/util/util.js","xtend":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/xtend/immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/index.js
      return function (require, module, exports) {
(function (process,Buffer){(function (){
module.exports = Level

var AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN
var util = require('util')
var Iterator = require('./iterator')
var xtend = require('xtend')

function Level(location) {
  if (!(this instanceof Level)) return new Level(location)

  AbstractLevelDOWN.call(this, location)
}

util.inherits(Level, AbstractLevelDOWN)

/**
 * Open a database and optionally create if missing.
 *
 * @param {Object} [options]  storeName and other options passed to indexedDB
 *                            open and createObjectStore.
 * @param {Function} callback  First parameter will be an error object or null.
 */
Level.prototype._open = function(options, callback) {
  var self = this

  // assume createIfMissing and errorIfExists are initialized by abstract-leveldown
  this._idbOpts = xtend({
    storeName: this.location,
    keyEncoding: 'none',
    valueEncoding: 'none'
  }, options)

  // support passing an open database
  if (this._idbOpts.idb) {
    onsuccess(this._idbOpts.idb)
  } else {
    var req = indexedDB.open(this.location) // use the databases current version
    req.onerror = onerror
    req.onsuccess = function() {
      onsuccess(req.result)
    }
  }

  function onerror(ev) {
    callback(ev.target.error)
  }

  // if the store does not exist and createIfMissing is true, create the object store
  function onsuccess(db) {
    self._db = db

    var exists = self._db.objectStoreNames.contains(self._idbOpts.storeName)

    if (options.errorIfExists && exists) {
      self._db.close()
      callback(new Error('store already exists'))
      return
    }

    if (!options.createIfMissing && !exists) {
      self._db.close()
      callback(new Error('store does not exist'))
      return
    }

    if (options.createIfMissing && !exists) {
      self._db.close()

      var req2 = indexedDB.open(self.location, self._db.version + 1)

      req2.onerror = function(ev) {
        callback(ev.target.error)
      }

      req2.onupgradeneeded = function() {
        var db = req2.result
        db.createObjectStore(self._idbOpts.storeName, self._idbOpts)
      }

      req2.onsuccess = function() {
        self._db = req2.result
        callback(null, self)
      }

      return
    }

    callback(null, self)
  }
}

Level.prototype._get = function(key, options, callback) {
  options = xtend(this._idbOpts, options)

  var origKey = key

  // support binary keys for any iterable type via array (ArrayBuffers as keys are only supported in IndexedDB Second Edition)
  if (options.keyEncoding === 'binary' && !Array.isArray(key)) key = Array.prototype.slice.call(key)

  var tx = this._db.transaction(this._idbOpts.storeName)
  var req = tx.objectStore(this._idbOpts.storeName).openCursor(IDBKeyRange.only(key))

  tx.onabort = function() {
    callback(tx.error)
  }

  req.onsuccess = function() {
    var cursor = req.result
    if (cursor) {
      var value = cursor.value

      // automatically convert Uint8Array values to Buffer
      if (value instanceof Uint8Array) value = new Buffer(value)
      if (options.valueEncoding === 'binary' && !Buffer.isBuffer(value)) value = new Buffer(value)

      if (options.asBuffer && !Buffer.isBuffer(value)) {
        if (value == null)                     value = new Buffer(0)
        else if (typeof value === 'string')    value = new Buffer(value) // defaults to utf8, should the encoding be utf16? (DOMString)
        else if (typeof value === 'boolean')   value = new Buffer(String(value)) // compatible with leveldb
        else if (typeof value === 'number')    value = new Buffer(String(value)) // compatible with leveldb
        else if (Array.isArray(value))         value = new Buffer(String(value)) // compatible with leveldb
        else if (value instanceof Uint8Array)  value = new Buffer(value)
        else return void callback(new TypeError('can\'t coerce `' + value.constructor.name + '` into a Buffer'))
      }
      return void callback(null, value, origKey)
    } else {
      // 'NotFound' error, consistent with LevelDOWN API
      return void callback(new Error('NotFound'))
    }
  }
}

Level.prototype._del = function(key, options, callback) {
  options = xtend(this._idbOpts, options)

  // support binary keys for any iterable type via array (ArrayBuffers as keys are only supported in IndexedDB Second Edition)
  if (options.keyEncoding === 'binary' && !Array.isArray(key)) key = Array.prototype.slice.call(key)

  var mode = 'readwrite'
  if (options.sync === true) {
    mode = 'readwriteflush' // only supported in Firefox (with "dom.indexedDB.experimental" pref set to true)
  }
  var tx = this._db.transaction(this._idbOpts.storeName, mode)
  var req = tx.objectStore(this._idbOpts.storeName).delete(key)

  tx.onabort = function() {
    callback(tx.error)
  }

  tx.oncomplete = function() {
    callback()
  }
}

Level.prototype._put = function(key, value, options, callback) {
  options = xtend(this._idbOpts, options)

  // support binary keys for any iterable type via array (ArrayBuffers as keys are only supported in IndexedDB Second Edition)
  if (options.keyEncoding === 'binary' && !Array.isArray(key)) key = Array.prototype.slice.call(key)

  var mode = 'readwrite'
  if (options.sync === true) {
    mode = 'readwriteflush' // only supported in Firefox (with "dom.indexedDB.experimental" pref set to true)
  }
  var tx = this._db.transaction(this._idbOpts.storeName, mode)
  var req = tx.objectStore(this._idbOpts.storeName).put(value, key)

  tx.onabort = function() {
    callback(tx.error)
  }

  tx.oncomplete = function() {
    callback()
  }
}

Level.prototype._iterator = function(options) {
  return new Iterator(this, options)
}

// only support sync: true on batch level, not operation level
Level.prototype._batch = function(array, options, callback) {
  if (array.length === 0) return process.nextTick(callback)

  var mode = 'readwrite'
  if (options.sync === true) {
    mode = 'readwriteflush' // only supported in Firefox (with "dom.indexedDB.experimental" pref set to true)
  }
  var tx = this._db.transaction(this._idbOpts.storeName, mode)
  var store = tx.objectStore(this._idbOpts.storeName)

  tx.onabort = function() {
    callback(tx.error)
  }

  tx.oncomplete = function() {
    callback()
  }

  array.forEach(function(currentOp) {
    var opts = xtend(options, currentOp)

    // support binary keys for any iterable type via array (ArrayBuffers as keys are only supported in IndexedDB Second Edition)
    if (opts.keyEncoding === 'binary' && !Array.isArray(currentOp.key)) currentOp.key = Array.prototype.slice.call(currentOp.key)

    if (currentOp.type === 'del') {
      store.delete(currentOp.key)
    } else {
      store.put(currentOp.value, currentOp.key)
    }
  })
}

Level.prototype._close = function (callback) {
  this._db.close()
  process.nextTick(callback)
}

Level.prototype._approximateSize = function (start, end, callback) {
  var err = new Error('Not implemented')
  if (callback)
    return void process.nextTick(function() {
      callback(err)
    })

  throw err
}

/**
 * Destroy the object store and the database if no other object stores exist.
 *
 * @param {String|Object} location  Name of the database or a database instance.
 */
Level.destroy = function(db, callback) {
  var idbOpts
  if (db != null && typeof db === 'object') {
    idbOpts = xtend({
      location: db.location,
      storeName: db.location
    }, db._idbOpts)
  } else if (typeof db === 'string') {
    idbOpts = {
      location: db,
      storeName: db
    }
  } else {
    throw new TypeError('location must be a string or an object')
  }

  if (typeof idbOpts.location !== 'string') throw new TypeError('location must be a string')
  if (typeof idbOpts.storeName !== 'string') throw new TypeError('db.storeName must be a string')

  var req = indexedDB.open(idbOpts.location) // use the databases current version

  req.onerror = function(ev) {
    callback(ev.target.error)
  }

  // if the database contains no other stores, delete the database as well
  req.onsuccess = function() {
    var db = req.result

    function deleteDatabase(name) {
      var req2 = indexedDB.deleteDatabase(name)
      req2.onerror = function(ev) {
        callback(ev.target.error)
      }
      req2.onsuccess = function() {
        callback()
      }
    }

    db.close()

    if (db.objectStoreNames.length === 0) return void deleteDatabase(idbOpts.location)
    if (!db.objectStoreNames.contains(idbOpts.storeName)) return void callback()

    // delete object store, and if no object stores remain, delete database
    var req2 = indexedDB.open(idbOpts.location, db.version + 1)

    req2.onerror = function(ev) {
      callback(ev.target.error)
    }

    req2.onupgradeneeded = function() {
      db = req2.result
      db.deleteObjectStore(idbOpts.storeName)
    }

    req2.onsuccess = function() {
      db = req2.result
      db.close()

      if (db.objectStoreNames.length === 0) deleteDatabase(idbOpts.location)
      else callback()
    }
  }
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

      };
    };
  }
}, {package:"level-js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/levelup/lib/levelup.js", {"./batch":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/levelup/lib/batch.js","./common":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/levelup/lib/common.js","./promisify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/levelup/lib/promisify.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","deferred-leveldown":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/deferred-leveldown/deferred-leveldown.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","level-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-errors/errors.js","level-iterator-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-iterator-stream/index.js","util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/util/util.js","xtend":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/xtend/immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/levelup/lib/levelup.js
      return function (require, module, exports) {
(function (process){(function (){
var EventEmitter = require('events').EventEmitter
var inherits = require('util').inherits
var extend = require('xtend')
var DeferredLevelDOWN = require('deferred-leveldown')
var IteratorStream = require('level-iterator-stream')
var Batch = require('./batch')
var errors = require('level-errors')
var assert = require('assert')
var promisify = require('./promisify')
var getCallback = require('./common').getCallback
var getOptions = require('./common').getOptions

var WriteError = errors.WriteError
var ReadError = errors.ReadError
var NotFoundError = errors.NotFoundError
var OpenError = errors.OpenError
var InitializationError = errors.InitializationError

// Possible AbstractLevelDOWN#status values:
//  - 'new'     - newly created, not opened or closed
//  - 'opening' - waiting for the database to be opened, post open()
//  - 'open'    - successfully opened the database, available for use
//  - 'closing' - waiting for the database to be closed, post close()
//  - 'closed'  - database has been successfully closed, should not be
//                 used except for another open() operation

function LevelUP (db, options, callback) {
  if (!(this instanceof LevelUP)) {
    return new LevelUP(db, options, callback)
  }

  var error

  EventEmitter.call(this)
  this.setMaxListeners(Infinity)

  if (typeof options === 'function') {
    callback = options
    options = {}
  }

  options = options || {}

  if (!db || typeof db !== 'object') {
    error = new InitializationError('First argument must be an abstract-leveldown compliant store')
    if (typeof callback === 'function') {
      return process.nextTick(callback, error)
    }
    throw error
  }

  assert.strictEqual(typeof db.status, 'string', '.status required, old abstract-leveldown')

  this.options = getOptions(options)
  this._db = db
  this.db = new DeferredLevelDOWN(db)
  this.open(callback)
}

LevelUP.prototype.emit = EventEmitter.prototype.emit
LevelUP.prototype.once = EventEmitter.prototype.once
inherits(LevelUP, EventEmitter)

LevelUP.prototype.open = function (opts, callback) {
  var self = this
  var promise

  if (typeof opts === 'function') {
    callback = opts
    opts = null
  }

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  if (!opts) {
    opts = this.options
  }

  if (this.isOpen()) {
    process.nextTick(callback, null, self)
    return promise
  }

  if (this._isOpening()) {
    this.once('open', function () { callback(null, self) })
    return promise
  }

  this.emit('opening')

  this.db.open(opts, function (err) {
    if (err) {
      return callback(new OpenError(err))
    }
    self.db = self._db
    callback(null, self)
    self.emit('open')
    self.emit('ready')
  })

  return promise
}

LevelUP.prototype.close = function (callback) {
  var self = this
  var promise

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  if (this.isOpen()) {
    this.db.close(function () {
      self.emit('closed')
      callback.apply(null, arguments)
    })
    this.emit('closing')
    this.db = new DeferredLevelDOWN(this._db)
  } else if (this.isClosed()) {
    process.nextTick(callback)
  } else if (this.db.status === 'closing') {
    this.once('closed', callback)
  } else if (this._isOpening()) {
    this.once('open', function () {
      self.close(callback)
    })
  }

  return promise
}

LevelUP.prototype.isOpen = function () {
  return this.db.status === 'open'
}

LevelUP.prototype._isOpening = function () {
  return this.db.status === 'opening'
}

LevelUP.prototype.isClosed = function () {
  return (/^clos|new/).test(this.db.status)
}

LevelUP.prototype.get = function (key, options, callback) {
  if (key === null || key === undefined) {
    throw new ReadError('get() requires a key argument')
  }

  var promise

  callback = getCallback(options, callback)

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  if (maybeError(this, callback)) { return promise }

  options = getOptions(options)

  this.db.get(key, options, function (err, value) {
    if (err) {
      if ((/notfound/i).test(err) || err.notFound) {
        err = new NotFoundError('Key not found in database [' + key + ']', err)
      } else {
        err = new ReadError(err)
      }
      return callback(err)
    }
    callback(null, value)
  })

  return promise
}

LevelUP.prototype.put = function (key, value, options, callback) {
  if (key === null || key === undefined) {
    throw new WriteError('put() requires a key argument')
  }

  var self = this
  var promise

  callback = getCallback(options, callback)

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  if (maybeError(this, callback)) { return promise }

  options = getOptions(options)

  this.db.put(key, value, options, function (err) {
    if (err) {
      return callback(new WriteError(err))
    }
    self.emit('put', key, value)
    callback()
  })

  return promise
}

LevelUP.prototype.del = function (key, options, callback) {
  if (key === null || key === undefined) {
    throw new WriteError('del() requires a key argument')
  }

  var self = this
  var promise

  callback = getCallback(options, callback)

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  if (maybeError(this, callback)) { return promise }

  options = getOptions(options)

  this.db.del(key, options, function (err) {
    if (err) {
      return callback(new WriteError(err))
    }
    self.emit('del', key)
    callback()
  })

  return promise
}

LevelUP.prototype.batch = function (arr, options, callback) {
  if (!arguments.length) {
    return new Batch(this)
  }

  if (!Array.isArray(arr)) {
    throw new WriteError('batch() requires an array argument')
  }

  var self = this
  var promise

  callback = getCallback(options, callback)

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  if (maybeError(this, callback)) { return promise }

  options = getOptions(options)

  this.db.batch(arr, options, function (err) {
    if (err) {
      return callback(new WriteError(err))
    }
    self.emit('batch', arr)
    callback()
  })

  return promise
}

LevelUP.prototype.iterator = function (options) {
  return this.db.iterator(options)
}

LevelUP.prototype.readStream =
LevelUP.prototype.createReadStream = function (options) {
  options = extend({ keys: true, values: true }, options)
  if (typeof options.limit !== 'number') { options.limit = -1 }
  return new IteratorStream(this.db.iterator(options), options)
}

LevelUP.prototype.keyStream =
LevelUP.prototype.createKeyStream = function (options) {
  return this.createReadStream(extend(options, { keys: true, values: false }))
}

LevelUP.prototype.valueStream =
LevelUP.prototype.createValueStream = function (options) {
  return this.createReadStream(extend(options, { keys: false, values: true }))
}

LevelUP.prototype.toString = function () {
  return 'LevelUP'
}

function maybeError (db, callback) {
  if (!db._isOpening() && !db.isOpen()) {
    process.nextTick(callback, new ReadError('Database is not open'))
    return true
  }
}

LevelUP.errors = errors
module.exports = LevelUP.default = LevelUP

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"levelup",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/levelup/lib/levelup.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/crypto.js", {"./blake":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/blake.js","./crypto-sha1-2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/crypto-sha1-2-browser.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/utils.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","js-sha3":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/js-sha3/src/sha3.js","murmurhash3js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/murmurhash3js/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/crypto.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const sha3 = require('js-sha3')
const murmur3 = require('murmurhash3js')

const utils = require('./utils')
const sha = require('./crypto-sha1-2')

const toCallback = utils.toCallback
const toBuf = utils.toBuf
const fromString = utils.fromString
const fromNumberTo32BitBuf = utils.fromNumberTo32BitBuf

const dblSha2256 = (buf, cb) => {
  sha.sha2256(buf, (err, firstHash) => {
    if (err) {
      cb(err)
    }
    sha.sha2256((Buffer.from(firstHash)), cb)
  })
}

module.exports = {
  sha1: sha.sha1,
  sha2256: sha.sha2256,
  sha2512: sha.sha2512,
  sha3512: toCallback(toBuf(sha3.sha3_512)),
  sha3384: toCallback(toBuf(sha3.sha3_384)),
  sha3256: toCallback(toBuf(sha3.sha3_256)),
  sha3224: toCallback(toBuf(sha3.sha3_224)),
  shake128: toCallback(toBuf(sha3.shake_128, 128)),
  shake256: toCallback(toBuf(sha3.shake_256, 256)),
  keccak224: toCallback(toBuf(sha3.keccak_224)),
  keccak256: toCallback(toBuf(sha3.keccak_256)),
  keccak384: toCallback(toBuf(sha3.keccak_384)),
  keccak512: toCallback(toBuf(sha3.keccak_512)),
  murmur3128: toCallback(toBuf(fromString(murmur3.x64.hash128))),
  murmur332: toCallback(fromNumberTo32BitBuf(fromString(murmur3.x86.hash32))),
  addBlake: require('./blake'),
  dblSha2256: dblSha2256
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/crypto.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/cipher.js", {"./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/cipher.js
      return function (require, module, exports) {
/**
 * Cipher base API.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */
var forge = require('./forge');
require('./util');

module.exports = forge.cipher = forge.cipher || {};

// registered algorithms
forge.cipher.algorithms = forge.cipher.algorithms || {};

/**
 * Creates a cipher object that can be used to encrypt data using the given
 * algorithm and key. The algorithm may be provided as a string value for a
 * previously registered algorithm or it may be given as a cipher algorithm
 * API object.
 *
 * @param algorithm the algorithm to use, either a string or an algorithm API
 *          object.
 * @param key the key to use, as a binary-encoded string of bytes or a
 *          byte buffer.
 *
 * @return the cipher.
 */
forge.cipher.createCipher = function(algorithm, key) {
  var api = algorithm;
  if(typeof api === 'string') {
    api = forge.cipher.getAlgorithm(api);
    if(api) {
      api = api();
    }
  }
  if(!api) {
    throw new Error('Unsupported algorithm: ' + algorithm);
  }

  // assume block cipher
  return new forge.cipher.BlockCipher({
    algorithm: api,
    key: key,
    decrypt: false
  });
};

/**
 * Creates a decipher object that can be used to decrypt data using the given
 * algorithm and key. The algorithm may be provided as a string value for a
 * previously registered algorithm or it may be given as a cipher algorithm
 * API object.
 *
 * @param algorithm the algorithm to use, either a string or an algorithm API
 *          object.
 * @param key the key to use, as a binary-encoded string of bytes or a
 *          byte buffer.
 *
 * @return the cipher.
 */
forge.cipher.createDecipher = function(algorithm, key) {
  var api = algorithm;
  if(typeof api === 'string') {
    api = forge.cipher.getAlgorithm(api);
    if(api) {
      api = api();
    }
  }
  if(!api) {
    throw new Error('Unsupported algorithm: ' + algorithm);
  }

  // assume block cipher
  return new forge.cipher.BlockCipher({
    algorithm: api,
    key: key,
    decrypt: true
  });
};

/**
 * Registers an algorithm by name. If the name was already registered, the
 * algorithm API object will be overwritten.
 *
 * @param name the name of the algorithm.
 * @param algorithm the algorithm API object.
 */
forge.cipher.registerAlgorithm = function(name, algorithm) {
  name = name.toUpperCase();
  forge.cipher.algorithms[name] = algorithm;
};

/**
 * Gets a registered algorithm by name.
 *
 * @param name the name of the algorithm.
 *
 * @return the algorithm, if found, null if not.
 */
forge.cipher.getAlgorithm = function(name) {
  name = name.toUpperCase();
  if(name in forge.cipher.algorithms) {
    return forge.cipher.algorithms[name];
  }
  return null;
};

var BlockCipher = forge.cipher.BlockCipher = function(options) {
  this.algorithm = options.algorithm;
  this.mode = this.algorithm.mode;
  this.blockSize = this.mode.blockSize;
  this._finish = false;
  this._input = null;
  this.output = null;
  this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
  this._decrypt = options.decrypt;
  this.algorithm.initialize(options);
};

/**
 * Starts or restarts the encryption or decryption process, whichever
 * was previously configured.
 *
 * For non-GCM mode, the IV may be a binary-encoded string of bytes, an array
 * of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in
 * bytes, then it must be Nb (16) bytes in length. If the IV is given in as
 * 32-bit integers, then it must be 4 integers long.
 *
 * Note: an IV is not required or used in ECB mode.
 *
 * For GCM-mode, the IV must be given as a binary-encoded string of bytes or
 * a byte buffer. The number of bytes should be 12 (96 bits) as recommended
 * by NIST SP-800-38D but another length may be given.
 *
 * @param options the options to use:
 *          iv the initialization vector to use as a binary-encoded string of
 *            bytes, null to reuse the last ciphered block from a previous
 *            update() (this "residue" method is for legacy support only).
 *          additionalData additional authentication data as a binary-encoded
 *            string of bytes, for 'GCM' mode, (default: none).
 *          tagLength desired length of authentication tag, in bits, for
 *            'GCM' mode (0-128, default: 128).
 *          tag the authentication tag to check if decrypting, as a
 *             binary-encoded string of bytes.
 *          output the output the buffer to write to, null to create one.
 */
BlockCipher.prototype.start = function(options) {
  options = options || {};
  var opts = {};
  for(var key in options) {
    opts[key] = options[key];
  }
  opts.decrypt = this._decrypt;
  this._finish = false;
  this._input = forge.util.createBuffer();
  this.output = options.output || forge.util.createBuffer();
  this.mode.start(opts);
};

/**
 * Updates the next block according to the cipher mode.
 *
 * @param input the buffer to read from.
 */
BlockCipher.prototype.update = function(input) {
  if(input) {
    // input given, so empty it into the input buffer
    this._input.putBuffer(input);
  }

  // do cipher operation until it needs more input and not finished
  while(!this._op.call(this.mode, this._input, this.output, this._finish) &&
    !this._finish) {}

  // free consumed memory from input buffer
  this._input.compact();
};

/**
 * Finishes encrypting or decrypting.
 *
 * @param pad a padding function to use in CBC mode, null for default,
 *          signature(blockSize, buffer, decrypt).
 *
 * @return true if successful, false on error.
 */
BlockCipher.prototype.finish = function(pad) {
  // backwards-compatibility w/deprecated padding API
  // Note: will overwrite padding functions even after another start() call
  if(pad && (this.mode.name === 'ECB' || this.mode.name === 'CBC')) {
    this.mode.pad = function(input) {
      return pad(this.blockSize, input, false);
    };
    this.mode.unpad = function(output) {
      return pad(this.blockSize, output, true);
    };
  }

  // build options for padding and afterFinish functions
  var options = {};
  options.decrypt = this._decrypt;

  // get # of bytes that won't fill a block
  options.overflow = this._input.length() % this.blockSize;

  if(!this._decrypt && this.mode.pad) {
    if(!this.mode.pad(this._input, options)) {
      return false;
    }
  }

  // do final update
  this._finish = true;
  this.update();

  if(this._decrypt && this.mode.unpad) {
    if(!this.mode.unpad(this.output, options)) {
      return false;
    }
  }

  if(this.mode.afterFinish) {
    if(!this.mode.afterFinish(this.output, options)) {
      return false;
    }
  }

  return true;
};

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/cipher.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/cipherModes.js", {"./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/cipherModes.js
      return function (require, module, exports) {
/**
 * Supported cipher modes.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */
var forge = require('./forge');
require('./util');

forge.cipher = forge.cipher || {};

// supported cipher modes
var modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};

/** Electronic codebook (ECB) (Don't use this; it's not secure) **/

modes.ecb = function(options) {
  options = options || {};
  this.name = 'ECB';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
};

modes.ecb.prototype.start = function(options) {};

modes.ecb.prototype.encrypt = function(input, output, finish) {
  // not enough input to encrypt
  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {
    return true;
  }

  // get next block
  for(var i = 0; i < this._ints; ++i) {
    this._inBlock[i] = input.getInt32();
  }

  // encrypt block
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // write output
  for(var i = 0; i < this._ints; ++i) {
    output.putInt32(this._outBlock[i]);
  }
};

modes.ecb.prototype.decrypt = function(input, output, finish) {
  // not enough input to decrypt
  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {
    return true;
  }

  // get next block
  for(var i = 0; i < this._ints; ++i) {
    this._inBlock[i] = input.getInt32();
  }

  // decrypt block
  this.cipher.decrypt(this._inBlock, this._outBlock);

  // write output
  for(var i = 0; i < this._ints; ++i) {
    output.putInt32(this._outBlock[i]);
  }
};

modes.ecb.prototype.pad = function(input, options) {
  // add PKCS#7 padding to block (each pad byte is the
  // value of the number of pad bytes)
  var padding = (input.length() === this.blockSize ?
    this.blockSize : (this.blockSize - input.length()));
  input.fillWithByte(padding, padding);
  return true;
};

modes.ecb.prototype.unpad = function(output, options) {
  // check for error: input data not a multiple of blockSize
  if(options.overflow > 0) {
    return false;
  }

  // ensure padding byte count is valid
  var len = output.length();
  var count = output.at(len - 1);
  if(count > (this.blockSize << 2)) {
    return false;
  }

  // trim off padding bytes
  output.truncate(count);
  return true;
};

/** Cipher-block Chaining (CBC) **/

modes.cbc = function(options) {
  options = options || {};
  this.name = 'CBC';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
};

modes.cbc.prototype.start = function(options) {
  // Note: legacy support for using IV residue (has security flaws)
  // if IV is null, reuse block from previous processing
  if(options.iv === null) {
    // must have a previous block
    if(!this._prev) {
      throw new Error('Invalid IV parameter.');
    }
    this._iv = this._prev.slice(0);
  } else if(!('iv' in options)) {
    throw new Error('Invalid IV parameter.');
  } else {
    // save IV as "previous" block
    this._iv = transformIV(options.iv, this.blockSize);
    this._prev = this._iv.slice(0);
  }
};

modes.cbc.prototype.encrypt = function(input, output, finish) {
  // not enough input to encrypt
  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {
    return true;
  }

  // get next block
  // CBC XOR's IV (or previous block) with plaintext
  for(var i = 0; i < this._ints; ++i) {
    this._inBlock[i] = this._prev[i] ^ input.getInt32();
  }

  // encrypt block
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // write output, save previous block
  for(var i = 0; i < this._ints; ++i) {
    output.putInt32(this._outBlock[i]);
  }
  this._prev = this._outBlock;
};

modes.cbc.prototype.decrypt = function(input, output, finish) {
  // not enough input to decrypt
  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {
    return true;
  }

  // get next block
  for(var i = 0; i < this._ints; ++i) {
    this._inBlock[i] = input.getInt32();
  }

  // decrypt block
  this.cipher.decrypt(this._inBlock, this._outBlock);

  // write output, save previous ciphered block
  // CBC XOR's IV (or previous block) with ciphertext
  for(var i = 0; i < this._ints; ++i) {
    output.putInt32(this._prev[i] ^ this._outBlock[i]);
  }
  this._prev = this._inBlock.slice(0);
};

modes.cbc.prototype.pad = function(input, options) {
  // add PKCS#7 padding to block (each pad byte is the
  // value of the number of pad bytes)
  var padding = (input.length() === this.blockSize ?
    this.blockSize : (this.blockSize - input.length()));
  input.fillWithByte(padding, padding);
  return true;
};

modes.cbc.prototype.unpad = function(output, options) {
  // check for error: input data not a multiple of blockSize
  if(options.overflow > 0) {
    return false;
  }

  // ensure padding byte count is valid
  var len = output.length();
  var count = output.at(len - 1);
  if(count > (this.blockSize << 2)) {
    return false;
  }

  // trim off padding bytes
  output.truncate(count);
  return true;
};

/** Cipher feedback (CFB) **/

modes.cfb = function(options) {
  options = options || {};
  this.name = 'CFB';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialBlock = new Array(this._ints);
  this._partialOutput = forge.util.createBuffer();
  this._partialBytes = 0;
};

modes.cfb.prototype.start = function(options) {
  if(!('iv' in options)) {
    throw new Error('Invalid IV parameter.');
  }
  // use IV as first input
  this._iv = transformIV(options.iv, this.blockSize);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};

modes.cfb.prototype.encrypt = function(input, output, finish) {
  // not enough input to encrypt
  var inputLength = input.length();
  if(inputLength === 0) {
    return true;
  }

  // encrypt block
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // handle full block
  if(this._partialBytes === 0 && inputLength >= this.blockSize) {
    // XOR input with output, write input as output
    for(var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
      output.putInt32(this._inBlock[i]);
    }
    return;
  }

  // handle partial block
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if(partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }

  // XOR input with output, write input as partial output
  this._partialOutput.clear();
  for(var i = 0; i < this._ints; ++i) {
    this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
    this._partialOutput.putInt32(this._partialBlock[i]);
  }

  if(partialBytes > 0) {
    // block still incomplete, restore input buffer
    input.read -= this.blockSize;
  } else {
    // block complete, update input block
    for(var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = this._partialBlock[i];
    }
  }

  // skip any previous partial bytes
  if(this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }

  if(partialBytes > 0 && !finish) {
    output.putBytes(this._partialOutput.getBytes(
      partialBytes - this._partialBytes));
    this._partialBytes = partialBytes;
    return true;
  }

  output.putBytes(this._partialOutput.getBytes(
    inputLength - this._partialBytes));
  this._partialBytes = 0;
};

modes.cfb.prototype.decrypt = function(input, output, finish) {
  // not enough input to decrypt
  var inputLength = input.length();
  if(inputLength === 0) {
    return true;
  }

  // encrypt block (CFB always uses encryption mode)
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // handle full block
  if(this._partialBytes === 0 && inputLength >= this.blockSize) {
    // XOR input with output, write input as output
    for(var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = input.getInt32();
      output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
    }
    return;
  }

  // handle partial block
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if(partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }

  // XOR input with output, write input as partial output
  this._partialOutput.clear();
  for(var i = 0; i < this._ints; ++i) {
    this._partialBlock[i] = input.getInt32();
    this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
  }

  if(partialBytes > 0) {
    // block still incomplete, restore input buffer
    input.read -= this.blockSize;
  } else {
    // block complete, update input block
    for(var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = this._partialBlock[i];
    }
  }

  // skip any previous partial bytes
  if(this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }

  if(partialBytes > 0 && !finish) {
    output.putBytes(this._partialOutput.getBytes(
      partialBytes - this._partialBytes));
    this._partialBytes = partialBytes;
    return true;
  }

  output.putBytes(this._partialOutput.getBytes(
    inputLength - this._partialBytes));
  this._partialBytes = 0;
};

/** Output feedback (OFB) **/

modes.ofb = function(options) {
  options = options || {};
  this.name = 'OFB';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge.util.createBuffer();
  this._partialBytes = 0;
};

modes.ofb.prototype.start = function(options) {
  if(!('iv' in options)) {
    throw new Error('Invalid IV parameter.');
  }
  // use IV as first input
  this._iv = transformIV(options.iv, this.blockSize);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};

modes.ofb.prototype.encrypt = function(input, output, finish) {
  // not enough input to encrypt
  var inputLength = input.length();
  if(input.length() === 0) {
    return true;
  }

  // encrypt block (OFB always uses encryption mode)
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // handle full block
  if(this._partialBytes === 0 && inputLength >= this.blockSize) {
    // XOR input with output and update next input
    for(var i = 0; i < this._ints; ++i) {
      output.putInt32(input.getInt32() ^ this._outBlock[i]);
      this._inBlock[i] = this._outBlock[i];
    }
    return;
  }

  // handle partial block
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if(partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }

  // XOR input with output
  this._partialOutput.clear();
  for(var i = 0; i < this._ints; ++i) {
    this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
  }

  if(partialBytes > 0) {
    // block still incomplete, restore input buffer
    input.read -= this.blockSize;
  } else {
    // block complete, update input block
    for(var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = this._outBlock[i];
    }
  }

  // skip any previous partial bytes
  if(this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }

  if(partialBytes > 0 && !finish) {
    output.putBytes(this._partialOutput.getBytes(
      partialBytes - this._partialBytes));
    this._partialBytes = partialBytes;
    return true;
  }

  output.putBytes(this._partialOutput.getBytes(
    inputLength - this._partialBytes));
  this._partialBytes = 0;
};

modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;

/** Counter (CTR) **/

modes.ctr = function(options) {
  options = options || {};
  this.name = 'CTR';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge.util.createBuffer();
  this._partialBytes = 0;
};

modes.ctr.prototype.start = function(options) {
  if(!('iv' in options)) {
    throw new Error('Invalid IV parameter.');
  }
  // use IV as first input
  this._iv = transformIV(options.iv, this.blockSize);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};

modes.ctr.prototype.encrypt = function(input, output, finish) {
  // not enough input to encrypt
  var inputLength = input.length();
  if(inputLength === 0) {
    return true;
  }

  // encrypt block (CTR always uses encryption mode)
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // handle full block
  if(this._partialBytes === 0 && inputLength >= this.blockSize) {
    // XOR input with output
    for(var i = 0; i < this._ints; ++i) {
      output.putInt32(input.getInt32() ^ this._outBlock[i]);
    }
  } else {
    // handle partial block
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if(partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }

    // XOR input with output
    this._partialOutput.clear();
    for(var i = 0; i < this._ints; ++i) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
    }

    if(partialBytes > 0) {
      // block still incomplete, restore input buffer
      input.read -= this.blockSize;
    }

    // skip any previous partial bytes
    if(this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }

    if(partialBytes > 0 && !finish) {
      output.putBytes(this._partialOutput.getBytes(
        partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }

    output.putBytes(this._partialOutput.getBytes(
      inputLength - this._partialBytes));
    this._partialBytes = 0;
  }

  // block complete, increment counter (input block)
  inc32(this._inBlock);
};

modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;

/** Galois/Counter Mode (GCM) **/

modes.gcm = function(options) {
  options = options || {};
  this.name = 'GCM';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge.util.createBuffer();
  this._partialBytes = 0;

  // R is actually this value concatenated with 120 more zero bits, but
  // we only XOR against R so the other zeros have no effect -- we just
  // apply this value to the first integer in a block
  this._R = 0xE1000000;
};

modes.gcm.prototype.start = function(options) {
  if(!('iv' in options)) {
    throw new Error('Invalid IV parameter.');
  }
  // ensure IV is a byte buffer
  var iv = forge.util.createBuffer(options.iv);

  // no ciphered data processed yet
  this._cipherLength = 0;

  // default additional data is none
  var additionalData;
  if('additionalData' in options) {
    additionalData = forge.util.createBuffer(options.additionalData);
  } else {
    additionalData = forge.util.createBuffer();
  }

  // default tag length is 128 bits
  if('tagLength' in options) {
    this._tagLength = options.tagLength;
  } else {
    this._tagLength = 128;
  }

  // if tag is given, ensure tag matches tag length
  this._tag = null;
  if(options.decrypt) {
    // save tag to check later
    this._tag = forge.util.createBuffer(options.tag).getBytes();
    if(this._tag.length !== (this._tagLength / 8)) {
      throw new Error('Authentication tag does not match tag length.');
    }
  }

  // create tmp storage for hash calculation
  this._hashBlock = new Array(this._ints);

  // no tag generated yet
  this.tag = null;

  // generate hash subkey
  // (apply block cipher to "zero" block)
  this._hashSubkey = new Array(this._ints);
  this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);

  // generate table M
  // use 4-bit tables (32 component decomposition of a 16 byte value)
  // 8-bit tables take more space and are known to have security
  // vulnerabilities (in native implementations)
  this.componentBits = 4;
  this._m = this.generateHashTable(this._hashSubkey, this.componentBits);

  // Note: support IV length different from 96 bits? (only supporting
  // 96 bits is recommended by NIST SP-800-38D)
  // generate J_0
  var ivLength = iv.length();
  if(ivLength === 12) {
    // 96-bit IV
    this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
  } else {
    // IV is NOT 96-bits
    this._j0 = [0, 0, 0, 0];
    while(iv.length() > 0) {
      this._j0 = this.ghash(
        this._hashSubkey, this._j0,
        [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);
    }
    this._j0 = this.ghash(
      this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));
  }

  // generate ICB (initial counter block)
  this._inBlock = this._j0.slice(0);
  inc32(this._inBlock);
  this._partialBytes = 0;

  // consume authentication data
  additionalData = forge.util.createBuffer(additionalData);
  // save additional data length as a BE 64-bit number
  this._aDataLength = from64To32(additionalData.length() * 8);
  // pad additional data to 128 bit (16 byte) block size
  var overflow = additionalData.length() % this.blockSize;
  if(overflow) {
    additionalData.fillWithByte(0, this.blockSize - overflow);
  }
  this._s = [0, 0, 0, 0];
  while(additionalData.length() > 0) {
    this._s = this.ghash(this._hashSubkey, this._s, [
      additionalData.getInt32(),
      additionalData.getInt32(),
      additionalData.getInt32(),
      additionalData.getInt32()
    ]);
  }
};

modes.gcm.prototype.encrypt = function(input, output, finish) {
  // not enough input to encrypt
  var inputLength = input.length();
  if(inputLength === 0) {
    return true;
  }

  // encrypt block
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // handle full block
  if(this._partialBytes === 0 && inputLength >= this.blockSize) {
    // XOR input with output
    for(var i = 0; i < this._ints; ++i) {
      output.putInt32(this._outBlock[i] ^= input.getInt32());
    }
    this._cipherLength += this.blockSize;
  } else {
    // handle partial block
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if(partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }

    // XOR input with output
    this._partialOutput.clear();
    for(var i = 0; i < this._ints; ++i) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
    }

    if(partialBytes <= 0 || finish) {
      // handle overflow prior to hashing
      if(finish) {
        // get block overflow
        var overflow = inputLength % this.blockSize;
        this._cipherLength += overflow;
        // truncate for hash function
        this._partialOutput.truncate(this.blockSize - overflow);
      } else {
        this._cipherLength += this.blockSize;
      }

      // get output block for hashing
      for(var i = 0; i < this._ints; ++i) {
        this._outBlock[i] = this._partialOutput.getInt32();
      }
      this._partialOutput.read -= this.blockSize;
    }

    // skip any previous partial bytes
    if(this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }

    if(partialBytes > 0 && !finish) {
      // block still incomplete, restore input buffer, get partial output,
      // and return early
      input.read -= this.blockSize;
      output.putBytes(this._partialOutput.getBytes(
        partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }

    output.putBytes(this._partialOutput.getBytes(
      inputLength - this._partialBytes));
    this._partialBytes = 0;
  }

  // update hash block S
  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);

  // increment counter (input block)
  inc32(this._inBlock);
};

modes.gcm.prototype.decrypt = function(input, output, finish) {
  // not enough input to decrypt
  var inputLength = input.length();
  if(inputLength < this.blockSize && !(finish && inputLength > 0)) {
    return true;
  }

  // encrypt block (GCM always uses encryption mode)
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // increment counter (input block)
  inc32(this._inBlock);

  // update hash block S
  this._hashBlock[0] = input.getInt32();
  this._hashBlock[1] = input.getInt32();
  this._hashBlock[2] = input.getInt32();
  this._hashBlock[3] = input.getInt32();
  this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);

  // XOR hash input with output
  for(var i = 0; i < this._ints; ++i) {
    output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
  }

  // increment cipher data length
  if(inputLength < this.blockSize) {
    this._cipherLength += inputLength % this.blockSize;
  } else {
    this._cipherLength += this.blockSize;
  }
};

modes.gcm.prototype.afterFinish = function(output, options) {
  var rval = true;

  // handle overflow
  if(options.decrypt && options.overflow) {
    output.truncate(this.blockSize - options.overflow);
  }

  // handle authentication tag
  this.tag = forge.util.createBuffer();

  // concatenate additional data length with cipher length
  var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));

  // include lengths in hash
  this._s = this.ghash(this._hashSubkey, this._s, lengths);

  // do GCTR(J_0, S)
  var tag = [];
  this.cipher.encrypt(this._j0, tag);
  for(var i = 0; i < this._ints; ++i) {
    this.tag.putInt32(this._s[i] ^ tag[i]);
  }

  // trim tag to length
  this.tag.truncate(this.tag.length() % (this._tagLength / 8));

  // check authentication tag
  if(options.decrypt && this.tag.bytes() !== this._tag) {
    rval = false;
  }

  return rval;
};

/**
 * See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois
 * field multiplication. The field, GF(2^128), is defined by the polynomial:
 *
 * x^128 + x^7 + x^2 + x + 1
 *
 * Which is represented in little-endian binary form as: 11100001 (0xe1). When
 * the value of a coefficient is 1, a bit is set. The value R, is the
 * concatenation of this value and 120 zero bits, yielding a 128-bit value
 * which matches the block size.
 *
 * This function will multiply two elements (vectors of bytes), X and Y, in
 * the field GF(2^128). The result is initialized to zero. For each bit of
 * X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)
 * by the current value of Y. For each bit, the value of Y will be raised by
 * a power of x (multiplied by the polynomial x). This can be achieved by
 * shifting Y once to the right. If the current value of Y, prior to being
 * multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.
 * Otherwise, we must divide by R after shifting to find the remainder.
 *
 * @param x the first block to multiply by the second.
 * @param y the second block to multiply by the first.
 *
 * @return the block result of the multiplication.
 */
modes.gcm.prototype.multiply = function(x, y) {
  var z_i = [0, 0, 0, 0];
  var v_i = y.slice(0);

  // calculate Z_128 (block has 128 bits)
  for(var i = 0; i < 128; ++i) {
    // if x_i is 0, Z_{i+1} = Z_i (unchanged)
    // else Z_{i+1} = Z_i ^ V_i
    // get x_i by finding 32-bit int position, then left shift 1 by remainder
    var x_i = x[(i / 32) | 0] & (1 << (31 - i % 32));
    if(x_i) {
      z_i[0] ^= v_i[0];
      z_i[1] ^= v_i[1];
      z_i[2] ^= v_i[2];
      z_i[3] ^= v_i[3];
    }

    // if LSB(V_i) is 1, V_i = V_i >> 1
    // else V_i = (V_i >> 1) ^ R
    this.pow(v_i, v_i);
  }

  return z_i;
};

modes.gcm.prototype.pow = function(x, out) {
  // if LSB(x) is 1, x = x >>> 1
  // else x = (x >>> 1) ^ R
  var lsb = x[3] & 1;

  // always do x >>> 1:
  // starting with the rightmost integer, shift each integer to the right
  // one bit, pulling in the bit from the integer to the left as its top
  // most bit (do this for the last 3 integers)
  for(var i = 3; i > 0; --i) {
    out[i] = (x[i] >>> 1) | ((x[i - 1] & 1) << 31);
  }
  // shift the first integer normally
  out[0] = x[0] >>> 1;

  // if lsb was not set, then polynomial had a degree of 127 and doesn't
  // need to divided; otherwise, XOR with R to find the remainder; we only
  // need to XOR the first integer since R technically ends w/120 zero bits
  if(lsb) {
    out[0] ^= this._R;
  }
};

modes.gcm.prototype.tableMultiply = function(x) {
  // assumes 4-bit tables are used
  var z = [0, 0, 0, 0];
  for(var i = 0; i < 32; ++i) {
    var idx = (i / 8) | 0;
    var x_i = (x[idx] >>> ((7 - (i % 8)) * 4)) & 0xF;
    var ah = this._m[i][x_i];
    z[0] ^= ah[0];
    z[1] ^= ah[1];
    z[2] ^= ah[2];
    z[3] ^= ah[3];
  }
  return z;
};

/**
 * A continuing version of the GHASH algorithm that operates on a single
 * block. The hash block, last hash value (Ym) and the new block to hash
 * are given.
 *
 * @param h the hash block.
 * @param y the previous value for Ym, use [0, 0, 0, 0] for a new hash.
 * @param x the block to hash.
 *
 * @return the hashed value (Ym).
 */
modes.gcm.prototype.ghash = function(h, y, x) {
  y[0] ^= x[0];
  y[1] ^= x[1];
  y[2] ^= x[2];
  y[3] ^= x[3];
  return this.tableMultiply(y);
  //return this.multiply(y, h);
};

/**
 * Precomputes a table for multiplying against the hash subkey. This
 * mechanism provides a substantial speed increase over multiplication
 * performed without a table. The table-based multiplication this table is
 * for solves X * H by multiplying each component of X by H and then
 * composing the results together using XOR.
 *
 * This function can be used to generate tables with different bit sizes
 * for the components, however, this implementation assumes there are
 * 32 components of X (which is a 16 byte vector), therefore each component
 * takes 4-bits (so the table is constructed with bits=4).
 *
 * @param h the hash subkey.
 * @param bits the bit size for a component.
 */
modes.gcm.prototype.generateHashTable = function(h, bits) {
  // TODO: There are further optimizations that would use only the
  // first table M_0 (or some variant) along with a remainder table;
  // this can be explored in the future
  var multiplier = 8 / bits;
  var perInt = 4 * multiplier;
  var size = 16 * multiplier;
  var m = new Array(size);
  for(var i = 0; i < size; ++i) {
    var tmp = [0, 0, 0, 0];
    var idx = (i / perInt) | 0;
    var shft = ((perInt - 1 - (i % perInt)) * bits);
    tmp[idx] = (1 << (bits - 1)) << shft;
    m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);
  }
  return m;
};

/**
 * Generates a table for multiplying against the hash subkey for one
 * particular component (out of all possible component values).
 *
 * @param mid the pre-multiplied value for the middle key of the table.
 * @param bits the bit size for a component.
 */
modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
  // compute the table quickly by minimizing the number of
  // POW operations -- they only need to be performed for powers of 2,
  // all other entries can be composed from those powers using XOR
  var size = 1 << bits;
  var half = size >>> 1;
  var m = new Array(size);
  m[half] = mid.slice(0);
  var i = half >>> 1;
  while(i > 0) {
    // raise m0[2 * i] and store in m0[i]
    this.pow(m[2 * i], m[i] = []);
    i >>= 1;
  }
  i = 2;
  while(i < half) {
    for(var j = 1; j < i; ++j) {
      var m_i = m[i];
      var m_j = m[j];
      m[i + j] = [
        m_i[0] ^ m_j[0],
        m_i[1] ^ m_j[1],
        m_i[2] ^ m_j[2],
        m_i[3] ^ m_j[3]
      ];
    }
    i *= 2;
  }
  m[0] = [0, 0, 0, 0];
  /* Note: We could avoid storing these by doing composition during multiply
  calculate top half using composition by speed is preferred. */
  for(i = half + 1; i < size; ++i) {
    var c = m[i ^ half];
    m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
  }
  return m;
};

/** Utility functions */

function transformIV(iv, blockSize) {
  if(typeof iv === 'string') {
    // convert iv string into byte buffer
    iv = forge.util.createBuffer(iv);
  }

  if(forge.util.isArray(iv) && iv.length > 4) {
    // convert iv byte array into byte buffer
    var tmp = iv;
    iv = forge.util.createBuffer();
    for(var i = 0; i < tmp.length; ++i) {
      iv.putByte(tmp[i]);
    }
  }

  if(iv.length() < blockSize) {
    throw new Error(
      'Invalid IV length; got ' + iv.length() +
      ' bytes and expected ' + blockSize + ' bytes.');
  }

  if(!forge.util.isArray(iv)) {
    // convert iv byte buffer into 32-bit integer array
    var ints = [];
    var blocks = blockSize / 4;
    for(var i = 0; i < blocks; ++i) {
      ints.push(iv.getInt32());
    }
    iv = ints;
  }

  return iv;
}

function inc32(block) {
  // increment last 32 bits of block only
  block[block.length - 1] = (block[block.length - 1] + 1) & 0xFFFFFFFF;
}

function from64To32(num) {
  // convert 64-bit number to two BE Int32s
  return [(num / 0x100000000) | 0, num & 0xFFFFFFFF];
}

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/cipherModes.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/sha256.js", {"./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./md":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/md.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/sha256.js
      return function (require, module, exports) {
/**
 * Secure Hash Algorithm with 256-bit digest (SHA-256) implementation.
 *
 * See FIPS 180-2 for details.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 */
var forge = require('./forge');
require('./md');
require('./util');

var sha256 = module.exports = forge.sha256 = forge.sha256 || {};
forge.md.sha256 = forge.md.algorithms.sha256 = sha256;

/**
 * Creates a SHA-256 message digest object.
 *
 * @return a message digest object.
 */
sha256.create = function() {
  // do initialization as necessary
  if(!_initialized) {
    _init();
  }

  // SHA-256 state contains eight 32-bit integers
  var _state = null;

  // input buffer
  var _input = forge.util.createBuffer();

  // used for word storage
  var _w = new Array(64);

  // message digest object
  var md = {
    algorithm: 'sha256',
    blockLength: 64,
    digestLength: 32,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };

  /**
   * Starts the digest.
   *
   * @return this digest object.
   */
  md.start = function() {
    // up to 56-bit message length for convenience
    md.messageLength = 0;

    // full message length (set md.messageLength64 for backwards-compatibility)
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for(var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }
    _input = forge.util.createBuffer();
    _state = {
      h0: 0x6A09E667,
      h1: 0xBB67AE85,
      h2: 0x3C6EF372,
      h3: 0xA54FF53A,
      h4: 0x510E527F,
      h5: 0x9B05688C,
      h6: 0x1F83D9AB,
      h7: 0x5BE0CD19
    };
    return md;
  };
  // start digest automatically for first time
  md.start();

  /**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */
  md.update = function(msg, encoding) {
    if(encoding === 'utf8') {
      msg = forge.util.encodeUtf8(msg);
    }

    // update message length
    var len = msg.length;
    md.messageLength += len;
    len = [(len / 0x100000000) >>> 0, len >>> 0];
    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = ((len[1] / 0x100000000) >>> 0);
    }

    // add bytes to input buffer
    _input.putBytes(msg);

    // process bytes
    _update(_state, _w, _input);

    // compact input buffer every 2K or if empty
    if(_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }

    return md;
  };

  /**
   * Produces the digest.
   *
   * @return a byte buffer containing the digest value.
   */
  md.digest = function() {
    /* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-256 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */

    /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.

    In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */

    var finalBlock = forge.util.createBuffer();
    finalBlock.putBytes(_input.bytes());

    // compute remaining size to be digested (include message length size)
    var remaining = (
      md.fullMessageLength[md.fullMessageLength.length - 1] +
      md.messageLengthSize);

    // add padding for overflow blockSize - overflow
    // _padding starts with 1 byte with first bit is set (byte value 128), then
    // there may be up to (blockSize - 1) other pad bytes
    var overflow = remaining & (md.blockLength - 1);
    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));

    // serialize message length in bits in big-endian order; since length
    // is stored in bytes we multiply by 8 and add carry from next int
    var next, carry;
    var bits = md.fullMessageLength[0] * 8;
    for(var i = 0; i < md.fullMessageLength.length - 1; ++i) {
      next = md.fullMessageLength[i + 1] * 8;
      carry = (next / 0x100000000) >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }
    finalBlock.putInt32(bits);

    var s2 = {
      h0: _state.h0,
      h1: _state.h1,
      h2: _state.h2,
      h3: _state.h3,
      h4: _state.h4,
      h5: _state.h5,
      h6: _state.h6,
      h7: _state.h7
    };
    _update(s2, _w, finalBlock);
    var rval = forge.util.createBuffer();
    rval.putInt32(s2.h0);
    rval.putInt32(s2.h1);
    rval.putInt32(s2.h2);
    rval.putInt32(s2.h3);
    rval.putInt32(s2.h4);
    rval.putInt32(s2.h5);
    rval.putInt32(s2.h6);
    rval.putInt32(s2.h7);
    return rval;
  };

  return md;
};

// sha-256 padding bytes not initialized yet
var _padding = null;
var _initialized = false;

// table of constants
var _k = null;

/**
 * Initializes the constant tables.
 */
function _init() {
  // create padding
  _padding = String.fromCharCode(128);
  _padding += forge.util.fillString(String.fromCharCode(0x00), 64);

  // create K table for SHA-256
  _k = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];

  // now initialized
  _initialized = true;
}

/**
 * Updates a SHA-256 state with the given byte buffer.
 *
 * @param s the SHA-256 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */
function _update(s, w, bytes) {
  // consume 512 bit (64 byte) chunks
  var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;
  var len = bytes.length();
  while(len >= 64) {
    // the w array will be populated with sixteen 32-bit big-endian words
    // and then extended into 64 32-bit words according to SHA-256
    for(i = 0; i < 16; ++i) {
      w[i] = bytes.getInt32();
    }
    for(; i < 64; ++i) {
      // XOR word 2 words ago rot right 17, rot right 19, shft right 10
      t1 = w[i - 2];
      t1 =
        ((t1 >>> 17) | (t1 << 15)) ^
        ((t1 >>> 19) | (t1 << 13)) ^
        (t1 >>> 10);
      // XOR word 15 words ago rot right 7, rot right 18, shft right 3
      t2 = w[i - 15];
      t2 =
        ((t2 >>> 7) | (t2 << 25)) ^
        ((t2 >>> 18) | (t2 << 14)) ^
        (t2 >>> 3);
      // sum(t1, word 7 ago, t2, word 16 ago) modulo 2^32
      w[i] = (t1 + w[i - 7] + t2 + w[i - 16]) | 0;
    }

    // initialize hash value for this chunk
    a = s.h0;
    b = s.h1;
    c = s.h2;
    d = s.h3;
    e = s.h4;
    f = s.h5;
    g = s.h6;
    h = s.h7;

    // round function
    for(i = 0; i < 64; ++i) {
      // Sum1(e)
      s1 =
        ((e >>> 6) | (e << 26)) ^
        ((e >>> 11) | (e << 21)) ^
        ((e >>> 25) | (e << 7));
      // Ch(e, f, g) (optimized the same way as SHA-1)
      ch = g ^ (e & (f ^ g));
      // Sum0(a)
      s0 =
        ((a >>> 2) | (a << 30)) ^
        ((a >>> 13) | (a << 19)) ^
        ((a >>> 22) | (a << 10));
      // Maj(a, b, c) (optimized the same way as SHA-1)
      maj = (a & b) | (c & (a ^ b));

      // main algorithm
      t1 = h + s1 + ch + _k[i] + w[i];
      t2 = s0 + maj;
      h = g;
      g = f;
      f = e;
      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      // can't truncate with `| 0`
      e = (d + t1) >>> 0;
      d = c;
      c = b;
      b = a;
      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      // can't truncate with `| 0`
      a = (t1 + t2) >>> 0;
    }

    // update hash state
    s.h0 = (s.h0 + a) | 0;
    s.h1 = (s.h1 + b) | 0;
    s.h2 = (s.h2 + c) | 0;
    s.h3 = (s.h3 + d) | 0;
    s.h4 = (s.h4 + e) | 0;
    s.h5 = (s.h5 + f) | 0;
    s.h6 = (s.h6 + g) | 0;
    s.h7 = (s.h7 + h) | 0;
    len -= 64;
  }
}

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/sha256.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/prng.js", {"./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/prng.js
      return function (require, module, exports) {
(function (process){(function (){
/**
 * A javascript implementation of a cryptographically-secure
 * Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed
 * here though the use of SHA-256 is not enforced; when generating an
 * a PRNG context, the hashing algorithm and block cipher used for
 * the generator are specified via a plugin.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */
var forge = require('./forge');
require('./util');

var _crypto = null;
if(forge.util.isNodejs && !forge.options.usePureJavaScript &&
  !process.versions['node-webkit']) {
  _crypto = require('crypto');
}

/* PRNG API */
var prng = module.exports = forge.prng = forge.prng || {};

/**
 * Creates a new PRNG context.
 *
 * A PRNG plugin must be passed in that will provide:
 *
 * 1. A function that initializes the key and seed of a PRNG context. It
 *   will be given a 16 byte key and a 16 byte seed. Any key expansion
 *   or transformation of the seed from a byte string into an array of
 *   integers (or similar) should be performed.
 * 2. The cryptographic function used by the generator. It takes a key and
 *   a seed.
 * 3. A seed increment function. It takes the seed and returns seed + 1.
 * 4. An api to create a message digest.
 *
 * For an example, see random.js.
 *
 * @param plugin the PRNG plugin to use.
 */
prng.create = function(plugin) {
  var ctx = {
    plugin: plugin,
    key: null,
    seed: null,
    time: null,
    // number of reseeds so far
    reseeds: 0,
    // amount of data generated so far
    generated: 0,
    // no initial key bytes
    keyBytes: ''
  };

  // create 32 entropy pools (each is a message digest)
  var md = plugin.md;
  var pools = new Array(32);
  for(var i = 0; i < 32; ++i) {
    pools[i] = md.create();
  }
  ctx.pools = pools;

  // entropy pools are written to cyclically, starting at index 0
  ctx.pool = 0;

  /**
   * Generates random bytes. The bytes may be generated synchronously or
   * asynchronously. Web workers must use the asynchronous interface or
   * else the behavior is undefined.
   *
   * @param count the number of random bytes to generate.
   * @param [callback(err, bytes)] called once the operation completes.
   *
   * @return count random bytes as a string.
   */
  ctx.generate = function(count, callback) {
    // do synchronously
    if(!callback) {
      return ctx.generateSync(count);
    }

    // simple generator using counter-based CBC
    var cipher = ctx.plugin.cipher;
    var increment = ctx.plugin.increment;
    var formatKey = ctx.plugin.formatKey;
    var formatSeed = ctx.plugin.formatSeed;
    var b = forge.util.createBuffer();

    // paranoid deviation from Fortuna:
    // reset key for every request to protect previously
    // generated random bytes should the key be discovered;
    // there is no 100ms based reseeding because of this
    // forced reseed for every `generate` call
    ctx.key = null;

    generate();

    function generate(err) {
      if(err) {
        return callback(err);
      }

      // sufficient bytes generated
      if(b.length() >= count) {
        return callback(null, b.getBytes(count));
      }

      // if amount of data generated is greater than 1 MiB, trigger reseed
      if(ctx.generated > 0xfffff) {
        ctx.key = null;
      }

      if(ctx.key === null) {
        // prevent stack overflow
        return forge.util.nextTick(function() {
          _reseed(generate);
        });
      }

      // generate the random bytes
      var bytes = cipher(ctx.key, ctx.seed);
      ctx.generated += bytes.length;
      b.putBytes(bytes);

      // generate bytes for a new key and seed
      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));

      forge.util.setImmediate(generate);
    }
  };

  /**
   * Generates random bytes synchronously.
   *
   * @param count the number of random bytes to generate.
   *
   * @return count random bytes as a string.
   */
  ctx.generateSync = function(count) {
    // simple generator using counter-based CBC
    var cipher = ctx.plugin.cipher;
    var increment = ctx.plugin.increment;
    var formatKey = ctx.plugin.formatKey;
    var formatSeed = ctx.plugin.formatSeed;

    // paranoid deviation from Fortuna:
    // reset key for every request to protect previously
    // generated random bytes should the key be discovered;
    // there is no 100ms based reseeding because of this
    // forced reseed for every `generateSync` call
    ctx.key = null;

    var b = forge.util.createBuffer();
    while(b.length() < count) {
      // if amount of data generated is greater than 1 MiB, trigger reseed
      if(ctx.generated > 0xfffff) {
        ctx.key = null;
      }

      if(ctx.key === null) {
        _reseedSync();
      }

      // generate the random bytes
      var bytes = cipher(ctx.key, ctx.seed);
      ctx.generated += bytes.length;
      b.putBytes(bytes);

      // generate bytes for a new key and seed
      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
    }

    return b.getBytes(count);
  };

  /**
   * Private function that asynchronously reseeds a generator.
   *
   * @param callback(err) called once the operation completes.
   */
  function _reseed(callback) {
    if(ctx.pools[0].messageLength >= 32) {
      _seed();
      return callback();
    }
    // not enough seed data...
    var needed = (32 - ctx.pools[0].messageLength) << 5;
    ctx.seedFile(needed, function(err, bytes) {
      if(err) {
        return callback(err);
      }
      ctx.collect(bytes);
      _seed();
      callback();
    });
  }

  /**
   * Private function that synchronously reseeds a generator.
   */
  function _reseedSync() {
    if(ctx.pools[0].messageLength >= 32) {
      return _seed();
    }
    // not enough seed data...
    var needed = (32 - ctx.pools[0].messageLength) << 5;
    ctx.collect(ctx.seedFileSync(needed));
    _seed();
  }

  /**
   * Private function that seeds a generator once enough bytes are available.
   */
  function _seed() {
    // update reseed count
    ctx.reseeds = (ctx.reseeds === 0xffffffff) ? 0 : ctx.reseeds + 1;

    // goal is to update `key` via:
    // key = hash(key + s)
    //   where 's' is all collected entropy from selected pools, then...

    // create a plugin-based message digest
    var md = ctx.plugin.md.create();

    // consume current key bytes
    md.update(ctx.keyBytes);

    // digest the entropy of pools whose index k meet the
    // condition 'n mod 2^k == 0' where n is the number of reseeds
    var _2powK = 1;
    for(var k = 0; k < 32; ++k) {
      if(ctx.reseeds % _2powK === 0) {
        md.update(ctx.pools[k].digest().getBytes());
        ctx.pools[k].start();
      }
      _2powK = _2powK << 1;
    }

    // get digest for key bytes
    ctx.keyBytes = md.digest().getBytes();

    // paranoid deviation from Fortuna:
    // update `seed` via `seed = hash(key)`
    // instead of initializing to zero once and only
    // ever incrementing it
    md.start();
    md.update(ctx.keyBytes);
    var seedBytes = md.digest().getBytes();

    // update state
    ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
    ctx.seed = ctx.plugin.formatSeed(seedBytes);
    ctx.generated = 0;
  }

  /**
   * The built-in default seedFile. This seedFile is used when entropy
   * is needed immediately.
   *
   * @param needed the number of bytes that are needed.
   *
   * @return the random bytes.
   */
  function defaultSeedFile(needed) {
    // use window.crypto.getRandomValues strong source of entropy if available
    var getRandomValues = null;
    var globalScope = forge.util.globalScope;
    var _crypto = globalScope.crypto || globalScope.msCrypto;
    if(_crypto && _crypto.getRandomValues) {
      getRandomValues = function(arr) {
        return _crypto.getRandomValues(arr);
      };
    }

    var b = forge.util.createBuffer();
    if(getRandomValues) {
      while(b.length() < needed) {
        // max byte length is 65536 before QuotaExceededError is thrown
        // http://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues
        var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
        var entropy = new Uint32Array(Math.floor(count));
        try {
          getRandomValues(entropy);
          for(var i = 0; i < entropy.length; ++i) {
            b.putInt32(entropy[i]);
          }
        } catch(e) {
          /* only ignore QuotaExceededError */
          if(!(typeof QuotaExceededError !== 'undefined' &&
            e instanceof QuotaExceededError)) {
            throw e;
          }
        }
      }
    }

    // be sad and add some weak random data
    if(b.length() < needed) {
      /* Draws from Park-Miller "minimal standard" 31 bit PRNG,
      implemented with David G. Carta's optimization: with 32 bit math
      and without division (Public Domain). */
      var hi, lo, next;
      var seed = Math.floor(Math.random() * 0x010000);
      while(b.length() < needed) {
        lo = 16807 * (seed & 0xFFFF);
        hi = 16807 * (seed >> 16);
        lo += (hi & 0x7FFF) << 16;
        lo += hi >> 15;
        lo = (lo & 0x7FFFFFFF) + (lo >> 31);
        seed = lo & 0xFFFFFFFF;

        // consume lower 3 bytes of seed
        for(var i = 0; i < 3; ++i) {
          // throw in more pseudo random
          next = seed >>> (i << 3);
          next ^= Math.floor(Math.random() * 0x0100);
          b.putByte(String.fromCharCode(next & 0xFF));
        }
      }
    }

    return b.getBytes(needed);
  }
  // initialize seed file APIs
  if(_crypto) {
    // use nodejs async API
    ctx.seedFile = function(needed, callback) {
      _crypto.randomBytes(needed, function(err, bytes) {
        if(err) {
          return callback(err);
        }
        callback(null, bytes.toString());
      });
    };
    // use nodejs sync API
    ctx.seedFileSync = function(needed) {
      return _crypto.randomBytes(needed).toString();
    };
  } else {
    ctx.seedFile = function(needed, callback) {
      try {
        callback(null, defaultSeedFile(needed));
      } catch(e) {
        callback(e);
      }
    };
    ctx.seedFileSync = defaultSeedFile;
  }

  /**
   * Adds entropy to a prng ctx's accumulator.
   *
   * @param bytes the bytes of entropy as a string.
   */
  ctx.collect = function(bytes) {
    // iterate over pools distributing entropy cyclically
    var count = bytes.length;
    for(var i = 0; i < count; ++i) {
      ctx.pools[ctx.pool].update(bytes.substr(i, 1));
      ctx.pool = (ctx.pool === 31) ? 0 : ctx.pool + 1;
    }
  };

  /**
   * Collects an integer of n bits.
   *
   * @param i the integer entropy.
   * @param n the number of bits in the integer.
   */
  ctx.collectInt = function(i, n) {
    var bytes = '';
    for(var x = 0; x < n; x += 8) {
      bytes += String.fromCharCode((i >> x) & 0xFF);
    }
    ctx.collect(bytes);
  };

  /**
   * Registers a Web Worker to receive immediate entropy from the main thread.
   * This method is required until Web Workers can access the native crypto
   * API. This method should be called twice for each created worker, once in
   * the main thread, and once in the worker itself.
   *
   * @param worker the worker to register.
   */
  ctx.registerWorker = function(worker) {
    // worker receives random bytes
    if(worker === self) {
      ctx.seedFile = function(needed, callback) {
        function listener(e) {
          var data = e.data;
          if(data.forge && data.forge.prng) {
            self.removeEventListener('message', listener);
            callback(data.forge.prng.err, data.forge.prng.bytes);
          }
        }
        self.addEventListener('message', listener);
        self.postMessage({forge: {prng: {needed: needed}}});
      };
    } else {
      // main thread sends random bytes upon request
      var listener = function(e) {
        var data = e.data;
        if(data.forge && data.forge.prng) {
          ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
            worker.postMessage({forge: {prng: {err: err, bytes: bytes}}});
          });
        }
      };
      // TODO: do we need to remove the event listener when the worker dies?
      worker.addEventListener('message', listener);
    }
  };

  return ctx;
};

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/prng.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/sha1.js", {"./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./md":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/md.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/sha1.js
      return function (require, module, exports) {
/**
 * Secure Hash Algorithm with 160-bit digest (SHA-1) implementation.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 */
var forge = require('./forge');
require('./md');
require('./util');

var sha1 = module.exports = forge.sha1 = forge.sha1 || {};
forge.md.sha1 = forge.md.algorithms.sha1 = sha1;

/**
 * Creates a SHA-1 message digest object.
 *
 * @return a message digest object.
 */
sha1.create = function() {
  // do initialization as necessary
  if(!_initialized) {
    _init();
  }

  // SHA-1 state contains five 32-bit integers
  var _state = null;

  // input buffer
  var _input = forge.util.createBuffer();

  // used for word storage
  var _w = new Array(80);

  // message digest object
  var md = {
    algorithm: 'sha1',
    blockLength: 64,
    digestLength: 20,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };

  /**
   * Starts the digest.
   *
   * @return this digest object.
   */
  md.start = function() {
    // up to 56-bit message length for convenience
    md.messageLength = 0;

    // full message length (set md.messageLength64 for backwards-compatibility)
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for(var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }
    _input = forge.util.createBuffer();
    _state = {
      h0: 0x67452301,
      h1: 0xEFCDAB89,
      h2: 0x98BADCFE,
      h3: 0x10325476,
      h4: 0xC3D2E1F0
    };
    return md;
  };
  // start digest automatically for first time
  md.start();

  /**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */
  md.update = function(msg, encoding) {
    if(encoding === 'utf8') {
      msg = forge.util.encodeUtf8(msg);
    }

    // update message length
    var len = msg.length;
    md.messageLength += len;
    len = [(len / 0x100000000) >>> 0, len >>> 0];
    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = ((len[1] / 0x100000000) >>> 0);
    }

    // add bytes to input buffer
    _input.putBytes(msg);

    // process bytes
    _update(_state, _w, _input);

    // compact input buffer every 2K or if empty
    if(_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }

    return md;
  };

  /**
   * Produces the digest.
   *
   * @return a byte buffer containing the digest value.
   */
  md.digest = function() {
    /* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-1 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */

    /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.

    In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */

    var finalBlock = forge.util.createBuffer();
    finalBlock.putBytes(_input.bytes());

    // compute remaining size to be digested (include message length size)
    var remaining = (
      md.fullMessageLength[md.fullMessageLength.length - 1] +
      md.messageLengthSize);

    // add padding for overflow blockSize - overflow
    // _padding starts with 1 byte with first bit is set (byte value 128), then
    // there may be up to (blockSize - 1) other pad bytes
    var overflow = remaining & (md.blockLength - 1);
    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));

    // serialize message length in bits in big-endian order; since length
    // is stored in bytes we multiply by 8 and add carry from next int
    var next, carry;
    var bits = md.fullMessageLength[0] * 8;
    for(var i = 0; i < md.fullMessageLength.length - 1; ++i) {
      next = md.fullMessageLength[i + 1] * 8;
      carry = (next / 0x100000000) >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }
    finalBlock.putInt32(bits);

    var s2 = {
      h0: _state.h0,
      h1: _state.h1,
      h2: _state.h2,
      h3: _state.h3,
      h4: _state.h4
    };
    _update(s2, _w, finalBlock);
    var rval = forge.util.createBuffer();
    rval.putInt32(s2.h0);
    rval.putInt32(s2.h1);
    rval.putInt32(s2.h2);
    rval.putInt32(s2.h3);
    rval.putInt32(s2.h4);
    return rval;
  };

  return md;
};

// sha-1 padding bytes not initialized yet
var _padding = null;
var _initialized = false;

/**
 * Initializes the constant tables.
 */
function _init() {
  // create padding
  _padding = String.fromCharCode(128);
  _padding += forge.util.fillString(String.fromCharCode(0x00), 64);

  // now initialized
  _initialized = true;
}

/**
 * Updates a SHA-1 state with the given byte buffer.
 *
 * @param s the SHA-1 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */
function _update(s, w, bytes) {
  // consume 512 bit (64 byte) chunks
  var t, a, b, c, d, e, f, i;
  var len = bytes.length();
  while(len >= 64) {
    // the w array will be populated with sixteen 32-bit big-endian words
    // and then extended into 80 32-bit words according to SHA-1 algorithm
    // and for 32-79 using Max Locktyukhin's optimization

    // initialize hash value for this chunk
    a = s.h0;
    b = s.h1;
    c = s.h2;
    d = s.h3;
    e = s.h4;

    // round 1
    for(i = 0; i < 16; ++i) {
      t = bytes.getInt32();
      w[i] = t;
      f = d ^ (b & (c ^ d));
      t = ((a << 5) | (a >>> 27)) + f + e + 0x5A827999 + t;
      e = d;
      d = c;
      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      c = ((b << 30) | (b >>> 2)) >>> 0;
      b = a;
      a = t;
    }
    for(; i < 20; ++i) {
      t = (w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);
      t = (t << 1) | (t >>> 31);
      w[i] = t;
      f = d ^ (b & (c ^ d));
      t = ((a << 5) | (a >>> 27)) + f + e + 0x5A827999 + t;
      e = d;
      d = c;
      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      c = ((b << 30) | (b >>> 2)) >>> 0;
      b = a;
      a = t;
    }
    // round 2
    for(; i < 32; ++i) {
      t = (w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);
      t = (t << 1) | (t >>> 31);
      w[i] = t;
      f = b ^ c ^ d;
      t = ((a << 5) | (a >>> 27)) + f + e + 0x6ED9EBA1 + t;
      e = d;
      d = c;
      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      c = ((b << 30) | (b >>> 2)) >>> 0;
      b = a;
      a = t;
    }
    for(; i < 40; ++i) {
      t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);
      t = (t << 2) | (t >>> 30);
      w[i] = t;
      f = b ^ c ^ d;
      t = ((a << 5) | (a >>> 27)) + f + e + 0x6ED9EBA1 + t;
      e = d;
      d = c;
      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      c = ((b << 30) | (b >>> 2)) >>> 0;
      b = a;
      a = t;
    }
    // round 3
    for(; i < 60; ++i) {
      t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);
      t = (t << 2) | (t >>> 30);
      w[i] = t;
      f = (b & c) | (d & (b ^ c));
      t = ((a << 5) | (a >>> 27)) + f + e + 0x8F1BBCDC + t;
      e = d;
      d = c;
      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      c = ((b << 30) | (b >>> 2)) >>> 0;
      b = a;
      a = t;
    }
    // round 4
    for(; i < 80; ++i) {
      t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);
      t = (t << 2) | (t >>> 30);
      w[i] = t;
      f = b ^ c ^ d;
      t = ((a << 5) | (a >>> 27)) + f + e + 0xCA62C1D6 + t;
      e = d;
      d = c;
      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      c = ((b << 30) | (b >>> 2)) >>> 0;
      b = a;
      a = t;
    }

    // update hash state
    s.h0 = (s.h0 + a) | 0;
    s.h1 = (s.h1 + b) | 0;
    s.h2 = (s.h2 + c) | 0;
    s.h3 = (s.h3 + d) | 0;
    s.h4 = (s.h4 + e) | 0;

    len -= 64;
  }
}

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/sha1.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/rsa-utils.js", {"./../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/util.js","asn1.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/rsa-utils.js
      return function (require, module, exports) {
'use strict'

const asn1 = require('asn1.js')

const util = require('./../util')
const toBase64 = util.toBase64
const toBn = util.toBn

const RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  )
})

const AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid({
      '1.2.840.113549.1.1.1': 'rsa'
    }),
    this.key('none').optional().null_(),
    this.key('curve').optional().objid(),
    this.key('params').optional().seq().obj(
      this.key('p').int(),
      this.key('q').int(),
      this.key('g').int()
    )
  )
})

const PublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})

const RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  )
})

// Convert a PKCS#1 in ASN1 DER format to a JWK key
exports.pkcs1ToJwk = function (bytes) {
  const asn1 = RSAPrivateKey.decode(bytes, 'der')

  return {
    kty: 'RSA',
    n: toBase64(asn1.modulus),
    e: toBase64(asn1.publicExponent),
    d: toBase64(asn1.privateExponent),
    p: toBase64(asn1.prime1),
    q: toBase64(asn1.prime2),
    dp: toBase64(asn1.exponent1),
    dq: toBase64(asn1.exponent2),
    qi: toBase64(asn1.coefficient),
    alg: 'RS256',
    kid: '2011-04-29'
  }
}

// Convert a JWK key into PKCS#1 in ASN1 DER format
exports.jwkToPkcs1 = function (jwk) {
  return RSAPrivateKey.encode({
    version: 0,
    modulus: toBn(jwk.n),
    publicExponent: toBn(jwk.e),
    privateExponent: toBn(jwk.d),
    prime1: toBn(jwk.p),
    prime2: toBn(jwk.q),
    exponent1: toBn(jwk.dp),
    exponent2: toBn(jwk.dq),
    coefficient: toBn(jwk.qi)
  }, 'der')
}

// Convert a PKCIX in ASN1 DER format to a JWK key
exports.pkixToJwk = function (bytes) {
  const ndata = PublicKey.decode(bytes, 'der')
  const asn1 = RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')

  return {
    kty: 'RSA',
    n: toBase64(asn1.modulus),
    e: toBase64(asn1.publicExponent),
    alg: 'RS256',
    kid: '2011-04-29'
  }
}

// Convert a JWK key to PKCIX in ASN1 DER format
exports.jwkToPkix = function (jwk) {
  return PublicKey.encode({
    algorithm: {
      algorithm: 'rsa',
      none: null
    },
    subjectPublicKey: {
      data: RSAPublicKey.encode({
        modulus: toBn(jwk.n),
        publicExponent: toBn(jwk.e)
      }, 'der')
    }
  }, 'der')
}

      };
    };
  }
}, {package:"libp2p-crypto",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/rsa-utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/protocol-buffers-schema/stringify.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/protocol-buffers-schema/stringify.js
      return function (require, module, exports) {
var onfield = function (f, result) {
  var prefix = f.repeated ? 'repeated' : f.required ? 'required' : 'optional'
  if (f.type === 'map') prefix = 'map<' + f.map.from + ',' + f.map.to + '>'
  if (f.oneof) prefix = ''

  var opts = Object.keys(f.options || {}).map(function (key) {
    return key + ' = ' + f.options[key]
  }).join(',')

  if (opts) opts = ' [' + opts + ']'

  result.push((prefix ? prefix + ' ' : '') + (f.map === 'map' ? '' : f.type + ' ') + f.name + ' = ' + f.tag + opts + ';')
  return result
}

var onmessage = function (m, result) {
  result.push('message ' + m.name + ' {')

  if (!m.enums) m.enums = []
  m.enums.forEach(function (e) {
    result.push(onenum(e, []))
  })

  if (!m.messages) m.messages = []
  m.messages.forEach(function (m) {
    result.push(onmessage(m, []))
  })

  var oneofs = {}

  if (!m.fields) m.fields = []
  m.fields.forEach(function (f) {
    if (f.oneof) {
      if (!oneofs[f.oneof]) oneofs[f.oneof] = []
      oneofs[f.oneof].push(onfield(f, []))
    } else {
      result.push(onfield(f, []))
    }
  })

  Object.keys(oneofs).forEach(function (n) {
    oneofs[n].unshift('oneof ' + n + ' {')
    oneofs[n].push('}')
    result.push(oneofs[n])
  })

  result.push('}', '')
  return result
}

var onenum = function (e, result) {
  result.push('enum ' + e.name + ' {')
  if (!e.options) e.options = {}
  var options = onoption(e.options, [])
  if (options.length > 1) {
    result.push(options.slice(0, -1))
  }
  Object.keys(e.values).map(function (v) {
    var val = onenumvalue(e.values[v])
    result.push([v + ' = ' + val + ';'])
  })
  result.push('}', '')
  return result
}

var onenumvalue = function (v, result) {
  var opts = Object.keys(v.options || {}).map(function (key) {
    return key + ' = ' + v.options[key]
  }).join(',')

  if (opts) opts = ' [' + opts + ']'
  var val = v.value + opts
  return val
}

var onoption = function (o, result) {
  var keys = Object.keys(o)
  keys.forEach(function (option) {
    var v = o[option]
    if (~option.indexOf('.')) option = '(' + option + ')'

    var type = typeof v

    if (type === 'object') {
      v = onoptionMap(v, [])
      if (v.length) result.push('option ' + option + ' = {', v, '};')
    } else {
      if (type === 'string' && option !== 'optimize_for') v = '"' + v + '"'
      result.push('option ' + option + ' = ' + v + ';')
    }
  })
  if (keys.length > 0) {
    result.push('')
  }

  return result
}

var onoptionMap = function (o, result) {
  var keys = Object.keys(o)
  keys.forEach(function (k) {
    var v = o[k]

    var type = typeof v

    if (type === 'object') {
      if (Array.isArray(v)) {
        v.forEach(function (v) {
          v = onoptionMap(v, [])
          if (v.length) result.push(k + ' {', v, '}')
        })
      } else {
        v = onoptionMap(v, [])
        if (v.length) result.push(k + ' {', v, '}')
      }
    } else {
      if (type === 'string') v = '"' + v + '"'
      result.push(k + ': ' + v)
    }
  })

  return result
}

var onservices = function (s, result) {
  result.push('service ' + s.name + ' {')

  if (!s.options) s.options = {}
  onoption(s.options, result)
  if (!s.methods) s.methods = []
  s.methods.forEach(function (m) {
    result.push(onrpc(m, []))
  })

  result.push('}', '')
  return result
}

var onrpc = function (rpc, result) {
  var def = 'rpc ' + rpc.name + '('
  if (rpc.client_streaming) def += 'stream '
  def += rpc.input_type + ') returns ('
  if (rpc.server_streaming) def += 'stream '
  def += rpc.output_type + ')'

  if (!rpc.options) rpc.options = {}

  var options = onoption(rpc.options, [])
  if (options.length > 1) {
    result.push(def + ' {', options.slice(0, -1), '}')
  } else {
    result.push(def + ';')
  }

  return result
}

var indent = function (lvl) {
  return function (line) {
    if (Array.isArray(line)) return line.map(indent(lvl + '  ')).join('\n')
    return lvl + line
  }
}

module.exports = function (schema) {
  var result = []

  result.push('syntax = "proto' + schema.syntax + '";', '')

  if (schema.package) result.push('package ' + schema.package + ';', '')

  if (!schema.options) schema.options = {}

  onoption(schema.options, result)

  if (!schema.enums) schema.enums = []
  schema.enums.forEach(function (e) {
    onenum(e, result)
  })

  if (!schema.messages) schema.messages = []
  schema.messages.forEach(function (m) {
    onmessage(m, result)
  })

  if (schema.services) {
    schema.services.forEach(function (s) {
      onservices(s, result)
    })
  }
  return result.map(indent('')).join('\n')
}

      };
    };
  }
}, {package:"protocol-buffers-schema",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protocol-buffers-schema/stringify.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/protocol-buffers-schema/parse.js", {"./tokenize":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protocol-buffers-schema/tokenize.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/protocol-buffers-schema/parse.js
      return function (require, module, exports) {
var tokenize = require('./tokenize')
var MAX_RANGE = 0x1FFFFFFF

// "Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire types) can be declared "packed"."
// https://developers.google.com/protocol-buffers/docs/encoding#optional
var PACKABLE_TYPES = [
  // varint wire types
  'int32', 'int64', 'uint32', 'uint64', 'sint32', 'sint64', 'bool',
  // + ENUMS
  // 64-bit wire types
  'fixed64', 'sfixed64', 'double',
  // 32-bit wire types
  'fixed32', 'sfixed32', 'float'
]

var onfieldoptions = function (tokens) {
  var opts = {}

  while (tokens.length) {
    switch (tokens[0]) {
      case '[':
      case ',':
        tokens.shift()
        var name = tokens.shift()
        if (name === '(') {       // handling [(A) = B]
          name = tokens.shift()
          tokens.shift()          // remove the end of bracket
        }
        if (tokens[0] !== '=') throw new Error('Unexpected token in field options: ' + tokens[0])
        tokens.shift()
        if (tokens[0] === ']') throw new Error('Unexpected ] in field option')
        opts[name] = tokens.shift()
        break
      case ']':
        tokens.shift()
        return opts

      default:
        throw new Error('Unexpected token in field options: ' + tokens[0])
    }
  }

  throw new Error('No closing tag for field options')
}

var onfield = function (tokens) {
  var field = {
    name: null,
    type: null,
    tag: -1,
    map: null,
    oneof: null,
    required: false,
    repeated: false,
    options: {}
  }

  while (tokens.length) {
    switch (tokens[0]) {
      case '=':
        tokens.shift()
        field.tag = Number(tokens.shift())
        break

      case 'map':
        field.type = 'map'
        field.map = {from: null, to: null}
        tokens.shift()
        if (tokens[0] !== '<') throw new Error('Unexpected token in map type: ' + tokens[0])
        tokens.shift()
        field.map.from = tokens.shift()
        if (tokens[0] !== ',') throw new Error('Unexpected token in map type: ' + tokens[0])
        tokens.shift()
        field.map.to = tokens.shift()
        if (tokens[0] !== '>') throw new Error('Unexpected token in map type: ' + tokens[0])
        tokens.shift()
        field.name = tokens.shift()
        break

      case 'repeated':
      case 'required':
      case 'optional':
        var t = tokens.shift()
        field.required = t === 'required'
        field.repeated = t === 'repeated'
        field.type = tokens.shift()
        field.name = tokens.shift()
        break

      case '[':
        field.options = onfieldoptions(tokens)
        break

      case ';':
        if (field.name === null) throw new Error('Missing field name')
        if (field.type === null) throw new Error('Missing type in message field: ' + field.name)
        if (field.tag === -1) throw new Error('Missing tag number in message field: ' + field.name)
        tokens.shift()
        return field

      default:
        throw new Error('Unexpected token in message field: ' + tokens[0])
    }
  }

  throw new Error('No ; found for message field')
}

var onmessagebody = function (tokens) {
  var body = {
    enums: [],
    messages: [],
    fields: [],
    extends: [],
    extensions: null
  }

  while (tokens.length) {
    switch (tokens[0]) {
      case 'map':
      case 'repeated':
      case 'optional':
      case 'required':
        body.fields.push(onfield(tokens))
        break

      case 'enum':
        body.enums.push(onenum(tokens))
        break

      case 'message':
        body.messages.push(onmessage(tokens))
        break

      case 'extensions':
        body.extensions = onextensions(tokens)
        break

      case 'oneof':
        tokens.shift()
        var name = tokens.shift()
        if (tokens[0] !== '{') throw new Error('Unexpected token in oneof: ' + tokens[0])
        tokens.shift()
        while (tokens[0] !== '}') {
          tokens.unshift('optional')
          var field = onfield(tokens)
          field.oneof = name
          body.fields.push(field)
        }
        tokens.shift()
        break

      case 'extend':
        body.extends.push(onextend(tokens))
        break

      case ';':
        tokens.shift()
        break

      case 'reserved':
      case 'option':
        tokens.shift()
        while (tokens[0] !== ';') {
          tokens.shift()
        }
        break

      default:
        // proto3 does not require the use of optional/required, assumed as optional
        // "singular: a well-formed message can have zero or one of this field (but not more than one)."
        // https://developers.google.com/protocol-buffers/docs/proto3#specifying-field-rules
        tokens.unshift('optional')
        body.fields.push(onfield(tokens))
    }
  }

  return body
}

var onextend = function (tokens) {
  var out = {
    name: tokens[1],
    message: onmessage(tokens)
  }
  return out
}

var onextensions = function (tokens) {
  tokens.shift()
  var from = Number(tokens.shift())
  if (isNaN(from)) throw new Error('Invalid from in extensions definition')
  if (tokens.shift() !== 'to') throw new Error("Expected keyword 'to' in extensions definition")
  var to = tokens.shift()
  if (to === 'max') to = MAX_RANGE
  to = Number(to)
  if (isNaN(to)) throw new Error('Invalid to in extensions definition')
  if (tokens.shift() !== ';') throw new Error('Missing ; in extensions definition')
  return {from: from, to: to}
}
var onmessage = function (tokens) {
  tokens.shift()

  var lvl = 1
  var body = []
  var msg = {
    name: tokens.shift(),
    enums: [],
    extends: [],
    messages: [],
    fields: []
  }

  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0])
  tokens.shift()

  while (tokens.length) {
    if (tokens[0] === '{') lvl++
    else if (tokens[0] === '}') lvl--

    if (!lvl) {
      tokens.shift()
      body = onmessagebody(body)
      msg.enums = body.enums
      msg.messages = body.messages
      msg.fields = body.fields
      msg.extends = body.extends
      msg.extensions = body.extensions
      return msg
    }

    body.push(tokens.shift())
  }

  if (lvl) throw new Error('No closing tag for message')
}

var onpackagename = function (tokens) {
  tokens.shift()
  var name = tokens.shift()
  if (tokens[0] !== ';') throw new Error('Expected ; but found ' + tokens[0])
  tokens.shift()
  return name
}

var onsyntaxversion = function (tokens) {
  tokens.shift()

  if (tokens[0] !== '=') throw new Error('Expected = but found ' + tokens[0])
  tokens.shift()

  var version = tokens.shift()
  switch (version) {
    case '"proto2"':
      version = 2
      break

    case '"proto3"':
      version = 3
      break

    default:
      throw new Error('Expected protobuf syntax version but found ' + version)
  }

  if (tokens[0] !== ';') throw new Error('Expected ; but found ' + tokens[0])
  tokens.shift()

  return version
}

var onenumvalue = function (tokens) {
  if (tokens.length < 4) throw new Error('Invalid enum value: ' + tokens.slice(0, 3).join(' '))
  if (tokens[1] !== '=') throw new Error('Expected = but found ' + tokens[1])
  if (tokens[3] !== ';' && tokens[3] !== '[') throw new Error('Expected ; or [ but found ' + tokens[1])

  var name = tokens.shift()
  tokens.shift()
  var val = {
    value: null,
    options: {}
  }
  val.value = Number(tokens.shift())
  if (tokens[0] === '[') {
    val.options = onfieldoptions(tokens)
  }
  tokens.shift() // expecting the semicolon here

  return {
    name: name,
    val: val
  }
}

var onenum = function (tokens) {
  tokens.shift()
  var options = {}
  var e = {
    name: tokens.shift(),
    values: {},
    options: {}
  }

  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0])
  tokens.shift()

  while (tokens.length) {
    if (tokens[0] === '}') {
      tokens.shift()
      // there goes optional semicolon after the enclosing "}"
      if (tokens[0] === ';') tokens.shift()
      return e
    }
    if (tokens[0] === 'option') {
      options = onoption(tokens)
      e.options[options.name] = options.value
      continue
    }
    var val = onenumvalue(tokens)
    e.values[val.name] = val.val
  }

  throw new Error('No closing tag for enum')
}

var onoption = function (tokens) {
  var name = null
  var value = null

  var parse = function (value) {
    if (value === 'true') return true
    if (value === 'false') return false
    return value.replace(/^"+|"+$/gm, '')
  }

  while (tokens.length) {
    if (tokens[0] === ';') {
      tokens.shift()
      return {name: name, value: value}
    }
    switch (tokens[0]) {
      case 'option':
        tokens.shift()

        var hasBracket = tokens[0] === '('
        if (hasBracket) tokens.shift()

        name = tokens.shift()

        if (hasBracket) {
          if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0])
          tokens.shift()
        }

        if (tokens[0][0] === '.') {
          name += tokens.shift()
        }

        break

      case '=':
        tokens.shift()
        if (name === null) throw new Error('Expected key for option with value: ' + tokens[0])
        value = parse(tokens.shift())

        if (name === 'optimize_for' && !/^(SPEED|CODE_SIZE|LITE_RUNTIME)$/.test(value)) {
          throw new Error('Unexpected value for option optimize_for: ' + value)
        } else if (value === '{') {
          // option foo = {bar: baz}
          value = onoptionMap(tokens)
        }
        break

      default:
        throw new Error('Unexpected token in option: ' + tokens[0])
    }
  }
}

var onoptionMap = function (tokens) {
  var parse = function (value) {
    if (value === 'true') return true
    if (value === 'false') return false
    return value.replace(/^"+|"+$/gm, '')
  }

  var map = {}

  while (tokens.length) {
    if (tokens[0] === '}') {
      tokens.shift()
      return map
    }

    var hasBracket = tokens[0] === '('
    if (hasBracket) tokens.shift()

    var key = tokens.shift()
    if (hasBracket) {
      if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0])
      tokens.shift()
    }

    var value = null

    switch (tokens[0]) {
      case ':':
        if (map[key] !== undefined) throw new Error('Duplicate option map key ' + key)

        tokens.shift()

        value = parse(tokens.shift())

        if (value === '{') {
          // option foo = {bar: baz}
          value = onoptionMap(tokens)
        }

        map[key] = value

        if (tokens[0] === ';') {
          tokens.shift()
        }
        break

      case '{':
        tokens.shift()
        value = onoptionMap(tokens)

        if (map[key] === undefined) map[key] = []
        if (!Array.isArray(map[key])) throw new Error('Duplicate option map key ' + key)

        map[key].push(value)
        break

      default:
        throw new Error('Unexpected token in option map: ' + tokens[0])
    }
  }

  throw new Error('No closing tag for option map')
}

var onimport = function (tokens) {
  tokens.shift()
  var file = tokens.shift().replace(/^"+|"+$/gm, '')

  if (tokens[0] !== ';') throw new Error('Unexpected token: ' + tokens[0] + '. Expected ";"')

  tokens.shift()
  return file
}

var onservice = function (tokens) {
  tokens.shift()

  var service = {
    name: tokens.shift(),
    methods: [],
    options: {}
  }

  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0])
  tokens.shift()

  while (tokens.length) {
    if (tokens[0] === '}') {
      tokens.shift()
      // there goes optional semicolon after the enclosing "}"
      if (tokens[0] === ';') tokens.shift()
      return service
    }

    switch (tokens[0]) {
      case 'option':
        var opt = onoption(tokens)
        if (service.options[opt.name] !== undefined) throw new Error('Duplicate option ' + opt.name)
        service.options[opt.name] = opt.value
        break
      case 'rpc':
        service.methods.push(onrpc(tokens))
        break
      default:
        throw new Error('Unexpected token in service: ' + tokens[0])
    }
  }

  throw new Error('No closing tag for service')
}

var onrpc = function (tokens) {
  tokens.shift()

  var rpc = {
    name: tokens.shift(),
    input_type: null,
    output_type: null,
    client_streaming: false,
    server_streaming: false,
    options: {}
  }

  if (tokens[0] !== '(') throw new Error('Expected ( but found ' + tokens[0])
  tokens.shift()

  if (tokens[0] === 'stream') {
    tokens.shift()
    rpc.client_streaming = true
  }

  rpc.input_type = tokens.shift()

  if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0])
  tokens.shift()

  if (tokens[0] !== 'returns') throw new Error('Expected returns but found ' + tokens[0])
  tokens.shift()

  if (tokens[0] !== '(') throw new Error('Expected ( but found ' + tokens[0])
  tokens.shift()

  if (tokens[0] === 'stream') {
    tokens.shift()
    rpc.server_streaming = true
  }

  rpc.output_type = tokens.shift()

  if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0])
  tokens.shift()

  if (tokens[0] === ';') {
    tokens.shift()
    return rpc
  }

  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0])
  tokens.shift()

  while (tokens.length) {
    if (tokens[0] === '}') {
      tokens.shift()
      // there goes optional semicolon after the enclosing "}"
      if (tokens[0] === ';') tokens.shift()
      return rpc
    }

    if (tokens[0] === 'option') {
      var opt = onoption(tokens)
      if (rpc.options[opt.name] !== undefined) throw new Error('Duplicate option ' + opt.name)
      rpc.options[opt.name] = opt.value
    } else {
      throw new Error('Unexpected token in rpc options: ' + tokens[0])
    }
  }

  throw new Error('No closing tag for rpc')
}

var parse = function (buf) {
  var tokens = tokenize(buf.toString())
  // check for isolated strings in tokens by looking for opening quote
  for (var i = 0; i < tokens.length; i++) {
    if (/^("|')([^'"]*)$/.test(tokens[i])) {
      var j
      if (tokens[i].length === 1) {
        j = i + 1
      } else {
        j = i
      }
      // look ahead for the closing quote and collapse all
      // in-between tokens into a single token
      for (j; j < tokens.length; j++) {
        if (/^([^'"]*)("|')$/.test(tokens[j])) {
          tokens = tokens.slice(0, i).concat(tokens.slice(i, j + 1).join('')).concat(tokens.slice(j + 1))
          break
        }
      }
    }
  }
  var schema = {
    syntax: 3,
    package: null,
    imports: [],
    enums: [],
    messages: [],
    options: {},
    extends: []
  }

  var firstline = true

  while (tokens.length) {
    switch (tokens[0]) {
      case 'package':
        schema.package = onpackagename(tokens)
        break

      case 'syntax':
        if (!firstline) throw new Error('Protobuf syntax version should be first thing in file')
        schema.syntax = onsyntaxversion(tokens)
        break

      case 'message':
        schema.messages.push(onmessage(tokens))
        break

      case 'enum':
        schema.enums.push(onenum(tokens))
        break

      case 'option':
        var opt = onoption(tokens)
        if (schema.options[opt.name]) throw new Error('Duplicate option ' + opt.name)
        schema.options[opt.name] = opt.value
        break

      case 'import':
        schema.imports.push(onimport(tokens))
        break

      case 'extend':
        schema.extends.push(onextend(tokens))
        break

      case 'service':
        if (!schema.services) schema.services = []
        schema.services.push(onservice(tokens))
        break

      default:
        throw new Error('Unexpected token: ' + tokens[0])
    }
    firstline = false
  }

  // now iterate over messages and propagate extends
  schema.extends.forEach(function (ext) {
    schema.messages.forEach(function (msg) {
      if (msg.name === ext.name) {
        ext.message.fields.forEach(function (field) {
          if (!msg.extensions || field.tag < msg.extensions.from || field.tag > msg.extensions.to) {
            throw new Error(msg.name + ' does not declare ' + field.tag + ' as an extension number')
          }
          msg.fields.push(field)
        })
      }
    })
  })

  schema.messages.forEach(function (msg) {
    msg.fields.forEach(function (field) {
      var fieldSplit
      var messageName
      var nestedEnumName
      var message

      function enumNameIsFieldType (en) {
        return en.name === field.type
      }

      function enumNameIsNestedEnumName (en) {
        return en.name === nestedEnumName
      }

      if (field.options && field.options.packed === 'true') {
        if (PACKABLE_TYPES.indexOf(field.type) === -1) {
          // let's see if it's an enum
          if (field.type.indexOf('.') === -1) {
            if (msg.enums && msg.enums.some(enumNameIsFieldType)) {
              return
            }
          } else {
            fieldSplit = field.type.split('.')
            if (fieldSplit.length > 2) {
              throw new Error('what is this?')
            }

            messageName = fieldSplit[0]
            nestedEnumName = fieldSplit[1]

            schema.messages.some(function (msg) {
              if (msg.name === messageName) {
                message = msg
                return msg
              }
            })

            if (message && message.enums && message.enums.some(enumNameIsNestedEnumName)) {
              return
            }
          }

          throw new Error(
            'Fields of type ' + field.type + ' cannot be declared [packed=true]. ' +
            'Only repeated fields of primitive numeric types (types which use ' +
            'the varint, 32-bit, or 64-bit wire types) can be declared "packed". ' +
            'See https://developers.google.com/protocol-buffers/docs/encoding#optional'
          )
        }
      }
    })
  })

  return schema
}

module.exports = parse

      };
    };
  }
}, {package:"protocol-buffers-schema",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protocol-buffers-schema/parse.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/decode.js", {"./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/utils.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/decode.js
      return function (require, module, exports) {
/* eslint max-depth: 1 */
'use strict'

var varint = require('varint')
var defined = require('./utils').defined

function compileDecode (m, resolve, enc) {
  var requiredFields = []
  var fields = {}
  var oneofFields = []
  var vals = []

  for (var i = 0; i < enc.length; i++) {
    var field = m.fields[i]

    fields[field.tag] = i

    var def = field.options && field.options.default
    var resolved = resolve(field.type, m.id, false)
    vals[i] = [def, resolved && resolved.values]

    m.fields[i].packed = field.repeated && field.options && field.options.packed && field.options.packed !== 'false'

    if (field.required) {
      requiredFields.push(field.name)
    }

    if (field.oneof) {
      oneofFields.push(field.name)
    }
  }

  function decodeField (e, field, obj, buf, offset, i) {
    var name = field.name

    if (field.oneof) {
      // clear already defined oneof fields
      var props = Object.keys(obj)
      for (var j = 0; j < props.length; j++) {
        if (oneofFields.indexOf(props[j]) > -1) {
          delete obj[props[j]]
        }
      }
    }

    if (e.message) {
      var len = varint.decode(buf, offset)
      offset += varint.decode.bytes

      var decoded = e.decode(buf, offset, offset + len)

      if (field.map) {
        obj[name] = obj[name] || {}
        obj[name][decoded.key] = decoded.value
      } else if (field.repeated) {
        obj[name] = obj[name] || []
        obj[name].push(decoded)
      } else {
        obj[name] = decoded
      }
    } else {
      if (field.repeated) {
        obj[name] = obj[name] || []
        obj[name].push(e.decode(buf, offset))
      } else {
        obj[name] = e.decode(buf, offset)
      }
    }

    offset += e.decode.bytes
    return offset
  }

  return function decode (buf, offset, end) {
    if (offset == null) {
      offset = 0
    }

    if (end == null) {
      end = buf.length
    }

    if (!(end <= buf.length && offset <= buf.length)) {
      throw new Error('Decoded message is not valid')
    }

    var oldOffset = offset
    var obj = {}
    var field

    while (true) {
      if (end <= offset) {
        // finished

        // check required methods
        var name = ''
        var j = 0
        for (j = 0; j < requiredFields.length; j++) {
          name = requiredFields[j]
          if (!defined(obj[name])) {
            throw new Error('Decoded message is not valid, missing required field: ' + name)
          }
        }

        // fill out missing defaults
        var val
        var def
        for (j = 0; j < enc.length; j++) {
          field = m.fields[j]
          def = vals[j][0]
          val = vals[j][1]
          name = field.name

          if (defined(obj[name])) {
            continue
          }

          var done = false
          if (field.oneof) {
            var props = Object.keys(obj)
            for (var k = 0; k < props.length; k++) {
              if (oneofFields.indexOf(props[k]) > -1) {
                done = true
                break
              }
            }
          }

          if (done) {
            continue
          }

          if (val) { // is enum
            if (field.repeated) {
              obj[name] = []
            } else {
              def = (def && val[def]) ? val[def].value : val[Object.keys(val)[0]].value
              obj[name] = parseInt(def || 0, 10)
            }
          } else {
            obj[name] = defaultValue(field, def)
          }
        }

        decode.bytes = offset - oldOffset
        return obj
      }

      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3

      var i = fields[tag]

      if (i == null) {
        offset = skip(prefix & 7, buf, offset)
        continue
      }

      var e = enc[i]
      field = m.fields[i]

      if (field.packed) {
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset

        while (offset < packedEnd) {
          offset = decodeField(e, field, obj, buf, offset, i)
        }
      } else {
        offset = decodeField(e, field, obj, buf, offset, i)
      }
    }
  }
}

var skip = function (type, buffer, offset) {
  switch (type) {
    case 0:
      varint.decode(buffer, offset)
      return offset + varint.decode.bytes

    case 1:
      return offset + 8

    case 2:
      var len = varint.decode(buffer, offset)
      return offset + varint.decode.bytes + len

    case 3:
    case 4:
      throw new Error('Groups are not supported')

    case 5:
      return offset + 4
    default:
      throw new Error('Unknown wire type: ' + type)
  }
}

var defaultValue = function (f, def) {
  if (f.map) return {}
  if (f.repeated) return []

  switch (f.type) {
    case 'string':
      return def != null ? def : ''

    case 'bool':
      return def === 'true'

    case 'float':
    case 'double':
    case 'sfixed32':
    case 'fixed32':
    case 'varint':
    case 'enum':
    case 'uint64':
    case 'uint32':
    case 'int64':
    case 'int32':
    case 'sint64':
    case 'sint32':
      return parseInt(def || 0, 10)

    default:
      return null
  }
}

module.exports = compileDecode

      };
    };
  }
}, {package:"protons",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/decode.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/encode.js", {"./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/utils.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/encode.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

var defined = require('./utils').defined
var varint = require('varint')

function compileEncode (m, resolve, enc, oneofs, encodingLength) {
  var oneofsKeys = Object.keys(oneofs)
  var encLength = enc.length
  var ints = {}
  for (var i = 0; i < encLength; i++) {
    ints[i] = {
      p: varint.encode(m.fields[i].tag << 3 | 2),
      h: varint.encode(m.fields[i].tag << 3 | enc[i].type)
    }

    var field = m.fields[i]
    m.fields[i].packed = field.repeated && field.options && field.options.packed && field.options.packed !== 'false'
  }

  function encodeField (buf, offset, h, e, packed, innerVal) {
    var j = 0
    if (!packed) {
      for (j = 0; j < h.length; j++) {
        buf[offset++] = h[j]
      }
    }

    if (e.message) {
      varint.encode(e.encodingLength(innerVal), buf, offset)
      offset += varint.encode.bytes
    }

    e.encode(innerVal, buf, offset)
    return offset + e.encode.bytes
  }

  return function encode (obj, buf, offset) {
    if (offset == null) {
      offset = 0
    }
    if (buf == null) {
      buf = Buffer.allocUnsafe(encodingLength(obj))
    }

    var oldOffset = offset
    var objKeys = Object.keys(obj)
    var i = 0

    // oneof checks

    var match = false
    for (i = 0; i < oneofsKeys.length; i++) {
      var name = oneofsKeys[i]
      var prop = oneofs[i]
      if (objKeys.indexOf(prop) > -1) {
        if (match) {
          throw new Error('only one of the properties defined in oneof ' + name + ' can be set')
        }

        match = true
      }
    }

    for (i = 0; i < encLength; i++) {
      var e = enc[i]
      var field = m.fields[i] // was f
      var val = obj[field.name]
      var j = 0

      if (!defined(val)) {
        if (field.required) {
          throw new Error(field.name + ' is required')
        }
        continue
      }
      var p = ints[i].p
      var h = ints[i].h

      var packed = field.packed

      if (field.map) {
        var tmp = Object.keys(val)
        for (j = 0; j < tmp.length; j++) {
          tmp[j] = {
            key: tmp[j],
            value: val[tmp[j]]
          }
        }
        val = tmp
      }

      if (packed) {
        var packedLen = 0
        for (j = 0; j < val.length; j++) {
          if (!defined(val[j])) {
            continue
          }

          packedLen += e.encodingLength(val[j])
        }

        if (packedLen) {
          for (j = 0; j < h.length; j++) {
            buf[offset++] = p[j]
          }
          varint.encode(packedLen, buf, offset)
          offset += varint.encode.bytes
        }
      }

      if (field.repeated) {
        var innerVal
        for (j = 0; j < val.length; j++) {
          innerVal = val[j]
          if (!defined(innerVal)) {
            continue
          }
          offset = encodeField(buf, offset, h, e, packed, innerVal)
        }
      } else {
        offset = encodeField(buf, offset, h, e, packed, val)
      }
    }

    encode.bytes = offset - oldOffset
    return buf
  }
}

module.exports = compileEncode

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"protons",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/encode.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/encoding-length.js", {"./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/utils.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/encoding-length.js
      return function (require, module, exports) {
'use strict'

var defined = require('./utils').defined
var varint = require('varint')

function compileEncodingLength (m, enc, oneofs) {
  var oneofsKeys = Object.keys(oneofs)
  var encLength = enc.length

  var hls = new Array(encLength)

  for (var i = 0; i < m.fields.length; i++) {
    hls[i] = varint.encodingLength(m.fields[i].tag << 3 | enc[i].type)

    var field = m.fields[i]
    m.fields[i].packed = field.repeated && field.options && field.options.packed && field.options.packed !== 'false'
  }

  return function encodingLength (obj) {
    var length = 0
    var i = 0
    var j = 0

    for (i = 0; i < oneofsKeys.length; i++) {
      var name = oneofsKeys[i]
      var props = oneofs[name]

      var match = false
      for (j = 0; j < props.length; j++) {
        if (defined(obj[props[j]])) {
          if (match) {
            throw new Error('only one of the properties defined in oneof ' + name + ' can be set')
          }
          match = true
        }
      }
    }

    for (i = 0; i < encLength; i++) {
      var e = enc[i]
      var field = m.fields[i]
      var val = obj[field.name]
      var hl = hls[i]
      var len

      if (!defined(val)) {
        if (field.required) {
          throw new Error(field.name + ' is required')
        }

        continue
      }

      if (field.map) {
        var tmp = Object.keys(val)
        for (j = 0; j < tmp.length; j++) {
          tmp[j] = {
            key: tmp[j],
            value: val[tmp[j]]
          }
        }

        val = tmp
      }

      if (field.packed) {
        var packedLen = 0
        for (j = 0; j < val.length; j++) {
          if (!defined(val[j])) {
            continue
          }
          len = e.encodingLength(val[j])
          packedLen += len

          if (e.message) {
            packedLen += varint.encodingLength(len)
          }
        }

        if (packedLen) {
          length += hl + packedLen + varint.encodingLength(packedLen)
        }
      } else if (field.repeated) {
        for (j = 0; j < val.length; j++) {
          if (!defined(val[j])) {
            continue
          }

          len = e.encodingLength(val[j])
          length += hl + len + (e.message ? varint.encodingLength(len) : 0)
        }
      } else {
        len = e.encodingLength(val)
        length += hl + len + (e.message ? varint.encodingLength(len) : 0)
      }
    }

    return length
  }
}

module.exports = compileEncodingLength

      };
    };
  }
}, {package:"protons",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/encoding-length.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/encodings.js", {"safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js","signed-varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/signed-varint/index.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/encodings.js
      return function (require, module, exports) {
'use strict'

var varint = require('varint')
var svarint = require('signed-varint')
var Buffer = require('safe-buffer').Buffer

var encoder = function (type, encode, decode, encodingLength) {
  encode.bytes = decode.bytes = 0

  return {
    type: type,
    encode: encode,
    decode: decode,
    encodingLength: encodingLength
  }
}

exports.make = encoder

exports.bytes = (function (tag) {
  var bufferLength = function (val) {
    return Buffer.isBuffer(val) ? val.length : Buffer.byteLength(val)
  }

  var encodingLength = function (val) {
    var len = bufferLength(val)
    return varint.encodingLength(len) + len
  }

  var encode = function (val, buffer, offset) {
    var oldOffset = offset
    var len = bufferLength(val)

    varint.encode(len, buffer, offset)
    offset += varint.encode.bytes

    if (Buffer.isBuffer(val)) val.copy(buffer, offset)
    else buffer.write(val, offset, len)
    offset += len

    encode.bytes = offset - oldOffset
    return buffer
  }

  var decode = function (buffer, offset) {
    var oldOffset = offset

    var len = varint.decode(buffer, offset)
    offset += varint.decode.bytes

    var val = buffer.slice(offset, offset + len)
    offset += val.length

    decode.bytes = offset - oldOffset
    return val
  }

  return encoder(2, encode, decode, encodingLength)
})()

exports.string = (function () {
  var encodingLength = function (val) {
    var len = Buffer.byteLength(val)
    return varint.encodingLength(len) + len
  }

  var encode = function (val, buffer, offset) {
    var oldOffset = offset
    var len = Buffer.byteLength(val)

    varint.encode(len, buffer, offset, 'utf-8')
    offset += varint.encode.bytes

    buffer.write(val, offset, len)
    offset += len

    encode.bytes = offset - oldOffset
    return buffer
  }

  var decode = function (buffer, offset) {
    var oldOffset = offset

    var len = varint.decode(buffer, offset)
    offset += varint.decode.bytes

    var val = buffer.toString('utf-8', offset, offset + len)
    offset += len

    decode.bytes = offset - oldOffset
    return val
  }

  return encoder(2, encode, decode, encodingLength)
})()

exports.bool = (function () {
  var encodingLength = function (val) {
    return 1
  }

  var encode = function (val, buffer, offset) {
    buffer[offset] = val ? 1 : 0
    encode.bytes = 1
    return buffer
  }

  var decode = function (buffer, offset) {
    var bool = buffer[offset] > 0
    decode.bytes = 1
    return bool
  }

  return encoder(0, encode, decode, encodingLength)
})()

exports.int32 = (function () {
  var decode = function (buffer, offset) {
    var val = varint.decode(buffer, offset)
    decode.bytes = varint.decode.bytes
    return val > 2147483647 ? val - 4294967296 : val
  }

  var encode = function (val, buffer, offset) {
    varint.encode(val < 0 ? val + 4294967296 : val, buffer, offset)
    encode.bytes = varint.encode.bytes
    return buffer
  }

  var encodingLength = function (val) {
    return varint.encodingLength(val < 0 ? val + 4294967296 : val)
  }

  return encoder(0, varint.encode, decode, encodingLength)
})()

exports.int64 = (function () {
  var decode = function (buffer, offset) {
    var val = varint.decode(buffer, offset)
    if (val >= Math.pow(2, 63)) {
      var limit = 9
      while (buffer[offset + limit - 1] === 0xff) limit--
      limit = limit || 9
      var subset = Buffer.allocUnsafe(limit)
      buffer.copy(subset, 0, offset, offset + limit)
      subset[limit - 1] = subset[limit - 1] & 0x7f
      val = -1 * varint.decode(subset, 0)
      decode.bytes = 10
    } else {
      decode.bytes = varint.decode.bytes
    }
    return val
  }

  var encode = function (val, buffer, offset) {
    if (val < 0) {
      var last = offset + 9
      varint.encode(val * -1, buffer, offset)
      offset += varint.encode.bytes - 1
      buffer[offset] = buffer[offset] | 0x80
      while (offset < last - 1) {
        offset++
        buffer[offset] = 0xff
      }
      buffer[last] = 0x01
      encode.bytes = 10
    } else {
      varint.encode(val, buffer, offset)
      encode.bytes = varint.encode.bytes
    }
    return buffer
  }

  var encodingLength = function (val) {
    return val < 0 ? 10 : varint.encodingLength(val)
  }

  return encoder(0, encode, decode, encodingLength)
})()

exports.sint32 =
exports.sint64 = (function () {
  return encoder(0, svarint.encode, svarint.decode, svarint.encodingLength)
})()

exports.uint32 =
exports.uint64 =
exports.enum =
exports.varint = (function () {
  return encoder(0, varint.encode, varint.decode, varint.encodingLength)
})()

// we cannot represent these in javascript so we just use buffers
exports.fixed64 =
exports.sfixed64 = (function () {
  var encodingLength = function (val) {
    return 8
  }

  var encode = function (val, buffer, offset) {
    val.copy(buffer, offset)
    encode.bytes = 8
    return buffer
  }

  var decode = function (buffer, offset) {
    var val = buffer.slice(offset, offset + 8)
    decode.bytes = 8
    return val
  }

  return encoder(1, encode, decode, encodingLength)
})()

exports.double = (function () {
  var encodingLength = function (val) {
    return 8
  }

  var encode = function (val, buffer, offset) {
    buffer.writeDoubleLE(val, offset)
    encode.bytes = 8
    return buffer
  }

  var decode = function (buffer, offset) {
    var val = buffer.readDoubleLE(offset)
    decode.bytes = 8
    return val
  }

  return encoder(1, encode, decode, encodingLength)
})()

exports.fixed32 = (function () {
  var encodingLength = function (val) {
    return 4
  }

  var encode = function (val, buffer, offset) {
    buffer.writeUInt32LE(val, offset)
    encode.bytes = 4
    return buffer
  }

  var decode = function (buffer, offset) {
    var val = buffer.readUInt32LE(offset)
    decode.bytes = 4
    return val
  }

  return encoder(5, encode, decode, encodingLength)
})()

exports.sfixed32 = (function () {
  var encodingLength = function (val) {
    return 4
  }

  var encode = function (val, buffer, offset) {
    buffer.writeInt32LE(val, offset)
    encode.bytes = 4
    return buffer
  }

  var decode = function (buffer, offset) {
    var val = buffer.readInt32LE(offset)
    decode.bytes = 4
    return val
  }

  return encoder(5, encode, decode, encodingLength)
})()

exports.float = (function () {
  var encodingLength = function (val) {
    return 4
  }

  var encode = function (val, buffer, offset) {
    buffer.writeFloatLE(val, offset)
    encode.bytes = 4
    return buffer
  }

  var decode = function (buffer, offset) {
    var val = buffer.readFloatLE(offset)
    decode.bytes = 4
    return val
  }

  return encoder(5, encode, decode, encodingLength)
})()

      };
    };
  }
}, {package:"protons",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/encodings.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/util.js", {"asn1.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/util.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const BN = require('asn1.js').bignum

// Convert a BN.js instance to a base64 encoded string without padding
// Adapted from https://tools.ietf.org/html/draft-ietf-jose-json-web-signature-41#appendix-C
exports.toBase64 = function toBase64 (bn, len) {
  // if len is defined then the bytes are leading-0 padded to the length
  let s = bn.toArrayLike(Buffer, 'be', len).toString('base64')

  return s
    .replace(/(=*)$/, '') // Remove any trailing '='s
    .replace(/\+/g, '-') // 62nd char of encoding
    .replace(/\//g, '_') // 63rd char of encoding
}

// Convert a base64 encoded string to a BN.js instance
exports.toBn = function toBn (str) {
  return new BN(Buffer.from(str, 'base64'))
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-crypto",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1.js", {"./asn1/api":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/api.js","./asn1/base":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/index.js","./asn1/constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/constants/index.js","./asn1/decoders":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/decoders/index.js","./asn1/encoders":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/encoders/index.js","bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bn.js/lib/bn.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1.js
      return function (require, module, exports) {
'use strict';

const asn1 = exports;

asn1.bignum = require('bn.js');

asn1.define = require('./asn1/api').define;
asn1.base = require('./asn1/base');
asn1.constants = require('./asn1/constants');
asn1.decoders = require('./asn1/decoders');
asn1.encoders = require('./asn1/encoders');

      };
    };
  }
}, {package:"asn1.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/crypto.js", {"./blake":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/blake.js","./crypto-sha1-2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/crypto-sha1-2-browser.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/utils.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","js-sha3":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/js-sha3/src/sha3.js","murmurhash3js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/murmurhash3js/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/crypto.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const sha3 = require('js-sha3')
const murmur3 = require('murmurhash3js')

const utils = require('./utils')
const sha = require('./crypto-sha1-2')

const toCallback = utils.toCallback
const toBuf = utils.toBuf
const fromString = utils.fromString
const fromNumberTo32BitBuf = utils.fromNumberTo32BitBuf

const dblSha2256 = (buf, cb) => {
  sha.sha2256(buf, (err, firstHash) => {
    if (err) {
      cb(err)
    }
    sha.sha2256((Buffer.from(firstHash)), cb)
  })
}

module.exports = {
  sha1: sha.sha1,
  sha2256: sha.sha2256,
  sha2512: sha.sha2512,
  sha3512: toCallback(toBuf(sha3.sha3_512)),
  sha3384: toCallback(toBuf(sha3.sha3_384)),
  sha3256: toCallback(toBuf(sha3.sha3_256)),
  sha3224: toCallback(toBuf(sha3.sha3_224)),
  shake128: toCallback(toBuf(sha3.shake_128, 128)),
  shake256: toCallback(toBuf(sha3.shake_256, 256)),
  keccak224: toCallback(toBuf(sha3.keccak_224)),
  keccak256: toCallback(toBuf(sha3.keccak_256)),
  keccak384: toCallback(toBuf(sha3.keccak_384)),
  keccak512: toCallback(toBuf(sha3.keccak_512)),
  murmur3128: toCallback(toBuf(fromString(murmur3.x64.hash128))),
  murmur332: toCallback(fromNumberTo32BitBuf(fromString(murmur3.x86.hash32))),
  addBlake: require('./blake'),
  dblSha2256: dblSha2256
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/crypto.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/js.js", {"./lib":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/index.js","./lib/js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/js.js
      return function (require, module, exports) {
'use strict'
module.exports = require('./lib')(require('./lib/js'))

      };
    };
  }
}, {package:"secp256k1",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/js.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-circular/lib/node.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/is-circular/lib/node.js
      return function (require, module, exports) {
module.exports = Node

/**
 * a linked-list node
 * @class
 * @param {any} value - node's value
 * @param {Node} next - next node
 */
function Node (value, next) {
  this.value = value
  this.next = next
}

/**
 * checks if this node or any of its children has the value
 * @param {any} value - value to check if linked-list contains
 * @return {boolean} true if the list contains the value; false if not
 */
Node.prototype.contains = function (value) {
  var cursor = this

  while (cursor) {
    if (cursor.value === value) return true
    cursor = cursor.next
  }

  return false
}

      };
    };
  }
}, {package:"is-circular",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-circular/lib/node.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/util.js", {"../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/util.js","./../dag-link":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-link/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/util.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const DAGLink = require('./../dag-link')
const {
  cid,
  serialize
} = require('../util')

exports = module.exports

function cloneData (dagNode) {
  let data

  if (dagNode.Data && dagNode.Data.length > 0) {
    data = Buffer.alloc(dagNode.Data.length)
    dagNode.Data.copy(data)
  } else {
    data = Buffer.alloc(0)
  }

  return data
}

function cloneLinks (dagNode) {
  return dagNode.Links.slice()
}

function linkSort (a, b) {
  return Buffer.compare(a.nameAsBuffer, b.nameAsBuffer)
}

/*
 * toDAGLink converts a DAGNode to a DAGLink
 */
const toDAGLink = async (node, options = {}) => {
  const serialized = serialize(node)
  const nodeCid = await cid(serialized)
  return new DAGLink(options.name || '', serialized.length, nodeCid)
}

exports.cloneData = cloneData
exports.cloneLinks = cloneLinks
exports.linkSort = linkSort
exports.toDAGLink = toDAGLink

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipld-dag-pb",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/stable/stable.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/stable/stable.js
      return function (require, module, exports) {
//! stable.js 0.1.8, https://github.com/Two-Screen/stable
//! © 2018 Angry Bytes and contributors. MIT licensed.

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.stable = factory());
}(this, (function () { 'use strict';

  // A stable array sort, because `Array#sort()` is not guaranteed stable.
  // This is an implementation of merge sort, without recursion.

  var stable = function (arr, comp) {
    return exec(arr.slice(), comp)
  };

  stable.inplace = function (arr, comp) {
    var result = exec(arr, comp);

    // This simply copies back if the result isn't in the original array,
    // which happens on an odd number of passes.
    if (result !== arr) {
      pass(result, null, arr.length, arr);
    }

    return arr
  };

  // Execute the sort using the input array and a second buffer as work space.
  // Returns one of those two, containing the final result.
  function exec(arr, comp) {
    if (typeof(comp) !== 'function') {
      comp = function (a, b) {
        return String(a).localeCompare(b)
      };
    }

    // Short-circuit when there's nothing to sort.
    var len = arr.length;
    if (len <= 1) {
      return arr
    }

    // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.
    // Chunks are the size of the left or right hand in merge sort.
    // Stop when the left-hand covers all of the array.
    var buffer = new Array(len);
    for (var chk = 1; chk < len; chk *= 2) {
      pass(arr, comp, chk, buffer);

      var tmp = arr;
      arr = buffer;
      buffer = tmp;
    }

    return arr
  }

  // Run a single pass with the given chunk size.
  var pass = function (arr, comp, chk, result) {
    var len = arr.length;
    var i = 0;
    // Step size / double chunk size.
    var dbl = chk * 2;
    // Bounds of the left and right chunks.
    var l, r, e;
    // Iterators over the left and right chunk.
    var li, ri;

    // Iterate over pairs of chunks.
    for (l = 0; l < len; l += dbl) {
      r = l + chk;
      e = r + chk;
      if (r > len) r = len;
      if (e > len) e = len;

      // Iterate both chunks in parallel.
      li = l;
      ri = r;
      while (true) {
        // Compare the chunks.
        if (li < r && ri < e) {
          // This works for a regular `sort()` compatible comparator,
          // but also for a simple comparator like: `a > b`
          if (comp(arr[li], arr[ri]) <= 0) {
            result[i++] = arr[li++];
          }
          else {
            result[i++] = arr[ri++];
          }
        }
        // Nothing to compare, just flush what's left.
        else if (li < r) {
          result[i++] = arr[li++];
        }
        else if (ri < e) {
          result[i++] = arr[ri++];
        }
        // Both iterators are at the chunk ends.
        else {
          break
        }
      }
    }
  };

  return stable;

})));

      };
    };
  }
}, {package:"stable",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/stable/stable.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/sha.browser.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/sha.browser.js
      return function (require, module, exports) {
'use strict'

const { Buffer } = require('buffer')

const crypto = self.crypto || self.msCrypto

module.exports = (algorithm) => {
  if (typeof self === 'undefined' || (!self.crypto && !self.msCrypto)) {
    throw new Error(
      'Please use a browser with webcrypto support and ensure the code has been delivered securely via HTTPS/TLS and run within a Secure Context'
    )
  }

  return async (data) => {
    switch (algorithm) {
      case 'sha1':
        return Buffer.from(await crypto.subtle.digest({ name: 'SHA-1' }, data))
      case 'sha2-256':
        return Buffer.from(await crypto.subtle.digest({ name: 'SHA-256' }, data))
      case 'sha2-512':
        return Buffer.from(await crypto.subtle.digest({ name: 'SHA-512' }, data))
      case 'dbl-sha2-256': {
        const d = await crypto.subtle.digest({ name: 'SHA-256' }, data)
        return Buffer.from(await crypto.subtle.digest({ name: 'SHA-256' }, d))
      }
      default:
        throw new Error(`${algorithm} is not a supported algorithm`)
    }
  }
}

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/sha.browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/utils.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/utils.js
      return function (require, module, exports) {
'use strict'

const { Buffer } = require('buffer')

const fromNumberTo32BitBuf = (number) => {
  const bytes = new Array(4)

  for (let i = 0; i < 4; i++) {
    bytes[i] = number & 0xff
    number = number >> 8
  }

  return Buffer.from(bytes)
}

module.exports = {
  fromNumberTo32BitBuf
}

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/blake.js", {"blakejs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/blake.js
      return function (require, module, exports) {
'use strict'

const { Buffer } = require('buffer')
const blake = require('blakejs')

const minB = 0xb201
const minS = 0xb241

const blake2b = {
  init: blake.blake2bInit,
  update: blake.blake2bUpdate,
  digest: blake.blake2bFinal
}

const blake2s = {
  init: blake.blake2sInit,
  update: blake.blake2sUpdate,
  digest: blake.blake2sFinal
}

// Note that although this function doesn't do any asynchronous work, we mark
// the function as async because it must return a Promise to match the API
// for other functions that do perform asynchronous work (see sha.browser.js)
const makeB2Hash = (size, hf) => async (data) => {
  const ctx = hf.init(size, null)
  hf.update(ctx, data)
  return Buffer.from(hf.digest(ctx))
}

module.exports = (table) => {
  for (let i = 0; i < 64; i++) {
    table[minB + i] = makeB2Hash(i + 1, blake2b)
  }
  for (let i = 0; i < 32; i++) {
    table[minS + i] = makeB2Hash(i + 1, blake2s)
  }
}

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/blake.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/murmurhash3js-revisited/index.js", {"./lib/murmurHash3js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/murmurhash3js-revisited/index.js
      return function (require, module, exports) {
module.exports = require('./lib/murmurHash3js');

      };
    };
  }
}, {package:"murmurhash3js-revisited",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/murmurhash3js-revisited/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ip-regex/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ip-regex/index.js
      return function (require, module, exports) {
'use strict';

const v4 = '(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])(?:\\.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])){3}';

const v6seg = '[0-9a-fA-F]{1,4}';
const v6 = `
(
(?:${v6seg}:){7}(?:${v6seg}|:)|                                // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                         // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v4}|(:${v6seg}){1,2}|:)|                 // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(:${v6seg}){0,1}:${v4}|(:${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(:${v6seg}){0,2}:${v4}|(:${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(:${v6seg}){0,3}:${v4}|(:${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(:${v6seg}){0,4}:${v4}|(:${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::((?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))           // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(%[0-9a-zA-Z]{1,})?                                           // %eth0            %1
`.replace(/\s*\/\/.*$/gm, '').replace(/\n/g, '').trim();

const ip = module.exports = opts => opts && opts.exact ?
	new RegExp(`(?:^${v4}$)|(?:^${v6}$)`) :
	new RegExp(`(?:${v4})|(?:${v6})`, 'g');

ip.v4 = opts => opts && opts.exact ? new RegExp(`^${v4}$`) : new RegExp(v4, 'g');
ip.v6 = opts => opts && opts.exact ? new RegExp(`^${v6}$`) : new RegExp(v6, 'g');

      };
    };
  }
}, {package:"ip-regex",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ip-regex/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/blake2s.js", {"./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/blake2s.js
      return function (require, module, exports) {
// BLAKE2s hash function in pure Javascript
// Adapted from the reference implementation in RFC7693
// Ported to Javascript by DC - https://github.com/dcposch

var util = require('./util')

// Little-endian byte access.
// Expects a Uint8Array and an index
// Returns the little-endian uint32 at v[i..i+3]
function B2S_GET32 (v, i) {
  return v[i] ^ (v[i + 1] << 8) ^ (v[i + 2] << 16) ^ (v[i + 3] << 24)
}

// Mixing function G.
function B2S_G (a, b, c, d, x, y) {
  v[a] = v[a] + v[b] + x
  v[d] = ROTR32(v[d] ^ v[a], 16)
  v[c] = v[c] + v[d]
  v[b] = ROTR32(v[b] ^ v[c], 12)
  v[a] = v[a] + v[b] + y
  v[d] = ROTR32(v[d] ^ v[a], 8)
  v[c] = v[c] + v[d]
  v[b] = ROTR32(v[b] ^ v[c], 7)
}

// 32-bit right rotation
// x should be a uint32
// y must be between 1 and 31, inclusive
function ROTR32 (x, y) {
  return (x >>> y) ^ (x << (32 - y))
}

// Initialization Vector.
var BLAKE2S_IV = new Uint32Array([
  0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,
  0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19])

var SIGMA = new Uint8Array([
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,
  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,
  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,
  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,
  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,
  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,
  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,
  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,
  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0])

// Compression function. "last" flag indicates last block
var v = new Uint32Array(16)
var m = new Uint32Array(16)
function blake2sCompress (ctx, last) {
  var i = 0
  for (i = 0; i < 8; i++) { // init work variables
    v[i] = ctx.h[i]
    v[i + 8] = BLAKE2S_IV[i]
  }

  v[12] ^= ctx.t // low 32 bits of offset
  v[13] ^= (ctx.t / 0x100000000) // high 32 bits
  if (last) { // last block flag set ?
    v[14] = ~v[14]
  }

  for (i = 0; i < 16; i++) { // get little-endian words
    m[i] = B2S_GET32(ctx.b, 4 * i)
  }

  // ten rounds of mixing
  // uncomment the DebugPrint calls to log the computation
  // and match the RFC sample documentation
  // util.debugPrint('          m[16]', m, 32)
  for (i = 0; i < 10; i++) {
    // util.debugPrint('   (i=' + i + ')  v[16]', v, 32)
    B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]])
    B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]])
    B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]])
    B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]])
    B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]])
    B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]])
    B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]])
    B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]])
  }
  // util.debugPrint('   (i=10) v[16]', v, 32)

  for (i = 0; i < 8; i++) {
    ctx.h[i] ^= v[i] ^ v[i + 8]
  }
  // util.debugPrint('h[8]', ctx.h, 32)
}

// Creates a BLAKE2s hashing context
// Requires an output length between 1 and 32 bytes
// Takes an optional Uint8Array key
function blake2sInit (outlen, key) {
  if (!(outlen > 0 && outlen <= 32)) {
    throw new Error('Incorrect output length, should be in [1, 32]')
  }
  var keylen = key ? key.length : 0
  if (key && !(keylen > 0 && keylen <= 32)) {
    throw new Error('Incorrect key length, should be in [1, 32]')
  }

  var ctx = {
    h: new Uint32Array(BLAKE2S_IV), // hash state
    b: new Uint32Array(64), // input block
    c: 0, // pointer within block
    t: 0, // input count
    outlen: outlen // output length in bytes
  }
  ctx.h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen

  if (keylen > 0) {
    blake2sUpdate(ctx, key)
    ctx.c = 64 // at the end
  }

  return ctx
}

// Updates a BLAKE2s streaming hash
// Requires hash context and Uint8Array (byte array)
function blake2sUpdate (ctx, input) {
  for (var i = 0; i < input.length; i++) {
    if (ctx.c === 64) { // buffer full ?
      ctx.t += ctx.c // add counters
      blake2sCompress(ctx, false) // compress (not last)
      ctx.c = 0 // counter to zero
    }
    ctx.b[ctx.c++] = input[i]
  }
}

// Completes a BLAKE2s streaming hash
// Returns a Uint8Array containing the message digest
function blake2sFinal (ctx) {
  ctx.t += ctx.c // mark last block offset
  while (ctx.c < 64) { // fill up with zeros
    ctx.b[ctx.c++] = 0
  }
  blake2sCompress(ctx, true) // final block flag = 1

  // little endian convert and store
  var out = new Uint8Array(ctx.outlen)
  for (var i = 0; i < ctx.outlen; i++) {
    out[i] = (ctx.h[i >> 2] >> (8 * (i & 3))) & 0xFF
  }
  return out
}

// Computes the BLAKE2S hash of a string or byte array, and returns a Uint8Array
//
// Returns a n-byte Uint8Array
//
// Parameters:
// - input - the input bytes, as a string, Buffer, or Uint8Array
// - key - optional key Uint8Array, up to 32 bytes
// - outlen - optional output length in bytes, default 64
function blake2s (input, key, outlen) {
  // preprocess inputs
  outlen = outlen || 32
  input = util.normalizeInput(input)

  // do the math
  var ctx = blake2sInit(outlen, key)
  blake2sUpdate(ctx, input)
  return blake2sFinal(ctx)
}

// Computes the BLAKE2S hash of a string or byte array
//
// Returns an n-byte hash in hex, all lowercase
//
// Parameters:
// - input - the input bytes, as a string, Buffer, or Uint8Array
// - key - optional key Uint8Array, up to 32 bytes
// - outlen - optional output length in bytes, default 64
function blake2sHex (input, key, outlen) {
  var output = blake2s(input, key, outlen)
  return util.toHex(output)
}

module.exports = {
  blake2s: blake2s,
  blake2sHex: blake2sHex,
  blake2sInit: blake2sInit,
  blake2sUpdate: blake2sUpdate,
  blake2sFinal: blake2sFinal
}

      };
    };
  }
}, {package:"blakejs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/blake2s.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/blake2b.js", {"./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/blake2b.js
      return function (require, module, exports) {
// Blake2B in pure Javascript
// Adapted from the reference implementation in RFC7693
// Ported to Javascript by DC - https://github.com/dcposch

var util = require('./util')

// 64-bit unsigned addition
// Sets v[a,a+1] += v[b,b+1]
// v should be a Uint32Array
function ADD64AA (v, a, b) {
  var o0 = v[a] + v[b]
  var o1 = v[a + 1] + v[b + 1]
  if (o0 >= 0x100000000) {
    o1++
  }
  v[a] = o0
  v[a + 1] = o1
}

// 64-bit unsigned addition
// Sets v[a,a+1] += b
// b0 is the low 32 bits of b, b1 represents the high 32 bits
function ADD64AC (v, a, b0, b1) {
  var o0 = v[a] + b0
  if (b0 < 0) {
    o0 += 0x100000000
  }
  var o1 = v[a + 1] + b1
  if (o0 >= 0x100000000) {
    o1++
  }
  v[a] = o0
  v[a + 1] = o1
}

// Little-endian byte access
function B2B_GET32 (arr, i) {
  return (arr[i] ^
  (arr[i + 1] << 8) ^
  (arr[i + 2] << 16) ^
  (arr[i + 3] << 24))
}

// G Mixing function
// The ROTRs are inlined for speed
function B2B_G (a, b, c, d, ix, iy) {
  var x0 = m[ix]
  var x1 = m[ix + 1]
  var y0 = m[iy]
  var y1 = m[iy + 1]

  ADD64AA(v, a, b) // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
  ADD64AC(v, a, x0, x1) // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits

  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
  var xor0 = v[d] ^ v[a]
  var xor1 = v[d + 1] ^ v[a + 1]
  v[d] = xor1
  v[d + 1] = xor0

  ADD64AA(v, c, d)

  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
  xor0 = v[b] ^ v[c]
  xor1 = v[b + 1] ^ v[c + 1]
  v[b] = (xor0 >>> 24) ^ (xor1 << 8)
  v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8)

  ADD64AA(v, a, b)
  ADD64AC(v, a, y0, y1)

  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
  xor0 = v[d] ^ v[a]
  xor1 = v[d + 1] ^ v[a + 1]
  v[d] = (xor0 >>> 16) ^ (xor1 << 16)
  v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16)

  ADD64AA(v, c, d)

  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
  xor0 = v[b] ^ v[c]
  xor1 = v[b + 1] ^ v[c + 1]
  v[b] = (xor1 >>> 31) ^ (xor0 << 1)
  v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1)
}

// Initialization Vector
var BLAKE2B_IV32 = new Uint32Array([
  0xF3BCC908, 0x6A09E667, 0x84CAA73B, 0xBB67AE85,
  0xFE94F82B, 0x3C6EF372, 0x5F1D36F1, 0xA54FF53A,
  0xADE682D1, 0x510E527F, 0x2B3E6C1F, 0x9B05688C,
  0xFB41BD6B, 0x1F83D9AB, 0x137E2179, 0x5BE0CD19
])

var SIGMA8 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,
  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,
  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,
  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,
  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,
  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,
  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,
  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,
  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3
]

// These are offsets into a uint64 buffer.
// Multiply them all by 2 to make them offsets into a uint32 buffer,
// because this is Javascript and we don't have uint64s
var SIGMA82 = new Uint8Array(SIGMA8.map(function (x) { return x * 2 }))

// Compression function. 'last' flag indicates last block.
// Note we're representing 16 uint64s as 32 uint32s
var v = new Uint32Array(32)
var m = new Uint32Array(32)
function blake2bCompress (ctx, last) {
  var i = 0

  // init work variables
  for (i = 0; i < 16; i++) {
    v[i] = ctx.h[i]
    v[i + 16] = BLAKE2B_IV32[i]
  }

  // low 64 bits of offset
  v[24] = v[24] ^ ctx.t
  v[25] = v[25] ^ (ctx.t / 0x100000000)
  // high 64 bits not supported, offset may not be higher than 2**53-1

  // last block flag set ?
  if (last) {
    v[28] = ~v[28]
    v[29] = ~v[29]
  }

  // get little-endian words
  for (i = 0; i < 32; i++) {
    m[i] = B2B_GET32(ctx.b, 4 * i)
  }

  // twelve rounds of mixing
  // uncomment the DebugPrint calls to log the computation
  // and match the RFC sample documentation
  // util.debugPrint('          m[16]', m, 64)
  for (i = 0; i < 12; i++) {
    // util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)
    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1])
    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3])
    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5])
    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7])
    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9])
    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11])
    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13])
    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15])
  }
  // util.debugPrint('   (i=12) v[16]', v, 64)

  for (i = 0; i < 16; i++) {
    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16]
  }
  // util.debugPrint('h[8]', ctx.h, 64)
}

// Creates a BLAKE2b hashing context
// Requires an output length between 1 and 64 bytes
// Takes an optional Uint8Array key
function blake2bInit (outlen, key) {
  if (outlen === 0 || outlen > 64) {
    throw new Error('Illegal output length, expected 0 < length <= 64')
  }
  if (key && key.length > 64) {
    throw new Error('Illegal key, expected Uint8Array with 0 < length <= 64')
  }

  // state, 'param block'
  var ctx = {
    b: new Uint8Array(128),
    h: new Uint32Array(16),
    t: 0, // input count
    c: 0, // pointer within buffer
    outlen: outlen // output length in bytes
  }

  // initialize hash state
  for (var i = 0; i < 16; i++) {
    ctx.h[i] = BLAKE2B_IV32[i]
  }
  var keylen = key ? key.length : 0
  ctx.h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen

  // key the hash, if applicable
  if (key) {
    blake2bUpdate(ctx, key)
    // at the end
    ctx.c = 128
  }

  return ctx
}

// Updates a BLAKE2b streaming hash
// Requires hash context and Uint8Array (byte array)
function blake2bUpdate (ctx, input) {
  for (var i = 0; i < input.length; i++) {
    if (ctx.c === 128) { // buffer full ?
      ctx.t += ctx.c // add counters
      blake2bCompress(ctx, false) // compress (not last)
      ctx.c = 0 // counter to zero
    }
    ctx.b[ctx.c++] = input[i]
  }
}

// Completes a BLAKE2b streaming hash
// Returns a Uint8Array containing the message digest
function blake2bFinal (ctx) {
  ctx.t += ctx.c // mark last block offset

  while (ctx.c < 128) { // fill up with zeros
    ctx.b[ctx.c++] = 0
  }
  blake2bCompress(ctx, true) // final block flag = 1

  // little endian convert and store
  var out = new Uint8Array(ctx.outlen)
  for (var i = 0; i < ctx.outlen; i++) {
    out[i] = ctx.h[i >> 2] >> (8 * (i & 3))
  }
  return out
}

// Computes the BLAKE2B hash of a string or byte array, and returns a Uint8Array
//
// Returns a n-byte Uint8Array
//
// Parameters:
// - input - the input bytes, as a string, Buffer or Uint8Array
// - key - optional key Uint8Array, up to 64 bytes
// - outlen - optional output length in bytes, default 64
function blake2b (input, key, outlen) {
  // preprocess inputs
  outlen = outlen || 64
  input = util.normalizeInput(input)

  // do the math
  var ctx = blake2bInit(outlen, key)
  blake2bUpdate(ctx, input)
  return blake2bFinal(ctx)
}

// Computes the BLAKE2B hash of a string or byte array
//
// Returns an n-byte hash in hex, all lowercase
//
// Parameters:
// - input - the input bytes, as a string, Buffer, or Uint8Array
// - key - optional key Uint8Array, up to 64 bytes
// - outlen - optional output length in bytes, default 64
function blake2bHex (input, key, outlen) {
  var output = blake2b(input, key, outlen)
  return util.toHex(output)
}

module.exports = {
  blake2b: blake2b,
  blake2bHex: blake2bHex,
  blake2bInit: blake2bInit,
  blake2bUpdate: blake2bUpdate,
  blake2bFinal: blake2bFinal
}

      };
    };
  }
}, {package:"blakejs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/blake2b.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-promise/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/is-promise/index.js
      return function (require, module, exports) {
module.exports = isPromise;

function isPromise(obj) {
  return obj && typeof obj.then === 'function';
}
      };
    };
  }
}, {package:"is-promise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-promise/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/promise/index.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","is-promise":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-promise/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/promise/index.js
      return function (require, module, exports) {
(function (process){(function (){
var isPromise = require('is-promise')

var nextTick;
if (typeof setImediate === 'function') nextTick = setImediate
else if (typeof process === 'object' && process && process.nextTick) nextTick = process.nextTick
else nextTick = function (cb) { setTimeout(cb, 0) }

var extensions = [];

module.exports = Promise
function Promise(fn) {
  if (!(this instanceof Promise)) {
    return typeof fn === 'function' ? new Promise(fn) : defer()
  }
  var isResolved = false
  var isFulfilled = false
  var value
  var waiting = []
  var running = false

  function next(skipTimeout) {
    if (waiting.length) {
      running = true
      waiting.shift()(skipTimeout || false)
    } else {
      running = false
    }
  }
  this.then = then;
  function then(cb, eb) {
    return new Promise(function (resolver) {
      function done(skipTimeout) {
        var callback = isFulfilled ? cb : eb
        if (typeof callback === 'function') {
          function timeoutDone() {
            var val;
            try {
              val = callback(value)
            } catch (ex) {
              resolver.reject(ex)
              return next()
            }
            resolver.fulfill(val);
            next(true);
          }
          if (skipTimeout) timeoutDone()
          else nextTick(timeoutDone)
        } else if (isFulfilled) {
          resolver.fulfill(value)
          next(skipTimeout)
        } else {
          resolver.reject(value)
          next(skipTimeout)
        }
      }
      waiting.push(done)
      if (isResolved && !running) next()
    });
  }
  
  (function () {
    function fulfill(val) {
      if (isResolved) return
      if (isPromise(val)) val.then(fulfill, reject)
      else {
        isResolved = isFulfilled = true
        value = val
        next()
      }
    }
    function reject(err) {
      if (isResolved) return
      isResolved = true
      isFulfilled = false
      value = err
      next()
    }
    var resolver = {fulfill: fulfill, reject: reject};
    for (var i = 0; i < extensions.length; i++) {
      extensions[i](this, resolver);
    }
    if (typeof fn === 'function') {
      try {
        fn(resolver)
      } catch (ex) {
        resolver.reject(ex);
      }
    }
  }());
}
function defer() {
  var resolver
  var promise = new Promise(function (res) { resolver = res })
  return {resolver: resolver, promise: promise}
}
Promise.use = function (extension) {
  extensions.push(extension);
};
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"promise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promise/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/on-end.js", {"./drain":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/drain.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/on-end.js
      return function (require, module, exports) {
'use strict'

var drain = require('./drain')

module.exports = function onEnd (done) {
  return drain(null, done)
}

      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/on-end.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/log.js", {"./drain":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/drain.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/log.js
      return function (require, module, exports) {
'use strict'

var drain = require('./drain')

module.exports = function log (done) {
  return drain(function (data) {
    console.log(data)
  }, done)
}

      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/log.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/find.js", {"../util/prop":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/util/prop.js","./drain":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/drain.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/find.js
      return function (require, module, exports) {
'use strict'

function id (e) { return e }
var prop = require('../util/prop')
var drain = require('./drain')

module.exports = function find (test, cb) {
  var ended = false
  if(!cb)
    cb = test, test = id
  else
    test = prop(test) || id

  return drain(function (data) {
    if(test(data)) {
      ended = true
      cb(null, data)
    return false
    }
  }, function (err) {
    if(ended) return //already called back
    cb(err === true ? null : err, null)
  })
}





      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/find.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/concat.js", {"./reduce":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/reduce.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/concat.js
      return function (require, module, exports) {
'use strict'

var reduce = require('./reduce')

module.exports = function concat (cb) {
  return reduce(function (a, b) {
    return a + b
  }, '', cb)
}

      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/concat.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/count.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/count.js
      return function (require, module, exports) {
'use strict'

module.exports = function count (max) {
  var i = 0; max = max || Infinity
  return function (end, cb) {
    if(end) return cb && cb(end)
    if(i > max)
      return cb(true)
    cb(null, i++)
  }
}



      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/count.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/infinite.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/infinite.js
      return function (require, module, exports) {
'use strict'
module.exports = function infinite (generate) {
  generate = generate || Math.random
  return function (end, cb) {
    if(end) return cb && cb(end)
    return cb(null, generate())
  }
}



      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/infinite.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/empty.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/empty.js
      return function (require, module, exports) {
'use strict'
//a stream that ends immediately.
module.exports = function empty () {
  return function (abort, cb) {
    cb(true)
  }
}

      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/empty.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/error.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/error.js
      return function (require, module, exports) {
'use strict'
//a stream that errors immediately.
module.exports = function error (err) {
  return function (abort, cb) {
    cb(err)
  }
}


      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/error.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/keys.js", {"./values":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/values.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/keys.js
      return function (require, module, exports) {
'use strict'
var values = require('./values')
module.exports = function (object) {
  return values(Object.keys(object))
}



      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sources/keys.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/through.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/through.js
      return function (require, module, exports) {
'use strict'

//a pass through stream that doesn't change the value.
module.exports = function through (op, onEnd) {
  var a = false

  function once (abort) {
    if(a || !onEnd) return
    a = true
    onEnd(abort === true ? null : abort)
  }

  return function (read) {
    return function (end, cb) {
      if(end) once(end)
      return read(end, function (end, data) {
        if(!end) op && op(data)
        else once(end)
        cb(end, data)
      })
    }
  }
}

      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/through.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/take.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/take.js
      return function (require, module, exports) {
'use strict'

//read a number of items and then stop.
module.exports = function take (test, opts) {
  opts = opts || {}
  var last = opts.last || false // whether the first item for which !test(item) should still pass
  var ended = false
  if('number' === typeof test) {
    last = true
    var n = test; test = function () {
      return --n
    }
  }

  return function (read) {

    function terminate (cb) {
      read(true, function (err) {
        last = false; cb(err || true)
      })
    }

    return function (end, cb) {
      if(ended && !end) last ? terminate(cb) : cb(ended)
      else if(ended = end) read(ended, cb)
      else
        read(null, function (end, data) {
          if(ended = ended || end) {
            //last ? terminate(cb) :
            cb(ended)
          }
          else if(!test(data)) {
            ended = true
            last ? cb(null, data) : terminate(cb)
          }
          else
            cb(null, data)
        })
    }
  }
}

      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/take.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/filter-not.js", {"../util/tester":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/util/tester.js","./filter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/filter.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/filter-not.js
      return function (require, module, exports) {
'use strict'

var tester = require('../util/tester')
var filter = require('./filter')

module.exports = function filterNot (test) {
  test = tester(test)
  return filter(function (data) { return !test(data) })
}

      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/filter-not.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/unique.js", {"../util/prop":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/util/prop.js","./filter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/filter.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/unique.js
      return function (require, module, exports) {
'use strict'

function id (e) { return e }
var prop = require('../util/prop')
var filter = require('./filter')

//drop items you have already seen.
module.exports = function unique (field, invert) {
  field = prop(field) || id
  var seen = {}
  return filter(function (data) {
    var key = field(data)
    if(seen[key]) return !!invert //false, by default
    else seen[key] = true
    return !invert //true by default
  })
}


      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/unique.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/non-unique.js", {"./unique":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/unique.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/non-unique.js
      return function (require, module, exports) {
'use strict'

var unique = require('./unique')

//passes an item through when you see it for the second time.
module.exports = function nonUnique (field) {
  return unique(field, true)
}

      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/non-unique.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/node_modules/uuid/v4.js", {"./lib/bytesToUuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/node_modules/uuid/lib/bytesToUuid.js","./lib/rng":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/node_modules/uuid/lib/rng-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/node_modules/uuid/v4.js
      return function (require, module, exports) {
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

      };
    };
  }
}, {package:"uuid",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/node_modules/uuid/v4.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/source.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/source.js
      return function (require, module, exports) {

module.exports = function () {
  var _read, _cb, abortCb, _end

  var read = function (end, cb) {
    if(!_read) {
      if(end) {
        _end = end
        abortCb = cb
      }
      else
        _cb = cb
    }
    else _read(end, cb)
  }
  read.resolve = function (read) {
    if(_read) throw new Error('already resolved')
    _read = read
    if(!_read) throw new Error('no read cannot resolve!' + _read)
    if(_cb) read(null, _cb)
    if(abortCb) read(_end, abortCb)
  }
  read.abort = function(err) {
    read.resolve(function (_, cb) {
      cb(err || true)
    })
  }
  return read
}


      };
    };
  }
}, {package:"pull-defer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/source.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/someLimit.js", {"./internal/createTester":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/createTester.js","./internal/doParallelLimit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/doParallelLimit.js","lodash/identity":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/identity.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/someLimit.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createTester = require('./internal/createTester');

var _createTester2 = _interopRequireDefault(_createTester);

var _doParallelLimit = require('./internal/doParallelLimit');

var _doParallelLimit2 = _interopRequireDefault(_doParallelLimit);

var _identity = require('lodash/identity');

var _identity2 = _interopRequireDefault(_identity);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.
 *
 * @name someLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.some]{@link module:Collections.some}
 * @alias anyLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in parallel.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 */
exports.default = (0, _doParallelLimit2.default)((0, _createTester2.default)(Boolean, _identity2.default));
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/someLimit.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-pubsub/src/index.js", {"./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-pubsub/src/utils.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-pubsub/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const { Key } = require('interface-datastore')
const { encodeBase32, keyToTopic, topicToKey } = require('./utils')

const errcode = require('err-code')
const assert = require('assert')
const debug = require('debug')
const log = debug('datastore-pubsub:publisher')
log.error = debug('datastore-pubsub:publisher:error')

// DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with
// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}
class DatastorePubsub {
  /**
   * Creates an instance of DatastorePubsub.
   * @param {*} pubsub - pubsub implementation.
   * @param {*} datastore - datastore instance.
   * @param {*} peerId - peer-id instance.
   * @param {Object} validator - validator functions.
   * @param {function(record, peerId, callback)} validator.validate - function to validate a record.
   * @param {function(received, current, callback)} validator.select - function to select the newest between two records.
   * @param {function(key, callback)} subscriptionKeyFn - optional function to manipulate the key topic received before processing it.
   * @memberof DatastorePubsub
   */
  constructor (pubsub, datastore, peerId, validator, subscriptionKeyFn) {
    assert.strictEqual(typeof validator, 'object', 'missing validator')
    assert.strictEqual(typeof validator.validate, 'function', 'missing validate function')
    assert.strictEqual(typeof validator.select, 'function', 'missing select function')
    subscriptionKeyFn && assert.strictEqual(typeof subscriptionKeyFn, 'function', 'invalid subscriptionKeyFn received')

    this._pubsub = pubsub
    this._datastore = datastore
    this._peerId = peerId
    this._validator = validator
    this._handleSubscriptionKeyFn = subscriptionKeyFn

    // Bind _onMessage function, which is called by pubsub.
    this._onMessage = this._onMessage.bind(this)
  }

  /**
   * Publishes a value through pubsub.
   * @param {Buffer} key identifier of the value to be published.
   * @param {Buffer} val value to be propagated.
   * @param {function(Error)} callback
   * @returns {void}
   */
  put (key, val, callback) {
    if (!Buffer.isBuffer(key)) {
      const errMsg = `datastore key does not have a valid format`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY'))
    }

    if (!Buffer.isBuffer(val)) {
      const errMsg = `received value is not a buffer`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_INVALID_VALUE_RECEIVED'))
    }

    const stringifiedTopic = keyToTopic(key)

    log(`publish value for topic ${stringifiedTopic}`)

    // Publish record to pubsub
    this._pubsub.publish(stringifiedTopic, val, callback)
  }

  /**
   * Try to subscribe a topic with Pubsub and returns the local value if available.
   * @param {Buffer} key identifier of the value to be subscribed.
   * @param {function(Error, Buffer)} callback
   * @returns {void}
   */
  get (key, callback) {
    if (!Buffer.isBuffer(key)) {
      const errMsg = `datastore key does not have a valid format`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY'))
    }

    const stringifiedTopic = keyToTopic(key)

    this._pubsub.ls((err, res) => {
      if (err) {
        return callback(err)
      }

      // If already subscribed, just try to get it
      if (res && Array.isArray(res) && res.indexOf(stringifiedTopic) > -1) {
        return this._getLocal(key, callback)
      }

      // Subscribe
      this._pubsub.subscribe(stringifiedTopic, this._onMessage, (err) => {
        if (err) {
          const errMsg = `cannot subscribe topic ${stringifiedTopic}`

          log.error(errMsg)
          return callback(errcode(new Error(errMsg), 'ERR_SUBSCRIBING_TOPIC'))
        }
        log(`subscribed values for key ${stringifiedTopic}`)

        this._getLocal(key, callback)
      })
    })
  }

  /**
   * Unsubscribe topic.
   * @param {Buffer} key identifier of the value to unsubscribe.
   * @returns {void}
   */
  unsubscribe (key) {
    const stringifiedTopic = keyToTopic(key)

    this._pubsub.unsubscribe(stringifiedTopic, this._onMessage)
  }

  // Get record from local datastore
  _getLocal (key, callback) {
    // encode key - base32(/ipns/{cid})
    const routingKey = new Key('/' + encodeBase32(key), false)

    this._datastore.get(routingKey, (err, dsVal) => {
      if (err) {
        if (err.code !== 'ERR_NOT_FOUND') {
          const errMsg = `unexpected error getting the ipns record for ${routingKey.toString()}`

          log.error(errMsg)
          return callback(errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD'))
        }
        const errMsg = `local record requested was not found for ${routingKey.toString()}`

        log.error(errMsg)
        return callback(errcode(new Error(errMsg), 'ERR_NOT_FOUND'))
      }

      if (!Buffer.isBuffer(dsVal)) {
        const errMsg = `found record that we couldn't convert to a value`

        log.error(errMsg)
        return callback(errcode(new Error(errMsg), 'ERR_INVALID_RECORD_RECEIVED'))
      }

      callback(null, dsVal)
    })
  }

  // handles pubsub subscription messages
  _onMessage (msg) {
    const { data, from, topicIDs } = msg
    let key
    try {
      key = topicToKey(topicIDs[0])
    } catch (err) {
      log.error(err)
      return
    }

    log(`message received for ${key} topic`)

    // Stop if the message is from the peer (it already stored it while publishing to pubsub)
    if (from === this._peerId.toB58String()) {
      log(`message discarded as it is from the same peer`)
      return
    }

    if (this._handleSubscriptionKeyFn) {
      this._handleSubscriptionKeyFn(key, (err, res) => {
        if (err) {
          log.error('message discarded by the subscriptionKeyFn')
          return
        }

        this._storeIfSubscriptionIsBetter(res, data)
      })
    } else {
      this._storeIfSubscriptionIsBetter(key, data)
    }
  }

  // Store the received record if it is better than the current stored
  _storeIfSubscriptionIsBetter (key, data) {
    this._isBetter(key, data, (err, res) => {
      if (!err && res) {
        this._storeRecord(Buffer.from(key), data)
      }
    })
  }

  // Validate record according to the received validation function
  _validateRecord (value, peerId, callback) {
    this._validator.validate(value, peerId, callback)
  }

  // Select the best record according to the received select function.
  _selectRecord (receivedRecord, currentRecord, callback) {
    this._validator.select(receivedRecord, currentRecord, (err, res) => {
      if (err) {
        log.error(err)
        return callback(err)
      }

      // If the selected was the first (0), it should be stored (true)
      callback(null, res === 0)
    })
  }

  // Verify if the record received through pubsub is valid and better than the one currently stored
  _isBetter (key, val, callback) {
    // validate received record
    this._validateRecord(val, key, (err, valid) => {
      // If not valid, it is not better than the one currently available
      if (err || !valid) {
        const errMsg = 'record received through pubsub is not valid'

        log.error(errMsg)
        return callback(errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD'))
      }

      // Get Local record
      const dsKey = new Key(key)

      this._getLocal(dsKey.toBuffer(), (err, currentRecord) => {
        // if the old one is invalid, the new one is *always* better
        if (err) {
          return callback(null, true)
        }

        // if the same record, do not need to store
        if (currentRecord.equals(val)) {
          return callback(null, false)
        }

        // verify if the received record should replace the current one
        this._selectRecord(val, currentRecord, callback)
      })
    })
  }

  // add record to datastore
  _storeRecord (key, data) {
    // encode key - base32(/ipns/{cid})
    const routingKey = new Key('/' + encodeBase32(key), false)

    this._datastore.put(routingKey, data, (err) => {
      if (err) {
        log.error(`record for ${key.toString()} could not be stored in the routing`)
        return
      }

      log(`record for ${key.toString()} was stored in the datastore`)
    })
  }

  open (callback) {
    const errMsg = `open function was not implemented yet`

    log.error(errMsg)
    return callback(errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET'))
  }

  has (key, callback) {
    const errMsg = `has function was not implemented yet`

    log.error(errMsg)
    return callback(errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET'))
  }

  delete (key, callback) {
    const errMsg = `delete function was not implemented yet`

    log.error(errMsg)
    return callback(errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET'))
  }

  close (callback) {
    const errMsg = `close function was not implemented yet`

    log.error(errMsg)
    return callback(errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET'))
  }

  batch () {
    const errMsg = `batch function was not implemented yet`

    log.error(errMsg)
    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET')
  }

  query () {
    const errMsg = `query function was not implemented yet`

    log.error(errMsg)
    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET')
  }
}

exports = module.exports = DatastorePubsub

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"datastore-pubsub",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-pubsub/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/sanitize-filename/index.js", {"truncate-utf8-bytes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/truncate-utf8-bytes/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/sanitize-filename/index.js
      return function (require, module, exports) {
/*jshint node:true*/
'use strict';

/**
 * Replaces characters in strings that are illegal/unsafe for filenames.
 * Unsafe characters are either removed or replaced by a substitute set
 * in the optional `options` object.
 *
 * Illegal Characters on Various Operating Systems
 * / ? < > \ : * | "
 * https://kb.acronis.com/content/39790
 *
 * Unicode Control codes
 * C0 0x00-0x1f & C1 (0x80-0x9f)
 * http://en.wikipedia.org/wiki/C0_and_C1_control_codes
 *
 * Reserved filenames on Unix-based systems (".", "..")
 * Reserved filenames in Windows ("CON", "PRN", "AUX", "NUL", "COM1",
 * "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9",
 * "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", and
 * "LPT9") case-insesitively and with or without filename extensions.
 *
 * Capped at 255 characters in length.
 * http://unix.stackexchange.com/questions/32795/what-is-the-maximum-allowed-filename-and-folder-size-with-ecryptfs
 *
 * @param  {String} input   Original filename
 * @param  {Object} options {replacement: String | Function }
 * @return {String}         Sanitized filename
 */

var truncate = require("truncate-utf8-bytes");

var illegalRe = /[\/\?<>\\:\*\|"]/g;
var controlRe = /[\x00-\x1f\x80-\x9f]/g;
var reservedRe = /^\.+$/;
var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
var windowsTrailingRe = /[\. ]+$/;

function sanitize(input, replacement) {
  if (typeof input !== 'string') {
    throw new Error('Input must be string');
  }
  var sanitized = input
    .replace(illegalRe, replacement)
    .replace(controlRe, replacement)
    .replace(reservedRe, replacement)
    .replace(windowsReservedRe, replacement)
    .replace(windowsTrailingRe, replacement);
  return truncate(sanitized, 255);
}

module.exports = function (input, options) {
  var replacement = (options && options.replacement) || '';
  var output = sanitize(input, replacement);
  if (replacement === '') {
    return output;
  }
  return sanitize(output, '');
};

      };
    };
  }
}, {package:"sanitize-filename",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/sanitize-filename/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-keychain/src/cms.js", {"./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-keychain/src/util.js","async/detect":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/detect.js","async/series":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/series.js","async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","node-forge/lib/forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","node-forge/lib/pbe":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pbe.js","node-forge/lib/pkcs7":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pkcs7.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-keychain/src/cms.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const setImmediate = require('async/setImmediate')
const series = require('async/series')
const detect = require('async/detect')
const waterfall = require('async/waterfall')
require('node-forge/lib/pkcs7')
require('node-forge/lib/pbe')
const forge = require('node-forge/lib/forge')
const util = require('./util')
const errcode = require('err-code')

/**
 * Cryptographic Message Syntax (aka PKCS #7)
 *
 * CMS describes an encapsulation syntax for data protection. It
 * is used to digitally sign, digest, authenticate, or encrypt
 * arbitrary message content.
 *
 * See RFC 5652 for all the details.
 */
class CMS {
  /**
   * Creates a new instance with a keychain
   *
   * @param {Keychain} keychain - the available keys
   */
  constructor (keychain) {
    if (!keychain) {
      throw errcode(new Error('keychain is required'), 'ERR_KEYCHAIN_REQUIRED')
    }

    this.keychain = keychain
  }

  /**
   * Creates some protected data.
   *
   * The output Buffer contains the PKCS #7 message in DER.
   *
   * @param {string} name - The local key name.
   * @param {Buffer} plain - The data to encrypt.
   * @param {function(Error, Buffer)} callback
   * @returns {undefined}
   */
  encrypt (name, plain, callback) {
    const self = this
    const done = (err, result) => setImmediate(() => callback(err, result))

    if (!Buffer.isBuffer(plain)) {
      return done(errcode(new Error('Plain data must be a Buffer'), 'ERR_INVALID_PARAMS'))
    }

    series([
      (cb) => self.keychain.findKeyByName(name, cb),
      (cb) => self.keychain._getPrivateKey(name, cb)
    ], (err, results) => {
      if (err) return done(err)

      let key = results[0]
      let pem = results[1]
      try {
        const privateKey = forge.pki.decryptRsaPrivateKey(pem, self.keychain._())
        util.certificateForKey(key, privateKey, (err, certificate) => {
          if (err) return callback(err)

          // create a p7 enveloped message
          const p7 = forge.pkcs7.createEnvelopedData()
          p7.addRecipient(certificate)
          p7.content = forge.util.createBuffer(plain)
          p7.encrypt()

          // convert message to DER
          const der = forge.asn1.toDer(p7.toAsn1()).getBytes()
          done(null, Buffer.from(der, 'binary'))
        })
      } catch (err) {
        done(err)
      }
    })
  }

  /**
   * Reads some protected data.
   *
   * The keychain must contain one of the keys used to encrypt the data.  If none of the keys
   * exists, an Error is returned with the property 'missingKeys'.  It is array of key ids.
   *
   * @param {Buffer} cmsData - The CMS encrypted data to decrypt.
   * @param {function(Error, Buffer)} callback
   * @returns {undefined}
   */
  decrypt (cmsData, callback) {
    const done = (err, result) => setImmediate(() => callback(err, result))

    if (!Buffer.isBuffer(cmsData)) {
      return done(errcode(new Error('CMS data is required'), 'ERR_INVALID_PARAMS'))
    }

    const self = this
    let cms
    try {
      const buf = forge.util.createBuffer(cmsData.toString('binary'))
      const obj = forge.asn1.fromDer(buf)
      cms = forge.pkcs7.messageFromAsn1(obj)
    } catch (err) {
      return done(errcode(new Error('Invalid CMS: ' + err.message), 'ERR_INVALID_CMS'))
    }

    // Find a recipient whose key we hold. We only deal with recipient certs
    // issued by ipfs (O=ipfs).
    const recipients = cms.recipients
      .filter(r => r.issuer.find(a => a.shortName === 'O' && a.value === 'ipfs'))
      .filter(r => r.issuer.find(a => a.shortName === 'CN'))
      .map(r => {
        return {
          recipient: r,
          keyId: r.issuer.find(a => a.shortName === 'CN').value
        }
      })
    detect(
      recipients,
      (r, cb) => self.keychain.findKeyById(r.keyId, (err, info) => cb(null, !err && info)),
      (err, r) => {
        if (err) return done(err)
        if (!r) {
          const missingKeys = recipients.map(r => r.keyId)
          err = errcode(new Error('Decryption needs one of the key(s): ' + missingKeys.join(', ')), 'ERR_MISSING_KEYS', {
            missingKeys
          })
          return done(err)
        }

        waterfall([
          (cb) => self.keychain.findKeyById(r.keyId, cb),
          (key, cb) => self.keychain._getPrivateKey(key.name, cb)
        ], (err, pem) => {
          if (err) return done(err)

          const privateKey = forge.pki.decryptRsaPrivateKey(pem, self.keychain._())
          cms.decrypt(r.recipient, privateKey)
          done(null, Buffer.from(cms.content.getBytes(), 'binary'))
        })
      }
    )
  }
}

module.exports = CMS

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-keychain",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-keychain/src/cms.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/constants.js
      return function (require, module, exports) {
'use strict'

const SECOND = 1000

module.exports = {
  maxProvidersPerRequest: 3,
  providerRequestTimeout: 10 * SECOND,
  hasBlockTimeout: 15 * SECOND,
  provideTimeout: 15 * SECOND,
  kMaxPriority: Math.pow(2, 31) - 1,
  rebroadcastDelay: 10 * SECOND,
  maxListeners: 1000
}

      };
    };
  }
}, {package:"ipfs-bitswap",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/message/index.js", {"./entry":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/message/entry.js","./message.proto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/message/message.proto.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","async/each":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/each.js","async/nextTick":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","ipfs-block":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-block/src/index.js","lodash.isequalwith":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash.isequalwith/index.js","multicodec/src/name-table":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/name-table.js","multihashing-async":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/multihashing-async/src/index.js","protons":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/index.js","varint-decoder":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint-decoder/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/message/index.js
      return function (require, module, exports) {
'use strict'

const protons = require('protons')
const Block = require('ipfs-block')
const isEqualWith = require('lodash.isequalwith')
const assert = require('assert')
const each = require('async/each')
const nextTick = require('async/nextTick')
const CID = require('cids')
const codecName = require('multicodec/src/name-table')
const vd = require('varint-decoder')
const multihashing = require('multihashing-async')

const pbm = protons(require('./message.proto'))
const Entry = require('./entry')

class BitswapMessage {
  constructor (full) {
    this.full = full
    this.wantlist = new Map()
    this.blocks = new Map()
  }

  get empty () {
    return this.blocks.size === 0 &&
           this.wantlist.size === 0
  }

  addEntry (cid, priority, cancel) {
    assert(cid && CID.isCID(cid), 'must be a valid cid')
    const cidStr = cid.buffer.toString()

    const entry = this.wantlist.get(cidStr)

    if (entry) {
      entry.priority = priority
      entry.cancel = Boolean(cancel)
    } else {
      this.wantlist.set(cidStr, new Entry(cid, priority, cancel))
    }
  }

  addBlock (block) {
    assert(Block.isBlock(block), 'must be a valid cid')
    const cidStr = block.cid.buffer.toString()
    this.blocks.set(cidStr, block)
  }

  cancel (cid) {
    assert(CID.isCID(cid), 'must be a valid cid')
    const cidStr = cid.buffer.toString()
    this.wantlist.delete(cidStr)
    this.addEntry(cid, 0, true)
  }

  /*
   * Serializes to Bitswap Message protobuf of
   * version 1.0.0
   */
  serializeToBitswap100 () {
    const msg = {
      wantlist: {
        entries: Array.from(this.wantlist.values()).map((entry) => {
          return {
            block: entry.cid.buffer, // cid
            priority: Number(entry.priority),
            cancel: Boolean(entry.cancel)
          }
        })
      },
      blocks: Array.from(this.blocks.values())
        .map((block) => block.data)
    }

    if (this.full) {
      msg.wantlist.full = true
    }

    return pbm.Message.encode(msg)
  }

  /*
   * Serializes to Bitswap Message protobuf of
   * version 1.1.0
   */
  serializeToBitswap110 () {
    const msg = {
      wantlist: {
        entries: Array.from(this.wantlist.values()).map((entry) => {
          return {
            block: entry.cid.buffer, // cid
            priority: Number(entry.priority),
            cancel: Boolean(entry.cancel)
          }
        })
      },
      payload: []
    }

    if (this.full) {
      msg.wantlist.full = true
    }

    this.blocks.forEach((block) => {
      msg.payload.push({
        prefix: block.cid.prefix,
        data: block.data
      })
    })

    return pbm.Message.encode(msg)
  }

  equals (other) {
    const cmp = (a, b) => {
      if (a.equals && typeof a.equals === 'function') {
        return a.equals(b)
      }
    }

    if (this.full !== other.full ||
        !isEqualWith(this.wantlist, other.wantlist, cmp) ||
        !isEqualWith(this.blocks, other.blocks, cmp)
    ) {
      return false
    }

    return true
  }

  get [Symbol.toStringTag] () {
    const list = Array.from(this.wantlist.keys())
    const blocks = Array.from(this.blocks.keys())
    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`
  }
}

BitswapMessage.deserialize = (raw, callback) => {
  let decoded
  try {
    decoded = pbm.Message.decode(raw)
  } catch (err) {
    return nextTick(() => callback(err))
  }

  const isFull = (decoded.wantlist && decoded.wantlist.full) || false
  const msg = new BitswapMessage(isFull)

  if (decoded.wantlist) {
    decoded.wantlist.entries.forEach((entry) => {
      // note: entry.block is the CID here
      let cid
      try {
        cid = new CID(entry.block)
      } catch (err) {
        return callback(err)
      }
      msg.addEntry(cid, entry.priority, entry.cancel)
    })
  }

  // Bitswap 1.0.0
  // decoded.blocks are just the byte arrays
  if (decoded.blocks.length > 0) {
    return each(decoded.blocks, (b, cb) => {
      multihashing(b, 'sha2-256', (err, hash) => {
        if (err) {
          return cb(err)
        }
        let cid
        try {
          cid = new CID(hash)
        } catch (err) {
          return callback(err)
        }
        msg.addBlock(new Block(b, cid))
        cb()
      })
    }, (err) => {
      if (err) {
        return callback(err)
      }
      callback(null, msg)
    })
  }

  // Bitswap 1.1.0
  if (decoded.payload.length > 0) {
    return each(decoded.payload, (p, cb) => {
      if (!p.prefix || !p.data) {
        return nextTick(cb)
      }
      const values = vd(p.prefix)
      const cidVersion = values[0]
      const multicodec = values[1]
      const hashAlg = values[2]
      // const hashLen = values[3] // We haven't need to use this so far
      multihashing(p.data, hashAlg, (err, hash) => {
        if (err) {
          return cb(err)
        }

        let cid
        try {
          cid = new CID(cidVersion, codecName[multicodec.toString('16')], hash)
        } catch (err) {
          return cb(err)
        }

        msg.addBlock(new Block(p.data, cid))
        cb()
      })
    }, (err) => {
      if (err) {
        return callback(err)
      }
      callback(null, msg)
    })
  }

  callback(null, msg)
}

BitswapMessage.Entry = Entry
module.exports = BitswapMessage

      };
    };
  }
}, {package:"ipfs-bitswap",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/message/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/wantlist/index.js", {"../../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/utils.js","./entry":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/wantlist/entry.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/wantlist/index.js
      return function (require, module, exports) {
'use strict'

const { sortBy } = require('../../utils')
const Entry = require('./entry')

class Wantlist {
  constructor (stats) {
    this.set = new Map()
    this._stats = stats
  }

  get length () {
    return this.set.size
  }

  add (cid, priority) {
    const cidStr = cid.buffer.toString()
    const entry = this.set.get(cidStr)

    if (entry) {
      entry.inc()
      entry.priority = priority
    } else {
      this.set.set(cidStr, new Entry(cid, priority))
      if (this._stats) {
        this._stats.push(null, 'wantListSize', 1)
      }
    }
  }

  remove (cid) {
    const cidStr = cid.buffer.toString()
    const entry = this.set.get(cidStr)

    if (!entry) {
      return
    }

    entry.dec()

    // only delete when no refs are held
    if (entry.hasRefs()) {
      return
    }

    this.set.delete(cidStr)
    if (this._stats) {
      this._stats.push(null, 'wantListSize', -1)
    }
  }

  removeForce (cidStr) {
    if (this.set.has(cidStr)) {
      this.set.delete(cidStr)
    }
  }

  forEach (fn) {
    return this.set.forEach(fn)
  }

  entries () {
    return this.set.entries()
  }

  sortedEntries () {
    return new Map(sortBy(o => o[1].key, Array.from(this.set.entries())))
  }

  contains (cid) {
    const cidStr = cid.buffer.toString()
    return this.set.get(cidStr)
  }
}

Wantlist.Entry = Entry
module.exports = Wantlist

      };
    };
  }
}, {package:"ipfs-bitswap",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/wantlist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/just-debounce-it/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/just-debounce-it/index.js
      return function (require, module, exports) {
module.exports = debounce;

function debounce(fn, wait, callFirst) {
  var timeout;
  return function() {
    if (!wait) {
      return fn.apply(this, arguments);
    }
    var context = this;
    var args = arguments;
    var callNow = callFirst && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      timeout = null;
      if (!callNow) {
        return fn.apply(context, args);
      }
    }, wait);

    if (callNow) {
      return fn.apply(this, arguments);
    }
  };
}

      };
    };
  }
}, {package:"just-debounce-it",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/just-debounce-it/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/decision-engine/ledger.js", {"../types/wantlist":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/wantlist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/decision-engine/ledger.js
      return function (require, module, exports) {
'use strict'

const Wantlist = require('../types/wantlist')

class Ledger {
  constructor (peerId) {
    this.partner = peerId
    this.wantlist = new Wantlist()

    this.exchangeCount = 0
    this.sentToPeer = new Map()

    this.accounting = {
      bytesSent: 0,
      bytesRecv: 0
    }
  }

  sentBytes (n) {
    this.exchangeCount++
    this.lastExchange = (new Date()).getTime()
    this.accounting.bytesSent += n
  }

  receivedBytes (n) {
    this.exchangeCount++
    this.lastExchange = (new Date()).getTime()
    this.accounting.bytesRecv += n
  }

  wants (cid, priority) {
    this.wantlist.add(cid, priority)
  }

  cancelWant (cid) {
    this.wantlist.remove(cid)
  }

  wantlistContains (cid) {
    return this.wantlist.contains(cid)
  }

  debtRatio () {
    return (this.accounting.bytesSent / (this.accounting.bytesRecv + 1)) // +1 is to prevent division by zero
  }
}

module.exports = Ledger

      };
    };
  }
}, {package:"ipfs-bitswap",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/decision-engine/ledger.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/stats/stat.js", {"bignumber.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/node_modules/bignumber.js/bignumber.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","moving-average":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/moving-average/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/stats/stat.js
      return function (require, module, exports) {
'use strict'

const EventEmitter = require('events')
const Big = require('bignumber.js')
const MovingAverage = require('moving-average')

class Stats extends EventEmitter {
  constructor (initialCounters, options) {
    super()

    this._options = options
    this._queue = []
    this._stats = {}

    this._frequencyLastTime = Date.now()
    this._frequencyAccumulators = {}
    this._movingAverages = {}

    this._update = this._update.bind(this)

    initialCounters.forEach((key) => {
      this._stats[key] = Big(0)
      this._movingAverages[key] = {}
      this._options.movingAverageIntervals.forEach((interval) => {
        const ma = this._movingAverages[key][interval] = MovingAverage(interval)
        ma.push(this._frequencyLastTime, 0)
      })
    })

    this._enabled = this._options.enabled
  }

  enable () {
    this._enabled = true
  }

  disable () {
    this._disabled = true
  }

  stop () {
    if (this._timeout) {
      clearTimeout(this._timeout)
    }
  }

  get snapshot () {
    return Object.assign({}, this._stats)
  }

  get movingAverages () {
    return Object.assign({}, this._movingAverages)
  }

  push (counter, inc) {
    if (this._enabled) {
      this._queue.push([counter, inc, Date.now()])
      this._resetComputeTimeout()
    }
  }

  _resetComputeTimeout () {
    if (this._timeout) {
      clearTimeout(this._timeout)
    }
    this._timeout = setTimeout(this._update, this._nextTimeout())
  }

  _nextTimeout () {
    // calculate the need for an update, depending on the queue length
    const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize
    return Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0)
  }

  _update () {
    this._timeout = null
    if (this._queue.length) {
      let last
      while (this._queue.length) {
        const op = last = this._queue.shift()
        this._applyOp(op)
      }

      this._updateFrequency(last[2]) // contains timestamp of last op

      this.emit('update', this._stats)
    }
  }

  _updateFrequency (latestTime) {
    const timeDiff = latestTime - this._frequencyLastTime

    Object.keys(this._stats).forEach((key) => {
      this._updateFrequencyFor(key, timeDiff, latestTime)
    })

    this._frequencyLastTime = latestTime
  }

  _updateFrequencyFor (key, timeDiffMS, latestTime) {
    const count = this._frequencyAccumulators[key] || 0
    this._frequencyAccumulators[key] = 0
    const hz = (count / timeDiffMS) * 1000

    let movingAverages = this._movingAverages[key]
    if (!movingAverages) {
      movingAverages = this._movingAverages[key] = {}
    }
    this._options.movingAverageIntervals.forEach((movingAverageInterval) => {
      let movingAverage = movingAverages[movingAverageInterval]
      if (!movingAverage) {
        movingAverage = movingAverages[movingAverageInterval] = MovingAverage(movingAverageInterval)
      }
      movingAverage.push(latestTime, hz)
    })
  }

  _applyOp (op) {
    const key = op[0]
    const inc = op[1]

    if (typeof inc !== 'number') {
      throw new Error('invalid increment number:', inc)
    }

    let n

    if (!this._stats.hasOwnProperty(key)) {
      n = this._stats[key] = Big(0)
    } else {
      n = this._stats[key]
    }
    this._stats[key] = n.plus(inc)

    if (!this._frequencyAccumulators[key]) {
      this._frequencyAccumulators[key] = 0
    }
    this._frequencyAccumulators[key] += inc
  }
}

module.exports = Stats

      };
    };
  }
}, {package:"ipfs-bitswap",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/stats/stat.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/want-manager/msg-queue.js", {"../types/message":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/message/index.js","../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/utils.js","just-debounce-it":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/just-debounce-it/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/want-manager/msg-queue.js
      return function (require, module, exports) {
'use strict'

const debounce = require('just-debounce-it')

const Message = require('../types/message')
const logger = require('../utils').logger

module.exports = class MsgQueue {
  constructor (selfPeerId, otherPeerId, network) {
    this.peerId = otherPeerId
    this.network = network
    this.refcnt = 1

    this._entries = []
    this._log = logger(selfPeerId, 'msgqueue', otherPeerId.toB58String().slice(0, 8))
    this.sendEntries = debounce(this._sendEntries.bind(this), 200)
  }

  addMessage (msg) {
    if (msg.empty) {
      return
    }

    this.send(msg)
  }

  addEntries (entries) {
    this._entries = this._entries.concat(entries)
    this.sendEntries()
  }

  _sendEntries () {
    if (!this._entries.length) {
      return
    }

    const msg = new Message(false)
    this._entries.forEach((entry) => {
      if (entry.cancel) {
        msg.cancel(entry.cid)
      } else {
        msg.addEntry(entry.cid, entry.priority)
      }
    })
    this._entries = []
    this.addMessage(msg)
  }

  send (msg) {
    this.network.connectTo(this.peerId, (err) => {
      if (err) {
        this._log.error('cant connect to peer %s: %s', this.peerId.toB58String(), err.message)
        return
      }

      this._log('sending message')
      this.network.sendMessage(this.peerId, msg, (err) => {
        if (err) {
          this._log.error('send error: %s', err.message)
        }
      })
    })
  }
}

      };
    };
  }
}, {package:"ipfs-bitswap",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/want-manager/msg-queue.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-length-prefixed/src/index.js", {"./decode":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-length-prefixed/src/decode.js","./encode":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-length-prefixed/src/encode.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-length-prefixed/src/index.js
      return function (require, module, exports) {
'use strict'

const encode = require('./encode')
const d = require('./decode')

exports.encode = encode
exports.decode = d.decode
exports.decodeFromReader = d.decodeFromReader

      };
    };
  }
}, {package:"pull-length-prefixed",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-length-prefixed/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/record.js", {"../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","./record.proto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/record.proto.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/utils.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","protons":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/record.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const protons = require('protons')
const assert = require('assert')

const pb = protons(require('./record.proto')).Record
const utils = require('./utils')

class Record {
  /**
   * @param {Buffer} [key]
   * @param {Buffer} [value]
   * @param {Date} [recvtime]
   */
  constructor (key, value, recvtime) {
    if (key) {
      assert(Buffer.isBuffer(key), 'key must be a Buffer')
    }

    if (value) {
      assert(Buffer.isBuffer(value), 'value must be a buffer')
    }

    this.key = key
    this.value = value
    this.timeReceived = recvtime
  }

  /**
   * @returns {Buffer}
   */
  serialize () {
    return pb.encode(this.prepareSerialize())
  }

  /**
   * Return the object format ready to be given to the protobuf library.
   *
   * @returns {Object}
   */
  prepareSerialize () {
    return {
      key: this.key,
      value: this.value,
      timeReceived: this.timeReceived && utils.toRFC3339(this.timeReceived)
    }
  }

  /**
   * Decode a protobuf encoded record.
   *
   * @param {Buffer} raw
   * @returns {Record}
   */
  static deserialize (raw) {
    const dec = pb.decode(raw)
    return Record.fromDeserialized(dec)
  }

  /**
   * Create a record from the raw object returned from the protobuf library.
   *
   * @param {Object} obj
   * @returns {Record}
   */
  static fromDeserialized (obj) {
    let recvtime
    if (obj.timeReceived) {
      recvtime = utils.parseRFC3339(obj.timeReceived)
    }

    const rec = new Record(
      obj.key, obj.value, recvtime
    )

    return rec
  }
}

module.exports = Record

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

      };
    };
  }
}, {package:"libp2p-record",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/record.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/selection.js", {"./selectors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/selectors/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","buffer-split":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/buffer-split/index.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/selection.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const bsplit = require('buffer-split')
const errcode = require('err-code')

/**
 * Select the best record out of the given records.
 *
 * @param {Object} selectors
 * @param {Buffer} k
 * @param {Array<Buffer>} records
 * @returns {number} - The index of the best record.
 */
const bestRecord = (selectors, k, records) => {
  if (records.length === 0) {
    const errMsg = `No records given`

    throw errcode(new Error(errMsg), 'ERR_NO_RECORDS_RECEIVED')
  }

  const parts = bsplit(k, Buffer.from('/'))

  if (parts.length < 3) {
    const errMsg = `Record key does not have a selector function`

    throw errcode(new Error(errMsg), 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY')
  }

  const selector = selectors[parts[1].toString()]

  if (!selector) {
    const errMsg = `Unrecognized key prefix: ${parts[1]}`

    throw errcode(new Error(errMsg), 'ERR_UNRECOGNIZED_KEY_PREFIX')
  }

  return selector(k, records)
}

module.exports = {
  bestRecord: bestRecord,
  selectors: require('./selectors')
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-record",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/selection.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/validator.js", {"./validators":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/validators/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","buffer-split":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/buffer-split/index.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/validator.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const bsplit = require('buffer-split')
const errcode = require('err-code')

/**
 * Checks a record and ensures it is still valid.
 * It runs the needed validators.
 *
 * @param {Object} validators
 * @param {Record} record
 * @param {function(Error)} callback
 * @returns {undefined}
 */
const verifyRecord = (validators, record, callback) => {
  const key = record.key
  const parts = bsplit(key, Buffer.from('/'))

  if (parts.length < 3) {
    // No validator available
    return callback()
  }

  const validator = validators[parts[1].toString()]

  if (!validator) {
    const errMsg = `Invalid record keytype`

    return callback(errcode(new Error(errMsg), 'ERR_INVALID_RECORD_KEY_TYPE'))
  }

  validator.func(key, record.value, callback)
}

module.exports = {
  verifyRecord: verifyRecord,
  validators: require('./validators')
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-record",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/validator.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipns/src/utils.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipns/src/utils.js
      return function (require, module, exports) {
'use strict'

/**
 * Convert a JavaScript date into an `RFC3339Nano` formatted
 * string.
 *
 * @param {Date} time
 * @returns {string}
 */
module.exports.toRFC3339 = (time) => {
  const year = time.getUTCFullYear()
  const month = String(time.getUTCMonth() + 1).padStart(2, '0')
  const day = String(time.getUTCDate()).padStart(2, '0')
  const hour = String(time.getUTCHours()).padStart(2, '0')
  const minute = String(time.getUTCMinutes()).padStart(2, '0')
  const seconds = String(time.getUTCSeconds()).padStart(2, '0')
  const milliseconds = time.getUTCMilliseconds()
  const nanoseconds = milliseconds * 1000 * 1000

  return `${year}-${month}-${day}T${hour}:${minute}:${seconds}.${nanoseconds}Z`
}

/**
 * Parses a date string formatted as `RFC3339Nano` into a
 * JavaScript Date object.
 *
 * @param {string} time
 * @returns {Date}
 */
module.exports.parseRFC3339 = (time) => {
  const rfc3339Matcher = new RegExp(
    // 2006-01-02T
    '(\\d{4})-(\\d{2})-(\\d{2})T' +
    // 15:04:05
    '(\\d{2}):(\\d{2}):(\\d{2})' +
    // .999999999Z
    '\\.(\\d+)Z'
  )
  const m = String(time).trim().match(rfc3339Matcher)

  if (!m) {
    throw new Error('Invalid format')
  }

  const year = parseInt(m[1], 10)
  const month = parseInt(m[2], 10) - 1
  const date = parseInt(m[3], 10)
  const hour = parseInt(m[4], 10)
  const minute = parseInt(m[5], 10)
  const second = parseInt(m[6], 10)
  const millisecond = parseInt(m[7].slice(0, -6), 10)

  return new Date(Date.UTC(year, month, date, hour, minute, second, millisecond))
}

      };
    };
  }
}, {package:"ipns",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipns/src/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipns/src/errors.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipns/src/errors.js
      return function (require, module, exports) {
'use strict'

exports.ERR_IPNS_EXPIRED_RECORD = 'ERR_IPNS_EXPIRED_RECORD'
exports.ERR_UNRECOGNIZED_VALIDITY = 'ERR_UNRECOGNIZED_VALIDITY'
exports.ERR_SIGNATURE_CREATION = 'ERR_SIGNATURE_CREATION'
exports.ERR_SIGNATURE_VERIFICATION = 'ERR_SIGNATURE_VERIFICATION'
exports.ERR_UNRECOGNIZED_FORMAT = 'ERR_UNRECOGNIZED_FORMAT'
exports.ERR_PEER_ID_FROM_PUBLIC_KEY = 'ERR_PEER_ID_FROM_PUBLIC_KEY'
exports.ERR_PUBLIC_KEY_FROM_ID = 'ERR_PUBLIC_KEY_FROM_ID'
exports.ERR_UNDEFINED_PARAMETER = 'ERR_UNDEFINED_PARAMETER'

      };
    };
  }
}, {package:"ipns",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipns/src/errors.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/timestamp-nano/timestamp.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/timestamp-nano/timestamp.js
      return function (require, module, exports) {
/**
 * Timestamp for 64-bit time_t, nanosecond precision and strftime
 *
 * @author Yusuke Kawasaki
 * @license MIT
 * @see https://github.com/kawanet/timestamp-nano
 */

var Timestamp = (function() {
  if ("undefined" !== typeof module) module.exports = Timestamp;

  var SEC_DAY = 24 * 3600; // seconds per day
  var YEAR_SLOT = 3200; // years per slot
  var DAY_SLOT = (365 * 400 + 97) * YEAR_SLOT / 400; // days per slot
  var SEC_SLOT = SEC_DAY * DAY_SLOT; // seconds per slot
  var MSEC_SLOT = SEC_SLOT * 1000; // mseconds per slot

  // 15.9.1.1 Time Values and Time Range
  // The actual range of times supported by ECMAScript Date objects is
  // exactly –100,000,000 days to 100,000,000 days measured relative to
  // midnight at the beginning of 01 January, 1970 UTC.
  var MAX_MSEC = 1000 * 10000 * 10000 * SEC_DAY;

  var BIT24 = 0x1000000;
  var BIT32 = 0x10000 * 0x10000;
  var DEC6 = 1000 * 1000;
  var DEC9 = 1000 * 1000 * 1000;
  var ZERO9 = "000000000";

  var trunc = Math.trunc || Math_trunc;
  var P = Timestamp.prototype;

  // static methods
  Timestamp.fromDate = fromDate;
  Timestamp.fromInt64BE = buildFromInt64(0, 1, 2, 3, 0, 4);
  Timestamp.fromInt64LE = buildFromInt64(3, 2, 1, 0, 4, 0);
  Timestamp.fromString = fromString;
  Timestamp.fromTimeT = fromTimeT;

  // private properties
  P.year = 0; // Offset number for year precision
  P.time = 0; // Milliseconds from epoch
  P.nano = 0; // Offset number for nanosecond precision

  // instance methods
  P.addNano = addNano;
  P.getNano = getNano;
  P.getTimeT = getTimeT;
  P.getYear = getYear;
  P.toDate = toDate;
  P.toJSON = toJSON;
  P.toString = toString;
  P.writeInt64BE = buildWriteInt64(0, 1, 2, 3, 0, 4);
  P.writeInt64LE = buildWriteInt64(3, 2, 1, 0, 4, 0);

  var FMT_JSON = "%Y-%m-%dT%H:%M:%S.%NZ";

  var FMT_MONTH = [
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
  ];

  var FMT_DAY = [
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
  ];

  var FMT_STRING = {
    "%": "%",
    F: "%Y-%m-%d",
    n: "\n",
    R: "%H:%M",
    T: "%H:%M:%S",
    t: "\t",
    X: "%T",
    Z: "GMT",
    z: "+0000"
  };

  return Timestamp;

  function Timestamp(time, nano, year) {
    var ts = this;
    if (!(ts instanceof Timestamp)) return new Timestamp(time, nano, year);
    ts.time = +time || 0;
    ts.nano = +nano || 0;
    ts.year = +year || 0;
    normalize(ts);
  }

  function getYear() {
    var year = this.toDate().getUTCFullYear();
    return year + this.year;
  }

  function normalize(ts) {
    var year = ts.year;
    var time = ts.time;
    var nano = ts.nano;
    var changed;
    var slot;

    // normalize nano
    if (nano < 0 || DEC6 <= nano) {
      var n = Math.floor(nano / DEC6);
      nano -= n * DEC6;
      time += n;
      changed = 1;
    }

    var y = year % YEAR_SLOT;
    if (time < -MAX_MSEC || MAX_MSEC < time || y) {
      // shrink time into the minimal slot
      slot = trunc(time / MSEC_SLOT);
      if (slot) {
        year += slot * YEAR_SLOT;
        time -= slot * MSEC_SLOT;
      }

      // add year offset smaller than a slot
      var dt = newDate(time);
      dt.setUTCFullYear(y + dt.getUTCFullYear());
      year -= y;
      time = +dt;

      // use full range of 100 million days.
      slot = trunc(year / YEAR_SLOT);
      var total = time + slot * MSEC_SLOT;
      if (slot && -MAX_MSEC <= total && total <= MAX_MSEC) {
        year -= slot * YEAR_SLOT;
        time = total;
      }

      changed = 1;
    }

    if (changed) {
      ts.year = year;
      ts.time = time;
      ts.nano = nano;
    }

    return ts;
  }

  function toDate() {
    var ts = normalize(this);
    return newDate(ts.time);
  }

  function newDate(time) {
    var dt = new Date(0);
    dt.setTime(time);
    return dt;
  }

  function addNano(nano) {
    this.nano += +nano || 0;
    return this;
  }

  function getNano() {
    var ts = normalize(this);
    return ((ts.time % 1000) * DEC6 + (+ts.nano) + DEC9) % DEC9;
  }

  function fromString(string) {
    var time;
    var ts = new Timestamp();
    string += "";

    var array = string.replace(/^\s*[+\-]?\d+/, function(match) {
      var year = +match;
      // Use only years around 1970 to avoid Date's terrible behavior:
      // 15.9.4.3 Date.UTC
      // If y is not NaN and 0 <= y <= 99, then let yr be 1900+y
      var y = 1970 + ((year - 1970) % 400);
      ts.year = year - y;
      return y;
    }).replace(/(?:Z|([+\-]\d{2}):?(\d{2}))$/, function(match, hour, min) {
      // time zone
      if (hour < 0) min *= -1;
      time = ((+hour) * 60 + (+min)) * 60000;
      return "";
    }).replace(/\.\d+$/, function(match) {
      // nanoseconds
      ts.nano = +((match + ZERO9).substr(1, 9));
      return "";
    }).split(/\D+/);

    if (array.length > 1) {
      array[1]--; // month starts from 0
    } else {
      array[1] = 0;
    }

    ts.time = time = Date.UTC.apply(Date, array) - (time || 0);

    if (isNaN(time)) {
      throw new TypeError("Invalid Date");
    }

    return normalize(ts);
  }

  function fromDate(date) {
    return new Timestamp(+date);
  }

  function fromTimeT(time) {
    return fromTime(time, 0);
  }

  function fromTime(low, high) {
    high |= 0;
    high *= BIT32;
    low = +low || 0;

    // slot count
    var slot = trunc(high / SEC_SLOT) + trunc(low / SEC_SLOT);

    // seconds within slot
    var second = (high % SEC_SLOT) + (low % SEC_SLOT);

    // slot offset
    var offset = trunc(second / SEC_SLOT);
    if (offset) {
      slot += offset;
      second -= offset * SEC_SLOT;
    }

    return new Timestamp(second * 1000, 0, slot * YEAR_SLOT);
  }

  function getTimeT() {
    var ts = normalize(this);
    var time = Math.floor(ts.time / 1000);

    var year = ts.year;
    if (year) time += year * DAY_SLOT * SEC_DAY / YEAR_SLOT;

    // this may loose some bits over than 53 bit precision
    return time;
  }

  function toJSON() {
    return this.toString().replace(/0{1,6}Z$/, "Z");
  }

  function toString(format) {
    var ts = this;
    var dt = ts.toDate();
    var map = {
      H: H,
      L: L,
      M: M,
      N: N,
      S: S,
      Y: Y,
      a: a,
      b: b,
      d: d,
      e: e,
      m: m
    };

    return strftime(format || FMT_JSON);

    function strftime(format) {
      return format.replace(/%./g, function(match) {
        var m = match[1];
        var c = FMT_STRING[m];
        var f = map[m];
        return c ? strftime(c) : f ? f() : match;
      });
    }

    function Y() {
      var year = ts.getYear();
      if (year > 999999) {
        return "+" + year;
      } else if (year > 9999) {
        return "+" + pad(year, 6);
      } else if (year >= 0) {
        return pad(year, 4);
      } else if (year >= -999999) {
        return "-" + pad(-year, 6);
      } else {
        return year;
      }
    }

    function m() {
      return pad2(dt.getUTCMonth() + 1);
    }

    function d() {
      return pad2(dt.getUTCDate());
    }

    function e() {
      return padS(dt.getUTCDate());
    }

    function H() {
      return pad2(dt.getUTCHours());
    }

    function M() {
      return pad2(dt.getUTCMinutes());
    }

    function S() {
      return pad2(dt.getUTCSeconds());
    }

    function L() {
      return pad(dt.getUTCMilliseconds(), 3);
    }

    function N() {
      return pad(ts.getNano(), 9);
    }

    function a() {
      return FMT_DAY[dt.getUTCDay()];
    }

    function b() {
      return FMT_MONTH[dt.getUTCMonth()];
    }
  }

  function buildWriteInt64(pos0, pos1, pos2, pos3, posH, posL) {
    return writeInt64;

    function writeInt64(buffer, offset) {
      var ts = normalize(this);
      if (!buffer) buffer = new Array(8);
      checkRange(buffer, offset |= 0);

      var second = Math.floor(ts.time / 1000);
      var day = ts.year * (DAY_SLOT * SEC_DAY / YEAR_SLOT);
      var high = trunc(day / BIT32) + trunc(second / BIT32);
      var low = (day % BIT32) + (second % BIT32);

      // slot offset
      var slot = Math.floor(low / BIT32);
      if (slot) {
        high += slot;
        low -= slot * BIT32;
      }

      writeUint32(buffer, offset + posH, high);
      writeUint32(buffer, offset + posL, low);
      return buffer;
    }

    function writeUint32(buffer, offset, value) {
      buffer[offset + pos0] = (value >> 24) & 255;
      buffer[offset + pos1] = (value >> 16) & 255;
      buffer[offset + pos2] = (value >> 8) & 255;
      buffer[offset + pos3] = value & 255;
    }
  }

  function buildFromInt64(pos0, pos1, pos2, pos3, posH, posL) {
    return fromInt64;

    function fromInt64(buffer, offset) {
      checkRange(buffer, offset |= 0);
      var high = readUint32(buffer, offset + posH);
      var low = readUint32(buffer, offset + posL);
      return fromTime(low, high);
    }

    function readUint32(buffer, offset) {
      return (buffer[offset + pos0] * BIT24) +
        ((buffer[offset + pos1] << 16) |
          (buffer[offset + pos2] << 8) |
          buffer[offset + pos3]);
    }
  }

  function checkRange(buffer, offset) {
    var last = buffer && buffer.length;
    if (last == null) throw new TypeError("Invalid Buffer");
    if (last < offset + 8) throw new RangeError("Out of range");
  }

  function Math_trunc(x) {
    var n = x - x % 1;
    return n === 0 && (x < 0 || (x === 0 && (1 / x !== 1 / 0))) ? -0 : n;
  }

  function padS(v) {
    return (v > 9 ? "" : " ") + (v | 0);
  }

  function pad2(v) {
    return (v > 9 ? "" : "0") + (v | 0);
  }

  function pad(v, len) {
    return (ZERO9 + (v | 0)).substr(-len);
  }
})();

      };
    };
  }
}, {package:"timestamp-nano",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/timestamp-nano/timestamp.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipns/src/pb/ipns.proto.js", {"protons":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipns/src/pb/ipns.proto.js
      return function (require, module, exports) {
'use strict'

const protons = require('protons')

/* eslint-disable no-tabs */
const message = `
message IpnsEntry {
  enum ValidityType {
		EOL = 0; // setting an EOL says "this record is valid until..."
	}

  required bytes value = 1;
	required bytes signature = 2;

	optional ValidityType validityType = 3;
	optional bytes validity = 4;

	optional uint64 sequence = 5;

	optional uint64 ttl = 6;

	// in order for nodes to properly validate a record upon receipt, they need the public
	// key associated with it. For old RSA keys, its easiest if we just send this as part of
	// the record itself. For newer ed25519 keys, the public key can be embedded in the
	// peerID, making this field unnecessary.
	optional bytes pubKey = 7;
}
`

module.exports = protons(message).IpnsEntry

      };
    };
  }
}, {package:"ipns",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipns/src/pb/ipns.proto.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/codec.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/codec.js
      return function (require, module, exports) {
'use strict'

module.exports = '/mplex/6.7.0'

      };
    };
  }
}, {package:"pull-mplex",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/codec.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-abortable/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-abortable/index.js
      return function (require, module, exports) {
function abortable(onEnd) {
  var aborted = false, reading = false, ended = false, _cb, _read

  function doEnd () {
    if(!onEnd) return
    if(aborted && aborted !== true) return onEnd(aborted)
    if(ended && ended !== true) return onEnd(ended)
    return onEnd(null)
  }

  function terminate (err) {
    doEnd()
    var cb = _cb; _cb = null
    if(cb) cb(aborted || ended)
  }

  function cancel () {
    ended = ended || true
    terminate(aborted || ended)
    if(_read)
      _read(aborted, function (err) {
        if(_cb) _cb(err||aborted)
      })
  }

  function reader (read) {
    _read = read
    return function (abort, cb) {
      _cb = cb
      if(abort)   aborted = abort
      if(ended)   return cb(ended)
      if(aborted) return
      reading = true
      read(abort, function (end, data) {
        reading = false
        if(aborted) return !abort && read(aborted, function () {})
        if(!_cb) return
        var cb = _cb
        _cb = null
        if(end) {
          ended = aborted || end
          doEnd()
          cb(aborted || end)
        }
        else {
          cb(aborted || end, data)
        }
      })
    }
  }

  reader.abort = function (err) {
    if(ended) return
    aborted = err || true
    cancel()
  }

  return reader
}

module.exports = abortable




      };
    };
  }
}, {package:"pull-abortable",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-abortable/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/muxer.js", {"./codec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/codec.js","async/nextTick":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","interface-connection":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-connection/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/muxer.js
      return function (require, module, exports) {
'use strict'

const EventEmitter = require('events').EventEmitter
const Connection = require('interface-connection').Connection
const nextTick = require('async/nextTick')
const debug = require('debug')

const MULTIPLEX_CODEC = require('./codec')

const log = debug('libp2p-mplex:muxer')
log.err = debug('libp2p-mplex:muxer:error')

function noop () {}

class MultiplexMuxer extends EventEmitter {
  /**
   * @constructor
   * @param {Connection} conn
   * @param {Mplex} multiplex
   */
  constructor (conn, multiplex) {
    super()
    this.conn = conn
    this.multiplex = multiplex
    this.multicodec = MULTIPLEX_CODEC

    multiplex.on('close', () => this.emit('close'))
    multiplex.on('error', (err) => this.emit('error', err))

    multiplex.on('stream', (stream) => {
      // install default error handler so that it doesn't throw
      stream.on('error', (err) => {
        log.err('receiver stream errored', err)
      })
      this.emit('stream', new Connection(stream, this.conn))
    })
  }

  /**
   * Creates a new stream from the `Connection` used in creating the muxer
   * @param {function(Error, Connection)} callback
   * @returns {Connection}
   */
  newStream (callback) {
    callback = callback || noop
    let stream = this.multiplex.createStream()
    // install default error handler so that it doesn't throw
    stream.on('error', (err) => {
      log.err('initiator stream errored', err)
    })
    const conn = new Connection(stream, this.conn)
    nextTick(callback, null, conn)
    return conn
  }

  /**
   * Ends the connection and all of its streams
   * @param {function(Error)} callback
   * @returns {void}
   */
  end (callback) {
    callback = callback || noop
    if (this.multiplex.destroyed) {
      return nextTick(callback)
    }
    this.multiplex.once('close', callback)
    this.multiplex.close()
  }
}

module.exports = MultiplexMuxer

      };
    };
  }
}, {package:"pull-mplex",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/muxer.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/mplex.js", {"./channel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/channel.js","./coder":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/coder.js","./consts":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/consts.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/util/index.js","async/nextTick":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","looper":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/node_modules/looper/index.js","pull-pushable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-pushable/index.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js","pull-through":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-through/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/mplex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const pull = require('pull-stream')
const pushable = require('pull-pushable')
const through = require('pull-through')
const looper = require('looper')
const nextTick = require('async/nextTick')
const EE = require('events')
const debug = require('debug')

const { emitError, emitStream } = require('./util')
const { Types, MAX_MSG_SIZE } = require('./consts')
const Channel = require('./channel')
const coder = require('./coder')

const log = debug('pull-plex')
log.err = debug('pull-plex:err')

/**
 * @typedef {Object} Message
 * @property {number} id
 * @property {MessageType} type
 * @property {Buffer} data
 */

/**
 * @fires Mplex#close Emitted when Mplex closes
 * @fires Mplex#error Emitted when an error occurs
 * @fires Mplex#stream Emitted when a new stream is opened
 */
class Mplex extends EE {
  /**
   * @constructor
   * @param {Object} opts
   * @param {boolean} opts.initiator Is this starting the stream. Default: `true`
   * @param {function(Channel, number)} opts.onChan A handler for new streams. Can be used instead of `.on('stream')`
   * @param {number} opts.maxChannels Maximum number of channels to have open. Default: `10000`
   * @param {number} opts.maxMsgSize Maximum size messages are allowed to be. Default: `1 << 20` (1MB)
   * @param {boolean} opts.lazy Should channels be opened lazily? If false, channels will be opened when they are created. Default: `false`
   */
  constructor (opts) {
    super()

    if (typeof opts === 'boolean') {
      opts = { initiator: opts }
    }

    opts = {
      initiator: true,
      onChan: null,
      maxChannels: 10000,
      maxMsgSize: MAX_MSG_SIZE,
      lazy: false,
      ...opts
    }

    this._maxChannels = opts.maxChannels
    this._maxMsgSize = opts.maxMsgSize
    this._lazy = opts.lazy

    this._initiator = Boolean(opts.initiator)
    this._chanId = 0
    this._inChannels = new Array(this._maxChannels / 2)
    this._outChannels = new Array(this._maxChannels / 2)
    this._endedRemote = false // remote stream ended
    this._endedLocal = false // local stream ended

    this._chandata = pushable((err) => {
      this._log('mplex ended')
      this._endedRemote = true
      this.close(err)
    })

    if (opts.onChan) {
      this.on('stream', (chan) => opts.onChan(chan, chan.id))
    }

    this.source = pull(
      this._chandata,
      coder.encode()
    )

    const self = this
    this.sink = pull(
      through(function (data) {
        // ensure data is within our max size requirement
        if (data && data.length >= self._maxMsgSize) {
          nextTick(emitError, self, new Error('message too large!'))
          return this.queue(null)
        }
        this.queue(data)
      }),
      coder.decode(),
      (read) => {
        const next = looper(() => {
          read(null, (end, data) => {
            if (self._endedLocal) { return }
            if (end === true) { return self.close() }
            if (end) { return self.destroy(end) }
            self._handle(data)
            next()
          })
        })
        next()
      })
  }

  /**
   * A convenience wrapper for the log that adds useful metadata to logs
   * @private
   * @param {string} name The name of the operation being logged
   * @param {Buffer|string} data Logged with the metadata. Must be `.toString` capable. Default: `''`
   */
  _log (name, data) {
    log({
      op: name,
      initiator: this._initiator,
      endedLocal: this._endedLocal,
      endedRemote: this._endedRemote,
      data: (data && data.toString()) || ''
    })
  }

  get initiator () {
    return this._initiator
  }

  /**
   * Closes all open channels
   * @param {Error} err Optional error
   */
  close (err) {
    this._log('close', err)

    if (this.destroyed) { return }

    if (err) {
      nextTick(emitError, this, err)
    }

    err = err || 'Underlying stream has been closed'
    this._endedLocal = true

    // propagate close to channels
    const chans = Array.prototype.concat(this._outChannels, this._inChannels)
    for (let chan of chans) {
      if (chan) {
        chan.close(err)
      }
    }

    this.emit('close')
  }

  get destroyed () {
    return this._endedRemote && this._endedLocal
  }

  /**
   * Destroys the parent stream and closes Mplex
   * @param {Error} err
   */
  destroy (err) {
    err = err || new Error('Underlying stream has been closed')
    this._chandata.end(err)
    this.close(err)
  }

  /**
   * Pushes data to the stream
   * @param {Buffer} data
   */
  push (data) {
    if (data.data &&
      Buffer.byteLength(data.data) > this._maxMsgSize) {
      this._chandata.end(new Error('message too large!'))
    }

    this._chandata.push(data)
  }

  /**
   * Creates a new Channel (stream). If Mplex was created with `opts.lazy` set to true,
   * the channel will not automatically be opened.
   *
   * @param {string} name The name of the channel/stream to create
   * @returns {Channel}
   */
  createStream (name) {
    if (typeof name === 'number') { name = name.toString() }
    const chan = this._newStream(null, true, false, name, this._outChannels)
    if (!this._lazy) { chan.openChan(name) }
    return chan
  }

  /**
   * Attempts to create a channel if it doesn't already exist.
   * If a channel already exists for `id`, `Mplex#error` will be emitted.
   *
   * @private
   * @param {number} id The id of the channel. If `null` it will be auto incremented from `Mplex._chanId`
   * @param {boolean} initiator Is the channel creating the connection
   * @param {boolean} open Should the channel be opened when created
   * @param {string} name The name of the channel
   * @param {Array} list The channel list to add the channel to
   * @returns {Channel}
   */
  _newStream (id, initiator, open, name, list) {
    if (this.chanSize >= this._maxChannels) {
      this.emit('error', new Error('max channels exceeded'))
      return
    }

    if (typeof initiator === 'string') {
      name = initiator
      initiator = false
      open = false
    }

    if (typeof open === 'string') {
      name = open
      open = false
    }

    id = typeof id === 'number' ? id : this._chanId++
    if (list[id]) {
      this.emit('error', new Error(`channel with id ${id} already exist!`))
      return
    }
    const chan = new Channel({
      id,
      name,
      plex: this,
      initiator,
      open: open || false
    })

    return this._addChan(id, chan, list)
  }

  /**
   * A convenience method for setting the `chan` up to be tracked.
   * @private
   * @param {number} id The id of the channel
   * @param {Channel} chan The channel to track
   * @param {Array} list The channel list to add the channel to
   * @returns {Channel} `chan`
   */
  _addChan (id, chan, list) {
    chan.once('close', () => {
      list[id] = null
    })
    chan.once('error', (err) => {
      log.err('channel error', err)
    })

    list[id] = chan
    return chan
  }

  get chanSize () {
    return this._inChannels.size + this._outChannels.size
  }

  /**
   * Takes the appropriate course of action based on `msg.type`.
   * If `msg.type` is not recognized `Mplex#error` will be emitted.
   * @param {Message} msg
   */
  _handle (msg) {
    this._log('_handle', msg)
    const { id, type, data } = msg
    switch (type) {
      // Create a new stream
      case Types.NEW: {
        const chan = this._newStream(id, false, true, data.toString(), this._inChannels)
        nextTick(emitStream, this, chan, id)
        break
      }

      // Push the data into the channel with the matching id if it exists
      case Types.OUT_MESSAGE:
      case Types.IN_MESSAGE: {
        const list = type & 1 ? this._outChannels : this._inChannels
        const chan = list[id]
        if (chan) {
          chan.push(data)
        }
        break
      }

      // Close the channel with the matching id
      case Types.OUT_CLOSE:
      case Types.IN_CLOSE: {
        const list = type & 1 ? this._outChannels : this._inChannels
        const chan = list[id]
        if (chan) {
          chan.close()
        }
        break
      }

      // Destroys the channel with the matching id
      case Types.OUT_RESET:
      case Types.IN_RESET: {
        const list = type & 1 ? this._outChannels : this._inChannels
        const chan = list[id]
        if (chan) {
          chan.destroy()
        }
        break
      }

      default:
        nextTick(emitError, this, new Error('Invalid message type'))
    }
  }
}

module.exports = Mplex

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"pull-mplex",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-mplex/src/mplex.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websockets/src/listener.js", {"interface-connection":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-connection/src/index.js","multiaddr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js","os":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/os-browserify/browser.js","pull-ws/server":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/server.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websockets/src/listener.js
      return function (require, module, exports) {
'use strict'

const Connection = require('interface-connection').Connection
const multiaddr = require('multiaddr')
const os = require('os')

function noop () {}

const createServer = require('pull-ws/server') || noop

module.exports = (options, handler) => {
  const listener = createServer(options, (socket) => {
    socket.getObservedAddrs = (callback) => {
      // TODO research if we can reuse the address in anyway
      return callback(null, [])
    }

    handler(new Connection(socket))
  })

  let listeningMultiaddr

  listener._listen = listener.listen
  listener.listen = (ma, callback) => {
    callback = callback || noop
    listeningMultiaddr = ma

    if (ma.protoNames().includes('ipfs')) {
      ma = ma.decapsulate('ipfs')
    }

    listener._listen(ma.toOptions(), callback)
  }

  listener.getAddrs = (callback) => {
    const multiaddrs = []
    const address = listener.address()

    if (!address) {
      return callback(new Error('Listener is not ready yet'))
    }

    let ipfsId = listeningMultiaddr.getPeerId()

    // Because TCP will only return the IPv6 version
    // we need to capture from the passed multiaddr
    if (listeningMultiaddr.toString().indexOf('ip4') !== -1) {
      let m = listeningMultiaddr.decapsulate('tcp')
      m = m.encapsulate('/tcp/' + address.port + '/ws')
      if (listeningMultiaddr.getPeerId()) {
        m = m.encapsulate('/ipfs/' + ipfsId)
      }

      if (m.toString().indexOf('0.0.0.0') !== -1) {
        const netInterfaces = os.networkInterfaces()
        Object.keys(netInterfaces).forEach((niKey) => {
          netInterfaces[niKey].forEach((ni) => {
            if (ni.family === 'IPv4') {
              multiaddrs.push(multiaddr(m.toString().replace('0.0.0.0', ni.address)))
            }
          })
        })
      } else {
        multiaddrs.push(m)
      }
    }

    callback(null, multiaddrs)
  }

  return listener
}

      };
    };
  }
}, {package:"libp2p-websockets",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websockets/src/listener.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-connection/src/index.js", {"./connection":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-connection/src/connection.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-connection/src/index.js
      return function (require, module, exports) {
'use strict'

exports.Connection = require('./connection')

      };
    };
  }
}, {package:"interface-connection",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-connection/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/client.js", {"./duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/duplex.js","./web-socket":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/web-socket.js","./ws-url":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/ws-url.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/client.js
      return function (require, module, exports) {
'use strict';

//load websocket library if we are not in the browser
var WebSocket = require('./web-socket')
var duplex = require('./duplex')
var wsurl = require('./ws-url')

function isFunction (f) {
  return 'function' === typeof f
}

module.exports = function (addr, opts) {
  if (isFunction(opts)) opts = {onConnect: opts}

  var location = typeof window === 'undefined' ? {} : window.location

  var url = wsurl(addr, location)
  var socket = new WebSocket(url)

  var stream = duplex(socket, opts)
  stream.remoteAddress = url
  stream.close = function (cb) {
    if (isFunction(cb)) {
      socket.addEventListener('close', cb)
    }
    socket.close()
  }

  socket.addEventListener('open', function (e) {
    if (opts && isFunction(opts.onConnect)) {
      opts.onConnect(null, stream)
    }
  })

  return stream
}

module.exports.connect = module.exports

      };
    };
  }
}, {package:"pull-ws",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-ws/client.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/constants.js
      return function (require, module, exports) {
'use strict'

// MaxRecordAge specifies the maximum time that any node will hold onto a record
// from the time its received. This does not apply to any other forms of validity that
// the record may contain.
// For example, a record may contain an ipns entry with an EOL saying its valid
// until the year 2020 (a great time in the future). For that record to stick around
// it must be rebroadcasted more frequently than once every 'MaxRecordAge'

const second = exports.second = 1000
const minute = exports.minute = 60 * second
const hour = exports.hour = 60 * minute

exports.MAX_RECORD_AGE = 36 * hour

exports.PROTOCOL_DHT = '/ipfs/kad/1.0.0'

exports.PROVIDERS_KEY_PREFIX = '/providers/'

exports.PROVIDERS_LRU_CACHE_SIZE = 256

exports.PROVIDERS_VALIDITY = 24 * hour

exports.PROVIDERS_CLEANUP_INTERVAL = hour

exports.READ_MESSAGE_TIMEOUT = 10 * second

// The number of records that will be retrieved on a call to getMany()
exports.GET_MANY_RECORD_COUNT = 16

// K is the maximum number of requests to perform before returning failure
exports.K = 20

// Alpha is the concurrency for asynchronous requests
exports.ALPHA = 3

exports.maxMessageSize = 2 << 22 // 4MB

exports.defaultRandomWalk = {
  enabled: true,
  queriesPerPeriod: 1,
  interval: 5 * minute,
  timeout: 10 * second,
  delay: 10 * second
}

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query-manager.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query-manager.js
      return function (require, module, exports) {
'use strict'

/**
 * Keeps track of all running queries.
 */
class QueryManager {
  /**
   * Creates a new QueryManager.
   */
  constructor () {
    this.queries = new Set()
    this.running = false
  }

  /**
   * Called when a query is started.
   *
   * @param {Query} query
   */
  queryStarted (query) {
    this.queries.add(query)
  }

  /**
   * Called when a query completes.
   *
   * @param {Query} query
   */
  queryCompleted (query) {
    this.queries.delete(query)
  }

  /**
   * Starts the query manager.
   */
  start () {
    this.running = true
  }

  /**
   * Stops all queries.
   */
  stop () {
    this.running = false
    for (const query of this.queries) {
      query.stop()
    }
    this.queries.clear()
  }
}

module.exports = QueryManager

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query-manager.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/filter.js", {"./internal/doParallel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/doParallel.js","./internal/filter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/filter.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/filter.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _filter = require('./internal/filter');

var _filter2 = _interopRequireDefault(_filter);

var _doParallel = require('./internal/doParallel');

var _doParallel2 = _interopRequireDefault(_doParallel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns a new array of all the values in `coll` which pass an async truth
 * test. This operation is performed in parallel, but the results array will be
 * in the same order as the original.
 *
 * @name filter
 * @static
 * @memberOf module:Collections
 * @method
 * @alias select
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @example
 *
 * async.filter(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, results) {
 *     // results now equals an array of the existing files
 * });
 */
exports.default = (0, _doParallel2.default)(_filter2.default);
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/filter.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/timeout.js", {"./internal/initialParams":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/initialParams.js","./internal/wrapAsync":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/wrapAsync.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/timeout.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = timeout;

var _initialParams = require('./internal/initialParams');

var _initialParams2 = _interopRequireDefault(_initialParams);

var _wrapAsync = require('./internal/wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Sets a time limit on an asynchronous function. If the function does not call
 * its callback within the specified milliseconds, it will be called with a
 * timeout error. The code property for the error object will be `'ETIMEDOUT'`.
 *
 * @name timeout
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} asyncFn - The async function to limit in time.
 * @param {number} milliseconds - The specified time limit.
 * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)
 * to timeout Error for more information..
 * @returns {AsyncFunction} Returns a wrapped function that can be used with any
 * of the control flow functions.
 * Invoke this function with the same parameters as you would `asyncFunc`.
 * @example
 *
 * function myFunction(foo, callback) {
 *     doAsyncTask(foo, function(err, data) {
 *         // handle errors
 *         if (err) return callback(err);
 *
 *         // do some stuff ...
 *
 *         // return processed data
 *         return callback(null, data);
 *     });
 * }
 *
 * var wrapped = async.timeout(myFunction, 1000);
 *
 * // call `wrapped` as you would `myFunction`
 * wrapped({ bar: 'bar' }, function(err, data) {
 *     // if `myFunction` takes < 1000 ms to execute, `err`
 *     // and `data` will have their expected values
 *
 *     // else `err` will be an Error with the code 'ETIMEDOUT'
 * });
 */
function timeout(asyncFn, milliseconds, info) {
    var fn = (0, _wrapAsync2.default)(asyncFn);

    return (0, _initialParams2.default)(function (args, callback) {
        var timedOut = false;
        var timer;

        function timeoutCallback() {
            var name = asyncFn.name || 'anonymous';
            var error = new Error('Callback function "' + name + '" timed out.');
            error.code = 'ETIMEDOUT';
            if (info) {
                error.info = info;
            }
            timedOut = true;
            callback(error);
        }

        args.push(function () {
            if (!timedOut) {
                callback.apply(null, arguments);
                clearTimeout(timer);
            }
        });

        // setup timer and call original function
        timer = setTimeout(timeoutCallback, milliseconds);
        fn.apply(null, args);
    });
}
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/timeout.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/private.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/constants.js","./limited-peer-list":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/limited-peer-list.js","./message":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/message/index.js","./query":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query/index.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/utils.js","async/timeout":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/timeout.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","libp2p-record":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","peer-info":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/index.js","promise-to-callback":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promise-to-callback/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/private.js
      return function (require, module, exports) {
'use strict'

const PeerId = require('peer-id')
const libp2pRecord = require('libp2p-record')
const timeout = require('async/timeout')
const PeerInfo = require('peer-info')
const promisify = require('promisify-es6')
const promiseToCallback = require('promise-to-callback')
const errcode = require('err-code')

const utils = require('./utils')
const Message = require('./message')
const c = require('./constants')
const Query = require('./query')
const LimitedPeerList = require('./limited-peer-list')

const Record = libp2pRecord.Record

module.exports = (dht) => ({
  /**
   * Returns the routing tables closest peers, for the key of
   * the message.
   *
   * @param {Message} msg
   * @param {function(Error, Array<PeerInfo>)} callback
   * @returns {undefined}
   * @private
   */
  _nearestPeersToQuery (msg, callback) {
    promiseToCallback(this._nearestPeersToQueryAsync(msg))(callback)
  },

  async _nearestPeersToQueryAsync (msg) {
    const key = await promisify(utils.convertBuffer)(msg.key)

    const ids = dht.routingTable.closestPeers(key, dht.kBucketSize)
    return ids.map((p) => {
      if (dht.peerBook.has(p)) {
        return dht.peerBook.get(p)
      }
      return dht.peerBook.put(new PeerInfo(p))
    })
  },
  /**
   * Get the nearest peers to the given query, but iff closer
   * than self.
   *
   * @param {Message} msg
   * @param {PeerInfo} peer
   * @param {function(Error, Array<PeerInfo>)} callback
   * @returns {undefined}
   * @private
   */

  _betterPeersToQuery (msg, peer, callback) {
    promiseToCallback(this._betterPeersToQueryAsync(msg, peer))(callback)
  },

  async _betterPeersToQueryAsync (msg, peer) {
    dht._log('betterPeersToQuery')
    const closer = await dht._nearestPeersToQueryAsync(msg)

    return closer.filter((closer) => {
      if (dht._isSelf(closer.id)) {
        // Should bail, not sure
        dht._log.error('trying to return self as closer')
        return false
      }

      return !closer.id.isEqual(peer.id)
    })
  },

  /**
   * Try to fetch a given record by from the local datastore.
   * Returns the record iff it is still valid, meaning
   * - it was either authored by this node, or
   * - it was received less than `MAX_RECORD_AGE` ago.
   *
   * @param {Buffer} key
   * @param {function(Error, Record)} callback
   * @returns {undefined}
   *
   *@private
   */

  _checkLocalDatastore (key, callback) {
    promiseToCallback(this._checkLocalDatastoreAsync(key))(callback)
  },

  async _checkLocalDatastoreAsync (key) {
    dht._log('checkLocalDatastore: %b', key)
    const dsKey = utils.bufferToKey(key)

    // Fetch value from ds
    let rawRecord
    try {
      rawRecord = await promisify(cb => dht.datastore.get(dsKey, cb))()
    } catch (err) {
      if (err.code === 'ERR_NOT_FOUND') {
        return undefined
      }
      throw err
    }

    // Create record from the returned bytes
    const record = Record.deserialize(rawRecord)

    if (!record) {
      throw errcode('Invalid record', 'ERR_INVALID_RECORD')
    }

    // Check validity: compare time received with max record age
    if (record.timeReceived == null ||
        utils.now() - record.timeReceived > c.MAX_RECORD_AGE) {
      // If record is bad delete it and return
      await promisify(cb => dht.datastore.delete(dsKey, cb))()
      return undefined
    }

    // Record is valid
    return record
  },
  /**
   * Add the peer to the routing table and update it in the peerbook.
   *
   * @param {PeerInfo} peer
   * @param {function(Error)} callback
   * @returns {undefined}
   *
   * @private
   */

  _add (peer, callback) {
    promiseToCallback(this._addAsync(peer))(err => callback(err))
  },

  async _addAsync (peer) {
    peer = dht.peerBook.put(peer)
    await promisify(cb => dht.routingTable.add(peer.id, cb))()
    return undefined
  },
  /**
   * Verify a record without searching the DHT.
   *
   * @param {Record} record
   * @param {function(Error)} callback
   * @returns {undefined}
   *
   * @private
   */

  _verifyRecordLocally (record, callback) {
    promiseToCallback(this._verifyRecordLocallyAsync(record))(err => callback(err))
  },

  async _verifyRecordLocallyAsync (record) {
    dht._log('verifyRecordLocally')
    await promisify(cb => libp2pRecord.validator.verifyRecord(
      dht.validators,
      record,
      cb
    ))()
  },

  /**
   * Find close peers for a given peer
   *
   * @param {Buffer} key
   * @param {PeerId} peer
   * @param {function(Error, Array<PeerInfo>)} callback
   * @returns {void}
   *
   * @private
   */

  _closerPeersSingle (key, peer, callback) {
    promiseToCallback(this._closerPeersSingleAsync(key, peer))(callback)
  },

  async _closerPeersSingleAsync (key, peer) {
    dht._log('_closerPeersSingle %b from %s', key, peer.toB58String())
    const msg = await dht._findPeerSingleAsync(peer, new PeerId(key))
    return msg.closerPeers
      .filter((pInfo) => !dht._isSelf(pInfo.id))
      .map((pInfo) => dht.peerBook.put(pInfo))
  },

  /**
   * Is the given peer id our PeerId?
   *
   * @param {PeerId} other
   * @returns {bool}
   *
   * @private
   */

  _isSelf (other) {
    return other && dht.peerInfo.id.id.equals(other.id)
  },

  /**
   * Ask peer `peer` if they know where the peer with id `target` is.
   *
   * @param {PeerId} peer
   * @param {PeerId} target
   * @param {function(Error, Message)} callback
   * @returns {void}
   *
   * @private
   */

  _findPeerSingle (peer, target, callback) {
    promiseToCallback(this._findPeerSingleAsync(peer, target))(callback)
  },

  async _findPeerSingleAsync (peer, target) {
    dht._log('_findPeerSingle %s', peer.toB58String())
    const msg = new Message(Message.TYPES.FIND_NODE, target.id, 0)
    return promisify(callback => dht.network.sendRequest(peer, msg, callback))()
  },

  /**
   * Store the given key/value pair at the peer `target`.
   *
   * @param {Buffer} key
   * @param {Buffer} rec - encoded record
   * @param {PeerId} target
   * @param {function(Error)} callback
   * @returns {void}
   *
   * @private
   */

  _putValueToPeer (key, rec, target, callback) {
    promiseToCallback(this._putValueToPeerAsync(key, rec, target))(callback)
  },

  async _putValueToPeerAsync (key, rec, target) {
    const msg = new Message(Message.TYPES.PUT_VALUE, key, 0)
    msg.record = rec

    const resp = await promisify(cb => dht.network.sendRequest(target, msg, cb))()

    if (!resp.record.value.equals(Record.deserialize(rec).value)) {
      throw errcode(new Error('value not put correctly'), 'ERR_PUT_VALUE_INVALID')
    }
  },

  /**
   * Store the given key/value pair locally, in the datastore.
   * @param {Buffer} key
   * @param {Buffer} rec - encoded record
   * @param {function(Error)} callback
   * @returns {void}
   *
   * @private
   */

  _putLocal (key, rec, callback) {
    promiseToCallback(this._putLocalAsync(key, rec))(err => callback(err))
  },

  async _putLocalAsync (key, rec) {
    await promisify(cb => dht.datastore.put(utils.bufferToKey(key), rec, cb))()
    return undefined
  },

  /**
   * Get the value for given key.
   *
   * @param {Buffer} key
   * @param {Object} options - get options
   * @param {number} options.timeout - optional timeout (default: 60000)
   * @param {function(Error, Record)} callback
   * @returns {void}
   *
   * @private
   */

  _get (key, options, callback) {
    promiseToCallback(this._getAsync(key, options))(callback)
  },

  async _getAsync (key, options) {
    dht._log('_get %b', key)

    const vals = await promisify(cb => dht.getMany(key, c.GET_MANY_RECORD_COUNT, options, cb))()

    const recs = vals.map((v) => v.val)
    let i = 0

    try {
      i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs)
    } catch (err) {
      // Assume the first record if no selector available
      if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {
        throw err
      }
    }

    const best = recs[i]
    dht._log('GetValue %b %s', key, best)

    if (!best) {
      throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND')
    }

    await this._sendCorrectionRecord(key, vals, best)

    return best
  },

  /**
   * Send the best record found to any peers that have an out of date record.
   *
   * @param {Buffer} key
   * @param {Array<Object>} vals - values retrieved from the DHT
   * @param {Object} best - the best record that was found
   * @returns {Promise}
   *
   * @private
   */
  async _sendCorrectionRecord (key, vals, best) {
    const fixupRec = await promisify(cb => utils.createPutRecord(key, best, cb))()

    return Promise.all(vals.map(async (v) => {
      // no need to do anything
      if (v.val.equals(best)) {
        return
      }

      // correct ourself
      if (dht._isSelf(v.from)) {
        try {
          await dht._putLocalAsync(key, fixupRec)
        } catch (err) {
          dht._log.error('Failed error correcting self', err)
        }
        return
      }

      // send correction
      try {
        await dht._putValueToPeerAsync(key, fixupRec, v.from)
      } catch (err) {
        dht._log.error('Failed error correcting entry', err)
      }
    }))
  },

  /**
   * Attempt to retrieve the value for the given key from
   * the local datastore.
   *
   * @param {Buffer} key
   * @param {function(Error, Record)} callback
   * @returns {void}
   *
   * @private
   */
  _getLocal (key, callback) {
    promiseToCallback(this._getLocalAsync(key))(callback)
  },

  async _getLocalAsync (key) {
    dht._log('getLocal %b', key)

    const raw = await promisify(cb => dht.datastore.get(utils.bufferToKey(key), cb))()
    dht._log('found %b in local datastore', key)
    const rec = Record.deserialize(raw)

    await dht._verifyRecordLocallyAsync(rec)
    return rec
  },

  /**
   * Query a particular peer for the value for the given key.
   * It will either return the value or a list of closer peers.
   *
   * Note: The peerbook is updated with new addresses found for the given peer.
   *
   * @param {PeerId} peer
   * @param {Buffer} key
   * @param {function(Error, Redcord, Array<PeerInfo>)} callback
   * @returns {void}
   *
   * @private
   */

  _getValueOrPeers (peer, key, callback) {
    promiseToCallback(this._getValueOrPeersAsync(peer, key))((err, result) => {
      if (err) return callback(err)
      callback(null, result.record, result.peers)
    })
  },

  async _getValueOrPeersAsync (peer, key) {
    const msg = await promisify(cb => dht._getValueSingle(peer, key, cb))()

    const peers = msg.closerPeers
    const record = msg.record

    if (record) {
      // We have a record
      try {
        await dht._verifyRecordOnlineAsync(record)
      } catch (err) {
        const errMsg = 'invalid record received, discarded'
        dht._log(errMsg)
        throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD')
      }

      return { record, peers }
    }

    if (peers.length > 0) {
      return { peers }
    }

    throw errcode(new Error('Not found'), 'ERR_NOT_FOUND')
  },

  /**
   * Get a value via rpc call for the given parameters.
   *
   * @param {PeerId} peer
   * @param {Buffer} key
   * @param {function(Error, Message)} callback
   * @returns {void}
   *
   * @private
   */

  _getValueSingle (peer, key, callback) {
    promiseToCallback(this._getValueSingleAsync(peer, key))(callback)
  },

  async _getValueSingleAsync (peer, key) {
    const msg = new Message(Message.TYPES.GET_VALUE, key, 0)
    return promisify(cb => dht.network.sendRequest(peer, msg, cb))()
  },

  /**
   * Verify a record, fetching missing public keys from the network.
   * Calls back with an error if the record is invalid.
   *
   * @param {Record} record
   * @param {function(Error)} callback
   * @returns {void}
   *
   * @private
   */

  _verifyRecordOnline (record, callback) {
    promiseToCallback(this._verifyRecordOnlineAsync(record))(err => callback(err))
  },

  async _verifyRecordOnlineAsync (record) {
    await promisify(cb => libp2pRecord.validator.verifyRecord(dht.validators, record, cb))()
  },

  /**
   * Get the public key directly from a node.
   *
   * @param {PeerId} peer
   * @param {function(Error, PublicKey)} callback
   * @returns {void}
   *
   * @private
   */

  _getPublicKeyFromNode (peer, callback) {
    promiseToCallback(this._getPublicKeyFromNodeAsync(peer))(callback)
  },

  async _getPublicKeyFromNodeAsync (peer) {
    const pkKey = utils.keyForPublicKey(peer)
    // const msg = await dht._getValueSingleAsync(peer, pkKey)
    const msg = await promisify(cb => dht._getValueSingle(peer, pkKey, cb))()

    if (!msg.record || !msg.record.value) {
      throw errcode(`Node not responding with its public key: ${peer.toB58String()}`, 'ERR_INVALID_RECORD')
    }

    const recPeer = await promisify(cb => PeerId.createFromPubKey(msg.record.value, cb))()

    // compare hashes of the pub key
    if (!recPeer.isEqual(peer)) {
      throw errcode('public key does not match id', 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID')
    }

    return recPeer.pubKey
  },

  /**
   * Search the dht for up to `n` providers of the given CID.
   *
   * @param {CID} key
   * @param {number} providerTimeout - How long the query should maximally run in milliseconds.
   * @param {number} n
   * @param {function(Error, Array<PeerInfo>)} callback
   * @returns {void}
   *
   * @private
   */
  _findNProviders (key, providerTimeout, n, callback) {
    promiseToCallback(this._findNProvidersAsync(key, providerTimeout, n))(callback)
  },

  async _findNProvidersAsync (key, providerTimeout, n) {
    const out = new LimitedPeerList(n)

    const provs = await dht.providers.getProviders(key)

    provs.forEach((id) => {
      let info
      if (dht.peerBook.has(id)) {
        info = dht.peerBook.get(id)
      } else {
        info = dht.peerBook.put(new PeerInfo(id))
      }
      out.push(info)
    })

    // All done
    if (out.length >= n) {
      return out.toArray()
    }

    // need more, query the network
    const paths = []
    const query = new Query(dht, key.buffer, (pathIndex, numPaths) => {
      // This function body runs once per disjoint path
      const pathSize = utils.pathSize(n - out.length, numPaths)
      const pathProviders = new LimitedPeerList(pathSize)
      paths.push(pathProviders)

      // Here we return the query function to use on this particular disjoint path
      return async (peer) => {
        const msg = await dht._findProvidersSingleAsync(peer, key)
        const provs = msg.providerPeers
        dht._log('(%s) found %s provider entries', dht.peerInfo.id.toB58String(), provs.length)

        provs.forEach((prov) => {
          pathProviders.push(dht.peerBook.put(prov))
        })

        // hooray we have all that we want
        if (pathProviders.length >= pathSize) {
          return { pathComplete: true }
        }

        // it looks like we want some more
        return { closerPeers: msg.closerPeers }
      }
    })

    const peers = dht.routingTable.closestPeers(key.buffer, dht.kBucketSize)

    try {
      await promisify(callback => timeout((cb) => {
        promiseToCallback(query.run(peers))(cb)
      }, providerTimeout)(callback))()
    } catch (err) {
      if (err.code !== 'ETIMEDOUT') {
        throw err
      }
    } finally {
      query.stop()
    }

    // combine peers from each path
    paths.forEach((path) => {
      path.toArray().forEach((peer) => {
        out.push(peer)
      })
    })

    if (out.length === 0) {
      throw errcode(new Error('no providers found'), 'ERR_NOT_FOUND')
    }

    return out.toArray()
  },

  /**
   * Check for providers from a single node.
   *
   * @param {PeerId} peer
   * @param {CID} key
   * @param {function(Error, Message)} callback
   * @returns {void}
   *
   * @private
   */
  _findProvidersSingle (peer, key, callback) {
    promiseToCallback(this._findProvidersSingleAsync(peer, key))(callback)
  },

  async _findProvidersSingleAsync (peer, key) {
    const msg = new Message(Message.TYPES.GET_PROVIDERS, key.buffer, 0)
    return promisify(cb => dht.network.sendRequest(peer, msg, cb))()
  }
})

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/private.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/message/index.js", {"../../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","./dht.proto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/message/dht.proto.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","libp2p-record":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","peer-info":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/index.js","protons":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/message/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const assert = require('assert')
const PeerInfo = require('peer-info')
const PeerId = require('peer-id')
const protons = require('protons')
const Record = require('libp2p-record').Record

const pbm = protons(require('./dht.proto'))

const MESSAGE_TYPE = pbm.Message.MessageType
const CONNECTION_TYPE = pbm.Message.ConnectionType

/**
 * Represents a single DHT control message.
 */
class Message {
  /**
   * @param {MessageType} type
   * @param {Buffer} key
   * @param {number} level
   */
  constructor (type, key, level) {
    if (key) {
      assert(Buffer.isBuffer(key))
    }

    this.type = type
    this.key = key
    this._clusterLevelRaw = level
    this.closerPeers = []
    this.providerPeers = []
    this.record = null
  }

  /**
   * @type {number}
   */
  get clusterLevel () {
    const level = this._clusterLevelRaw - 1
    if (level < 0) {
      return 0
    }

    return level
  }

  set clusterLevel (level) {
    this._clusterLevelRaw = level
  }

  /**
   * Encode into protobuf
   * @returns {Buffer}
   */
  serialize () {
    const obj = {
      key: this.key,
      type: this.type,
      clusterLevelRaw: this._clusterLevelRaw,
      closerPeers: this.closerPeers.map(toPbPeer),
      providerPeers: this.providerPeers.map(toPbPeer)
    }

    if (this.record) {
      if (Buffer.isBuffer(this.record)) {
        obj.record = this.record
      } else {
        obj.record = this.record.serialize()
      }
    }

    return pbm.Message.encode(obj)
  }

  /**
   * Decode from protobuf
   *
   * @param {Buffer} raw
   * @returns {Message}
   */
  static deserialize (raw) {
    const dec = pbm.Message.decode(raw)

    const msg = new Message(dec.type, dec.key, dec.clusterLevelRaw)

    msg.closerPeers = dec.closerPeers.map(fromPbPeer)
    msg.providerPeers = dec.providerPeers.map(fromPbPeer)
    if (dec.record) {
      msg.record = Record.deserialize(dec.record)
    }

    return msg
  }
}

Message.TYPES = MESSAGE_TYPE
Message.CONNECTION_TYPES = CONNECTION_TYPE

function toPbPeer (peer) {
  const res = {
    id: peer.id.id,
    addrs: peer.multiaddrs.toArray().map((m) => m.buffer)
  }

  if (peer.isConnected()) {
    res.connection = CONNECTION_TYPE.CONNECTED
  } else {
    res.connection = CONNECTION_TYPE.NOT_CONNECTED
  }

  return res
}

function fromPbPeer (peer) {
  const info = new PeerInfo(new PeerId(peer.id))
  peer.addrs.forEach((a) => info.multiaddrs.add(a))

  return info
}

module.exports = Message

}).call(this)}).call(this,{"isBuffer":require("../../../is-buffer/index.js")})

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/message/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/providers.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/constants.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/utils.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","hashlru":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/hashlru/index.js","interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js","p-queue":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-queue/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js","pull-stream-to-async-iterator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream-to-async-iterator/index.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/providers.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const cache = require('hashlru')
const varint = require('varint')
const PeerId = require('peer-id')
const Key = require('interface-datastore').Key
const Queue = require('p-queue')
const promisify = require('promisify-es6')
const toIterator = require('pull-stream-to-async-iterator')

const c = require('./constants')
const utils = require('./utils')

/**
 * This class manages known providers.
 * A provider is a peer that we know to have the content for a given CID.
 *
 * Every `cleanupInterval` providers are checked if they
 * are still valid, i.e. younger than the `provideValidity`.
 * If they are not, they are deleted.
 *
 * To ensure the list survives restarts of the daemon,
 * providers are stored in the datastore, but to ensure
 * access is fast there is an LRU cache in front of that.
 */
class Providers {
  /**
   * @param {Object} datastore
   * @param {PeerId} [self]
   * @param {number} [cacheSize=256]
   */
  constructor (datastore, self, cacheSize) {
    this.datastore = datastore

    this._log = utils.logger(self, 'providers')

    /**
     * How often invalid records are cleaned. (in seconds)
     *
     * @type {number}
     */
    this.cleanupInterval = c.PROVIDERS_CLEANUP_INTERVAL

    /**
     * How long is a provider valid for. (in seconds)
     *
     * @type {number}
     */
    this.provideValidity = c.PROVIDERS_VALIDITY

    /**
     * LRU cache size
     *
     * @type {number}
     */
    this.lruCacheSize = cacheSize || c.PROVIDERS_LRU_CACHE_SIZE

    this.providers = cache(this.lruCacheSize)

    this.syncQueue = new Queue({ concurrency: 1 })
  }

  /**
   * Release any resources.
   *
   * @returns {undefined}
   */
  stop () {
    if (this._cleaner) {
      clearInterval(this._cleaner)
      this._cleaner = null
    }
  }

  /**
   * Check all providers if they are still valid, and if not delete them.
   *
   * @returns {Promise}
   *
   * @private
   */
  _cleanup () {
    return this.syncQueue.add(async () => {
      this._log('start cleanup')
      const start = Date.now()

      let count = 0
      let deleteCount = 0
      const deleted = new Map()
      const batch = this.datastore.batch()

      // Get all provider entries from the datastore
      const query = this.datastore.query({ prefix: c.PROVIDERS_KEY_PREFIX })
      for await (const entry of toIterator(query)) {
        try {
          // Add a delete to the batch for each expired entry
          const { cid, peerId } = parseProviderKey(entry.key)
          const time = readTime(entry.value)
          const now = Date.now()
          const delta = now - time
          const expired = delta > this.provideValidity
          this._log('comparing: %d - %d = %d > %d %s',
            now, time, delta, this.provideValidity, expired ? '(expired)' : '')
          if (expired) {
            deleteCount++
            batch.delete(entry.key)
            const peers = deleted.get(cid) || new Set()
            peers.add(peerId)
            deleted.set(cid, peers)
          }
          count++
        } catch (err) {
          this._log.error(err.message)
        }
      }
      this._log('deleting %d / %d entries', deleteCount, count)

      // Commit the deletes to the datastore
      if (deleted.size) {
        await promisify(cb => batch.commit(cb))()
      }

      // Clear expired entries from the cache
      for (const [cid, peers] of deleted) {
        const key = makeProviderKey(cid)
        const provs = this.providers.get(key)
        if (provs) {
          for (const peerId of peers) {
            provs.delete(peerId)
          }
          if (provs.size === 0) {
            this.providers.remove(key)
          } else {
            this.providers.set(key, provs)
          }
        }
      }

      this._log('Cleanup successful (%dms)', Date.now() - start)
    })
  }

  /**
   * Get the currently known provider peer ids for a given CID.
   *
   * @param {CID} cid
   * @returns {Promise<Map<String, Date>>}
   *
   * @private
   */
  async _getProvidersMap (cid) {
    const cacheKey = makeProviderKey(cid)
    let provs = this.providers.get(cacheKey)
    if (!provs) {
      provs = await loadProviders(this.datastore, cid)
      this.providers.set(cacheKey, provs)
    }
    return provs
  }

  get cleanupInterval () {
    return this._cleanupInterval
  }

  set cleanupInterval (val) {
    this._cleanupInterval = val

    if (this._cleaner) {
      clearInterval(this._cleaner)
    }

    this._cleaner = setInterval(
      () => this._cleanup(),
      this.cleanupInterval
    )
  }

  /**
   * Add a new provider for the given CID.
   *
   * @param {CID} cid
   * @param {PeerId} provider
   * @returns {Promise}
   */
  async addProvider (cid, provider) {
    return this.syncQueue.add(async () => {
      this._log('addProvider %s', cid.toBaseEncodedString())
      const provs = await this._getProvidersMap(cid)

      this._log('loaded %s provs', provs.size)
      const now = Date.now()
      provs.set(utils.encodeBase32(provider.id), now)

      const dsKey = makeProviderKey(cid)
      this.providers.set(dsKey, provs)
      return writeProviderEntry(this.datastore, cid, provider, now)
    })
  }

  /**
   * Get a list of providers for the given CID.
   *
   * @param {CID} cid
   * @returns {Promise<Array<PeerId>>}
   */
  async getProviders (cid) {
    return this.syncQueue.add(async () => {
      this._log('getProviders %s', cid.toBaseEncodedString())
      const provs = await this._getProvidersMap(cid)
      return [...provs.keys()].map((base32PeerId) => {
        return new PeerId(utils.decodeBase32(base32PeerId))
      })
    })
  }
}

/**
 * Encode the given key its matching datastore key.
 *
 * @param {CID|string} cid - cid or base32 encoded string
 * @returns {string}
 *
 * @private
 */
function makeProviderKey (cid) {
  cid = typeof cid === 'string' ? cid : utils.encodeBase32(cid.buffer)
  return c.PROVIDERS_KEY_PREFIX + cid
}

/**
 * Write a provider into the given store.
 *
 * @param {Datastore} store
 * @param {CID} cid
 * @param {PeerId} peer
 * @param {number} time
 * @returns {Promise}
 *
 * @private
 */
async function writeProviderEntry (store, cid, peer, time) {
  const dsKey = [
    makeProviderKey(cid),
    '/',
    utils.encodeBase32(peer.id)
  ].join('')

  const key = new Key(dsKey)
  const buffer = Buffer.from(varint.encode(time))
  return promisify(cb => store.put(key, buffer, cb))()
}

/**
 * Parse the CID and provider peer id from the key
 *
 * @param {DKey} key
 * @returns {Object} object with peer id and cid
 *
 * @private
 */
function parseProviderKey (key) {
  const parts = key.toString().split('/')
  if (parts.length !== 4) {
    throw new Error('incorrectly formatted provider entry key in datastore: ' + key)
  }

  return {
    cid: parts[2],
    peerId: parts[3]
  }
}

/**
 * Load providers for the given CID from the store.
 *
 * @param {Datastore} store
 * @param {CID} cid
 * @returns {Promise<Map<PeerId, Date>>}
 *
 * @private
 */
async function loadProviders (store, cid) {
  const providers = new Map()
  const query = store.query({ prefix: makeProviderKey(cid) })
  for await (const entry of toIterator(query)) {
    const { peerId } = parseProviderKey(entry.key)
    providers.set(peerId, readTime(entry.value))
  }
  return providers
}

function readTime (buf) {
  return varint.decode(buf)
}

module.exports = Providers

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/providers.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/routing.js", {"./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/utils.js","k-bucket":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/k-bucket/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/routing.js
      return function (require, module, exports) {
'use strict'

const KBucket = require('k-bucket')

const utils = require('./utils')

/**
 * A wrapper around `k-bucket`, to provide easy store and
 * retrival for peers.
 */
class RoutingTable {
  /**
   * @param {PeerId} self
   * @param {number} kBucketSize
   */
  constructor (self, kBucketSize) {
    this.self = self
    this._onPing = this._onPing.bind(this)

    utils.convertPeerId(self, (err, selfKey) => {
      if (err) {
        throw err
      }

      this.kb = new KBucket({
        localNodeId: selfKey,
        numberOfNodesPerKBucket: kBucketSize,
        numberOfNodesToPing: 1
      })

      this.kb.on('ping', this._onPing)
    })
  }

  // -- Private Methods

  /**
   * Called on the `ping` event from `k-bucket`.
   * Currently this just removes the oldest contact from
   * the list, without acutally pinging the individual peers.
   * This is the same as go does, but should probably
   * be upgraded to actually ping the individual peers.
   *
   * @param {Array<Object>} oldContacts
   * @param {Object} newContact
   * @returns {undefined}
   * @private
   */
  _onPing (oldContacts, newContact) {
    // just use the first one (k-bucket sorts from oldest to newest)
    const oldest = oldContacts[0]

    // remove the oldest one
    this.kb.remove(oldest.id)

    // add the new one
    this.kb.add(newContact)
  }

  // -- Public Interface

  /**
   * Amount of currently stored peers.
   *
   * @type {number}
   */
  get size () {
    return this.kb.count()
  }

  /**
   * Find a specific peer by id.
   *
   * @param {PeerId} peer
   * @param {function(Error, PeerId)} callback
   * @returns {void}
   */
  find (peer, callback) {
    utils.convertPeerId(peer, (err, key) => {
      if (err) {
        return callback(err)
      }
      const closest = this.closestPeer(key)

      if (closest && closest.isEqual(peer)) {
        return callback(null, closest)
      }

      callback()
    })
  }

  /**
   * Retrieve the closest peers to the given key.
   *
   * @param {Buffer} key
   * @param {number} count
   * @returns {PeerId|undefined}
   */
  closestPeer (key, count) {
    const res = this.closestPeers(key, 1)
    if (res.length > 0) {
      return res[0]
    }
  }

  /**
   * Retrieve the `count`-closest peers to the given key.
   *
   * @param {Buffer} key
   * @param {number} count
   * @returns {Array<PeerId>}
   */
  closestPeers (key, count) {
    return this.kb.closest(key, count).map((p) => p.peer)
  }

  /**
   * Add or update the routing table with the given peer.
   *
   * @param {PeerId} peer
   * @param {function(Error)} callback
   * @returns {undefined}
   */
  add (peer, callback) {
    utils.convertPeerId(peer, (err, id) => {
      if (err) {
        return callback(err)
      }
      this.kb.add({ id: id, peer: peer })
      callback()
    })
  }

  /**
   * Remove a given peer from the table.
   *
   * @param {PeerId} peer
   * @param {function(Error)} callback
   * @returns {undefined}
   */
  remove (peer, callback) {
    utils.convertPeerId(peer, (err, id) => {
      if (err) {
        return callback(err)
      }
      this.kb.remove(id)
      callback()
    })
  }
}

module.exports = RoutingTable

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/routing.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/random-walk.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/constants.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/utils.js","abort-controller":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/abort-controller/browser.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","libp2p-crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/index.js","multihashing-async":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/index.js","p-times":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-times/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/random-walk.js
      return function (require, module, exports) {
'use strict'

const promisify = require('promisify-es6')
const crypto = require('libp2p-crypto')
const multihashing = promisify(require('multihashing-async'))
const PeerId = require('peer-id')
const assert = require('assert')
const AbortController = require('abort-controller')
const errcode = require('err-code')
const times = require('p-times')
const c = require('./constants')
const { logger } = require('./utils')

class RandomWalk {
  /**
   * @constructor
   * @param {DHT} dht
   * @param {object} options
   * @param {randomWalkOptions.enabled} options.enabled
   * @param {randomWalkOptions.queriesPerPeriod} options.queriesPerPeriod
   * @param {randomWalkOptions.interval} options.interval
   * @param {randomWalkOptions.timeout} options.timeout
   * @param {randomWalkOptions.delay} options.delay
   * @param {DHT} options.dht
   */
  constructor (dht, options) {
    assert(dht, 'Random Walk needs an instance of the Kademlia DHT')
    this._options = { ...c.defaultRandomWalk, ...options }
    this._kadDHT = dht
    this.log = logger(dht.peerInfo.id, 'random-walk')
    this._timeoutId = undefined
  }

  /**
   * Start the Random Walk process. This means running a number of queries
   * every interval requesting random data. This is done to keep the dht
   * healthy over time.
   *
   * @returns {void}
   */
  start () {
    // Don't run twice
    if (this._timeoutId || !this._options.enabled) { return }

    // Start doing random walks after `this._options.delay`
    this._timeoutId = setTimeout(() => {
      // Start runner immediately
      this._runPeriodically()
    }, this._options.delay)
  }

  /**
   * Stop the random-walk process. Any active
   * queries will be aborted.
   *
   * @returns {void}
   */
  stop () {
    if (this._timeoutId) {
      clearTimeout(this._timeoutId)
      this._timeoutId = undefined
    }
    this._controller && this._controller.abort()
  }

  /**
   * Run function `randomWalk._walk` on every `options.interval` ms
   *
   * @private
   */
  async _runPeriodically () {
    // run until the walk has been stopped
    while (this._timeoutId) {
      try {
        await this._walk(this._options.queriesPerPeriod, this._options.timeout)
      } catch (err) {
        this._kadDHT._log.error('random-walk:error', err)
      }
      // Each subsequent walk should run on a `this._options.interval` interval
      await new Promise(resolve => {
        this._timeoutId = setTimeout(resolve, this._options.interval)
      })
    }
  }

  /**
   * Do the random walk work.
   *
   * @param {number} queries
   * @param {number} walkTimeout
   * @returns {Promise}
   *
   * @private
   */
  async _walk (queries, walkTimeout) {
    this.log('start')
    this._controller = new AbortController()

    try {
      await times(queries, async (index) => {
        this.log('running query %d', index)
        try {
          const id = await this._randomPeerId()

          // Check if we've happened to already abort
          if (!this._controller) return

          await this._query(id, {
            timeout: walkTimeout,
            signal: this._controller.signal
          })
        } catch (err) {
          if (err && err.code !== 'ETIMEDOUT') {
            this.log.error('query %d finished with error', index, err)
            throw err
          }
        }

        this.log('finished query %d', index)
      })
    } finally {
      this._controller = null
      this.log('finished queries')
    }
  }

  /**
   * The query run during a random walk request.
   *
   * TODO: While query currently supports an abort controller, it is not
   * yet supported by `DHT.findPeer`. Once https://github.com/libp2p/js-libp2p-kad-dht/pull/82
   * is complete, and AbortController support has been added to the
   * DHT query functions, the abort here will just work, provided the
   * functions support `options.signal`. Once done, this todo should be
   * removed.
   *
   * @param {PeerId} id
   * @param {object} options
   * @param {number} options.timeout
   * @param {AbortControllerSignal} options.signal
   * @returns {Promise}
   *
   * @private
   */
  async _query (id, options) {
    this.log('query:%s', id.toB58String())

    let peer
    try {
      peer = await promisify(cb => this._kadDHT.findPeer(id, options, cb))()
    } catch (err) {
      if (err && err.code === 'ERR_NOT_FOUND') {
        // expected case, we asked for random stuff after all
        return
      }

      throw err
    }

    this.log('query:found', peer)

    // wait what, there was something found? Lucky day!
    throw errcode(`random-walk: ACTUALLY FOUND PEER: ${peer}, ${id.toB58String()}`, 'ERR_FOUND_RANDOM_PEER')
  }

  /**
   * Generate a random peer id for random-walk purposes.
   *
   * @returns {Promise<PeerId>}
   *
   * @private
   */
  async _randomPeerId () {
    const digest = await multihashing(crypto.randomBytes(16), 'sha2-256')
    return new PeerId(digest)
  }
}

module.exports = RandomWalk

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/random-walk.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/utils.js", {"async/map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/map.js","async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","base32.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/base32.js/base32.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js","libp2p-record":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-record/src/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js","multihashing-async":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/node_modules/multihashing-async/src/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","xor-distance":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/xor-distance/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/utils.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const debug = require('debug')
const multihashing = require('multihashing-async')
const mh = require('multihashes')
const Key = require('interface-datastore').Key
const base32 = require('base32.js')
const distance = require('xor-distance')
const map = require('async/map')
const Record = require('libp2p-record').Record
const setImmediate = require('async/setImmediate')
const PeerId = require('peer-id')
const errcode = require('err-code')

/**
 * Creates a DHT ID by hashing a given buffer.
 *
 * @param {Buffer} buf
 * @param {function(Error, Buffer)} callback
 * @returns {void}
 */
exports.convertBuffer = (buf, callback) => {
  multihashing.digest(buf, 'sha2-256', callback)
}

/**
 * Creates a DHT ID by hashing a Peer ID
 *
 * @param {PeerId} peer
 * @param {function(Error, Buffer)} callback
 * @returns {void}
 */
exports.convertPeerId = (peer, callback) => {
  multihashing.digest(peer.id, 'sha2-256', callback)
}

/**
 * Convert a buffer to their SHA2-256 hash.
 *
 * @param {Buffer} buf
 * @returns {Key}
 */
exports.bufferToKey = (buf) => {
  return new Key('/' + exports.encodeBase32(buf), false)
}

/**
 * Generate the key for a public key.
 *
 * @param {PeerId} peer
 * @returns {Buffer}
 */
exports.keyForPublicKey = (peer) => {
  return Buffer.concat([
    Buffer.from('/pk/'),
    peer.id
  ])
}

exports.isPublicKeyKey = (key) => {
  return key.slice(0, 4).toString() === '/pk/'
}

exports.fromPublicKeyKey = (key) => {
  return new PeerId(key.slice(4))
}

/**
 * Get the current time as timestamp.
 *
 * @returns {number}
 */
exports.now = () => {
  return Date.now()
}

/**
 * Encode a given buffer into a base32 string.
 * @param {Buffer} buf
 * @returns {string}
 */
exports.encodeBase32 = (buf) => {
  const enc = new base32.Encoder()
  return enc.write(buf).finalize()
}

/**
 * Decode a given base32 string into a buffer.
 * @param {string} raw
 * @returns {Buffer}
 */
exports.decodeBase32 = (raw) => {
  const dec = new base32.Decoder()
  return Buffer.from(dec.write(raw).finalize())
}

/**
 * Sort peers by distance to the given `target`.
 *
 * @param {Array<PeerId>} peers
 * @param {Buffer} target
 * @param {function(Error, Array<PeerId>)} callback
 * @returns {void}
 */
exports.sortClosestPeers = (peers, target, callback) => {
  map(peers, (peer, cb) => {
    exports.convertPeerId(peer, (err, id) => {
      if (err) {
        return cb(err)
      }

      cb(null, {
        peer: peer,
        distance: distance(id, target)
      })
    })
  }, (err, distances) => {
    if (err) {
      return callback(err)
    }

    callback(null, distances.sort(exports.xorCompare).map((d) => d.peer))
  })
}

/**
 * Compare function to sort an array of elements which have a distance property which is the xor distance to a given element.
 *
 * @param {Object} a
 * @param {Object} b
 * @returns {number}
 */
exports.xorCompare = (a, b) => {
  return distance.compare(a.distance, b.distance)
}

/**
 * Computes how many results to collect on each disjoint path, rounding up.
 * This ensures that we look for at least one result per path.
 *
 * @param {number} resultsWanted
 * @param {number} numPaths - total number of paths
 * @returns {number}
 */
exports.pathSize = (resultsWanted, numPaths) => {
  return Math.ceil(resultsWanted / numPaths)
}

/**
 * Create a new put record, encodes and signs it if enabled.
 *
 * @param {Buffer} key
 * @param {Buffer} value
 * @param {function(Error, Buffer)} callback
 * @returns {void}
 */
exports.createPutRecord = (key, value, callback) => {
  const timeReceived = new Date()
  const rec = new Record(key, value, timeReceived)

  setImmediate(() => {
    callback(null, rec.serialize())
  })
}

/**
 * Creates a logger for the given subsystem
 *
 * @param {PeerId} [id]
 * @param {string} [subsystem]
 * @returns {debug}
 *
 * @private
 */
exports.logger = (id, subsystem) => {
  const name = ['libp2p', 'dht']
  if (subsystem) {
    name.push(subsystem)
  }
  if (id) {
    name.push(`${id.toB58String().slice(0, 8)}`)
  }

  // Add a formatter for converting to a base58 string
  debug.formatters.b = (v) => {
    return mh.toB58String(v)
  }

  const logger = debug(name.join(':'))
  logger.error = debug(name.concat(['error']).join(':'))

  return logger
}

exports.TimeoutError = class TimeoutError extends Error {
  get code () {
    return 'ETIMEDOUT'
  }
}

/**
 * Creates an async function that calls the given `asyncFn` and Errors
 * if it does not resolve within `time` ms
 *
 * @param {Function} [asyncFn]
 * @param {Number} [time]
 * @returns {Function}
 *
 * @private
 */
exports.withTimeout = (asyncFn, time) => {
  return async (...args) => {
    return Promise.race([
      asyncFn(...args),
      new Promise((resolve, reject) => {
        setTimeout(() => {
          reject(errcode(new Error('Async function did not complete before timeout'), 'ETIMEDOUT'))
        }, time)
      })
    ])
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query/index.js", {"../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/utils.js","./run":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query/run.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query/index.js
      return function (require, module, exports) {
'use strict'

const mh = require('multihashes')

const utils = require('../utils')
const Run = require('./run')

/**
 * Divide peers up into disjoint paths (subqueries). Any peer can only be used once over all paths.
 * Within each path, query peers from closest to farthest away.
 */
class Query {
  /**
   * User-supplied function to set up an individual disjoint path. Per-path
   * query state should be held in this function's closure.
   * @typedef {makePath} function
   * @param {number} pathNum - Numeric index from zero to numPaths - 1
   * @returns {queryFunc} - Function to call on each peer in the query
   */

  /**
   * Query function.
   * @typedef {queryFunc} function
   * @param {PeerId} next - Peer to query
   * @param {function(Error, Object)} callback - Query result callback
   */

  /**
   * Create a new query. The makePath function is called once per disjoint path, so that per-path
   * variables can be created in that scope. makePath then returns the actual query function (queryFunc) to
   * use when on that path.
   *
   * @param {DHT} dht - DHT instance
   * @param {Buffer} key
   * @param {makePath} makePath - Called to set up each disjoint path. Must return the query function.
   */
  constructor (dht, key, makePath) {
    this.dht = dht
    this.key = key
    this.makePath = makePath
    this._log = utils.logger(this.dht.peerInfo.id, 'query:' + mh.toB58String(key))

    this.running = false

    this._onStart = this._onStart.bind(this)
    this._onComplete = this._onComplete.bind(this)
  }

  /**
   * Run this query, start with the given list of peers first.
   *
   * @param {Array<PeerId>} peers
   * @returns {Promise}
   */
  async run (peers) {
    if (!this.dht._queryManager.running) {
      this._log.error('Attempt to run query after shutdown')
      return { finalSet: new Set(), paths: [] }
    }

    if (peers.length === 0) {
      this._log.error('Running query with no peers')
      return { finalSet: new Set(), paths: [] }
    }

    this._run = new Run(this)

    this._log(`query running with K=${this.dht.kBucketSize}, A=${this.dht.concurrency}, D=${Math.min(this.dht.disjointPaths, peers.length)}`)
    this._run.once('start', this._onStart)
    this._run.once('complete', this._onComplete)
    return this._run.execute(peers)
  }

  /**
   * Called when the run starts.
   */
  _onStart () {
    this.running = true
    this._startTime = Date.now()
    this._log('query:start')

    // Register this query so we can stop it if the DHT stops
    this.dht._queryManager.queryStarted(this)
  }

  /**
   * Called when the run completes (even if there's an error).
   */
  _onComplete () {
    // Ensure worker queues for all paths are stopped at the end of the query
    this.stop()
  }

  /**
   * Stop the query.
   */
  stop () {
    this._log(`query:done in ${Date.now() - this._startTime}ms`)

    if (this._run) {
      this._log(`${this._run.errors.length} of ${this._run.peersSeen.size} peers errored (${this._run.errors.length / this._run.peersSeen.size * 100}% fail rate)`)
    }

    if (!this.running) {
      return
    }

    this._run.removeListener('start', this._onStart)
    this._run.removeListener('complete', this._onComplete)

    this.running = false
    this._run && this._run.stop()
    this.dht._queryManager.queryCompleted(this)
  }
}

module.exports = Query

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/query/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/network.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/constants.js","./message":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/message/index.js","./rpc":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/rpc/index.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/utils.js","async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","async/timeout":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/timeout.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","pull-length-prefixed":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-length-prefixed/src/index.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/network.js
      return function (require, module, exports) {
'use strict'

const pull = require('pull-stream')
const timeout = require('async/timeout')
const lp = require('pull-length-prefixed')
const setImmediate = require('async/setImmediate')

const errcode = require('err-code')

const rpc = require('./rpc')
const c = require('./constants')
const Message = require('./message')
const utils = require('./utils')

/**
 * Handle network operations for the dht
 */
class Network {
  /**
   * Create a new network.
   *
   * @param {KadDHT} self
   */
  constructor (self) {
    this.dht = self
    this.readMessageTimeout = c.READ_MESSAGE_TIMEOUT
    this._log = utils.logger(this.dht.peerInfo.id, 'net')
    this._rpc = rpc(this.dht)
    this._onPeerConnected = this._onPeerConnected.bind(this)
    this._running = false
  }

  /**
   * Start the network.
   *
   * @param {function(Error)} callback
   * @returns {void}
   */
  start (callback) {
    const cb = (err) => setImmediate(() => callback(err))

    if (this._running) {
      return cb(errcode(new Error('Network is already running'), 'ERR_NETWORK_ALREADY_RUNNING'))
    }

    // TODO add a way to check if switch has started or not
    if (!this.dht.isStarted) {
      return cb(errcode(new Error('Can not start network'), 'ERR_CANNOT_START_NETWORK'))
    }

    this._running = true

    // handle incoming connections
    this.dht.switch.handle(c.PROTOCOL_DHT, this._rpc)

    // handle new connections
    this.dht.switch.on('peer-mux-established', this._onPeerConnected)

    cb()
  }

  /**
   * Stop all network activity.
   *
   * @param {function(Error)} callback
   * @returns {void}
   */
  stop (callback) {
    const cb = (err) => setImmediate(() => callback(err))

    if (!this.dht.isStarted && !this.isStarted) {
      return cb(errcode(new Error('Network is already stopped'), 'ERR_NETWORK_ALREADY_STOPPED'))
    }
    this._running = false
    this.dht.switch.removeListener('peer-mux-established', this._onPeerConnected)

    this.dht.switch.unhandle(c.PROTOCOL_DHT)
    cb()
  }

  /**
   * Is the network online?
   *
   * @type {bool}
   */
  get isStarted () {
    return this._running
  }

  /**
   * Are all network components there?
   *
   * @type {bool}
   */
  get isConnected () {
    // TODO add a way to check if switch has started or not
    return this.dht.isStarted && this.isStarted
  }

  /**
   * Handle new connections in the switch.
   *
   * @param {PeerInfo} peer
   * @returns {void}
   * @private
   */
  _onPeerConnected (peer) {
    if (!this.isConnected) {
      return this._log.error('Network is offline')
    }

    this.dht.switch.dial(peer, c.PROTOCOL_DHT, (err, conn) => {
      if (err) {
        return this._log('%s does not support protocol: %s', peer.id.toB58String(), c.PROTOCOL_DHT)
      }

      // TODO: conn.close()
      pull(pull.empty(), conn)

      this.dht._add(peer, (err) => {
        if (err) {
          return this._log.error('Failed to add to the routing table', err)
        }

        this._log('added to the routing table: %s', peer.id.toB58String())
      })
    })
  }

  /**
   * Send a request and record RTT for latency measurements.
   *
   * @param {PeerId} to - The peer that should receive a message
   * @param {Message} msg - The message to send.
   * @param {function(Error, Message)} callback
   * @returns {void}
   */
  sendRequest (to, msg, callback) {
    // TODO: record latency
    if (!this.isConnected) {
      return callback(errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE'))
    }

    this._log('sending to: %s', to.toB58String())
    this.dht.switch.dial(to, c.PROTOCOL_DHT, (err, conn) => {
      if (err) {
        return callback(err)
      }

      this._writeReadMessage(conn, msg.serialize(), callback)
    })
  }

  /**
   * Sends a message without expecting an answer.
   *
   * @param {PeerId} to
   * @param {Message} msg
   * @param {function(Error)} callback
   * @returns {void}
   */
  sendMessage (to, msg, callback) {
    if (!this.isConnected) {
      return setImmediate(() => callback(errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE')))
    }

    this._log('sending to: %s', to.toB58String())

    this.dht.switch.dial(to, c.PROTOCOL_DHT, (err, conn) => {
      if (err) {
        return callback(err)
      }

      this._writeMessage(conn, msg.serialize(), callback)
    })
  }

  /**
   * Write a message and read its response.
   * If no response is received after the specified timeout
   * this will error out.
   *
   * @param {Connection} conn - the connection to use
   * @param {Buffer} msg - the message to send
   * @param {function(Error, Message)} callback
   * @returns {void}
   * @private
   */
  _writeReadMessage (conn, msg, callback) {
    timeout(
      writeReadMessage,
      this.readMessageTimeout
    )(conn, msg, callback)
  }

  /**
   * Write a message to the given connection.
   *
   * @param {Connection} conn - the connection to use
   * @param {Buffer} msg - the message to send
   * @param {function(Error)} callback
   * @returns {void}
   * @private
   */
  _writeMessage (conn, msg, callback) {
    pull(
      pull.values([msg]),
      lp.encode(),
      conn,
      pull.onEnd(callback)
    )
  }
}

function writeReadMessage (conn, msg, callback) {
  pull(
    pull.values([msg]),
    lp.encode(),
    conn,
    pull.filter((msg) => msg.length < c.maxMessageSize),
    lp.decode(),
    pull.collect((err, res) => {
      if (err) {
        return callback(err)
      }
      if (res.length === 0) {
        return callback(errcode(new Error('No message received'), 'ERR_NO_MESSAGE_RECEIVED'))
      }

      let response
      try {
        response = Message.deserialize(res[0])
      } catch (err) {
        return callback(errcode(err, 'ERR_FAILED_DESERIALIZE_RESPONSE'))
      }

      callback(null, response)
    })
  )
}

module.exports = Network

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-kad-dht/src/network.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/state.js", {"pull-defer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/index.js","pull-handshake":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-handshake/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/state.js
      return function (require, module, exports) {
'use strict'

const handshake = require('pull-handshake')
const deferred = require('pull-defer')

class State {
  constructor (localId, remoteId, timeout, callback) {
    if (typeof timeout === 'function') {
      callback = timeout
      timeout = undefined
    }

    this.setup()

    this.id.local = localId
    // TODO use remoteId to verify PeersIdentity
    this.id.remote = remoteId
    this.key.local = localId.privKey
    this.timeout = timeout || 60 * 1000
    callback = callback || (() => {})

    this.secure = deferred.duplex()
    this.stream = handshake({ timeout: this.timeout }, callback)
    this.shake = this.stream.handshake
    delete this.stream.handshake
  }

  setup () {
    this.id = { local: null, remote: null }
    this.key = { local: null, remote: null }
    this.shake = null
    this.cleanSecrets()
  }

  // remove all data from the handshake that is not needed anymore
  cleanSecrets () {
    this.shared = {}

    this.ephemeralKey = { local: null, remote: null }
    this.proposal = { in: null, out: null }
    this.proposalEncoded = { in: null, out: null }
    this.protocols = { local: null, remote: null }
    this.exchange = { in: null, out: null }
  }
}

module.exports = State

      };
    };
  }
}, {package:"libp2p-secio",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/state.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/index.js", {"./exchange":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/exchange.js","./finish":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/finish.js","./propose":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/propose.js","async/series":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/series.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/index.js
      return function (require, module, exports) {
'use strict'

const series = require('async/series')

const propose = require('./propose')
const exchange = require('./exchange')
const finish = require('./finish')

// Performs initial communication over insecure channel to share keys, IDs,
// and initiate communication, assigning all necessary params.
module.exports = function handshake (state, callback) {
  series([
    (cb) => propose(state, cb),
    (cb) => exchange(state, cb),
    (cb) => finish(state, cb)
  ], (err) => {
    state.cleanSecrets()

    if (err) {
      if (err === true) {
        err = new Error('Stream ended prematurely')
      }
      state.shake.abort(err)
    }

    // signal when the handshake is finished so that plumbing can happen
    callback(err)
  })

  return state.stream
}

      };
    };
  }
}, {package:"libp2p-secio",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-secio/src/handshake/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star/src/index.js", {"./listener":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star/src/listener.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star/src/utils.js","async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","class-is":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/class-is/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","interface-connection":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-connection/src/index.js","mafmt":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/mafmt/src/index.js","multiaddr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","peer-info":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star/src/index.js
      return function (require, module, exports) {
'use strict'

const debug = require('debug')
const log = debug('libp2p:websocket-star')
const multiaddr = require('multiaddr')
const EE = require('events').EventEmitter
const PeerId = require('peer-id')
const PeerInfo = require('peer-info')
const Connection = require('interface-connection').Connection
const setImmediate = require('async/setImmediate')
const utils = require('./utils')
const Listener = require('./listener')
const cleanUrlSIO = utils.cleanUrlSIO
const mafmt = require('mafmt')
const withIs = require('class-is')

class WebsocketStar {
  /**
    * WebsocketStar Transport
    * @class
    * @param {Object} options - Options for the listener
    * @param {PeerId} options.id - Id for the crypto challenge
    */
  constructor (options) {
    options = options || {}

    this.id = options.id
    this.flag = options.allowJoinWithDisabledChallenge // let's just refer to it as "flag"

    this.discovery = new EE()
    this.discovery.tag = 'websocketStar'
    this.discovery.start = (callback) => {
      setImmediate(callback)
    }
    this.discovery.stop = (callback) => {
      setImmediate(callback)
    }

    this.listeners_list = {}
    this._peerDiscovered = this._peerDiscovered.bind(this)
  }

  /**
    * Sets the id after transport creation (aka the lazy way)
    * @param {PeerId} id
    * @returns {undefined}
    */
  lazySetId (id) {
    if (!id) return
    this.id = id
    this.canCrypto = true
  }

  /**
    * Dials a peer
    * @param {Multiaddr} ma - Multiaddr to dial to
    * @param {Object} options
    * @param {function} callback
    * @returns {Connection}
    */
  dial (ma, options, callback) {
    if (typeof options === 'function') {
      callback = options
      options = {}
    }

    let url
    try {
      url = cleanUrlSIO(ma)
    } catch (err) {
      return callback(err) // early
    }
    const listener = this.listeners_list[url]
    if (!listener) {
      callback(new Error('No listener for this server'))
      return new Connection()
    }
    return listener.dial(ma, options, callback)
  }

  /**
    * Creates a listener
    * @param {Object} options
    * @param {function} handler
    * @returns {Listener}
    */
  createListener (options, handler) {
    if (typeof options === 'function') {
      handler = options
      options = {}
    }

    const listener = new Listener({
      id: this.id,
      handler,
      listeners: this.listeners_list,
      flag: this.flag
    })

    listener.on('peer', this._peerDiscovered)

    return listener
  }

  /**
    * Filters multiaddrs
    * @param {Multiaddr[]} multiaddrs
    * @returns {boolean}
    */
  filter (multiaddrs) {
    if (!Array.isArray(multiaddrs)) {
      multiaddrs = [multiaddrs]
    }

    return multiaddrs.filter((ma) => mafmt.WebSocketStar.matches(ma))
  }

  /**
    * Used to fire peer events on the discovery part
    * @param {Multiaddr} maStr
    * @fires Discovery#peer
    * @returns {undefined}
    * @private
    */
  _peerDiscovered (maStr) {
    log('Peer Discovered:', maStr)
    const peerIdStr = maStr.split('/ipfs/').pop()
    const peerId = PeerId.createFromB58String(peerIdStr)
    const peerInfo = new PeerInfo(peerId)

    peerInfo.multiaddrs.add(multiaddr(maStr))
    this.discovery.emit('peer', peerInfo)
  }
}

module.exports = withIs(WebsocketStar, { className: 'WebsocketStar', symbolName: '@libp2p/js-libp2p-websocket-star/websocketstar' })

      };
    };
  }
}, {package:"libp2p-websocket-star",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-websocket-star/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/webrtcsupport/index-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/webrtcsupport/index-browser.js
      return function (require, module, exports) {
/* global self */

// created by @HenrikJoreteg
var prefix
var version

if (self.mozRTCPeerConnection || navigator.mozGetUserMedia) {
  prefix = 'moz'
  version = parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1], 10)
} else if (self.webkitRTCPeerConnection || navigator.webkitGetUserMedia) {
  prefix = 'webkit'
  version = navigator.userAgent.match(/Chrom(e|ium)/) && parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2], 10)
}

var PC = self.RTCPeerConnection || self.mozRTCPeerConnection || self.webkitRTCPeerConnection
var IceCandidate = self.mozRTCIceCandidate || self.RTCIceCandidate
var SessionDescription = self.mozRTCSessionDescription || self.RTCSessionDescription
var MediaStream = self.webkitMediaStream || self.MediaStream
var screenSharing = self.location.protocol === 'https:' &&
    ((prefix === 'webkit' && version >= 26) ||
     (prefix === 'moz' && version >= 33))
var AudioContext = self.AudioContext || self.webkitAudioContext
var videoEl = self.document && document.createElement('video')
var supportVp8 = videoEl && videoEl.canPlayType && videoEl.canPlayType('video/webm; codecs="vp8", vorbis') === 'probably'
var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.msGetUserMedia || navigator.mozGetUserMedia

// export support flags and constructors.prototype && PC
module.exports = {
  prefix: prefix,
  browserVersion: version,
  support: !!PC && !!getUserMedia,
    // new support style
  supportRTCPeerConnection: !!PC,
  supportVp8: supportVp8,
  supportGetUserMedia: !!getUserMedia,
  supportDataChannel: !!(PC && PC.prototype && PC.prototype.createDataChannel),
  supportWebAudio: !!(AudioContext && AudioContext.prototype.createMediaStreamSource),
  supportMediaStream: !!(MediaStream && MediaStream.prototype.removeTrack),
  supportScreenSharing: !!screenSharing,
    // constructors
  AudioContext: AudioContext,
  PeerConnection: PC,
  SessionDescription: SessionDescription,
  IceCandidate: IceCandidate,
  MediaStream: MediaStream,
  getUserMedia: getUserMedia
}

      };
    };
  }
}, {package:"webrtcsupport",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/webrtcsupport/index-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-webrtc-star/src/utils.js", {"multiaddr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-webrtc-star/src/utils.js
      return function (require, module, exports) {
'use strict'

const multiaddr = require('multiaddr')

function cleanUrlSIO (ma) {
  const maStrSplit = ma.toString().split('/')
  const tcpProto = ma.protos()[1].name
  const wsProto = ma.protos()[2].name
  const tcpPort = ma.stringTuples()[1][1]

  if (tcpProto !== 'tcp' || (wsProto !== 'ws' && wsProto !== 'wss')) {
    throw new Error('invalid multiaddr: ' + ma.toString())
  }

  if (!multiaddr.isName(ma)) {
    return 'http://' + maStrSplit[2] + ':' + maStrSplit[4]
  }

  if (wsProto === 'ws') {
    return 'http://' + maStrSplit[2] + (tcpPort === 80 ? '' : ':' + tcpPort)
  }

  if (wsProto === 'wss') {
    return 'https://' + maStrSplit[2] + (tcpPort === 443 ? '' : ':' + tcpPort)
  }
}

function cleanMultiaddr (maStr) {
  const legacy = '/libp2p-webrtc-star'

  if (maStr.indexOf(legacy) !== -1) {
    maStr = maStr.substring(legacy.length, maStr.length)
    let ma = multiaddr(maStr)
    const tuppleIPFS = ma.stringTuples().filter((tupple) => {
      return tupple[0] === 421 // ipfs code
    })[0]

    ma = ma.decapsulate('ipfs')
    ma = ma.encapsulate('/p2p-webrtc-star')
    ma = ma.encapsulate(`/ipfs/${tuppleIPFS[1]}`)
    maStr = ma.toString()
  }

  return maStr
}

exports = module.exports
exports.cleanUrlSIO = cleanUrlSIO
exports.cleanMultiaddr = cleanMultiaddr

      };
    };
  }
}, {package:"libp2p-webrtc-star",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-webrtc-star/src/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/index.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","get-browser-rtc":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/get-browser-rtc/index.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","randombytes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/randombytes/browser.js","readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/node_modules/readable-stream/readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
module.exports = Peer

var debug = require('debug')('simple-peer')
var getBrowserRTC = require('get-browser-rtc')
var inherits = require('inherits')
var randombytes = require('randombytes')
var stream = require('readable-stream')

var MAX_BUFFERED_AMOUNT = 64 * 1024
var ICECOMPLETE_TIMEOUT = 5 * 1000
var CHANNEL_CLOSING_TIMEOUT = 5 * 1000

inherits(Peer, stream.Duplex)

/**
 * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.
 * Duplex stream.
 * @param {Object} opts
 */
function Peer (opts) {
  var self = this
  if (!(self instanceof Peer)) return new Peer(opts)

  self._id = randombytes(4).toString('hex').slice(0, 7)
  self._debug('new peer %o', opts)

  opts = Object.assign({
    allowHalfOpen: false
  }, opts)

  stream.Duplex.call(self, opts)

  self.channelName = opts.initiator
    ? opts.channelName || randombytes(20).toString('hex')
    : null

  self.initiator = opts.initiator || false
  self.channelConfig = opts.channelConfig || Peer.channelConfig
  self.config = Object.assign({}, Peer.config, opts.config)
  self.offerOptions = opts.offerOptions || {}
  self.answerOptions = opts.answerOptions || {}
  self.sdpTransform = opts.sdpTransform || function (sdp) { return sdp }
  self.streams = opts.streams || (opts.stream ? [opts.stream] : []) // support old "stream" option
  self.trickle = opts.trickle !== undefined ? opts.trickle : true
  self.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false
  self.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT

  self.destroyed = false
  self._connected = false

  self.remoteAddress = undefined
  self.remoteFamily = undefined
  self.remotePort = undefined
  self.localAddress = undefined
  self.localFamily = undefined
  self.localPort = undefined

  self._wrtc = (opts.wrtc && typeof opts.wrtc === 'object')
    ? opts.wrtc
    : getBrowserRTC()

  if (!self._wrtc) {
    if (typeof window === 'undefined') {
      throw makeError('No WebRTC support: Specify `opts.wrtc` option in this environment', 'ERR_WEBRTC_SUPPORT')
    } else {
      throw makeError('No WebRTC support: Not a supported browser', 'ERR_WEBRTC_SUPPORT')
    }
  }

  self._pcReady = false
  self._channelReady = false
  self._iceComplete = false // ice candidate trickle done (got null candidate)
  self._iceCompleteTimer = null // send an offer/answer anyway after some timeout
  self._channel = null
  self._pendingCandidates = []

  self._isNegotiating = !self.initiator // is this peer waiting for negotiation to complete?
  self._batchedNegotiation = false // batch synchronous negotiations
  self._queuedNegotiation = false // is there a queued negotiation request?
  self._sendersAwaitingStable = []
  self._senderMap = new Map()
  self._firstStable = true
  self._closingInterval = null

  self._remoteTracks = []
  self._remoteStreams = []

  self._chunk = null
  self._cb = null
  self._interval = null

  try {
    self._pc = new (self._wrtc.RTCPeerConnection)(self.config)
  } catch (err) {
    setTimeout(() => self.destroy(err), 0)
    return
  }

  // We prefer feature detection whenever possible, but sometimes that's not
  // possible for certain implementations.
  self._isReactNativeWebrtc = typeof self._pc._peerConnectionId === 'number'

  self._pc.oniceconnectionstatechange = function () {
    self._onIceStateChange()
  }
  self._pc.onicegatheringstatechange = function () {
    self._onIceStateChange()
  }
  self._pc.onsignalingstatechange = function () {
    self._onSignalingStateChange()
  }
  self._pc.onicecandidate = function (event) {
    self._onIceCandidate(event)
  }

  // Other spec events, unused by this implementation:
  // - onconnectionstatechange
  // - onicecandidateerror
  // - onfingerprintfailure
  // - onnegotiationneeded

  if (self.initiator) {
    self._setupData({
      channel: self._pc.createDataChannel(self.channelName, self.channelConfig)
    })
  } else {
    self._pc.ondatachannel = function (event) {
      self._setupData(event)
    }
  }

  if (self.streams) {
    self.streams.forEach(function (stream) {
      self.addStream(stream)
    })
  }
  self._pc.ontrack = function (event) {
    self._onTrack(event)
  }

  if (self.initiator) {
    self._needsNegotiation()
  }

  self._onFinishBound = function () {
    self._onFinish()
  }
  self.once('finish', self._onFinishBound)
}

Peer.WEBRTC_SUPPORT = !!getBrowserRTC()

/**
 * Expose peer and data channel config for overriding all Peer
 * instances. Otherwise, just set opts.config or opts.channelConfig
 * when constructing a Peer.
 */
Peer.config = {
  iceServers: [
    {
      urls: 'stun:stun.l.google.com:19302'
    },
    {
      urls: 'stun:global.stun.twilio.com:3478?transport=udp'
    }
  ],
  sdpSemantics: 'unified-plan'
}
Peer.channelConfig = {}

Object.defineProperty(Peer.prototype, 'bufferSize', {
  get: function () {
    var self = this
    return (self._channel && self._channel.bufferedAmount) || 0
  }
})

// HACK: it's possible channel.readyState is "closing" before peer.destroy() fires
// https://bugs.chromium.org/p/chromium/issues/detail?id=882743
Object.defineProperty(Peer.prototype, 'connected', {
  get: function () {
    var self = this
    return (self._connected && self._channel.readyState === 'open')
  }
})

Peer.prototype.address = function () {
  var self = this
  return { port: self.localPort, family: self.localFamily, address: self.localAddress }
}

Peer.prototype.signal = function (data) {
  var self = this
  if (self.destroyed) throw makeError('cannot signal after peer is destroyed', 'ERR_SIGNALING')
  if (typeof data === 'string') {
    try {
      data = JSON.parse(data)
    } catch (err) {
      data = {}
    }
  }
  self._debug('signal()')

  if (data.renegotiate && self.initiator) {
    self._debug('got request to renegotiate')
    self._needsNegotiation()
  }
  if (data.transceiverRequest && self.initiator) {
    self._debug('got request for transceiver')
    self.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)
  }
  if (data.candidate) {
    if (self._pc.localDescription && self._pc.localDescription.type && self._pc.remoteDescription && self._pc.remoteDescription.type) {
      self._addIceCandidate(data.candidate)
    } else {
      self._pendingCandidates.push(data.candidate)
    }
  }
  if (data.sdp) {
    self._pc.setRemoteDescription(new (self._wrtc.RTCSessionDescription)(data)).then(function () {
      if (self.destroyed) return

      self._pendingCandidates.forEach(function (candidate) {
        self._addIceCandidate(candidate)
      })
      self._pendingCandidates = []

      if (self._pc.remoteDescription.type === 'offer') self._createAnswer()
    }).catch(function (err) { self.destroy(makeError(err, 'ERR_SET_REMOTE_DESCRIPTION')) })
  }
  if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {
    self.destroy(makeError('signal() called with invalid signal data', 'ERR_SIGNALING'))
  }
}

Peer.prototype._addIceCandidate = function (candidate) {
  var self = this
  var iceCandidateObj = new self._wrtc.RTCIceCandidate(candidate)
  self._pc.addIceCandidate(iceCandidateObj).catch(function (err) {
    if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {
      warn('Ignoring unsupported ICE candidate.')
    } else {
      self.destroy(makeError(err, 'ERR_ADD_ICE_CANDIDATE'))
    }
  })
}

/**
 * Send text/binary data to the remote peer.
 * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk
 */
Peer.prototype.send = function (chunk) {
  var self = this
  self._channel.send(chunk)
}

/**
 * Add a Transceiver to the connection.
 * @param {String} kind
 * @param {Object} init
 */
Peer.prototype.addTransceiver = function (kind, init) {
  var self = this

  self._debug('addTransceiver()')

  if (self.initiator) {
    try {
      self._pc.addTransceiver(kind, init)
      self._needsNegotiation()
    } catch (err) {
      self.destroy(err)
    }
  } else {
    self.emit('signal', { // request initiator to renegotiate
      transceiverRequest: { kind, init }
    })
  }
}

/**
 * Add a MediaStream to the connection.
 * @param {MediaStream} stream
 */
Peer.prototype.addStream = function (stream) {
  var self = this

  self._debug('addStream()')

  stream.getTracks().forEach(function (track) {
    self.addTrack(track, stream)
  })
}

/**
 * Add a MediaStreamTrack to the connection.
 * @param {MediaStreamTrack} track
 * @param {MediaStream} stream
 */
Peer.prototype.addTrack = function (track, stream) {
  var self = this

  self._debug('addTrack()')

  var submap = self._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender
  var sender = submap.get(stream)
  if (!sender) {
    sender = self._pc.addTrack(track, stream)
    submap.set(stream, sender)
    self._senderMap.set(track, submap)
    self._needsNegotiation()
  } else if (sender.removed) {
    self.destroy(makeError('Track has been removed. You should enable/disable tracks that you want to re-add.', 'ERR_SENDER_REMOVED'))
  } else {
    self.destroy(makeError('Track has already been added to that stream.', 'ERR_SENDER_ALREADY_ADDED'))
  }
}

/**
 * Replace a MediaStreamTrack by another in the connection.
 * @param {MediaStreamTrack} oldTrack
 * @param {MediaStreamTrack} newTrack
 * @param {MediaStream} stream
 */
Peer.prototype.replaceTrack = function (oldTrack, newTrack, stream) {
  var self = this

  self._debug('replaceTrack()')

  var submap = self._senderMap.get(oldTrack)
  var sender = submap ? submap.get(stream) : null
  if (!sender) {
    self.destroy(makeError('Cannot replace track that was never added.', 'ERR_TRACK_NOT_ADDED'))
  }
  if (newTrack) self._senderMap.set(newTrack, submap)

  if (sender.replaceTrack != null) {
    sender.replaceTrack(newTrack)
  } else {
    self.destroy(makeError('replaceTrack is not supported in this browser', 'ERR_UNSUPPORTED_REPLACETRACK'))
  }
}

/**
 * Remove a MediaStreamTrack from the connection.
 * @param {MediaStreamTrack} track
 * @param {MediaStream} stream
 */
Peer.prototype.removeTrack = function (track, stream) {
  var self = this

  self._debug('removeSender()')

  var submap = self._senderMap.get(track)
  var sender = submap ? submap.get(stream) : null
  if (!sender) {
    self.destroy(makeError('Cannot remove track that was never added.', 'ERR_TRACK_NOT_ADDED'))
  }
  try {
    sender.removed = true
    self._pc.removeTrack(sender)
  } catch (err) {
    if (err.name === 'NS_ERROR_UNEXPECTED') {
      self._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874
    } else {
      self.destroy(err)
    }
  }
  self._needsNegotiation()
}

/**
 * Remove a MediaStream from the connection.
 * @param {MediaStream} stream
 */
Peer.prototype.removeStream = function (stream) {
  var self = this

  self._debug('removeSenders()')

  stream.getTracks().forEach(function (track) {
    self.removeTrack(track, stream)
  })
}

Peer.prototype._needsNegotiation = function () {
  var self = this

  self._debug('_needsNegotiation')
  if (self._batchedNegotiation) return // batch synchronous renegotiations
  self._batchedNegotiation = true
  setTimeout(function () {
    self._batchedNegotiation = false
    self._debug('starting batched negotiation')
    self.negotiate()
  }, 0)
}

Peer.prototype.negotiate = function () {
  var self = this

  if (self.initiator) {
    if (self._isNegotiating) {
      self._queuedNegotiation = true
      self._debug('already negotiating, queueing')
    } else {
      self._debug('start negotiation')
      setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer
        self._createOffer()
      }, 0)
    }
  } else {
    if (!self._isNegotiating) {
      self._debug('requesting negotiation from initiator')
      self.emit('signal', { // request initiator to renegotiate
        renegotiate: true
      })
    }
  }
  self._isNegotiating = true
}

// TODO: Delete this method once readable-stream is updated to contain a default
// implementation of destroy() that automatically calls _destroy()
// See: https://github.com/nodejs/readable-stream/issues/283
Peer.prototype.destroy = function (err) {
  var self = this
  self._destroy(err, function () {})
}

Peer.prototype._destroy = function (err, cb) {
  var self = this
  if (self.destroyed) return

  self._debug('destroy (error: %s)', err && (err.message || err))

  self.readable = self.writable = false

  if (!self._readableState.ended) self.push(null)
  if (!self._writableState.finished) self.end()

  self.destroyed = true
  self._connected = false
  self._pcReady = false
  self._channelReady = false
  self._remoteTracks = null
  self._remoteStreams = null
  self._senderMap = null

  clearInterval(self._closingInterval)
  self._closingInterval = null

  clearInterval(self._interval)
  self._interval = null
  self._chunk = null
  self._cb = null

  if (self._onFinishBound) self.removeListener('finish', self._onFinishBound)
  self._onFinishBound = null

  if (self._channel) {
    try {
      self._channel.close()
    } catch (err) {}

    self._channel.onmessage = null
    self._channel.onopen = null
    self._channel.onclose = null
    self._channel.onerror = null
  }
  if (self._pc) {
    try {
      self._pc.close()
    } catch (err) {}

    self._pc.oniceconnectionstatechange = null
    self._pc.onicegatheringstatechange = null
    self._pc.onsignalingstatechange = null
    self._pc.onicecandidate = null
    self._pc.ontrack = null
    self._pc.ondatachannel = null
  }
  self._pc = null
  self._channel = null

  if (err) self.emit('error', err)
  self.emit('close')
  cb()
}

Peer.prototype._setupData = function (event) {
  var self = this
  if (!event.channel) {
    // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),
    // which is invalid behavior. Handle it gracefully.
    // See: https://github.com/feross/simple-peer/issues/163
    return self.destroy(makeError('Data channel event is missing `channel` property', 'ERR_DATA_CHANNEL'))
  }

  self._channel = event.channel
  self._channel.binaryType = 'arraybuffer'

  if (typeof self._channel.bufferedAmountLowThreshold === 'number') {
    self._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT
  }

  self.channelName = self._channel.label

  self._channel.onmessage = function (event) {
    self._onChannelMessage(event)
  }
  self._channel.onbufferedamountlow = function () {
    self._onChannelBufferedAmountLow()
  }
  self._channel.onopen = function () {
    self._onChannelOpen()
  }
  self._channel.onclose = function () {
    self._onChannelClose()
  }
  self._channel.onerror = function (err) {
    self.destroy(makeError(err, 'ERR_DATA_CHANNEL'))
  }

  // HACK: Chrome will sometimes get stuck in readyState "closing", let's check for this condition
  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743
  var isClosing = false
  self._closingInterval = setInterval(function () { // No "onclosing" event
    if (self._channel && self._channel.readyState === 'closing') {
      if (isClosing) self._onChannelClose() // closing timed out: equivalent to onclose firing
      isClosing = true
    } else {
      isClosing = false
    }
  }, CHANNEL_CLOSING_TIMEOUT)
}

Peer.prototype._read = function () {}

Peer.prototype._write = function (chunk, encoding, cb) {
  var self = this
  if (self.destroyed) return cb(makeError('cannot write after peer is destroyed', 'ERR_DATA_CHANNEL'))

  if (self._connected) {
    try {
      self.send(chunk)
    } catch (err) {
      return self.destroy(makeError(err, 'ERR_DATA_CHANNEL'))
    }
    if (self._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
      self._debug('start backpressure: bufferedAmount %d', self._channel.bufferedAmount)
      self._cb = cb
    } else {
      cb(null)
    }
  } else {
    self._debug('write before connect')
    self._chunk = chunk
    self._cb = cb
  }
}

// When stream finishes writing, close socket. Half open connections are not
// supported.
Peer.prototype._onFinish = function () {
  var self = this
  if (self.destroyed) return

  if (self._connected) {
    destroySoon()
  } else {
    self.once('connect', destroySoon)
  }

  // Wait a bit before destroying so the socket flushes.
  // TODO: is there a more reliable way to accomplish this?
  function destroySoon () {
    setTimeout(function () {
      self.destroy()
    }, 1000)
  }
}

Peer.prototype._startIceCompleteTimeout = function () {
  var self = this
  if (self.destroyed) return
  if (self._iceCompleteTimer) return
  self._debug('started iceComplete timeout')
  self._iceCompleteTimer = setTimeout(function () {
    if (!self._iceComplete) {
      self._iceComplete = true
      self._debug('iceComplete timeout completed')
      self.emit('iceTimeout')
      self.emit('_iceComplete')
    }
  }, self.iceCompleteTimeout)
}

Peer.prototype._createOffer = function () {
  var self = this
  if (self.destroyed) return

  self._pc.createOffer(self.offerOptions).then(function (offer) {
    if (self.destroyed) return
    if (!self.trickle && !self.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)
    offer.sdp = self.sdpTransform(offer.sdp)
    self._pc.setLocalDescription(offer).then(onSuccess).catch(onError)

    function onSuccess () {
      self._debug('createOffer success')
      if (self.destroyed) return
      if (self.trickle || self._iceComplete) sendOffer()
      else self.once('_iceComplete', sendOffer) // wait for candidates
    }

    function onError (err) {
      self.destroy(makeError(err, 'ERR_SET_LOCAL_DESCRIPTION'))
    }

    function sendOffer () {
      if (self.destroyed) return
      var signal = self._pc.localDescription || offer
      self._debug('signal')
      self.emit('signal', {
        type: signal.type,
        sdp: signal.sdp
      })
    }
  }).catch(function (err) { self.destroy(makeError(err, 'ERR_CREATE_OFFER')) })
}

Peer.prototype._requestMissingTransceivers = function () {
  var self = this

  if (self._pc.getTransceivers) {
    self._pc.getTransceivers().forEach(transceiver => {
      if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {
        transceiver.requested = true // HACK: Safari returns negotiated transceivers with a null mid
        self.addTransceiver(transceiver.sender.track.kind)
      }
    })
  }
}

Peer.prototype._createAnswer = function () {
  var self = this
  if (self.destroyed) return

  self._pc.createAnswer(self.answerOptions).then(function (answer) {
    if (self.destroyed) return
    if (!self.trickle && !self.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)
    answer.sdp = self.sdpTransform(answer.sdp)
    self._pc.setLocalDescription(answer).then(onSuccess).catch(onError)

    function onSuccess () {
      if (self.destroyed) return
      if (self.trickle || self._iceComplete) sendAnswer()
      else self.once('_iceComplete', sendAnswer)
    }

    function onError (err) {
      self.destroy(makeError(err, 'ERR_SET_LOCAL_DESCRIPTION'))
    }

    function sendAnswer () {
      if (self.destroyed) return
      var signal = self._pc.localDescription || answer
      self._debug('signal')
      self.emit('signal', {
        type: signal.type,
        sdp: signal.sdp
      })
      if (!self.initiator) self._requestMissingTransceivers()
    }
  }).catch(function (err) { self.destroy(makeError(err, 'ERR_CREATE_ANSWER')) })
}

Peer.prototype._onIceStateChange = function () {
  var self = this
  if (self.destroyed) return
  var iceConnectionState = self._pc.iceConnectionState
  var iceGatheringState = self._pc.iceGatheringState

  self._debug(
    'iceStateChange (connection: %s) (gathering: %s)',
    iceConnectionState,
    iceGatheringState
  )
  self.emit('iceStateChange', iceConnectionState, iceGatheringState)

  if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {
    self._pcReady = true
    self._maybeReady()
  }
  if (iceConnectionState === 'failed') {
    self.destroy(makeError('Ice connection failed.', 'ERR_ICE_CONNECTION_FAILURE'))
  }
  if (iceConnectionState === 'closed') {
    self.destroy(makeError('Ice connection closed.', 'ERR_ICE_CONNECTION_CLOSED'))
  }
}

Peer.prototype.getStats = function (cb) {
  var self = this

  // Promise-based getStats() (standard)
  if (self._pc.getStats.length === 0) {
    self._pc.getStats().then(function (res) {
      var reports = []
      res.forEach(function (report) {
        reports.push(flattenValues(report))
      })
      cb(null, reports)
    }, function (err) { cb(err) })

  // Two-parameter callback-based getStats() (deprecated, former standard)
  } else if (self._isReactNativeWebrtc) {
    self._pc.getStats(null, function (res) {
      var reports = []
      res.forEach(function (report) {
        reports.push(flattenValues(report))
      })
      cb(null, reports)
    }, function (err) { cb(err) })

  // Single-parameter callback-based getStats() (non-standard)
  } else if (self._pc.getStats.length > 0) {
    self._pc.getStats(function (res) {
      // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed
      if (self.destroyed) return

      var reports = []
      res.result().forEach(function (result) {
        var report = {}
        result.names().forEach(function (name) {
          report[name] = result.stat(name)
        })
        report.id = result.id
        report.type = result.type
        report.timestamp = result.timestamp
        reports.push(flattenValues(report))
      })
      cb(null, reports)
    }, function (err) { cb(err) })

  // Unknown browser, skip getStats() since it's anyone's guess which style of
  // getStats() they implement.
  } else {
    cb(null, [])
  }

  // statreports can come with a value array instead of properties
  function flattenValues (report) {
    if (Object.prototype.toString.call(report.values) === '[object Array]') {
      report.values.forEach(function (value) {
        Object.assign(report, value)
      })
    }
    return report
  }
}

Peer.prototype._maybeReady = function () {
  var self = this
  self._debug('maybeReady pc %s channel %s', self._pcReady, self._channelReady)
  if (self._connected || self._connecting || !self._pcReady || !self._channelReady) return

  self._connecting = true

  // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339
  function findCandidatePair () {
    if (self.destroyed) return

    self.getStats(function (err, items) {
      if (self.destroyed) return

      // Treat getStats error as non-fatal. It's not essential.
      if (err) items = []

      var remoteCandidates = {}
      var localCandidates = {}
      var candidatePairs = {}
      var foundSelectedCandidatePair = false

      items.forEach(function (item) {
        // TODO: Once all browsers support the hyphenated stats report types, remove
        // the non-hypenated ones
        if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {
          remoteCandidates[item.id] = item
        }
        if (item.type === 'localcandidate' || item.type === 'local-candidate') {
          localCandidates[item.id] = item
        }
        if (item.type === 'candidatepair' || item.type === 'candidate-pair') {
          candidatePairs[item.id] = item
        }
      })

      items.forEach(function (item) {
        // Spec-compliant
        if (item.type === 'transport' && item.selectedCandidatePairId) {
          setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])
        }

        // Old implementations
        if (
          (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||
          ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)
        ) {
          setSelectedCandidatePair(item)
        }
      })

      function setSelectedCandidatePair (selectedCandidatePair) {
        foundSelectedCandidatePair = true

        var local = localCandidates[selectedCandidatePair.localCandidateId]

        if (local && (local.ip || local.address)) {
          // Spec
          self.localAddress = local.ip || local.address
          self.localPort = Number(local.port)
        } else if (local && local.ipAddress) {
          // Firefox
          self.localAddress = local.ipAddress
          self.localPort = Number(local.portNumber)
        } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {
          // TODO: remove this once Chrome 58 is released
          local = selectedCandidatePair.googLocalAddress.split(':')
          self.localAddress = local[0]
          self.localPort = Number(local[1])
        }
        if (self.localAddress) {
          self.localFamily = self.localAddress.includes(':') ? 'IPv6' : 'IPv4'
        }

        var remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]

        if (remote && (remote.ip || remote.address)) {
          // Spec
          self.remoteAddress = remote.ip || remote.address
          self.remotePort = Number(remote.port)
        } else if (remote && remote.ipAddress) {
          // Firefox
          self.remoteAddress = remote.ipAddress
          self.remotePort = Number(remote.portNumber)
        } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {
          // TODO: remove this once Chrome 58 is released
          remote = selectedCandidatePair.googRemoteAddress.split(':')
          self.remoteAddress = remote[0]
          self.remotePort = Number(remote[1])
        }
        if (self.remoteAddress) {
          self.remoteFamily = self.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'
        }

        self._debug(
          'connect local: %s:%s remote: %s:%s',
          self.localAddress, self.localPort, self.remoteAddress, self.remotePort
        )
      }

      // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates
      // But wait until at least 1 candidate pair is available
      if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
        setTimeout(findCandidatePair, 100)
        return
      } else {
        self._connecting = false
        self._connected = true
      }

      if (self._chunk) {
        try {
          self.send(self._chunk)
        } catch (err) {
          return self.destroy(makeError(err, 'ERR_DATA_CHANNEL'))
        }
        self._chunk = null
        self._debug('sent chunk from "write before connect"')

        var cb = self._cb
        self._cb = null
        cb(null)
      }

      // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,
      // fallback to using setInterval to implement backpressure.
      if (typeof self._channel.bufferedAmountLowThreshold !== 'number') {
        self._interval = setInterval(function () { self._onInterval() }, 150)
        if (self._interval.unref) self._interval.unref()
      }

      self._debug('connect')
      self.emit('connect')
    })
  }
  findCandidatePair()
}

Peer.prototype._onInterval = function () {
  var self = this
  if (!self._cb || !self._channel || self._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
    return
  }
  self._onChannelBufferedAmountLow()
}

Peer.prototype._onSignalingStateChange = function () {
  var self = this
  if (self.destroyed) return

  if (self._pc.signalingState === 'stable' && !self._firstStable) {
    self._isNegotiating = false

    // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'
    self._debug('flushing sender queue', self._sendersAwaitingStable)
    self._sendersAwaitingStable.forEach(function (sender) {
      self._pc.removeTrack(sender)
      self._queuedNegotiation = true
    })
    self._sendersAwaitingStable = []

    if (self._queuedNegotiation) {
      self._debug('flushing negotiation queue')
      self._queuedNegotiation = false
      self._needsNegotiation() // negotiate again
    }

    self._debug('negotiate')
    self.emit('negotiate')
  }
  self._firstStable = false

  self._debug('signalingStateChange %s', self._pc.signalingState)
  self.emit('signalingStateChange', self._pc.signalingState)
}

Peer.prototype._onIceCandidate = function (event) {
  var self = this
  if (self.destroyed) return
  if (event.candidate && self.trickle) {
    self.emit('signal', {
      candidate: {
        candidate: event.candidate.candidate,
        sdpMLineIndex: event.candidate.sdpMLineIndex,
        sdpMid: event.candidate.sdpMid
      }
    })
  } else if (!event.candidate && !self._iceComplete) {
    self._iceComplete = true
    self.emit('_iceComplete')
  }
  // as soon as we've received one valid candidate start timeout
  if (event.candidate) {
    self._startIceCompleteTimeout()
  }
}

Peer.prototype._onChannelMessage = function (event) {
  var self = this
  if (self.destroyed) return
  var data = event.data
  if (data instanceof ArrayBuffer) data = Buffer.from(data)
  self.push(data)
}

Peer.prototype._onChannelBufferedAmountLow = function () {
  var self = this
  if (self.destroyed || !self._cb) return
  self._debug('ending backpressure: bufferedAmount %d', self._channel.bufferedAmount)
  var cb = self._cb
  self._cb = null
  cb(null)
}

Peer.prototype._onChannelOpen = function () {
  var self = this
  if (self._connected || self.destroyed) return
  self._debug('on channel open')
  self._channelReady = true
  self._maybeReady()
}

Peer.prototype._onChannelClose = function () {
  var self = this
  if (self.destroyed) return
  self._debug('on channel close')
  self.destroy()
}

Peer.prototype._onTrack = function (event) {
  var self = this
  if (self.destroyed) return

  event.streams.forEach(function (eventStream) {
    self._debug('on track')
    self.emit('track', event.track, eventStream)

    self._remoteTracks.push({
      track: event.track,
      stream: eventStream
    })

    if (self._remoteStreams.some(function (remoteStream) {
      return remoteStream.id === eventStream.id
    })) return // Only fire one 'stream' event, even though there may be multiple tracks per stream

    self._remoteStreams.push(eventStream)
    setTimeout(function () {
      self.emit('stream', eventStream) // ensure all tracks have been added
    }, 0)
  })
}

Peer.prototype._debug = function () {
  var self = this
  var args = [].slice.call(arguments)
  args[0] = '[' + self._id + '] ' + args[0]
  debug.apply(null, args)
}

// HACK: Filter trickle lines when trickle is disabled #354
function filterTrickle (sdp) {
  return sdp.replace(/a=ice-options:trickle\s\n/g, '')
}

function makeError (message, code) {
  var err = new Error(message)
  err.code = code
  return err
}

function warn (message) {
  console.warn(message)
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"simple-peer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/simple-peer/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/index.js", {"./manager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/manager.js","./socket":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/socket.js","./url":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/url.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/node_modules/debug/src/browser.js","socket.io-parser":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-parser/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/index.js
      return function (require, module, exports) {

/**
 * Module dependencies.
 */

var url = require('./url');
var parser = require('socket.io-parser');
var Manager = require('./manager');
var debug = require('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup (uri, opts) {
  if (typeof uri === 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.query;
  }
  return io.socket(parsed.path, opts);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = require('./manager');
exports.Socket = require('./socket');

      };
    };
  }
}, {package:"socket.io-client",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/socket.io-client/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/errors.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/errors.js
      return function (require, module, exports) {
'use strict'

exports.messages = {
  NOT_STARTED_YET: 'The libp2p node is not started yet',
  DHT_DISABLED: 'DHT is not available'
}

exports.codes = {
  DHT_DISABLED: 'ERR_DHT_DISABLED',
  PUBSUB_NOT_STARTED: 'ERR_PUBSUB_NOT_STARTED',
  ERR_NODE_NOT_STARTED: 'ERR_NODE_NOT_STARTED',
  ERR_DISCOVERED_SELF: 'ERR_DISCOVERED_SELF'
}

      };
    };
  }
}, {package:"libp2p",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/errors.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/get-peer-info.js", {"err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","multiaddr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","peer-info":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/get-peer-info.js
      return function (require, module, exports) {
'use strict'

const PeerId = require('peer-id')
const PeerInfo = require('peer-info')
const multiaddr = require('multiaddr')
const errCode = require('err-code')

module.exports = (node) => {
  /*
   * Helper method to check the data type of peer and convert it to PeerInfo
   */
  return function (peer, callback) {
    let p
    // PeerInfo
    if (PeerInfo.isPeerInfo(peer)) {
      p = peer
    // Multiaddr instance or Multiaddr String
    } else if (multiaddr.isMultiaddr(peer) || typeof peer === 'string') {
      if (typeof peer === 'string') {
        try {
          peer = multiaddr(peer)
        } catch (err) {
          return callback(
            errCode(err, 'ERR_INVALID_MULTIADDR')
          )
        }
      }

      const peerIdB58Str = peer.getPeerId()

      if (!peerIdB58Str) {
        return callback(
          errCode(
            new Error('peer multiaddr instance or string must include peerId'),
            'ERR_INVALID_MULTIADDR'
          )
        )
      }

      try {
        p = node.peerBook.get(peerIdB58Str)
      } catch (err) {
        p = new PeerInfo(PeerId.createFromB58String(peerIdB58Str))
      }
      p.multiaddrs.add(peer)

      // PeerId
    } else if (PeerId.isPeerId(peer)) {
      const peerIdB58Str = peer.toB58String()
      try {
        p = node.peerBook.get(peerIdB58Str)
      } catch (err) {
        return node.peerRouting.findPeer(peer, callback)
      }
    } else {
      return callback(
        errCode(
          new Error(`${p} is not a valid peer type`),
          'ERR_INVALID_PEER_TYPE'
        )
      )
    }

    callback(null, p)
  }
}

      };
    };
  }
}, {package:"libp2p",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/get-peer-info.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/config.js", {"superstruct":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/superstruct/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/config.js
      return function (require, module, exports) {
'use strict'

const { struct, superstruct } = require('superstruct')
const { optional, list } = struct

// Define custom types
const s = superstruct()
const transport = s.union([
  s.interface({
    createListener: 'function',
    dial: 'function'
  }),
  'function'
])
const modulesSchema = s({
  connEncryption: optional(list([s('object|function')])),
  // this is hacky to simulate optional because interface doesnt work correctly with it
  // change to optional when fixed upstream
  connProtector: s.union(['undefined', s.interface({ protect: 'function' })]),
  contentRouting: optional(list(['object'])),
  dht: optional(s('null|function|object')),
  peerDiscovery: optional(list([s('object|function')])),
  peerRouting: optional(list(['object'])),
  streamMuxer: optional(list([s('object|function')])),
  transport: s.intersection([[transport], s.interface({
    length (v) {
      return v > 0 ? true : 'ERROR_EMPTY'
    }
  })])
})

const configSchema = s({
  peerDiscovery: s('object', {
    autoDial: true
  }),
  relay: s({
    enabled: 'boolean',
    hop: optional(s({
      enabled: 'boolean',
      active: 'boolean'
    }, {
      // HOP defaults
      enabled: false,
      active: false
    }))
  }, {
    // Relay defaults
    enabled: true
  }),
  // DHT config
  dht: s('object?', {
    // DHT defaults
    enabled: false,
    kBucketSize: 20,
    randomWalk: {
      enabled: false, // disabled waiting for https://github.com/libp2p/js-libp2p-kad-dht/issues/86
      queriesPerPeriod: 1,
      interval: 300e3,
      timeout: 10e3
    }
  }),
  // Experimental config
  EXPERIMENTAL: s({
    pubsub: 'boolean'
  }, {
    // Experimental defaults
    pubsub: false
  })
}, {})

const optionsSchema = s({
  switch: 'object?',
  connectionManager: s('object', {
    minPeers: 25
  }),
  datastore: 'object?',
  peerInfo: 'object',
  peerBook: 'object?',
  modules: modulesSchema,
  config: configSchema
})

module.exports.validate = (opts) => {
  const [error, options] = optionsSchema.validate(opts)

  // Improve errors throwed, reduce stack by throwing here and add reason to the message
  if (error) {
    throw new Error(`${error.message}${error.reason ? ' - ' + error.reason : ''}`)
  } else {
    // Throw when dht is enabled but no dht module provided
    if (options.config.dht.enabled) {
      s('function|object')(options.modules.dht)
    }
  }

  if (options.config.peerDiscovery.autoDial === undefined) {
    options.config.peerDiscovery.autoDial = true
  }

  return options
}

      };
    };
  }
}, {package:"libp2p",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/config.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/peer-routing.js", {"async/tryEach":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/tryEach.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/peer-routing.js
      return function (require, module, exports) {
'use strict'

const tryEach = require('async/tryEach')
const errCode = require('err-code')

module.exports = (node) => {
  const routers = node._modules.peerRouting || []

  // If we have the dht, make it first
  if (node._dht) {
    routers.unshift(node._dht)
  }

  return {
    /**
     * Iterates over all peer routers in series to find the given peer.
     *
     * @param {String} id The id of the peer to find
     * @param {object} options
     * @param {number} options.maxTimeout How long the query should run
     * @param {function(Error, Result<Array>)} callback
     * @returns {void}
     */
    findPeer: (id, options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      if (!routers.length) {
        callback(errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE'))
      }

      const tasks = routers.map((router) => {
        return (cb) => router.findPeer(id, options, (err, result) => {
          if (err) {
            return cb(err)
          }

          // If we don't have a result, we need to provide an error to keep trying
          if (!result || Object.keys(result).length === 0) {
            return cb(errCode(new Error('not found'), 'NOT_FOUND'), null)
          }

          cb(null, result)
        })
      })

      tryEach(tasks, (err, results) => {
        if (err) {
          return callback(err)
        }
        results = results || []
        callback(null, results)
      })
    }
  }
}

      };
    };
  }
}, {package:"libp2p",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/peer-routing.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/dht.js", {"./errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/errors.js","async/nextTick":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/dht.js
      return function (require, module, exports) {
'use strict'

const nextTick = require('async/nextTick')
const errCode = require('err-code')

const { messages, codes } = require('./errors')

module.exports = (node) => {
  return {
    put: (key, value, callback) => {
      if (!node._dht) {
        return nextTick(callback, errCode(new Error(messages.DHT_DISABLED), codes.DHT_DISABLED))
      }

      node._dht.put(key, value, callback)
    },
    get: (key, options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      if (!node._dht) {
        return nextTick(callback, errCode(new Error(messages.DHT_DISABLED), codes.DHT_DISABLED))
      }

      node._dht.get(key, options, callback)
    },
    getMany: (key, nVals, options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      if (!node._dht) {
        return nextTick(callback, errCode(new Error(messages.DHT_DISABLED), codes.DHT_DISABLED))
      }

      node._dht.getMany(key, nVals, options, callback)
    }
  }
}

      };
    };
  }
}, {package:"libp2p",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/dht.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/util/index.js", {"once":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/once/once.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/util/index.js
      return function (require, module, exports) {
'use strict'
const once = require('once')

/**
 * Registers `handler` to each event in `events`. The `handler`
 * will only be called for the first event fired, at which point
 * the `handler` will be removed as a listener.
 *
 * Ensures `handler` is only called once.
 *
 * @example
 * // will call `callback` when `start` or `error` is emitted by `this`
 * emitFirst(this, ['error', 'start'], callback)
 *
 * @private
 * @param {EventEmitter} emitter The emitter to listen on
 * @param {Array<string>} events The events to listen for
 * @param {function(*)} handler The handler to call when an event is triggered
 * @returns {void}
 */
function emitFirst (emitter, events, handler) {
  handler = once(handler)
  events.forEach((e) => {
    emitter.once(e, (...args) => {
      events.forEach((ev) => {
        emitter.removeListener(ev, handler)
      })
      handler.apply(emitter, args)
    })
  })
}

module.exports.emitFirst = emitFirst

      };
    };
  }
}, {package:"libp2p",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/util/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/content-routing.js", {"async/parallel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/parallel.js","async/tryEach":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/tryEach.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/content-routing.js
      return function (require, module, exports) {
'use strict'

const tryEach = require('async/tryEach')
const parallel = require('async/parallel')
const errCode = require('err-code')

module.exports = (node) => {
  const routers = node._modules.contentRouting || []

  // If we have the dht, make it first
  if (node._dht) {
    routers.unshift(node._dht)
  }

  return {
    /**
     * Iterates over all content routers in series to find providers of the given key.
     * Once a content router succeeds, iteration will stop.
     *
     * @param {CID} key The CID key of the content to find
     * @param {object} options
     * @param {number} options.maxTimeout How long the query should run
     * @param {number} options.maxNumProviders - maximum number of providers to find
     * @param {function(Error, Result<Array>)} callback
     * @returns {void}
     */
    findProviders: (key, options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      } else if (typeof options === 'number') { // This can be deprecated in a future release
        options = {
          maxTimeout: options
        }
      }

      if (!routers.length) {
        return callback(errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE'))
      }

      const tasks = routers.map((router) => {
        return (cb) => router.findProviders(key, options, (err, results) => {
          if (err) {
            return cb(err)
          }

          // If we don't have any results, we need to provide an error to keep trying
          if (!results || Object.keys(results).length === 0) {
            return cb(errCode(new Error('not found'), 'NOT_FOUND'), null)
          }

          cb(null, results)
        })
      })

      tryEach(tasks, (err, results) => {
        if (err && err.code !== 'NOT_FOUND') {
          return callback(err)
        }
        results = results || []
        callback(null, results)
      })
    },

    /**
     * Iterates over all content routers in parallel to notify it is
     * a provider of the given key.
     *
     * @param {CID} key The CID key of the content to find
     * @param {function(Error)} callback
     * @returns {void}
     */
    provide: (key, callback) => {
      if (!routers.length) {
        return callback(errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE'))
      }

      parallel(routers.map((router) => {
        return (cb) => router.provide(key, cb)
      }), callback)
    }
  }
}

      };
    };
  }
}, {package:"libp2p",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/content-routing.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/index.js", {"./handler":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/handler.js","./ping":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/ping.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/index.js
      return function (require, module, exports) {
'use strict'

const handler = require('./handler')

exports = module.exports = require('./ping')
exports.mount = handler.mount
exports.unmount = handler.unmount

      };
    };
  }
}, {package:"libp2p-ping",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-ping/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/pubsub.js", {"../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","./errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/errors.js","async/nextTick":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","libp2p-floodsub":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-floodsub/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/pubsub.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const nextTick = require('async/nextTick')
const { messages, codes } = require('./errors')
const FloodSub = require('libp2p-floodsub')

const errCode = require('err-code')

module.exports = (node) => {
  const floodSub = new FloodSub(node)

  node._floodSub = floodSub

  return {
    subscribe: (topic, options, handler, callback) => {
      if (typeof options === 'function') {
        callback = handler
        handler = options
        options = {}
      }

      if (!node.isStarted() && !floodSub.started) {
        return nextTick(callback, errCode(new Error(messages.NOT_STARTED_YET), codes.PUBSUB_NOT_STARTED))
      }

      function subscribe (cb) {
        if (floodSub.listenerCount(topic) === 0) {
          floodSub.subscribe(topic)
        }

        floodSub.on(topic, handler)
        nextTick(cb)
      }

      subscribe(callback)
    },

    unsubscribe: (topic, handler, callback) => {
      if (!node.isStarted() && !floodSub.started) {
        return nextTick(callback, errCode(new Error(messages.NOT_STARTED_YET), codes.PUBSUB_NOT_STARTED))
      }
      if (!handler && !callback) {
        floodSub.removeAllListeners(topic)
      } else {
        floodSub.removeListener(topic, handler)
      }

      if (floodSub.listenerCount(topic) === 0) {
        floodSub.unsubscribe(topic)
      }

      if (typeof callback === 'function') {
        nextTick(() => callback())
      }
    },

    publish: (topic, data, callback) => {
      if (!node.isStarted() && !floodSub.started) {
        return nextTick(callback, errCode(new Error(messages.NOT_STARTED_YET), codes.PUBSUB_NOT_STARTED))
      }

      if (!Buffer.isBuffer(data)) {
        return nextTick(callback, errCode(new Error('data must be a Buffer'), 'ERR_DATA_IS_NOT_A_BUFFER'))
      }

      floodSub.publish(topic, data, callback)
    },

    ls: (callback) => {
      if (!node.isStarted() && !floodSub.started) {
        return nextTick(callback, errCode(new Error(messages.NOT_STARTED_YET), codes.PUBSUB_NOT_STARTED))
      }

      const subscriptions = Array.from(floodSub.subscriptions)

      nextTick(() => callback(null, subscriptions))
    },

    peers: (topic, callback) => {
      if (!node.isStarted() && !floodSub.started) {
        return nextTick(callback, errCode(new Error(messages.NOT_STARTED_YET), codes.PUBSUB_NOT_STARTED))
      }

      if (typeof topic === 'function') {
        callback = topic
        topic = null
      }

      const peers = Array.from(floodSub.peers.values())
        .filter((peer) => topic ? peer.topics.has(topic) : true)
        .map((peer) => peer.info.id.toB58String())

      nextTick(() => callback(null, peers))
    },

    setMaxListeners (n) {
      return floodSub.setMaxListeners(n)
    }
  }
}

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

      };
    };
  }
}, {package:"libp2p",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p/src/pubsub.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-connection-manager/src/index.js", {"debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","latency-monitor":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/latency-monitor/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-connection-manager/src/index.js
      return function (require, module, exports) {
'use strict'

const EventEmitter = require('events')
const LatencyMonitor = require('latency-monitor').default
const debug = require('debug')('libp2p:connection-manager')

const defaultOptions = {
  maxPeers: Infinity,
  minPeers: 0,
  maxData: Infinity,
  maxSentData: Infinity,
  maxReceivedData: Infinity,
  maxEventLoopDelay: Infinity,
  pollInterval: 2000,
  movingAverageInterval: 60000,
  defaultPeerValue: 1
}

class ConnectionManager extends EventEmitter {
  constructor (libp2p, options) {
    super()
    this._libp2p = libp2p
    this._options = Object.assign({}, defaultOptions, options)
    this._options.maxPeersPerProtocol = fixMaxPeersPerProtocol(this._options.maxPeersPerProtocol)

    debug('options: %j', this._options)

    this._stats = libp2p.stats
    if (options && !this._stats) {
      throw new Error('No libp2p.stats')
    }

    this._peerValues = new Map()
    this._peers = new Map()
    this._peerProtocols = new Map()
    this._peerCountPerProtocol = new Map()
    this._onStatsUpdate = this._onStatsUpdate.bind(this)
    this._onPeerConnect = this._onPeerConnect.bind(this)
    this._onPeerDisconnect = this._onPeerDisconnect.bind(this)

    if (this._libp2p.isStarted()) {
      this._onceStarted()
    } else {
      this._libp2p.once('start', this._onceStarted.bind(this))
    }
  }

  start () {
    this._stats.on('update', this._onStatsUpdate)
    this._libp2p.on('connection:start', this._onPeerConnect)
    this._libp2p.on('connection:end', this._onPeerDisconnect)
    // latency monitor
    this._latencyMonitor = new LatencyMonitor({
      dataEmitIntervalMs: this._options.pollInterval
    })
    this._onLatencyMeasure = this._onLatencyMeasure.bind(this)
    this._latencyMonitor.on('data', this._onLatencyMeasure)
  }

  stop () {
    this._stats.removeListener('update', this._onStatsUpdate)
    this._libp2p.removeListener('connection:start', this._onPeerConnect)
    this._libp2p.removeListener('connection:end', this._onPeerDisconnect)
    this._latencyMonitor.removeListener('data', this._onLatencyMeasure)
  }

  setPeerValue (peerId, value) {
    if (value < 0 || value > 1) {
      throw new Error('value should be a number between 0 and 1')
    }
    if (peerId.toB58String) {
      peerId = peerId.toB58String()
    }
    this._peerValues.set(peerId, value)
  }

  _onceStarted () {
    this._peerId = this._libp2p.peerInfo.id.toB58String()
  }

  _onStatsUpdate () {
    const movingAvgs = this._stats.global.movingAverages
    const received = movingAvgs.dataReceived[this._options.movingAverageInterval].movingAverage()
    this._checkLimit('maxReceivedData', received)
    const sent = movingAvgs.dataSent[this._options.movingAverageInterval].movingAverage()
    this._checkLimit('maxSentData', sent)
    const total = received + sent
    this._checkLimit('maxData', total)
    debug('stats update', total)
  }

  _onPeerConnect (peerInfo) {
    const peerId = peerInfo.id.toB58String()
    debug('%s: connected to %s', this._peerId, peerId)
    this._peerValues.set(peerId, this._options.defaultPeerValue)
    this._peers.set(peerId, peerInfo)
    this.emit('connected', peerId)
    this._checkLimit('maxPeers', this._peers.size)

    protocolsFromPeerInfo(peerInfo).forEach((protocolTag) => {
      const protocol = this._peerCountPerProtocol[protocolTag]
      if (!protocol) {
        this._peerCountPerProtocol[protocolTag] = 0
      }
      this._peerCountPerProtocol[protocolTag]++

      let peerProtocols = this._peerProtocols[peerId]
      if (!peerProtocols) {
        peerProtocols = this._peerProtocols[peerId] = new Set()
      }
      peerProtocols.add(protocolTag)
      this._checkProtocolMaxPeersLimit(protocolTag, this._peerCountPerProtocol[protocolTag])
    })
  }

  _onPeerDisconnect (peerInfo) {
    const peerId = peerInfo.id.toB58String()
    debug('%s: disconnected from %s', this._peerId, peerId)
    this._peerValues.delete(peerId)
    this._peers.delete(peerId)

    const peerProtocols = this._peerProtocols[peerId]
    if (peerProtocols) {
      Array.from(peerProtocols).forEach((protocolTag) => {
        const peerCountForProtocol = this._peerCountPerProtocol[protocolTag]
        if (peerCountForProtocol) {
          this._peerCountPerProtocol[protocolTag]--
        }
      })
    }

    this.emit('disconnected', peerId)
  }

  _onLatencyMeasure (summary) {
    this._checkLimit('maxEventLoopDelay', summary.avgMs)
  }

  _checkLimit (name, value) {
    const limit = this._options[name]
    debug('checking limit of %s. current value: %d of %d', name, value, limit)
    if (value > limit) {
      debug('%s: limit exceeded: %s, %d', this._peerId, name, value)
      this.emit('limit:exceeded', name, value)
      this._maybeDisconnectOne()
    }
  }

  _checkProtocolMaxPeersLimit (protocolTag, value) {
    debug('checking protocol limit. current value of %s is %d', protocolTag, value)
    const limit = this._options.maxPeersPerProtocol[protocolTag]
    if (value > limit) {
      debug('%s: protocol max peers limit exceeded: %s, %d', this._peerId, protocolTag, value)
      this.emit('limit:exceeded', protocolTag, value)
      this._maybeDisconnectOne()
    }
  }

  _maybeDisconnectOne () {
    if (this._options.minPeers < this._peerValues.size) {
      const peerValues = Array.from(this._peerValues).sort(byPeerValue)
      debug('%s: sorted peer values: %j', this._peerId, peerValues)
      const disconnectPeer = peerValues[0]
      if (disconnectPeer) {
        const peerId = disconnectPeer[0]
        debug('%s: lowest value peer is %s', this._peerId, peerId)
        debug('%s: forcing disconnection from %j', this._peerId, peerId)
        this._disconnectPeer(peerId)
      }
    }
  }

  _disconnectPeer (peerId) {
    debug('preemptively disconnecting peer', peerId)
    this.emit('%s: disconnect:preemptive', this._peerId, peerId)
    const peer = this._peers.get(peerId)
    this._libp2p.hangUp(peer, (err) => {
      if (err) {
        this.emit('error', err)
      }
    })
  }
}

module.exports = ConnectionManager

function byPeerValue (peerValueEntryA, peerValueEntryB) {
  return peerValueEntryA[1] - peerValueEntryB[1]
}

function fixMaxPeersPerProtocol (maxPeersPerProtocol) {
  if (!maxPeersPerProtocol) {
    maxPeersPerProtocol = {}
  }

  Object.keys(maxPeersPerProtocol).forEach((transportTag) => {
    const max = maxPeersPerProtocol[transportTag]
    delete maxPeersPerProtocol[transportTag]
    maxPeersPerProtocol[transportTag.toLowerCase()] = max
  })

  return maxPeersPerProtocol
}

function protocolsFromPeerInfo (peerInfo) {
  const protocolTags = new Set()
  peerInfo.multiaddrs.forEach((multiaddr) => {
    multiaddr.protos().map(protocolToProtocolTag).forEach((protocolTag) => {
      protocolTags.add(protocolTag)
    })
  })

  return Array.from(protocolTags)
}

function protocolToProtocolTag (protocol) {
  return protocol.name.toLowerCase()
}

      };
    };
  }
}, {package:"libp2p-connection-manager",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-connection-manager/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/index.js", {"./connection/handler":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/connection/handler.js","./connection/manager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/connection/manager.js","./dialer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/dialer/index.js","./errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/errors.js","./get-peer-info":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/get-peer-info.js","./observer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/observer.js","./plaintext":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/plaintext.js","./protocol-muxer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/protocol-muxer.js","./stats":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/stats/index.js","./transport":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/transport.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","async/each":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/each.js","async/eachSeries":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/eachSeries.js","async/series":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/series.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","fsm-event":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fsm-event/index.js","libp2p-circuit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-circuit/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/index.js
      return function (require, module, exports) {
'use strict'

const FSM = require('fsm-event')
const EventEmitter = require('events').EventEmitter
const each = require('async/each')
const eachSeries = require('async/eachSeries')
const series = require('async/series')
const Circuit = require('libp2p-circuit')
const TransportManager = require('./transport')
const ConnectionManager = require('./connection/manager')
const getPeerInfo = require('./get-peer-info')
const getDialer = require('./dialer')
const connectionHandler = require('./connection/handler')
const ProtocolMuxer = require('./protocol-muxer')
const plaintext = require('./plaintext')
const Observer = require('./observer')
const Stats = require('./stats')
const assert = require('assert')
const Errors = require('./errors')
const debug = require('debug')
const log = debug('libp2p:switch')
log.error = debug('libp2p:switch:error')

/**
 * @fires Switch#stop Triggered when the switch has stopped
 * @fires Switch#start Triggered when the switch has started
 * @fires Switch#error Triggered whenever an error occurs
 */
class Switch extends EventEmitter {
  constructor (peerInfo, peerBook, options) {
    super()
    assert(peerInfo, 'You must provide a `peerInfo`')
    assert(peerBook, 'You must provide a `peerBook`')

    this._peerInfo = peerInfo
    this._peerBook = peerBook
    this._options = options || {}

    this.setMaxListeners(Infinity)
    // transports --
    // { key: transport }; e.g { tcp: <tcp> }
    this.transports = {}

    // connections --
    // { peerIdB58: { conn: <conn> }}
    this.conns = {}

    // { protocol: handler }
    this.protocols = {}

    // { muxerCodec: <muxer> } e.g { '/spdy/0.3.1': spdy }
    this.muxers = {}

    // is the Identify protocol enabled?
    this.identify = false

    // Crypto details
    this.crypto = plaintext

    this.protector = this._options.protector || null

    this.transport = new TransportManager(this)
    this.connection = new ConnectionManager(this)

    this.observer = Observer(this)
    this.stats = Stats(this.observer, this._options.stats)
    this.protocolMuxer = ProtocolMuxer(this.protocols, this.observer)

    // All purpose connection handler for managing incoming connections
    this._connectionHandler = connectionHandler(this)

    // Setup the internal state
    this.state = new FSM('STOPPED', {
      STOPPED: {
        start: 'STARTING',
        stop: 'STOPPING' // ensures that any transports that were manually started are stopped
      },
      STARTING: {
        done: 'STARTED',
        stop: 'STOPPING'
      },
      STARTED: {
        stop: 'STOPPING',
        start: 'STARTED'
      },
      STOPPING: {
        stop: 'STOPPING',
        done: 'STOPPED'
      }
    })
    this.state.on('STARTING', () => {
      log('The switch is starting')
      this._onStarting()
    })
    this.state.on('STOPPING', () => {
      log('The switch is stopping')
      this._onStopping()
    })
    this.state.on('STARTED', () => {
      log('The switch has started')
      this.emit('start')
    })
    this.state.on('STOPPED', () => {
      log('The switch has stopped')
      this.emit('stop')
    })
    this.state.on('error', (err) => {
      log.error(err)
      this.emit('error', err)
    })

    // higher level (public) API
    this.dialer = getDialer(this)
    this.dial = this.dialer.dial
    this.dialFSM = this.dialer.dialFSM
  }

  /**
   * Returns a list of the transports peerInfo has addresses for
   *
   * @param {PeerInfo} peerInfo
   * @returns {Array<Transport>}
   */
  availableTransports (peerInfo) {
    const myAddrs = peerInfo.multiaddrs.toArray()
    const myTransports = Object.keys(this.transports)

    // Only listen on transports we actually have addresses for
    return myTransports.filter((ts) => this.transports[ts].filter(myAddrs).length > 0)
      // push Circuit to be the last proto to be dialed, and alphabetize the others
      .sort((a, b) => {
        if (a === Circuit.tag) return 1
        if (b === Circuit.tag) return -1
        return a < b ? -1 : 1
      })
  }

  /**
   * Adds the `handlerFunc` and `matchFunc` to the Switch's protocol
   * handler list for the given `protocol`. If the `matchFunc` returns
   * true for a protocol check, the `handlerFunc` will be called.
   *
   * @param {string} protocol
   * @param {function(string, Connection)} handlerFunc
   * @param {function(string, string, function(Error, boolean))} matchFunc
   * @returns {void}
   */
  handle (protocol, handlerFunc, matchFunc) {
    this.protocols[protocol] = {
      handlerFunc: handlerFunc,
      matchFunc: matchFunc
    }
    this._peerInfo.protocols.add(protocol)
  }

  /**
   * Removes the given protocol from the Switch's protocol list
   *
   * @param {string} protocol
   * @returns {void}
   */
  unhandle (protocol) {
    if (this.protocols[protocol]) {
      delete this.protocols[protocol]
    }
    this._peerInfo.protocols.delete(protocol)
  }

  /**
   * If a muxed Connection exists for the given peer, it will be closed
   * and its reference on the Switch will be removed.
   *
   * @param {PeerInfo|Multiaddr|PeerId} peer
   * @param {function()} callback
   * @returns {void}
   */
  hangUp (peer, callback) {
    const peerInfo = getPeerInfo(peer, this._peerBook)
    const key = peerInfo.id.toB58String()
    const conns = [...this.connection.getAllById(key)]
    each(conns, (conn, cb) => {
      conn.once('close', cb)
      conn.close()
    }, callback)
  }

  /**
   * Returns whether or not the switch has any transports
   *
   * @returns {boolean}
   */
  hasTransports () {
    const transports = Object.keys(this.transports).filter((t) => t !== Circuit.tag)
    return transports && transports.length > 0
  }

  /**
   * Issues a start on the Switch state.
   *
   * @param {function} callback deprecated: Listening for the `error` and `start` events are recommended
   * @returns {void}
   */
  start (callback = () => {}) {
    // Add once listener for deprecated callback support
    this.once('start', callback)

    this.state('start')
  }

  /**
   * Issues a stop on the Switch state.
   *
   * @param {function} callback deprecated: Listening for the `error` and `stop` events are recommended
   * @returns {void}
   */
  stop (callback = () => {}) {
    // Add once listener for deprecated callback support
    this.once('stop', callback)

    this.state('stop')
  }

  /**
   * A listener that will start any necessary services and listeners
   *
   * @private
   * @returns {void}
   */
  _onStarting () {
    this.stats.start()
    eachSeries(this.availableTransports(this._peerInfo), (ts, cb) => {
      // Listen on the given transport
      this.transport.listen(ts, {}, null, cb)
    }, (err) => {
      if (err) {
        log.error(err)
        this.emit('error', err)
        return this.state('stop')
      }
      this.state('done')
    })
  }

  /**
   * A listener that will turn off all running services and listeners
   *
   * @private
   * @returns {void}
   */
  _onStopping () {
    this.stats.stop()
    series([
      (cb) => {
        each(this.transports, (transport, cb) => {
          each(transport.listeners, (listener, cb) => {
            listener.close((err) => {
              if (err) log.error(err)
              cb()
            })
          }, cb)
        }, cb)
      },
      (cb) => each(this.connection.getAll(), (conn, cb) => {
        conn.once('close', cb)
        conn.close()
      }, cb)
    ], (_) => {
      this.state('done')
    })
  }
}

module.exports = Switch
module.exports.errors = Errors

      };
    };
  }
}, {package:"libp2p-switch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-switch/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/through.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/through.js
      return function (require, module, exports) {

module.exports = function () {
  var read, reader, cb, abort, stream

  function delayed (_read) {
    //if we already have the stream, go!
    if(stream) return stream(_read)

    read = _read
    return function (_abort, _cb) {
      if(reader) reader(_abort, _cb)
      else abort = _abort, cb = _cb

    }
  }

  delayed.resolve = function (_stream) {
    if(stream) throw new Error('already resolved')
    stream = _stream
    if(!stream) throw new Error('resolve *must* be passed a transform stream')
    if(read) {
      reader = stream(read)
      if(cb) reader(abort, cb)
    }
  }

  return delayed
}

      };
    };
  }
}, {package:"pull-defer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/through.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/sink.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/sink.js
      return function (require, module, exports) {
module.exports = function (stream) {
  var read, started = false

  function consume (_read) {
    if(!_read) throw new Error('must be passed a readable')
    read = _read
    if(started) stream(read)
  }

  consume.resolve =
  consume.ready =
  consume.start = function (_stream) {
    started = true; stream = _stream || stream
    if(read) stream(read)
    return consume
  }

  return consume
}

      };
    };
  }
}, {package:"pull-defer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/sink.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/duplex.js", {"./sink":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/sink.js","./source":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/source.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/duplex.js
      return function (require, module, exports) {

var Source = require('./source')
var Sink = require('./sink')

module.exports = function () {

  var source = Source()
  var sink = Sink()

  return {
    source: source,
    sink: sink,
    resolve: function (duplex) {
      source.resolve(duplex.source)
      sink.resolve(duplex.sink)

    }
  }


}

      };
    };
  }
}, {package:"pull-defer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-defer/duplex.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-last/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-last/index.js
      return function (require, module, exports) {
'use strict'

const last = async (iterator) => {
  let res

  for await (const entry of iterator) {
    res = entry
  }

  return res
}

module.exports = last

      };
    };
  }
}, {package:"async-iterator-last",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-last/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/index.js", {"./dag-cbor":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/dag-cbor.js","./raw":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/raw.js","./unixfs-v1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/index.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/index.js
      return function (require, module, exports) {
'use strict'

const errCode = require('err-code')

const resolvers = {
  'dag-pb': require('./unixfs-v1'),
  raw: require('./raw'),
  'dag-cbor': require('./dag-cbor')
}

const resolve = (cid, name, path, toResolve, depth, ipld) => {
  const resolver = resolvers[cid.codec]

  if (!resolver) {
    throw errCode(new Error(`No resolver for codec ${cid.codec}`), 'ERR_NO_RESOLVER')
  }

  return resolver(cid, name, path, toResolve, resolve, depth, ipld)
}

module.exports = resolve

      };
    };
  }
}, {package:"ipfs-unixfs-exporter",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/resolvers/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/util/abort-cb.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/util/abort-cb.js
      return function (require, module, exports) {
module.exports = function abortCb(cb, abort, onAbort) {
  cb(abort)
  onAbort && onAbort(abort === true ? null: abort)
  return
}


      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/util/abort-cb.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/util/tester.js", {"./prop":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/util/prop.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/util/tester.js
      return function (require, module, exports) {
var prop = require('./prop')

function id (e) { return e }

module.exports = function tester (test) {
  return (
    'object' === typeof test && 'function' === typeof test.test //regexp
    ? function (data) { return test.test(data) }
    : prop (test) || id
  )
}

      };
    };
  }
}, {package:"pull-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/util/tester.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/is-buffer/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/is-buffer/index.js
      return function (require, module, exports) {
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

module.exports = function isBuffer (obj) {
  return obj != null && obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

      };
    };
  }
}, {package:"is-buffer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/is-buffer/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/is-stream/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/is-stream/index.js
      return function (require, module, exports) {
'use strict';

const isStream = stream =>
	stream !== null &&
	typeof stream === 'object' &&
	typeof stream.pipe === 'function';

isStream.writable = stream =>
	isStream(stream) &&
	stream.writable !== false &&
	typeof stream._write === 'function' &&
	typeof stream._writableState === 'object';

isStream.readable = stream =>
	isStream(stream) &&
	stream.readable !== false &&
	typeof stream._read === 'function' &&
	typeof stream._readableState === 'object';

isStream.duplex = stream =>
	isStream.writable(stream) &&
	isStream.readable(stream);

isStream.transform = stream =>
	isStream.duplex(stream) &&
	typeof stream._transform === 'function' &&
	typeof stream._transformState === 'object';

module.exports = isStream;

      };
    };
  }
}, {package:"is-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/is-stream/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/looper/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/looper/index.js
      return function (require, module, exports) {

var looper = module.exports = function (fun) {
  (function next () {
    var loop = true, returned = false, sync = false
    do {
      sync = true; loop = false
      fun.call(this, function () {
        if(sync) loop = true
        else     next()
      })
      sync = false
    } while(loop)
  })()
}

      };
    };
  }
}, {package:"looper",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/looper/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/readable-browser.js", {"./lib/_stream_duplex.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_passthrough.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_passthrough.js","./lib/_stream_readable.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_transform.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_writable.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/_stream_writable.js","./lib/internal/streams/end-of-stream.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","./lib/internal/streams/pipeline.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/lib/internal/streams/pipeline.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/readable-browser.js
      return function (require, module, exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-utils/node_modules/readable-stream/readable-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/tree-builder.js", {"./dir":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dir.js","./dir-flat":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dir-flat.js","./flat-to-shard":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/flat-to-shard.js","./utils/to-path-components":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/utils/to-path-components.js","async-iterator-first":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-first/index.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/tree-builder.js
      return function (require, module, exports) {
'use strict'

const DirFlat = require('./dir-flat')
const flatToShard = require('./flat-to-shard')
const Dir = require('./dir')
const toPathComponents = require('./utils/to-path-components')
const errCode = require('err-code')
const first = require('async-iterator-first')

async function addToTree (elem, tree, options) {
  const pathElems = toPathComponents(elem.path || '')
  const lastIndex = pathElems.length - 1
  let parent = tree
  let currentPath = ''

  for (let i = 0; i < pathElems.length; i++) {
    const pathElem = pathElems[i]

    currentPath += `${currentPath ? '/' : ''}${pathElem}`

    const last = (i === lastIndex)
    parent.dirty = true
    parent.cid = null
    parent.size = null

    if (last) {
      await parent.put(pathElem, elem)
      tree = await flatToShard(null, parent, options.shardSplitThreshold, options)
    } else {
      let dir = await parent.get(pathElem)

      if (!dir || !(dir instanceof Dir)) {
        dir = new DirFlat({
          dir: true,
          parent: parent,
          parentKey: pathElem,
          path: currentPath,
          dirty: true,
          flat: true
        }, options)
      }

      await parent.put(pathElem, dir)

      parent = dir
    }
  }

  return tree
}

async function * treeBuilder (source, ipld, options) {
  let tree = new DirFlat({
    root: true,
    dir: true,
    path: '',
    dirty: true,
    flat: true
  }, options)

  for await (const entry of source) {
    tree = await addToTree(entry, tree, options)

    yield entry
  }

  if (tree) {
    if (!options.wrapWithDirectory) {
      if (tree.childCount() > 1) {
        throw errCode(new Error('detected more than one root'), 'ERR_MORE_THAN_ONE_ROOT')
      }

      const unwrapped = await first(tree.eachChildSeries())

      if (!unwrapped) {
        return
      }

      tree = unwrapped.child
    }

    if (!tree.dir) {
      return
    }

    for await (const entry of tree.flush(tree.path, ipld)) {
      yield entry
    }
  }
}

module.exports = treeBuilder

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/tree-builder.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/index.js", {"../chunker":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/chunker/index.js","./dir":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/dir.js","./file":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/file/index.js","./validate-chunks":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/validate-chunks.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/index.js
      return function (require, module, exports) {
'use strict'

const dirBuilder = require('./dir')
const fileBuilder = require('./file')
const createChunker = require('../chunker')
const validateChunks = require('./validate-chunks')

async function * dagBuilder (source, ipld, options) {
  for await (const entry of source) {
    if (entry.path) {
      if (entry.path.substring(0, 2) === './') {
        options.wrapWithDirectory = true
      }

      entry.path = entry.path
        .split('/')
        .filter(path => path && path !== '.')
        .join('/')
    }

    if (entry.content) {
      let source = entry.content

      // wrap in iterator if it is array-like or not an iterator
      if ((!source[Symbol.asyncIterator] && !source[Symbol.iterator]) || source.length !== undefined) {
        source = {
          [Symbol.iterator]: function * () {
            yield entry.content
          }
        }
      }

      const chunker = createChunker(options.chunker, validateChunks(source), options.chunkerOptions)

      // item is a file
      yield fileBuilder(entry, chunker, ipld, options)
    } else {
      // item is a directory
      yield dirBuilder(entry, ipld, options)
    }
  }
}

module.exports = dagBuilder

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/dag-builder/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/errors-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/errors-browser.js
      return function (require, module, exports) {
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/errors-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/destroy.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/destroy.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/destroy.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/stream-browser.js", {"events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/stream-browser.js
      return function (require, module, exports) {
module.exports = require('events').EventEmitter;

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/stream-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/state.js", {"../../../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/errors-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/state.js
      return function (require, module, exports) {
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/state.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/from-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/from-browser.js
      return function (require, module, exports) {
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/from-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/buffer_list.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/buffer_list.js
      return function (require, module, exports) {
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/buffer_list.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/async_iterator.js", {"./end-of-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/async_iterator.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/lib/internal/streams/async_iterator.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js", {"../../../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/errors-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
      return function (require, module, exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js", {"../../../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/errors-browser.js","./end-of-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js
      return function (require, module, exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_duplex.js", {"./_stream_readable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_writable.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_duplex.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_duplex.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_passthrough.js", {"./_stream_transform":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_transform.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_passthrough.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_passthrough.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_transform.js", {"../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_duplex.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_transform.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_transform.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_writable.js", {"../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_duplex.js","./internal/streams/destroy":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/state":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/state.js","./internal/streams/stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","util-deprecate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/util-deprecate/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_writable.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_writable.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_readable.js", {"../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_duplex.js","./internal/streams/async_iterator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js","./internal/streams/buffer_list":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js","./internal/streams/destroy":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/from":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/from-browser.js","./internal/streams/state":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/state.js","./internal/streams/stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","string_decoder/":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/string_decoder/lib/string_decoder.js","util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_readable.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/node_modules/readable-stream/lib/_stream_readable.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/read.js", {"./utils/apply-default-options":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/apply-default-options.js","./utils/to-mfs-path":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-mfs-path.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","ipfs-unixfs-exporter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/read.js
      return function (require, module, exports) {
'use strict'

const exporter = require('ipfs-unixfs-exporter')
const applyDefaultOptions = require('./utils/apply-default-options')
const toMfsPath = require('./utils/to-mfs-path')
const errCode = require('err-code')

const defaultOptions = {
  offset: 0,
  length: Infinity
}

module.exports = (context) => {
  return function mfsRead (path, options = {}) {
    options = applyDefaultOptions(options, defaultOptions)

    return {
      [Symbol.asyncIterator]: async function * read () {
        const mfsPath = await toMfsPath(context, path)
        const result = await exporter(mfsPath.mfsPath, context.ipld)

        if (result.unixfs.type !== 'file') {
          throw errCode(new Error(`${path} was not a file`), 'ERR_NOT_FILE')
        }

        if (!result.content) {
          throw errCode(new Error(`Could not load content stream from ${path}`), 'ERR_NO_CONTENT')
        }

        for await (const buf of result.content({
          offset: options.offset,
          length: options.length
        })) {
          yield buf
        }
      }
    }
  }
}

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/read.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/ls.js", {"./utils/apply-default-options":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/apply-default-options.js","./utils/constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/constants.js","./utils/to-mfs-path":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-mfs-path.js","ipfs-unixfs-exporter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/ls.js
      return function (require, module, exports) {
'use strict'

const exporter = require('ipfs-unixfs-exporter')
const applyDefaultOptions = require('./utils/apply-default-options')
const toMfsPath = require('./utils/to-mfs-path')
const {
  FILE_SEPARATOR,
  FILE_TYPES
} = require('./utils/constants')

const defaultOptions = {

}

const toOutput = (fsEntry) => {
  let type = 0
  let size = fsEntry.node.size || fsEntry.node.length

  if (fsEntry.unixfs) {
    size = fsEntry.unixfs.fileSize()
    type = FILE_TYPES[fsEntry.unixfs.type]
  }

  return {
    cid: fsEntry.cid,
    name: fsEntry.name,
    type,
    size
  }
}

module.exports = (context) => {
  return async function * mfsLs (path = FILE_SEPARATOR, options = {}) {
    if (typeof path === 'object' && !(path instanceof String)) {
      options = path
      path = FILE_SEPARATOR
    }

    options = applyDefaultOptions(options, defaultOptions)

    const mfsPath = await toMfsPath(context, path)
    const fsDir = await exporter(mfsPath.mfsPath, context.ipld)

    // single file/node
    if (!fsDir.unixfs || !fsDir.unixfs.type.includes('directory')) {
      yield toOutput(fsDir)

      return
    }

    // directory, perhaps sharded
    for await (const fsEntry of fsDir.content(options)) {
      yield toOutput(fsEntry)
    }
  }
}

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/ls.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/mv.js", {"./cp":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/cp.js","./rm":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/rm.js","./utils/apply-default-options":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/apply-default-options.js","./utils/to-sources":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-sources.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/mv.js
      return function (require, module, exports) {
'use strict'

const applyDefaultOptions = require('./utils/apply-default-options')
const toSources = require('./utils/to-sources')
const cp = require('./cp')
const rm = require('./rm')

const defaultOptions = {
  parents: false,
  recursive: false,
  flush: true,
  format: 'dag-pb',
  hashAlg: 'sha2-256',
  shardSplitThreshold: 1000
}

module.exports = (context) => {
  return async function mfsMv (...args) {
    if (Array.isArray(args[0])) {
      args = args[0].concat(args.slice(1))
    }

    const {
      sources
    } = await toSources(context, args)
    const options = applyDefaultOptions(args, defaultOptions)

    const cpArgs = sources
      .map(source => source.path).concat(options)

    // remove the last source as it'll be the destination
    const rmArgs = sources
      .slice(0, -1)
      .map(source => source.path)
      .concat(Object.assign(options, {
        recursive: true
      }))

    await cp(context).apply(null, cpArgs)
    await rm(context).apply(null, rmArgs)
  }
}

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/mv.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/stat.js", {"./utils/apply-default-options":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/apply-default-options.js","./utils/to-mfs-path":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-mfs-path.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","ipfs-unixfs-exporter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/stat.js
      return function (require, module, exports) {
'use strict'

const applyDefaultOptions = require('./utils/apply-default-options')
const toMfsPath = require('./utils/to-mfs-path')
const exporter = require('ipfs-unixfs-exporter')
const log = require('debug')('ipfs:mfs:stat')
const errCode = require('err-code')

const defaultOptions = {
  withLocal: false
}

module.exports = (context) => {
  return async function mfsStat (path, options) {
    options = applyDefaultOptions(options, defaultOptions)

    log(`Fetching stats for ${path}`)

    const {
      type,
      cid,
      mfsPath
    } = await toMfsPath(context, path)

    let exportPath = type === 'ipfs' && cid ? cid : mfsPath
    let file

    try {
      file = await exporter(exportPath, context.ipld)
    } catch (err) {
      if (err.code === 'ERR_NOT_FOUND') {
        throw errCode(new Error(`${path} does not exist`), 'ERR_NOT_FOUND')
      }

      throw err
    }

    if (!statters[file.cid.codec]) {
      throw new Error(`Cannot stat codec ${file.cid.codec}`)
    }

    return statters[file.cid.codec](file, options)
  }
}

const statters = {
  raw: (file) => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      blocks: 0,
      type: 'file', // for go compatibility
      local: undefined,
      sizeLocal: undefined,
      withLocality: false
    }
  },
  'dag-pb': (file) => {
    let blocks = file.node.Links.length
    let size = file.node.size
    let cumulativeSize = file.node.size
    let nodeType = null

    if (file.unixfs) {
      size = file.unixfs.fileSize()
      nodeType = file.unixfs.type

      if (nodeType.includes('directory')) {
        size = 0
        cumulativeSize = file.node.size
      }

      if (nodeType === 'file') {
        blocks = file.unixfs.blockSizes.length
      }
    }

    return {
      cid: file.cid,
      size: size,
      cumulativeSize: cumulativeSize,
      blocks: blocks,
      type: nodeType,
      local: undefined,
      sizeLocal: undefined,
      withLocality: false
    }
  },
  'dag-cbor': (file) => {
    return {
      cid: file.cid,
      local: undefined,
      sizeLocal: undefined,
      withLocality: false
    }
  }
}

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/stat.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/flush.js", {"./stat":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/stat.js","./utils/apply-default-options":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/apply-default-options.js","./utils/constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/constants.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/flush.js
      return function (require, module, exports) {
'use strict'

const applyDefaultOptions = require('./utils/apply-default-options')
const stat = require('./stat')
const {
  FILE_SEPARATOR
} = require('./utils/constants')

const defaultOptions = {}

module.exports = (context) => {
  return async function mfsFlush (path = FILE_SEPARATOR, options = defaultOptions) {
    options = applyDefaultOptions(options, defaultOptions)

    await stat(context)(path, options)
  }
}

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/flush.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/mkdir.js", {"./utils/add-link":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/add-link.js","./utils/apply-default-options":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/apply-default-options.js","./utils/constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/constants.js","./utils/create-node":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/create-node.js","./utils/to-path-components":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-path-components.js","./utils/update-mfs-root":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/update-mfs-root.js","./utils/update-tree":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/update-tree.js","./utils/with-mfs-root":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/with-mfs-root.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","ipfs-unixfs-exporter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-exporter/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/mkdir.js
      return function (require, module, exports) {
'use strict'

const errCode = require('err-code')
const log = require('debug')('ipfs:mfs:mkdir')
const exporter = require('ipfs-unixfs-exporter')
const createNode = require('./utils/create-node')
const toPathComponents = require('./utils/to-path-components')
const updateMfsRoot = require('./utils/update-mfs-root')
const updateTree = require('./utils/update-tree')
const addLink = require('./utils/add-link')
const withMfsRoot = require('./utils/with-mfs-root')
const applyDefaultOptions = require('./utils/apply-default-options')
const {
  FILE_SEPARATOR
} = require('./utils/constants')

const defaultOptions = {
  parents: false,
  hashAlg: 'sha2-256',
  cidVersion: 0,
  shardSplitThreshold: 1000,
  format: 'dag-pb',
  flush: true
}

module.exports = (context) => {
  return async function mfsMkdir (path, options) {
    options = applyDefaultOptions(options, defaultOptions)

    if (!path) {
      throw new Error('no path given to Mkdir')
    }

    path = path.trim()

    if (path === FILE_SEPARATOR) {
      if (options.parents) {
        return
      }

      throw errCode(new Error(`cannot create directory '${FILE_SEPARATOR}': Already exists`), 'ERR_INVALID_PATH')
    }

    if (path.substring(0, 1) !== FILE_SEPARATOR) {
      throw errCode(new Error('paths must start with a leading /'), 'ERR_INVALID_PATH')
    }

    log(`Creating ${path}`)

    const pathComponents = toPathComponents(path)

    if (pathComponents[0] === 'ipfs') {
      throw errCode(new Error("path cannot have the prefix 'ipfs'"), 'ERR_INVALID_PATH')
    }

    let root = await withMfsRoot(context)
    let parent
    let trail = []
    const emptyDir = await createNode(context, 'directory', options)

    // make sure the containing folder exists, creating it if necessary
    for (let i = 0; i <= pathComponents.length; i++) {
      const subPathComponents = pathComponents.slice(0, i)
      const subPath = `/ipfs/${root}/${subPathComponents.join('/')}`

      try {
        parent = await exporter(subPath, context.ipld)
        log(`${subPath} existed`)
        log(`${subPath} had children ${parent.node.Links.map(link => link.Name)}`)

        if (i === pathComponents.length) {
          if (options.parents) {
            return
          }

          throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS')
        }

        trail.push({
          name: parent.name,
          cid: parent.cid
        })
      } catch (err) {
        if (err.code === 'ERR_NOT_FOUND') {
          if (i < pathComponents.length && !options.parents) {
            throw errCode(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND')
          }

          // add the intermediate directory
          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, options)
        } else {
          throw err
        }
      }
    }

    // add an empty dir to the last path component
    // await addEmptyDir(context, pathComponents[pathComponents.length - 1], emptyDir, parent, trail)

    // update the tree from the leaf to the root
    const newRootCid = await updateTree(context, trail, options)

    // Update the MFS record with the new CID for the root of the tree
    await updateMfsRoot(context, newRootCid)
  }
}

const addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {
  log(`Adding empty dir called ${childName} to ${parent.cid}`)

  const result = await addLink(context, {
    parent: parent.node,
    parentCid: parent.cid,
    size: emptyDir.node.size,
    cid: emptyDir.cid,
    name: childName,
    format: options.format,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion
  })

  trail[trail.length - 1].cid = result.cid

  trail.push({
    name: childName,
    cid: emptyDir.cid
  })
}

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/mkdir.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/rm.js", {"./utils/apply-default-options":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/apply-default-options.js","./utils/constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/constants.js","./utils/remove-link":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/remove-link.js","./utils/to-mfs-path":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-mfs-path.js","./utils/to-sources":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-sources.js","./utils/to-trail":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-trail.js","./utils/update-mfs-root":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/update-mfs-root.js","./utils/update-tree":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/update-tree.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/rm.js
      return function (require, module, exports) {
'use strict'

const errCode = require('err-code')
const updateTree = require('./utils/update-tree')
const updateMfsRoot = require('./utils/update-mfs-root')
const toSources = require('./utils/to-sources')
const removeLink = require('./utils/remove-link')
const toMfsPath = require('./utils/to-mfs-path')
const toTrail = require('./utils/to-trail')
const applyDefaultOptions = require('./utils/apply-default-options')
const {
  FILE_SEPARATOR
} = require('./utils/constants')

const defaultOptions = {
  recursive: false,
  cidVersion: 0,
  hashAlg: 'sha2-256',
  format: 'dag-pb',
  flush: true
}

module.exports = (context) => {
  return async function mfsRm () {
    const args = Array.from(arguments)

    const {
      sources
    } = await toSources(context, args, defaultOptions)
    const options = applyDefaultOptions(args, defaultOptions)

    if (!sources.length) {
      throw errCode(new Error('Please supply at least one path to remove'), 'ERR_INVALID_PARAMS')
    }

    sources.forEach(source => {
      if (source.path === FILE_SEPARATOR) {
        throw errCode(new Error('Cannot delete root'), 'ERR_INVALID_PARAMS')
      }
    })

    for (const source of sources) {
      await removePath(context, source.path, options)
    }
  }
}

const removePath = async (context, path, options) => {
  const mfsPath = await toMfsPath(context, path)
  const trail = await toTrail(context, mfsPath.mfsPath, options)
  const child = trail.pop()
  const parent = trail[trail.length - 1]

  if (!parent) {
    throw errCode(new Error(`${path} does not exist`), 'ERR_NOT_FOUND')
  }

  if (child.type === 'directory' && !options.recursive) {
    throw errCode(new Error(`${path} is a directory, use -r to remove directories`), 'ERR_WAS_DIR')
  }

  const {
    cid
  } = await removeLink(context, {
    parentCid: parent.cid,
    name: child.name,
    format: options.format,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    flush: options.flush
  })

  parent.cid = cid

  // update the tree with the new child
  const newRootCid = await updateTree(context, trail, options)

  // Update the MFS record with the new CID for the root of the tree
  await updateMfsRoot(context, newRootCid)
}

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/rm.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/write.js", {"./mkdir":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/mkdir.js","./stat":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/stat.js","./utils/add-link":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/add-link.js","./utils/apply-default-options":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/apply-default-options.js","./utils/constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/constants.js","./utils/create-lock":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/create-lock.js","./utils/to-async-iterator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-async-iterator.js","./utils/to-mfs-path":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-mfs-path.js","./utils/to-path-components":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-path-components.js","./utils/to-trail":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-trail.js","./utils/update-mfs-root":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/update-mfs-root.js","./utils/update-tree":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/update-tree.js","async-iterator-last":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-last/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","ipfs-unixfs-importer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs-importer/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/write.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const log = require('debug')('ipfs:mfs:write')
const importer = require('ipfs-unixfs-importer')
const stat = require('./stat')
const mkdir = require('./mkdir')
const addLink = require('./utils/add-link')
const applyDefaultOptions = require('./utils/apply-default-options')
const createLock = require('./utils/create-lock')
const toAsyncIterator = require('./utils/to-async-iterator')
const toMfsPath = require('./utils/to-mfs-path')
const toPathComponents = require('./utils/to-path-components')
const toTrail = require('./utils/to-trail')
const updateTree = require('./utils/update-tree')
const updateMfsRoot = require('./utils/update-mfs-root')
const errCode = require('err-code')
const {
  MAX_CHUNK_SIZE
} = require('./utils/constants')
const last = require('async-iterator-last')

const defaultOptions = {
  offset: 0, // the offset in the file to begin writing
  length: undefined, // how many bytes from the incoming buffer to write
  create: false, // whether to create the file if it does not exist
  truncate: false, // whether to truncate the file first
  rawLeaves: false,
  reduceSingleLeafToSelf: false,
  cidVersion: 0,
  hashAlg: 'sha2-256',
  format: 'dag-pb',
  parents: false, // whether to create intermediate directories if they do not exist
  progress: () => {},
  strategy: 'trickle',
  flush: true,
  leafType: 'raw',
  shardSplitThreshold: 1000
}

module.exports = (context) => {
  return async function mfsWrite (path, content, options) {
    log('Hello world, writing', path, content, options)
    options = applyDefaultOptions(options, defaultOptions)

    let source, destination, parent
    log('Reading source, destination and parent')
    await createLock().readLock(async () => {
      source = await toAsyncIterator(content, options)
      destination = await toMfsPath(context, path)
      parent = await toMfsPath(context, destination.mfsDirectory)
    })()
    log('Read source, destination and parent')
    if (!options.parents && !parent.exists) {
      throw errCode(new Error('directory does not exist'), 'ERR_NO_EXIST')
    }

    if (!options.create && !destination.exists) {
      throw errCode(new Error('file does not exist'), 'ERR_NO_EXIST')
    }

    return updateOrImport(context, path, source, destination, options)
  }
}

const updateOrImport = async (context, path, source, destination, options) => {
  const child = await write(context, source, destination, options)

  // The slow bit is done, now add or replace the DAGLink in the containing directory
  // re-reading the path to the containing folder in case it has changed in the interim
  await createLock().writeLock(async () => {
    const pathComponents = toPathComponents(path)
    const fileName = pathComponents.pop()
    let parentExists = false

    try {
      await stat(context)(`/${pathComponents.join('/')}`, options)
      parentExists = true
    } catch (err) {
      if (err.code !== 'ERR_NOT_FOUND') {
        throw err
      }
    }

    if (!parentExists) {
      await mkdir(context)(`/${pathComponents.join('/')}`, options)
    }

    // get an updated mfs path in case the root changed while we were writing
    const updatedPath = await toMfsPath(context, path)
    const trail = await toTrail(context, updatedPath.mfsDirectory, options)
    const parent = trail[trail.length - 1]

    if (!parent.type.includes('directory')) {
      throw errCode(new Error(`cannot write to ${parent.name}: Not a directory`), 'ERR_NOT_A_DIRECTORY')
    }

    const parentNode = await context.ipld.get(parent.cid)

    const result = await addLink(context, {
      parent: parentNode,
      name: fileName,
      cid: child.cid,
      size: child.size,
      flush: options.flush,
      shardSplitThreshold: options.shardSplitThreshold,
      format: options.format,
      hashAlg: options.hashAlg,
      cidVersion: options.cidVersion
    })

    parent.cid = result.cid

    // update the tree with the new child
    const newRootCid = await updateTree(context, trail, options)

    // Update the MFS record with the new CID for the root of the tree
    await updateMfsRoot(context, newRootCid)
  })()
}

const write = async (context, source, destination, options) => {
  if (destination.exists) {
    log(`Overwriting file ${destination.cid} offset ${options.offset} length ${options.length}`)
  } else {
    log(`Writing file offset ${options.offset} length ${options.length}`)
  }

  const sources = []

  // pad start of file if necessary
  if (options.offset > 0) {
    if (destination.unixfs && destination.unixfs.fileSize() > options.offset) {
      log(`Writing first ${options.offset} bytes of original file`)

      sources.push(
        () => {
          return destination.content({
            offset: 0,
            length: options.offset
          })
        }
      )
    } else {
      log(`Writing zeros for first ${options.offset} bytes`)
      sources.push(
        asyncZeroes(options.offset)
      )
    }
  }

  sources.push(
    limitAsyncStreamBytes(source, options.length)
  )

  const content = countBytesStreamed(catAsyncInterators(sources), (bytesWritten) => {
    if (destination.unixfs && !options.truncate) {
      // if we've done reading from the new source and we are not going
      // to truncate the file, add the end of the existing file to the output
      const fileSize = destination.unixfs.fileSize()

      if (fileSize > bytesWritten) {
        log(`Writing last ${fileSize - bytesWritten} of ${fileSize} bytes from original file starting at offset ${bytesWritten}`)

        return destination.content({
          offset: bytesWritten
        })
      } else {
        log(`Not writing last bytes from original file`)
      }
    }

    return {
      [Symbol.asyncIterator]: async function * () {}
    }
  })

  let result = await last(importer([{
    content: content
  }], context.ipld, {
    progress: options.progress,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    strategy: options.strategy,
    rawLeaves: options.rawLeaves,
    reduceSingleLeafToSelf: options.reduceSingleLeafToSelf,
    leafType: options.leafType
  }))

  log(`Wrote ${result.cid}`)

  return {
    cid: result.cid,
    size: result.size
  }
}

const limitAsyncStreamBytes = (stream, limit) => {
  return async function * _limitAsyncStreamBytes () {
    let emitted = 0

    for await (const buf of stream) {
      emitted += buf.length

      if (emitted > limit) {
        yield buf.slice(0, limit - emitted)

        return
      }

      yield buf
    }
  }
}

const asyncZeroes = (count, chunkSize = MAX_CHUNK_SIZE) => {
  const buf = Buffer.alloc(chunkSize, 0)

  const stream = {
    [Symbol.asyncIterator]: async function * _asyncZeroes () {
      while (true) {
        yield buf.slice()
      }
    }
  }

  return limitAsyncStreamBytes(stream, count)
}

const catAsyncInterators = async function * (sources) {
  for (let i = 0; i < sources.length; i++) {
    for await (const buf of sources[i]()) {
      yield buf
    }
  }
}

const countBytesStreamed = async function * (source, notify) {
  let wrote = 0

  for await (const buf of source) {
    wrote += buf.length

    yield buf
  }

  for await (const buf of notify(wrote)) {
    wrote += buf.length

    yield buf
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/write.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/cp.js", {"./mkdir":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/mkdir.js","./utils/add-link":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/add-link.js","./utils/apply-default-options":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/apply-default-options.js","./utils/to-mfs-path":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-mfs-path.js","./utils/to-sources-and-destination":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-sources-and-destination.js","./utils/to-trail":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/to-trail.js","./utils/update-mfs-root":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/update-mfs-root.js","./utils/update-tree":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/update-tree.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/cp.js
      return function (require, module, exports) {
'use strict'

const mkdir = require('./mkdir')
const log = require('debug')('ipfs:mfs:cp')
const errCode = require('err-code')
const updateTree = require('./utils/update-tree')
const updateMfsRoot = require('./utils/update-mfs-root')
const addLink = require('./utils/add-link')
const applyDefaultOptions = require('./utils/apply-default-options')
const toMfsPath = require('./utils/to-mfs-path')
const toSourcesAndDestination = require('./utils/to-sources-and-destination')
const toTrail = require('./utils/to-trail')

const defaultOptions = {
  parents: false,
  flush: true,
  format: 'dag-pb',
  hashAlg: 'sha2-256',
  cidVersion: 0,
  shardSplitThreshold: 1000
}

module.exports = (context) => {
  return async function mfsCp (...args) {
    const options = applyDefaultOptions(args, defaultOptions)
    let {
      sources, destination
    } = await toSourcesAndDestination(context, args)

    if (!sources.length) {
      throw errCode(new Error('Please supply at least one source'), 'ERR_INVALID_PARAMS')
    }

    if (!destination) {
      throw errCode(new Error('Please supply a destination'), 'ERR_INVALID_PARAMS')
    }

    options.parents = options.p || options.parents

    // make sure all sources exist
    const missing = sources.find(source => !source.exists)

    if (missing) {
      throw errCode(new Error(`${missing.path} does not exist`), 'ERR_INVALID_PARAMS')
    }

    const destinationIsDirectory = isDirectory(destination)

    if (destination.exists) {
      log('Destination exists')

      if (sources.length === 1 && !destinationIsDirectory) {
        throw errCode(new Error('directory already has entry by that name'), 'ERR_ALREADY_EXISTS')
      }
    } else {
      log('Destination does not exist')

      if (sources.length > 1) {
        if (!options.parents) {
          throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS')
        }

        await mkdir(context)(destination.path, options)
        destination = await toMfsPath(context, destination.path)
      }
    }

    const destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory
    const trail = await toTrail(context, destinationPath, options)

    if (sources.length === 1) {
      const source = sources.pop()
      const destinationName = destinationIsDirectory ? source.name : destination.name

      log(`Only one source, copying to destination ${destinationIsDirectory ? 'directory' : 'file'} ${destinationName}`)

      return copyToFile(context, source, destinationName, trail, options)
    }

    log('Multiple sources, wrapping in a directory')
    return copyToDirectory(context, sources, destination, trail, options)
  }
}

const isDirectory = (destination) => {
  return destination.unixfs &&
    destination.unixfs.type &&
    destination.unixfs.type.includes('directory')
}

const copyToFile = async (context, source, destination, destinationTrail, options) => {
  let parent = destinationTrail.pop()

  parent = await addSourceToParent(context, source, destination, parent, options)

  // update the tree with the new containg directory
  destinationTrail.push(parent)

  const newRootCid = await updateTree(context, destinationTrail, options)

  // Update the MFS record with the new CID for the root of the tree
  await updateMfsRoot(context, newRootCid)
}

const copyToDirectory = async (context, sources, destination, destinationTrail, options) => {
  // copy all the sources to the destination
  for (let i = 0; i < sources.length; i++) {
    const source = sources[i]

    destination = await addSourceToParent(context, source, source.name, destination, options)
  }

  // update the tree with the new containg directory
  destinationTrail[destinationTrail.length - 1] = destination

  const newRootCid = await updateTree(context, destinationTrail, options)

  // Update the MFS record with the new CID for the root of the tree
  await updateMfsRoot(context, newRootCid)
}

const addSourceToParent = async (context, source, childName, parent, options) => {
  const sourceBlock = await context.repo.blocks.get(source.cid)

  const {
    node,
    cid
  } = await addLink(context, {
    parentCid: parent.cid,
    size: sourceBlock.data.length,
    cid: source.cid,
    name: childName,
    format: options.format,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion
  })

  parent.node = node
  parent.cid = cid
  parent.size = node.size

  return parent
}

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/cp.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/create-lock.js", {"mortice":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/mortice/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/create-lock.js
      return function (require, module, exports) {
'use strict'

const mortice = require('mortice')

let lock

module.exports = (repoOwner) => {
  if (lock) {
    return lock
  }

  const mutex = mortice({
    // ordinarily the main thread would store the read/write lock but
    // if we are the thread that owns the repo, we can store the lock
    // on this process even if we are a worker thread
    singleProcess: repoOwner
  })

  lock = {
    readLock: (func) => {
      return (...args) => {
        return mutex.readLock(() => {
          return func.apply(null, args)
        })
      }
    },

    writeLock: (func) => {
      return (...args) => {
        return mutex.writeLock(() => {
          return func.apply(null, args)
        })
      }
    }
  }

  return lock
}

      };
    };
  }
}, {package:"ipfs-mfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/src/core/utils/create-lock.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js", {"../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/utils.js","./inlineSnaps":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/snaps/inlineSnaps.js","@metamask/controllers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/index.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","nanoid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/nanoid/index.browser.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnapController = exports.SnapStatusEvent = exports.SnapStatus = exports.SNAP_PREFIX_REGEX = exports.SNAP_PREFIX = exports.controllerName = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const controllers_1 = require("@metamask/controllers");
const nanoid_1 = require("nanoid");
const utils_1 = require("../utils");
const inlineSnaps_1 = require("./inlineSnaps");
exports.controllerName = 'SnapController';
exports.SNAP_PREFIX = 'wallet_snap_';
exports.SNAP_PREFIX_REGEX = new RegExp(`^${exports.SNAP_PREFIX}`, 'u');
const SERIALIZABLE_SNAP_PROPERTIES = new Set([
    'initialPermissions',
    'name',
    'permissionName',
]);
const defaultState = {
    snapErrors: {},
    inlineSnapIsRunning: false,
    snaps: {},
    snapStates: {},
};
var SnapStatus;
(function (SnapStatus) {
    SnapStatus["installing"] = "installing";
    SnapStatus["running"] = "running";
    SnapStatus["stopped"] = "stopped";
    SnapStatus["crashed"] = "crashed";
})(SnapStatus = exports.SnapStatus || (exports.SnapStatus = {}));
var SnapStatusEvent;
(function (SnapStatusEvent) {
    SnapStatusEvent["start"] = "start";
    SnapStatusEvent["stop"] = "stop";
    SnapStatusEvent["crash"] = "crash";
})(SnapStatusEvent = exports.SnapStatusEvent || (exports.SnapStatusEvent = {}));
/**
 * Guard transitioning when the snap is disabled.
 */
const disabledGuard = (serializedSnap) => {
    return serializedSnap.enabled;
};
/**
 * The state machine configuration for a snaps `status` state.
 * Using a state machine for a snaps `status` ensures that the snap transitions to a valid next lifecycle state.
 * Supports a very minimal subset of XState conventions outlined in `_transitionSnapState`.
 */
const snapStatusStateMachineConfig = {
    initial: SnapStatus.installing,
    states: {
        [SnapStatus.installing]: {
            on: {
                [SnapStatusEvent.start]: {
                    target: SnapStatus.running,
                    cond: disabledGuard,
                },
            },
        },
        [SnapStatus.running]: {
            on: {
                [SnapStatusEvent.stop]: SnapStatus.stopped,
                [SnapStatusEvent.crash]: SnapStatus.crashed,
            },
        },
        [SnapStatus.stopped]: {
            on: {
                [SnapStatusEvent.start]: {
                    target: SnapStatus.running,
                    cond: disabledGuard,
                },
            },
        },
        [SnapStatus.crashed]: {
            on: {
                [SnapStatusEvent.start]: {
                    target: SnapStatus.running,
                    cond: disabledGuard,
                },
            },
        },
    },
};
const name = 'SnapController';
/*
 * A snap is initialized in three phases:
 * - Add: Loads the snap from a remote source and parses it.
 * - Authorize: Requests the snap's required permissions from the user.
 * - Start: Initializes the snap in its SES realm with the authorized permissions.
 */
class SnapController extends controllers_1.BaseControllerV2 {
    constructor({ removeAllPermissionsFor, closeAllConnections, requestPermissions, getPermissions, terminateSnap, terminateAllSnaps, hasPermission, executeSnap, getRpcMessageHandler, messenger, state, maxIdleTime = 30000, idleTimeCheckInterval = 5000, maxRequestTime = 60000, }) {
        super({
            messenger,
            metadata: {
                snapErrors: {
                    persist: false,
                    anonymous: false,
                },
                inlineSnapIsRunning: {
                    persist: false,
                    anonymous: false,
                },
                snapStates: {
                    persist: true,
                    anonymous: false,
                },
                snaps: {
                    persist: (snaps) => {
                        return Object.values(snaps)
                            .map((snap) => {
                            return Object.assign(Object.assign({}, snap), { 
                                // At the time state is rehydrated, no snap will be running.
                                status: SnapStatus.stopped });
                        })
                            .reduce((memo, snap) => {
                            memo[snap.name] = snap;
                            return memo;
                        }, {});
                    },
                    anonymous: false,
                },
            },
            name,
            state: Object.assign(Object.assign({}, defaultState), state),
        });
        this._removeAllPermissionsFor = removeAllPermissionsFor;
        this._closeAllConnections = closeAllConnections;
        this._requestPermissions = requestPermissions;
        this._getPermissions = getPermissions;
        this._hasPermission = hasPermission;
        this._terminateSnap = terminateSnap;
        this._terminateAllSnaps = terminateAllSnaps;
        this._executeSnap = executeSnap;
        this._getRpcMessageHandler = getRpcMessageHandler;
        this._onUnhandledSnapError = this._onUnhandledSnapError.bind(this);
        this._onUnresponsiveSnap = this._onUnresponsiveSnap.bind(this);
        this.messagingSystem.subscribe('ServiceMessenger:unhandledError', this._onUnhandledSnapError);
        this.messagingSystem.subscribe('ServiceMessenger:unresponsive', this._onUnresponsiveSnap);
        this._snapsBeingAdded = new Map();
        this._maxIdleTime = maxIdleTime;
        this._maxRequestTime = maxRequestTime;
        this._idleTimeCheckInterval = idleTimeCheckInterval;
        this._pollForLastRequestStatus();
        this._lastRequestMap = new Map();
        this._rpcHandlerMap = new Map();
    }
    _pollForLastRequestStatus() {
        this._timeoutForLastRequestStatus = setTimeout(async () => {
            this._stopSnapsLastRequestPastMax();
            this._pollForLastRequestStatus();
        }, this._idleTimeCheckInterval);
    }
    _stopSnapsLastRequestPastMax() {
        this._lastRequestMap.forEach(async (timestamp, snapName) => {
            if (this._maxIdleTime && utils_1.timeSince(timestamp) > this._maxIdleTime) {
                this.stopSnap(snapName);
            }
        });
    }
    _onUnresponsiveSnap(snapName) {
        this._transitionSnapState(snapName, SnapStatusEvent.crash);
        this._stopSnap(snapName, false);
        this.addSnapError({
            code: -32001,
            message: 'Snap Unresponsive',
            data: {
                snapName,
            },
        });
    }
    _onUnhandledSnapError(snapName, error) {
        this._transitionSnapState(snapName, SnapStatusEvent.crash);
        this._stopSnap(snapName, false);
        this.addSnapError(error);
    }
    /**
     * Transitions between states using `snapStatusStateMachineConfig` as the template to figure out the next state.
     * This transition function uses a very minimal subset of XState conventions:
     * - supports initial state
     * - .on supports raw event target string
     * - .on supports {target, cond} object
     * - the arguments for `cond` is the `SerializedSnap` instead of Xstate convention of `(event, context) => boolean`
     * @param snapName the name of the snap to transition
     * @param event the event enum to use to transition
     */
    _transitionSnapState(snapName, event) {
        var _a;
        const snapStatus = this.state.snaps[snapName].status;
        let nextStatus = (_a = snapStatusStateMachineConfig.states[snapStatus].on[event]) !== null && _a !== void 0 ? _a : snapStatus;
        if (nextStatus.cond) {
            const cond = nextStatus.cond(this.state.snaps[snapName]);
            if (cond === false) {
                throw new Error(`Condition failed for state transition "${snapName}" with event "${event}".`);
            }
        }
        if (nextStatus.target) {
            nextStatus = nextStatus.target;
        }
        if (nextStatus === snapStatus) {
            return;
        }
        this.update((state) => {
            state.snaps[snapName].status = nextStatus;
        });
    }
    /**
     * Runs existing (installed) snaps.
     * Deletes any snaps that cannot be started.
     */
    async runExistingSnaps() {
        const { snaps } = this.state;
        if (Object.keys(snaps).length > 0) {
            console.log('Starting existing snaps...', snaps);
        }
        else {
            console.log('No existing snaps to run.');
            return;
        }
        await Promise.all(Object.values(snaps).map(async ({ name: snapName, sourceCode }) => {
            console.log(`Starting: ${snapName}`);
            try {
                await this._startSnap({
                    snapName,
                    sourceCode,
                });
            }
            catch (err) {
                console.warn(`Failed to start "${snapName}", deleting it.`, err);
                // Clean up failed snaps:
                this.removeSnap(snapName);
            }
        }));
    }
    /**
     * Starts the given snap. Throws an error if no such snap exists
     * or if it is already running.
     *
     * @param snapName - The name of the snap to start.
     */
    async startSnap(snapName) {
        const snap = this.get(snapName);
        if (!snap) {
            throw new Error(`Snap "${snapName}" not found.`);
        }
        if (this.state.snaps[snapName].enabled === false) {
            throw new Error(`Snap "${snapName}" is disabled.`);
        }
        await this._startSnap({
            snapName,
            sourceCode: snap.sourceCode,
        });
    }
    /**
     * Enables the given snap. A snap can only be started if it is enabled.
     *
     * @param snapName - The name of the snap to enable.
     */
    enableSnap(snapName) {
        this.update((state) => {
            state.snaps[snapName].enabled = true;
        });
    }
    /**
     * Disables the given snap. A snap can only be started if it is enabled.
     *
     * @param snapName - The name of the snap to disable.
     */
    disableSnap(snapName) {
        this.stopSnap(snapName);
        this.update((state) => {
            state.snaps[snapName].enabled = false;
        });
    }
    /**
     * Stops the given snap. Throws an error if no such snap exists
     * or if it is already stopped.
     *
     * @param snapName - The name of the snap to stop.
     */
    stopSnap(snapName) {
        const snap = this.get(snapName);
        if (!snap) {
            throw new Error(`Snap "${snapName}" not found.`);
        }
        if (!this.isRunning(snapName)) {
            throw new Error(`Snap "${snapName}" already stopped.`);
        }
        this._stopSnap(snapName);
        console.log(`Snap "${snapName}" stopped.`);
    }
    /**
     * Stops the given snap, removes all hooks, closes all connections, and
     * terminates its worker.
     *
     * @param snapName - The name of the snap to stop.
     * @param setNotRunning - Whether to mark the snap as not running.
     * Should only be set to false if the snap is about to be deleted.
     */
    _stopSnap(snapName, setNotRunning = true) {
        this._lastRequestMap.delete(snapName);
        this._closeAllConnections(snapName);
        this._terminateSnap(snapName);
        if (setNotRunning) {
            this._transitionSnapState(snapName, SnapStatusEvent.stop);
        }
    }
    /**
     * Returns whether the given snap is running.
     * Throws an error if the snap doesn't exist.
     *
     * @param snapName - The name of the snap to check.
     */
    isRunning(snapName) {
        const snap = this.get(snapName);
        if (!snap) {
            throw new Error(`Snap "${snapName}" not found.`);
        }
        return snap.status === SnapStatus.running;
    }
    /**
     * Returns whether the given snap has been added to state.
     *
     * @param snapName - The name of the snap to check for.
     */
    has(snapName) {
        return snapName in this.state.snaps;
    }
    /**
     * Gets the snap with the given name if it exists, including all data.
     * This should not be used if the snap is to be serializable, as e.g.
     * the snap sourceCode may be quite large.
     *
     * @param snapName - The name of the snap to get.
     */
    get(snapName) {
        return this.state.snaps[snapName];
    }
    /**
     * Gets the snap with the given name if it exists, excluding any
     * non-serializable or expensive-to-serialize data.
     *
     * @param snapName - The name of the snap to get.
     */
    getSerializable(snapName) {
        const snap = this.get(snapName);
        return snap
            ? // The cast to "any" of the accumulator object is due to a TypeScript bug
                Object.keys(snap).reduce((serialized, key) => {
                    if (SERIALIZABLE_SNAP_PROPERTIES.has(key)) {
                        serialized[key] = snap[key];
                    }
                    return serialized;
                }, {})
            : null;
    }
    /**
     * Updates the own state of the snap with the given name.
     * This is distinct from the state MetaMask uses to manage snaps.
     *
     * @param snapName - The name of the snap whose state should be updated.
     * @param newSnapState - The new state of the snap.
     */
    async updateSnapState(snapName, newSnapState) {
        this.update((state) => {
            state.snapStates[snapName] = newSnapState;
        });
    }
    /**
     * Adds error from a snap to the SnapControllers state.
     *
     * @param snapError - The error to store on the SnapController
     */
    async addSnapError(snapError) {
        this.update((state) => {
            const id = nanoid_1.nanoid();
            state.snapErrors[id] = Object.assign(Object.assign({}, snapError), { internalID: id });
        });
    }
    /**
     * Removes an error by internalID from a the SnapControllers state.
     *
     * @param internalID - The internal error ID to remove on the SnapController
     */
    async removeSnapError(internalID) {
        this.update((state) => {
            delete state.snapErrors[internalID];
        });
    }
    /**
     * Clears all errors from the SnapControllers state.
     *
     */
    async clearSnapErrors() {
        this.update((state) => {
            state.snapErrors = {};
        });
    }
    /**
     * Gets the own state of the snap with the given name.
     * This is distinct from the state MetaMask uses to manage snaps.
     *
     * @param snapName - The name of the snap whose state to get.
     */
    async getSnapState(snapName) {
        return this.state.snapStates[snapName];
    }
    /**
     * Completely clear the controller's state: delete all associated data,
     * handlers, event listeners, and permissions; tear down all snap providers.
     */
    clearState() {
        const snapNames = Object.keys(this.state.snaps);
        snapNames.forEach((snapName) => {
            this._closeAllConnections(snapName);
        });
        this._terminateAllSnaps();
        this._removeAllPermissionsFor(snapNames);
        this.update((state) => {
            state.inlineSnapIsRunning = false;
            state.snaps = {};
            state.snapStates = {};
        });
    }
    /**
     * Removes the given snap from state, and clears all associated handlers
     * and listeners.
     *
     * @param snapName - The name of the snap.
     */
    removeSnap(snapName) {
        this.removeSnaps([snapName]);
    }
    /**
     * Stops the given snaps, removes them from state, and clears all associated
     * permissions, handlers, and listeners.
     *
     * @param {Array<string>} snapName - The name of the snaps.
     */
    removeSnaps(snapNames) {
        if (!Array.isArray(snapNames)) {
            throw new Error('Expected array of snap names.');
        }
        this.update((state) => {
            snapNames.forEach((snapName) => {
                this._stopSnap(snapName, false);
                this._rpcHandlerMap.delete(snapName);
                delete state.snaps[snapName];
                delete state.snapStates[snapName];
            });
        });
        this._removeAllPermissionsFor(snapNames);
    }
    /**
     * Gets the serialized permitted snaps of the given origin, if any.
     * @param origin - The origin whose permitted snaps to retrieve.
     */
    getPermittedSnaps(origin) {
        return this._getPermissions(origin).reduce((permittedSnaps, perm) => {
            if (perm.parentCapability.startsWith(exports.SNAP_PREFIX)) {
                const snapName = perm.parentCapability.replace(exports.SNAP_PREFIX_REGEX, '');
                const snap = this.getSerializable(snapName);
                permittedSnaps[snapName] = snap || {
                    error: eth_rpc_errors_1.serializeError(new Error('Snap permitted but not installed.')),
                };
            }
            return permittedSnaps;
        }, {});
    }
    /**
     * Installs the snaps requested by the given origin, returning the snap
     * object if the origin is permitted to install it, and an authorization error
     * otherwise.
     *
     * @param origin - The origin that requested to install the snaps.
     * @param requestedSnaps - The snaps to install.
     * @returns An object of snap names and snap objects, or errors if a
     * snap couldn't be installed.
     */
    async installSnaps(origin, requestedSnaps) {
        const result = {};
        // use a for-loop so that we can return an object and await the resolution
        // of each call to processRequestedSnap
        await Promise.all(Object.keys(requestedSnaps).map(async (snapName) => {
            const permissionName = exports.SNAP_PREFIX + snapName;
            if (this._hasPermission(origin, permissionName)) {
                // attempt to install and run the snap, storing any errors that
                // occur during the process
                result[snapName] = Object.assign({}, (await this.processRequestedSnap(snapName)));
            }
            else {
                // only allow the installation of permitted snaps
                result[snapName] = {
                    error: eth_rpc_errors_1.ethErrors.provider.unauthorized(`Not authorized to install snap '${snapName}'. Request the permission for the snap before attempting to install it.`),
                };
            }
        }));
        return result;
    }
    /**
     * Adds, authorizes, and runs the given snap with a snap provider.
     * Results from this method should be efficiently serializable.
     *
     * @param - snapName - The name of the snap.
     * @returns The resulting snap object, or an error if something went wrong.
     */
    async processRequestedSnap(snapName) {
        // If the snap is already installed, just return it
        const snap = this.get(snapName);
        if (snap) {
            return this.getSerializable(snapName);
        }
        try {
            const { sourceCode } = await this.add({
                name: snapName,
                manifestUrl: snapName,
            });
            await this.authorize(snapName);
            await this._startSnap({
                snapName,
                sourceCode,
            });
            return this.getSerializable(snapName);
        }
        catch (err) {
            console.error(`Error when adding snap.`, err);
            return { error: eth_rpc_errors_1.serializeError(err) };
        }
    }
    /**
     * Returns a promise representing the complete installation of the requested snap.
     * If the snap is already being installed, the previously pending promise will be returned.
     *
     * @param snapName - The name of the snap.
     * @param args - Object containing either the URL of the snap's manifest,
     * or the snap's manifest and source code.
     * @returns The resulting snap object.
     */
    add(args) {
        const { name: snapName } = args;
        if (!snapName || typeof snapName !== 'string') {
            throw new Error(`Invalid snap name: ${snapName}`);
        }
        if (!args ||
            (!('manifestUrl' in args) &&
                (!('manifest' in args) || !('sourceCode' in args)))) {
            throw new Error(`Invalid add snap args for snap "${snapName}".`);
        }
        if (!this._snapsBeingAdded.has(snapName)) {
            console.log(`Adding snap: ${snapName}`);
            this._snapsBeingAdded.set(snapName, this._add(args));
        }
        return this._snapsBeingAdded.get(snapName);
    }
    async _startSnap(snapData) {
        const { snapName } = snapData;
        if (this.isRunning(snapName)) {
            throw new Error(`Snap "${snapName}" is already started.`);
        }
        const result = await this._executeSnap(snapData);
        this._transitionSnapState(snapName, SnapStatusEvent.start);
        return result;
    }
    /**
     * Internal method. See the "add" method.
     *
     * @param snapName - The name of the snap.
     * @param args - The add snap args.
     * @returns The resulting snap object.
     */
    async _add(args) {
        var _a;
        const { name: snapName } = args;
        let manifest, sourceCode;
        if ('manifestUrl' in args) {
            const _sourceUrl = args.manifestUrl || snapName;
            [manifest, sourceCode] = await this._fetchSnap(snapName, _sourceUrl);
        }
        else {
            manifest = args.manifest;
            sourceCode = args.sourceCode;
        }
        if (typeof sourceCode !== 'string' || sourceCode.length === 0) {
            throw new Error(`Invalid source code for snap "${snapName}".`);
        }
        const initialPermissions = (_a = manifest === null || manifest === void 0 ? void 0 : manifest.web3Wallet) === null || _a === void 0 ? void 0 : _a.initialPermissions;
        if (!initialPermissions ||
            typeof initialPermissions !== 'object' ||
            Array.isArray(initialPermissions)) {
            throw new Error(`Invalid initial permissions for snap "${snapName}".`);
        }
        let snap = {
            initialPermissions,
            name: snapName,
            permissionName: exports.SNAP_PREFIX + snapName,
            sourceCode,
            version: manifest.version,
            enabled: true,
            status: snapStatusStateMachineConfig.initial,
        };
        const snapsState = this.state.snaps;
        // restore relevant snap state if it exists
        if (snapsState[snapName]) {
            snap = Object.assign(Object.assign({}, snapsState[snapName]), snap);
        }
        // store the snap back in state
        this.update((state) => {
            state.snaps[snapName] = snap;
        });
        return snap;
    }
    /**
     * Fetches the manifest and source code of a snap.
     *
     * @param name - The name of the snap.
     * @param manifestUrl - The URL of the snap's manifest file.
     * @returns An array of the snap manifest object and the snap source code.
     */
    async _fetchSnap(snapName, manifestUrl) {
        try {
            console.log(`Fetching snap manifest from: ${manifestUrl}`);
            const snapSource = await fetch(manifestUrl);
            const manifest = await snapSource.json();
            console.log(`Destructuring snap: `, manifest);
            const { web3Wallet: { bundle }, } = manifest;
            console.log(`Fetching snap source code from: ${bundle.url}`);
            const snapBundle = await fetch(bundle.url);
            const sourceCode = await snapBundle.text();
            return [manifest, sourceCode];
        }
        catch (err) {
            throw new Error(`Problem fetching snap "${snapName}": ${err.message}`);
        }
    }
    /**
     * Initiates a request for the given snap's initial permissions.
     * Must be called in order. See processRequestedSnap.
     *
     * @param snapName - The name of the snap.
     * @returns The snap's approvedPermissions.
     */
    async authorize(snapName) {
        console.log(`Authorizing snap: ${snapName}`);
        const snapsState = this.state.snaps;
        const snap = snapsState[snapName];
        const { initialPermissions } = snap;
        // Don't prompt if there are no permissions requested:
        if (Object.keys(initialPermissions).length === 0) {
            return [];
        }
        if (initialPermissions === null) {
            return [];
        }
        try {
            const approvedPermissions = await this._requestPermissions(snapName, initialPermissions);
            return approvedPermissions.map((perm) => perm.parentCapability);
        }
        finally {
            this._snapsBeingAdded.delete(snapName);
        }
    }
    /**
     * Test method.
     */
    runInlineSnap(inlineSnapName = 'IDLE') {
        this._startSnap({
            snapName: 'inlineSnap',
            sourceCode: inlineSnaps_1.INLINE_SNAPS[inlineSnapName],
        });
        this.update((state) => {
            state.inlineSnapIsRunning = true;
        });
    }
    /**
     * Test method.
     */
    removeInlineSnap() {
        this.update((state) => {
            state.inlineSnapIsRunning = false;
        });
        this.removeSnap('inlineSnap');
    }
    destroy() {
        super.destroy();
        if (this._timeoutForLastRequestStatus) {
            clearTimeout(this._timeoutForLastRequestStatus);
        }
        this.messagingSystem.unsubscribe('ServiceMessenger:unhandledError', this._onUnhandledSnapError);
        this.messagingSystem.unsubscribe('ServiceMessenger:unresponsive', this._onUnresponsiveSnap);
    }
    /**
     * Gets the RPC message handler for the given snap.
     *
     * @param snapName - The name of the snap whose message handler to get.
     */
    async getRpcMessageHandler(snapName) {
        const existingHandler = this._rpcHandlerMap.get(snapName);
        if (existingHandler) {
            return existingHandler;
        }
        const rpcHandler = async (origin, request) => {
            let handler = await this._getRpcMessageHandler(snapName);
            if (this.state.snaps[snapName].enabled === false) {
                throw new Error(`Snap "${snapName}" is disabled.`);
            }
            if (this.state.snaps[snapName].status === SnapStatus.installing) {
                throw new Error(`Snap "${snapName}" has not been started yet.`);
            }
            if (!handler && this.isRunning(snapName) === false) {
                // cold start
                await this.startSnap(snapName);
                handler = await this._getRpcMessageHandler(snapName);
            }
            if (!handler) {
                throw new Error(`Snap execution service returned no RPC handler for running snap "${snapName}".`);
            }
            this._recordSnapRpcRequest(snapName);
            // Handle max request time
            let timeout;
            const timeoutPromise = new Promise((_resolve, reject) => {
                timeout = setTimeout(() => {
                    this._stopSnap(snapName);
                    reject(new Error('The request timed out.'));
                }, this._maxRequestTime);
            });
            // This will either get the result or reject due to the timeout.
            const result = await Promise.race([
                handler(origin, request),
                timeoutPromise,
            ]);
            clearTimeout(timeout);
            return result;
        };
        this._rpcHandlerMap.set(snapName, rpcHandler);
        return rpcHandler;
    }
    _recordSnapRpcRequest(snapName) {
        this._lastRequestMap.set(snapName, Date.now());
    }
}
exports.SnapController = SnapController;
//# sourceMappingURL=SnapController.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/subject-metadata/SubjectMetadataController.js", {"@metamask/controllers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/subject-metadata/SubjectMetadataController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubjectMetadataController = void 0;
const controllers_1 = require("@metamask/controllers");
const controllerName = 'SubjectMetadataController';
const stateMetadata = {
    subjectMetadata: { persist: true, anonymous: false },
};
const defaultState = {
    subjectMetadata: {},
};
/**
 * A controller for storing metadata associated with permission subjects. More
 * or less, a cache.
 */
class SubjectMetadataController extends controllers_1.BaseControllerV2 {
    constructor({ messenger, subjectCacheLimit, state = {}, }) {
        if (!Number.isInteger(subjectCacheLimit) || subjectCacheLimit < 1) {
            throw new Error(`subjectCacheLimit must be a positive integer. Received: "${subjectCacheLimit}"`);
        }
        const hasPermissions = (origin) => {
            return messenger.call('PermissionController:hasPermissions', origin);
        };
        super({
            name: controllerName,
            metadata: stateMetadata,
            messenger,
            state: Object.assign({}, SubjectMetadataController.getTrimmedState(state, hasPermissions)),
        });
        this.subjectHasPermissions = hasPermissions;
        this.subjectCacheLimit = subjectCacheLimit;
        this.subjectsWithoutPermissionsEcounteredSinceStartup = new Set();
    }
    /**
     * Clears the state of this controller. Also resets the cache of subjects
     * encountered since startup, so as to not prematurely reach the cache limit.
     */
    clearState() {
        this.subjectsWithoutPermissionsEcounteredSinceStartup.clear();
        this.update((_draftState) => {
            return Object.assign({}, defaultState);
        });
    }
    /**
     * Stores domain metadata for the given origin (subject). Deletes metadata for
     * subjects without permissions in a FIFO manner once more than
     * {@link SubjectMetadataController.subjectCacheLimit} distinct origins have
     * been added since boot.
     *
     * In order to prevent a degraded user experience,
     * metadata is never deleted for subjects with permissions, since metadata
     * cannot yet be requested on demand.
     *
     * @param metadata - The subject metadata to store.
     */
    addSubjectMetadata(metadata) {
        const { origin } = metadata;
        const newMetadata = Object.assign(Object.assign({}, metadata), { extensionId: metadata.extensionId || null, iconUrl: metadata.iconUrl || null });
        let originToForget = null;
        // We only delete the oldest encountered subject from the cache, again to
        // ensure that the user's experience isn't degraded by missing icons etc.
        if (this.subjectsWithoutPermissionsEcounteredSinceStartup.size >=
            this.subjectCacheLimit) {
            const cachedOrigin = this.subjectsWithoutPermissionsEcounteredSinceStartup
                .values()
                .next().value;
            this.subjectsWithoutPermissionsEcounteredSinceStartup.delete(cachedOrigin);
            if (!this.subjectHasPermissions(cachedOrigin)) {
                originToForget = cachedOrigin;
            }
        }
        this.subjectsWithoutPermissionsEcounteredSinceStartup.add(origin);
        this.update((draftState) => {
            // Typecast: ts(2589)
            draftState.subjectMetadata[origin] = newMetadata;
            if (typeof originToForget === 'string') {
                delete draftState.subjectMetadata[originToForget];
            }
        });
    }
    /**
     * Deletes all subjects without permissions from the controller's state.
     */
    trimMetadataState() {
        this.update((draftState) => {
            return SubjectMetadataController.getTrimmedState(
            // Typecast: ts(2589)
            draftState, this.subjectHasPermissions);
        });
    }
    /**
     * Returns a new state object that only includes subjects with permissions.
     * This method is static because we want to call it in the constructor, before
     * the controller's state is initialized.
     *
     * @param state - The state object to trim.
     * @param hasPermissions - A function that returns a boolean indicating
     * whether a particular subject (identified by its origin) has any
     * permissions.
     * @returns The new state object. If the specified `state` object has no
     * subject metadata, the returned object will be equivalent to the default
     * state of this controller.
     */
    static getTrimmedState(state, hasPermissions) {
        const { subjectMetadata = {} } = state;
        return {
            subjectMetadata: Object.keys(subjectMetadata).reduce((newSubjectMetadata, origin) => {
                if (hasPermissions(origin)) {
                    newSubjectMetadata[origin] = subjectMetadata[origin];
                }
                return newSubjectMetadata;
            }, {}),
        };
    }
}
exports.SubjectMetadataController = SubjectMetadataController;
//# sourceMappingURL=SubjectMetadataController.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/subject-metadata/SubjectMetadataController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/services/ExecutionEnvironmentService.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/services/ExecutionEnvironmentService.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=ExecutionEnvironmentService.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/services/ExecutionEnvironmentService.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/services/WebWorkerExecutionEnvironmentService.js", {"@metamask/object-multiplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/object-multiplex/dist/index.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/index.js","@metamask/post-message-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/index.js","@metamask/snap-workers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-workers/dist/index.js","json-rpc-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js","json-rpc-middleware-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/json-rpc-middleware-stream/dist/index.js","nanoid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/nanoid/index.browser.cjs","pump":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pump/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/services/WebWorkerExecutionEnvironmentService.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebWorkerExecutionEnvironmentService = void 0;
const nanoid_1 = require("nanoid");
const pump_1 = __importDefault(require("pump"));
const obs_store_1 = require("@metamask/obs-store");
const object_multiplex_1 = __importDefault(require("@metamask/object-multiplex"));
const post_message_stream_1 = require("@metamask/post-message-stream");
const snap_workers_1 = require("@metamask/snap-workers");
const json_rpc_middleware_stream_1 = require("json-rpc-middleware-stream");
const json_rpc_engine_1 = require("json-rpc-engine");
class WebWorkerExecutionEnvironmentService {
    constructor({ setupSnapProvider, workerUrl, messenger, unresponsivePollingInterval = 5000, unresponsiveTimeout = 30000, }) {
        this.workerUrl = workerUrl;
        this.setupSnapProvider = setupSnapProvider;
        this.store = new obs_store_1.ObservableStore({ workers: {} });
        this.workers = new Map();
        this.snapToWorkerMap = new Map();
        this.workerToSnapMap = new Map();
        this._snapRpcHooks = new Map();
        this._messenger = messenger;
        this._unresponsivePollingInterval = unresponsivePollingInterval;
        this._unresponsiveTimeout = unresponsiveTimeout;
        this._timeoutForUnresponsiveMap = new Map();
    }
    _setWorker(workerId, workerWrapper) {
        this.workers.set(workerId, workerWrapper);
        const newWorkerState = Object.assign(Object.assign({}, this.store.getState().workers), { [workerId]: workerWrapper });
        this.store.updateState({ workers: newWorkerState });
    }
    _deleteWorker(workerId) {
        this.workers.delete(workerId);
        const newWorkerState = Object.assign({}, this.store.getState().workers);
        delete newWorkerState[workerId];
        this.store.updateState({ workers: newWorkerState });
    }
    async _command(workerId, message) {
        if (typeof message !== 'object') {
            throw new Error('Must send object.');
        }
        const workerWrapper = this.workers.get(workerId);
        if (!workerWrapper) {
            throw new Error(`Worker with id ${workerId} not found.`);
        }
        console.log('Parent: Sending Command', message);
        const response = await workerWrapper.rpcEngine.handle(message);
        if (response.error) {
            throw new Error(response.error.message);
        }
        return response.result;
    }
    async terminateAllSnaps() {
        for (const workerId of this.workers.keys()) {
            this.terminate(workerId);
        }
        this._snapRpcHooks.clear();
    }
    async terminateSnap(snapName) {
        const workerId = this.snapToWorkerMap.get(snapName);
        workerId && this.terminate(workerId);
        this._removeSnapHooks(snapName);
    }
    terminate(workerId) {
        const workerWrapper = this.workers.get(workerId);
        if (!workerWrapper) {
            throw new Error(`Worker with id "${workerId}" not found.`);
        }
        const snapName = this._getSnapForWorker(workerId);
        if (!snapName) {
            throw new Error(`Failed to find a snap for worker with id "${workerId}".`);
        }
        Object.values(workerWrapper.streams).forEach((stream) => {
            try {
                !stream.destroyed && stream.destroy();
                stream.removeAllListeners();
            }
            catch (err) {
                console.log('Error while destroying stream', err);
            }
        });
        workerWrapper.worker.terminate();
        this._removeSnapAndWorkerMapping(workerId);
        this._deleteWorker(workerId);
        clearTimeout(this._timeoutForUnresponsiveMap.get(workerId));
        this._timeoutForUnresponsiveMap.delete(workerId);
        console.log(`worker:${workerId} terminated`);
    }
    /**
     * Gets the RPC message handler for the given snap.
     *
     * @param snapName - The name of the snap whose message handler to get.
     */
    async getRpcMessageHandler(snapName) {
        return this._snapRpcHooks.get(snapName);
    }
    _removeSnapHooks(snapName) {
        this._snapRpcHooks.delete(snapName);
    }
    _createSnapHooks(snapName, workerId) {
        const rpcHook = async (origin, request) => {
            return await this._command(workerId, {
                id: nanoid_1.nanoid(),
                jsonrpc: '2.0',
                method: 'snapRpc',
                params: {
                    origin,
                    request,
                    target: snapName,
                },
            });
        };
        this._snapRpcHooks.set(snapName, rpcHook);
    }
    async executeSnap(snapData) {
        if (this.snapToWorkerMap.has(snapData.snapName)) {
            throw new Error(`Snap "${snapData.snapName}" is already being executed.`);
        }
        const worker = await this._initWorker();
        this._mapSnapAndWorker(snapData.snapName, worker.id);
        this.setupSnapProvider(snapData.snapName, worker.streams.rpc);
        const result = await this._command(worker.id, {
            jsonrpc: '2.0',
            method: 'executeSnap',
            params: snapData,
            id: nanoid_1.nanoid(),
        });
        // set up poll/ping for status to see if its up, if its not then emit event that it cant be reached
        this._pollForWorkerStatus(snapData.snapName);
        this._createSnapHooks(snapData.snapName, worker.id);
        return result;
    }
    _pollForWorkerStatus(snapName) {
        const workerId = this._getWorkerForSnap(snapName);
        if (!workerId) {
            throw new Error('no worker id found for snap');
        }
        const timeout = setTimeout(async () => {
            this._getWorkerStatus(workerId)
                .then(() => {
                this._pollForWorkerStatus(snapName);
            })
                .catch(() => {
                this._messenger.publish('ServiceMessenger:unresponsive', snapName);
            });
        }, this._unresponsivePollingInterval);
        this._timeoutForUnresponsiveMap.set(snapName, timeout);
    }
    async _getWorkerStatus(workerId) {
        let resolve;
        let reject;
        const timeoutPromise = new Promise((res, rej) => {
            resolve = res;
            reject = rej;
        });
        const timeout = setTimeout(() => {
            reject(new Error('ping request timed out'));
        }, this._unresponsiveTimeout);
        return Promise.race([
            this._command(workerId, {
                jsonrpc: '2.0',
                method: 'ping',
                params: [],
                id: nanoid_1.nanoid(),
            }).then(() => {
                clearTimeout(timeout);
                resolve();
            }),
            timeoutPromise,
        ]);
    }
    _mapSnapAndWorker(snapName, workerId) {
        this.snapToWorkerMap.set(snapName, workerId);
        this.workerToSnapMap.set(workerId, snapName);
    }
    /**
     * @returns The ID of the snap's worker.
     */
    _getWorkerForSnap(snapName) {
        return this.snapToWorkerMap.get(snapName);
    }
    /**
     * @returns The ID worker's snap.
     */
    _getSnapForWorker(workerId) {
        return this.workerToSnapMap.get(workerId);
    }
    _removeSnapAndWorkerMapping(workerId) {
        const snapName = this.workerToSnapMap.get(workerId);
        if (!snapName) {
            throw new Error(`worker:${workerId} has no mapped snap.`);
        }
        this.workerToSnapMap.delete(workerId);
        this.snapToWorkerMap.delete(snapName);
    }
    async _initWorker() {
        const workerId = nanoid_1.nanoid();
        const worker = new Worker(this.workerUrl, {
            name: workerId,
        });
        // Handle out-of-band errors, i.e. errors thrown from the snap outside of the req/res cycle.
        const errorHandler = (ev) => {
            if (this._messenger) {
                const snapName = this.workerToSnapMap.get(workerId);
                if (snapName) {
                    this._messenger.publish('ServiceMessenger:unhandledError', snapName, {
                        code: ev.error.code,
                        message: ev.error.message,
                        data: ev.error.data,
                    });
                }
            }
        };
        worker.addEventListener('error', errorHandler, { once: true });
        const streams = this._initWorkerStreams(worker, workerId);
        const rpcEngine = new json_rpc_engine_1.JsonRpcEngine();
        const jsonRpcConnection = json_rpc_middleware_stream_1.createStreamMiddleware();
        pump_1.default(jsonRpcConnection.stream, streams.command, jsonRpcConnection.stream);
        rpcEngine.push(jsonRpcConnection.middleware);
        const workerWrapper = {
            id: workerId,
            streams,
            rpcEngine,
            worker,
        };
        this._setWorker(workerId, workerWrapper);
        await this._command(workerId, {
            jsonrpc: '2.0',
            method: 'ping',
            id: nanoid_1.nanoid(),
        });
        return workerWrapper;
    }
    _initWorkerStreams(worker, workerId) {
        const workerStream = new post_message_stream_1.WorkerParentPostMessageStream({ worker });
        // Typecast justification: stream type mismatch
        const mux = setupMultiplex(workerStream, `Worker:${workerId}`);
        const commandStream = mux.createStream(snap_workers_1.SNAP_STREAM_NAMES.COMMAND);
        const rpcStream = mux.createStream(snap_workers_1.SNAP_STREAM_NAMES.JSON_RPC);
        // Typecast: stream type mismatch
        return {
            command: commandStream,
            rpc: rpcStream,
            _connection: workerStream,
        };
    }
}
exports.WebWorkerExecutionEnvironmentService = WebWorkerExecutionEnvironmentService;
/**
 * Sets up stream multiplexing for the given stream.
 *
 * @param {any} connectionStream - the stream to mux
 * @param {string} streamName - the name of the stream, for identification in errors
 * @return {stream.Stream} the multiplexed stream
 */
function setupMultiplex(connectionStream, streamName) {
    const mux = new object_multiplex_1.default();
    pump_1.default(connectionStream, 
    // Typecast: stream type mismatch
    mux, connectionStream, (err) => {
        if (err) {
            streamName
                ? console.error(`${streamName} stream failure.`, err)
                : console.error(err);
        }
    });
    return mux;
}
//# sourceMappingURL=WebWorkerExecutionEnvironmentService.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/services/WebWorkerExecutionEnvironmentService.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/resource/ExternalResourceController.js", {"@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/obs-store/dist/index.js","@metamask/safe-event-emitter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/safe-event-emitter/index.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","nanoid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/nanoid/index.browser.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/resource/ExternalResourceController.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExternalResourceController = void 0;
const obs_store_1 = require("@metamask/obs-store");
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
const eth_rpc_errors_1 = require("eth-rpc-errors");
const nanoid_1 = require("nanoid");
const alwaysRequiredFields = ['fromDomain'];
const computeState = (storageKey, initialResources) => {
    return { [storageKey]: initialResources };
};
const getUnauthorizedMessage = (id) => `Not authorized to access resource with id "${id}".`;
/**
 * A class intended to describe a particular resource that is managed by snaps.
 * Example resources are assets.
 *
 * These are things that MetaMask treats as first-class objects with distinct properties within its own UI.
 */
class ExternalResourceController extends safe_event_emitter_1.default {
    constructor({ storageKey, requiredFields, initialResources, }) {
        super();
        this.requiredFields = requiredFields;
        this.storageKey = storageKey;
        this.store = new obs_store_1.ObservableStore(computeState(storageKey, initialResources));
    }
    getResources() {
        return Object.assign({}, this.store.getState()[this.storageKey]);
    }
    setResources(resources) {
        this.store.updateState({
            [this.storageKey]: resources,
        });
    }
    clearResources() {
        this.setResources({});
    }
    deleteResourcesFor(fromDomain) {
        const resources = this.getResources();
        const newResources = Object.entries(resources).reduce((acc, [id, resource]) => {
            if (resource.fromDomain !== fromDomain) {
                acc[id] = resource;
            }
            return acc;
        }, {});
        this.setResources(newResources);
    }
    get(fromDomain, id) {
        const resource = this.getResources()[id];
        if (resource && resource.fromDomain !== fromDomain) {
            throw eth_rpc_errors_1.ethErrors.provider.unauthorized({
                message: getUnauthorizedMessage(id),
            });
        }
        return resource ? Object.assign({}, resource) : null;
    }
    getAllResources(fromDomain) {
        return Object.values(this.getResources()).filter((resource) => {
            return resource.fromDomain === fromDomain;
        });
    }
    add(fromDomain, resource) {
        const newResource = this.processNewResource(fromDomain, resource);
        const { id } = newResource;
        const resources = this.getResources();
        if (resources[id]) {
            throw new Error(`Resource with id "${id}" already exists.`);
        }
        else {
            resources[id] = newResource;
            this.setResources(resources);
        }
        return newResource.id;
    }
    update(fromDomain, resource) {
        const { id } = resource;
        const resources = this.getResources();
        const existingResource = resources[id];
        if (!existingResource) {
            throw eth_rpc_errors_1.ethErrors.rpc.resourceNotFound({
                message: `Resource with id "${id}" not found.`,
            });
        }
        else if (existingResource.fromDomain !== fromDomain) {
            throw eth_rpc_errors_1.ethErrors.provider.unauthorized({
                message: getUnauthorizedMessage(id),
            });
        }
        resources[id] = this.processNewResource(fromDomain, Object.assign(Object.assign({}, resources[id]), resource));
        this.setResources(resources);
        return id;
    }
    processNewResource(fromDomain, resource) {
        this.requiredFields.forEach((requiredField) => {
            if (!(requiredField in resource)) {
                throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Resource from "${fromDomain}" missing required field: ${requiredField}`);
            }
        });
        return Object.assign(Object.assign({}, resource), { fromDomain, id: resource.id || nanoid_1.nanoid() });
    }
    delete(fromDomain, id) {
        const resources = this.getResources();
        const existingResource = resources[id];
        if (!existingResource) {
            throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
                message: `Resource with id "${id}" not found.`,
            });
        }
        else if (existingResource.fromDomain !== fromDomain) {
            throw eth_rpc_errors_1.ethErrors.provider.unauthorized({
                message: getUnauthorizedMessage(id),
            });
        }
        delete resources[id];
        this.setResources(resources);
        return null;
    }
    handleRpcRequest(fromDomain, method, arg) {
        if (!fromDomain || typeof fromDomain !== 'string') {
            throw new Error('Invalid fromDomain.');
        }
        switch (method) {
            case 'get':
                return this.get(fromDomain, arg);
            case 'getAll':
                return this.getAllResources(fromDomain);
            case 'add':
                return this.add(fromDomain, arg);
            case 'update':
                return this.update(fromDomain, arg);
            case 'delete':
                return this.delete(fromDomain, arg);
            default:
                throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound({
                    message: `Not an asset method: ${method}`,
                });
        }
    }
}
exports.ExternalResourceController = ExternalResourceController;
//# sourceMappingURL=ExternalResourceController.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/resource/ExternalResourceController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/utils.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/utils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MethodNames = void 0;
var MethodNames;
(function (MethodNames) {
    MethodNames["requestPermissions"] = "wallet_requestPermissions";
    MethodNames["getPermissions"] = "wallet_getPermissions";
})(MethodNames = exports.MethodNames || (exports.MethodNames = {}));
//# sourceMappingURL=utils.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/Permission.js", {"nanoid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/nanoid/index.browser.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/Permission.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findCaveat = exports.constructPermission = void 0;
const nanoid_1 = require("nanoid");
/**
 * The default permission factory function. Naively constructs a permission from
 * the inputs. Sets a default, random `id` if none is provided.
 *
 * @see {@link Permission} For more details.
 *
 * @template TargetPermission - The {@link Permission} that will be constructed.
 * @param options - The options for the permission.
 * @returns The new permission object.
 */
function constructPermission(options) {
    const { caveats = null, invoker, target } = options;
    return {
        id: nanoid_1.nanoid(),
        parentCapability: target,
        invoker,
        caveats,
        date: new Date().getTime(),
    };
}
exports.constructPermission = constructPermission;
/**
 * Gets the caveat of the specified type belonging to the specified permission.
 *
 * @param permission The permission whose caveat to retrieve.
 * @param caveatType The type of the caveat to retrieve.
 * @returns The caveat, or undefined if no such caveat exists.
 */
function findCaveat(permission, caveatType) {
    var _a;
    return (_a = permission.caveats) === null || _a === void 0 ? void 0 : _a.find((caveat) => caveat.type === caveatType);
}
exports.findCaveat = findCaveat;
//# sourceMappingURL=Permission.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/Permission.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/Caveat.js", {"./errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/errors.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/Caveat.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decorateWithCaveats = void 0;
const errors_1 = require("./errors");
/**
 * Decorate a restricted method implementation with its caveats.
 *
 * Note that all caveat functions (i.e. the argument and return value of the
 * decorator) must be awaited.
 */
function decorateWithCaveats(methodImplementation, permission, // bound to the requesting origin
caveatSpecifications) {
    const { caveats } = permission;
    if (!caveats) {
        return methodImplementation;
    }
    let decorated = async (args) => methodImplementation(args);
    for (const caveat of caveats) {
        const specification = caveatSpecifications[caveat.type];
        if (!specification) {
            throw new errors_1.UnrecognizedCaveatTypeError(caveat.type);
        }
        decorated = specification.decorator(decorated, caveat);
    }
    return decorated;
}
exports.decorateWithCaveats = decorateWithCaveats;
//# sourceMappingURL=Caveat.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/Caveat.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/index.js", {"./getPermissions":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/getPermissions.js","./requestPermissions":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/requestPermissions.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handlers = void 0;
const requestPermissions_1 = require("./requestPermissions");
const getPermissions_1 = require("./getPermissions");
exports.handlers = [requestPermissions_1.requestPermissionsHandler, getPermissions_1.getPermissionsHandler];
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/PermissionController.js", {"../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/utils.js","./Caveat":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/Caveat.js","./Permission":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/Permission.js","./errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/errors.js","./permission-middleware":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/permission-middleware.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/utils.js","@metamask/controllers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/controllers/dist/index.js","deep-freeze-strict":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/deep-freeze-strict/index.js","immer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/immer/dist/index.js","nanoid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/nanoid/index.browser.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/PermissionController.js
      return function (require, module, exports) {
"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionController = exports.CaveatMutatorOperation = void 0;
const controllers_1 = require("@metamask/controllers");
/* eslint-enable @typescript-eslint/no-unused-vars */
const deep_freeze_strict_1 = __importDefault(require("deep-freeze-strict"));
const immer_1 = require("immer");
const nanoid_1 = require("nanoid");
const utils_1 = require("../utils");
const Caveat_1 = require("./Caveat");
const Permission_1 = require("./Permission");
const errors_1 = require("./errors");
const utils_2 = require("./utils");
const permission_middleware_1 = require("./permission-middleware");
/**
 * The name of the {@link PermissionController}.
 */
const controllerName = 'PermissionController';
/**
 * Get the state metadata of the {@link PermissionController}.
 *
 * @template Permission - The controller's permission type union.
 */
function getStateMetadata() {
    return { subjects: { anonymous: true, persist: true } };
}
/**
 * Get the default state of the {@link PermissionController}.
 *
 * @template Permission - The controller's permission type union.
 */
function getDefaultState() {
    return { subjects: {} };
}
/**
 * Describes the possible results of a {@link CaveatMutator} function.
 */
var CaveatMutatorOperation;
(function (CaveatMutatorOperation) {
    CaveatMutatorOperation[CaveatMutatorOperation["noop"] = 0] = "noop";
    CaveatMutatorOperation[CaveatMutatorOperation["updateValue"] = 1] = "updateValue";
    CaveatMutatorOperation[CaveatMutatorOperation["deleteCaveat"] = 2] = "deleteCaveat";
    CaveatMutatorOperation[CaveatMutatorOperation["revokePermission"] = 3] = "revokePermission";
})(CaveatMutatorOperation = exports.CaveatMutatorOperation || (exports.CaveatMutatorOperation = {}));
/**
 * The permission controller. See the README for details.
 *
 * Assumes the existence of an {@link ApprovalController} reachable via the
 * {@link ControllerMessenger}.
 *
 * @template ControllerPermissionSpecification - A union of the types of all
 * permission specifications available to the controller. Any referenced caveats
 * must be included in the controller's caveat specifications.
 * @template ControllerCaveatSpecification - A union of the types of all
 * caveat specifications available to the controller.
 */
class PermissionController extends controllers_1.BaseControllerV2 {
    /**
     * @param options - Permission controller options.
     * @param options.caveatSpecifications - The specifications of all caveats
     * available to the controller. See {@link CaveatSpecificationMap} and the
     * documentation for more details.
     * @param options.permissionSpecifications - The specifications of all
     * permissions available to the controller. See
     * {@link PermissionSpecificationMap} and the README for more details.
     * @param options.unrestrictedMethods - The callable names of all JSON-RPC
     * methods ignored by the new controller.
     * @param options.messenger - The controller messenger. See
     * {@link BaseController} for more information.
     * @param options.state - Existing state to hydrate the controller with at
     * initialization.
     */
    constructor(options) {
        const { caveatSpecifications, permissionSpecifications, unrestrictedMethods, messenger, state = {}, } = options;
        super({
            name: controllerName,
            metadata: getStateMetadata(),
            messenger,
            state: Object.assign(Object.assign({}, getDefaultState()), state),
        });
        this._unrestrictedMethods = new Set(unrestrictedMethods);
        this._caveatSpecifications = deep_freeze_strict_1.default(Object.assign({}, caveatSpecifications));
        this.validatePermissionSpecifications(permissionSpecifications, this._caveatSpecifications);
        this._permissionSpecifications = deep_freeze_strict_1.default(Object.assign({}, permissionSpecifications));
        this.registerMessageHandlers();
        this.createPermissionMiddleware = permission_middleware_1.getPermissionMiddlewareFactory({
            executeRestrictedMethod: this._executeRestrictedMethod.bind(this),
            getRestrictedMethod: this.getRestrictedMethod.bind(this),
            isUnrestrictedMethod: this.unrestrictedMethods.has.bind(this.unrestrictedMethods),
        });
    }
    /**
     * The names of all JSON-RPC methods that will be ignored by the controller.
     */
    get unrestrictedMethods() {
        return this._unrestrictedMethods;
    }
    /**
     * Gets a permission specification.
     *
     * @param targetKey - The target key of the permission specification to get.
     * @returns The permission specification with the specified target key.
     */
    getPermissionSpecification(targetKey) {
        return this._permissionSpecifications[targetKey];
    }
    /**
     * Gets a caveat specification.
     *
     * @param caveatType - The type of the caveat specification to get.
     * @returns The caveat specification with the specified type.
     */
    getCaveatSpecification(caveatType) {
        return this._caveatSpecifications[caveatType];
    }
    /**
     * Constructor helper for validating permission specifications. This is
     * intended to prevent the use of invalid target keys which, while impossible
     * to add in TypeScript, could rather easily occur in plain JavaScript.
     *
     * Throws an error if validation fails.
     *
     * @param permissionSpecifications - The permission specifications passed to
     * this controller's constructor.
     * @param caveatSpecifications - The caveat specifications passed to this
     * controller.
     */
    validatePermissionSpecifications(permissionSpecifications, caveatSpecifications) {
        Object.entries(permissionSpecifications).forEach(([targetKey, { targetKey: innerTargetKey, allowedCaveats }]) => {
            // Check if the target key is the empty string, ends with "_", or ends
            // with "*" but not "_*"
            if (!targetKey || /_$/u.test(targetKey) || /[^_]\*$/u.test(targetKey)) {
                throw new Error(`Invalid permission target key: "${targetKey}"`);
            }
            if (targetKey !== innerTargetKey) {
                throw new Error(`Invalid permission specification: key "${targetKey}" must match specification.target value "${innerTargetKey}".`);
            }
            if (allowedCaveats) {
                allowedCaveats.forEach((caveatType) => {
                    if (!utils_1.hasProperty(caveatSpecifications, caveatType)) {
                        throw new errors_1.UnrecognizedCaveatTypeError(caveatType);
                    }
                });
            }
        });
    }
    /**
     * Constructor helper for registering the controller's messaging system
     * actions.
     */
    registerMessageHandlers() {
        this.messagingSystem.registerActionHandler(`${controllerName}:clearPermissions`, () => this.clearState());
        this.messagingSystem.registerActionHandler(`${controllerName}:getSubjectNames`, () => this.getSubjectNames());
        this.messagingSystem.registerActionHandler(`${controllerName}:hasPermissions`, (origin) => this.hasPermissions(origin));
    }
    /**
     * Clears the state of the controller.
     */
    clearState() {
        this.update((_draftState) => {
            return Object.assign({}, getDefaultState());
        });
    }
    /**
     * Gets the implementation of the specified restricted method.
     *
     * A JSON-RPC error is thrown if the method does not exist.
     *
     * @see {@link PermissionController.executeRestrictedMethod} and
     * {@link PermissionController.createPermissionMiddleware} for internal usage.
     * @param method - The name of the restricted method.
     * @param origin - The origin associated with the request for the restricted
     * method, if any.
     * @returns The restricted method implementation.
     */
    getRestrictedMethod(method, origin) {
        const targetKey = this.getTargetKey(method);
        if (!targetKey) {
            const error = errors_1.methodNotFound({ method });
            if (origin) {
                error.data = { origin };
            }
            throw error;
        }
        return this.getPermissionSpecification(targetKey).methodImplementation;
    }
    /**
     * @returns The origins (i.e. IDs) of all subjects.
     */
    getSubjectNames() {
        return Object.keys(this.state.subjects);
    }
    /**
     * Gets the permission for the specified target of the subject corresponding
     * to the specified origin.
     *
     * @param origin - The origin of the subject.
     * @param targetName - The method name as invoked by a third party (i.e., not
     * a method key).
     * @returns The permission if it exists, or undefined otherwise.
     */
    getPermission(origin, targetName) {
        var _a;
        return (_a = this.state.subjects[origin]) === null || _a === void 0 ? void 0 : _a.permissions[targetName];
    }
    /**
     * Gets all permissions for the specified subject, if any.
     *
     * @param origin - The origin of the subject.
     * @returns The permissions of the subject, if any.
     */
    getPermissions(origin) {
        var _a;
        return (_a = this.state.subjects[origin]) === null || _a === void 0 ? void 0 : _a.permissions;
    }
    /**
     * Checks whether the subject with the specified origin has the specified
     * permission.
     *
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @returns Whether the subject has the permission.
     */
    hasPermission(origin, target) {
        return Boolean(this.getPermission(origin, target));
    }
    /**
     * Checks whether the subject with the specified origin has any permissions.
     * Use this if you want to know if a subject "exists".
     *
     * @param origin - The origin of the subject to check.
     * @returns Whether the subject has any permissions.
     */
    hasPermissions(origin) {
        return Boolean(this.state.subjects[origin]);
    }
    /**
     * Revokes all permissions from the specified origin.
     *
     * Throws an error of the origin has no permissions.
     *
     * @param origin - The origin whose permissions to revoke.
     */
    revokeAllPermissions(origin) {
        this.update((draftState) => {
            if (!draftState.subjects[origin]) {
                throw new errors_1.UnrecognizedSubjectError(origin);
            }
            delete draftState.subjects[origin];
        });
    }
    /**
     * Revokes the specified permission from the subject with the specified
     * origin.
     *
     * Throws an error if the subject or the permission does not exist.
     *
     * @param origin - The origin of the subject whose permission to revoke.
     * @param target - The target name of the permission to revoke.
     */
    revokePermission(origin, target) {
        this.revokePermissions({ [origin]: [target] });
    }
    /**
     * Revokes the specified permissions from the specified subjects.
     *
     * Throws an error if any of the subjects or permissions do not exist.
     *
     * @param subjectsAndPermissions - An object mapping subject origins
     * to arrays of permission target names to revoke.
     */
    revokePermissions(subjectsAndPermissions) {
        this.update((draftState) => {
            Object.keys(subjectsAndPermissions).forEach((origin) => {
                if (!utils_1.hasProperty(draftState.subjects, origin)) {
                    throw new errors_1.UnrecognizedSubjectError(origin);
                }
                subjectsAndPermissions[origin].forEach((target) => {
                    const { permissions } = draftState.subjects[origin];
                    if (!utils_1.hasProperty(permissions, target)) {
                        throw new errors_1.PermissionDoesNotExistError(origin, target);
                    }
                    this.deletePermission(draftState.subjects, origin, target);
                });
            });
        });
    }
    /**
     * Revokes all permissions corresponding to the specified target for all subjects.
     * Does nothing if no subjects or no such permission exists.
     *
     * @param target - The name of the target to revoke all permissions for.
     */
    revokePermissionForAllSubjects(target) {
        if (this.getSubjectNames().length === 0) {
            return;
        }
        this.update((draftState) => {
            Object.entries(draftState.subjects).forEach(([origin, subject]) => {
                const { permissions } = subject;
                if (utils_1.hasProperty(permissions, target)) {
                    this.deletePermission(draftState.subjects, origin, target);
                }
            });
        });
    }
    /**
     * Deletes the permission identified by the given origin and target. If the
     * permission is the single remaining permission of its subject, the subject
     * is also deleted.
     *
     * @param subjects - The draft permission controller subjects.
     * @param origin - The origin of the subject associated with the permission
     * to delete.
     * @param target - The target name of the permission to delete.
     */
    deletePermission(subjects, origin, target) {
        const { permissions } = subjects[origin];
        if (Object.keys(permissions).length > 1) {
            delete permissions[target];
        }
        else {
            delete subjects[origin];
        }
    }
    /**
     * Checks whether the permission of the subject corresponding to the given
     * origin has a caveat of the specified type.
     *
     * Throws an error if the subject does not have a permission with the
     * specified target name.
     *
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to check for.
     * @returns Whether the permission has the specified caveat.
     */
    hasCaveat(origin, target, caveatType) {
        return Boolean(this.getCaveat(origin, target, caveatType));
    }
    /**
     * Gets the caveat of the specified type, if any, for the permission of
     * the subject corresponding to the given origin.
     *
     * Throws an error if the subject does not have a permission with the
     * specified target name.
     *
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to get.
     * @returns The caveat, or `undefined` if no such caveat exists.
     */
    getCaveat(origin, target, caveatType) {
        const permission = this.getPermission(origin, target);
        if (!permission) {
            throw new errors_1.PermissionDoesNotExistError(origin, target);
        }
        return Permission_1.findCaveat(permission, caveatType);
    }
    /**
     * Adds a caveat of the specified type, with the specified caveat value, to
     * the permission corresponding to the given subject origin and permission
     * target.
     *
     * For modifying existing caveats, use
     * {@link PermissionController.updateCaveat}.
     *
     * Throws an error if no such permission exists, or if the caveat already
     * exists.
     *
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to add.
     * @param caveatValue - The value of the caveat to add.
     */
    addCaveat(origin, target, caveatType, caveatValue) {
        if (this.hasCaveat(origin, target, caveatType)) {
            throw new errors_1.CaveatAlreadyExistsError(origin, target, caveatType);
        }
        this.setCaveat(origin, target, caveatType, caveatValue);
    }
    /**
     * Updates the value of the caveat of the specified type belonging to the
     * permission corresponding to the given subject origin and permission
     * target.
     *
     * For adding new caveats, use
     * {@link PermissionController.addCaveat}.
     *
     * Throws an error if no such permission or caveat exists.
     *
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to update.
     * @param caveatValue - The new value of the caveat.
     */
    updateCaveat(origin, target, caveatType, caveatValue) {
        if (!this.hasCaveat(origin, target, caveatType)) {
            throw new errors_1.CaveatDoesNotExistError(origin, target, caveatType);
        }
        this.setCaveat(origin, target, caveatType, caveatValue);
    }
    /**
     * Sets the specified caveat on the specified permission. Overwrites existing
     * caveats of the same type in-place (preserving array order), and adds the
     * caveat to the end of the array otherwise.
     *
     * Throws an error if the permission does not exist or fails to validate after
     * its caveats have been modified.
     *
     * @see {@link PermissionController.addCaveat}
     * @see {@link PermissionController.updateCaveat}
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to set.
     * @param caveatValue - The value of the caveat to set.
     */
    setCaveat(origin, target, caveatType, caveatValue) {
        this.update((draftState) => {
            const subject = draftState.subjects[origin];
            // Unreachable because `hasCaveat` is always called before this, and it
            // throws if permissions are missing. TypeScript needs this, however.
            /* istanbul ignore if */
            if (!subject) {
                throw new errors_1.UnrecognizedSubjectError(origin);
            }
            const permission = subject.permissions[target];
            /* istanbul ignore if: practically impossible, but TypeScript wants it */
            if (!permission) {
                throw new errors_1.PermissionDoesNotExistError(origin, target);
            }
            const caveat = {
                type: caveatType,
                value: caveatValue,
            };
            this.validateCaveat(caveat, origin, target);
            if (permission.caveats) {
                const caveatIndex = permission.caveats.findIndex((existingCaveat) => existingCaveat.type === caveat.type);
                if (caveatIndex === -1) {
                    permission.caveats.push(caveat);
                }
                else {
                    permission.caveats.splice(caveatIndex, 1, caveat);
                }
            }
            else {
                // Typecast: At this point, we don't know if the specific permission
                // is allowed to have caveats, but it should be impossible to call
                // this method for a permission that may not have any caveats.
                // If all else fails, the permission validator is also called.
                permission.caveats = [caveat];
            }
            this.validateModifiedPermission(permission, origin, target);
        });
    }
    /**
     * Updates all caveats with the specified type for all subjects and
     * permissions by applying the specified mutator function to them.
     *
     * **ATTN:** Permissions can be revoked entirely by the action of this method,
     * read on for details.
     *
     * Caveat mutators are functions that receive a caveat value and return a
     * tuple consisting of a {@link CaveatMutatorOperation} and, optionally, a new
     * value to update the existing caveat with.
     *
     * For each caveat, depending on the mutator result, this method will:
     * - Do nothing ({@link CaveatMutatorOperation.noop})
     * - Update the value of the caveat ({@link CaveatMutatorOperation.updateValue})
     *   - The caveat specification validator, if any, will be called after
     *     updating the value.
     * - Delete the caveat ({@link CaveatMutatorOperation.deleteCaveat})
     *   - The permission specification validator, if any, will be called after
     *     deleting the caveat.
     * - Revoke the parent permission ({@link CaveatMutatorOperation.revokePermission})
     *
     * This method throws if the validation of any caveat or permission fails.
     *
     * @param targetCaveatType - The type of the caveats to update.
     * @param mutator - The mutator function which will be applied to all caveat
     * values.
     */
    updatePermissionsByCaveat(targetCaveatType, mutator) {
        if (Object.keys(this.state.subjects).length === 0) {
            return;
        }
        this.update((draftState) => {
            Object.values(draftState.subjects).forEach((subject) => {
                Object.values(subject.permissions).forEach((permission) => {
                    const { caveats } = permission;
                    const targetCaveat = caveats === null || caveats === void 0 ? void 0 : caveats.find(({ type }) => type === targetCaveatType);
                    if (!targetCaveat) {
                        return;
                    }
                    // The mutator may modify the caveat value in place, and must always
                    // return a valid mutation result.
                    const mutatorResult = mutator(targetCaveat.value);
                    switch (mutatorResult.operation) {
                        case CaveatMutatorOperation.noop:
                            break;
                        case CaveatMutatorOperation.updateValue:
                            // Typecast: `Mutable` is used here to assign to a readonly
                            // property. `targetConstraint` should already be mutable because
                            // it's part of a draft, but for some reason it's not. We can't
                            // use the more-correct `Draft` type here either because it
                            // results in an error.
                            targetCaveat.value =
                                mutatorResult.value;
                            this.validateCaveat(targetCaveat, subject.origin, permission.parentCapability);
                            break;
                        case CaveatMutatorOperation.deleteCaveat:
                            this.deleteCaveat(permission, targetCaveatType, subject.origin, permission.parentCapability);
                            break;
                        case CaveatMutatorOperation.revokePermission:
                            this.deletePermission(draftState.subjects, subject.origin, permission.parentCapability);
                            break;
                        default: {
                            // This type check ensures that the switch statement is
                            // exhaustive.
                            const _exhaustiveCheck = mutatorResult;
                            throw new Error(`Unrecognized mutation result: "${_exhaustiveCheck.operation}"`);
                        }
                    }
                });
            });
        });
    }
    /**
     * Removes the caveat of the specified type from the permission corresponding
     * to the given subject origin and target name.
     *
     * Throws an error if no such permission or caveat exists.
     *
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to remove.
     */
    removeCaveat(origin, target, caveatType) {
        this.update((draftState) => {
            var _a;
            const permission = (_a = draftState.subjects[origin]) === null || _a === void 0 ? void 0 : _a.permissions[target];
            if (!permission) {
                throw new errors_1.PermissionDoesNotExistError(origin, target);
            }
            if (!permission.caveats) {
                throw new errors_1.CaveatDoesNotExistError(origin, target, caveatType);
            }
            this.deleteCaveat(permission, caveatType, origin, target);
        });
    }
    /**
     * Deletes the specified caveat from the specified permission. If no caveats
     * remain after deletion, the permission's caveat property is set to `null`.
     * The permission is validated after being modified.
     *
     * Throws an error if the permission does not have a caveat with the specified
     * type.
     *
     * @param permission - The permission whose caveat to delete.
     * @param caveatType - The type of the caveat to delete.
     * @param origin - The origin the permission subject.
     * @param target - The name of the permission target.
     */
    deleteCaveat(permission, caveatType, origin, target) {
        /* istanbul ignore if: not possible in our usage */
        if (!permission.caveats) {
            throw new errors_1.CaveatDoesNotExistError(origin, target, caveatType);
        }
        const caveatIndex = permission.caveats.findIndex((existingCaveat) => existingCaveat.type === caveatType);
        if (caveatIndex === -1) {
            throw new errors_1.CaveatDoesNotExistError(origin, target, caveatType);
        }
        if (permission.caveats.length === 1) {
            permission.caveats = null;
        }
        else {
            permission.caveats.splice(caveatIndex, 1);
        }
        this.validateModifiedPermission(permission, origin, target);
    }
    /**
     * Validates the specified modified permission. Should **always** be invoked
     * on a permission after its caveats have been modified.
     *
     * Just like {@link PermissionController.validatePermission}, except that the
     * corresponding target key and specification are retrieved first, and an
     * error is thrown if the target key does not exist.
     *
     * @param permission - The modified permission to validate.
     * @param origin - The origin associated with the permission.
     * @param targetName - The target name name of the permission.
     */
    validateModifiedPermission(permission, origin, targetName) {
        const targetKey = this.getTargetKey(permission.parentCapability);
        /* istanbul ignore if: this should be impossible */
        if (!targetKey) {
            throw new Error(`Fatal: Existing permission target key "${targetKey}" has no specification.`);
        }
        this.validatePermission(this.getPermissionSpecification(targetKey), permission, origin, targetName);
    }
    /**
     * Gets the key for the specified permission target.
     *
     * Used to support our namespaced permission target feature, which is used
     * to implement namespaced restricted JSON-RPC methods.
     *
     * @param target - The requested permission target.
     * @returns The internal key of the permission target.
     */
    getTargetKey(target) {
        if (utils_1.hasProperty(this._permissionSpecifications, target)) {
            return target;
        }
        const namespacedTargetsWithoutWildcard = {};
        for (const targetKey of Object.keys(this._permissionSpecifications)) {
            const wildCardMatch = targetKey.match(/(.+)\*$/u);
            if (wildCardMatch) {
                namespacedTargetsWithoutWildcard[wildCardMatch[1]] = true;
            }
        }
        // Check for potentially nested namespaces:
        // Ex: wildzone_
        // Ex: eth_plugin_
        const segments = target.split('_');
        let targetKey = '';
        while (segments.length > 0 &&
            !utils_1.hasProperty(this._permissionSpecifications, targetKey) &&
            !namespacedTargetsWithoutWildcard[targetKey]) {
            targetKey += `${segments.shift()}_`;
        }
        if (namespacedTargetsWithoutWildcard[targetKey]) {
            return `${targetKey}*`;
        }
        return undefined;
    }
    /**
     * Grants _approved_ permissions to the specified subject. Every permission and
     * caveat is stringently validated – including by calling every specification
     * validator – and an error is thrown if any validation fails.
     *
     * **ATTN:** This method does **not** prompt the user for approval.
     *
     * @see {@link PermissionController.requestPermissions} For initiating a
     * permissions request requiring user approval.
     * @param options - Options bag.
     * @param options.approvedPermissions - The requested permissions approved by
     * the user.
     * @param options.requestData - Permission request data. Passed to permission
     * factory functions.
     * @param options.preserveExistingPermissions - Whether to preserve the
     * subject's existing permissions.
     * @param options.subject - The subject to grant permissions to.
     * @returns The granted permissions.
     */
    grantPermissions({ approvedPermissions, requestData, preserveExistingPermissions = true, subject, }) {
        const { origin } = subject;
        if (!origin || typeof origin !== 'string') {
            throw new errors_1.InvalidSubjectIdentifierError(origin);
        }
        const permissions = (preserveExistingPermissions
            ? Object.assign({}, this.getPermissions(origin)) : {});
        for (const [requestedTarget, approvedPermission] of Object.entries(approvedPermissions)) {
            const targetKey = this.getTargetKey(requestedTarget);
            if (!targetKey) {
                throw errors_1.methodNotFound({ method: requestedTarget });
            }
            if (approvedPermission.parentCapability !== undefined &&
                requestedTarget !== approvedPermission.parentCapability) {
                throw new errors_1.InvalidApprovedPermissionError(origin, requestedTarget, approvedPermission);
            }
            // The requested target must be a valid target name if we found its key.
            // We reassign it to change its type.
            const targetName = requestedTarget;
            const specification = this.getPermissionSpecification(targetKey);
            // The requested caveats are validated here.
            const caveats = this.constructCaveats(origin, targetName, approvedPermission.caveats);
            const permissionOptions = {
                caveats,
                invoker: origin,
                target: targetName,
            };
            let permission;
            if (specification.factory) {
                permission = specification.factory(permissionOptions, requestData);
                // Full caveat and permission validation is performed here since the
                // factory function can arbitrarily modify the entire permission object,
                // including its caveats.
                this.validatePermission(specification, permission, origin, targetName);
            }
            else {
                permission = Permission_1.constructPermission(permissionOptions);
                // We do not need to validate caveats in this case, because the plain
                // permission constructor function does not modify the caveats, which
                // were already validated by `constructCaveats` above.
                this.validatePermission(specification, permission, origin, targetName, {
                    invokePermissionValidator: true,
                    performCaveatValidation: false,
                });
            }
            permissions[targetName] = permission;
        }
        this.setValidatedPermissions(origin, permissions);
        return permissions;
    }
    /**
     * Validates the specified permission by:
     * - Ensuring that its `caveats` property is either `null` or a non-empty
     *   array.
     * - Ensuring that it only includes caveats allowed by its specification.
     * - Ensuring that it includes no duplicate caveats (by caveat type).
     * - Validating each caveat object, if `performCaveatValidation` is `true`.
     * - Calling the validator of its specification, if one exists and
     *   `invokePermissionValidator` is `true`.
     *
     * An error is thrown if validation fails.
     *
     * @param specification - The specification of the permission.
     * @param permission - The permission to validate.
     * @param origin - The origin associated with the permission.
     * @param targetName - The target name of the permission.
     * @param validationOptions - Validation options.
     * @param validationOptions.invokePermissionValidator - Whether to invoke the
     * permission's consumer-specified validator function, if any.
     * @param validationOptions.performCaveatValidation - Whether to invoke
     * {@link PermissionController.validateCaveat} on each of the permission's
     * caveats.
     */
    validatePermission(specification, permission, origin, targetName, { invokePermissionValidator, performCaveatValidation } = {
        invokePermissionValidator: true,
        performCaveatValidation: true,
    }) {
        const { allowedCaveats, validator } = specification;
        if (utils_1.hasProperty(permission, 'caveats')) {
            const { caveats } = permission;
            if (caveats !== null && !(Array.isArray(caveats) && caveats.length > 0)) {
                throw new errors_1.InvalidCaveatsPropertyError(origin, targetName, caveats);
            }
            const seenCaveatTypes = new Set();
            caveats === null || caveats === void 0 ? void 0 : caveats.forEach((caveat) => {
                if (performCaveatValidation) {
                    this.validateCaveat(caveat, origin, targetName);
                }
                if (!(allowedCaveats === null || allowedCaveats === void 0 ? void 0 : allowedCaveats.includes(caveat.type))) {
                    throw new errors_1.ForbiddenCaveatError(caveat.type, origin, targetName);
                }
                if (seenCaveatTypes.has(caveat.type)) {
                    throw new errors_1.DuplicateCaveatError(caveat.type, origin, targetName);
                }
                seenCaveatTypes.add(caveat.type);
            });
        }
        if (invokePermissionValidator && validator) {
            validator(permission, origin, targetName);
        }
    }
    /**
     * Assigns the specified permissions to the subject with the given origin.
     * Overwrites all existing permissions, and creates a subject entry if it
     * doesn't already exist.
     *
     * **ATTN:** Assumes that the new permissions have been validated.
     *
     * @param origin - The origin of the grantee subject.
     * @param permissions - The new permissions for the grantee subject.
     */
    setValidatedPermissions(origin, permissions) {
        this.update((draftState) => {
            if (!draftState.subjects[origin]) {
                draftState.subjects[origin] = { origin, permissions: {} };
            }
            draftState.subjects[origin].permissions = immer_1.castDraft(permissions);
        });
    }
    /**
     * Validates the requested caveats for the permission of the specified
     * subject origin and target name and returns the validated caveat array.
     *
     * Throws an error if validation fails.
     *
     * @param origin - The origin of the permission subject.
     * @param target - The permission target name.
     * @param requestedCaveats - The requested caveats to construct.
     * @returns The constructed caveats.
     */
    constructCaveats(origin, target, requestedCaveats) {
        const caveatArray = requestedCaveats === null || requestedCaveats === void 0 ? void 0 : requestedCaveats.map((requestedCaveat) => {
            this.validateCaveat(requestedCaveat, origin, target);
            // Reassign so that we have a fresh object.
            const { type, value } = requestedCaveat;
            return { type, value };
        });
        return caveatArray && utils_1.isNonEmptyArray(caveatArray)
            ? caveatArray
            : undefined;
    }
    /**
     * This methods validates that the specified caveat is an object with the
     * expected properties and types. It also ensures that a caveat specification
     * exists for the requested caveat type, and calls the specification
     * validator, if it exists, on the caveat object.
     *
     * Throws an error if validation fails.
     *
     * @param caveat - The caveat object to validate.
     * @param origin - The origin associated with the subject of the parent
     * permission.
     * @param target - The target name associated with the parent permission.
     */
    validateCaveat(caveat, origin, target) {
        var _a;
        if (!utils_1.isPlainObject(caveat)) {
            throw new errors_1.InvalidCaveatError(caveat, origin, target);
        }
        if (Object.keys(caveat).length !== 2) {
            throw new errors_1.InvalidCaveatFieldsError(caveat, origin, target);
        }
        if (typeof caveat.type !== 'string') {
            throw new errors_1.InvalidCaveatTypeError(caveat, origin, target);
        }
        const specification = this.getCaveatSpecification(caveat.type);
        if (!specification) {
            throw new errors_1.UnrecognizedCaveatTypeError(caveat.type, origin, target);
        }
        if (!utils_1.hasProperty(caveat, 'value') || caveat.value === undefined) {
            throw new errors_1.CaveatMissingValueError(caveat, origin, target);
        }
        if (!utils_1.isValidJson(caveat.value)) {
            throw new errors_1.CaveatInvalidJsonError(caveat, origin, target);
        }
        // Typecast: TypeScript still believes that the caveat is a PlainObject.
        (_a = specification.validator) === null || _a === void 0 ? void 0 : _a.call(specification, caveat, origin, target);
    }
    /**
     * Initiates a permission request that requires user approval. This should
     * always be used to grant additional permissions to a subject, unless user
     * approval has been obtained through some other means.
     *
     * Permissions are validated at every step of the approval process, and this
     * method will reject if validation fails.
     *
     * @see {@link ApprovalController} For the user approval logic.
     * @see {@link PermissionController.acceptPermissionsRequest} For the method
     * that _accepts_ the request and resolves the user approval promise.
     * @see {@link PermissionController.rejectPermissionsRequest} For the method
     * that _rejects_ the request and the user approval promise.
     * @param subject - The grantee subject.
     * @param requestedPermissions - The requested permissions.
     * @param options - Additional options.
     * @param options.id - The id of the permissions request. Defaults to a unique
     * id.
     * @param options.preserveExistingPermissions - Whether to preserve the
     * subject's existing permissions. Defaults to `true`.
     * @returns The granted permissions and request metadata.
     */
    async requestPermissions(subject, requestedPermissions, options = {}) {
        const { origin } = subject;
        const { id = nanoid_1.nanoid(), preserveExistingPermissions = true } = options;
        this.validateRequestedPermissions(origin, requestedPermissions);
        const metadata = {
            id,
            origin,
        };
        const permissionsRequest = {
            metadata,
            permissions: requestedPermissions,
        };
        const _a = await this.requestUserApproval(permissionsRequest), { permissions: approvedPermissions } = _a, requestData = __rest(_a, ["permissions"]);
        return [
            this.grantPermissions({
                subject,
                approvedPermissions,
                preserveExistingPermissions,
                requestData,
            }),
            metadata,
        ];
    }
    /**
     * Validates requested permissions. Throws if validation fails.
     *
     * This method ensures that the requested permissions are a properly
     * formatted {@link RequestedPermissions} object, and performs the same
     * validation as {@link PermissionController.grantPermissions}, except that
     * consumer-specified permission validator functions are not called, since
     * they are only called on fully constructed, approved permissions that are
     * otherwise completely valid.
     *
     * Unrecognzied properties on requested permissions are ignored.
     *
     * @param origin - The origin of the grantee subject.
     * @param requestedPermissions - The requested permissions.
     */
    validateRequestedPermissions(origin, requestedPermissions) {
        if (!utils_1.isPlainObject(requestedPermissions)) {
            throw errors_1.invalidParams({
                message: `Requested permissions for origin "${origin}" is not a plain object.`,
                data: { origin, requestedPermissions },
            });
        }
        if (Object.keys(requestedPermissions).length === 0) {
            throw errors_1.invalidParams({
                message: `Permissions request for origin "${origin}" contains no permissions.`,
                data: { requestedPermissions },
            });
        }
        for (const targetName of Object.keys(requestedPermissions)) {
            const permission = requestedPermissions[targetName];
            const targetKey = this.getTargetKey(targetName);
            if (!targetKey) {
                throw errors_1.methodNotFound({
                    method: targetName,
                    data: { origin, requestedPermissions },
                });
            }
            if (!utils_1.isPlainObject(permission) ||
                (permission.parentCapability !== undefined &&
                    targetName !== permission.parentCapability)) {
                throw errors_1.invalidParams({
                    message: `Permissions request for origin "${origin}" contains invalid requested permission(s).`,
                    data: { origin, requestedPermissions },
                });
            }
            // Here we validate the permission without invoking its validator, if any.
            // The validator will be invoked after the permission has been approved.
            this.validatePermission(this.getPermissionSpecification(targetKey), 
            // Typecast: The permission is still a "PlainObject" here.
            permission, origin, targetName, { invokePermissionValidator: false, performCaveatValidation: true });
        }
    }
    /**
     * Adds a request to the {@link ApprovalController} using the
     * {@link AddApprovalRequest} action. Also validates the resulting approved
     * permissions request, and throws an error if validation fails.
     *
     * @param permissionsRequest - The permissions request object.
     * @returns The approved permissions request object.
     */
    async requestUserApproval(permissionsRequest) {
        const { origin, id } = permissionsRequest.metadata;
        const approvedRequest = await this.messagingSystem.call('ApprovalController:addRequest', {
            id,
            origin,
            requestData: permissionsRequest,
            type: utils_2.MethodNames.requestPermissions,
        }, true);
        this.validateApprovedPermissions(approvedRequest, { id, origin });
        return approvedRequest;
    }
    /**
     * Validates an approved {@link PermissionsRequest} object. The approved
     * request must have the required `metadata` and `permissions` properties,
     * the `id` and `origin` of the `metadata` must match the original request
     * metadata, and the requested permissions must be valid per
     * {@link PermissionController.validateRequestedPermissions}. Any extra
     * metadata properties are ignored.
     *
     * An error is thrown if validation fails.
     *
     * @param approvedRequest - The approved permissions request object.
     * @param originalMetadata - The original request metadata.
     */
    validateApprovedPermissions(approvedRequest, originalMetadata) {
        const { id, origin } = originalMetadata;
        if (!utils_1.isPlainObject(approvedRequest) ||
            !utils_1.isPlainObject(approvedRequest.metadata)) {
            throw errors_1.internalError(`Approved permissions request for subject "${origin}" is invalid.`, { data: { approvedRequest } });
        }
        const { metadata: { id: newId, origin: newOrigin }, permissions, } = approvedRequest;
        if (newId !== id) {
            throw errors_1.internalError(`Approved permissions request for subject "${origin}" mutated its id.`, { originalId: id, mutatedId: newId });
        }
        if (newOrigin !== origin) {
            throw errors_1.internalError(`Approved permissions request for subject "${origin}" mutated its origin.`, { originalOrigin: origin, mutatedOrigin: newOrigin });
        }
        try {
            this.validateRequestedPermissions(origin, permissions);
        }
        catch (error) {
            // Re-throw as an internal error; we should never receive invalid approved
            // permissions.
            throw errors_1.internalError(`Invalid approved permissions request: ${error.message}`, error.data);
        }
    }
    /**
     * Accepts a permissions request created by
     * {@link PermissionController.requestPermissions}.
     *
     * @param request - The permissions request.
     */
    async acceptPermissionsRequest(request) {
        const { id } = request.metadata;
        if (!this.hasApprovalRequest({ id })) {
            throw new errors_1.PermissionsRequestNotFoundError(id);
        }
        if (Object.keys(request.permissions).length === 0) {
            this._rejectPermissionsRequest(id, errors_1.invalidParams({
                message: 'Must request at least one permission.',
            }));
            return;
        }
        try {
            this.messagingSystem.call('ApprovalController:acceptRequest', id, request);
        }
        catch (error) {
            // If accepting unexpectedly fails, reject the request and re-throw the
            // error
            this._rejectPermissionsRequest(id, error);
            throw error;
        }
    }
    /**
     * Rejects a permissions request created by
     * {@link PermissionController.requestPermissions}.
     *
     * @param id - The id of the request to be rejected.
     */
    async rejectPermissionsRequest(id) {
        if (!this.hasApprovalRequest({ id })) {
            throw new errors_1.PermissionsRequestNotFoundError(id);
        }
        this._rejectPermissionsRequest(id, errors_1.userRejectedRequest());
    }
    /**
     * Checks whether the {@link ApprovalController} has a particular permissions
     * request.
     *
     * @see {@link PermissionController.acceptPermissionsRequest} and
     * {@link PermissionController.rejectPermissionsRequest} for usage.
     * @param options - The {@link HasApprovalRequest} options.
     * @param options.id - The id of the approval request to check for.
     * @returns Whether the specified request exists.
     */
    hasApprovalRequest(options) {
        return this.messagingSystem.call('ApprovalController:hasRequest', 
        // Typecast: For some reason, the type here expects all of the possible
        // HasApprovalRequest options to be specified, when they're actually all
        // optional. Passing just the id is definitely valid, so we just cast it.
        options);
    }
    /**
     * Rejects the permissions request with the specified id, with the specified
     * error as the reason. This method is effectively a wrapper around a
     * messenger call for the `ApprovalController:rejectRequest` action.
     *
     * @see {@link PermissionController.acceptPermissionsRequest} and
     * {@link PermissionController.rejectPermissionsRequest} for usage.
     * @param id - The id of the request to reject.
     * @param error - The error associated with the rejection.
     */
    _rejectPermissionsRequest(id, error) {
        return this.messagingSystem.call('ApprovalController:rejectRequest', id, error);
    }
    /**
     * Executes a restricted method as the subject with the given origin.
     * The specified params, if any, will be passed to the method implementation.
     *
     * **ATTN:** Great caution should be exercised in the use of this method.
     * Methods that cause side effects or affect application state should
     * be avoided.
     *
     * This method will first attempt to retrieve the requested restricted method
     * implementation, throwing if it does not exist. The method will then be
     * invoked as though the subject with the specified origin had invoked it with
     * the specified parameters. This means that any existing caveats will be
     * applied to the restricted method, and this method will throw if the
     * restricted method or its caveat decorators throw.
     *
     * In addition, this method will throw if the subject does not have a
     * permission for the specified restricted method.
     *
     * @param origin - The origin of the subject to execute the method on behalf
     * of.
     * @param targetName - The name of the method to execute. This must be a valid
     * permission target name.
     * @param params - The parameters to pass to the method implementation.
     * @returns The result of the executed method.
     */
    async executeRestrictedMethod(origin, targetName, params) {
        // Throws if the method does not exist
        const methodImplementation = this.getRestrictedMethod(targetName, origin);
        const result = await this._executeRestrictedMethod(methodImplementation, { origin }, targetName, params);
        if (result === undefined) {
            throw new Error(`Internal request for method "${targetName}" as origin "${origin}" returned no result.`);
        }
        return result;
    }
    /**
     * An internal method used in the controller's `json-rpc-engine` middleware
     * and {@link PermissionController.executeRestrictedMethod}. Calls the
     * specified restricted method implementation after decorating it with the
     * caveats of its permission. Throws if the subject does not have the
     * requisite permission.
     *
     * **ATTN:** Parameter validation is the responsibility of the caller, or
     * the restricted method implementation in the case of `params`.
     *
     * @see {@link PermissionController.executeRestrictedMethod} and
     * {@link PermissionController.createPermissionMiddleware} for usage.
     * @param methodImplementation - The implementation of the method to call.
     * @param subject - Metadata about the subject that made the request.
     * @param req - The request object associated with the request.
     * @returns
     */
    _executeRestrictedMethod(methodImplementation, subject, method, params = []) {
        const { origin } = subject;
        const permission = this.getPermission(origin, method);
        if (!permission) {
            throw errors_1.unauthorized({ data: { origin, method } });
        }
        return Caveat_1.decorateWithCaveats(methodImplementation, permission, this._caveatSpecifications)({ method, params, context: { origin } });
    }
}
exports.PermissionController = PermissionController;
//# sourceMappingURL=PermissionController.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/permissions/PermissionController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/utils.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/constants.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/utils.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidBase64StringKey = exports.isValidHexStringKey = exports.isValidBufferKey = exports.bufferToBase64String = exports.hexStringToBuffer = exports.base64StringToBuffer = exports.isValidHexString = exports.stripHexPrefix = exports.isHardened = exports.isValidBIP32Index = exports.validateBIP32Index = exports.getUnhardenedBIP32NodeToken = exports.getHardenedBIP32NodeToken = exports.getBIP44CoinTypeToAddressPathTuple = exports.getBIP44ChangePathString = exports.getBIP44CoinTypePathString = void 0;
const constants_1 = require("./constants");
/**
 * Gets a string representation of a BIP-44 path of depth 2, i.e.:
 * `m / 44' / coin_type'`
 *
 * For display purposes only.
 *
 * @param coin_type - The `coin_type` index to create a path visualization for.
 * @returns The visualization of the BIP-44 path for thte specified `coin_type`.
 */
function getBIP44CoinTypePathString(coin_type) {
    return `m / ${constants_1.BIP44PurposeNodeToken} / ${getUnhardenedBIP32NodeToken(coin_type)}'`;
}
exports.getBIP44CoinTypePathString = getBIP44CoinTypePathString;
/**
 * Gets a string representation of a BIP-44 path of depth 4, i.e.:
 * `m / 44' / coin_type' / account' / change`
 *
 * For display purposes only.
 *
 * @param coinTypePath - The parent `coin_type` path.
 * @param coin_type - The `change` index to create a path visualization for.
 * @returns The visualization of the BIP-44 path for the specified `coin_type`
 * and `change` indices.
 */
function getBIP44ChangePathString(coinTypePath, indices) {
    return `${coinTypePath} / ${getHardenedBIP32NodeToken(indices.account || 0)} / ${getUnhardenedBIP32NodeToken(indices.change || 0)}`;
}
exports.getBIP44ChangePathString = getBIP44ChangePathString;
/**
 * Gets a BIP-44 path tuple of the form `account' / change / address_index`,
 * which can be used to derive address keys together with a `coin_type` key.
 *
 * @param indices - The BIP-44 derivation index values.
 * @param indices.account - The `account` index value.
 * @param indices.change - The `change` index value.
 * @param indices.address_index - The `address_index` index value.
 * @returns The `account' / change / address_index` path corresponding to the
 * specified indices.
 */
function getBIP44CoinTypeToAddressPathTuple({ account = 0, change = 0, address_index, }) {
    return [
        getHardenedBIP32NodeToken(account),
        getUnhardenedBIP32NodeToken(change),
        getUnhardenedBIP32NodeToken(address_index),
    ];
}
exports.getBIP44CoinTypeToAddressPathTuple = getBIP44CoinTypeToAddressPathTuple;
/**
 * A hardened BIP-32 node token, e.g. `bip32:0'`.
 * Validates that the index is a non-negative integer number, and throws an
 * error if validation fails.
 *
 * @param index - The index of the node.
 * @returns The hardened BIP-32 node token.
 */
function getHardenedBIP32NodeToken(index) {
    validateBIP32Index(index);
    return `${getUnhardenedBIP32NodeToken(index)}'`;
}
exports.getHardenedBIP32NodeToken = getHardenedBIP32NodeToken;
/**
 * An unhardened BIP-32 node token, e.g. `bip32:0`.
 * Validates that the index is a non-negative integer number, and throws an
 * error if validation fails.
 *
 * @param index - The index of the node.
 * @returns The unhardened BIP-32 node token.
 */
function getUnhardenedBIP32NodeToken(index) {
    validateBIP32Index(index);
    return `bip32:${index}`;
}
exports.getUnhardenedBIP32NodeToken = getUnhardenedBIP32NodeToken;
/**
 * Validates that the index is a non-negative integer number. Throws an
 * error if validation fails.
 *
 * @param addressIndex - The index to validate.
 */
function validateBIP32Index(addressIndex) {
    if (!isValidBIP32Index(addressIndex)) {
        throw new Error(`Invalid BIP-32 index: Must be a non-negative integer.`);
    }
}
exports.validateBIP32Index = validateBIP32Index;
/**
 * @param index - The BIP-32 index to test.
 * @returns Whether the index is a non-negative integer number.
 */
function isValidBIP32Index(index) {
    return Number.isInteger(index) && index >= 0;
}
exports.isValidBIP32Index = isValidBIP32Index;
/**
 * @param bip32Token - The token to test.
 * @returns Whether the token is hardened, i.e. ends with `'`.
 */
function isHardened(bip32Token) {
    return bip32Token.endsWith(`'`);
}
exports.isHardened = isHardened;
/**
 * @param hexString - The hexadecimal string to strip.
 * @returns The hexadecimal string, without a `0x`-prefix, if any.
 */
function stripHexPrefix(hexString) {
    return hexString.replace(/^0x/iu, '');
}
exports.stripHexPrefix = stripHexPrefix;
/**
 * Tests whether the specified string is a valid hexadecimal string. The string
 * may or may not be `0x`-prefixed, and the test is case-insensitive.
 *
 * @param hexString - The string to test.
 * @returns Whether the specified string is a valid hexadecimal string. The
 * string may or may not be `0x`-prefixed.
 */
function isValidHexString(hexString) {
    return /^(?:0x)?[a-f0-9]+$/iu.test(hexString);
}
exports.isValidHexString = isValidHexString;
/**
 * @param base64String - The Base64 string to convert.
 * @returns The {@link Buffer} corresponding to the Base64 string.
 */
function base64StringToBuffer(base64String) {
    return Buffer.from(base64String, 'base64');
}
exports.base64StringToBuffer = base64StringToBuffer;
/**
 * @param hexString - The hexadecimal string to convert.
 * @returns The {@link Buffer} corresponding to the hexadecimal string.
 */
function hexStringToBuffer(hexString) {
    return Buffer.from(stripHexPrefix(hexString), 'hex');
}
exports.hexStringToBuffer = hexStringToBuffer;
/**
 * @param input - The {@link Buffer} to convert.
 * @returns The buffer as a Base64 string.
 */
function bufferToBase64String(input) {
    return input.toString('base64');
}
exports.bufferToBase64String = bufferToBase64String;
/**
 * Tests whether the specified {@link Buffer} is a valid BIP-32 key.
 * A valid buffer key is 64 bytes long and has at least one non-zero byte.
 *
 * @param buffer - The {@link Buffer} to test.
 * @returns Whether the buffer represents a valid BIP-32 key.
 */
function isValidBufferKey(buffer) {
    if (buffer.length !== constants_1.BUFFER_KEY_LENGTH) {
        return false;
    }
    for (const byte of buffer) {
        if (byte !== 0) {
            return true;
        }
    }
    return false;
}
exports.isValidBufferKey = isValidBufferKey;
/**
 * @param input - The string to test.
 * @returns Whether the given string is a valid Base64 string.
 */
function isValidBase64String(input) {
    return constants_1.BASE_64_REGEX.test(input);
}
/**
 * Tests whether the specified hexadecimal string is a valid BIP-32 key.
 * A valid hexadecimal string key is 128 characters long (excluding any `0x`
 * prefix) and has at least one non-zero byte.
 *
 * @param stringKey - The hexadecimal string to test.
 * @returns Whether the string represents a valid BIP-32 key.
 */
function isValidHexStringKey(stringKey) {
    if (!isValidHexString(stringKey)) {
        return false;
    }
    const stripped = stripHexPrefix(stringKey);
    if (stripped.length !== constants_1.HEXADECIMAL_KEY_LENGTH) {
        return false;
    }
    if (/^0+$/iu.test(stripped)) {
        return false;
    }
    return true;
}
exports.isValidHexStringKey = isValidHexStringKey;
/**
 * Tests whether the specified Base64 string is a valid BIP-32 key.
 * A valid Base64 string key is 88 characters long and has at least one non-zero
 * byte.
 *
 * @param stringKey - The Base64 string to test.
 * @returns Whether the string represents a valid BIP-32 key.
 */
function isValidBase64StringKey(stringKey) {
    if (!isValidBase64String(stringKey)) {
        return false;
    }
    if (stringKey.length !== constants_1.BASE_64_KEY_LENGTH) {
        return false;
    }
    if (stringKey === constants_1.BASE_64_ZERO) {
        return false;
    }
    return true;
}
exports.isValidBase64StringKey = isValidBase64StringKey;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/key-tree",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/derivation.js", {"../../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/constants.js","./derivers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/derivers/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/derivation.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validatePathSegment = exports.deriveKeyFromPath = void 0;
const constants_1 = require("./constants");
const derivers_1 = require("./derivers");
/**
 * ethereum default seed path: "m/44'/60'/0'/0/{account_index}"
 * multipath: "bip32:44'/bip32:60'/bip32:0'/bip32:0/bip32:{account_index}"
 *
 * m: { privateKey, chainCode } = sha512Hmac("Bitcoin seed", masterSeed)
 * 44': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])
 * 60': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])
 * 0': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])
 * 0: { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [parentKey.publicKey, index])
 * 0: { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [parentKey.publicKey, index])
 */
/**
 * Takes a full or partial HD path string and returns the key corresponding to
 * the given path, with the following constraints:
 *
 * - If the path starts with a BIP-32 node, a parent key must be provided.
 * - If the path starts with a BIP-39 node, a parent key must NOT be provided.
 * - The path cannot exceed 5 BIP-32 nodes in length, optionally preceded by
 *   a single BIP-39 node.
 *
 * WARNING: It is the consumer's responsibility to ensure that the path is valid
 * relative to its parent key.
 *
 * @param pathSegment - A full or partial HD path, e.g.:
 * bip39:SEED_PHRASE/bip32:44'/bip32:60'/bip32:0'/bip32:0/bip32:0
 *
 * BIP-39 seed phrases must be lowercase, space-delimited, and 12-24 words long.
 * @param parentKey - The parent key of the given path segment, if any.
 * @returns The derived key.
 */
function deriveKeyFromPath(pathSegment, parentKey, depth) {
    if (parentKey && !Buffer.isBuffer(parentKey)) {
        throw new Error('Parent key must be a Buffer if specified.');
    }
    validatePathSegment(pathSegment, Boolean(parentKey), depth);
    let key = parentKey;
    // derive through each part of path
    pathSegment.forEach((node) => {
        const [pathType, pathValue] = node.split(':');
        /* istanbul ignore if: should be impossible */
        if (!hasDeriver(pathType)) {
            throw new Error(`Unknown derivation type: "${pathType}"`);
        }
        const deriver = derivers_1.derivers[pathType];
        const childKey = deriver.deriveChildKey(pathValue, key);
        // continue deriving from child key
        key = childKey;
    });
    return key;
}
exports.deriveKeyFromPath = deriveKeyFromPath;
/**
 * @param pathType
 */
function hasDeriver(pathType) {
    return pathType in derivers_1.derivers;
}
/**
 * The path segment must be one of the following:
 * - A lone BIP-32 path node
 * - A lone BIP-39 path node
 * - A multipath
 *
 * @param pathSegment - The path segment string to validate.
 */
function validatePathSegment(pathSegment, hasKey, depth) {
    if (pathSegment.length === 0) {
        throw new Error(`Invalid HD path segment: The segment must not be empty.`);
    }
    if (pathSegment.length - 1 > constants_1.MAX_BIP_44_DEPTH) {
        throw new Error(`Invalid HD path segment: The segment cannot exceed a 0-indexed depth of 5.`);
    }
    let startsWithBip39 = false;
    pathSegment.forEach((node, index) => {
        if (index === 0) {
            startsWithBip39 = constants_1.BIP_39_PATH_REGEX.test(node);
            if (!startsWithBip39 && !constants_1.BIP_32_PATH_REGEX.test(node)) {
                throw getMalformedError();
            }
        }
        else if (!constants_1.BIP_32_PATH_REGEX.test(node)) {
            throw getMalformedError();
        }
    });
    if (depth === constants_1.MIN_BIP_44_DEPTH &&
        (!startsWithBip39 || pathSegment.length !== 1)) {
        throw new Error(`Invalid HD path segment: The segment must consist of a single BIP-39 node for depths of ${constants_1.MIN_BIP_44_DEPTH}. Received: "${pathSegment}"`);
    }
    if (!hasKey && !startsWithBip39) {
        throw new Error('Invalid derivation parameters: Must specify parent key if the first node of the path segment is not a BIP-39 node.');
    }
    if (hasKey && startsWithBip39) {
        throw new Error('Invalid derivation parameters: May not specify parent key if the path segment starts with a BIP-39 node.');
    }
}
exports.validatePathSegment = validatePathSegment;
function getMalformedError() {
    throw new Error('Invalid HD path segment: The path segment is malformed.');
}

}).call(this)}).call(this,{"isBuffer":require("../../../is-buffer/index.js")})

      };
    };
  }
}, {package:"@metamask/key-tree",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/derivation.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-abi/lib/utils/index.js", {"bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/bn.js/lib/bn.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","js-sha3":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/js-sha3/src/sha3.js","number-to-bn":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/number-to-bn/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-abi/lib/utils/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var BN = require('bn.js');
var numberToBN = require('number-to-bn');
var keccak256 = require('js-sha3').keccak_256;

// from ethereumjs-util
function stripZeros(aInput) {
  var a = aInput; // eslint-disable-line
  var first = a[0]; // eslint-disable-line
  while (a.length > 0 && first.toString() === '0') {
    a = a.slice(1);
    first = a[0];
  }
  return a;
}

function bnToBuffer(bnInput) {
  var bn = bnInput; // eslint-disable-line
  var hex = bn.toString(16); // eslint-disable-line
  if (hex.length % 2) {
    hex = '0' + hex;
  }
  return stripZeros(new Buffer(hex, 'hex'));
}

function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}

function hexOrBuffer(valueInput, name) {
  var value = valueInput; // eslint-disable-line
  if (!Buffer.isBuffer(value)) {
    if (!isHexString(value)) {
      var error = new Error(name ? '[ethjs-abi] invalid ' + name : '[ethjs-abi] invalid hex or buffer, must be a prefixed alphanumeric even length hex string');
      error.reason = '[ethjs-abi] invalid hex string, hex must be prefixed and alphanumeric (e.g. 0x023..)';
      error.value = value;
      throw error;
    }

    value = value.substring(2);
    if (value.length % 2) {
      value = '0' + value;
    }
    value = new Buffer(value, 'hex');
  }

  return value;
}

function hexlify(value) {
  if (typeof value === 'number') {
    return '0x' + bnToBuffer(new BN(value)).toString('hex');
  } else if (value.mod || value.modulo) {
    return '0x' + bnToBuffer(value).toString('hex');
  } else {
    // eslint-disable-line
    return '0x' + hexOrBuffer(value).toString('hex');
  }
}

// getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
function getKeys(params, key, allowEmpty) {
  var result = []; // eslint-disable-line

  if (!Array.isArray(params)) {
    throw new Error('[ethjs-abi] while getting keys, invalid params value ' + JSON.stringify(params));
  }

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('[ethjs-abi] while getKeys found invalid ABI data structure, type value not string');
    }
    result.push(value);
  }

  return result;
}

function coderNumber(size, signed) {
  return {
    encode: function encodeNumber(valueInput) {
      var value = valueInput; // eslint-disable-line

      if (typeof value === 'object' && value.toString && (value.toTwos || value.dividedToIntegerBy)) {
        value = value.toString(10).split('.')[0];
      }

      if (typeof value === 'string' || typeof value === 'number') {
        value = String(value).split('.')[0];
      }

      value = numberToBN(value);
      value = value.toTwos(size * 8).maskn(size * 8);
      if (signed) {
        value = value.fromTwos(size * 8).toTwos(256);
      }
      return value.toArrayLike(Buffer, 'be', 32);
    },
    decode: function decodeNumber(data, offset) {
      var junkLength = 32 - size; // eslint-disable-line
      var value = new BN(data.slice(offset + junkLength, offset + 32)); // eslint-disable-line
      if (signed) {
        value = value.fromTwos(size * 8);
      } else {
        value = value.maskn(size * 8);
      }
      return {
        consumed: 32,
        value: new BN(value.toString(10))
      };
    }
  };
}
var uint256Coder = coderNumber(32, false);

var coderBoolean = {
  encode: function encodeBoolean(value) {
    return uint256Coder.encode(value ? 1 : 0);
  },
  decode: function decodeBoolean(data, offset) {
    var result = uint256Coder.decode(data, offset); // eslint-disable-line
    return {
      consumed: result.consumed,
      value: !result.value.isZero()
    };
  }
};

function coderFixedBytes(length) {
  return {
    encode: function encodeFixedBytes(valueInput) {
      var value = valueInput; // eslint-disable-line
      value = hexOrBuffer(value);

      if (value.length === 32) {
        return value;
      }

      var result = new Buffer(32); // eslint-disable-line
      result.fill(0);
      value.copy(result);
      return result;
    },
    decode: function decodeFixedBytes(data, offset) {
      if (data.length !== 0 && data.length < offset + 32) {
        throw new Error('[ethjs-abi] while decoding fixed bytes, invalid bytes data length: ' + length);
      }

      return {
        consumed: 32,
        value: '0x' + data.slice(offset, offset + length).toString('hex')
      };
    }
  };
}

var coderAddress = {
  encode: function encodeAddress(valueInput) {
    var value = valueInput; // eslint-disable-line
    var result = new Buffer(32); // eslint-disable-line
    if (!isHexString(value, 20)) {
      throw new Error('[ethjs-abi] while encoding address, invalid address value, not alphanumeric 20 byte hex string');
    }
    value = hexOrBuffer(value);
    result.fill(0);
    value.copy(result, 12);
    return result;
  },
  decode: function decodeAddress(data, offset) {
    if (data.length === 0) {
      return {
        consumed: 32,
        value: '0x'
      };
    }
    if (data.length !== 0 && data.length < offset + 32) {
      throw new Error('[ethjs-abi] while decoding address data, invalid address data, invalid byte length ' + data.length);
    }
    return {
      consumed: 32,
      value: '0x' + data.slice(offset + 12, offset + 32).toString('hex')
    };
  }
};

function encodeDynamicBytesHelper(value) {
  var dataLength = parseInt(32 * Math.ceil(value.length / 32)); // eslint-disable-line
  var padding = new Buffer(dataLength - value.length); // eslint-disable-line
  padding.fill(0);

  return Buffer.concat([uint256Coder.encode(value.length), value, padding]);
}

function decodeDynamicBytesHelper(data, offset) {
  if (data.length !== 0 && data.length < offset + 32) {
    throw new Error('[ethjs-abi] while decoding dynamic bytes data, invalid bytes length: ' + data.length + ' should be less than ' + (offset + 32));
  }

  var length = uint256Coder.decode(data, offset).value; // eslint-disable-line
  length = length.toNumber();
  if (data.length !== 0 && data.length < offset + 32 + length) {
    throw new Error('[ethjs-abi] while decoding dynamic bytes data, invalid bytes length: ' + data.length + ' should be less than ' + (offset + 32 + length));
  }

  return {
    consumed: parseInt(32 + 32 * Math.ceil(length / 32), 10),
    value: data.slice(offset + 32, offset + 32 + length)
  };
}

var coderDynamicBytes = {
  encode: function encodeDynamicBytes(value) {
    return encodeDynamicBytesHelper(hexOrBuffer(value));
  },
  decode: function decodeDynamicBytes(data, offset) {
    var result = decodeDynamicBytesHelper(data, offset); // eslint-disable-line
    result.value = '0x' + result.value.toString('hex');
    return result;
  },
  dynamic: true
};

var coderString = {
  encode: function encodeString(value) {
    return encodeDynamicBytesHelper(new Buffer(value, 'utf8'));
  },
  decode: function decodeString(data, offset) {
    var result = decodeDynamicBytesHelper(data, offset); // eslint-disable-line
    result.value = result.value.toString('utf8');
    return result;
  },
  dynamic: true
};

function coderArray(coder, lengthInput) {
  return {
    encode: function encodeArray(value) {
      var result = new Buffer(0); // eslint-disable-line
      var length = lengthInput; // eslint-disable-line

      if (!Array.isArray(value)) {
        throw new Error('[ethjs-abi] while encoding array, invalid array data, not type Object (Array)');
      }

      if (length === -1) {
        length = value.length;
        result = uint256Coder.encode(length);
      }

      if (length !== value.length) {
        throw new Error('[ethjs-abi] while encoding array, size mismatch array length ' + length + ' does not equal ' + value.length);
      }

      value.forEach(function (resultValue) {
        result = Buffer.concat([result, coder.encode(resultValue)]);
      });

      return result;
    },
    decode: function decodeArray(data, offsetInput) {
      var length = lengthInput; // eslint-disable-line
      var offset = offsetInput; // eslint-disable-line
      // @TODO:
      // if (data.length < offset + length * 32) { throw new Error('invalid array'); }

      var consumed = 0; // eslint-disable-line
      var decodeResult; // eslint-disable-line

      if (length === -1) {
        decodeResult = uint256Coder.decode(data, offset);
        length = decodeResult.value.toNumber();
        consumed += decodeResult.consumed;
        offset += decodeResult.consumed;
      }

      var value = []; // eslint-disable-line

      for (var i = 0; i < length; i++) {
        // eslint-disable-line
        var loopResult = coder.decode(data, offset);
        consumed += loopResult.consumed;
        offset += loopResult.consumed;
        value.push(loopResult.value);
      }

      return {
        consumed: consumed,
        value: value
      };
    },
    dynamic: lengthInput === -1
  };
}

// Break the type up into [staticType][staticArray]*[dynamicArray]? | [dynamicType] and
// build the coder up from its parts
var paramTypePart = new RegExp(/^((u?int|bytes)([0-9]*)|(address|bool|string)|(\[([0-9]*)\]))/);

function getParamCoder(typeInput) {
  var type = typeInput; // eslint-disable-line
  var coder = null; // eslint-disable-line
  var invalidTypeErrorMessage = '[ethjs-abi] while getting param coder (getParamCoder) type value ' + JSON.stringify(type) + ' is either invalid or unsupported by ethjs-abi.';

  while (type) {
    var part = type.match(paramTypePart); // eslint-disable-line
    if (!part) {
      throw new Error(invalidTypeErrorMessage);
    }
    type = type.substring(part[0].length);

    var prefix = part[2] || part[4] || part[5]; // eslint-disable-line
    switch (prefix) {
      case 'int':case 'uint':
        if (coder) {
          throw new Error(invalidTypeErrorMessage);
        }
        var intSize = parseInt(part[3] || 256); // eslint-disable-line
        if (intSize === 0 || intSize > 256 || intSize % 8 !== 0) {
          throw new Error('[ethjs-abi] while getting param coder for type ' + type + ', invalid ' + prefix + '<N> width: ' + type);
        }

        coder = coderNumber(intSize / 8, prefix === 'int');
        break;

      case 'bool':
        if (coder) {
          throw new Error(invalidTypeErrorMessage);
        }
        coder = coderBoolean;
        break;

      case 'string':
        if (coder) {
          throw new Error(invalidTypeErrorMessage);
        }
        coder = coderString;
        break;

      case 'bytes':
        if (coder) {
          throw new Error(invalidTypeErrorMessage);
        }
        if (part[3]) {
          var size = parseInt(part[3]); // eslint-disable-line
          if (size === 0 || size > 32) {
            throw new Error('[ethjs-abi] while getting param coder for prefix bytes, invalid type ' + type + ', size ' + size + ' should be 0 or greater than 32');
          }
          coder = coderFixedBytes(size);
        } else {
          coder = coderDynamicBytes;
        }
        break;

      case 'address':
        if (coder) {
          throw new Error(invalidTypeErrorMessage);
        }
        coder = coderAddress;
        break;

      case '[]':
        if (!coder || coder.dynamic) {
          throw new Error(invalidTypeErrorMessage);
        }
        coder = coderArray(coder, -1);
        break;

      // "[0-9+]"
      default:
        if (!coder || coder.dynamic) {
          throw new Error(invalidTypeErrorMessage);
        }
        var defaultSize = parseInt(part[6]); // eslint-disable-line
        coder = coderArray(coder, defaultSize);
    }
  }

  if (!coder) {
    throw new Error(invalidTypeErrorMessage);
  }
  return coder;
}

module.exports = {
  BN: BN,
  bnToBuffer: bnToBuffer,
  isHexString: isHexString,
  hexOrBuffer: hexOrBuffer,
  hexlify: hexlify,
  stripZeros: stripZeros,

  keccak256: keccak256,

  getKeys: getKeys,
  numberToBN: numberToBN,
  coderNumber: coderNumber,
  uint256Coder: uint256Coder,
  coderBoolean: coderBoolean,
  coderFixedBytes: coderFixedBytes,
  coderAddress: coderAddress,
  coderDynamicBytes: coderDynamicBytes,
  coderString: coderString,
  coderArray: coderArray,
  paramTypePart: paramTypePart,
  getParamCoder: getParamCoder
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethjs-abi",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-abi/lib/utils/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/node_modules/ethjs-util/lib/index.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","is-hex-prefixed":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-hex-prefixed/src/index.js","strip-hex-prefix":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/strip-hex-prefix/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/node_modules/ethjs-util/lib/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + padToEven(hex);
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return Buffer.from(hex.slice(2), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/node_modules/ethjs-util/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/node_modules/ethjs-abi/lib/index.js", {"./utils/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/node_modules/ethjs-abi/lib/utils/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/node_modules/ethjs-abi/lib/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

/* eslint-disable */

var utils = require('./utils/index.js');
var uint256Coder = utils.uint256Coder;
var coderBoolean = utils.coderBoolean;
var coderFixedBytes = utils.coderFixedBytes;
var coderAddress = utils.coderAddress;
var coderDynamicBytes = utils.coderDynamicBytes;
var coderString = utils.coderString;
var coderArray = utils.coderArray;
var paramTypePart = utils.paramTypePart;
var getParamCoder = utils.getParamCoder;

function Result() {}

function encodeParams(types, values) {
  if (types.length !== values.length) {
    throw new Error('[ethjs-abi] while encoding params, types/values mismatch, Your contract requires ' + types.length + ' types (arguments), and you passed in ' + values.length);
  }

  var parts = [];

  types.forEach(function (type, index) {
    var coder = getParamCoder(type);
    parts.push({ dynamic: coder.dynamic, value: coder.encode(values[index]) });
  });

  function alignSize(size) {
    return parseInt(32 * Math.ceil(size / 32));
  }

  var staticSize = 0,
      dynamicSize = 0;
  parts.forEach(function (part) {
    if (part.dynamic) {
      staticSize += 32;
      dynamicSize += alignSize(part.value.length);
    } else {
      staticSize += alignSize(part.value.length);
    }
  });

  var offset = 0,
      dynamicOffset = staticSize;
  var data = new Buffer(staticSize + dynamicSize);

  parts.forEach(function (part, index) {
    if (part.dynamic) {
      uint256Coder.encode(dynamicOffset).copy(data, offset);
      offset += 32;

      part.value.copy(data, dynamicOffset);
      dynamicOffset += alignSize(part.value.length);
    } else {
      part.value.copy(data, offset);
      offset += alignSize(part.value.length);
    }
  });

  return '0x' + data.toString('hex');
}

// decode bytecode data from output names and types
function decodeParams(names, types, data) {
  var useNumberedParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  // Names is optional, so shift over all the parameters if not provided
  if (arguments.length < 3) {
    data = types;
    types = names;
    names = [];
  }

  data = utils.hexOrBuffer(data);
  var values = new Result();

  var offset = 0;
  types.forEach(function (type, index) {
    var coder = getParamCoder(type);
    if (coder.dynamic) {
      var dynamicOffset = uint256Coder.decode(data, offset);
      var result = coder.decode(data, dynamicOffset.value.toNumber());
      offset += dynamicOffset.consumed;
    } else {
      var result = coder.decode(data, offset);
      offset += result.consumed;
    }
    if (useNumberedParams) values[index] = result.value;
    if (names[index]) {
      values[names[index]] = result.value;
    }
  });
  return values;
}

// encode method ABI object with values in an array, output bytecode
function encodeMethod(method, values) {
  var signature = method.name + '(' + utils.getKeys(method.inputs, 'type').join(',') + ')';
  var signatureEncoded = '0x' + new Buffer(utils.keccak256(signature), 'hex').slice(0, 4).toString('hex');
  var paramsEncoded = encodeParams(utils.getKeys(method.inputs, 'type'), values).substring(2);

  return '' + signatureEncoded + paramsEncoded;
}

// decode method data bytecode, from method ABI object
function decodeMethod(method, data) {
  var outputNames = utils.getKeys(method.outputs, 'name', true);
  var outputTypes = utils.getKeys(method.outputs, 'type');

  return decodeParams(outputNames, outputTypes, utils.hexOrBuffer(data));
}

// decode method data bytecode, from method ABI object
function encodeEvent(eventObject, values) {
  return encodeMethod(eventObject, values);
}

function eventSignature(eventObject) {
  var signature = eventObject.name + '(' + utils.getKeys(eventObject.inputs, 'type').join(',') + ')';
  return '0x' + utils.keccak256(signature);
}

// decode method data bytecode, from method ABI object
function decodeEvent(eventObject, data, topics) {
  var useNumberedParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  var nonIndexed = eventObject.inputs.filter(function (input) {
    return !input.indexed;
  });
  var nonIndexedNames = utils.getKeys(nonIndexed, 'name', true);
  var nonIndexedTypes = utils.getKeys(nonIndexed, 'type');
  var event = decodeParams(nonIndexedNames, nonIndexedTypes, utils.hexOrBuffer(data), useNumberedParams);
  var topicOffset = eventObject.anonymous ? 0 : 1;
  eventObject.inputs.filter(function (input) {
    return input.indexed;
  }).map(function (input, i) {
    var topic = new Buffer(topics[i + topicOffset].slice(2), 'hex');
    var coder = getParamCoder(input.type);
    event[input.name] = coder.decode(topic, 0).value;
  });
  event._eventName = eventObject.name;
  return event;
}

// Decode a specific log item with a specific event abi
function decodeLogItem(eventObject, log) {
  var useNumberedParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  if (eventObject && log.topics[0] === eventSignature(eventObject)) {
    return decodeEvent(eventObject, log.data, log.topics, useNumberedParams);
  }
}

// Create a decoder for all events defined in an abi. It returns a function which is called
// on an array of log entries such as received from getLogs or getTransactionReceipt and parses
// any matching log entries
function logDecoder(abi) {
  var useNumberedParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  var eventMap = {};
  abi.filter(function (item) {
    return item.type === 'event';
  }).map(function (item) {
    eventMap[eventSignature(item)] = item;
  });
  return function (logItems) {
    return logItems.map(function (log) {
      return decodeLogItem(eventMap[log.topics[0]], log, useNumberedParams);
    }).filter(function (i) {
      return i;
    });
  };
}

module.exports = {
  encodeParams: encodeParams,
  decodeParams: decodeParams,
  encodeMethod: encodeMethod,
  decodeMethod: decodeMethod,
  encodeEvent: encodeEvent,
  decodeEvent: decodeEvent,
  decodeLogItem: decodeLogItem,
  logDecoder: logDecoder,
  eventSignature: eventSignature
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethjs-abi",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/node_modules/ethjs-abi/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/lib/has-tx-object.js", {"babel-runtime/core-js/object/keys":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/babel-runtime/core-js/object/keys.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/lib/has-tx-object.js
      return function (require, module, exports) {
'use strict';

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var txObjectProperties = ['from', 'to', 'data', 'value', 'gasPrice', 'gas'];

module.exports = hasTransactionObject;

function hasTransactionObject(args) {
  // bad/empty args: bad
  if (!Array.isArray(args) || args.length === 0) {
    return false;
  }
  var lastArg = args[args.length - 1];
  // missing or non-object: bad
  if (!lastArg) return false;
  if (typeof lastArg !== 'object') {
    return false;
  }
  // empty object: good
  if ((0, _keys2['default'])(lastArg).length === 0) {
    return true;
  }
  // txParams object: good
  var keys = (0, _keys2['default'])(lastArg);
  var hasMatchingKeys = txObjectProperties.some(function (value) {
    return keys.includes(value);
  });
  if (hasMatchingKeys) {
    return true;
  }
  // no match
  return false;
}
      };
    };
  }
}, {package:"ethjs-contract",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/lib/has-tx-object.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/lib/contract.js", {"./has-tx-object":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/lib/has-tx-object.js","babel-runtime/core-js/json/stringify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/babel-runtime/core-js/json/stringify.js","babel-runtime/core-js/object/assign":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/babel-runtime/core-js/object/assign.js","babel-runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/babel-runtime/helpers/asyncToGenerator.js","babel-runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/babel-runtime/regenerator/index.js","ethjs-abi":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/node_modules/ethjs-abi/lib/index.js","ethjs-filter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethjs-filter/lib/index.js","ethjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/node_modules/ethjs-util/lib/index.js","js-sha3":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/js-sha3/src/sha3.js","promise-to-callback":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promise-to-callback/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/lib/contract.js
      return function (require, module, exports) {
'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var abi = require('ethjs-abi'); // eslint-disable-line
var EthFilter = require('ethjs-filter'); // eslint-disable-line
var getKeys = require('ethjs-util').getKeys; // eslint-disable-line
var keccak256 = require('js-sha3').keccak_256; // eslint-disable-line
var hasTransactionObject = require('./has-tx-object');
var promiseToCallback = require('promise-to-callback');

module.exports = Contract;

function Contract() {
  var performCall = function () {
    var _ref2 = (0, _asyncToGenerator3['default'])( /*#__PURE__*/_regenerator2['default'].mark(function _callee(_ref) {
      var methodObject = _ref.methodObject,
          methodArgs = _ref.methodArgs;
      var queryMethod, providedTxObject, methodTxObject, queryResult, decodedMethodResult, decodingError;
      return _regenerator2['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              queryMethod = 'call'; // eslint-disable-line

              providedTxObject = {}; // eslint-disable-line

              if (hasTransactionObject(methodArgs)) providedTxObject = methodArgs.pop();
              methodTxObject = (0, _assign2['default'])({}, self.defaultTxObject, providedTxObject, {
                to: self.address
              });

              methodTxObject.data = abi.encodeMethod(methodObject, methodArgs);

              if (methodObject.constant === false) {
                queryMethod = 'sendTransaction';
              }

              _context.next = 8;
              return self.query[queryMethod](methodTxObject);

            case 8:
              queryResult = _context.sent;

              if (!(queryMethod === 'call')) {
                _context.next = 19;
                break;
              }

              _context.prev = 10;
              decodedMethodResult = abi.decodeMethod(methodObject, queryResult);
              return _context.abrupt('return', decodedMethodResult);

            case 15:
              _context.prev = 15;
              _context.t0 = _context['catch'](10);
              decodingError = new Error('[ethjs-contract] while formatting incoming raw call data ' + (0, _stringify2['default'])(queryResult) + ' ' + _context.t0);
              throw decodingError;

            case 19:
              return _context.abrupt('return', queryResult);

            case 20:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this, [[10, 15]]);
    }));

    return function performCall(_x2) {
      return _ref2.apply(this, arguments);
    };
  }();

  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var self = this;
  self.abi = opts.contractABI || [];
  self.query = opts.query;
  self.address = opts.address || '0x';
  self.bytecode = opts.contractBytecode || '0x';
  self.defaultTxObject = opts.contractDefaultTxObject || {};
  self.filters = new EthFilter(self.query);

  getCallableMethodsFromABI(self.abi).forEach(function (methodObject) {
    if (methodObject.type === 'function') {
      self[methodObject.name] = createContractFunction(methodObject);
    } else if (methodObject.type === 'event') {
      self[methodObject.name] = createContractEvent(methodObject);
    }
  });

  function createContractEvent(methodObject) {
    return function contractEvent() {
      var methodArgs = [].slice.call(arguments); // eslint-disable-line

      var filterInputTypes = getKeys(methodObject.inputs, 'type', false);
      var filterTopic = '0x' + keccak256(methodObject.name + '(' + filterInputTypes.join(',') + ')');
      var filterTopcis = [filterTopic];
      var argsObject = (0, _assign2['default'])({}, methodArgs[0]) || {};

      var defaultFilterObject = (0, _assign2['default'])({}, methodArgs[0] || {}, {
        to: self.address,
        topics: filterTopcis
      });
      var filterOpts = (0, _assign2['default'])({}, argsObject, {
        decoder: function decoder(logData) {
          return abi.decodeEvent(methodObject, logData, filterTopcis);
        },
        defaultFilterObject: defaultFilterObject
      });

      return new self.filters.Filter(filterOpts);
    };
  }

  function createContractFunction(methodObject) {
    return function contractFunction() {
      var methodCallback = void 0; // eslint-disable-line
      var methodArgs = [].slice.call(arguments); // eslint-disable-line
      if (typeof methodArgs[methodArgs.length - 1] === 'function') {
        methodCallback = methodArgs.pop();
      }

      var promise = performCall({ methodObject: methodObject, methodArgs: methodArgs });

      if (methodCallback) {
        return promiseToCallback(promise)(methodCallback);
      }

      return promise;
    };
  }
}

function getCallableMethodsFromABI(contractABI) {
  return contractABI.filter(function (json) {
    return (json.type === 'function' || json.type === 'event') && json.name.length > 0;
  });
}
      };
    };
  }
}, {package:"ethjs-contract",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-contract/lib/contract.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js", {"events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js
      return function (require, module, exports) {
module.exports = require('events').EventEmitter;

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/internal/streams/destroy.js", {"process-nextick-args":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process-nextick-args/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/internal/streams/destroy.js
      return function (require, module, exports) {
'use strict';

/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      processNextTick(emitErrorNT, this, err);
    }
    return;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      processNextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/internal/streams/destroy.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/safe-buffer/index.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/safe-buffer/index.js
      return function (require, module, exports) {
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

      };
    };
  }
}, {package:"safe-buffer",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/safe-buffer/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/process-nextick-args/index.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/process-nextick-args/index.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"process-nextick-args",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process-nextick-args/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/internal/streams/BufferList.js", {"safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/safe-buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/internal/streams/BufferList.js
      return function (require, module, exports) {
'use strict';

/*<replacement>*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/readable-stream/lib/internal/streams/BufferList.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/string_decoder/lib/string_decoder.js", {"safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/safe-buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/string_decoder/lib/string_decoder.js
      return function (require, module, exports) {
'use strict';

var Buffer = require('safe-buffer').Buffer;

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return -1;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// UTF-8 replacement characters ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd'.repeat(p);
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd'.repeat(p + 1);
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd'.repeat(p + 2);
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character for each buffered byte of a (partial)
// character needs to be added to the output.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd'.repeat(this.lastTotal - this.lastNeed);
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
      };
    };
  }
}, {package:"string_decoder",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/node_modules/string_decoder/lib/string_decoder.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/errno/custom.js", {"prr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/prr/prr.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/errno/custom.js
      return function (require, module, exports) {
var prr = require('prr')

function init (type, message, cause) {
  if (!!message && typeof message != 'string') {
    message = message.message || message.name
  }
  prr(this, {
      type    : type
    , name    : type
      // can be passed just a 'cause'
    , cause   : typeof message != 'string' ? message : cause
    , message : message
  }, 'ewr')
}

// generic prototype, not intended to be actually used - helpful for `instanceof`
function CustomError (message, cause) {
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, this.constructor)
  init.call(this, 'CustomError', message, cause)
}

CustomError.prototype = new Error()

function createError (errno, type, proto) {
  var err = function (message, cause) {
    init.call(this, type, message, cause)
    //TODO: the specificity here is stupid, errno should be available everywhere
    if (type == 'FilesystemError') {
      this.code    = this.cause.code
      this.path    = this.cause.path
      this.errno   = this.cause.errno
      this.message =
        (errno.errno[this.cause.errno]
          ? errno.errno[this.cause.errno].description
          : this.cause.message)
        + (this.cause.path ? ' [' + this.cause.path + ']' : '')
    }
    Error.call(this)
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, err)
  }
  err.prototype = !!proto ? new proto() : new CustomError()
  return err
}

module.exports = function (errno) {
  var ce = function (type, proto) {
    return createError(errno, type, proto)
  }
  return {
      CustomError     : CustomError
    , FilesystemError : ce('FilesystemError')
    , createError     : ce
  }
}

      };
    };
  }
}, {package:"errno",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/errno/custom.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/end-of-stream.js", {"../../../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/errors-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
      return function (require, module, exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/end-of-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/pipeline.js", {"../../../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/errors-browser.js","./end-of-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/pipeline.js
      return function (require, module, exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/pipeline.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_duplex.js", {"./_stream_readable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_writable.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_duplex.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_duplex.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_passthrough.js", {"./_stream_transform":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_transform.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_passthrough.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_passthrough.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_writable.js", {"../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_duplex.js","./internal/streams/destroy":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/state":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/state.js","./internal/streams/stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/stream-browser.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","util-deprecate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/util-deprecate/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_writable.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_writable.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_transform.js", {"../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_duplex.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_transform.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_transform.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_readable.js", {"../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_duplex.js","./internal/streams/async_iterator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/async_iterator.js","./internal/streams/buffer_list":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/buffer_list.js","./internal/streams/destroy":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/from":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/from-browser.js","./internal/streams/state":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/state.js","./internal/streams/stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/internal/streams/stream-browser.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","string_decoder/":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/string_decoder/lib/string_decoder.js","util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_readable.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/readable-stream/lib/_stream_readable.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/DoublyLinkedList.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/DoublyLinkedList.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = DLL;
// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation
// used for queues. This implementation assumes that the node provided by the user can be modified
// to adjust the next and last properties. We implement only the minimal functionality
// for queue support.
function DLL() {
    this.head = this.tail = null;
    this.length = 0;
}

function setInitial(dll, node) {
    dll.length = 1;
    dll.head = dll.tail = node;
}

DLL.prototype.removeLink = function (node) {
    if (node.prev) node.prev.next = node.next;else this.head = node.next;
    if (node.next) node.next.prev = node.prev;else this.tail = node.prev;

    node.prev = node.next = null;
    this.length -= 1;
    return node;
};

DLL.prototype.empty = function () {
    while (this.head) this.shift();
    return this;
};

DLL.prototype.insertAfter = function (node, newNode) {
    newNode.prev = node;
    newNode.next = node.next;
    if (node.next) node.next.prev = newNode;else this.tail = newNode;
    node.next = newNode;
    this.length += 1;
};

DLL.prototype.insertBefore = function (node, newNode) {
    newNode.prev = node.prev;
    newNode.next = node;
    if (node.prev) node.prev.next = newNode;else this.head = newNode;
    node.prev = newNode;
    this.length += 1;
};

DLL.prototype.unshift = function (node) {
    if (this.head) this.insertBefore(this.head, node);else setInitial(this, node);
};

DLL.prototype.push = function (node) {
    if (this.tail) this.insertAfter(this.tail, node);else setInitial(this, node);
};

DLL.prototype.shift = function () {
    return this.head && this.removeLink(this.head);
};

DLL.prototype.pop = function () {
    return this.tail && this.removeLink(this.tail);
};

DLL.prototype.toArray = function () {
    var arr = Array(this.length);
    var curr = this.head;
    for (var idx = 0; idx < this.length; idx++) {
        arr[idx] = curr.data;
        curr = curr.next;
    }
    return arr;
};

DLL.prototype.remove = function (testFn) {
    var curr = this.head;
    while (!!curr) {
        var next = curr.next;
        if (testFn(curr)) {
            this.removeLink(curr);
        }
        curr = next;
    }
    return this;
};
module.exports = exports["default"];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/DoublyLinkedList.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/shard-readme.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/shard-readme.js
      return function (require, module, exports) {
/* @flow */
'use strict'

module.exports = `This is a repository of IPLD objects. Each IPLD object is in a single file,
named <base32 encoding of cid>.data. Where <base32 encoding of cid> is the
"base32" encoding of the CID (as specified in
https://github.com/multiformats/multibase) without the 'B' prefix.
All the object files are placed in a tree of directories, based on a
function of the CID. This is a form of sharding similar to
the objects directory in git repositories. Previously, we used
prefixes, we now use the next-to-last two charters.
    func NextToLast(base32cid string) {
      nextToLastLen := 2
      offset := len(base32cid) - nextToLastLen - 1
      return str[offset : offset+nextToLastLen]
    }
For example, an object with a base58 CIDv1 of
    zb2rhYSxw4ZjuzgCnWSt19Q94ERaeFhu9uSqRgjSdx9bsgM6f
has a base32 CIDv1 of
    BAFKREIA22FLID5AJ2KU7URG47MDLROZIH6YF2KALU2PWEFPVI37YLKRSCA
and will be placed at
    SC/AFKREIA22FLID5AJ2KU7URG47MDLROZIH6YF2KALU2PWEFPVI37YLKRSCA.data
with 'SC' being the last-to-next two characters and the 'B' at the
beginning of the CIDv1 string is the multibase prefix that is not
stored in the filename.
`

      };
    };
  }
}, {package:"datastore-core",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-core/src/shard-readme.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-many/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-many/index.js
      return function (require, module, exports) {


/*
all pull streams have these states:

{
  START: {
    read: READING,
    abort: ABORTING
  },
  READY: {
    read: READING,
    abort: ABORTING
  },
  READING: {
    cb: READY,
    err: ERROR,
    end: END
  },
  ABORTING: {
    cb: END
  },
  ERROR: {},
  END: {}
}

this module takes a collection of pull-streams,
and interleaves their states.
if all the streams have ended, it ends.
If it is in reading state, and one stream goes has READING->cb
it goes into READY

on read, trigger read on every stream in START or READY

on abort, trigger abort on all streams immediately***

if a stream is in READY, and big stream is in ABORT,
trigger abort

if every stream is in END or ERROR, trigger end or error

could you describe this declaritively or something?
*/

module.exports = function (ary) {

  var capped = !!ary
  var inputs = (ary || []).map(create), i = 0, abort, cb

  function create (stream) {
    return {ready: false, reading: false, ended: false, read: stream, data: null}
  }

  function check () {
    if(!cb) return
    clean()
    var l = inputs.length
    var _cb = cb
    if(l === 0 && (abort || capped)) {
      cb = null; _cb(abort ||  true)
      return
    }

    //scan the inputs to check whether there is one we can use.
    for(var j = 0; j < l; j++) {
      var current = inputs[(i + j) % l]
      if(current.ready && !current.ended) {
        var data = current.data
        current.ready = false
        current.data = null
        i ++; cb = null
        return _cb(null, data)
      }
    }
  }

  function clean () {
    var l = inputs.length
    //iterate backwards so that we can remove items.
    while(l--) {
      if(inputs[l].ended)
        inputs.splice(l, 1)
    }
  }

  function next () {
    var l = inputs.length
    while(l--)
      (function (current) {
        //read the next item if we aren't already
        if(l > inputs.length) throw new Error('this should never happen')
        if(current.reading || current.ended || current.ready) return
        current.reading = true
        var sync = true
        current.read(abort, function next (end, data) {
          current.data = data
          current.ready = true
          current.reading = false

          if(end === true || abort) current.ended = true
          else if(end) abort = current.ended = end
          //check whether we need to abort this stream.
          if(abort && !end) current.read(abort, next)
          if(!sync) check()
        })
        sync = false
      })(inputs[l])

    //scan the feed
    check()
  }

  function read (_abort, _cb) {
    abort = abort || _abort; cb = _cb; next()
  }

  read.add = function (stream) {
    if(!stream) {
      //the stream will now end when all the streams end.
      capped = true
      //we just changed state, so we may need to cb
      return next()
    }
    inputs.push(create(stream))
    next()
  }

  read.cap = function (err) {
    read.add(null)
  }

  return read
}


      };
    };
  }
}, {package:"pull-many",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-many/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/filter.js", {"./wrapAsync":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/wrapAsync.js","lodash/_arrayMap":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/_arrayMap.js","lodash/_baseProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/_baseProperty.js","lodash/isArrayLike":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/isArrayLike.js","lodash/noop":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/noop.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/filter.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = _filter;

var _arrayMap = require('lodash/_arrayMap');

var _arrayMap2 = _interopRequireDefault(_arrayMap);

var _isArrayLike = require('lodash/isArrayLike');

var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

var _baseProperty = require('lodash/_baseProperty');

var _baseProperty2 = _interopRequireDefault(_baseProperty);

var _noop = require('lodash/noop');

var _noop2 = _interopRequireDefault(_noop);

var _wrapAsync = require('./wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function filterArray(eachfn, arr, iteratee, callback) {
    var truthValues = new Array(arr.length);
    eachfn(arr, function (x, index, callback) {
        iteratee(x, function (err, v) {
            truthValues[index] = !!v;
            callback(err);
        });
    }, function (err) {
        if (err) return callback(err);
        var results = [];
        for (var i = 0; i < arr.length; i++) {
            if (truthValues[i]) results.push(arr[i]);
        }
        callback(null, results);
    });
}

function filterGeneric(eachfn, coll, iteratee, callback) {
    var results = [];
    eachfn(coll, function (x, index, callback) {
        iteratee(x, function (err, v) {
            if (err) {
                callback(err);
            } else {
                if (v) {
                    results.push({ index: index, value: x });
                }
                callback();
            }
        });
    }, function (err) {
        if (err) {
            callback(err);
        } else {
            callback(null, (0, _arrayMap2.default)(results.sort(function (a, b) {
                return a.index - b.index;
            }), (0, _baseProperty2.default)('value')));
        }
    });
}

function _filter(eachfn, coll, iteratee, callback) {
    var filter = (0, _isArrayLike2.default)(coll) ? filterArray : filterGeneric;
    filter(eachfn, coll, (0, _wrapAsync2.default)(iteratee), callback || _noop2.default);
}
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/filter.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-codec/index.js", {"./lib/encodings":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-codec/lib/encodings.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/level-codec/index.js
      return function (require, module, exports) {
var encodings = require('./lib/encodings')

module.exports = Codec

function Codec (opts) {
  if (!(this instanceof Codec)) {
    return new Codec(opts)
  }
  this.opts = opts || {}
  this.encodings = encodings
}

Codec.prototype._encoding = function (encoding) {
  if (typeof encoding === 'string') encoding = encodings[encoding]
  if (!encoding) encoding = encodings.id
  return encoding
}

Codec.prototype._keyEncoding = function (opts, batchOpts) {
  return this._encoding((batchOpts && batchOpts.keyEncoding) ||
                        (opts && opts.keyEncoding) ||
                        this.opts.keyEncoding)
}

Codec.prototype._valueEncoding = function (opts, batchOpts) {
  return this._encoding((batchOpts && (batchOpts.valueEncoding || batchOpts.encoding)) ||
                        (opts && (opts.valueEncoding || opts.encoding)) ||
                        (this.opts.valueEncoding || this.opts.encoding))
}

Codec.prototype.encodeKey = function (key, opts, batchOpts) {
  return this._keyEncoding(opts, batchOpts).encode(key)
}

Codec.prototype.encodeValue = function (value, opts, batchOpts) {
  return this._valueEncoding(opts, batchOpts).encode(value)
}

Codec.prototype.decodeKey = function (key, opts) {
  return this._keyEncoding(opts).decode(key)
}

Codec.prototype.decodeValue = function (value, opts) {
  return this._valueEncoding(opts).decode(value)
}

Codec.prototype.encodeBatch = function (ops, opts) {
  var self = this

  return ops.map(function (_op) {
    var op = {
      type: _op.type,
      key: self.encodeKey(_op.key, opts, _op)
    }
    if (self.keyAsBuffer(opts, _op)) op.keyEncoding = 'binary'
    if (_op.prefix) op.prefix = _op.prefix
    if ('value' in _op) {
      op.value = self.encodeValue(_op.value, opts, _op)
      if (self.valueAsBuffer(opts, _op)) op.valueEncoding = 'binary'
    }
    return op
  })
}

var ltgtKeys = ['lt', 'gt', 'lte', 'gte', 'start', 'end']

Codec.prototype.encodeLtgt = function (ltgt) {
  var self = this
  var ret = {}
  Object.keys(ltgt).forEach(function (key) {
    ret[key] = ltgtKeys.indexOf(key) > -1
      ? self.encodeKey(ltgt[key], ltgt)
      : ltgt[key]
  })
  return ret
}

Codec.prototype.createStreamDecoder = function (opts) {
  var self = this

  if (opts.keys && opts.values) {
    return function (key, value) {
      return {
        key: self.decodeKey(key, opts),
        value: self.decodeValue(value, opts)
      }
    }
  } else if (opts.keys) {
    return function (key) {
      return self.decodeKey(key, opts)
    }
  } else if (opts.values) {
    return function (_, value) {
      return self.decodeValue(value, opts)
    }
  } else {
    return function () {}
  }
}

Codec.prototype.keyAsBuffer = function (opts) {
  return this._keyEncoding(opts).buffer
}

Codec.prototype.valueAsBuffer = function (opts) {
  return this._valueEncoding(opts).buffer
}

      };
    };
  }
}, {package:"level-codec",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-codec/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/iterator.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","abstract-leveldown":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","idb-readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/idb-readable-stream/index.js","ltgt":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ltgt/index.js","stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/stream-browserify/index.js","util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/util/util.js","xtend":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/xtend/immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/iterator.js
      return function (require, module, exports) {
(function (process,Buffer){(function (){
var util = require('util')
var AbstractIterator  = require('abstract-leveldown').AbstractIterator
var ltgt = require('ltgt')
var idbReadableStream = require('idb-readable-stream')
var stream = require('stream')
var xtend = require('xtend')

var Writable = stream.Writable

module.exports = Iterator

/**
 * Open IndexedDB cursor.
 *
 * @param {Object} db  db instance
 * @param {Object} [options]  options
 *
 * options:
 *   snapshot {Boolean}  Whether to use snapshot mode, that may lead to memory
 *     spikes, or use back pressure, that can't guarantee the same snapshot. This
 *     option is true by default.
 */
function Iterator(db, options) {
  this._db = db._db
  this._idbOpts = db._idbOpts

  AbstractIterator.call(this, db)

  this._options = xtend({
    snapshot: true
  }, this._idbOpts, options)

  this._limit = this._options.limit
  if (this._limit == null || this._limit === -1) {
    this._limit = Infinity
  }
  if (typeof this._limit !== 'number') throw new TypeError('options.limit must be a number')
  if (this._limit === 0) return // skip further processing and wait for first call to _next

  this._count = 0

  this._startCursor(this._options)
}

util.inherits(Iterator, AbstractIterator)

Iterator.prototype._startCursor = function(options) {
  options = xtend(this._options, options)

  var self = this

  var keyRange = null
  var lower = ltgt.lowerBound(options)
  var upper = ltgt.upperBound(options)
  var lowerOpen = ltgt.lowerBoundExclusive(options)
  var upperOpen = ltgt.upperBoundExclusive(options)

  var direction = options.reverse ? 'prev': 'next'

  // support binary keys for any iterable type via array (ArrayBuffers as keys are only supported in IndexedDB Second Edition)
  if (lower)
    if (options.keyEncoding === 'binary' && !Array.isArray(lower)) lower = Array.prototype.slice.call(lower)
  if (upper)
    if (options.keyEncoding === 'binary' && !Array.isArray(upper)) upper = Array.prototype.slice.call(upper)

  if (lower && upper)
    try {
      keyRange = IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen)
    } catch (err) {
      // skip the iterator and return 0 results if IDBKeyRange throws a DataError (if keys overlap)
      this._keyRangeError = true
      return
    }
  else if (lower)
    keyRange = IDBKeyRange.lowerBound(lower, lowerOpen)
  else if (upper)
    keyRange = IDBKeyRange.upperBound(upper, upperOpen)

  this._reader = idbReadableStream(this._db, this._idbOpts.storeName, xtend(options, { range: keyRange, direction: direction }))

  this._reader.on('error', function(err) {
    var cb = self._callback
    self._callback = false

    if (cb)
      cb(err)
    else // else wait for _next
      self._readNext = function(cb) {
        cb(err)
      }
  })

  this._reader.pipe(new Writable({
    objectMode: true,
    write: function(item, enc, cb) {
      if (self._count++ >= self._limit) { // limit reached, finish
        self._reader.pause()
        self._reader.unpipe(this)
        cb()
        this.end()
        return
      }

      var cb2 = self._callback
      self._callback = false

      if (cb2)
        self._processItem(item, function(err, key, value) {
          cb(err) // proceed with next item
          cb2(err, key, value)
        })
      else // else wait for _next
        self._readNext = function(cb2) {
          self._processItem(item, function(err, key, value) {
            cb(err) // proceed with next item
            cb2(err, key, value)
          })
        }

    }
  })).on('finish', function() {
    var cb = self._callback
    self._callback = false

    if (cb)
      cb()
    else // else wait for _next
      self._readNext = function(cb) {
        cb()
      }
  })
}

Iterator.prototype._processItem = function(item, cb) {
  if (typeof cb !== 'function') throw new TypeError('cb must be a function')

  var key = item.key
  var value = item.value

  // automatically convert Uint8Array values to Buffer
  if (value instanceof Uint8Array) value = new Buffer(value)
  if (this._options.keyEncoding === 'binary' && Array.isArray(key)) key = new Buffer(key)
  if (this._options.valueEncoding === 'binary' && !Buffer.isBuffer(value)) value = new Buffer(value)

  if (this._options.keyAsBuffer && !Buffer.isBuffer(key)) {
    if (key == null)                     key = new Buffer(0)
    else if (typeof key === 'string')    key = new Buffer(key) // defaults to utf8, should the encoding be utf16? (DOMString)
    else if (typeof key === 'boolean')   key = new Buffer(String(key)) // compatible with leveldb
    else if (typeof key === 'number')    key = new Buffer(String(key)) // compatible with leveldb
    else if (Array.isArray(key))         key = new Buffer(String(key)) // compatible with leveldb
    else if (key instanceof Uint8Array)  key = new Buffer(key)
    else throw new TypeError('can\'t coerce `' + key.constructor.name + '` into a Buffer')
  }

  if (this._options.valueAsBuffer && !Buffer.isBuffer(value)) {
    if (value == null)                     value = new Buffer(0)
    else if (typeof value === 'string')    value = new Buffer(value) // defaults to utf8, should the encoding be utf16? (DOMString)
    else if (typeof value === 'boolean')   value = new Buffer(String(value)) // compatible with leveldb
    else if (typeof value === 'number')    value = new Buffer(String(value)) // compatible with leveldb
    else if (Array.isArray(value))         value = new Buffer(String(value)) // compatible with leveldb
    else if (value instanceof Uint8Array)  value = new Buffer(value)
    else throw new TypeError('can\'t coerce `' + value.constructor.name + '` into a Buffer')
  }

  cb(null, key, value)
}

// register a callback, only call it directly if a nextHandler is registered
Iterator.prototype._next = function(callback) {
  if (this._callback) throw new Error('callback already exists') // each callback should be invoked exactly once
  if (this._keyRangeError || this._limit === 0) return void callback()

  var readNext = this._readNext
  this._readNext = false

  if (readNext) {
    process.nextTick(function() {
      readNext(callback)
    })
  } else {
    this._callback = callback
  }
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

      };
    };
  }
}, {package:"level-js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/iterator.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/index.js", {"./abstract-chained-batch":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/abstract-chained-batch.js","./abstract-iterator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/abstract-iterator.js","./abstract-leveldown":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/abstract-leveldown.js","./is-leveldown":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/is-leveldown.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/index.js
      return function (require, module, exports) {
exports.AbstractLevelDOWN    = require('./abstract-leveldown')
exports.AbstractIterator     = require('./abstract-iterator')
exports.AbstractChainedBatch = require('./abstract-chained-batch')
exports.isLevelDOWN          = require('./is-leveldown')

      };
    };
  }
}, {package:"abstract-leveldown",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-js/node_modules/abstract-leveldown/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/levelup/lib/common.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/levelup/lib/common.js
      return function (require, module, exports) {
exports.getCallback = function (options, callback) {
  return typeof options === 'function' ? options : callback
}

exports.getOptions = function (options) {
  return typeof options === 'object' && options !== null ? options : {}
}

      };
    };
  }
}, {package:"levelup",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/levelup/lib/common.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/levelup/lib/promisify.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/levelup/lib/promisify.js
      return function (require, module, exports) {
function promisify () {
  var callback
  var promise = new Promise(function (resolve, reject) {
    callback = function callback (err, value) {
      if (err) reject(err)
      else resolve(value)
    }
  })
  callback.promise = promise
  return callback
}

module.exports = promisify

      };
    };
  }
}, {package:"levelup",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/levelup/lib/promisify.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/levelup/lib/batch.js", {"./common":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/levelup/lib/common.js","./promisify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/levelup/lib/promisify.js","level-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-errors/errors.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/levelup/lib/batch.js
      return function (require, module, exports) {
var WriteError = require('level-errors').WriteError
var promisify = require('./promisify')
var getCallback = require('./common').getCallback
var getOptions = require('./common').getOptions

function Batch (levelup) {
  this._levelup = levelup
  this.batch = levelup.db.batch()
  this.ops = []
  this.length = 0
}

Batch.prototype.put = function (key, value) {
  try {
    this.batch.put(key, value)
  } catch (e) {
    throw new WriteError(e)
  }

  this.ops.push({ type: 'put', key: key, value: value })
  this.length++

  return this
}

Batch.prototype.del = function (key) {
  try {
    this.batch.del(key)
  } catch (err) {
    throw new WriteError(err)
  }

  this.ops.push({ type: 'del', key: key })
  this.length++

  return this
}

Batch.prototype.clear = function () {
  try {
    this.batch.clear()
  } catch (err) {
    throw new WriteError(err)
  }

  this.ops = []
  this.length = 0

  return this
}

Batch.prototype.write = function (options, callback) {
  var levelup = this._levelup
  var ops = this.ops
  var promise

  callback = getCallback(options, callback)

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  options = getOptions(options)

  try {
    this.batch.write(options, function (err) {
      if (err) { return callback(new WriteError(err)) }
      levelup.emit('batch', ops)
      callback()
    })
  } catch (err) {
    throw new WriteError(err)
  }

  return promise
}

module.exports = Batch

      };
    };
  }
}, {package:"levelup",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/levelup/lib/batch.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/deferred-leveldown/deferred-leveldown.js", {"./deferred-iterator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/deferred-leveldown/deferred-iterator.js","abstract-leveldown":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/index.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/deferred-leveldown/deferred-leveldown.js
      return function (require, module, exports) {
var AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN
var inherits = require('inherits')
var DeferredIterator = require('./deferred-iterator')
var deferrables = 'put get del batch'.split(' ')

function DeferredLevelDOWN (db) {
  AbstractLevelDOWN.call(this, '')
  this._db = db
  this._operations = []
  this._iterators = []
  closed(this)
}

inherits(DeferredLevelDOWN, AbstractLevelDOWN)

DeferredLevelDOWN.prototype._open = function (options, callback) {
  var self = this

  this._db.open(options, function (err) {
    if (err) return callback(err)

    self._operations.forEach(function (op) {
      self._db[op.method].apply(self._db, op.args)
    })
    self._operations = []
    self._iterators.forEach(function (it) {
      it.setDb(self._db)
    })
    self._iterators = []
    open(self)
    callback()
  })
}

DeferredLevelDOWN.prototype._close = function (callback) {
  var self = this

  this._db.close(function (err) {
    if (err) return callback(err)
    closed(self)
    callback()
  })
}

function open (self) {
  deferrables.concat('iterator').forEach(function (m) {
    self['_' + m] = function () {
      return this._db[m].apply(this._db, arguments)
    }
  })
  if (self._db.approximateSize) {
    self.approximateSize = function () {
      return this._db.approximateSize.apply(this._db, arguments)
    }
  }
}

function closed (self) {
  deferrables.forEach(function (m) {
    self['_' + m] = function () {
      this._operations.push({ method: m, args: arguments })
    }
  })
  if (typeof self._db.approximateSize === 'function') {
    self.approximateSize = function () {
      this._operations.push({
        method: 'approximateSize',
        args: arguments
      })
    }
  }
  self._iterator = function (options) {
    var it = new DeferredIterator(options)
    this._iterators.push(it)
    return it
  }
}

DeferredLevelDOWN.prototype._serializeKey = function (key) {
  return key
}

DeferredLevelDOWN.prototype._serializeValue = function (value) {
  return value
}

module.exports = DeferredLevelDOWN
module.exports.DeferredIterator = DeferredIterator

      };
    };
  }
}, {package:"deferred-leveldown",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/deferred-leveldown/deferred-leveldown.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-iterator-stream/index.js", {"inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/readable-stream/readable-browser.js","xtend":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/xtend/immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-iterator-stream/index.js
      return function (require, module, exports) {
var inherits = require('inherits')
var Readable = require('readable-stream').Readable
var extend = require('xtend')

module.exports = ReadStream
inherits(ReadStream, Readable)

function ReadStream (iterator, options) {
  if (!(this instanceof ReadStream)) return new ReadStream(iterator, options)
  options = options || {}
  Readable.call(this, extend(options, {
    objectMode: true
  }))
  this._iterator = iterator
  this._options = options
  this.on('end', this.destroy.bind(this, null, null))
}

ReadStream.prototype._read = function () {
  var self = this
  var options = this._options
  if (this.destroyed) return

  this._iterator.next(function (err, key, value) {
    if (self.destroyed) return
    if (err) return self.destroy(err)

    if (key === undefined && value === undefined) {
      self.push(null)
    } else if (options.keys !== false && options.values === false) {
      self.push(key)
    } else if (options.keys === false && options.values !== false) {
      self.push(value)
    } else {
      self.push({ key: key, value: value })
    }
  })
}

ReadStream.prototype._destroy = function (err, callback) {
  this._iterator.end(function (err2) {
    callback(err || err2)
  })
}

      };
    };
  }
}, {package:"level-iterator-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-level/node_modules/level-iterator-stream/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/utils.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/utils.js
      return function (require, module, exports) {
(function (process,Buffer){(function (){
'use strict'

exports.toCallback = (doWork) => {
  return function (input, callback) {
    let res
    try {
      res = doWork(input)
    } catch (err) {
      process.nextTick(callback, err)
      return
    }

    process.nextTick(callback, null, res)
  }
}

exports.toBuf = (doWork, other) => (input) => {
  let result = doWork(input, other)
  return Buffer.from(result, 'hex')
}

exports.fromString = (doWork, other) => (_input) => {
  const input = Buffer.isBuffer(_input) ? _input.toString() : _input
  return doWork(input, other)
}

exports.fromNumberTo32BitBuf = (doWork, other) => (input) => {
  let number = doWork(input, other)
  const bytes = new Array(4)

  for (let i = 0; i < 4; i++) {
    bytes[i] = number & 0xff
    number = number >> 8
  }

  return Buffer.from(bytes)
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/crypto-sha1-2-browser.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","nodeify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/nodeify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/crypto-sha1-2-browser.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/* global self */

'use strict'

const nodeify = require('nodeify')

const webCrypto = getWebCrypto()

function getWebCrypto () {
  if (self.crypto) {
    return self.crypto.subtle || self.crypto.webkitSubtle
  }

  if (self.msCrypto) {
    return self.msCrypto.subtle
  }
}

function webCryptoHash (type) {
  if (!webCrypto) {
    throw new Error('Please use a browser with webcrypto support and ensure the code has been delivered securely via HTTPS/TLS and run within a Secure Context')
  }

  return (data, callback) => {
    const res = webCrypto.digest({ name: type }, data)

    if (typeof res.then !== 'function') { // IE11
      res.onerror = () => {
        callback(new Error(`hashing data using ${type}`))
      }
      res.oncomplete = (e) => {
        callback(null, e.target.result)
      }
      return
    }

    nodeify(
      res.then((raw) => Buffer.from(new Uint8Array(raw))),
      callback
    )
  }
}

function sha1 (buf, callback) {
  webCryptoHash('SHA-1')(buf, callback)
}

function sha2256 (buf, callback) {
  webCryptoHash('SHA-256')(buf, callback)
}

function sha2512 (buf, callback) {
  webCryptoHash('SHA-512')(buf, callback)
}

module.exports = {
  sha1: sha1,
  sha2256: sha2256,
  sha2512: sha2512
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/crypto-sha1-2-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/blake.js", {"./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/utils.js","blakejs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/blake.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const blake = require('blakejs')

const toCallback = require('./utils').toCallback

const minB = 0xb201
const minS = 0xb241

const blake2b = {
  init: blake.blake2bInit,
  update: blake.blake2bUpdate,
  digest: blake.blake2bFinal
}

const blake2s = {
  init: blake.blake2sInit,
  update: blake.blake2sUpdate,
  digest: blake.blake2sFinal
}

const makeB2Hash = (size, hf) => toCallback((buf) => {
  const ctx = hf.init(size, null)
  hf.update(ctx, buf)
  return Buffer.from(hf.digest(ctx))
})

module.exports = (table) => {
  for (let i = 0; i < 64; i++) {
    table[minB + i] = makeB2Hash(i + 1, blake2b)
  }
  for (let i = 0; i < 32; i++) {
    table[minS + i] = makeB2Hash(i + 1, blake2s)
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/multihashing-async/src/blake.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/protocol-buffers-schema/tokenize.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/protocol-buffers-schema/tokenize.js
      return function (require, module, exports) {
module.exports = function (sch) {
  var noComments = function (line) {
    var i = line.indexOf('//')
    return i > -1 ? line.slice(0, i) : line
  }

  var noMultilineComments = function () {
    var inside = false
    return function (token) {
      if (token === '/*') {
        inside = true
        return false
      }
      if (token === '*/') {
        inside = false
        return false
      }
      return !inside
    }
  }

  var trim = function (line) {
    return line.trim()
  }

  return sch
    .replace(/([;,{}()=:[\]<>]|\/\*|\*\/)/g, ' $1 ')
    .split(/\n/)
    .map(trim)
    .filter(Boolean)
    .map(noComments)
    .map(trim)
    .filter(Boolean)
    .join('\n')
    .split(/\s+|\n+/gm)
    .filter(noMultilineComments())
}

      };
    };
  }
}, {package:"protocol-buffers-schema",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protocol-buffers-schema/tokenize.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/utils.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/utils.js
      return function (require, module, exports) {
'use strict'

exports.defined = function (val) {
  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))
}

      };
    };
  }
}, {package:"protons",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/compile/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/signed-varint/index.js", {"varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/signed-varint/index.js
      return function (require, module, exports) {
var varint = require('varint')
exports.encode = function encode (v, b, o) {
  v = v >= 0 ? v*2 : v*-2 - 1
  var r = varint.encode(v, b, o)
  encode.bytes = varint.encode.bytes
  return r
}
exports.decode = function decode (b, o) {
  var v = varint.decode(b, o)
  decode.bytes = varint.decode.bytes
  return v & 1 ? (v+1) / -2 : v / 2
}

exports.encodingLength = function (v) {
  return varint.encodingLength(v >= 0 ? v*2 : v*-2 - 1)
}

      };
    };
  }
}, {package:"signed-varint",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/signed-varint/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/constants/index.js", {"./der":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/constants/der.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/constants/index.js
      return function (require, module, exports) {
'use strict';

const constants = exports;

// Helper
constants._reverse = function reverse(map) {
  const res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    const value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = require('./der');

      };
    };
  }
}, {package:"asn1.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/constants/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/api.js", {"./decoders":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/decoders/index.js","./encoders":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/encoders/index.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/api.js
      return function (require, module, exports) {
'use strict';

const encoders = require('./encoders');
const decoders = require('./decoders');
const inherits = require('inherits');

const api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
}

Entity.prototype._createNamed = function createNamed(Base) {
  const name = this.name;

  function Generated(entity) {
    this._initNamed(entity, name);
  }
  inherits(Generated, Base);
  Generated.prototype._initNamed = function _initNamed(entity, name) {
    Base.call(this, entity, name);
  };

  return new Generated(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der';
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der';
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};

      };
    };
  }
}, {package:"asn1.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/api.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/index.js", {"./buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/buffer.js","./node":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/node.js","./reporter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/reporter.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/index.js
      return function (require, module, exports) {
'use strict';

const base = exports;

base.Reporter = require('./reporter').Reporter;
base.DecoderBuffer = require('./buffer').DecoderBuffer;
base.EncoderBuffer = require('./buffer').EncoderBuffer;
base.Node = require('./node');

      };
    };
  }
}, {package:"asn1.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/base/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/encoders/index.js", {"./der":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/encoders/der.js","./pem":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/encoders/pem.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/encoders/index.js
      return function (require, module, exports) {
'use strict';

const encoders = exports;

encoders.der = require('./der');
encoders.pem = require('./pem');

      };
    };
  }
}, {package:"asn1.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/encoders/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/decoders/index.js", {"./der":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/decoders/der.js","./pem":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/decoders/pem.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/decoders/index.js
      return function (require, module, exports) {
'use strict';

const decoders = exports;

decoders.der = require('./der');
decoders.pem = require('./pem');

      };
    };
  }
}, {package:"asn1.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/asn1.js/lib/asn1/decoders/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/utils.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/utils.js
      return function (require, module, exports) {
(function (process,Buffer){(function (){
'use strict'

exports.toCallback = (doWork) => {
  return function (input, callback) {
    let res
    try {
      res = doWork(input)
    } catch (err) {
      process.nextTick(callback, err)
      return
    }

    process.nextTick(callback, null, res)
  }
}

exports.toBuf = (doWork, other) => (input) => {
  let result = doWork(input, other)
  return Buffer.from(result, 'hex')
}

exports.fromString = (doWork, other) => (_input) => {
  const input = Buffer.isBuffer(_input) ? _input.toString() : _input
  return doWork(input, other)
}

exports.fromNumberTo32BitBuf = (doWork, other) => (input) => {
  let number = doWork(input, other)
  const bytes = new Array(4)

  for (let i = 0; i < 4; i++) {
    bytes[i] = number & 0xff
    number = number >> 8
  }

  return Buffer.from(bytes)
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/crypto-sha1-2-browser.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","nodeify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/nodeify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/crypto-sha1-2-browser.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/* global self */

'use strict'

const nodeify = require('nodeify')

const webCrypto = getWebCrypto()

function getWebCrypto () {
  if (self.crypto) {
    return self.crypto.subtle || self.crypto.webkitSubtle
  }

  if (self.msCrypto) {
    return self.msCrypto.subtle
  }
}

function webCryptoHash (type) {
  if (!webCrypto) {
    throw new Error('Please use a browser with webcrypto support and ensure the code has been delivered securely via HTTPS/TLS and run within a Secure Context')
  }

  return (data, callback) => {
    const res = webCrypto.digest({ name: type }, data)

    if (typeof res.then !== 'function') { // IE11
      res.onerror = () => {
        callback(new Error(`hashing data using ${type}`))
      }
      res.oncomplete = (e) => {
        callback(null, e.target.result)
      }
      return
    }

    nodeify(
      res.then((raw) => Buffer.from(new Uint8Array(raw))),
      callback
    )
  }
}

function sha1 (buf, callback) {
  webCryptoHash('SHA-1')(buf, callback)
}

function sha2256 (buf, callback) {
  webCryptoHash('SHA-256')(buf, callback)
}

function sha2512 (buf, callback) {
  webCryptoHash('SHA-512')(buf, callback)
}

module.exports = {
  sha1: sha1,
  sha2256: sha2256,
  sha2512: sha2512
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/crypto-sha1-2-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/blake.js", {"./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/utils.js","blakejs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/blake.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const blake = require('blakejs')

const toCallback = require('./utils').toCallback

const minB = 0xb201
const minS = 0xb241

const blake2b = {
  init: blake.blake2bInit,
  update: blake.blake2bUpdate,
  digest: blake.blake2bFinal
}

const blake2s = {
  init: blake.blake2sInit,
  update: blake.blake2sUpdate,
  digest: blake.blake2sFinal
}

const makeB2Hash = (size, hf) => toCallback((buf) => {
  const ctx = hf.init(size, null)
  hf.update(ctx, buf)
  return Buffer.from(hf.digest(ctx))
})

module.exports = (table) => {
  for (let i = 0; i < 64; i++) {
    table[minB + i] = makeB2Hash(i + 1, blake2b)
  }
  for (let i = 0; i < 32; i++) {
    table[minS + i] = makeB2Hash(i + 1, blake2s)
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/blake.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/index.js", {"../messages.json":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/messages.json","./bn":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/bn/index.js","./ecpoint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/ecpoint.js","./ecpointg":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/ecpointg.js","create-hash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/create-hash/browser.js","drbg.js/hmac":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/drbg.js/hmac.js","safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/index.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var createHash = require('create-hash')
var HmacDRBG = require('drbg.js/hmac')
var messages = require('../messages.json')
var BN = require('./bn')
var ECPoint = require('./ecpoint')
var g = require('./ecpointg')

exports.privateKeyVerify = function (privateKey) {
  var bn = BN.fromBuffer(privateKey)
  return !(bn.isOverflow() || bn.isZero())
}

exports.privateKeyExport = function (privateKey, compressed) {
  var d = BN.fromBuffer(privateKey)
  if (d.isOverflow() || d.isZero()) throw new Error(messages.EC_PRIVATE_KEY_EXPORT_DER_FAIL)

  return g.mul(d).toPublicKey(compressed)
}

exports.privateKeyNegate = function (privateKey) {
  var bn = BN.fromBuffer(privateKey)
  if (bn.isZero()) return Buffer.alloc(32)

  if (bn.ucmp(BN.n) > 0) bn.isub(BN.n)
  return BN.n.sub(bn).toBuffer()
}

exports.privateKeyModInverse = function (privateKey) {
  var bn = BN.fromBuffer(privateKey)
  if (bn.isOverflow() || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_RANGE_INVALID)

  return bn.uinvm().toBuffer()
}

exports.privateKeyTweakAdd = function (privateKey, tweak) {
  var bn = BN.fromBuffer(tweak)
  if (bn.isOverflow()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL)

  bn.iadd(BN.fromBuffer(privateKey))
  if (bn.isOverflow()) bn.isub(BN.n)
  if (bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL)

  return bn.toBuffer()
}

exports.privateKeyTweakMul = function (privateKey, tweak) {
  var bn = BN.fromBuffer(tweak)
  if (bn.isOverflow() || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_MUL_FAIL)

  var d = BN.fromBuffer(privateKey)
  return bn.umul(d).ureduce().toBuffer()
}

exports.publicKeyCreate = function (privateKey, compressed) {
  var d = BN.fromBuffer(privateKey)
  if (d.isOverflow() || d.isZero()) throw new Error(messages.EC_PUBLIC_KEY_CREATE_FAIL)

  return g.mul(d).toPublicKey(compressed)
}

exports.publicKeyConvert = function (publicKey, compressed) {
  var point = ECPoint.fromPublicKey(publicKey)
  if (point === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  return point.toPublicKey(compressed)
}

exports.publicKeyVerify = function (publicKey) {
  return ECPoint.fromPublicKey(publicKey) !== null
}

exports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {
  var point = ECPoint.fromPublicKey(publicKey)
  if (point === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  tweak = BN.fromBuffer(tweak)
  if (tweak.isOverflow()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL)

  var result = g.mul(tweak).add(point)
  if (result.inf) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL)

  return result.toPublicKey(compressed)
}

exports.publicKeyTweakMul = function (publicKey, tweak, compressed) {
  var point = ECPoint.fromPublicKey(publicKey)
  if (point === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  tweak = BN.fromBuffer(tweak)
  if (tweak.isOverflow() || tweak.isZero()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_MUL_FAIL)

  return point.mul(tweak).toPublicKey(compressed)
}

exports.publicKeyCombine = function (publicKeys, compressed) {
  var points = new Array(publicKeys.length)
  for (var i = 0; i < publicKeys.length; ++i) {
    points[i] = ECPoint.fromPublicKey(publicKeys[i])
    if (points[i] === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)
  }

  var point = points[0]
  for (var j = 1; j < points.length; ++j) point = point.add(points[j])
  if (point.inf) throw new Error(messages.EC_PUBLIC_KEY_COMBINE_FAIL)

  return point.toPublicKey(compressed)
}

exports.signatureNormalize = function (signature) {
  var r = BN.fromBuffer(signature.slice(0, 32))
  var s = BN.fromBuffer(signature.slice(32, 64))
  if (r.isOverflow() || s.isOverflow()) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  var result = Buffer.from(signature)
  if (s.isHigh()) BN.n.sub(s).toBuffer().copy(result, 32)

  return result
}

exports.signatureExport = function (signature) {
  var r = signature.slice(0, 32)
  var s = signature.slice(32, 64)
  if (BN.fromBuffer(r).isOverflow() || BN.fromBuffer(s).isOverflow()) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  return { r: r, s: s }
}

exports.signatureImport = function (sigObj) {
  var r = BN.fromBuffer(sigObj.r)
  if (r.isOverflow()) r = BN.fromNumber(0)

  var s = BN.fromBuffer(sigObj.s)
  if (s.isOverflow()) s = BN.fromNumber(0)

  return Buffer.concat([r.toBuffer(), s.toBuffer()])
}

exports.sign = function (message, privateKey, noncefn, data) {
  var d = BN.fromBuffer(privateKey)
  if (d.isOverflow() || d.isZero()) throw new Error(messages.ECDSA_SIGN_FAIL)

  if (noncefn === null) {
    var drbg = new HmacDRBG('sha256', privateKey, message, data)
    noncefn = function () { return drbg.generate(32) }
  }

  var bnMessage = BN.fromBuffer(message)
  for (var count = 0; ; ++count) {
    var nonce = noncefn(message, privateKey, null, data, count)
    if (!Buffer.isBuffer(nonce) || nonce.length !== 32) throw new Error(messages.ECDSA_SIGN_FAIL)

    var k = BN.fromBuffer(nonce)
    if (k.isOverflow() || k.isZero()) continue

    var kp = g.mul(k)
    var r = kp.x.fireduce()
    if (r.isZero()) continue

    var s = k.uinvm().umul(r.umul(d).ureduce().iadd(bnMessage).fireduce()).ureduce()
    if (s.isZero()) continue

    var recovery = (kp.x.ucmp(r) !== 0 ? 2 : 0) | (kp.y.isOdd() ? 1 : 0)
    if (s.isHigh()) {
      s = BN.n.sub(s)
      recovery ^= 1
    }

    return {
      signature: Buffer.concat([r.toBuffer(), s.toBuffer()]),
      recovery: recovery
    }
  }
}

exports.verify = function (message, signature, publicKey) {
  var sigr = BN.fromBuffer(signature.slice(0, 32))
  var sigs = BN.fromBuffer(signature.slice(32, 64))
  if (sigr.isOverflow() || sigs.isOverflow()) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  if (sigs.isHigh() || sigr.isZero() || sigs.isZero()) return false

  var pub = ECPoint.fromPublicKey(publicKey)
  if (pub === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  var sinv = sigs.uinvm()
  var u1 = sinv.umul(BN.fromBuffer(message)).ureduce()
  var u2 = sinv.umul(sigr).ureduce()
  var point = g.mulAdd(u1, pub, u2)
  if (point.inf) return false

  // return ECPoint.fromECJPoint(point).x.fireduce().ucmp(sigr) === 0
  // Inversion-free
  var z2 = point.z.redSqr()
  if (sigr.redMul(z2).ucmp(point.x) === 0) return true
  if (sigr.ucmp(BN.psn) >= 0) return false

  return sigr.iadd(BN.psn).redMul(z2).ucmp(point.x) === 0
}

exports.recover = function (message, signature, recovery, compressed) {
  var sigr = BN.fromBuffer(signature.slice(0, 32))
  var sigs = BN.fromBuffer(signature.slice(32, 64))
  if (sigr.isOverflow() || sigs.isOverflow()) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  do {
    if (sigr.isZero() || sigs.isZero()) break

    var kpx = sigr
    if (recovery >> 1) {
      if (kpx.ucmp(BN.psn) >= 0) break
      kpx = sigr.add(BN.n)
    }

    var kpPublicKey = Buffer.concat([Buffer.from([0x02 + (recovery & 0x01)]), kpx.toBuffer()])
    var kp = ECPoint.fromPublicKey(kpPublicKey)
    if (kp === null) break

    var rInv = sigr.uinvm()
    var s1 = BN.n.sub(BN.fromBuffer(message)).umul(rInv).ureduce()
    var s2 = sigs.umul(rInv).ureduce()
    var point = ECPoint.fromECJPoint(g.mulAdd(s1, kp, s2))
    return point.toPublicKey(compressed)
  } while (false)

  throw new Error(messages.ECDSA_RECOVER_FAIL)
}

exports.ecdh = function (publicKey, privateKey) {
  var shared = exports.ecdhUnsafe(publicKey, privateKey, true)
  return createHash('sha256').update(shared).digest()
}

exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
  var point = ECPoint.fromPublicKey(publicKey)
  if (point === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  var scalar = BN.fromBuffer(privateKey)
  if (scalar.isOverflow() || scalar.isZero()) throw new Error(messages.ECDH_FAIL)

  return point.mul(scalar).toPublicKey(compressed)
}

      };
    };
  }
}, {package:"secp256k1",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/lib/js/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js
      return function (require, module, exports) {
/* jshint -W086: true */
// +----------------------------------------------------------------------+
// | murmurHash3js.js v3.0.1 // https://github.com/pid/murmurHash3js
// | A javascript implementation of MurmurHash3's x86 hashing algorithms. |
// |----------------------------------------------------------------------|
// | Copyright (c) 2012-2015 Karan Lyons                                       |
// | https://github.com/karanlyons/murmurHash3.js/blob/c1778f75792abef7bdd74bc85d2d4e1a3d25cfe9/murmurHash3.js |
// | Freely distributable under the MIT license.                          |
// +----------------------------------------------------------------------+

;(function (root, undefined) {
    'use strict';

    // Create a local object that'll be exported or referenced globally.
    var library = {
        'version': '3.0.0',
        'x86': {},
        'x64': {},
        'inputValidation': true
    };

    // PRIVATE FUNCTIONS
    // -----------------

    function _validBytes(bytes) {
        // check the input is an array or a typed array
        if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {
            return false;
        }

        // check all bytes are actually bytes
        for (var i = 0; i < bytes.length; i++) {
            if (!Number.isInteger(bytes[i]) || bytes[i] < 0 || bytes[i] > 255) {
                return false;
            }
        }
        return true;
    }

    function _x86Multiply(m, n) {
        //
        // Given two 32bit ints, returns the two multiplied together as a
        // 32bit int.
        //

        return ((m & 0xffff) * n) + ((((m >>> 16) * n) & 0xffff) << 16);
    }

    function _x86Rotl(m, n) {
        //
        // Given a 32bit int and an int representing a number of bit positions,
        // returns the 32bit int rotated left by that number of positions.
        //

        return (m << n) | (m >>> (32 - n));
    }

    function _x86Fmix(h) {
        //
        // Given a block, returns murmurHash3's final x86 mix of that block.
        //

        h ^= h >>> 16;
        h = _x86Multiply(h, 0x85ebca6b);
        h ^= h >>> 13;
        h = _x86Multiply(h, 0xc2b2ae35);
        h ^= h >>> 16;

        return h;
    }

    function _x64Add(m, n) {
        //
        // Given two 64bit ints (as an array of two 32bit ints) returns the two
        // added together as a 64bit int (as an array of two 32bit ints).
        //

        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];
        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];
        var o = [0, 0, 0, 0];

        o[3] += m[3] + n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 0xffff;

        o[2] += m[2] + n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 0xffff;

        o[1] += m[1] + n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 0xffff;

        o[0] += m[0] + n[0];
        o[0] &= 0xffff;

        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];
    }

    function _x64Multiply(m, n) {
        //
        // Given two 64bit ints (as an array of two 32bit ints) returns the two
        // multiplied together as a 64bit int (as an array of two 32bit ints).
        //

        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];
        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];
        var o = [0, 0, 0, 0];

        o[3] += m[3] * n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 0xffff;

        o[2] += m[2] * n[3];
        o[1] += o[2] >>> 16;
        o[2] &= 0xffff;

        o[2] += m[3] * n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 0xffff;

        o[1] += m[1] * n[3];
        o[0] += o[1] >>> 16;
        o[1] &= 0xffff;

        o[1] += m[2] * n[2];
        o[0] += o[1] >>> 16;
        o[1] &= 0xffff;

        o[1] += m[3] * n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 0xffff;

        o[0] += (m[0] * n[3]) + (m[1] * n[2]) + (m[2] * n[1]) + (m[3] * n[0]);
        o[0] &= 0xffff;

        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];
    }

    function _x64Rotl(m, n) {
        //
        // Given a 64bit int (as an array of two 32bit ints) and an int
        // representing a number of bit positions, returns the 64bit int (as an
        // array of two 32bit ints) rotated left by that number of positions.
        //

        n %= 64;

        if (n === 32) {
            return [m[1], m[0]];
        } else if (n < 32) {
            return [(m[0] << n) | (m[1] >>> (32 - n)), (m[1] << n) | (m[0] >>> (32 - n))];
        } else {
            n -= 32;
            return [(m[1] << n) | (m[0] >>> (32 - n)), (m[0] << n) | (m[1] >>> (32 - n))];
        }
    }

    function _x64LeftShift(m, n) {
        //
        // Given a 64bit int (as an array of two 32bit ints) and an int
        // representing a number of bit positions, returns the 64bit int (as an
        // array of two 32bit ints) shifted left by that number of positions.
        //

        n %= 64;

        if (n === 0) {
            return m;
        } else if (n < 32) {
            return [(m[0] << n) | (m[1] >>> (32 - n)), m[1] << n];
        } else {
            return [m[1] << (n - 32), 0];
        }
    }

    function _x64Xor(m, n) {
        //
        // Given two 64bit ints (as an array of two 32bit ints) returns the two
        // xored together as a 64bit int (as an array of two 32bit ints).
        //

        return [m[0] ^ n[0], m[1] ^ n[1]];
    }

    function _x64Fmix(h) {
        //
        // Given a block, returns murmurHash3's final x64 mix of that block.
        // (`[0, h[0] >>> 1]` is a 33 bit unsigned right shift. This is the
        // only place where we need to right shift 64bit ints.)
        //

        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [0xff51afd7, 0xed558ccd]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [0xc4ceb9fe, 0x1a85ec53]);
        h = _x64Xor(h, [0, h[0] >>> 1]);

        return h;
    }

    // PUBLIC FUNCTIONS
    // ----------------

    library.x86.hash32 = function (bytes, seed) {
        //
        // Given a string and an optional seed as an int, returns a 32 bit hash
        // using the x86 flavor of MurmurHash3, as an unsigned int.
        //
        if (library.inputValidation && !_validBytes(bytes)) {
            return undefined;
        }
        seed = seed || 0;

        var remainder = bytes.length % 4;
        var blocks = bytes.length - remainder;

        var h1 = seed;

        var k1 = 0;

        var c1 = 0xcc9e2d51;
        var c2 = 0x1b873593;

        for (var i = 0; i < blocks; i = i + 4) {
            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);

            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);

            h1 ^= k1;
            h1 = _x86Rotl(h1, 13);
            h1 = _x86Multiply(h1, 5) + 0xe6546b64;
        }

        k1 = 0;

        switch (remainder) {
            case 3:
                k1 ^= bytes[i + 2] << 16;

            case 2:
                k1 ^= bytes[i + 1] << 8;

            case 1:
                k1 ^= bytes[i];
                k1 = _x86Multiply(k1, c1);
                k1 = _x86Rotl(k1, 15);
                k1 = _x86Multiply(k1, c2);
                h1 ^= k1;
        }

        h1 ^= bytes.length;
        h1 = _x86Fmix(h1);

        return h1 >>> 0;
    };

    library.x86.hash128 = function (bytes, seed) {
        //
        // Given a string and an optional seed as an int, returns a 128 bit
        // hash using the x86 flavor of MurmurHash3, as an unsigned hex.
        //
        if (library.inputValidation && !_validBytes(bytes)) {
            return undefined;
        }

        seed = seed || 0;
        var remainder = bytes.length % 16;
        var blocks = bytes.length - remainder;

        var h1 = seed;
        var h2 = seed;
        var h3 = seed;
        var h4 = seed;

        var k1 = 0;
        var k2 = 0;
        var k3 = 0;
        var k4 = 0;

        var c1 = 0x239b961b;
        var c2 = 0xab0e9789;
        var c3 = 0x38b34ae5;
        var c4 = 0xa1e38b93;

        for (var i = 0; i < blocks; i = i + 16) {
            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);
            k2 = (bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24);
            k3 = (bytes[i + 8]) | (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24);
            k4 = (bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24);

            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;

            h1 = _x86Rotl(h1, 19);
            h1 += h2;
            h1 = _x86Multiply(h1, 5) + 0x561ccd1b;

            k2 = _x86Multiply(k2, c2);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c3);
            h2 ^= k2;

            h2 = _x86Rotl(h2, 17);
            h2 += h3;
            h2 = _x86Multiply(h2, 5) + 0x0bcaa747;

            k3 = _x86Multiply(k3, c3);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c4);
            h3 ^= k3;

            h3 = _x86Rotl(h3, 15);
            h3 += h4;
            h3 = _x86Multiply(h3, 5) + 0x96cd1c35;

            k4 = _x86Multiply(k4, c4);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h4 ^= k4;

            h4 = _x86Rotl(h4, 13);
            h4 += h1;
            h4 = _x86Multiply(h4, 5) + 0x32ac3b17;
        }

        k1 = 0;
        k2 = 0;
        k3 = 0;
        k4 = 0;

        switch (remainder) {
            case 15:
                k4 ^= bytes[i + 14] << 16;

            case 14:
                k4 ^= bytes[i + 13] << 8;

            case 13:
                k4 ^= bytes[i + 12];
                k4 = _x86Multiply(k4, c4);
                k4 = _x86Rotl(k4, 18);
                k4 = _x86Multiply(k4, c1);
                h4 ^= k4;

            case 12:
                k3 ^= bytes[i + 11] << 24;

            case 11:
                k3 ^= bytes[i + 10] << 16;

            case 10:
                k3 ^= bytes[i + 9] << 8;

            case 9:
                k3 ^= bytes[i + 8];
                k3 = _x86Multiply(k3, c3);
                k3 = _x86Rotl(k3, 17);
                k3 = _x86Multiply(k3, c4);
                h3 ^= k3;

            case 8:
                k2 ^= bytes[i + 7] << 24;

            case 7:
                k2 ^= bytes[i + 6] << 16;

            case 6:
                k2 ^= bytes[i + 5] << 8;

            case 5:
                k2 ^= bytes[i + 4];
                k2 = _x86Multiply(k2, c2);
                k2 = _x86Rotl(k2, 16);
                k2 = _x86Multiply(k2, c3);
                h2 ^= k2;

            case 4:
                k1 ^= bytes[i + 3] << 24;

            case 3:
                k1 ^= bytes[i + 2] << 16;

            case 2:
                k1 ^= bytes[i + 1] << 8;

            case 1:
                k1 ^= bytes[i];
                k1 = _x86Multiply(k1, c1);
                k1 = _x86Rotl(k1, 15);
                k1 = _x86Multiply(k1, c2);
                h1 ^= k1;
        }

        h1 ^= bytes.length;
        h2 ^= bytes.length;
        h3 ^= bytes.length;
        h4 ^= bytes.length;

        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;

        h1 = _x86Fmix(h1);
        h2 = _x86Fmix(h2);
        h3 = _x86Fmix(h3);
        h4 = _x86Fmix(h4);

        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;

        return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
    };

    library.x64.hash128 = function (bytes, seed) {
        //
        // Given a string and an optional seed as an int, returns a 128 bit
        // hash using the x64 flavor of MurmurHash3, as an unsigned hex.
        //
        if (library.inputValidation && !_validBytes(bytes)) {
            return undefined;
        }
        seed = seed || 0;

        var remainder = bytes.length % 16;
        var blocks = bytes.length - remainder;

        var h1 = [0, seed];
        var h2 = [0, seed];

        var k1 = [0, 0];
        var k2 = [0, 0];

        var c1 = [0x87c37b91, 0x114253d5];
        var c2 = [0x4cf5ad43, 0x2745937f];

        for (var i = 0; i < blocks; i = i + 16) {
            k1 = [(bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24), (bytes[i]) |
                (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24)];
            k2 = [(bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24), (bytes[i + 8]) |
                (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24)];

            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c2);
            h1 = _x64Xor(h1, k1);

            h1 = _x64Rotl(h1, 27);
            h1 = _x64Add(h1, h2);
            h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 0x52dce729]);

            k2 = _x64Multiply(k2, c2);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h2 = _x64Xor(h2, k2);

            h2 = _x64Rotl(h2, 31);
            h2 = _x64Add(h2, h1);
            h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 0x38495ab5]);
        }

        k1 = [0, 0];
        k2 = [0, 0];

        switch (remainder) {
            case 15:
                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 14]], 48));

            case 14:
                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 13]], 40));

            case 13:
                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 12]], 32));

            case 12:
                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 11]], 24));

            case 11:
                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 10]], 16));

            case 10:
                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 9]], 8));

            case 9:
                k2 = _x64Xor(k2, [0, bytes[i + 8]]);
                k2 = _x64Multiply(k2, c2);
                k2 = _x64Rotl(k2, 33);
                k2 = _x64Multiply(k2, c1);
                h2 = _x64Xor(h2, k2);

            case 8:
                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 7]], 56));

            case 7:
                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 6]], 48));

            case 6:
                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 5]], 40));

            case 5:
                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 4]], 32));

            case 4:
                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 3]], 24));

            case 3:
                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 2]], 16));

            case 2:
                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 1]], 8));

            case 1:
                k1 = _x64Xor(k1, [0, bytes[i]]);
                k1 = _x64Multiply(k1, c1);
                k1 = _x64Rotl(k1, 31);
                k1 = _x64Multiply(k1, c2);
                h1 = _x64Xor(h1, k1);
        }

        h1 = _x64Xor(h1, [0, bytes.length]);
        h2 = _x64Xor(h2, [0, bytes.length]);

        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);

        h1 = _x64Fmix(h1);
        h2 = _x64Fmix(h2);

        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);

        return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
    };

    // INITIALIZATION
    // --------------

    // Export murmurHash3 for CommonJS, either as an AMD module or just as part
    // of the global object.
    if (typeof exports !== 'undefined') {

        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = library;
        }

        exports.murmurHash3 = library;

    } else if (typeof define === 'function' && define.amd) {

        define([], function () {
            return library;
        });
    } else {

        // Use murmurHash3.noConflict to restore `murmurHash3` back to its
        // original value. Returns a reference to the library object, to allow
        // it to be used under a different name.
        library._murmurHash3 = root.murmurHash3;

        library.noConflict = function () {
            root.murmurHash3 = library._murmurHash3;
            library._murmurHash3 = undefined;
            library.noConflict = undefined;

            return library;
        };

        root.murmurHash3 = library;
    }
})(this);

      };
    };
  }
}, {package:"murmurhash3js-revisited",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/util.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/util.js
      return function (require, module, exports) {
(function (Buffer){(function (){
var ERROR_MSG_INPUT = 'Input must be an string, Buffer or Uint8Array'

// For convenience, let people hash a string, not just a Uint8Array
function normalizeInput (input) {
  var ret
  if (input instanceof Uint8Array) {
    ret = input
  } else if (input instanceof Buffer) {
    ret = new Uint8Array(input)
  } else if (typeof (input) === 'string') {
    ret = new Uint8Array(Buffer.from(input, 'utf8'))
  } else {
    throw new Error(ERROR_MSG_INPUT)
  }
  return ret
}

// Converts a Uint8Array to a hexadecimal string
// For example, toHex([255, 0, 255]) returns "ff00ff"
function toHex (bytes) {
  return Array.prototype.map.call(bytes, function (n) {
    return (n < 16 ? '0' : '') + n.toString(16)
  }).join('')
}

// Converts any value in [0...2^32-1] to an 8-character hex string
function uint32ToHex (val) {
  return (0x100000000 + val).toString(16).substring(1)
}

// For debugging: prints out hash state in the same format as the RFC
// sample computation exactly, so that you can diff
function debugPrint (label, arr, size) {
  var msg = '\n' + label + ' = '
  for (var i = 0; i < arr.length; i += 2) {
    if (size === 32) {
      msg += uint32ToHex(arr[i]).toUpperCase()
      msg += ' '
      msg += uint32ToHex(arr[i + 1]).toUpperCase()
    } else if (size === 64) {
      msg += uint32ToHex(arr[i + 1]).toUpperCase()
      msg += uint32ToHex(arr[i]).toUpperCase()
    } else throw new Error('Invalid size ' + size)
    if (i % 6 === 4) {
      msg += '\n' + new Array(label.length + 4).join(' ')
    } else if (i < arr.length - 2) {
      msg += ' '
    }
  }
  console.log(msg)
}

// For performance testing: generates N bytes of input, hashes M times
// Measures and prints MB/second hash performance each time
function testSpeed (hashFn, N, M) {
  var startMs = new Date().getTime()

  var input = new Uint8Array(N)
  for (var i = 0; i < N; i++) {
    input[i] = i % 256
  }
  var genMs = new Date().getTime()
  console.log('Generated random input in ' + (genMs - startMs) + 'ms')
  startMs = genMs

  for (i = 0; i < M; i++) {
    var hashHex = hashFn(input)
    var hashMs = new Date().getTime()
    var ms = hashMs - startMs
    startMs = hashMs
    console.log('Hashed in ' + ms + 'ms: ' + hashHex.substring(0, 20) + '...')
    console.log(Math.round(N / (1 << 20) / (ms / 1000) * 100) / 100 + ' MB PER SECOND')
  }
}

module.exports = {
  normalizeInput: normalizeInput,
  toHex: toHex,
  debugPrint: debugPrint,
  testSpeed: testSpeed
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"blakejs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/blakejs/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/node_modules/uuid/lib/rng-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/node_modules/uuid/lib/rng-browser.js
      return function (require, module, exports) {
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

      };
    };
  }
}, {package:"uuid",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/node_modules/uuid/lib/rng-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/node_modules/uuid/lib/bytesToUuid.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/node_modules/uuid/lib/bytesToUuid.js
      return function (require, module, exports) {
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;

      };
    };
  }
}, {package:"uuid",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/node_modules/uuid/lib/bytesToUuid.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-pubsub/src/utils.js", {"err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","multibase":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-pubsub/src/utils.js
      return function (require, module, exports) {
'use strict'

const multibase = require('multibase')
const errcode = require('err-code')

const namespace = '/record/'
const base64urlCode = 'u' // base64url code from multibase

module.exports.encodeBase32 = (buf) => {
  return multibase.encode('base32', buf).slice(1) // slice off multibase codec
}

// converts a binary record key to a pubsub topic key.
module.exports.keyToTopic = (key) => {
  // Record-store keys are arbitrary binary. However, pubsub requires UTF-8 string topic IDs
  // Encodes to "/record/base64url(key)"
  const b64url = multibase.encode('base64url', key).slice(1).toString()

  return `${namespace}${b64url}`
}

// converts a pubsub topic key to a binary record key.
module.exports.topicToKey = (topic) => {
  if (topic.substring(0, namespace.length) !== namespace) {
    throw errcode(new Error('topic received is not from a record'), 'ERR_TOPIC_IS_NOT_FROM_RECORD_NAMESPACE')
  }

  const key = `${base64urlCode}${topic.substring(namespace.length)}`

  return multibase.decode(key).toString()
}

      };
    };
  }
}, {package:"datastore-pubsub",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/datastore-pubsub/src/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/truncate-utf8-bytes/browser.js", {"./lib/truncate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/truncate-utf8-bytes/lib/truncate.js","utf8-byte-length/browser":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/utf8-byte-length/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/truncate-utf8-bytes/browser.js
      return function (require, module, exports) {
'use strict';

var truncate = require("./lib/truncate");
var getLength = require("utf8-byte-length/browser");
module.exports = truncate.bind(null, getLength);

      };
    };
  }
}, {package:"truncate-utf8-bytes",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/truncate-utf8-bytes/browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/detect.js", {"./internal/createTester":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/createTester.js","./internal/doParallel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/doParallel.js","./internal/findGetResult":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/findGetResult.js","lodash/identity":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/identity.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/detect.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _identity = require('lodash/identity');

var _identity2 = _interopRequireDefault(_identity);

var _createTester = require('./internal/createTester');

var _createTester2 = _interopRequireDefault(_createTester);

var _doParallel = require('./internal/doParallel');

var _doParallel2 = _interopRequireDefault(_doParallel);

var _findGetResult = require('./internal/findGetResult');

var _findGetResult2 = _interopRequireDefault(_findGetResult);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns the first value in `coll` that passes an async truth test. The
 * `iteratee` is applied in parallel, meaning the first iteratee to return
 * `true` will fire the detect `callback` with that result. That means the
 * result might not be the first item in the original `coll` (in terms of order)
 * that passes the test.

 * If order within the original `coll` is important, then look at
 * [`detectSeries`]{@link module:Collections.detectSeries}.
 *
 * @name detect
 * @static
 * @memberOf module:Collections
 * @method
 * @alias find
 * @category Collections
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
 * The iteratee must complete with a boolean value as its result.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 * @example
 *
 * async.detect(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, result) {
 *     // result now equals the first file in the list that exists
 * });
 */
exports.default = (0, _doParallel2.default)((0, _createTester2.default)(_identity2.default, _findGetResult2.default));
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/detect.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pkcs7.js", {"./aes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/aes.js","./asn1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/asn1.js","./des":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/des.js","./forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","./oids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/oids.js","./pem":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pem.js","./pkcs7asn1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pkcs7asn1.js","./random":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/random.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js","./x509":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/x509.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pkcs7.js
      return function (require, module, exports) {
/**
 * Javascript implementation of PKCS#7 v1.5.
 *
 * @author Stefan Siegl
 * @author Dave Longley
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 * Copyright (c) 2012-2015 Digital Bazaar, Inc.
 *
 * Currently this implementation only supports ContentType of EnvelopedData,
 * EncryptedData, or SignedData at the root level. The top level elements may
 * contain only a ContentInfo of ContentType Data, i.e. plain data. Further
 * nesting is not (yet) supported.
 *
 * The Forge validators for PKCS #7's ASN.1 structures are available from
 * a separate file pkcs7asn1.js, since those are referenced from other
 * PKCS standards like PKCS #12.
 */
var forge = require('./forge');
require('./aes');
require('./asn1');
require('./des');
require('./oids');
require('./pem');
require('./pkcs7asn1');
require('./random');
require('./util');
require('./x509');

// shortcut for ASN.1 API
var asn1 = forge.asn1;

// shortcut for PKCS#7 API
var p7 = module.exports = forge.pkcs7 = forge.pkcs7 || {};

/**
 * Converts a PKCS#7 message from PEM format.
 *
 * @param pem the PEM-formatted PKCS#7 message.
 *
 * @return the PKCS#7 message.
 */
p7.messageFromPem = function(pem) {
  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'PKCS7') {
    var error = new Error('Could not convert PKCS#7 message from PEM; PEM ' +
      'header type is not "PKCS#7".');
    error.headerType = msg.type;
    throw error;
  }
  if(msg.procType && msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert PKCS#7 message from PEM; PEM is encrypted.');
  }

  // convert DER to ASN.1 object
  var obj = asn1.fromDer(msg.body);

  return p7.messageFromAsn1(obj);
};

/**
 * Converts a PKCS#7 message to PEM format.
 *
 * @param msg The PKCS#7 message object
 * @param maxline The maximum characters per line, defaults to 64.
 *
 * @return The PEM-formatted PKCS#7 message.
 */
p7.messageToPem = function(msg, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var pemObj = {
    type: 'PKCS7',
    body: asn1.toDer(msg.toAsn1()).getBytes()
  };
  return forge.pem.encode(pemObj, {maxline: maxline});
};

/**
 * Converts a PKCS#7 message from an ASN.1 object.
 *
 * @param obj the ASN.1 representation of a ContentInfo.
 *
 * @return the PKCS#7 message.
 */
p7.messageFromAsn1 = function(obj) {
  // validate root level ContentInfo and capture data
  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
    var error = new Error('Cannot read PKCS#7 message. ' +
      'ASN.1 object is not an PKCS#7 ContentInfo.');
    error.errors = errors;
    throw error;
  }

  var contentType = asn1.derToOid(capture.contentType);
  var msg;

  switch(contentType) {
    case forge.pki.oids.envelopedData:
      msg = p7.createEnvelopedData();
      break;

    case forge.pki.oids.encryptedData:
      msg = p7.createEncryptedData();
      break;

    case forge.pki.oids.signedData:
      msg = p7.createSignedData();
      break;

    default:
      throw new Error('Cannot read PKCS#7 message. ContentType with OID ' +
        contentType + ' is not (yet) supported.');
  }

  msg.fromAsn1(capture.content.value[0]);
  return msg;
};

p7.createSignedData = function() {
  var msg = null;
  msg = {
    type: forge.pki.oids.signedData,
    version: 1,
    certificates: [],
    crls: [],
    // TODO: add json-formatted signer stuff here?
    signers: [],
    // populated during sign()
    digestAlgorithmIdentifiers: [],
    contentInfo: null,
    signerInfos: [],

    fromAsn1: function(obj) {
      // validate SignedData content block and capture data.
      _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
      msg.certificates = [];
      msg.crls = [];
      msg.digestAlgorithmIdentifiers = [];
      msg.contentInfo = null;
      msg.signerInfos = [];

      if(msg.rawCapture.certificates) {
        var certs = msg.rawCapture.certificates.value;
        for(var i = 0; i < certs.length; ++i) {
          msg.certificates.push(forge.pki.certificateFromAsn1(certs[i]));
        }
      }

      // TODO: parse crls
    },

    toAsn1: function() {
      // degenerate case with no content
      if(!msg.contentInfo) {
        msg.sign();
      }

      var certs = [];
      for(var i = 0; i < msg.certificates.length; ++i) {
        certs.push(forge.pki.certificateToAsn1(msg.certificates[i]));
      }

      var crls = [];
      // TODO: implement CRLs

      // [0] SignedData
      var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Version
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
            asn1.integerToDer(msg.version).getBytes()),
          // DigestAlgorithmIdentifiers
          asn1.create(
            asn1.Class.UNIVERSAL, asn1.Type.SET, true,
            msg.digestAlgorithmIdentifiers),
          // ContentInfo
          msg.contentInfo
        ])
      ]);
      if(certs.length > 0) {
        // [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL
        signedData.value[0].value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs));
      }
      if(crls.length > 0) {
        // [1] IMPLICIT CertificateRevocationLists OPTIONAL
        signedData.value[0].value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls));
      }
      // SignerInfos
      signedData.value[0].value.push(
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true,
          msg.signerInfos));

      // ContentInfo
      return asn1.create(
        asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // ContentType
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
            asn1.oidToDer(msg.type).getBytes()),
          // [0] SignedData
          signedData
        ]);
    },

    /**
     * Add (another) entity to list of signers.
     *
     * Note: If authenticatedAttributes are provided, then, per RFC 2315,
     * they must include at least two attributes: content type and
     * message digest. The message digest attribute value will be
     * auto-calculated during signing and will be ignored if provided.
     *
     * Here's an example of providing these two attributes:
     *
     * forge.pkcs7.createSignedData();
     * p7.addSigner({
     *   issuer: cert.issuer.attributes,
     *   serialNumber: cert.serialNumber,
     *   key: privateKey,
     *   digestAlgorithm: forge.pki.oids.sha1,
     *   authenticatedAttributes: [{
     *     type: forge.pki.oids.contentType,
     *     value: forge.pki.oids.data
     *   }, {
     *     type: forge.pki.oids.messageDigest
     *   }]
     * });
     *
     * TODO: Support [subjectKeyIdentifier] as signer's ID.
     *
     * @param signer the signer information:
     *          key the signer's private key.
     *          [certificate] a certificate containing the public key
     *            associated with the signer's private key; use this option as
     *            an alternative to specifying signer.issuer and
     *            signer.serialNumber.
     *          [issuer] the issuer attributes (eg: cert.issuer.attributes).
     *          [serialNumber] the signer's certificate's serial number in
     *           hexadecimal (eg: cert.serialNumber).
     *          [digestAlgorithm] the message digest OID, as a string, to use
     *            (eg: forge.pki.oids.sha1).
     *          [authenticatedAttributes] an optional array of attributes
     *            to also sign along with the content.
     */
    addSigner: function(signer) {
      var issuer = signer.issuer;
      var serialNumber = signer.serialNumber;
      if(signer.certificate) {
        var cert = signer.certificate;
        if(typeof cert === 'string') {
          cert = forge.pki.certificateFromPem(cert);
        }
        issuer = cert.issuer.attributes;
        serialNumber = cert.serialNumber;
      }
      var key = signer.key;
      if(!key) {
        throw new Error(
          'Could not add PKCS#7 signer; no private key specified.');
      }
      if(typeof key === 'string') {
        key = forge.pki.privateKeyFromPem(key);
      }

      // ensure OID known for digest algorithm
      var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;
      switch(digestAlgorithm) {
      case forge.pki.oids.sha1:
      case forge.pki.oids.sha256:
      case forge.pki.oids.sha384:
      case forge.pki.oids.sha512:
      case forge.pki.oids.md5:
        break;
      default:
        throw new Error(
          'Could not add PKCS#7 signer; unknown message digest algorithm: ' +
          digestAlgorithm);
      }

      // if authenticatedAttributes is present, then the attributes
      // must contain at least PKCS #9 content-type and message-digest
      var authenticatedAttributes = signer.authenticatedAttributes || [];
      if(authenticatedAttributes.length > 0) {
        var contentType = false;
        var messageDigest = false;
        for(var i = 0; i < authenticatedAttributes.length; ++i) {
          var attr = authenticatedAttributes[i];
          if(!contentType && attr.type === forge.pki.oids.contentType) {
            contentType = true;
            if(messageDigest) {
              break;
            }
            continue;
          }
          if(!messageDigest && attr.type === forge.pki.oids.messageDigest) {
            messageDigest = true;
            if(contentType) {
              break;
            }
            continue;
          }
        }

        if(!contentType || !messageDigest) {
          throw new Error('Invalid signer.authenticatedAttributes. If ' +
            'signer.authenticatedAttributes is specified, then it must ' +
            'contain at least two attributes, PKCS #9 content-type and ' +
            'PKCS #9 message-digest.');
        }
      }

      msg.signers.push({
        key: key,
        version: 1,
        issuer: issuer,
        serialNumber: serialNumber,
        digestAlgorithm: digestAlgorithm,
        signatureAlgorithm: forge.pki.oids.rsaEncryption,
        signature: null,
        authenticatedAttributes: authenticatedAttributes,
        unauthenticatedAttributes: []
      });
    },

    /**
     * Signs the content.
     * @param options Options to apply when signing:
     *    [detached] boolean. If signing should be done in detached mode. Defaults to false.
     */
    sign: function(options) {
      options = options || {};
      // auto-generate content info
      if(typeof msg.content !== 'object' || msg.contentInfo === null) {
        // use Data ContentInfo
        msg.contentInfo = asn1.create(
          asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // ContentType
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
              asn1.oidToDer(forge.pki.oids.data).getBytes())
          ]);

        // add actual content, if present
        if('content' in msg) {
          var content;
          if(msg.content instanceof forge.util.ByteBuffer) {
            content = msg.content.bytes();
          } else if(typeof msg.content === 'string') {
            content = forge.util.encodeUtf8(msg.content);
          }

          if (options.detached) {
            msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
          } else {
            msg.contentInfo.value.push(
              // [0] EXPLICIT content
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,
                  content)
              ]));
          }
        }
      }

      // no signers, return early (degenerate case for certificate container)
      if(msg.signers.length === 0) {
        return;
      }

      // generate digest algorithm identifiers
      var mds = addDigestAlgorithmIds();

      // generate signerInfos
      addSignerInfos(mds);
    },

    verify: function() {
      throw new Error('PKCS#7 signature verification not yet implemented.');
    },

    /**
     * Add a certificate.
     *
     * @param cert the certificate to add.
     */
    addCertificate: function(cert) {
      // convert from PEM
      if(typeof cert === 'string') {
        cert = forge.pki.certificateFromPem(cert);
      }
      msg.certificates.push(cert);
    },

    /**
     * Add a certificate revokation list.
     *
     * @param crl the certificate revokation list to add.
     */
    addCertificateRevokationList: function(crl) {
      throw new Error('PKCS#7 CRL support not yet implemented.');
    }
  };
  return msg;

  function addDigestAlgorithmIds() {
    var mds = {};

    for(var i = 0; i < msg.signers.length; ++i) {
      var signer = msg.signers[i];
      var oid = signer.digestAlgorithm;
      if(!(oid in mds)) {
        // content digest
        mds[oid] = forge.md[forge.pki.oids[oid]].create();
      }
      if(signer.authenticatedAttributes.length === 0) {
        // no custom attributes to digest; use content message digest
        signer.md = mds[oid];
      } else {
        // custom attributes to be digested; use own message digest
        // TODO: optimize to just copy message digest state if that
        // feature is ever supported with message digests
        signer.md = forge.md[forge.pki.oids[oid]].create();
      }
    }

    // add unique digest algorithm identifiers
    msg.digestAlgorithmIdentifiers = [];
    for(var oid in mds) {
      msg.digestAlgorithmIdentifiers.push(
        // AlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
            asn1.oidToDer(oid).getBytes()),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
        ]));
    }

    return mds;
  }

  function addSignerInfos(mds) {
    var content;

    if (msg.detachedContent) {
      // Signature has been made in detached mode.
      content = msg.detachedContent;
    } else {
      // Note: ContentInfo is a SEQUENCE with 2 values, second value is
      // the content field and is optional for a ContentInfo but required here
      // since signers are present
      // get ContentInfo content
      content = msg.contentInfo.value[1];
      // skip [0] EXPLICIT content wrapper
      content = content.value[0];
    }

    if(!content) {
      throw new Error(
        'Could not sign PKCS#7 message; there is no content to sign.');
    }

    // get ContentInfo content type
    var contentType = asn1.derToOid(msg.contentInfo.value[0].value);

    // serialize content
    var bytes = asn1.toDer(content);

    // skip identifier and length per RFC 2315 9.3
    // skip identifier (1 byte)
    bytes.getByte();
    // read and discard length bytes
    asn1.getBerValueLength(bytes);
    bytes = bytes.getBytes();

    // digest content DER value bytes
    for(var oid in mds) {
      mds[oid].start().update(bytes);
    }

    // sign content
    var signingTime = new Date();
    for(var i = 0; i < msg.signers.length; ++i) {
      var signer = msg.signers[i];

      if(signer.authenticatedAttributes.length === 0) {
        // if ContentInfo content type is not "Data", then
        // authenticatedAttributes must be present per RFC 2315
        if(contentType !== forge.pki.oids.data) {
          throw new Error(
            'Invalid signer; authenticatedAttributes must be present ' +
            'when the ContentInfo content type is not PKCS#7 Data.');
        }
      } else {
        // process authenticated attributes
        // [0] IMPLICIT
        signer.authenticatedAttributesAsn1 = asn1.create(
          asn1.Class.CONTEXT_SPECIFIC, 0, true, []);

        // per RFC 2315, attributes are to be digested using a SET container
        // not the above [0] IMPLICIT container
        var attrsAsn1 = asn1.create(
          asn1.Class.UNIVERSAL, asn1.Type.SET, true, []);

        for(var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
          var attr = signer.authenticatedAttributes[ai];
          if(attr.type === forge.pki.oids.messageDigest) {
            // use content message digest as value
            attr.value = mds[signer.digestAlgorithm].digest();
          } else if(attr.type === forge.pki.oids.signingTime) {
            // auto-populate signing time if not already set
            if(!attr.value) {
              attr.value = signingTime;
            }
          }

          // convert to ASN.1 and push onto Attributes SET (for signing) and
          // onto authenticatedAttributesAsn1 to complete SignedData ASN.1
          // TODO: optimize away duplication
          attrsAsn1.value.push(_attributeToAsn1(attr));
          signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
        }

        // DER-serialize and digest SET OF attributes only
        bytes = asn1.toDer(attrsAsn1).getBytes();
        signer.md.start().update(bytes);
      }

      // sign digest
      signer.signature = signer.key.sign(signer.md, 'RSASSA-PKCS1-V1_5');
    }

    // add signer info
    msg.signerInfos = _signersToAsn1(msg.signers);
  }
};

/**
 * Creates an empty PKCS#7 message of type EncryptedData.
 *
 * @return the message.
 */
p7.createEncryptedData = function() {
  var msg = null;
  msg = {
    type: forge.pki.oids.encryptedData,
    version: 0,
    encryptedContent: {
      algorithm: forge.pki.oids['aes256-CBC']
    },

    /**
     * Reads an EncryptedData content block (in ASN.1 format)
     *
     * @param obj The ASN.1 representation of the EncryptedData content block
     */
    fromAsn1: function(obj) {
      // Validate EncryptedData content block and capture data.
      _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
    },

    /**
     * Decrypt encrypted content
     *
     * @param key The (symmetric) key as a byte buffer
     */
    decrypt: function(key) {
      if(key !== undefined) {
        msg.encryptedContent.key = key;
      }
      _decryptContent(msg);
    }
  };
  return msg;
};

/**
 * Creates an empty PKCS#7 message of type EnvelopedData.
 *
 * @return the message.
 */
p7.createEnvelopedData = function() {
  var msg = null;
  msg = {
    type: forge.pki.oids.envelopedData,
    version: 0,
    recipients: [],
    encryptedContent: {
      algorithm: forge.pki.oids['aes256-CBC']
    },

    /**
     * Reads an EnvelopedData content block (in ASN.1 format)
     *
     * @param obj the ASN.1 representation of the EnvelopedData content block.
     */
    fromAsn1: function(obj) {
      // validate EnvelopedData content block and capture data
      var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
      msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
    },

    toAsn1: function() {
      // ContentInfo
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // ContentType
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
          asn1.oidToDer(msg.type).getBytes()),
        // [0] EnvelopedData
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // Version
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
              asn1.integerToDer(msg.version).getBytes()),
            // RecipientInfos
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true,
              _recipientsToAsn1(msg.recipients)),
            // EncryptedContentInfo
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true,
              _encryptedContentToAsn1(msg.encryptedContent))
          ])
        ])
      ]);
    },

    /**
     * Find recipient by X.509 certificate's issuer.
     *
     * @param cert the certificate with the issuer to look for.
     *
     * @return the recipient object.
     */
    findRecipient: function(cert) {
      var sAttr = cert.issuer.attributes;

      for(var i = 0; i < msg.recipients.length; ++i) {
        var r = msg.recipients[i];
        var rAttr = r.issuer;

        if(r.serialNumber !== cert.serialNumber) {
          continue;
        }

        if(rAttr.length !== sAttr.length) {
          continue;
        }

        var match = true;
        for(var j = 0; j < sAttr.length; ++j) {
          if(rAttr[j].type !== sAttr[j].type ||
            rAttr[j].value !== sAttr[j].value) {
            match = false;
            break;
          }
        }

        if(match) {
          return r;
        }
      }

      return null;
    },

    /**
     * Decrypt enveloped content
     *
     * @param recipient The recipient object related to the private key
     * @param privKey The (RSA) private key object
     */
    decrypt: function(recipient, privKey) {
      if(msg.encryptedContent.key === undefined && recipient !== undefined &&
        privKey !== undefined) {
        switch(recipient.encryptedContent.algorithm) {
          case forge.pki.oids.rsaEncryption:
          case forge.pki.oids.desCBC:
            var key = privKey.decrypt(recipient.encryptedContent.content);
            msg.encryptedContent.key = forge.util.createBuffer(key);
            break;

          default:
            throw new Error('Unsupported asymmetric cipher, ' +
              'OID ' + recipient.encryptedContent.algorithm);
        }
      }

      _decryptContent(msg);
    },

    /**
     * Add (another) entity to list of recipients.
     *
     * @param cert The certificate of the entity to add.
     */
    addRecipient: function(cert) {
      msg.recipients.push({
        version: 0,
        issuer: cert.issuer.attributes,
        serialNumber: cert.serialNumber,
        encryptedContent: {
          // We simply assume rsaEncryption here, since forge.pki only
          // supports RSA so far.  If the PKI module supports other
          // ciphers one day, we need to modify this one as well.
          algorithm: forge.pki.oids.rsaEncryption,
          key: cert.publicKey
        }
      });
    },

    /**
     * Encrypt enveloped content.
     *
     * This function supports two optional arguments, cipher and key, which
     * can be used to influence symmetric encryption.  Unless cipher is
     * provided, the cipher specified in encryptedContent.algorithm is used
     * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key
     * is (re-)used.  If that one's not set, a random key will be generated
     * automatically.
     *
     * @param [key] The key to be used for symmetric encryption.
     * @param [cipher] The OID of the symmetric cipher to use.
     */
    encrypt: function(key, cipher) {
      // Part 1: Symmetric encryption
      if(msg.encryptedContent.content === undefined) {
        cipher = cipher || msg.encryptedContent.algorithm;
        key = key || msg.encryptedContent.key;

        var keyLen, ivLen, ciphFn;
        switch(cipher) {
          case forge.pki.oids['aes128-CBC']:
            keyLen = 16;
            ivLen = 16;
            ciphFn = forge.aes.createEncryptionCipher;
            break;

          case forge.pki.oids['aes192-CBC']:
            keyLen = 24;
            ivLen = 16;
            ciphFn = forge.aes.createEncryptionCipher;
            break;

          case forge.pki.oids['aes256-CBC']:
            keyLen = 32;
            ivLen = 16;
            ciphFn = forge.aes.createEncryptionCipher;
            break;

          case forge.pki.oids['des-EDE3-CBC']:
            keyLen = 24;
            ivLen = 8;
            ciphFn = forge.des.createEncryptionCipher;
            break;

          default:
            throw new Error('Unsupported symmetric cipher, OID ' + cipher);
        }

        if(key === undefined) {
          key = forge.util.createBuffer(forge.random.getBytes(keyLen));
        } else if(key.length() != keyLen) {
          throw new Error('Symmetric key has wrong length; ' +
            'got ' + key.length() + ' bytes, expected ' + keyLen + '.');
        }

        // Keep a copy of the key & IV in the object, so the caller can
        // use it for whatever reason.
        msg.encryptedContent.algorithm = cipher;
        msg.encryptedContent.key = key;
        msg.encryptedContent.parameter = forge.util.createBuffer(
          forge.random.getBytes(ivLen));

        var ciph = ciphFn(key);
        ciph.start(msg.encryptedContent.parameter.copy());
        ciph.update(msg.content);

        // The finish function does PKCS#7 padding by default, therefore
        // no action required by us.
        if(!ciph.finish()) {
          throw new Error('Symmetric encryption failed.');
        }

        msg.encryptedContent.content = ciph.output;
      }

      // Part 2: asymmetric encryption for each recipient
      for(var i = 0; i < msg.recipients.length; ++i) {
        var recipient = msg.recipients[i];

        // Nothing to do, encryption already done.
        if(recipient.encryptedContent.content !== undefined) {
          continue;
        }

        switch(recipient.encryptedContent.algorithm) {
          case forge.pki.oids.rsaEncryption:
            recipient.encryptedContent.content =
              recipient.encryptedContent.key.encrypt(
                msg.encryptedContent.key.data);
            break;

          default:
            throw new Error('Unsupported asymmetric cipher, OID ' +
              recipient.encryptedContent.algorithm);
        }
      }
    }
  };
  return msg;
};

/**
 * Converts a single recipient from an ASN.1 object.
 *
 * @param obj the ASN.1 RecipientInfo.
 *
 * @return the recipient object.
 */
function _recipientFromAsn1(obj) {
  // validate EnvelopedData content block and capture data
  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
    var error = new Error('Cannot read PKCS#7 RecipientInfo. ' +
      'ASN.1 object is not an PKCS#7 RecipientInfo.');
    error.errors = errors;
    throw error;
  }

  return {
    version: capture.version.charCodeAt(0),
    issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
    serialNumber: forge.util.createBuffer(capture.serial).toHex(),
    encryptedContent: {
      algorithm: asn1.derToOid(capture.encAlgorithm),
      parameter: capture.encParameter.value,
      content: capture.encKey
    }
  };
}

/**
 * Converts a single recipient object to an ASN.1 object.
 *
 * @param obj the recipient object.
 *
 * @return the ASN.1 RecipientInfo.
 */
function _recipientToAsn1(obj) {
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // Version
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      asn1.integerToDer(obj.version).getBytes()),
    // IssuerAndSerialNumber
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // Name
      forge.pki.distinguishedNameToAsn1({attributes: obj.issuer}),
      // Serial
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
        forge.util.hexToBytes(obj.serialNumber))
    ]),
    // KeyEncryptionAlgorithmIdentifier
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // Algorithm
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()),
      // Parameter, force NULL, only RSA supported for now.
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
    ]),
    // EncryptedKey
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,
      obj.encryptedContent.content)
  ]);
}

/**
 * Map a set of RecipientInfo ASN.1 objects to recipient objects.
 *
 * @param infos an array of ASN.1 representations RecipientInfo (i.e. SET OF).
 *
 * @return an array of recipient objects.
 */
function _recipientsFromAsn1(infos) {
  var ret = [];
  for(var i = 0; i < infos.length; ++i) {
    ret.push(_recipientFromAsn1(infos[i]));
  }
  return ret;
}

/**
 * Map an array of recipient objects to ASN.1 RecipientInfo objects.
 *
 * @param recipients an array of recipientInfo objects.
 *
 * @return an array of ASN.1 RecipientInfos.
 */
function _recipientsToAsn1(recipients) {
  var ret = [];
  for(var i = 0; i < recipients.length; ++i) {
    ret.push(_recipientToAsn1(recipients[i]));
  }
  return ret;
}

/**
 * Converts a single signer from an ASN.1 object.
 *
 * @param obj the ASN.1 representation of a SignerInfo.
 *
 * @return the signer object.
 */
function _signerFromAsn1(obj) {
  // validate EnvelopedData content block and capture data
  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, p7.asn1.signerInfoValidator, capture, errors)) {
    var error = new Error('Cannot read PKCS#7 SignerInfo. ' +
      'ASN.1 object is not an PKCS#7 SignerInfo.');
    error.errors = errors;
    throw error;
  }

  var rval = {
    version: capture.version.charCodeAt(0),
    issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
    serialNumber: forge.util.createBuffer(capture.serial).toHex(),
    digestAlgorithm: asn1.derToOid(capture.digestAlgorithm),
    signatureAlgorithm: asn1.derToOid(capture.signatureAlgorithm),
    signature: capture.signature,
    authenticatedAttributes: [],
    unauthenticatedAttributes: []
  };

  // TODO: convert attributes
  var authenticatedAttributes = capture.authenticatedAttributes || [];
  var unauthenticatedAttributes = capture.unauthenticatedAttributes || [];

  return rval;
}

/**
 * Converts a single signerInfo object to an ASN.1 object.
 *
 * @param obj the signerInfo object.
 *
 * @return the ASN.1 representation of a SignerInfo.
 */
function _signerToAsn1(obj) {
  // SignerInfo
  var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // version
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      asn1.integerToDer(obj.version).getBytes()),
    // issuerAndSerialNumber
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // name
      forge.pki.distinguishedNameToAsn1({attributes: obj.issuer}),
      // serial
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
        forge.util.hexToBytes(obj.serialNumber))
    ]),
    // digestAlgorithm
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // algorithm
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(obj.digestAlgorithm).getBytes()),
      // parameters (null)
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
    ])
  ]);

  // authenticatedAttributes (OPTIONAL)
  if(obj.authenticatedAttributesAsn1) {
    // add ASN.1 previously generated during signing
    rval.value.push(obj.authenticatedAttributesAsn1);
  }

  // digestEncryptionAlgorithm
  rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // algorithm
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
      asn1.oidToDer(obj.signatureAlgorithm).getBytes()),
    // parameters (null)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
  ]));

  // encryptedDigest
  rval.value.push(asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.signature));

  // unauthenticatedAttributes (OPTIONAL)
  if(obj.unauthenticatedAttributes.length > 0) {
    // [1] IMPLICIT
    var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
    for(var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
      var attr = obj.unauthenticatedAttributes[i];
      attrsAsn1.values.push(_attributeToAsn1(attr));
    }
    rval.value.push(attrsAsn1);
  }

  return rval;
}

/**
 * Map a set of SignerInfo ASN.1 objects to an array of signer objects.
 *
 * @param signerInfoAsn1s an array of ASN.1 SignerInfos (i.e. SET OF).
 *
 * @return an array of signers objects.
 */
function _signersFromAsn1(signerInfoAsn1s) {
  var ret = [];
  for(var i = 0; i < signerInfoAsn1s.length; ++i) {
    ret.push(_signerFromAsn1(signerInfoAsn1s[i]));
  }
  return ret;
}

/**
 * Map an array of signer objects to ASN.1 objects.
 *
 * @param signers an array of signer objects.
 *
 * @return an array of ASN.1 SignerInfos.
 */
function _signersToAsn1(signers) {
  var ret = [];
  for(var i = 0; i < signers.length; ++i) {
    ret.push(_signerToAsn1(signers[i]));
  }
  return ret;
}

/**
 * Convert an attribute object to an ASN.1 Attribute.
 *
 * @param attr the attribute object.
 *
 * @return the ASN.1 Attribute.
 */
function _attributeToAsn1(attr) {
  var value;

  // TODO: generalize to support more attributes
  if(attr.type === forge.pki.oids.contentType) {
    value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
      asn1.oidToDer(attr.value).getBytes());
  } else if(attr.type === forge.pki.oids.messageDigest) {
    value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,
      attr.value.bytes());
  } else if(attr.type === forge.pki.oids.signingTime) {
    /* Note per RFC 2985: Dates between 1 January 1950 and 31 December 2049
      (inclusive) MUST be encoded as UTCTime. Any dates with year values
      before 1950 or after 2049 MUST be encoded as GeneralizedTime. [Further,]
      UTCTime values MUST be expressed in Greenwich Mean Time (Zulu) and MUST
      include seconds (i.e., times are YYMMDDHHMMSSZ), even where the
      number of seconds is zero.  Midnight (GMT) must be represented as
      "YYMMDD000000Z". */
    // TODO: make these module-level constants
    var jan_1_1950 = new Date('1950-01-01T00:00:00Z');
    var jan_1_2050 = new Date('2050-01-01T00:00:00Z');
    var date = attr.value;
    if(typeof date === 'string') {
      // try to parse date
      var timestamp = Date.parse(date);
      if(!isNaN(timestamp)) {
        date = new Date(timestamp);
      } else if(date.length === 13) {
        // YYMMDDHHMMSSZ (13 chars for UTCTime)
        date = asn1.utcTimeToDate(date);
      } else {
        // assume generalized time
        date = asn1.generalizedTimeToDate(date);
      }
    }

    if(date >= jan_1_1950 && date < jan_1_2050) {
      value = asn1.create(
        asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false,
        asn1.dateToUtcTime(date));
    } else {
      value = asn1.create(
        asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false,
        asn1.dateToGeneralizedTime(date));
    }
  }

  // TODO: expose as common API call
  // create a RelativeDistinguishedName set
  // each value in the set is an AttributeTypeAndValue first
  // containing the type (an OID) and second the value
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // AttributeType
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
      asn1.oidToDer(attr.type).getBytes()),
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
      // AttributeValue
      value
    ])
  ]);
}

/**
 * Map messages encrypted content to ASN.1 objects.
 *
 * @param ec The encryptedContent object of the message.
 *
 * @return ASN.1 representation of the encryptedContent object (SEQUENCE).
 */
function _encryptedContentToAsn1(ec) {
  return [
    // ContentType, always Data for the moment
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
      asn1.oidToDer(forge.pki.oids.data).getBytes()),
    // ContentEncryptionAlgorithmIdentifier
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // Algorithm
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(ec.algorithm).getBytes()),
      // Parameters (IV)
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,
        ec.parameter.getBytes())
    ]),
    // [0] EncryptedContent
    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,
        ec.content.getBytes())
    ])
  ];
}

/**
 * Reads the "common part" of an PKCS#7 content block (in ASN.1 format)
 *
 * This function reads the "common part" of the PKCS#7 content blocks
 * EncryptedData and EnvelopedData, i.e. version number and symmetrically
 * encrypted content block.
 *
 * The result of the ASN.1 validate and capture process is returned
 * to allow the caller to extract further data, e.g. the list of recipients
 * in case of a EnvelopedData object.
 *
 * @param msg the PKCS#7 object to read the data to.
 * @param obj the ASN.1 representation of the content block.
 * @param validator the ASN.1 structure validator object to use.
 *
 * @return the value map captured by validator object.
 */
function _fromAsn1(msg, obj, validator) {
  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, validator, capture, errors)) {
    var error = new Error('Cannot read PKCS#7 message. ' +
      'ASN.1 object is not a supported PKCS#7 message.');
    error.errors = error;
    throw error;
  }

  // Check contentType, so far we only support (raw) Data.
  var contentType = asn1.derToOid(capture.contentType);
  if(contentType !== forge.pki.oids.data) {
    throw new Error('Unsupported PKCS#7 message. ' +
      'Only wrapped ContentType Data supported.');
  }

  if(capture.encryptedContent) {
    var content = '';
    if(forge.util.isArray(capture.encryptedContent)) {
      for(var i = 0; i < capture.encryptedContent.length; ++i) {
        if(capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {
          throw new Error('Malformed PKCS#7 message, expecting encrypted ' +
            'content constructed of only OCTET STRING objects.');
        }
        content += capture.encryptedContent[i].value;
      }
    } else {
      content = capture.encryptedContent;
    }
    msg.encryptedContent = {
      algorithm: asn1.derToOid(capture.encAlgorithm),
      parameter: forge.util.createBuffer(capture.encParameter.value),
      content: forge.util.createBuffer(content)
    };
  }

  if(capture.content) {
    var content = '';
    if(forge.util.isArray(capture.content)) {
      for(var i = 0; i < capture.content.length; ++i) {
        if(capture.content[i].type !== asn1.Type.OCTETSTRING) {
          throw new Error('Malformed PKCS#7 message, expecting ' +
            'content constructed of only OCTET STRING objects.');
        }
        content += capture.content[i].value;
      }
    } else {
      content = capture.content;
    }
    msg.content = forge.util.createBuffer(content);
  }

  msg.version = capture.version.charCodeAt(0);
  msg.rawCapture = capture;

  return capture;
}

/**
 * Decrypt the symmetrically encrypted content block of the PKCS#7 message.
 *
 * Decryption is skipped in case the PKCS#7 message object already has a
 * (decrypted) content attribute.  The algorithm, key and cipher parameters
 * (probably the iv) are taken from the encryptedContent attribute of the
 * message object.
 *
 * @param The PKCS#7 message object.
 */
function _decryptContent(msg) {
  if(msg.encryptedContent.key === undefined) {
    throw new Error('Symmetric key not available.');
  }

  if(msg.content === undefined) {
    var ciph;

    switch(msg.encryptedContent.algorithm) {
      case forge.pki.oids['aes128-CBC']:
      case forge.pki.oids['aes192-CBC']:
      case forge.pki.oids['aes256-CBC']:
        ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);
        break;

      case forge.pki.oids['desCBC']:
      case forge.pki.oids['des-EDE3-CBC']:
        ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);
        break;

      default:
        throw new Error('Unsupported symmetric cipher, OID ' +
          msg.encryptedContent.algorithm);
    }
    ciph.start(msg.encryptedContent.parameter);
    ciph.update(msg.encryptedContent.content);

    if(!ciph.finish()) {
      throw new Error('Symmetric decryption failed.');
    }

    msg.content = ciph.output;
  }
}

      };
    };
  }
}, {package:"node-forge",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pkcs7.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-keychain/src/util.js", {"node-forge/lib/forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","node-forge/lib/x509":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/x509.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-keychain/src/util.js
      return function (require, module, exports) {
'use strict'

require('node-forge/lib/x509')
const forge = require('node-forge/lib/forge')
const pki = forge.pki
exports = module.exports

/**
 * Gets a self-signed X.509 certificate for the key.
 *
 * The output Buffer contains the PKCS #7 message in DER.
 *
 * TODO: move to libp2p-crypto package
 *
 * @param {KeyInfo} key - The id and name of the key
 * @param {RsaPrivateKey} privateKey - The naked key
 * @param {function(Error, Certificate)} callback
 * @returns {undefined}
 */
exports.certificateForKey = (key, privateKey, callback) => {
  const publicKey = pki.setRsaPublicKey(privateKey.n, privateKey.e)
  const cert = pki.createCertificate()
  cert.publicKey = publicKey
  cert.serialNumber = '01'
  cert.validity.notBefore = new Date()
  cert.validity.notAfter = new Date()
  cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 10)
  const attrs = [{
    name: 'organizationName',
    value: 'ipfs'
  }, {
    shortName: 'OU',
    value: 'keystore'
  }, {
    name: 'commonName',
    value: key.id
  }]
  cert.setSubject(attrs)
  cert.setIssuer(attrs)
  cert.setExtensions([{
    name: 'basicConstraints',
    cA: true
  }, {
    name: 'keyUsage',
    keyCertSign: true,
    digitalSignature: true,
    nonRepudiation: true,
    keyEncipherment: true,
    dataEncipherment: true
  }, {
    name: 'extKeyUsage',
    serverAuth: true,
    clientAuth: true,
    codeSigning: true,
    emailProtection: true,
    timeStamping: true
  }, {
    name: 'nsCertType',
    client: true,
    server: true,
    email: true,
    objsign: true,
    sslCA: true,
    emailCA: true,
    objCA: true
  }])
  // self-sign certificate
  cert.sign(privateKey)

  return callback(null, cert)
}

      };
    };
  }
}, {package:"libp2p-keychain",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-keychain/src/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/message/message.proto.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/message/message.proto.js
      return function (require, module, exports) {
'use strict'

// from: https://github.com/ipfs/go-ipfs/blob/master/exchange/bitswap/message/pb/message.proto

module.exports = `
  message Message {
    message Wantlist {
      message Entry {
        // changed from string to bytes, it makes a difference in JavaScript
        optional bytes block = 1;      // the block cid (cidV0 in bitswap 1.0.0, cidV1 in bitswap 1.1.0)
        optional int32 priority = 2;    // the priority (normalized). default to 1
        optional bool cancel = 3;       // whether this revokes an entry
      }

      repeated Entry entries = 1;       // a list of wantlist entries
      optional bool full = 2;           // whether this is the full wantlist. default to false
    }

    message Block {
      optional bytes prefix = 1;        // CID prefix (cid version, multicodec and multihash prefix (type + length)
      optional bytes data = 2;
    }

    optional Wantlist wantlist = 1;
    repeated bytes blocks = 2;          // used to send Blocks in bitswap 1.0.0
    repeated Block payload = 3;         // used to send Blocks in bitswap 1.1.0
  }
`

      };
    };
  }
}, {package:"ipfs-bitswap",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/types/message/message.proto.js",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9zdHJlYW0tdG8tcHVsbC1zdHJlYW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHVsbC1zdHJlYW0vc291cmNlcy92YWx1ZXMuanMiLCJub2RlX21vZHVsZXMvcHVsbC1zdHJlYW0vdGhyb3VnaHMvYXN5bmMtbWFwLmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtc3RyZWFtL3Rocm91Z2hzL2ZsYXR0ZW4uanMiLCJub2RlX21vZHVsZXMvaXBmcy11dGlscy9zcmMvc3VwcG9ydHMuanMiLCJub2RlX21vZHVsZXMvaXBmcy11dGlscy9zcmMvc3RyZWFtcy9zdHJlYW0tZnJvbS1maWxlcmVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXN0cmVhbS91dGlsL3Byb3AuanMiLCJub2RlX21vZHVsZXMvaXBmcy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvaXBmcy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvaXBmcy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy1pdGVyYXRvci10by1zdHJlYW0vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtbWZzL3NyYy9jb3JlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9zbmFwcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3Qvc3ViamVjdC1tZXRhZGF0YS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3Qvc2VydmljZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3Jlc291cmNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9wZXJtaXNzaW9ucy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2sva2V5LXRyZWUvZGlzdC9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2tleS10cmVlL2Rpc3QvQklQNDRDb2luVHlwZU5vZGUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2tleS10cmVlL2Rpc3QvQklQNDROb2RlLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtYWJpL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9zZWNwMjU2azF2My1saWIvZGVyLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLWFiaS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2VjcDI1NmsxdjMtbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzby11cmwvc3JjL3VybC1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lzby11cmwvc3JjL3JlbGF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9ub2RlX21vZHVsZXMvdXVpZC9saWIvcm5nLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtd2FsbGV0L25vZGVfbW9kdWxlcy91dWlkL2xpYi9ieXRlc1RvVXVpZC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvZXRoanMvbGliL2xpYi9nZXRUcmFuc2FjdGlvblN1Y2Nlc3MuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL2JuLmpzL2xpYi9ibi5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvanMtc2hhMy9zcmMvc2hhMy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvZXRoanMvbm9kZV9tb2R1bGVzL2V0aGpzLXV0aWwvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL25vZGVfbW9kdWxlcy9ldGhqcy1hYmkvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL25vZGVfbW9kdWxlcy9ldGhqcy1xdWVyeS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL2V0aGpzLWNvbnRyYWN0L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcG9zdC1tZXNzYWdlLXN0cmVhbS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9wb3N0LW1lc3NhZ2Utc3RyZWFtL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9wb3N0LW1lc3NhZ2Utc3RyZWFtL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9wb3N0LW1lc3NhZ2Utc3RyZWFtL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3Bvc3QtbWVzc2FnZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9pcy10eXBlZGFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ltbWVkaWF0ZS9saWIvbXV0YXRpb24uanMiLCJub2RlX21vZHVsZXMvaW1tZWRpYXRlL2xpYi9tZXNzYWdlQ2hhbm5lbC5qcyIsIm5vZGVfbW9kdWxlcy9pbW1lZGlhdGUvbGliL3N0YXRlQ2hhbmdlLmpzIiwibm9kZV9tb2R1bGVzL2ltbWVkaWF0ZS9saWIvdGltZW91dC5qcyIsIm5vZGVfbW9kdWxlcy9pbW1lZGlhdGUvbGliL25leHRUaWNrLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWtleXN0b3JlL25vZGVfbW9kdWxlcy9kZWZlcnJlZC1sZXZlbGRvd24vZGVmZXJyZWQtaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvZXJybm8vZXJybm8uanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGIta2V5c3RvcmUvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL3F1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFzdG9yZS1jb3JlL3NyYy9rZXl0cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvZGF0YXN0b3JlLWNvcmUvc3JjL25hbWVzcGFjZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhc3RvcmUtY29yZS9zcmMvc2hhcmQuanMiLCJub2RlX21vZHVsZXMvZGF0YXN0b3JlLWNvcmUvc3JjL3NoYXJkaW5nLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFzdG9yZS1jb3JlL3NyYy9tb3VudC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhc3RvcmUtY29yZS9zcmMvdGllcmVkLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL3JlamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhc3RvcmUtbGV2ZWwvbm9kZV9tb2R1bGVzL2VuY29kaW5nLWRvd24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGF0YXN0b3JlLWxldmVsL25vZGVfbW9kdWxlcy9sZXZlbC1qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhc3RvcmUtbGV2ZWwvbm9kZV9tb2R1bGVzL2xldmVsdXAvbGliL2xldmVsdXAuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWNyeXB0by9ub2RlX21vZHVsZXMvbXVsdGloYXNoaW5nLWFzeW5jL3NyYy9jcnlwdG8uanMiLCJub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvY2lwaGVyLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2NpcGhlck1vZGVzLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3NoYTI1Ni5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9wcm5nLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3NoYTEuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWNyeXB0by9zcmMva2V5cy9yc2EtdXRpbHMuanMiLCJub2RlX21vZHVsZXMvcHJvdG9jb2wtYnVmZmVycy1zY2hlbWEvc3RyaW5naWZ5LmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvY29sLWJ1ZmZlcnMtc2NoZW1hL3BhcnNlLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvbnMvc3JjL2NvbXBpbGUvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvbnMvc3JjL2NvbXBpbGUvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvbnMvc3JjL2NvbXBpbGUvZW5jb2RpbmctbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvbnMvc3JjL2NvbXBpbGUvZW5jb2RpbmdzLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1jcnlwdG8vc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtY3J5cHRvL25vZGVfbW9kdWxlcy9saWJwMnAtY3J5cHRvLXNlY3AyNTZrMS9ub2RlX21vZHVsZXMvbXVsdGloYXNoaW5nLWFzeW5jL3NyYy9jcnlwdG8uanMiLCJub2RlX21vZHVsZXMvc2VjcDI1NmsxL2pzLmpzIiwibm9kZV9tb2R1bGVzL2lzLWNpcmN1bGFyL2xpYi9ub2RlLmpzIiwibm9kZV9tb2R1bGVzL2lwbGQtZGFnLXBiL3NyYy9kYWctbm9kZS91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3N0YWJsZS9zdGFibGUuanMiLCJub2RlX21vZHVsZXMvbXVsdGloYXNoaW5nLWFzeW5jL3NyYy9zaGEuYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWhhc2hpbmctYXN5bmMvc3JjL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL211bHRpaGFzaGluZy1hc3luYy9zcmMvYmxha2UuanMiLCJub2RlX21vZHVsZXMvbXVybXVyaGFzaDNqcy1yZXZpc2l0ZWQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXAtcmVnZXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmxha2Vqcy9ibGFrZTJzLmpzIiwibm9kZV9tb2R1bGVzL2JsYWtlanMvYmxha2UyYi5qcyIsIm5vZGVfbW9kdWxlcy9pcy1wcm9taXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb21pc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHVsbC1zdHJlYW0vc2lua3Mvb24tZW5kLmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtc3RyZWFtL3NpbmtzL2xvZy5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXN0cmVhbS9zaW5rcy9maW5kLmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtc3RyZWFtL3NpbmtzL2NvbmNhdC5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXN0cmVhbS9zb3VyY2VzL2NvdW50LmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtc3RyZWFtL3NvdXJjZXMvaW5maW5pdGUuanMiLCJub2RlX21vZHVsZXMvcHVsbC1zdHJlYW0vc291cmNlcy9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXN0cmVhbS9zb3VyY2VzL2Vycm9yLmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtc3RyZWFtL3NvdXJjZXMva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXN0cmVhbS90aHJvdWdocy90aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtc3RyZWFtL3Rocm91Z2hzL3Rha2UuanMiLCJub2RlX21vZHVsZXMvcHVsbC1zdHJlYW0vdGhyb3VnaHMvZmlsdGVyLW5vdC5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXN0cmVhbS90aHJvdWdocy91bmlxdWUuanMiLCJub2RlX21vZHVsZXMvcHVsbC1zdHJlYW0vdGhyb3VnaHMvbm9uLXVuaXF1ZS5qcyIsIm5vZGVfbW9kdWxlcy9pbnRlcmZhY2UtZGF0YXN0b3JlL25vZGVfbW9kdWxlcy91dWlkL3Y0LmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtZGVmZXIvc291cmNlLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL3NvbWVMaW1pdC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhc3RvcmUtcHVic3ViL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zYW5pdGl6ZS1maWxlbmFtZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAta2V5Y2hhaW4vc3JjL2Ntcy5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWJpdHN3YXAvc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWJpdHN3YXAvc3JjL3R5cGVzL21lc3NhZ2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy1iaXRzd2FwL3NyYy90eXBlcy93YW50bGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qdXN0LWRlYm91bmNlLWl0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtYml0c3dhcC9zcmMvZGVjaXNpb24tZW5naW5lL2xlZGdlci5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWJpdHN3YXAvc3JjL3N0YXRzL3N0YXQuanMiLCJub2RlX21vZHVsZXMvaXBmcy1iaXRzd2FwL3NyYy93YW50LW1hbmFnZXIvbXNnLXF1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtbGVuZ3RoLXByZWZpeGVkL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtcmVjb3JkL3NyYy9yZWNvcmQuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXJlY29yZC9zcmMvc2VsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1yZWNvcmQvc3JjL3ZhbGlkYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9pcG5zL3NyYy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9pcG5zL3NyYy9lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvdGltZXN0YW1wLW5hbm8vdGltZXN0YW1wLmpzIiwibm9kZV9tb2R1bGVzL2lwbnMvc3JjL3BiL2lwbnMucHJvdG8uanMiLCJub2RlX21vZHVsZXMvcHVsbC1tcGxleC9zcmMvY29kZWMuanMiLCJub2RlX21vZHVsZXMvcHVsbC1hYm9ydGFibGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHVsbC1tcGxleC9zcmMvbXV4ZXIuanMiLCJub2RlX21vZHVsZXMvcHVsbC1tcGxleC9zcmMvbXBsZXguanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXdlYnNvY2tldHMvc3JjL2xpc3RlbmVyLmpzIiwibm9kZV9tb2R1bGVzL2ludGVyZmFjZS1jb25uZWN0aW9uL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXdzL2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAta2FkLWRodC9zcmMvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1rYWQtZGh0L3NyYy9xdWVyeS1tYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL2ZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy90aW1lb3V0LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1rYWQtZGh0L3NyYy9wcml2YXRlLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1rYWQtZGh0L3NyYy9tZXNzYWdlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1rYWQtZGh0L3NyYy9wcm92aWRlcnMuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWthZC1kaHQvc3JjL3JvdXRpbmcuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWthZC1kaHQvc3JjL3JhbmRvbS13YWxrLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1rYWQtZGh0L3NyYy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAta2FkLWRodC9zcmMvcXVlcnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWthZC1kaHQvc3JjL25ldHdvcmsuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXNlY2lvL3NyYy9zdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtc2VjaW8vc3JjL2hhbmRzaGFrZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtd2Vic29ja2V0LXN0YXIvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Y3N1cHBvcnQvaW5kZXgtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtd2VicnRjLXN0YXIvc3JjL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1wZWVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC9zcmMvZXJyb3JzLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC9zcmMvZ2V0LXBlZXItaW5mby5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAvc3JjL2NvbmZpZy5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAvc3JjL3BlZXItcm91dGluZy5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAvc3JjL2RodC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAvc3JjL3V0aWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGlicDJwL3NyYy9jb250ZW50LXJvdXRpbmcuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXBpbmcvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC9zcmMvcHVic3ViLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1jb25uZWN0aW9uLW1hbmFnZXIvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1zd2l0Y2gvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtZGVmZXIvdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLWRlZmVyL3NpbmsuanMiLCJub2RlX21vZHVsZXMvcHVsbC1kZWZlci9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvYXN5bmMtaXRlcmF0b3ItbGFzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1leHBvcnRlci9zcmMvcmVzb2x2ZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtc3RyZWFtL3V0aWwvYWJvcnQtY2IuanMiLCJub2RlX21vZHVsZXMvcHVsbC1zdHJlYW0vdXRpbC90ZXN0ZXIuanMiLCJub2RlX21vZHVsZXMvaXBmcy11dGlscy9ub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdXRpbHMvbm9kZV9tb2R1bGVzL2lzLXN0cmVhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb29wZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy11dGlscy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtaW1wb3J0ZXIvc3JjL3RyZWUtYnVpbGRlci5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9zcmMvZGFnLWJ1aWxkZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2Vycm9ycy1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RhdGUuanMiLCJub2RlX21vZHVsZXMvaXBmcy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QuanMiLCJub2RlX21vZHVsZXMvaXBmcy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jLWl0ZXJhdG9yLXRvLXN0cmVhbS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvYXN5bmMtaXRlcmF0b3ItdG8tc3RyZWFtL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMiLCJub2RlX21vZHVsZXMvYXN5bmMtaXRlcmF0b3ItdG8tc3RyZWFtL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jLWl0ZXJhdG9yLXRvLXN0cmVhbS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jLWl0ZXJhdG9yLXRvLXN0cmVhbS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy1pdGVyYXRvci10by1zdHJlYW0vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy1pdGVyYXRvci10by1zdHJlYW0vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLW1mcy9zcmMvY29yZS9yZWFkLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtbWZzL3NyYy9jb3JlL2xzLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtbWZzL3NyYy9jb3JlL212LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtbWZzL3NyYy9jb3JlL3N0YXQuanMiLCJub2RlX21vZHVsZXMvaXBmcy1tZnMvc3JjL2NvcmUvZmx1c2guanMiLCJub2RlX21vZHVsZXMvaXBmcy1tZnMvc3JjL2NvcmUvbWtkaXIuanMiLCJub2RlX21vZHVsZXMvaXBmcy1tZnMvc3JjL2NvcmUvcm0uanMiLCJub2RlX21vZHVsZXMvaXBmcy1tZnMvc3JjL2NvcmUvd3JpdGUuanMiLCJub2RlX21vZHVsZXMvaXBmcy1tZnMvc3JjL2NvcmUvY3AuanMiLCJub2RlX21vZHVsZXMvaXBmcy1tZnMvc3JjL2NvcmUvdXRpbHMvY3JlYXRlLWxvY2suanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3NuYXBzL1NuYXBDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9zdWJqZWN0LW1ldGFkYXRhL1N1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3NlcnZpY2VzL0V4ZWN1dGlvbkVudmlyb25tZW50U2VydmljZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3Qvc2VydmljZXMvV2ViV29ya2VyRXhlY3V0aW9uRW52aXJvbm1lbnRTZXJ2aWNlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9yZXNvdXJjZS9FeHRlcm5hbFJlc291cmNlQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3QvcGVybWlzc2lvbnMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3Blcm1pc3Npb25zL1Blcm1pc3Npb24uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3Blcm1pc3Npb25zL0NhdmVhdC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3QvcGVybWlzc2lvbnMvcnBjLW1ldGhvZHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3Blcm1pc3Npb25zL1Blcm1pc3Npb25Db250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9rZXktdHJlZS9kaXN0L3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9rZXktdHJlZS9kaXN0L2Rlcml2YXRpb24uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL2V0aGpzLWFiaS9saWIvdXRpbHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL2V0aGpzLWNvbnRyYWN0L25vZGVfbW9kdWxlcy9ldGhqcy11dGlsL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvZXRoanMtY29udHJhY3Qvbm9kZV9tb2R1bGVzL2V0aGpzLWFiaS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL2V0aGpzLWNvbnRyYWN0L2xpYi9oYXMtdHgtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL25vZGVfbW9kdWxlcy9ldGhqcy1jb250cmFjdC9saWIvY29udHJhY3QuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3Bvc3QtbWVzc2FnZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcG9zdC1tZXNzYWdlLXN0cmVhbS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3Bvc3QtbWVzc2FnZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9wb3N0LW1lc3NhZ2Utc3RyZWFtL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcG9zdC1tZXNzYWdlLXN0cmVhbS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL2Vycm5vL2N1c3RvbS5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1rZXlzdG9yZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGIta2V5c3RvcmUvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1rZXlzdG9yZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1rZXlzdG9yZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWtleXN0b3JlL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGIta2V5c3RvcmUvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGIta2V5c3RvcmUvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9Eb3VibHlMaW5rZWRMaXN0LmpzIiwibm9kZV9tb2R1bGVzL2RhdGFzdG9yZS1jb3JlL3NyYy9zaGFyZC1yZWFkbWUuanMiLCJub2RlX21vZHVsZXMvcHVsbC1tYW55L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL2ZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9sZXZlbC1jb2RlYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhc3RvcmUtbGV2ZWwvbm9kZV9tb2R1bGVzL2xldmVsLWpzL2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFzdG9yZS1sZXZlbC9ub2RlX21vZHVsZXMvbGV2ZWwtanMvbm9kZV9tb2R1bGVzL2Fic3RyYWN0LWxldmVsZG93bi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhc3RvcmUtbGV2ZWwvbm9kZV9tb2R1bGVzL2xldmVsdXAvbGliL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhc3RvcmUtbGV2ZWwvbm9kZV9tb2R1bGVzL2xldmVsdXAvbGliL3Byb21pc2lmeS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhc3RvcmUtbGV2ZWwvbm9kZV9tb2R1bGVzL2xldmVsdXAvbGliL2JhdGNoLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFzdG9yZS1sZXZlbC9ub2RlX21vZHVsZXMvZGVmZXJyZWQtbGV2ZWxkb3duL2RlZmVycmVkLWxldmVsZG93bi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhc3RvcmUtbGV2ZWwvbm9kZV9tb2R1bGVzL2xldmVsLWl0ZXJhdG9yLXN0cmVhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtY3J5cHRvL25vZGVfbW9kdWxlcy9tdWx0aWhhc2hpbmctYXN5bmMvc3JjL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1jcnlwdG8vbm9kZV9tb2R1bGVzL211bHRpaGFzaGluZy1hc3luYy9zcmMvY3J5cHRvLXNoYTEtMi1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1jcnlwdG8vbm9kZV9tb2R1bGVzL211bHRpaGFzaGluZy1hc3luYy9zcmMvYmxha2UuanMiLCJub2RlX21vZHVsZXMvcHJvdG9jb2wtYnVmZmVycy1zY2hlbWEvdG9rZW5pemUuanMiLCJub2RlX21vZHVsZXMvcHJvdG9ucy9zcmMvY29tcGlsZS91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9zaWduZWQtdmFyaW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvY29uc3RhbnRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvYXBpLmpzIiwibm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZGVjb2RlcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWNyeXB0by9ub2RlX21vZHVsZXMvbGlicDJwLWNyeXB0by1zZWNwMjU2azEvbm9kZV9tb2R1bGVzL211bHRpaGFzaGluZy1hc3luYy9zcmMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWNyeXB0by9ub2RlX21vZHVsZXMvbGlicDJwLWNyeXB0by1zZWNwMjU2azEvbm9kZV9tb2R1bGVzL211bHRpaGFzaGluZy1hc3luYy9zcmMvY3J5cHRvLXNoYTEtMi1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1jcnlwdG8vbm9kZV9tb2R1bGVzL2xpYnAycC1jcnlwdG8tc2VjcDI1NmsxL25vZGVfbW9kdWxlcy9tdWx0aWhhc2hpbmctYXN5bmMvc3JjL2JsYWtlLmpzIiwibm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9saWIvanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXVybXVyaGFzaDNqcy1yZXZpc2l0ZWQvbGliL211cm11ckhhc2gzanMuanMiLCJub2RlX21vZHVsZXMvYmxha2Vqcy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2ludGVyZmFjZS1kYXRhc3RvcmUvbm9kZV9tb2R1bGVzL3V1aWQvbGliL3JuZy1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2ludGVyZmFjZS1kYXRhc3RvcmUvbm9kZV9tb2R1bGVzL3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFzdG9yZS1wdWJzdWIvc3JjL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3RydW5jYXRlLXV0ZjgtYnl0ZXMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9kZXRlY3QuanMiLCJub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGtjczcuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWtleWNoYWluL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtYml0c3dhcC9zcmMvdHlwZXMvbWVzc2FnZS9tZXNzYWdlLnByb3RvLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN4ckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNubUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDOU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN6bkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbjJHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN2ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzkrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDcFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3YrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3JTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6Q0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JDQTtBQUNBOzs7Ozs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzdsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVnQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEdBO0FBQ0E7Ozs7Ozs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3hyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25tQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNudUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwSEE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDem5DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDMU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ2hhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMzTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUpBO0FBQ0E7Ozs7Ozs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbm1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDblBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDcmtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6dUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJiYWNrZ3JvdW5kLTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3B1bGwnKVxudmFyIGxvb3BlciA9IHJlcXVpcmUoJ2xvb3BlcicpXG5cbmZ1bmN0aW9uIGRlc3Ryb3kgKHN0cmVhbSkge1xuICBpZighc3RyZWFtLmRlc3Ryb3kpXG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgICd3YXJuaW5nLCBzdHJlYW0tdG8tcHVsbC1zdHJlYW06IFxcbidcbiAgICArICd0aGUgd3JhcHBlZCBub2RlLXN0cmVhbSBkb2VzIG5vdCBpbXBsZW1lbnQgYGRlc3Ryb3lgLCBcXG4nXG4gICAgKyAndGhpcyBtYXkgY2F1c2UgcmVzb3VyY2UgbGVha3MuJ1xuICAgIClcbiAgZWxzZSBzdHJlYW0uZGVzdHJveSgpXG5cbn1cblxuZnVuY3Rpb24gd3JpdGUocmVhZCwgc3RyZWFtLCBjYikge1xuICB2YXIgZW5kZWQsIGNsb3NlZCA9IGZhbHNlLCBkaWRcbiAgZnVuY3Rpb24gZG9uZSAoKSB7XG4gICAgaWYoZGlkKSByZXR1cm5cbiAgICBkaWQgPSB0cnVlXG4gICAgY2IgJiYgY2IoZW5kZWQgPT09IHRydWUgPyBudWxsIDogZW5kZWQpXG4gIH1cblxuICBmdW5jdGlvbiBvbkNsb3NlICgpIHtcbiAgICBpZihjbG9zZWQpIHJldHVyblxuICAgIGNsb3NlZCA9IHRydWVcbiAgICBjbGVhbnVwKClcbiAgICBpZighZW5kZWQpIHJlYWQoZW5kZWQgPSB0cnVlLCBkb25lKVxuICAgIGVsc2UgICAgICAgZG9uZSgpXG4gIH1cbiAgZnVuY3Rpb24gb25FcnJvciAoZXJyKSB7XG4gICAgY2xlYW51cCgpXG4gICAgaWYoIWVuZGVkKSByZWFkKGVuZGVkID0gZXJyLCBkb25lKVxuICB9XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc3RyZWFtLm9uKCdmaW5pc2gnLCBvbkNsb3NlKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbkNsb3NlKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKVxuICB9XG4gIHN0cmVhbS5vbignY2xvc2UnLCBvbkNsb3NlKVxuICBzdHJlYW0ub24oJ2ZpbmlzaCcsIG9uQ2xvc2UpXG4gIHN0cmVhbS5vbignZXJyb3InLCBvbkVycm9yKVxuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBsb29wZXIoZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJlYWQobnVsbCwgZnVuY3Rpb24gKGVuZCwgZGF0YSkge1xuICAgICAgICBlbmRlZCA9IGVuZGVkIHx8IGVuZFxuICAgICAgICAvL3lvdSBjYW4ndCBcImVuZFwiIGEgc3Rkb3V0IHN0cmVhbSwgc28gdGhpcyBuZWVkcyB0byBiZSBoYW5kbGVkIHNwZWNpYWxseS5cbiAgICAgICAgaWYoZW5kID09PSB0cnVlKVxuICAgICAgICAgIHJldHVybiBzdHJlYW0uX2lzU3RkaW8gPyBkb25lKCkgOiBzdHJlYW0uZW5kKClcblxuICAgICAgICBpZihlbmRlZCA9IGVuZGVkIHx8IGVuZCkge1xuICAgICAgICAgIGRlc3Ryb3koc3RyZWFtKVxuICAgICAgICAgIHJldHVybiBkb25lKGVuZGVkKVxuICAgICAgICB9XG5cbiAgICAgICAgLy9JIG5vdGljZWQgYSBwcm9ibGVtIHN0cmVhbWluZyB0byB0aGUgdGVybWluYWw6XG4gICAgICAgIC8vc29tZXRpbWVzIHRoZSBlbmQgZ290IGN1dCBvZmYsIGNyZWF0aW5nIGludmFsaWQgb3V0cHV0LlxuICAgICAgICAvL2l0IHNlZW1zIHRoYXQgc3Rkb3V0IGFsd2F5cyBlbWl0cyBcImRyYWluXCIgd2hlbiBpdCBlbmRzLlxuICAgICAgICAvL3NvIHRoaXMgc2VlbXMgdG8gd29yaywgYnV0IGkgaGF2ZSBiZWVuIHVuYWJsZSB0byByZXByb2R1Y2UgdGhpcyB0ZXN0XG4gICAgICAgIC8vYXV0b21hdGljYWxseSwgc28geW91IG5lZWQgdG8gcnVuIC4vdGVzdC9zdGRvdXQuanMgYSBmZXcgdGltZXMgYW5kIHRoZSBlbmQgaXMgdmFsaWQganNvbi5cbiAgICAgICAgaWYoc3RyZWFtLl9pc1N0ZGlvKVxuICAgICAgICAgIHN0cmVhbS53cml0ZShkYXRhLCBmdW5jdGlvbiAoKSB7IG5leHQoKSB9KVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcGF1c2UgPSBzdHJlYW0ud3JpdGUoZGF0YSlcbiAgICAgICAgICBpZihwYXVzZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICBzdHJlYW0ub25jZSgnZHJhaW4nLCBuZXh0KVxuICAgICAgICAgIGVsc2UgbmV4dCgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gZmlyc3QgKGVtaXR0ZXIsIGV2ZW50cywgaGFuZGxlcikge1xuICBmdW5jdGlvbiBsaXN0ZW5lciAodmFsKSB7XG4gICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoZSwgbGlzdGVuZXIpXG4gICAgfSlcbiAgICBoYW5kbGVyKHZhbClcbiAgfVxuICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgIGVtaXR0ZXIub24oZSwgbGlzdGVuZXIpXG4gIH0pXG4gIHJldHVybiBlbWl0dGVyXG59XG5cbmZ1bmN0aW9uIHJlYWQyKHN0cmVhbSkge1xuICB2YXIgZW5kZWQgPSBmYWxzZSwgd2FpdGluZyA9IGZhbHNlXG4gIHZhciBfY2JcblxuICBmdW5jdGlvbiByZWFkICgpIHtcbiAgICB2YXIgZGF0YSA9IHN0cmVhbS5yZWFkKClcbiAgICBpZihkYXRhICE9PSBudWxsICYmIF9jYikge1xuICAgICAgdmFyIGNiID0gX2NiOyBfY2IgPSBudWxsXG4gICAgICBjYihudWxsLCBkYXRhKVxuICAgIH1cbiAgfVxuXG4gIHN0cmVhbS5vbigncmVhZGFibGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgd2FpdGluZyA9IHRydWVcbiAgICBfY2IgJiYgcmVhZCgpXG4gIH0pXG4gIC5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGVuZGVkID0gdHJ1ZVxuICAgIF9jYiAmJiBfY2IoZW5kZWQpXG4gIH0pXG4gIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgZW5kZWQgPSBlcnJcbiAgICBfY2IgJiYgX2NiKGVuZGVkKVxuICB9KVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZW5kLCBjYikge1xuICAgIF9jYiA9IGNiXG4gICAgaWYoZW5kZWQpXG4gICAgICBjYihlbmRlZClcbiAgICBlbHNlIGlmKHdhaXRpbmcpXG4gICAgICByZWFkKClcbiAgfVxufVxuXG5mdW5jdGlvbiByZWFkMShzdHJlYW0pIHtcbiAgdmFyIGJ1ZmZlciA9IFtdLCBjYnMgPSBbXSwgZW5kZWQsIHBhdXNlZCA9IGZhbHNlXG5cbiAgdmFyIGRyYWluaW5nXG4gIGZ1bmN0aW9uIGRyYWluKCkge1xuICAgIHdoaWxlKChidWZmZXIubGVuZ3RoIHx8IGVuZGVkKSAmJiBjYnMubGVuZ3RoKVxuICAgICAgY2JzLnNoaWZ0KCkoYnVmZmVyLmxlbmd0aCA/IG51bGwgOiBlbmRlZCwgYnVmZmVyLnNoaWZ0KCkpXG4gICAgaWYoIWJ1ZmZlci5sZW5ndGggJiYgKHBhdXNlZCkpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlXG4gICAgICBzdHJlYW0ucmVzdW1lKClcbiAgICB9XG4gIH1cblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGJ1ZmZlci5wdXNoKGRhdGEpXG4gICAgZHJhaW4oKVxuICAgIGlmKGJ1ZmZlci5sZW5ndGggJiYgc3RyZWFtLnBhdXNlKSB7XG4gICAgICBwYXVzZWQgPSB0cnVlXG4gICAgICBzdHJlYW0ucGF1c2UoKVxuICAgIH1cbiAgfSlcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZW5kZWQgPSB0cnVlXG4gICAgZHJhaW4oKVxuICB9KVxuICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGRyYWluKClcbiAgfSlcbiAgc3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBlbmRlZCA9IGVyclxuICAgIGRyYWluKClcbiAgfSlcbiAgcmV0dXJuIGZ1bmN0aW9uIChhYm9ydCwgY2IpIHtcbiAgICBpZighY2IpIHRocm93IG5ldyBFcnJvcignKm11c3QqIHByb3ZpZGUgY2InKVxuICAgIGlmKGFib3J0KSB7XG4gICAgICBmdW5jdGlvbiBvbkFib3J0ICgpIHtcbiAgICAgICAgd2hpbGUoY2JzLmxlbmd0aCkgY2JzLnNoaWZ0KCkoYWJvcnQpXG4gICAgICAgIGNiKGFib3J0KVxuICAgICAgfVxuICAgICAgLy9pZiB0aGUgc3RyZWFtIGhhcHBlbnMgdG8gaGF2ZSBhbHJlYWR5IGVuZGVkLCB0aGVuIHdlIGRvbid0IG5lZWQgdG8gYWJvcnQuXG4gICAgICBpZihlbmRlZCkgcmV0dXJuIG9uQWJvcnQoKVxuICAgICAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgb25BYm9ydClcbiAgICAgIGRlc3Ryb3koc3RyZWFtKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNicy5wdXNoKGNiKVxuICAgICAgZHJhaW4oKVxuICAgIH1cbiAgfVxufVxuXG52YXIgcmVhZCA9IHJlYWQxXG5cbnZhciBzaW5rID0gZnVuY3Rpb24gKHN0cmVhbSwgY2IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZWFkKSB7XG4gICAgcmV0dXJuIHdyaXRlKHJlYWQsIHN0cmVhbSwgY2IpXG4gIH1cbn1cblxudmFyIHNvdXJjZSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgcmV0dXJuIHJlYWQxKHN0cmVhbSlcbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cmVhbSwgY2IpIHtcbiAgcmV0dXJuIChcbiAgICAoc3RyZWFtLndyaXRhYmxlICYmIHN0cmVhbS53cml0ZSlcbiAgICA/IHN0cmVhbS5yZWFkYWJsZVxuICAgICAgPyBmdW5jdGlvbihfcmVhZCkge1xuICAgICAgICAgIHdyaXRlKF9yZWFkLCBzdHJlYW0sIGNiKTtcbiAgICAgICAgICByZXR1cm4gcmVhZDEoc3RyZWFtKVxuICAgICAgICB9XG4gICAgICA6IHNpbmsoc3RyZWFtLCBjYilcbiAgICA6IHNvdXJjZShzdHJlYW0pXG4gIClcbn1cblxuZXhwb3J0cy5zaW5rID0gc2lua1xuZXhwb3J0cy5zb3VyY2UgPSBzb3VyY2VcbmV4cG9ydHMucmVhZCA9IHJlYWRcbmV4cG9ydHMucmVhZDEgPSByZWFkMVxuZXhwb3J0cy5yZWFkMiA9IHJlYWQyXG5leHBvcnRzLmR1cGxleCA9IGZ1bmN0aW9uIChzdHJlYW0sIGNiKSB7XG4gIHJldHVybiB7XG4gICAgc291cmNlOiBzb3VyY2Uoc3RyZWFtKSxcbiAgICBzaW5rOiBzaW5rKHN0cmVhbSwgY2IpXG4gIH1cbn1cbmV4cG9ydHMudHJhbnNmb3JtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlYWQpIHtcbiAgICB2YXIgX3NvdXJjZSA9IHNvdXJjZShzdHJlYW0pXG4gICAgc2luayhzdHJlYW0pKHJlYWQpOyByZXR1cm4gX3NvdXJjZVxuICB9XG59XG5cblxuXG5cblxuXG5cblxuXG4iLCIndXNlIHN0cmljdCdcbnZhciBhYm9ydENiID0gcmVxdWlyZSgnLi4vdXRpbC9hYm9ydC1jYicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsdWVzIChhcnJheSwgb25BYm9ydCkge1xuICBpZighYXJyYXkpXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhYm9ydCwgY2IpIHtcbiAgICAgIGlmKGFib3J0KSByZXR1cm4gYWJvcnRDYihjYiwgYWJvcnQsIG9uQWJvcnQpXG4gICAgICByZXR1cm4gY2IodHJ1ZSlcbiAgICB9XG4gIGlmKCFBcnJheS5pc0FycmF5KGFycmF5KSlcbiAgICBhcnJheSA9IE9iamVjdC5rZXlzKGFycmF5KS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgIHJldHVybiBhcnJheVtrXVxuICAgIH0pXG4gIHZhciBpID0gMFxuICByZXR1cm4gZnVuY3Rpb24gKGFib3J0LCBjYikge1xuICAgIGlmKGFib3J0KVxuICAgICAgcmV0dXJuIGFib3J0Q2IoY2IsIGFib3J0LCBvbkFib3J0KVxuICAgIGlmKGkgPj0gYXJyYXkubGVuZ3RoKVxuICAgICAgY2IodHJ1ZSlcbiAgICBlbHNlXG4gICAgICBjYihudWxsLCBhcnJheVtpKytdKVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuZnVuY3Rpb24gaWQgKGUpIHsgcmV0dXJuIGUgfVxudmFyIHByb3AgPSByZXF1aXJlKCcuLi91dGlsL3Byb3AnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFzeW5jTWFwIChtYXApIHtcbiAgaWYoIW1hcCkgcmV0dXJuIGlkXG4gIG1hcCA9IHByb3AobWFwKVxuICB2YXIgYnVzeSA9IGZhbHNlLCBhYm9ydENiLCBhYm9ydGVkXG4gIHJldHVybiBmdW5jdGlvbiAocmVhZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0IChhYm9ydCwgY2IpIHtcbiAgICAgIGlmKGFib3J0ZWQpIHJldHVybiBjYihhYm9ydGVkKVxuICAgICAgaWYoYWJvcnQpIHtcbiAgICAgICAgYWJvcnRlZCA9IGFib3J0XG4gICAgICAgIGlmKCFidXN5KSByZWFkKGFib3J0LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgLy9pbmNhc2UgdGhlIHNvdXJjZSBoYXMgYWxyZWFkeSBlbmRlZCBub3JtYWxseSxcbiAgICAgICAgICAvL3dlIHNob3VsZCBwYXNzIG91ciBvd24gZXJyb3IuXG4gICAgICAgICAgY2IoYWJvcnQpXG4gICAgICAgIH0pXG4gICAgICAgIGVsc2UgcmVhZChhYm9ydCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIC8vaWYgd2UgYXJlIHN0aWxsIGJ1c3ksIHdhaXQgZm9yIHRoZSBtYXBwZXIgdG8gY29tcGxldGUuXG4gICAgICAgICAgaWYoYnVzeSkgYWJvcnRDYiA9IGNiXG4gICAgICAgICAgZWxzZSBjYihhYm9ydClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgcmVhZChudWxsLCBmdW5jdGlvbiAoZW5kLCBkYXRhKSB7XG4gICAgICAgICAgaWYoZW5kKSBjYihlbmQpXG4gICAgICAgICAgZWxzZSBpZihhYm9ydGVkKSBjYihhYm9ydGVkKVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnVzeSA9IHRydWVcbiAgICAgICAgICAgIG1hcChkYXRhLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICAgIGJ1c3kgPSBmYWxzZVxuICAgICAgICAgICAgICBpZihhYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgY2IoYWJvcnRlZClcbiAgICAgICAgICAgICAgICBhYm9ydENiICYmIGFib3J0Q2IoYWJvcnRlZClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmKGVycikgbmV4dCAoZXJyLCBjYilcbiAgICAgICAgICAgICAgZWxzZSBjYihudWxsLCBkYXRhKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cblxuXG5cblxuXG5cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgdmFsdWVzID0gcmVxdWlyZSgnLi4vc291cmNlcy92YWx1ZXMnKVxudmFyIG9uY2UgPSByZXF1aXJlKCcuLi9zb3VyY2VzL29uY2UnKVxuXG4vL2NvbnZlcnQgYSBzdHJlYW0gb2YgYXJyYXlzIG9yIHN0cmVhbXMgaW50byBqdXN0IGEgc3RyZWFtLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmbGF0dGVuICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZWFkKSB7XG4gICAgdmFyIF9yZWFkXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhYm9ydCwgY2IpIHtcbiAgICAgIGlmIChhYm9ydCkgeyAvL2Fib3J0IHRoZSBjdXJyZW50IHN0cmVhbSwgYW5kIHRoZW4gc3RyZWFtIG9mIHN0cmVhbXMuXG4gICAgICAgIF9yZWFkID8gX3JlYWQoYWJvcnQsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHJlYWQoZXJyIHx8IGFib3J0LCBjYilcbiAgICAgICAgfSkgOiByZWFkKGFib3J0LCBjYilcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYoX3JlYWQpIG5leHRDaHVuaygpXG4gICAgICBlbHNlIG5leHRTdHJlYW0oKVxuXG4gICAgICBmdW5jdGlvbiBuZXh0Q2h1bmsgKCkge1xuICAgICAgICBfcmVhZChudWxsLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgICAgaWYgKGVyciA9PT0gdHJ1ZSkgbmV4dFN0cmVhbSgpXG4gICAgICAgICAgZWxzZSBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZWFkKHRydWUsIGZ1bmN0aW9uKGFib3J0RXJyKSB7XG4gICAgICAgICAgICAgIC8vIFRPRE86IHdoYXQgZG8gd2UgZG8gd2l0aCB0aGUgYWJvcnRFcnI/XG4gICAgICAgICAgICAgIGNiKGVycilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgY2IobnVsbCwgZGF0YSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG5leHRTdHJlYW0gKCkge1xuICAgICAgICBfcmVhZCA9IG51bGxcbiAgICAgICAgcmVhZChudWxsLCBmdW5jdGlvbiAoZW5kLCBzdHJlYW0pIHtcbiAgICAgICAgICBpZihlbmQpXG4gICAgICAgICAgICByZXR1cm4gY2IoZW5kKVxuICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkoc3RyZWFtKSB8fCBzdHJlYW0gJiYgJ29iamVjdCcgPT09IHR5cGVvZiBzdHJlYW0pXG4gICAgICAgICAgICBzdHJlYW0gPSB2YWx1ZXMoc3RyZWFtKVxuICAgICAgICAgIGVsc2UgaWYoJ2Z1bmN0aW9uJyAhPSB0eXBlb2Ygc3RyZWFtKVxuICAgICAgICAgICAgc3RyZWFtID0gb25jZShzdHJlYW0pXG4gICAgICAgICAgX3JlYWQgPSBzdHJlYW1cbiAgICAgICAgICBuZXh0Q2h1bmsoKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN1cHBvcnRzRmlsZVJlYWRlcjogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICdGaWxlUmVhZGVyJyBpbiBzZWxmXG59XG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IHsgUmVhZGFibGUgfSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5jb25zdCB7IHN1cHBvcnRzRmlsZVJlYWRlciB9ID0gcmVxdWlyZSgnLi4vc3VwcG9ydHMnKVxuXG5jb25zdCBzdHJlYW1Gcm9tRmlsZVJlYWRlciA9IChmaWxlLCBvcHRpb25zKSA9PiB7XG4gIGlmICghc3VwcG9ydHNGaWxlUmVhZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaWxlUmVhZGVyIERPTSBBUEkgaXMgbm90IHN1cHBvcnRlZC4nKVxuICB9XG4gIGNsYXNzIEZpbGVTdHJlYW0gZXh0ZW5kcyBSZWFkYWJsZSB7XG4gICAgY29uc3RydWN0b3IgKGZpbGUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgc3VwZXIob3B0aW9ucylcbiAgICAgIHRoaXMuZmlsZSA9IGZpbGVcbiAgICAgIHRoaXMub2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQgfHwgMFxuICAgICAgdGhpcy5jaHVua1NpemUgPSBvcHRpb25zLmNodW5rU2l6ZSB8fCAxMDI0ICogMTAyNFxuICAgICAgdGhpcy5maWxlUmVhZGVyID0gbmV3IHNlbGYuRmlsZVJlYWRlcihmaWxlKVxuICAgICAgdGhpcy5maWxlUmVhZGVyLm9ubG9hZGVuZCA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gZXZlbnQudGFyZ2V0LnJlc3VsdFxuICAgICAgICBpZiAoZGF0YS5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wdXNoKG51bGwpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdXNoKG5ldyBVaW50OEFycmF5KGRhdGEpKVxuICAgICAgfVxuICAgICAgdGhpcy5maWxlUmVhZGVyLm9uZXJyb3IgPSAoZXJyKSA9PiB0aGlzLmRlc3Ryb3koZXJyKVxuICAgIH1cblxuICAgIF9yZWFkIChzaXplKSB7XG4gICAgICBjb25zdCBlbmQgPSB0aGlzLm9mZnNldCArIHRoaXMuY2h1bmtTaXplXG4gICAgICBjb25zdCBzbGljZSA9IGZpbGUuc2xpY2UodGhpcy5vZmZzZXQsIGVuZClcbiAgICAgIHRoaXMuZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihzbGljZSlcbiAgICAgIHRoaXMub2Zmc2V0ID0gZW5kXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBGaWxlU3RyZWFtKGZpbGUsIG9wdGlvbnMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyZWFtRnJvbUZpbGVSZWFkZXJcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHN1cGVyc3RydWN0IH0gPSByZXF1aXJlKCdzdXBlcnN0cnVjdCcpXG5jb25zdCBkYWdCdWlsZGVyID0gcmVxdWlyZSgnLi9kYWctYnVpbGRlcicpXG5jb25zdCB0cmVlQnVpbGRlciA9IHJlcXVpcmUoJy4vdHJlZS1idWlsZGVyJylcbmNvbnN0IG1oID0gcmVxdWlyZSgnbXVsdGloYXNoZXMnKVxuXG5jb25zdCBzdHJ1Y3QgPSBzdXBlcnN0cnVjdCh7XG4gIHR5cGVzOiB7XG4gICAgY29kZWM6IHYgPT4gWydkYWctcGInLCAnZGFnLWNib3InLCAncmF3J10uaW5jbHVkZXModiksXG4gICAgaGFzaEFsZzogdiA9PiBPYmplY3Qua2V5cyhtaC5uYW1lcykuaW5jbHVkZXModiksXG4gICAgbGVhZlR5cGU6IHYgPT4gWydmaWxlJywgJ3JhdyddLmluY2x1ZGVzKHYpXG4gIH1cbn0pXG5cbmNvbnN0IENodW5rZXJPcHRpb25zID0gc3RydWN0KHtcbiAgbWluQ2h1bmtTaXplOiAnbnVtYmVyPycsXG4gIG1heENodW5rU2l6ZTogJ251bWJlcj8nLFxuICBhdmdDaHVua1NpemU6ICdudW1iZXI/JyxcbiAgd2luZG93OiAnbnVtYmVyPycsXG4gIHBvbHlub21pYWw6ICdudW1iZXI/J1xufSwge1xuICBtYXhDaHVua1NpemU6IDI2MjE0NCxcbiAgYXZnQ2h1bmtTaXplOiAyNjIxNDQsXG4gIHdpbmRvdzogMTYsXG4gIHBvbHlub21pYWw6IDE3NDM3MTgwMTMyNzYzNjUzIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pcGZzL2dvLWlwZnMtY2h1bmtlci9ibG9iL2QwMTI1ODMyNTEyMTYzNzA4YzA4MDRhM2NkYTA2MGUyMWFjZGRhZTQvcmFiaW4uZ28jTDExXG59KVxuXG5jb25zdCBCdWlsZGVyT3B0aW9ucyA9IHN0cnVjdCh7XG4gIG1heENoaWxkcmVuUGVyTm9kZTogJ251bWJlcj8nLFxuICBsYXllclJlcGVhdDogJ251bWJlcj8nXG59LCB7XG4gIG1heENoaWxkcmVuUGVyTm9kZTogMTc0LFxuICBsYXllclJlcGVhdDogNFxufSlcblxuY29uc3QgT3B0aW9ucyA9IHN0cnVjdCh7XG4gIGNodW5rZXI6IHN0cnVjdC5lbnVtKFsnZml4ZWQnLCAncmFiaW4nXSksXG4gIHJhd0xlYXZlczogJ2Jvb2xlYW4/JyxcbiAgaGFzaE9ubHk6ICdib29sZWFuPycsXG4gIHN0cmF0ZWd5OiBzdHJ1Y3QuZW51bShbJ2JhbGFuY2VkJywgJ2ZsYXQnLCAndHJpY2tsZSddKSxcbiAgcmVkdWNlU2luZ2xlTGVhZlRvU2VsZjogJ2Jvb2xlYW4/JyxcbiAgY29kZWM6ICdjb2RlYz8nLFxuICBmb3JtYXQ6ICdjb2RlYz8nLFxuICBoYXNoQWxnOiAnaGFzaEFsZz8nLFxuICBsZWFmVHlwZTogJ2xlYWZUeXBlPycsXG4gIGNpZFZlcnNpb246ICdudW1iZXI/JyxcbiAgcHJvZ3Jlc3M6ICdmdW5jdGlvbj8nLFxuICB3cmFwV2l0aERpcmVjdG9yeTogJ2Jvb2xlYW4/JyxcbiAgc2hhcmRTcGxpdFRocmVzaG9sZDogJ251bWJlcj8nLFxuICBvbmx5SGFzaDogJ2Jvb2xlYW4/JyxcbiAgY2h1bmtlck9wdGlvbnM6IENodW5rZXJPcHRpb25zLFxuICBidWlsZGVyT3B0aW9uczogQnVpbGRlck9wdGlvbnMsXG5cbiAgd3JhcDogJ2Jvb2xlYW4/JyxcbiAgcGluOiAnYm9vbGVhbj8nLFxuICByZWN1cnNpdmU6ICdib29sZWFuPycsXG4gIGlnbm9yZTogJ2FycmF5PycsXG4gIGhpZGRlbjogJ2Jvb2xlYW4/JyxcbiAgcHJlbG9hZDogJ2Jvb2xlYW4/J1xufSwge1xuICBjaHVua2VyOiAnZml4ZWQnLFxuICBzdHJhdGVneTogJ2JhbGFuY2VkJyxcbiAgcmF3TGVhdmVzOiBmYWxzZSxcbiAgcmVkdWNlU2luZ2xlTGVhZlRvU2VsZjogdHJ1ZSxcbiAgY29kZWM6ICdkYWctcGInLFxuICBoYXNoQWxnOiAnc2hhMi0yNTYnLFxuICBsZWFmVHlwZTogJ2ZpbGUnLFxuICBjaWRWZXJzaW9uOiAwLFxuICBwcm9ncmVzczogKCkgPT4gKCkgPT4ge30sXG4gIHNoYXJkU3BsaXRUaHJlc2hvbGQ6IDEwMDBcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gYXN5bmMgZnVuY3Rpb24gKiAoc291cmNlLCBpcGxkLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qgb3B0cyA9IE9wdGlvbnMob3B0aW9ucylcblxuICBpZiAob3B0aW9ucy5jaWRWZXJzaW9uID4gMCAmJiBvcHRpb25zLnJhd0xlYXZlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gaWYgdGhlIGNpZCB2ZXJzaW9uIGlzIDEgb3IgYWJvdmUsIHVzZSByYXcgbGVhdmVzIGFzIHRoaXMgaXNcbiAgICAvLyB3aGF0IGdvIGRvZXMuXG4gICAgb3B0cy5yYXdMZWF2ZXMgPSB0cnVlXG4gIH1cblxuICBpZiAob3B0aW9ucy5oYXNoQWxnICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yYXdMZWF2ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGlmIGEgbm9uLWRlZmF1bHQgaGFzaCBhbGcgaGFzIGJlZW4gc3BlY2lmaWVkLCB1c2UgcmF3IGxlYXZlcyBhcyB0aGlzIGlzXG4gICAgLy8gd2hhdCBnbyBkb2VzLlxuICAgIG9wdHMucmF3TGVhdmVzID0gdHJ1ZVxuICB9XG5cbiAgLy8gZ28taWZwcyB0cmlja2xlIGRhZyBkZWZhdWx0cyB0byB1bml4ZnMgcmF3IGxlYXZlcywgYmFsYW5jZWQgZGFnIGRlZmF1bHRzIHRvIGZpbGUgbGVhdmVzXG4gIGlmIChvcHRpb25zLnN0cmF0ZWd5ID09PSAndHJpY2tsZScpIHtcbiAgICBvcHRzLmxlYWZUeXBlID0gJ3JhdydcbiAgICBvcHRzLnJlZHVjZVNpbmdsZUxlYWZUb1NlbGYgPSBmYWxzZVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuZm9ybWF0KSB7XG4gICAgb3B0aW9ucy5jb2RlYyA9IG9wdGlvbnMuZm9ybWF0XG4gIH1cblxuICBmb3IgYXdhaXQgKGNvbnN0IGVudHJ5IG9mIHRyZWVCdWlsZGVyKGRhZ0J1aWxkZXIoc291cmNlLCBpcGxkLCBvcHRzKSwgaXBsZCwgb3B0cykpIHtcbiAgICB5aWVsZCB7XG4gICAgICBjaWQ6IGVudHJ5LmNpZCxcbiAgICAgIHBhdGg6IGVudHJ5LnBhdGgsXG4gICAgICB1bml4ZnM6IGVudHJ5LnVuaXhmcyxcbiAgICAgIHNpemU6IGVudHJ5LnNpemVcbiAgICB9XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHJvcCAoa2V5KSB7XG4gIHJldHVybiBrZXkgJiYgKFxuICAgICdzdHJpbmcnID09IHR5cGVvZiBrZXlcbiAgICA/IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhW2tleV0gfVxuICAgIDogJ29iamVjdCcgPT09IHR5cGVvZiBrZXkgJiYgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGtleS5leGVjIC8vcmVnZXhwXG4gICAgPyBmdW5jdGlvbiAoZGF0YSkgeyB2YXIgdiA9IGtleS5leGVjKGRhdGEpOyByZXR1cm4gdiAmJiB2WzBdIH1cbiAgICA6IGtleVxuICApXG59XG4iLCIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2VuZC1vZi1zdHJlYW0gd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFO1xuXG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZW9zKHN0cmVhbSwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW9zKHN0cmVhbSwgbnVsbCwgb3B0cyk7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gIHZhciByZWFkYWJsZSA9IG9wdHMucmVhZGFibGUgfHwgb3B0cy5yZWFkYWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLnJlYWRhYmxlO1xuICB2YXIgd3JpdGFibGUgPSBvcHRzLndyaXRhYmxlIHx8IG9wdHMud3JpdGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS53cml0YWJsZTtcblxuICB2YXIgb25sZWdhY3lmaW5pc2ggPSBmdW5jdGlvbiBvbmxlZ2FjeWZpbmlzaCgpIHtcbiAgICBpZiAoIXN0cmVhbS53cml0YWJsZSkgb25maW5pc2goKTtcbiAgfTtcblxuICB2YXIgd3JpdGFibGVFbmRlZCA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZSAmJiBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQ7XG5cbiAgdmFyIG9uZmluaXNoID0gZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgd3JpdGFibGUgPSBmYWxzZTtcbiAgICB3cml0YWJsZUVuZGVkID0gdHJ1ZTtcbiAgICBpZiAoIXJlYWRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG4gIH07XG5cbiAgdmFyIHJlYWRhYmxlRW5kZWQgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGUgJiYgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQ7XG5cbiAgdmFyIG9uZW5kID0gZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICByZWFkYWJsZUVuZGVkID0gdHJ1ZTtcbiAgICBpZiAoIXdyaXRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG4gIH07XG5cbiAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICB9O1xuXG4gIHZhciBvbmNsb3NlID0gZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICB2YXIgZXJyO1xuXG4gICAgaWYgKHJlYWRhYmxlICYmICFyZWFkYWJsZUVuZGVkKSB7XG4gICAgICBpZiAoIXN0cmVhbS5fcmVhZGFibGVTdGF0ZSB8fCAhc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgICB9XG5cbiAgICBpZiAod3JpdGFibGUgJiYgIXdyaXRhYmxlRW5kZWQpIHtcbiAgICAgIGlmICghc3RyZWFtLl93cml0YWJsZVN0YXRlIHx8ICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZW5kZWQpIGVyciA9IG5ldyBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSgpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgb25yZXF1ZXN0ID0gZnVuY3Rpb24gb25yZXF1ZXN0KCkge1xuICAgIHN0cmVhbS5yZXEub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgfTtcblxuICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHtcbiAgICBzdHJlYW0ub24oJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5vbignYWJvcnQnLCBvbmNsb3NlKTtcbiAgICBpZiAoc3RyZWFtLnJlcSkgb25yZXF1ZXN0KCk7ZWxzZSBzdHJlYW0ub24oJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuICB9IGVsc2UgaWYgKHdyaXRhYmxlICYmICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAvLyBsZWdhY3kgc3RyZWFtc1xuICAgIHN0cmVhbS5vbignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5vbignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gIH1cblxuICBzdHJlYW0ub24oJ2VuZCcsIG9uZW5kKTtcbiAgc3RyZWFtLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gIGlmIChvcHRzLmVycm9yICE9PSBmYWxzZSkgc3RyZWFtLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBzdHJlYW0ub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0Jywgb25jbG9zZSk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcbiAgICBpZiAoc3RyZWFtLnJlcSkgc3RyZWFtLnJlcS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlb3M7IiwiLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9wdW1wIHdpdGhcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW9zO1xuXG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBjYWxsYmFjay5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9NSVNTSU5HX0FSR1MgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUlTU0lOR19BUkdTLFxuICAgIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQ7XG5cbmZ1bmN0aW9uIG5vb3AoZXJyKSB7XG4gIC8vIFJldGhyb3cgdGhlIGVycm9yIGlmIGl0IGV4aXN0cyB0byBhdm9pZCBzd2FsbG93aW5nIGl0XG4gIGlmIChlcnIpIHRocm93IGVycjtcbn1cblxuZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICB2YXIgY2xvc2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgfSk7XG4gIGlmIChlb3MgPT09IHVuZGVmaW5lZCkgZW9zID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG4gIGVvcyhzdHJlYW0sIHtcbiAgICByZWFkYWJsZTogcmVhZGluZyxcbiAgICB3cml0YWJsZTogd3JpdGluZ1xuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgICBjYWxsYmFjaygpO1xuICB9KTtcbiAgdmFyIGRlc3Ryb3llZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChjbG9zZWQpIHJldHVybjtcbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgZGVzdHJveWVkID0gdHJ1ZTsgLy8gcmVxdWVzdC5kZXN0cm95IGp1c3QgZG8gLmVuZCAtIC5hYm9ydCBpcyB3aGF0IHdlIHdhbnRcblxuICAgIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkgcmV0dXJuIHN0cmVhbS5hYm9ydCgpO1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHJldHVybiBzdHJlYW0uZGVzdHJveSgpO1xuICAgIGNhbGxiYWNrKGVyciB8fCBuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3BpcGUnKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhbGwoZm4pIHtcbiAgZm4oKTtcbn1cblxuZnVuY3Rpb24gcGlwZShmcm9tLCB0bykge1xuICByZXR1cm4gZnJvbS5waXBlKHRvKTtcbn1cblxuZnVuY3Rpb24gcG9wQ2FsbGJhY2soc3RyZWFtcykge1xuICBpZiAoIXN0cmVhbXMubGVuZ3RoKSByZXR1cm4gbm9vcDtcbiAgaWYgKHR5cGVvZiBzdHJlYW1zW3N0cmVhbXMubGVuZ3RoIC0gMV0gIT09ICdmdW5jdGlvbicpIHJldHVybiBub29wO1xuICByZXR1cm4gc3RyZWFtcy5wb3AoKTtcbn1cblxuZnVuY3Rpb24gcGlwZWxpbmUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdHJlYW1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHN0cmVhbXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgY2FsbGJhY2sgPSBwb3BDYWxsYmFjayhzdHJlYW1zKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RyZWFtc1swXSkpIHN0cmVhbXMgPSBzdHJlYW1zWzBdO1xuXG4gIGlmIChzdHJlYW1zLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnc3RyZWFtcycpO1xuICB9XG5cbiAgdmFyIGVycm9yO1xuICB2YXIgZGVzdHJveXMgPSBzdHJlYW1zLm1hcChmdW5jdGlvbiAoc3RyZWFtLCBpKSB7XG4gICAgdmFyIHJlYWRpbmcgPSBpIDwgc3RyZWFtcy5sZW5ndGggLSAxO1xuICAgIHZhciB3cml0aW5nID0gaSA+IDA7XG4gICAgcmV0dXJuIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmICghZXJyb3IpIGVycm9yID0gZXJyO1xuICAgICAgaWYgKGVycikgZGVzdHJveXMuZm9yRWFjaChjYWxsKTtcbiAgICAgIGlmIChyZWFkaW5nKSByZXR1cm47XG4gICAgICBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xuICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHN0cmVhbXMucmVkdWNlKHBpcGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBpcGVsaW5lOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cbid1c2Ugc3RyaWN0Jztcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcblxudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gQWxsb3cgdGhlIGtleXMgYXJyYXkgdG8gYmUgR0MnZWQuXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuXG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xuICAgIH1cbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7IC8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcblxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIElmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLCB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuOyAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuXG4gIHByb2Nlc3MubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcsXG4gICAgRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wID0gX3JlcXVpcmUkY29kZXMuRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmIChjYiA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuICBjYihlcik7XG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcblxuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTsgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfSAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG5cblxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07IC8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfdHJhbnNmb3JtKCknKSk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuXG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTsgLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcblxuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTsgLy8gVE9ETyhCcmlkZ2VBUik6IFdyaXRlIGEgdGVzdCBmb3IgdGhlc2UgdHdvIGVycm9yIGNhc2VzXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG5cbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAoKTtcbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORygpO1xuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn0gLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cblxuXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUsXG4gICAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRCxcbiAgICBFUlJfU1RSRUFNX05VTExfVkFMVUVTID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyxcbiAgICBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5ELFxuICAgIEVSUl9VTktOT1dOX0VOQ09ESU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1VOS05PV05fRU5DT0RJTkc7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLFxuICAvLyBlLmcuIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlIHZzLiBvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSwgZXRjLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTsgLy8gZHJhaW4gZXZlbnQgZmxhZy5cblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlOyAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7IC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcblxuICB0aGlzLmVuZGVkID0gZmFsc2U7IC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cblxuICB0aGlzLmxlbmd0aCA9IDA7IC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7IC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcblxuICB0aGlzLmNvcmtlZCA9IDA7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7IC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcblxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9OyAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcblxuXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7IC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cblxuICB0aGlzLndyaXRlbGVuID0gMDtcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsOyAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcblxuICB0aGlzLnBlbmRpbmdjYiA9IDA7IC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcblxuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7IC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdmaW5pc2gnIChhbmQgcG90ZW50aWFsbHkgJ2VuZCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDsgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG5cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG5cbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVCdWZmZXJHZXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpOyAvLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cblxuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiByZWFsSGFzSW5zdGFuY2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTsgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBXcml0YWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIGlmICghaXNEdXBsZXggJiYgIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5LlxuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn0gLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuXG5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSgpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQoKTsgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcblxuICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xufSAvLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5cblxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIGVyO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJ10sIGNodW5rKTtcbiAgfVxuXG4gIGlmIChlcikge1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG4gIGlmIChzdGF0ZS5lbmRpbmcpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBFUlJfVU5LTk9XTl9FTkNPRElORyhlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuXG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7IC8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyazsgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAoc3RhdGUuZGVzdHJveWVkKSBzdGF0ZS5vbndyaXRlKG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnd3JpdGUnKSk7ZWxzZSBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG5cbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpO1xuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSkgfHwgc3RyZWFtLmRlc3Ryb3llZDtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59IC8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuXG5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn0gLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcblxuXG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG5cbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTsgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcblxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTsgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cblxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ193cml0ZSgpJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTsgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9IC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cblxuXG4gIGlmICghc3RhdGUuZW5kaW5nKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuXG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicgJiYgIXN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuXG4gICAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgICAvLyBpZiB0aGUgcmVhZGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gICAgICAgIGlmICghclN0YXRlIHx8IHJTdGF0ZS5hdXRvRGVzdHJveSAmJiByU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuXG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9IC8vIHJldXNlIHRoZSBmcmVlIGNvcmtSZXEuXG5cblxuICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBFRWxpc3RlbmVyQ291bnQoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgZGVidWc7XG5cbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0Jyk7XG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICAgIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQ7IC8vIExhenkgbG9hZGVkIHRvIGltcHJvdmUgdGhlIHN0YXJ0dXAgcGVyZm9ybWFuY2UuXG5cblxudmFyIFN0cmluZ0RlY29kZXI7XG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yO1xudmFyIGZyb207XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7IC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cblxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OyAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlOyAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpOyAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG5cbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTsgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdGhpcy5wYXVzZWQgPSB0cnVlOyAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOyAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2VuZCcgKGFuZCBwb3RlbnRpYWxseSAnZmluaXNoJylcblxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95OyAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOyAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOyAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7IC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcblxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuXG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7IC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFJlYWRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG5cbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5XG5cbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblxuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07IC8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTsgLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgZGVidWcoJ3JlYWRhYmxlQWRkQ2h1bmsnLCBjaHVuayk7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcblxuICAgIGlmIChlcikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQoKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YoKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSAvLyBXZSBjYW4gcHVzaCBtb3JlIGRhdGEgaWYgd2UgYXJlIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLlxuICAvLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZSBtb3JlIGJ5dGVzLlxuICAvLyBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLCBzdWNoIGFzIHRoZSByZXBsLlxuXG5cbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG5cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG5cbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInLCAnVWludDhBcnJheSddLCBjaHVuayk7XG4gIH1cblxuICByZXR1cm4gZXI7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59OyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHZhciBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gZGVjb2RlcjsgLy8gSWYgc2V0RW5jb2RpbmcobnVsbCksIGRlY29kZXIuZW5jb2RpbmcgZXF1YWxzIHV0ZjhcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyLmVuY29kaW5nOyAvLyBJdGVyYXRlIG92ZXIgY3VycmVudCBidWZmZXIgdG8gY29udmVydCBhbHJlYWR5IHN0b3JlZCBCdWZmZXJzOlxuXG4gIHZhciBwID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuaGVhZDtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICB3aGlsZSAocCAhPT0gbnVsbCkge1xuICAgIGNvbnRlbnQgKz0gZGVjb2Rlci53cml0ZShwLmRhdGEpO1xuICAgIHAgPSBwLm5leHQ7XG4gIH1cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuXG4gIGlmIChjb250ZW50ICE9PSAnJykgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIucHVzaChjb250ZW50KTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMUdCXG5cblxudmFyIE1BWF9IV00gPSAweDQwMDAwMDAwO1xuXG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICAvLyBUT0RPKHJvbmFnKTogVGhyb3cgRVJSX1ZBTFVFX09VVF9PRl9SQU5HRS5cbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG5cbiAgcmV0dXJuIG47XG59IC8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG5cbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH0gLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG5cblxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjsgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcblxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59IC8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7IC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cblxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKChzdGF0ZS5oaWdoV2F0ZXJNYXJrICE9PSAwID8gc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgOiBzdGF0ZS5sZW5ndGggPiAwKSB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7IC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cblxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cblxuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTsgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfSAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG5cblxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlOyAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcblxuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTsgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1Zygnb25Fb2ZDaHVuaycpO1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcblxuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG5cbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS5zeW5jKSB7XG4gICAgLy8gaWYgd2UgYXJlIHN5bmMsIHdhaXQgdW50aWwgbmV4dCB0aWNrIHRvIGVtaXQgdGhlIGRhdGEuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIHJpc2sgZW1pdHRpbmcgZGF0YSBpbiB0aGUgZmxvdygpXG4gICAgLy8gdGhlIHJlYWRhYmxlIGNvZGUgdHJpZ2dlcnMgZHVyaW5nIGEgcmVhZCgpIGNhbGxcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAgIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgIH1cbiAgfVxufSAvLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuXG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUubmVlZFJlYWRhYmxlLCBzdGF0ZS5lbWl0dGVkUmVhZGFibGUpO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGVfJywgc3RhdGUuZGVzdHJveWVkLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcblxuICBpZiAoIXN0YXRlLmRlc3Ryb3llZCAmJiAoc3RhdGUubGVuZ3RoIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB9IC8vIFRoZSBzdHJlYW0gbmVlZHMgYW5vdGhlciByZWFkYWJsZSBldmVudCBpZlxuICAvLyAxLiBJdCBpcyBub3QgZmxvd2luZywgYXMgdGhlIGZsb3cgbWVjaGFuaXNtIHdpbGwgdGFrZVxuICAvLyAgICBjYXJlIG9mIGl0LlxuICAvLyAyLiBJdCBpcyBub3QgZW5kZWQuXG4gIC8vIDMuIEl0IGlzIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLCBzbyB3ZSBjYW4gc2NoZWR1bGVcbiAgLy8gICAgYW5vdGhlciByZWFkYWJsZSBsYXRlci5cblxuXG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9ICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgZmxvdyhzdHJlYW0pO1xufSAvLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cblxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIC8vIEF0dGVtcHQgdG8gcmVhZCBtb3JlIGRhdGEgaWYgd2Ugc2hvdWxkLlxuICAvL1xuICAvLyBUaGUgY29uZGl0aW9ucyBmb3IgcmVhZGluZyBtb3JlIGRhdGEgYXJlIChvbmUgb2YpOlxuICAvLyAtIE5vdCBlbm91Z2ggZGF0YSBidWZmZXJlZCAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykuIFRoZSBsb29wXG4gIC8vICAgaXMgcmVzcG9uc2libGUgZm9yIGZpbGxpbmcgdGhlIGJ1ZmZlciB3aXRoIGVub3VnaCBkYXRhIGlmIHN1Y2ggZGF0YVxuICAvLyAgIGlzIGF2YWlsYWJsZS4gSWYgaGlnaFdhdGVyTWFyayBpcyAwIGFuZCB3ZSBhcmUgbm90IGluIHRoZSBmbG93aW5nIG1vZGVcbiAgLy8gICB3ZSBzaG91bGQgX25vdF8gYXR0ZW1wdCB0byBidWZmZXIgYW55IGV4dHJhIGRhdGEuIFdlJ2xsIGdldCBtb3JlIGRhdGFcbiAgLy8gICB3aGVuIHRoZSBzdHJlYW0gY29uc3VtZXIgY2FsbHMgcmVhZCgpIGluc3RlYWQuXG4gIC8vIC0gTm8gZGF0YSBpbiB0aGUgYnVmZmVyLCBhbmQgdGhlIHN0cmVhbSBpcyBpbiBmbG93aW5nIG1vZGUuIEluIHRoaXMgbW9kZVxuICAvLyAgIHRoZSBsb29wIGJlbG93IGlzIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyByZWFkKCkgaXMgY2FsbGVkLiBGYWlsaW5nIHRvXG4gIC8vICAgY2FsbCByZWFkIGhlcmUgd291bGQgYWJvcnQgdGhlIGZsb3cgYW5kIHRoZXJlJ3Mgbm8gb3RoZXIgbWVjaGFuaXNtIGZvclxuICAvLyAgIGNvbnRpbnVpbmcgdGhlIGZsb3cgaWYgdGhlIHN0cmVhbSBjb25zdW1lciBoYXMganVzdCBzdWJzY3JpYmVkIHRvIHRoZVxuICAvLyAgICdkYXRhJyBldmVudC5cbiAgLy9cbiAgLy8gSW4gYWRkaXRpb24gdG8gdGhlIGFib3ZlIGNvbmRpdGlvbnMgdG8ga2VlcCByZWFkaW5nIGRhdGEsIHRoZSBmb2xsb3dpbmdcbiAgLy8gY29uZGl0aW9ucyBwcmV2ZW50IHRoZSBkYXRhIGZyb20gYmVpbmcgcmVhZDpcbiAgLy8gLSBUaGUgc3RyZWFtIGhhcyBlbmRlZCAoc3RhdGUuZW5kZWQpLlxuICAvLyAtIFRoZXJlIGlzIGFscmVhZHkgYSBwZW5kaW5nICdyZWFkJyBvcGVyYXRpb24gKHN0YXRlLnJlYWRpbmcpLiBUaGlzIGlzIGFcbiAgLy8gICBjYXNlIHdoZXJlIHRoZSB0aGUgc3RyZWFtIGhhcyBjYWxsZWQgdGhlIGltcGxlbWVudGF0aW9uIGRlZmluZWQgX3JlYWQoKVxuICAvLyAgIG1ldGhvZCwgYnV0IHRoZXkgYXJlIHByb2Nlc3NpbmcgdGhlIGNhbGwgYXN5bmNocm9ub3VzbHkgYW5kIGhhdmUgX25vdF9cbiAgLy8gICBjYWxsZWQgcHVzaCgpIHdpdGggbmV3IGRhdGEuIEluIHRoaXMgY2FzZSB3ZSBza2lwIHBlcmZvcm1pbmcgbW9yZVxuICAvLyAgIHJlYWQoKXMuIFRoZSBleGVjdXRpb24gZW5kcyBpbiB0aGlzIG1ldGhvZCBhZ2FpbiBhZnRlciB0aGUgX3JlYWQoKSBlbmRzXG4gIC8vICAgdXAgY2FsbGluZyBwdXNoKCkgd2l0aCBtb3JlIGRhdGEuXG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDApKSB7XG4gICAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59IC8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3JlYWQoKScpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzcy5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG5cbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcblxuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9IC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuXG5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpOyAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGNsZWFuZWRVcCA9IHRydWU7IC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgZGVidWcoJ2Rlc3Qud3JpdGUnLCByZXQpO1xuXG4gICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICB9XG5cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfSAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuXG5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZXJyb3JPckRlc3Ryb3koZGVzdCwgZXIpO1xuICB9IC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cblxuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTsgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuXG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcblxuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG5cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9IC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG5cblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpOyAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVPbkRyYWluRnVuY3Rpb25SZXN1bHQoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHtcbiAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICB9OyAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzOyAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7IC8vIGdvdCBhIG1hdGNoLlxuXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywge1xuICAgICAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cblxuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gdXBkYXRlIHJlYWRhYmxlTGlzdGVuaW5nIHNvIHRoYXQgcmVzdW1lKCkgbWF5IGJlIGEgbm8tb3BcbiAgICAvLyBhIGZldyBsaW5lcyBkb3duLiBUaGlzIGlzIG5lZWRlZCB0byBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJykuXG4gICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0aGlzLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwOyAvLyBUcnkgc3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG5cbiAgICBpZiAoc3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGRlYnVnKCdvbiByZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUucmVhZGluZyk7XG5cbiAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfSBlbHNlIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIuY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2KSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyB8fCBldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nKHNlbGYpIHtcbiAgdmFyIHN0YXRlID0gc2VsZi5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzZWxmLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwO1xuXG4gIGlmIChzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgJiYgIXN0YXRlLnBhdXNlZCkge1xuICAgIC8vIGZsb3dpbmcgbmVlZHMgdG8gYmUgc2V0IHRvIHRydWUgbm93LCBvdGhlcndpc2VcbiAgICAvLyB0aGUgdXBjb21pbmcgcmVzdW1lIHdpbGwgbm90IGZsb3cuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7IC8vIGNydWRlIHdheSB0byBjaGVjayBpZiB3ZSBzaG91bGQgcmVzdW1lXG4gIH0gZWxzZSBpZiAoc2VsZi5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwKSB7XG4gICAgc2VsZi5yZXN1bWUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59IC8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTsgLy8gd2UgZmxvdyBvbmx5IGlmIHRoZXJlIGlzIG5vIG9uZSBsaXN0ZW5pbmdcbiAgICAvLyBmb3IgcmVhZGFibGUsIGJ1dCB3ZSBzdGlsbCBoYXZlIHRvIGNhbGxcbiAgICAvLyByZXN1bWUoKVxuXG4gICAgc3RhdGUuZmxvd2luZyA9ICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZztcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG5cbiAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdyZXN1bWUnLCBzdGF0ZS5yZWFkaW5nKTtcblxuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5wYXVzZWQgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcblxuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7XG4gICAgO1xuICB9XG59IC8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuXG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTsgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG5cbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG5cbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7IC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiBtZXRob2RXcmFwKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWV0aG9kV3JhcFJldHVybkZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfSAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG5cblxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9IC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG5cblxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuXG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVhZGFibGUucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvcicpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcyk7XG4gIH07XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVGbG93aW5nJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldChzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBzdGF0ZTtcbiAgICB9XG4gIH1cbn0pOyAvLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pOyAvLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmZpcnN0KCk7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBzdGF0ZS5idWZmZXIuY29uc3VtZShuLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW5kUmVhZGFibGUnLCBzdGF0ZS5lbmRFbWl0dGVkKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlTlQnLCBzdGF0ZS5lbmRFbWl0dGVkLCBzdGF0ZS5sZW5ndGgpOyAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuXG4gICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAvLyBpZiB0aGUgd3JpdGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcblxuICAgICAgaWYgKCF3U3RhdGUgfHwgd1N0YXRlLmF1dG9EZXN0cm95ICYmIHdTdGF0ZS5maW5pc2hlZCkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5mcm9tID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBvcHRzKSB7XG4gICAgaWYgKGZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnJvbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9mcm9tJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cblxuICByZXR1cm4gLTE7XG59IiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbmV4cG9ydHMuZmluaXNoZWQgPSByZXF1aXJlKCcuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMnKTtcbmV4cG9ydHMucGlwZWxpbmUgPSByZXF1aXJlKCcuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzJyk7XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHByb21pc2lmeSA9IHJlcXVpcmUoJ3Byb21pc2lmeS1lczYnKVxuY29uc3QgY3JlYXRlTG9jayA9IHJlcXVpcmUoJy4vdXRpbHMvY3JlYXRlLWxvY2snKVxuXG4vLyBUaGVzZSBvcGVyYXRpb25zIGFyZSByZWFkLWxvY2tlZCBhdCB0aGUgZnVuY3Rpb24gbGV2ZWwgYW5kIHdpbGwgZXhlY3V0ZSBzaW11bHRhbmVvdXNseVxuY29uc3QgcmVhZE9wZXJhdGlvbnMgPSB7XG4gIHN0YXQ6IHJlcXVpcmUoJy4vc3RhdCcpXG59XG5cbi8vIFRoZXNlIG9wZXJhdGlvbnMgYXJlIGxvY2tlZCBhdCB0aGUgZnVuY3Rpb24gbGV2ZWwgYW5kIHdpbGwgZXhlY3V0ZSBpbiBzZXJpZXNcbmNvbnN0IHdyaXRlT3BlcmF0aW9ucyA9IHtcbiAgY3A6IHJlcXVpcmUoJy4vY3AnKSxcbiAgZmx1c2g6IHJlcXVpcmUoJy4vZmx1c2gnKSxcbiAgbWtkaXI6IHJlcXVpcmUoJy4vbWtkaXInKSxcbiAgbXY6IHJlcXVpcmUoJy4vbXYnKSxcbiAgcm06IHJlcXVpcmUoJy4vcm0nKVxufVxuXG4vLyBUaGVzZSBvcGVyYXRpb25zIGFyZSBhc3luY2hyb25vdXMgYW5kIG1hbmFnZSB0aGVpciBvd24gbG9ja2luZ1xuY29uc3QgdW53cmFwcGVkT3BlcmF0aW9ucyA9IHtcbiAgd3JpdGU6IHJlcXVpcmUoJy4vd3JpdGUnKSxcbiAgcmVhZDogcmVxdWlyZSgnLi9yZWFkJyksXG4gIGxzOiByZXF1aXJlKCcuL2xzJylcbn1cblxuY29uc3Qgd3JhcCA9ICh7XG4gIG9wdGlvbnMsIG1mcywgb3BlcmF0aW9ucywgbG9ja1xufSkgPT4ge1xuICBPYmplY3Qua2V5cyhvcGVyYXRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgbWZzW2tleV0gPSBsb2NrKG9wZXJhdGlvbnNba2V5XShvcHRpb25zKSlcbiAgfSlcbn1cblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHJlcG9Pd25lcjogdHJ1ZSxcbiAgaXBsZDogbnVsbCxcbiAgcmVwbzogbnVsbFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtcbiAgICByZXBvT3duZXJcbiAgfSA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zIHx8IHt9LCBvcHRpb25zKVxuXG4gIGFzc2VydChvcHRpb25zLmlwbGQsICdNRlMgcmVxdWlyZXMgYW4gSVBMRCBpbnN0YW5jZScpXG4gIGFzc2VydChvcHRpb25zLmJsb2NrcywgJ01GUyByZXF1aXJlcyBhbiBCbG9ja1N0b3JlIGluc3RhbmNlJylcbiAgYXNzZXJ0KG9wdGlvbnMuZGF0YXN0b3JlLCAnTUZTIHJlcXVpcmVzIGEgRGF0YVN0b3JlIGluc3RhbmNlJylcblxuICAvLyBzaG91bGQgYmUgYWJsZSB0byByZW1vdmUgdGhpcyB3aGVuIGFzeW5jL2F3YWl0IFBScyBhcmUgaW4gZm9yIGRhdGFzdG9yZSwgYmxvY2tzdG9yZSAmIHJlcG9cbiAgb3B0aW9ucy5yZXBvID0ge1xuICAgIGJsb2Nrczoge1xuICAgICAgZ2V0OiBwcm9taXNpZnkob3B0aW9ucy5ibG9ja3MuZ2V0LCB7XG4gICAgICAgIGNvbnRleHQ6IG9wdGlvbnMuYmxvY2tzXG4gICAgICB9KVxuICAgIH0sXG4gICAgZGF0YXN0b3JlOiB7XG4gICAgICBvcGVuOiBwcm9taXNpZnkob3B0aW9ucy5kYXRhc3RvcmUub3Blbiwge1xuICAgICAgICBjb250ZXh0OiBvcHRpb25zLmRhdGFzdG9yZVxuICAgICAgfSksXG4gICAgICBnZXQ6IHByb21pc2lmeShvcHRpb25zLmRhdGFzdG9yZS5nZXQsIHtcbiAgICAgICAgY29udGV4dDogb3B0aW9ucy5kYXRhc3RvcmVcbiAgICAgIH0pLFxuICAgICAgcHV0OiBwcm9taXNpZnkob3B0aW9ucy5kYXRhc3RvcmUucHV0LCB7XG4gICAgICAgIGNvbnRleHQ6IG9wdGlvbnMuZGF0YXN0b3JlXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGxvY2sgPSBjcmVhdGVMb2NrKHJlcG9Pd25lcilcblxuICBjb25zdCByZWFkTG9jayA9IChvcGVyYXRpb24pID0+IHtcbiAgICByZXR1cm4gbG9jay5yZWFkTG9jayhvcGVyYXRpb24pXG4gIH1cblxuICBjb25zdCB3cml0ZUxvY2sgPSAob3BlcmF0aW9uKSA9PiB7XG4gICAgcmV0dXJuIGxvY2sud3JpdGVMb2NrKG9wZXJhdGlvbilcbiAgfVxuXG4gIGNvbnN0IG1mcyA9IHt9XG5cbiAgd3JhcCh7XG4gICAgb3B0aW9ucywgbWZzLCBvcGVyYXRpb25zOiByZWFkT3BlcmF0aW9ucywgbG9jazogcmVhZExvY2tcbiAgfSlcbiAgd3JhcCh7XG4gICAgb3B0aW9ucywgbWZzLCBvcGVyYXRpb25zOiB3cml0ZU9wZXJhdGlvbnMsIGxvY2s6IHdyaXRlTG9ja1xuICB9KVxuXG4gIE9iamVjdC5rZXlzKHVud3JhcHBlZE9wZXJhdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBtZnNba2V5XSA9IHVud3JhcHBlZE9wZXJhdGlvbnNba2V5XShvcHRpb25zKVxuICB9KVxuXG4gIHJldHVybiBtZnNcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vU25hcENvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9TdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRTZXJ2aWNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9XZWJXb3JrZXJFeGVjdXRpb25FbnZpcm9ubWVudFNlcnZpY2VcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9FeHRlcm5hbFJlc291cmNlQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGVybWlzc2lvblJwY01ldGhvZHMgPSB2b2lkIDA7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ2F2ZWF0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9QZXJtaXNzaW9uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9QZXJtaXNzaW9uQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHNcIiksIGV4cG9ydHMpO1xuLy8gVE9ETzogTW92ZSB0aGVzZSB0byB0aGUgYXBwcm9wcmlhdGUgcGFja2FnZVxuZXhwb3J0cy5wZXJtaXNzaW9uUnBjTWV0aG9kcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9ycGMtbWV0aG9kc1wiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQklQXzM5X1BBVEhfUkVHRVggPSBleHBvcnRzLkJJUF8zMl9QQVRIX1JFR0VYID0gZXhwb3J0cy5CSVA0NFB1cnBvc2VOb2RlVG9rZW4gPSBleHBvcnRzLk1BWF9CSVBfNDRfREVQVEggPSBleHBvcnRzLk1JTl9CSVBfNDRfREVQVEggPSBleHBvcnRzLkJBU0VfNjRfUkVHRVggPSBleHBvcnRzLkhFWEFERUNJTUFMX0tFWV9MRU5HVEggPSBleHBvcnRzLkJBU0VfNjRfWkVSTyA9IGV4cG9ydHMuQkFTRV82NF9LRVlfTEVOR1RIID0gZXhwb3J0cy5CVUZGRVJfS0VZX0xFTkdUSCA9IHZvaWQgMDtcbmV4cG9ydHMuQlVGRkVSX0tFWV9MRU5HVEggPSA2NDtcbmV4cG9ydHMuQkFTRV82NF9LRVlfTEVOR1RIID0gODg7XG5leHBvcnRzLkJBU0VfNjRfWkVSTyA9ICdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQT09JztcbmV4cG9ydHMuSEVYQURFQ0lNQUxfS0VZX0xFTkdUSCA9IDEyODtcbi8vIFNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ3NTIxN1xuZXhwb3J0cy5CQVNFXzY0X1JFR0VYID0gL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezN9PXxbQS1aYS16MC05Ky9dezJ9PT0pPyQvdTtcbmV4cG9ydHMuTUlOX0JJUF80NF9ERVBUSCA9IDA7XG5leHBvcnRzLk1BWF9CSVBfNDRfREVQVEggPSA1O1xuZXhwb3J0cy5CSVA0NFB1cnBvc2VOb2RlVG9rZW4gPSBgYmlwMzI6NDQnYDtcbi8qKlxuICogZS5nLlxuICogLSAgYmlwMzI6MFxuICogLSAgYmlwMzI6MCdcbiAqL1xuZXhwb3J0cy5CSVBfMzJfUEFUSF9SRUdFWCA9IC9eYmlwMzI6XFxkKyc/JC91O1xuLyoqXG4gKiBiaXAzOTo8U1BBQ0VfREVMTUlURURfU0VFRF9QSFJBU0U+XG4gKlxuICogVGhlIHNlZWQgcGhyYXNlIG11c3QgY29uc2lzdCBvZiAxMiA8PSAyNCB3b3Jkcy5cbiAqL1xuZXhwb3J0cy5CSVBfMzlfUEFUSF9SRUdFWCA9IC9eYmlwMzk6KFthLXpdKyl7MX0oIFthLXpdKyl7MTEsMjN9JC91O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRCSVA0NEFkZHJlc3NLZXlEZXJpdmVyID0gZXhwb3J0cy5kZXJpdmVCSVA0NEFkZHJlc3NLZXkgPSBleHBvcnRzLkJJUDQ0Q29pblR5cGVOb2RlID0gZXhwb3J0cy5CSVBfNDRfQ09JTl9UWVBFX0RFUFRIID0gdm9pZCAwO1xuY29uc3QgQklQNDROb2RlXzEgPSByZXF1aXJlKFwiLi9CSVA0NE5vZGVcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5leHBvcnRzLkJJUF80NF9DT0lOX1RZUEVfREVQVEggPSAyO1xuLyoqXG4gKiBVc2VkIHRvIGNvbmNlYWwgdGhlIGlubmVyIHtAbGluayBCSVA0NE5vZGV9IGZyb20gY29uc3VtZXJzLlxuICovXG5jb25zdCBJbm5lck5vZGUgPSBTeW1ib2woJ19ub2RlJyk7XG4vKipcbiAqIEEgd3JhcHBlciBvYmplY3QgZm9yIEJJUC00NCBgY29pbl90eXBlYCBrZXlzLiBgY29pbl90eXBlYCBpcyB0aGUgaW5kZXhcbiAqIHNwZWNpZnlpbmcgdGhlIHByb3RvY29sIGZvciB3aGljaCBkZWVwZXIga2V5cyBhcmUgaW50ZW5kZWQuIEZvciB0aGVcbiAqIGF1dGhvcml0YXRpdmUgbGlzdCBvZiBjb2luIHR5cGVzLCBwbGVhc2Ugc2VlXG4gKiBbU0xJUC00NF0oaHR0cHM6Ly9naXRodWIuY29tL3NhdG9zaGlsYWJzL3NsaXBzL2Jsb2IvbWFzdGVyL3NsaXAtMDA0NC5tZCkuXG4gKlxuICogUmVjYWxsIHRoYXQgYSBCSVAtNDQgSEQgdHJlZSBwYXRoIGNvbnNpc3RzIG9mIHRoZSBmb2xsb3dpbmcgbm9kZXM6XG4gKlxuICogYG0gLyA0NCcgLyBjb2luX3R5cGUnIC8gYWNjb3VudCcgLyBjaGFuZ2UgLyBhZGRyZXNzX2luZGV4YFxuICpcbiAqIFdpdGggdGhlIGZvbGxvd2luZyBkZXB0aHM6XG4gKlxuICogYDAgLyAxIC8gMiAvIDMgLyA0IC8gNWBcbiAqXG4gKi9cbmNsYXNzIEJJUDQ0Q29pblR5cGVOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgQklQLTQ0IGBjb2luX3R5cGVgIG5vZGUuIGBjb2luX3R5cGVgIGlzIHRoZSBpbmRleFxuICAgICAqIHNwZWNpZnlpbmcgdGhlIHByb3RvY29sIGZvciB3aGljaCBkZWVwZXIga2V5cyBhcmUgaW50ZW5kZWQuIEZvciB0aGVcbiAgICAgKiBhdXRob3JpdGF0aXZlIGxpc3Qgb2YgY29pbiB0eXBlcywgcGxlYXNlIHNlZVxuICAgICAqIFtTTElQLTQ0XShodHRwczovL2dpdGh1Yi5jb20vc2F0b3NoaWxhYnMvc2xpcHMvYmxvYi9tYXN0ZXIvc2xpcC0wMDQ0Lm1kKS5cbiAgICAgKlxuICAgICAqIFJlY2FsbCB0aGF0IGEgQklQLTQ0IEhEIHRyZWUgcGF0aCBjb25zaXN0cyBvZiB0aGUgZm9sbG93aW5nIG5vZGVzOlxuICAgICAqXG4gICAgICogYG0gLyA0NCcgLyBjb2luX3R5cGUnIC8gYWNjb3VudCcgLyBjaGFuZ2UgLyBhZGRyZXNzX2luZGV4YFxuICAgICAqXG4gICAgICogV2l0aCB0aGUgZm9sbG93aW5nIGRlcHRoczpcbiAgICAgKlxuICAgICAqIGAwIC8gMSAvIDIgLyAzIC8gNCAvIDVgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZU9yUGF0aFR1cGxlIC0gVGhlIHtAbGluayBCSVA0NE5vZGV9IG9yIGRlcml2YXRpb24gcGF0aCBmb3IgdGhlXG4gICAgICoga2V5IG9mIHRoaXMgYGNvaW5fdHlwZWAgbm9kZS5cbiAgICAgKiBAcGFyYW0gY29pbl90eXBlIC0gVGhlIGNvaW5fdHlwZSBpbmRleCBvZiB0aGlzIG5vZGUuIE11c3QgYmUgYSBub24tbmVnYXRpdmVcbiAgICAgKiBpbnRlZ2VyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5vZGVPclBhdGhUdXBsZSwgY29pbl90eXBlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGVPclBhdGhUdXBsZSkpIHtcbiAgICAgICAgICAgIGlmIChjb2luX3R5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXJhbWV0ZXJzOiBNYXkgbm90IHNwZWNpZnkgYm90aCBjb2luIHR5cGUgYW5kIGEgZGVyaXZhdGlvbiBwYXRoLiBUaGUgY29pbiB0eXBlIHdpbGwgYmUgY29tcHV0ZWQgZnJvbSB0aGUgZGVyaXZhdGlvbiBwYXRoLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsaWRhdGVDb2luVHlwZU5vZGVEZXB0aChub2RlT3JQYXRoVHVwbGUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB0aGlzW0lubmVyTm9kZV0gPSBuZXcgQklQNDROb2RlXzEuQklQNDROb2RlKHtcbiAgICAgICAgICAgICAgICBkZXJpdmF0aW9uUGF0aDogbm9kZU9yUGF0aFR1cGxlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBTcGxpdCB0aGUgYmlwMzIgc3RyaW5nIHRva2VuIGFuZCBleHRyYWN0IHRoZSBjb2luX3R5cGUgaW5kZXhcbiAgICAgICAgICAgIHRoaXMuY29pbl90eXBlID0gTnVtYmVyLnBhcnNlSW50KG5vZGVPclBhdGhUdXBsZVtleHBvcnRzLkJJUF80NF9DT0lOX1RZUEVfREVQVEhdLnNwbGl0KCc6JylbMV0ucmVwbGFjZShgJ2AsICcnKSwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsaWRhdGVDb2luVHlwZU5vZGVEZXB0aChub2RlT3JQYXRoVHVwbGUuZGVwdGgpO1xuICAgICAgICAgICAgdmFsaWRhdGVDb2luVHlwZVBhcmVudEtleShub2RlT3JQYXRoVHVwbGUua2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGtleUJ1ZmZlciA9IG5vZGVPclBhdGhUdXBsZSBpbnN0YW5jZW9mIEJJUDQ0Tm9kZV8xLkJJUDQ0Tm9kZVxuICAgICAgICAgICAgICAgID8gbm9kZU9yUGF0aFR1cGxlLmtleUJ1ZmZlclxuICAgICAgICAgICAgICAgIDogdXRpbHNfMS5iYXNlNjRTdHJpbmdUb0J1ZmZlcihub2RlT3JQYXRoVHVwbGUua2V5KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29pbl90eXBlICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKGNvaW5fdHlwZSkgfHxcbiAgICAgICAgICAgICAgICBjb2luX3R5cGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvaW4gdHlwZTogVGhlIHNwZWNpZmllZCBjb2luIHR5cGUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIG51bWJlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29pbl90eXBlID0gY29pbl90eXBlO1xuICAgICAgICAgICAgdGhpc1tJbm5lck5vZGVdID1cbiAgICAgICAgICAgICAgICBub2RlT3JQYXRoVHVwbGUgaW5zdGFuY2VvZiBCSVA0NE5vZGVfMS5CSVA0NE5vZGVcbiAgICAgICAgICAgICAgICAgICAgPyBub2RlT3JQYXRoVHVwbGVcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgQklQNDROb2RlXzEuQklQNDROb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoOiBleHBvcnRzLkJJUF80NF9DT0lOX1RZUEVfREVQVEgsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleUJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXRoID0gdXRpbHNfMS5nZXRCSVA0NENvaW5UeXBlUGF0aFN0cmluZyh0aGlzLmNvaW5fdHlwZSk7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIGdldCBkZXB0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSW5uZXJOb2RlXS5kZXB0aDtcbiAgICB9XG4gICAgZ2V0IGtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSW5uZXJOb2RlXS5rZXk7XG4gICAgfVxuICAgIGdldCBrZXlCdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0lubmVyTm9kZV0ua2V5QnVmZmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXJpdmVzIGEgQklQLTQ0IGBhZGRyZXNzX2luZGV4YCBrZXkgY29ycmVzcG9uZGluZyB0byB0aGUgcGF0aCBvZiB0aGlzXG4gICAgICogbm9kZSBhbmQgdGhlIHNwZWNpZmllZCBgYWNjb3VudGAsIGBjaGFuZ2VgLCBhbmQgYGFkZHJlc3NfaW5kZXhgIHZhbHVlcy5cbiAgICAgKiBgYWRkcmVzc19pbmRleGAga2V5cyBhcmUgbm9ybWFsbHkgdGhlIGtleXMgdXNlZCB0byBnZW5lcmF0ZSB1c2VyIGFjY291bnRcbiAgICAgKiBhZGRyZXNzZXMuXG4gICAgICpcbiAgICAgKiBSZWNhbGwgdGhhdCBhIEJJUC00NCBIRCB0cmVlIHBhdGggY29uc2lzdHMgb2YgdGhlIGZvbGxvd2luZyBub2RlczpcbiAgICAgKlxuICAgICAqIGBtIC8gNDQnIC8gY29pbl90eXBlJyAvIGFjY291bnQnIC8gY2hhbmdlIC8gYWRkcmVzc19pbmRleGBcbiAgICAgKlxuICAgICAqIFdpdGggdGhlIGZvbGxvd2luZyBkZXB0aHM6XG4gICAgICpcbiAgICAgKiBgMCAvIDEgLyAyIC8gMyAvIDQgLyA1YFxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGljZXMgLSBUaGUgQklQLTQ0IGluZGV4IHZhbHVlcyB0byB1c2UgaW4ga2V5IGRlcml2YXRpb24uXG4gICAgICogQHBhcmFtIGluZGljZXMuYWNjb3VudCAtIFRoZSBgYWNjb3VudGAgaW5kZXguIERlZmF1bHQ6IGAwYFxuICAgICAqIEBwYXJhbSBpbmRpY2VzLmNoYW5nZSAtIFRoZSBgY2hhbmdlYCBpbmRleC4gRGVmYXVsdDogYDBgXG4gICAgICogQHBhcmFtIGluZGljZXMuYWRkcmVzc19pbmRleCAtIFRoZSBgYWRkcmVzc19pbmRleGAgaW5kZXguXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBkZXJpdmVCSVA0NEFkZHJlc3NLZXkoeyBhY2NvdW50ID0gMCwgY2hhbmdlID0gMCwgYWRkcmVzc19pbmRleCwgfSkge1xuICAgICAgICByZXR1cm4gdGhpc1tJbm5lck5vZGVdLmRlcml2ZSh1dGlsc18xLmdldEJJUDQ0Q29pblR5cGVUb0FkZHJlc3NQYXRoVHVwbGUoeyBhY2NvdW50LCBjaGFuZ2UsIGFkZHJlc3NfaW5kZXggfSkpLmtleUJ1ZmZlcjtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzW0lubmVyTm9kZV0udG9KU09OKCkpLCB7IGNvaW5fdHlwZTogdGhpcy5jb2luX3R5cGUsIHBhdGg6IHRoaXMucGF0aCB9KTtcbiAgICB9XG59XG5leHBvcnRzLkJJUDQ0Q29pblR5cGVOb2RlID0gQklQNDRDb2luVHlwZU5vZGU7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgZGVwdGggb2YgYSBgY29pbl90eXBlYCBub2RlLiBTaW1wbHksIGVuc3VyZXMgdGhhdCBpdCBpcyB0aGVcbiAqIG51bWJlciBgMmAuIEFuIGVycm9yIGlzIHRocm93biBpZiB2YWxpZGF0aW9uIGZhaWxzLlxuICpcbiAqIEBwYXJhbSBkZXB0aCAtIFRoZSBkZXB0aCB0byB2YWxpZGF0ZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb2luVHlwZU5vZGVEZXB0aChkZXB0aCkge1xuICAgIGlmIChkZXB0aCAhPT0gZXhwb3J0cy5CSVBfNDRfQ09JTl9UWVBFX0RFUFRIKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkZXB0aDogQ29pbiB0eXBlIG5vZGVzIG11c3QgYmUgb2YgZGVwdGggJHtleHBvcnRzLkJJUF80NF9DT0lOX1RZUEVfREVQVEh9LiBSZWNlaXZlZDogXCIke2RlcHRofVwiYCk7XG4gICAgfVxufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSBgY29pbl90eXBlYCBCYXNlNjQgc3RyaW5nIGtleS4gXCJQYXJlbnRcIiBpcyBpbiB0aGUgbmFtZSBiZWNhdXNlXG4gKiBpdCdzIGFsc28gaW4gdGhlIG1lc3NhZ2UgdGhhdCdzIHRocm93biBvbiB2YWxpZGF0aW9uIGZhaWx1cmUuXG4gKlxuICogQHBhcmFtIHBhcmVudEtleSBUaGUgYGNvaW5fdHlwZWAga2V5IHRvIHZhbGlkYXRlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvaW5UeXBlUGFyZW50S2V5KHBhcmVudEtleSkge1xuICAgIGlmICghdXRpbHNfMS5pc1ZhbGlkQmFzZTY0U3RyaW5nS2V5KHBhcmVudEtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhcmVudCBrZXk6IE11c3QgYmUgYSBub24temVybyA2NC1ieXRlIGtleS4nKTtcbiAgICB9XG59XG4vKipcbiAqIERlcml2ZXMgYSBCSVAtNDQgYWRkcmVzcyBrZXkgY29ycmVzcG9uZGluZyB0byB0aGUgc3BlY2lmaWVkIGRlcml2YXRpb24gcGF0aCxcbiAqIGdpdmVuIGVpdGhlciBieSBhIHtAbGluayBCSVA0NENvaW5UeXBlTm9kZX0gb3IgZGVyaXZhdGlvbiBwYXRoIHR1cGxlLlxuICpcbiAqIFJlY2FsbCB0aGF0IGEgQklQLTQ0IEhEIHRyZWUgcGF0aCBjb25zaXN0cyBvZiB0aGUgZm9sbG93aW5nIG5vZGVzOlxuICpcbiAqIGBtIC8gNDQnIC8gY29pbl90eXBlJyAvIGFjY291bnQnIC8gY2hhbmdlIC8gYWRkcmVzc19pbmRleGBcbiAqXG4gKiBXaXRoIHRoZSBmb2xsb3dpbmcgZGVwdGhzOlxuICpcbiAqIGAwIC8gMSAvIDIgLyAzIC8gNCAvIDVgXG4gKlxuICogQHBhcmFtIHBhcmVudEtleU9yTm9kZSAtIFRoZSBgY29pbl90eXBlYCBwYXJlbnQga2V5IHRvIGRlcml2ZSBmcm9tLlxuICogQHBhcmFtIGluZGljZXMgLSBUaGUgYGFjY291bnRgLCBgY2hhbmdlYCwgYW5kIGBhZGRyZXNzX2luZGV4YCB1c2VkIGZvclxuICogZGVyaXZhdGlvbi5cbiAqIEByZXR1cm5zIFRoZSBkZXJpdmVkIGBhZGRyZXNzX2luZGV4YCBrZXkgZm9yIHRoZSBzcGVjaWZpZWQgZGVyaXZhdGlvbiBwYXRoLlxuICovXG5mdW5jdGlvbiBkZXJpdmVCSVA0NEFkZHJlc3NLZXkocGFyZW50S2V5T3JOb2RlLCB7IGFjY291bnQgPSAwLCBjaGFuZ2UgPSAwLCBhZGRyZXNzX2luZGV4IH0pIHtcbiAgICBpZiAodHlwZW9mIHBhcmVudEtleU9yTm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsaWRhdGVDb2luVHlwZVBhcmVudEtleShwYXJlbnRLZXlPck5vZGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsaWRhdGVDb2luVHlwZU5vZGVEZXB0aChwYXJlbnRLZXlPck5vZGUuZGVwdGgpO1xuICAgICAgICB2YWxpZGF0ZUNvaW5UeXBlUGFyZW50S2V5KHBhcmVudEtleU9yTm9kZS5rZXkpO1xuICAgIH1cbiAgICBsZXQga2V5QnVmZmVyO1xuICAgIGlmIChwYXJlbnRLZXlPck5vZGUgaW5zdGFuY2VvZiBCSVA0NENvaW5UeXBlTm9kZSkge1xuICAgICAgICBrZXlCdWZmZXIgPSBwYXJlbnRLZXlPck5vZGUua2V5QnVmZmVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAga2V5QnVmZmVyID0gdXRpbHNfMS5iYXNlNjRTdHJpbmdUb0J1ZmZlcih0eXBlb2YgcGFyZW50S2V5T3JOb2RlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBwYXJlbnRLZXlPck5vZGVcbiAgICAgICAgICAgIDogcGFyZW50S2V5T3JOb2RlLmtleSk7XG4gICAgfVxuICAgIHJldHVybiBCSVA0NE5vZGVfMS5kZXJpdmVDaGlsZE5vZGUoa2V5QnVmZmVyLCBleHBvcnRzLkJJUF80NF9DT0lOX1RZUEVfREVQVEgsIHV0aWxzXzEuZ2V0QklQNDRDb2luVHlwZVRvQWRkcmVzc1BhdGhUdXBsZSh7IGFjY291bnQsIGNoYW5nZSwgYWRkcmVzc19pbmRleCB9KSkua2V5QnVmZmVyO1xufVxuZXhwb3J0cy5kZXJpdmVCSVA0NEFkZHJlc3NLZXkgPSBkZXJpdmVCSVA0NEFkZHJlc3NLZXk7XG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGRlcml2ZXMgQklQLTQ0IGFkZHJlc3Mga2V5cyBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICogc3BlY2lmaWVkIGRlcml2YXRpb24gcGF0aCwgZ2l2ZW4gZWl0aGVyIGJ5IGEge0BsaW5rIEJJUDQ0Q29pblR5cGVOb2RlfSBvclxuICogZGVyaXZhdGlvbiBwYXRoIHR1cGxlLlxuICpcbiAqIFJlY2FsbCB0aGF0IGEgQklQLTQ0IEhEIHRyZWUgcGF0aCBjb25zaXN0cyBvZiB0aGUgZm9sbG93aW5nIG5vZGVzOlxuICpcbiAqIGBtIC8gNDQnIC8gY29pbl90eXBlJyAvIGFjY291bnQnIC8gY2hhbmdlIC8gYWRkcmVzc19pbmRleGBcbiAqXG4gKiBXaXRoIHRoZSBmb2xsb3dpbmcgZGVwdGhzOlxuICpcbiAqIGAwIC8gMSAvIDIgLyAzIC8gNCAvIDVgXG4gKlxuICogQHBhcmFtIG5vZGUgLSBUaGUge0BsaW5rIEJJUDQ0Q29pblR5cGVOb2RlfSB0byBkZXJpdmUgYWRkcmVzcyBrZXlzIGZyb20uXG4gKiBUaGlzIG5vZGUgY29udGFpbnMgYSBCSVAtNDQga2V5IG9mIGRlcHRoIDIsIGBjb2luX3R5cGVgLlxuICogQHBhcmFtIGFjY291bnRBbmRDaGFuZ2VJbmRpY2VzIC0gVGhlIGBhY2NvdW50YCBhbmQgYGNoYW5nZWAgaW5kaWNlcyB0aGF0XG4gKiB3aWxsIGJlIHVzZWQgdG8gZGVyaXZlIGFkZHJlc3Nlcy5cbiAqIEByZXR1cm5zIFRoZSBkZXJpdmVyIGZ1bmN0aW9uIGZvciB0aGUgZGVyaXZhdGlvbiBwYXRoIHNwZWNpZmllZCBieSB0aGVcbiAqIGBjb2luX3R5cGVgIG5vZGUsIGBhY2NvdW50YCwgYW5kIGBjaGFuZ2VgIGluZGljZXMuXG4gKi9cbmZ1bmN0aW9uIGdldEJJUDQ0QWRkcmVzc0tleURlcml2ZXIobm9kZSwgYWNjb3VudEFuZENoYW5nZUluZGljZXMpIHtcbiAgICBjb25zdCB7IGFjY291bnQgPSAwLCBjaGFuZ2UgPSAwIH0gPSBhY2NvdW50QW5kQ2hhbmdlSW5kaWNlcyB8fCB7fTtcbiAgICBjb25zdCB7IGtleSwgZGVwdGggfSA9IG5vZGU7XG4gICAgdmFsaWRhdGVDb2luVHlwZU5vZGVEZXB0aChkZXB0aCk7XG4gICAgdmFsaWRhdGVDb2luVHlwZVBhcmVudEtleShrZXkpO1xuICAgIGNvbnN0IHBhcmVudEtleUJ1ZmZlciA9IG5vZGUgaW5zdGFuY2VvZiBCSVA0NENvaW5UeXBlTm9kZVxuICAgICAgICA/IG5vZGUua2V5QnVmZmVyXG4gICAgICAgIDogdXRpbHNfMS5iYXNlNjRTdHJpbmdUb0J1ZmZlcihrZXkpO1xuICAgIGNvbnN0IGFjY291bnROb2RlID0gdXRpbHNfMS5nZXRIYXJkZW5lZEJJUDMyTm9kZVRva2VuKGFjY291bnQpO1xuICAgIGNvbnN0IGNoYW5nZU5vZGUgPSB1dGlsc18xLmdldFVuaGFyZGVuZWRCSVAzMk5vZGVUb2tlbihjaGFuZ2UpO1xuICAgIGNvbnN0IGJpcDQ0QWRkcmVzc0tleURlcml2ZXIgPSAoYWRkcmVzc19pbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gQklQNDROb2RlXzEuZGVyaXZlQ2hpbGROb2RlKHBhcmVudEtleUJ1ZmZlciwgZXhwb3J0cy5CSVBfNDRfQ09JTl9UWVBFX0RFUFRILCBbXG4gICAgICAgICAgICBhY2NvdW50Tm9kZSxcbiAgICAgICAgICAgIGNoYW5nZU5vZGUsXG4gICAgICAgICAgICB1dGlsc18xLmdldFVuaGFyZGVuZWRCSVAzMk5vZGVUb2tlbihhZGRyZXNzX2luZGV4KSxcbiAgICAgICAgXSkua2V5QnVmZmVyO1xuICAgIH07XG4gICAgYmlwNDRBZGRyZXNzS2V5RGVyaXZlci5jb2luX3R5cGUgPSBub2RlLmNvaW5fdHlwZTtcbiAgICBiaXA0NEFkZHJlc3NLZXlEZXJpdmVyLnBhdGggPSB1dGlsc18xLmdldEJJUDQ0Q2hhbmdlUGF0aFN0cmluZyhub2RlLnBhdGgsIHtcbiAgICAgICAgYWNjb3VudCxcbiAgICAgICAgY2hhbmdlLFxuICAgIH0pO1xuICAgIE9iamVjdC5mcmVlemUoYmlwNDRBZGRyZXNzS2V5RGVyaXZlcik7XG4gICAgcmV0dXJuIGJpcDQ0QWRkcmVzc0tleURlcml2ZXI7XG59XG5leHBvcnRzLmdldEJJUDQ0QWRkcmVzc0tleURlcml2ZXIgPSBnZXRCSVA0NEFkZHJlc3NLZXlEZXJpdmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QklQNDRDb2luVHlwZU5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlcml2ZUNoaWxkTm9kZSA9IGV4cG9ydHMuQklQNDROb2RlID0gdm9pZCAwO1xuY29uc3QgZGVyaXZhdGlvbl8xID0gcmVxdWlyZShcIi4vZGVyaXZhdGlvblwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBBIHdyYXBwZXIgZm9yIEJJUC00NCBIaWVyYXJjaGljYWwgRGV0ZXJtaW5pc3RpYyAoSEQpIHRyZWUgbm9kZXMsIGkuZS5cbiAqIGNyeXB0b2dyYXBoaWMga2V5cyB1c2VkIHRvIGdlbmVyYXRlIGtleXBhaXJzIGFuZCBhZGRyZXNzZXMgZm9yIGNyeXB0b2N1cnJlbmN5XG4gKiBwcm90b2NvbHMuXG4gKlxuICogVGhpcyBjbGFzcyBjb250YWlucyBtZXRob2RzIGFuZCBmaWVsZHMgdGhhdCBtYXkgbm90IHNlcmlhbGl6ZSB3ZWxsLiBVc2VcbiAqIHtAbGluayBCSVA0NE5vZGUudG9KU09OfSB0byBnZXQgYSBKU09OLWNvbXBhdGlibGUgcmVwcmVzZW50YXRpb24uXG4gKi9cbmNsYXNzIEJJUDQ0Tm9kZSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBCSVAtNDQgbm9kZS4gQWNjZXB0cyBlaXRoZXI6XG4gICAgICogLSBBbiBleGlzdGluZyA2NC1ieXRlIEJJUC00NCBrZXksIGFuZCBpdHMgKiowLWluZGV4ZWQqKiBCSVAtNDQgcGF0aCBkZXB0aC5cbiAgICAgKiAgIC0gVGhlIGtleSBtYXkgYmUgaW4gdGhlIGZvcm0gb2YgYSBoZXhhZGVjaW1hbCBzdHJpbmcsIEJhc2U2NCBzdHJpbmcsIG9yIGFcbiAgICAgKiAgICAge0BsaW5rIEJ1ZmZlcn0uXG4gICAgICogLSBBIEJJUC00NCBkZXJpdmF0aW9uIHBhdGggc3RhcnRpbmcgd2l0aCBhbiBgbWAgbm9kZS5cbiAgICAgKiAgIC0gQXQgcHJlc2VudCwgdGhlIGBtYCBub2RlIG11c3QgYmUgYSBCSVAtMzkgbm9kZSwgZ2l2ZW4gYXMgYSBzdHJpbmcgb2ZcbiAgICAgKiAgICAgdGhlIGZvcm0gYGJpcDM5Ok1ORU1PTklDYCwgd2hlcmUgYE1ORU1PTklDYCBpcyBhIHNwYWNlLXNlcGFyYXRlZCBsaXN0XG4gICAgICogICAgIG9mIEJJUC0zOSBzZWVkIHBocmFzZSB3b3Jkcy5cbiAgICAgKlxuICAgICAqIEFsbCBwYXJhbWV0ZXJzIGFyZSBzdHJpbmdlbnRseSB2YWxpZGF0ZWQsIGFuZCBhbiBlcnJvciBpcyB0aHJvd24gaWZcbiAgICAgKiB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogUmVjYWxsIHRoYXQgYSBCSVAtNDQgSEQgdHJlZSBwYXRoIGNvbnNpc3RzIG9mIHRoZSBmb2xsb3dpbmcgbm9kZXM6XG4gICAgICpcbiAgICAgKiBgbSAvIDQ0JyAvIGNvaW5fdHlwZScgLyBhY2NvdW50JyAvIGNoYW5nZSAvIGFkZHJlc3NfaW5kZXhgXG4gICAgICpcbiAgICAgKiBXaXRoIHRoZSBmb2xsb3dpbmcgZGVwdGhzOlxuICAgICAqXG4gICAgICogYDAgLyAxIC8gMiAvIDMgLyA0IC8gNWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBiYWcuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVwdGggLSBUaGUgMC1pbmRleGVkIEJJUC00NCB0cmVlIGRlcHRoIG9mIHRoZSBga2V5YCwgaWZcbiAgICAgKiBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMua2V5IC0gVGhlIGtleSBvZiB0aGlzIG5vZGUuIE11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoXG4gICAgICogYGRlcml2YXRpb25QYXRoYCwgYW5kIHJlcXVpcmVzIGEgYGRlcHRoYCB0byBiZSBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVyaXZhdGlvblBhdGggLSBUaGUgcm9vdGVkIEhEIHRyZWUgcGF0aCB0aGF0IHdpbGwgYmUgdXNlZFxuICAgICAqIHRvIGRlcml2ZSB0aGUga2V5IG9mIHRoaXMgbm9kZS4gTXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggYGtleWAuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBkZXB0aCwga2V5LCBkZXJpdmF0aW9uUGF0aCB9KSB7XG4gICAgICAgIGNvbnN0IF9rZXkgPSBCSVA0NE5vZGUuX3BhcnNlS2V5KGtleSk7XG4gICAgICAgIGlmIChkZXJpdmF0aW9uUGF0aCkge1xuICAgICAgICAgICAgaWYgKF9rZXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyczogTWF5IG5vdCBzcGVjaWZ5IGEgZGVyaXZhdGlvbiBwYXRoIGlmIGEga2V5IGlzIHNwZWNpZmllZC4gSW5pdGlhbGl6ZSB0aGUgbm9kZSB3aXRoIGp1c3QgdGhlIHBhcmVudCBrZXkgYW5kIGl0cyBkZXB0aCwgdGhlbiBjYWxsIEJJUDQ0Tm9kZS5kZXJpdmUoKSB3aXRoIHlvdXIgZGVzaXJlZCBwYXRoLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlcHRoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhcmFtZXRlcnM6IE1heSBub3Qgc3BlY2lmeSBhIGRlcHRoIGlmIGEgZGVyaXZhdGlvbiBwYXRoIGlzIHNwZWNpZmllZC4gVGhlIGRlcHRoIHdpbGwgYmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBwYXRoLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlcml2YXRpb25QYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkZXJpdmF0aW9uIHBhdGg6IE1heSBub3Qgc3BlY2lmeSBhbiBlbXB0eSBkZXJpdmF0aW9uIHBhdGguJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBfZGVwdGggPSBkZXJpdmF0aW9uUGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdmFsaWRhdGVCSVA0NERlcHRoKF9kZXB0aCk7XG4gICAgICAgICAgICB0aGlzLmRlcHRoID0gX2RlcHRoO1xuICAgICAgICAgICAgdmFsaWRhdGVCSVA0NERlcml2YXRpb25QYXRoKGRlcml2YXRpb25QYXRoLCBjb25zdGFudHNfMS5NSU5fQklQXzQ0X0RFUFRIKTtcbiAgICAgICAgICAgIHRoaXMua2V5QnVmZmVyID0gZGVyaXZhdGlvbl8xLmRlcml2ZUtleUZyb21QYXRoKGRlcml2YXRpb25QYXRoLCB1bmRlZmluZWQsIHRoaXMuZGVwdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9rZXkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlQklQNDREZXB0aChkZXB0aCk7XG4gICAgICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgICAgICAgICB0aGlzLmtleUJ1ZmZlciA9IF9rZXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyczogTXVzdCBzcGVjaWZ5IGVpdGhlciBrZXkgb3IgZGVyaXZhdGlvbiBwYXRoLicpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIGdldCBrZXkoKSB7XG4gICAgICAgIHJldHVybiB1dGlsc18xLmJ1ZmZlclRvQmFzZTY0U3RyaW5nKHRoaXMua2V5QnVmZmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgaGVscGVyIGZvciB2YWxpZGF0aW5nIGFuZCBwYXJzaW5nIHRoZSBga2V5YCBwYXJhbWV0ZXIuIEFuIGVycm9yXG4gICAgICogaXMgdGhyb3duIGlmIHZhbGlkYXRpb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byBwYXJzZS5cbiAgICAgKiBAcmV0dXJucyBBIHtAbGluayBCdWZmZXJ9LCBvciBgdW5kZWZpbmVkYCBpZiBubyBrZXkgcGFyYW1ldGVyIHdhc1xuICAgICAqIHNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlS2V5KGtleSkge1xuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwga2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBidWZmZXJLZXk7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoa2V5KSkge1xuICAgICAgICAgICAgaWYgKCF1dGlsc18xLmlzVmFsaWRCdWZmZXJLZXkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBidWZmZXIga2V5OiBNdXN0IGJlIGEgNjQtYnl0ZSwgbm9uLWVtcHR5IEJ1ZmZlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlcktleSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHV0aWxzXzEuaXNWYWxpZEhleFN0cmluZ0tleShrZXkpKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyS2V5ID0gdXRpbHNfMS5oZXhTdHJpbmdUb0J1ZmZlcihrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodXRpbHNfMS5pc1ZhbGlkQmFzZTY0U3RyaW5nS2V5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJLZXkgPSB1dGlsc18xLmJhc2U2NFN0cmluZ1RvQnVmZmVyKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nIGtleTogTXVzdCBiZSBhIDY0LWJ5dGUgaGV4YWRlY2ltYWwgb3IgQmFzZTY0IHN0cmluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBrZXk6IE11c3QgYmUgYSBCdWZmZXIgb3Igc3RyaW5nIGlmIHNwZWNpZmllZC4gUmVjZWl2ZWQ6IFwiJHt0eXBlb2Yga2V5fVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcktleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVyaXZlcyBhIGNoaWxkIG9mIHRoZSBrZXkgY29udGFpbnMgYmUgdGhpcyBub2RlIGFuZCByZXR1cm5zIGEgbmV3XG4gICAgICoge0BsaW5rIEJJUDQ0Tm9kZX0gY29udGFpbmluZyB0aGUgY2hpbGQga2V5LlxuICAgICAqXG4gICAgICogVGhlIHNwZWNpZmllZCBwYXRoIG11c3QgYmUgYSB2YWxpZCBIRCBwYXRoIGZyb20gdGhpcyBub2RlLCBwZXIgQklQLTQ0LlxuICAgICAqIEF0IHByZXNlbnQsIHRoaXMgbWVhbnMgdGhhdCB0aGUgcGF0aCBtdXN0IGNvbnNpc3Qgb2Ygbm8gbW9yZSB0aGFuIDUgQklQLTMyXG4gICAgICogbm9kZXMsIGRlcGVuZGluZyBvbiB0aGUgZGVwdGggb2YgdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogUmVjYWxsIHRoYXQgYSBCSVAtNDQgSEQgdHJlZSBwYXRoIGNvbnNpc3RzIG9mIHRoZSBmb2xsb3dpbmcgbm9kZXM6XG4gICAgICpcbiAgICAgKiBgbSAvIDQ0JyAvIGNvaW5fdHlwZScgLyBhY2NvdW50JyAvIGNoYW5nZSAvIGFkZHJlc3NfaW5kZXhgXG4gICAgICpcbiAgICAgKiBXaXRoIHRoZSBmb2xsb3dpbmcgZGVwdGhzOlxuICAgICAqXG4gICAgICogYDAgLyAxIC8gMiAvIDMgLyA0IC8gNWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhcnRpYWwgKG5vbi1yb290ZWQpIEJJUC00NCBIRCB0cmVlIHBhdGggd2lsbCBiZSB1c2VkXG4gICAgICogdG8gZGVyaXZlIGEgY2hpbGQga2V5IGZyb20gdGhlIHBhcmVudCBrZXkgY29udGFpbmVkIHdpdGhpbiB0aGlzIG5vZGUuXG4gICAgICogQHJldHVybnMgVGhlIHtAbGluayBCSVA0NE5vZGV9IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGRlcml2ZWQgY2hpbGQga2V5LlxuICAgICAqL1xuICAgIGRlcml2ZShwYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLmRlcHRoID09PSBjb25zdGFudHNfMS5NQVhfQklQXzQ0X0RFUFRIKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgb3BlcmF0aW9uOiBUaGlzIEhEIHRyZWUgbm9kZSBpcyBhbHJlYWR5IGEgbGVhZiBub2RlLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXJpdmVDaGlsZE5vZGUodGhpcy5rZXlCdWZmZXIsIHRoaXMuZGVwdGgsIHBhdGgpO1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIGRvY3VtZW50ZWQgaW4gdGhlIGludGVyZmFjZSBvZiB0aGlzIGNsYXNzLlxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlcHRoOiB0aGlzLmRlcHRoLFxuICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkJJUDQ0Tm9kZSA9IEJJUDQ0Tm9kZTtcbi8qKlxuICogRGVyaXZlcyBhIGNoaWxkIGtleSBmcm9tIHRoZSBnaXZlbiBwYXJlbnQga2V5LCBhcyBhIHtAbGluayBCSVA0NE5vZGV9LlxuICogQHBhcmFtIHBhcmVudEtleSAtIFRoZSBwYXJlbnQga2V5IHRvIGRlcml2ZSBmcm9tLlxuICogQHBhcmFtIHBhcmVudERlcHRoIC0gVGhlIGRlcHRoIG9mIHRoZSBwYXJlbnQga2V5LlxuICogQHBhcmFtIHBhdGhUb0NoaWxkIC0gVGhlIHBhdGggdG8gdGhlIGNoaWxkIG5vZGUgLyBrZXkuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIEJJUDQ0Tm9kZX0gY29ycmVzcG9uZGluZyB0byB0aGUgZGVyaXZlZCBjaGlsZCBrZXkuXG4gKi9cbmZ1bmN0aW9uIGRlcml2ZUNoaWxkTm9kZShwYXJlbnRLZXksIHBhcmVudERlcHRoLCBwYXRoVG9DaGlsZCkge1xuICAgIGlmIChwYXRoVG9DaGlsZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEhEIHRyZWUgZGVyaXZhdGlvbiBwYXRoOiBEZXJpdmluZyBhIHBhdGggb2YgbGVuZ3RoIDAgaXMgbm90IGRlZmluZWQnKTtcbiAgICB9XG4gICAgLy8gTm90ZSB0aGF0IHdlIGRvIG5vdCBzdWJ0cmFjdCAxIGZyb20gdGhlIGxlbmd0aCBvZiB0aGUgcGF0aCB0byB0aGUgY2hpbGQsXG4gICAgLy8gdW5saWtlIHdoZW4gd2UgY2FsY3VsYXRlIHRoZSBkZXB0aCBvZiBhIHJvb3RlZCBwYXRoLlxuICAgIGNvbnN0IG5ld0RlcHRoID0gKHBhcmVudERlcHRoICsgcGF0aFRvQ2hpbGQubGVuZ3RoKTtcbiAgICB2YWxpZGF0ZUJJUDQ0RGVwdGgobmV3RGVwdGgpO1xuICAgIHZhbGlkYXRlQklQNDREZXJpdmF0aW9uUGF0aChwYXRoVG9DaGlsZCwgKHBhcmVudERlcHRoICsgMSkpO1xuICAgIHJldHVybiBuZXcgQklQNDROb2RlKHtcbiAgICAgICAgZGVwdGg6IG5ld0RlcHRoLFxuICAgICAgICBrZXk6IGRlcml2YXRpb25fMS5kZXJpdmVLZXlGcm9tUGF0aChwYXRoVG9DaGlsZCwgcGFyZW50S2V5KSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVyaXZlQ2hpbGROb2RlID0gZGVyaXZlQ2hpbGROb2RlO1xuLyoqXG4gKiBWYWxpZGF0ZXMgYSBCSVAtNDQgcGF0aCBkZXB0aC4gRWZmZWN0aXZlbHksIGFzc2VydHMgdGhhdCB0aGUgZGVwdGggaXMgYW5cbiAqIGludGVnZXIgYG51bWJlcmAgTiBzdWNoIHRoYXQgMCA8PSBOIDw9IDUuIFRocm93cyBhbiBlcnJvciBpZiB2YWxpZGF0aW9uXG4gKiBmYWlscy5cbiAqXG4gKiBAcGFyYW0gZGVwdGggLSBUaGUgZGVwdGggdG8gdmFsaWRhdGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQklQNDREZXB0aChkZXB0aCkge1xuICAgIGlmICh0eXBlb2YgZGVwdGggIT09ICdudW1iZXInIHx8XG4gICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKGRlcHRoKSB8fFxuICAgICAgICBkZXB0aCA8IGNvbnN0YW50c18xLk1JTl9CSVBfNDRfREVQVEggfHxcbiAgICAgICAgZGVwdGggPiBjb25zdGFudHNfMS5NQVhfQklQXzQ0X0RFUFRIKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBIRCB0cmVlIHBhdGggZGVwdGg6IFRoZSBkZXB0aCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBOIHN1Y2ggdGhhdCAwIDw9IE4gPD0gNS4gUmVjZWl2ZWQ6IFwiJHtkZXB0aH1cImApO1xuICAgIH1cbn1cbi8qKlxuICogRW5zdXJlcyB0aGF0IHRoZSBnaXZlbiBkZXJpdmF0aW9uIGlzIHZhbGlkIGJ5IEJJUC00NC5cbiAqXG4gKiBSZWNhbGwgdGhhdCBhIEJJUC00NCBIRCB0cmVlIHBhdGggY29uc2lzdHMgb2YgdGhlIGZvbGxvd2luZyBub2RlczpcbiAqXG4gKiBgbSAvIDQ0JyAvIGNvaW5fdHlwZScgLyBhY2NvdW50JyAvIGNoYW5nZSAvIGFkZHJlc3NfaW5kZXhgXG4gKlxuICogV2l0aCB0aGUgZm9sbG93aW5nIGRlcHRoczpcbiAqXG4gKiBgMCAvIDEgLyAyIC8gMyAvIDQgLyA1YFxuICpcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gc3RhcnRpbmdEZXB0aCAtIFRoZSBkZXB0aCBvZiB0aGUgZmlyc3Qgbm9kZSBvZiB0aGUgZGVyaXZhdGlvbiBwYXRoLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUJJUDQ0RGVyaXZhdGlvblBhdGgocGF0aCwgc3RhcnRpbmdEZXB0aCkge1xuICAgIHBhdGguZm9yRWFjaCgobm9kZVRva2VuLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50RGVwdGggPSBzdGFydGluZ0RlcHRoICsgaW5kZXg7XG4gICAgICAgIHN3aXRjaCAoY3VycmVudERlcHRoKSB7XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLk1JTl9CSVBfNDRfREVQVEg6XG4gICAgICAgICAgICAgICAgaWYgKCFjb25zdGFudHNfMS5CSVBfMzlfUEFUSF9SRUdFWC50ZXN0KG5vZGVUb2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRlcml2YXRpb24gcGF0aDogVGhlIFwibVwiIC8gc2VlZCBub2RlIChkZXB0aCAwKSBtdXN0IGJlIGEgQklQLTM5IG5vZGUuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGlmIChub2RlVG9rZW4gIT09IGNvbnN0YW50c18xLkJJUDQ0UHVycG9zZU5vZGVUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGVyaXZhdGlvbiBwYXRoOiBUaGUgXCJwdXJwb3NlXCIgbm9kZSBub2RlIChkZXB0aCAxKSBtdXN0IGJlIHRoZSBzdHJpbmcgXCIke2NvbnN0YW50c18xLkJJUDQ0UHVycG9zZU5vZGVUb2tlbn1cIi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgaWYgKCFjb25zdGFudHNfMS5CSVBfMzJfUEFUSF9SRUdFWC50ZXN0KG5vZGVUb2tlbikgfHwgIXV0aWxzXzEuaXNIYXJkZW5lZChub2RlVG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkZXJpdmF0aW9uIHBhdGg6IFRoZSBcImNvaW5fdHlwZVwiIG5vZGUgKGRlcHRoIDIpIG11c3QgYmUgYSBoYXJkZW5lZCBCSVAtMzIgbm9kZS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKCFjb25zdGFudHNfMS5CSVBfMzJfUEFUSF9SRUdFWC50ZXN0KG5vZGVUb2tlbikgfHwgIXV0aWxzXzEuaXNIYXJkZW5lZChub2RlVG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkZXJpdmF0aW9uIHBhdGg6IFRoZSBcImFjY291bnRcIiBub2RlIChkZXB0aCAzKSBtdXN0IGJlIGEgaGFyZGVuZWQgQklQLTMyIG5vZGUuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGlmICghY29uc3RhbnRzXzEuQklQXzMyX1BBVEhfUkVHRVgudGVzdChub2RlVG9rZW4pIHx8IHV0aWxzXzEuaXNIYXJkZW5lZChub2RlVG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkZXJpdmF0aW9uIHBhdGg6IFRoZSBcImNoYW5nZVwiIG5vZGUgKGRlcHRoIDQpIG11c3QgYmUgYW4gdW5oYXJkZW5lZCBCSVAtMzIgbm9kZS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLk1BWF9CSVBfNDRfREVQVEg6IC8vIDVcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnN0YW50c18xLkJJUF8zMl9QQVRIX1JFR0VYLnRlc3Qobm9kZVRva2VuKSB8fCB1dGlsc18xLmlzSGFyZGVuZWQobm9kZVRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGVyaXZhdGlvbiBwYXRoOiBUaGUgXCJhZGRyZXNzX2luZGV4XCIgbm9kZSAoZGVwdGggNSkgbXVzdCBiZSBhbiB1bmhhcmRlbmVkIEJJUC0zMiBub2RlLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzaG91bGQgYmUgaW1wb3NzaWJsZSBpbiBvdXIgdXNhZ2UgKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRlcml2YXRpb24gcGF0aDogVGhlIHBhdGggZXhjZWVkcyB0aGUgbWF4aW11bSBCSVAtNDQgZGVwdGguYCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJJUDQ0Tm9kZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZFxcK1xcLVxcLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gVGhpcyBmaWxlIGlzIGltcG9ydGVkIGZyb20gc2VjcDI1NmsxIHYzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL3NlY3AyNTZrMS1ub2RlL2Jsb2IvbWFzdGVyL0xJQ0VOU0Vcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFQ19QUklWS0VZX0VYUE9SVF9ERVJfQ09NUFJFU1NFRCA9IEJ1ZmZlci5mcm9tKFtcbiAgICAvLyBiZWdpblxuICAgIDB4MzAsXG4gICAgMHg4MSxcbiAgICAweGQzLFxuICAgIDB4MDIsXG4gICAgMHgwMSxcbiAgICAweDAxLFxuICAgIDB4MDQsXG4gICAgMHgyMCxcbiAgICAvLyBwcml2YXRlIGtleVxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAvLyBtaWRkbGVcbiAgICAweGEwLFxuICAgIDB4ODEsXG4gICAgMHg4NSxcbiAgICAweDMwLFxuICAgIDB4ODEsXG4gICAgMHg4MixcbiAgICAweDAyLFxuICAgIDB4MDEsXG4gICAgMHgwMSxcbiAgICAweDMwLFxuICAgIDB4MmMsXG4gICAgMHgwNixcbiAgICAweDA3LFxuICAgIDB4MmEsXG4gICAgMHg4NixcbiAgICAweDQ4LFxuICAgIDB4Y2UsXG4gICAgMHgzZCxcbiAgICAweDAxLFxuICAgIDB4MDEsXG4gICAgMHgwMixcbiAgICAweDIxLFxuICAgIDB4MDAsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZSxcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmYyxcbiAgICAweDJmLFxuICAgIDB4MzAsXG4gICAgMHgwNixcbiAgICAweDA0LFxuICAgIDB4MDEsXG4gICAgMHgwMCxcbiAgICAweDA0LFxuICAgIDB4MDEsXG4gICAgMHgwNyxcbiAgICAweDA0LFxuICAgIDB4MjEsXG4gICAgMHgwMixcbiAgICAweDc5LFxuICAgIDB4YmUsXG4gICAgMHg2NixcbiAgICAweDdlLFxuICAgIDB4ZjksXG4gICAgMHhkYyxcbiAgICAweGJiLFxuICAgIDB4YWMsXG4gICAgMHg1NSxcbiAgICAweGEwLFxuICAgIDB4NjIsXG4gICAgMHg5NSxcbiAgICAweGNlLFxuICAgIDB4ODcsXG4gICAgMHgwYixcbiAgICAweDA3LFxuICAgIDB4MDIsXG4gICAgMHg5YixcbiAgICAweGZjLFxuICAgIDB4ZGIsXG4gICAgMHgyZCxcbiAgICAweGNlLFxuICAgIDB4MjgsXG4gICAgMHhkOSxcbiAgICAweDU5LFxuICAgIDB4ZjIsXG4gICAgMHg4MSxcbiAgICAweDViLFxuICAgIDB4MTYsXG4gICAgMHhmOCxcbiAgICAweDE3LFxuICAgIDB4OTgsXG4gICAgMHgwMixcbiAgICAweDIxLFxuICAgIDB4MDAsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZSxcbiAgICAweGJhLFxuICAgIDB4YWUsXG4gICAgMHhkYyxcbiAgICAweGU2LFxuICAgIDB4YWYsXG4gICAgMHg0OCxcbiAgICAweGEwLFxuICAgIDB4M2IsXG4gICAgMHhiZixcbiAgICAweGQyLFxuICAgIDB4NWUsXG4gICAgMHg4YyxcbiAgICAweGQwLFxuICAgIDB4MzYsXG4gICAgMHg0MSxcbiAgICAweDQxLFxuICAgIDB4MDIsXG4gICAgMHgwMSxcbiAgICAweDAxLFxuICAgIDB4YTEsXG4gICAgMHgyNCxcbiAgICAweDAzLFxuICAgIDB4MjIsXG4gICAgMHgwMCxcbiAgICAvLyBwdWJsaWMga2V5XG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG5dKTtcbnZhciBFQ19QUklWS0VZX0VYUE9SVF9ERVJfVU5DT01QUkVTU0VEID0gQnVmZmVyLmZyb20oW1xuICAgIC8vIGJlZ2luXG4gICAgMHgzMCxcbiAgICAweDgyLFxuICAgIDB4MDEsXG4gICAgMHgxMyxcbiAgICAweDAyLFxuICAgIDB4MDEsXG4gICAgMHgwMSxcbiAgICAweDA0LFxuICAgIDB4MjAsXG4gICAgLy8gcHJpdmF0ZSBrZXlcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgLy8gbWlkZGxlXG4gICAgMHhhMCxcbiAgICAweDgxLFxuICAgIDB4YTUsXG4gICAgMHgzMCxcbiAgICAweDgxLFxuICAgIDB4YTIsXG4gICAgMHgwMixcbiAgICAweDAxLFxuICAgIDB4MDEsXG4gICAgMHgzMCxcbiAgICAweDJjLFxuICAgIDB4MDYsXG4gICAgMHgwNyxcbiAgICAweDJhLFxuICAgIDB4ODYsXG4gICAgMHg0OCxcbiAgICAweGNlLFxuICAgIDB4M2QsXG4gICAgMHgwMSxcbiAgICAweDAxLFxuICAgIDB4MDIsXG4gICAgMHgyMSxcbiAgICAweDAwLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmUsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmMsXG4gICAgMHgyZixcbiAgICAweDMwLFxuICAgIDB4MDYsXG4gICAgMHgwNCxcbiAgICAweDAxLFxuICAgIDB4MDAsXG4gICAgMHgwNCxcbiAgICAweDAxLFxuICAgIDB4MDcsXG4gICAgMHgwNCxcbiAgICAweDQxLFxuICAgIDB4MDQsXG4gICAgMHg3OSxcbiAgICAweGJlLFxuICAgIDB4NjYsXG4gICAgMHg3ZSxcbiAgICAweGY5LFxuICAgIDB4ZGMsXG4gICAgMHhiYixcbiAgICAweGFjLFxuICAgIDB4NTUsXG4gICAgMHhhMCxcbiAgICAweDYyLFxuICAgIDB4OTUsXG4gICAgMHhjZSxcbiAgICAweDg3LFxuICAgIDB4MGIsXG4gICAgMHgwNyxcbiAgICAweDAyLFxuICAgIDB4OWIsXG4gICAgMHhmYyxcbiAgICAweGRiLFxuICAgIDB4MmQsXG4gICAgMHhjZSxcbiAgICAweDI4LFxuICAgIDB4ZDksXG4gICAgMHg1OSxcbiAgICAweGYyLFxuICAgIDB4ODEsXG4gICAgMHg1YixcbiAgICAweDE2LFxuICAgIDB4ZjgsXG4gICAgMHgxNyxcbiAgICAweDk4LFxuICAgIDB4NDgsXG4gICAgMHgzYSxcbiAgICAweGRhLFxuICAgIDB4NzcsXG4gICAgMHgyNixcbiAgICAweGEzLFxuICAgIDB4YzQsXG4gICAgMHg2NSxcbiAgICAweDVkLFxuICAgIDB4YTQsXG4gICAgMHhmYixcbiAgICAweGZjLFxuICAgIDB4MGUsXG4gICAgMHgxMSxcbiAgICAweDA4LFxuICAgIDB4YTgsXG4gICAgMHhmZCxcbiAgICAweDE3LFxuICAgIDB4YjQsXG4gICAgMHg0OCxcbiAgICAweGE2LFxuICAgIDB4ODUsXG4gICAgMHg1NCxcbiAgICAweDE5LFxuICAgIDB4OWMsXG4gICAgMHg0NyxcbiAgICAweGQwLFxuICAgIDB4OGYsXG4gICAgMHhmYixcbiAgICAweDEwLFxuICAgIDB4ZDQsXG4gICAgMHhiOCxcbiAgICAweDAyLFxuICAgIDB4MjEsXG4gICAgMHgwMCxcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZlLFxuICAgIDB4YmEsXG4gICAgMHhhZSxcbiAgICAweGRjLFxuICAgIDB4ZTYsXG4gICAgMHhhZixcbiAgICAweDQ4LFxuICAgIDB4YTAsXG4gICAgMHgzYixcbiAgICAweGJmLFxuICAgIDB4ZDIsXG4gICAgMHg1ZSxcbiAgICAweDhjLFxuICAgIDB4ZDAsXG4gICAgMHgzNixcbiAgICAweDQxLFxuICAgIDB4NDEsXG4gICAgMHgwMixcbiAgICAweDAxLFxuICAgIDB4MDEsXG4gICAgMHhhMSxcbiAgICAweDQ0LFxuICAgIDB4MDMsXG4gICAgMHg0MixcbiAgICAweDAwLFxuICAgIC8vIHB1YmxpYyBrZXlcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG5dKTtcbmV4cG9ydHMucHJpdmF0ZUtleUV4cG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBwdWJsaWNLZXksIGNvbXByZXNzZWQpIHtcbiAgICBpZiAoY29tcHJlc3NlZCA9PT0gdm9pZCAwKSB7IGNvbXByZXNzZWQgPSB0cnVlOyB9XG4gICAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5mcm9tKGNvbXByZXNzZWQgPyBFQ19QUklWS0VZX0VYUE9SVF9ERVJfQ09NUFJFU1NFRCA6IEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9VTkNPTVBSRVNTRUQpO1xuICAgIHByaXZhdGVLZXkuY29weShyZXN1bHQsIGNvbXByZXNzZWQgPyA4IDogOSk7XG4gICAgcHVibGljS2V5LmNvcHkocmVzdWx0LCBjb21wcmVzc2VkID8gMTgxIDogMjE0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMucHJpdmF0ZUtleUltcG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgdmFyIGxlbmd0aCA9IHByaXZhdGVLZXkubGVuZ3RoO1xuICAgIC8vIHNlcXVlbmNlIGhlYWRlclxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMSB8fCBwcml2YXRlS2V5W2luZGV4XSAhPT0gMHgzMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaW5kZXggKz0gMTtcbiAgICAvLyBzZXF1ZW5jZSBsZW5ndGggY29uc3RydWN0b3JcbiAgICBpZiAobGVuZ3RoIDwgaW5kZXggKyAxIHx8ICEocHJpdmF0ZUtleVtpbmRleF0gJiAweDgwKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgdmFyIGxlbmIgPSBwcml2YXRlS2V5W2luZGV4XSAmIDB4N2Y7XG4gICAgaW5kZXggKz0gMTtcbiAgICBpZiAobGVuYiA8IDEgfHwgbGVuYiA+IDIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChsZW5ndGggPCBpbmRleCArIGxlbmIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIHNlcXVlbmNlIGxlbmd0aFxuICAgIHZhciBsZW4gPSBwcml2YXRlS2V5W2luZGV4ICsgbGVuYiAtIDFdIHwgKGxlbmIgPiAxID8gcHJpdmF0ZUtleVtpbmRleCArIGxlbmIgLSAyXSA8PCA4IDogMCk7XG4gICAgaW5kZXggKz0gbGVuYjtcbiAgICBpZiAobGVuZ3RoIDwgaW5kZXggKyBsZW4pXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIHNlcXVlbmNlIGVsZW1lbnQgMDogdmVyc2lvbiBudW1iZXIgKD0xKVxuICAgIGlmIChsZW5ndGggPCBpbmRleCArIDMgfHxcbiAgICAgICAgcHJpdmF0ZUtleVtpbmRleF0gIT09IDB4MDIgfHxcbiAgICAgICAgcHJpdmF0ZUtleVtpbmRleCArIDFdICE9PSAweDAxIHx8XG4gICAgICAgIHByaXZhdGVLZXlbaW5kZXggKyAyXSAhPT0gMHgwMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaW5kZXggKz0gMztcbiAgICAvLyBzZXF1ZW5jZSBlbGVtZW50IDE6IG9jdGV0IHN0cmluZywgdXAgdG8gMzIgYnl0ZXNcbiAgICBpZiAobGVuZ3RoIDwgaW5kZXggKyAyIHx8XG4gICAgICAgIHByaXZhdGVLZXlbaW5kZXhdICE9PSAweDA0IHx8XG4gICAgICAgIHByaXZhdGVLZXlbaW5kZXggKyAxXSA+IDB4MjAgfHxcbiAgICAgICAgbGVuZ3RoIDwgaW5kZXggKyAyICsgcHJpdmF0ZUtleVtpbmRleCArIDFdKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcHJpdmF0ZUtleS5zbGljZShpbmRleCArIDIsIGluZGV4ICsgMiArIHByaXZhdGVLZXlbaW5kZXggKyAxXSk7XG59O1xuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnRMYXggPSBmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG4gICAgdmFyIHIgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuICAgIHZhciBzID0gQnVmZmVyLmFsbG9jKDMyLCAwKTtcbiAgICB2YXIgbGVuZ3RoID0gc2lnbmF0dXJlLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIC8vIHNlcXVlbmNlIHRhZyBieXRlXG4gICAgaWYgKHNpZ25hdHVyZVtpbmRleCsrXSAhPT0gMHgzMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gc2VxdWVuY2UgbGVuZ3RoIGJ5dGVcbiAgICB2YXIgbGVuYnl0ZSA9IHNpZ25hdHVyZVtpbmRleCsrXTtcbiAgICBpZiAobGVuYnl0ZSAmIDB4ODApIHtcbiAgICAgICAgaW5kZXggKz0gbGVuYnl0ZSAtIDB4ODA7XG4gICAgICAgIGlmIChpbmRleCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc2VxdWVuY2UgdGFnIGJ5dGUgZm9yIHJcbiAgICBpZiAoc2lnbmF0dXJlW2luZGV4KytdICE9PSAweDAyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBsZW5ndGggZm9yIHJcbiAgICB2YXIgcmxlbiA9IHNpZ25hdHVyZVtpbmRleCsrXTtcbiAgICBpZiAocmxlbiAmIDB4ODApIHtcbiAgICAgICAgbGVuYnl0ZSA9IHJsZW4gLSAweDgwO1xuICAgICAgICBpZiAoaW5kZXggKyBsZW5ieXRlID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgbGVuYnl0ZSA+IDAgJiYgc2lnbmF0dXJlW2luZGV4XSA9PT0gMHgwMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKVxuICAgICAgICAgICAgO1xuICAgICAgICBmb3IgKHJsZW4gPSAwOyBsZW5ieXRlID4gMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKVxuICAgICAgICAgICAgcmxlbiA9IChybGVuIDw8IDgpICsgc2lnbmF0dXJlW2luZGV4XTtcbiAgICB9XG4gICAgaWYgKHJsZW4gPiBsZW5ndGggLSBpbmRleCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHJpbmRleCA9IGluZGV4O1xuICAgIGluZGV4ICs9IHJsZW47XG4gICAgLy8gc2VxdWVuY2UgdGFnIGJ5dGUgZm9yIHNcbiAgICBpZiAoc2lnbmF0dXJlW2luZGV4KytdICE9PSAweDAyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBsZW5ndGggZm9yIHNcbiAgICB2YXIgc2xlbiA9IHNpZ25hdHVyZVtpbmRleCsrXTtcbiAgICBpZiAoc2xlbiAmIDB4ODApIHtcbiAgICAgICAgbGVuYnl0ZSA9IHNsZW4gLSAweDgwO1xuICAgICAgICBpZiAoaW5kZXggKyBsZW5ieXRlID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgbGVuYnl0ZSA+IDAgJiYgc2lnbmF0dXJlW2luZGV4XSA9PT0gMHgwMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKVxuICAgICAgICAgICAgO1xuICAgICAgICBmb3IgKHNsZW4gPSAwOyBsZW5ieXRlID4gMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKVxuICAgICAgICAgICAgc2xlbiA9IChzbGVuIDw8IDgpICsgc2lnbmF0dXJlW2luZGV4XTtcbiAgICB9XG4gICAgaWYgKHNsZW4gPiBsZW5ndGggLSBpbmRleCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHNpbmRleCA9IGluZGV4O1xuICAgIGluZGV4ICs9IHNsZW47XG4gICAgLy8gaWdub3JlIGxlYWRpbmcgemVyb3MgaW4gclxuICAgIGZvciAoOyBybGVuID4gMCAmJiBzaWduYXR1cmVbcmluZGV4XSA9PT0gMHgwMDsgcmxlbiAtPSAxLCByaW5kZXggKz0gMSlcbiAgICAgICAgO1xuICAgIC8vIGNvcHkgciB2YWx1ZVxuICAgIGlmIChybGVuID4gMzIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBydmFsdWUgPSBzaWduYXR1cmUuc2xpY2UocmluZGV4LCByaW5kZXggKyBybGVuKTtcbiAgICBydmFsdWUuY29weShyLCAzMiAtIHJ2YWx1ZS5sZW5ndGgpO1xuICAgIC8vIGlnbm9yZSBsZWFkaW5nIHplcm9zIGluIHNcbiAgICBmb3IgKDsgc2xlbiA+IDAgJiYgc2lnbmF0dXJlW3NpbmRleF0gPT09IDB4MDA7IHNsZW4gLT0gMSwgc2luZGV4ICs9IDEpXG4gICAgICAgIDtcbiAgICAvLyBjb3B5IHMgdmFsdWVcbiAgICBpZiAoc2xlbiA+IDMyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgc3ZhbHVlID0gc2lnbmF0dXJlLnNsaWNlKHNpbmRleCwgc2luZGV4ICsgc2xlbik7XG4gICAgc3ZhbHVlLmNvcHkocywgMzIgLSBzdmFsdWUubGVuZ3RoKTtcbiAgICByZXR1cm4geyByOiByLCBzOiBzIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8gVGhpcyBmaWxlIGlzIGltcG9ydGVkIGZyb20gc2VjcDI1NmsxIHYzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL3NlY3AyNTZrMS1ub2RlL2Jsb2IvbWFzdGVyL0xJQ0VOU0Vcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCTiA9IHJlcXVpcmUoXCJibi5qc1wiKTtcbnZhciBFQyA9IHJlcXVpcmUoJ2VsbGlwdGljJykuZWM7XG52YXIgZWMgPSBuZXcgRUMoJ3NlY3AyNTZrMScpO1xudmFyIGVjcGFyYW1zID0gZWMuY3VydmU7XG5leHBvcnRzLnByaXZhdGVLZXlFeHBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICAgIGlmIChjb21wcmVzc2VkID09PSB2b2lkIDApIHsgY29tcHJlc3NlZCA9IHRydWU7IH1cbiAgICB2YXIgZCA9IG5ldyBCTihwcml2YXRlS2V5KTtcbiAgICBpZiAoZC51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY291bGRuJ3QgZXhwb3J0IHRvIERFUiBmb3JtYXRcIik7XG4gICAgfVxuICAgIHZhciBwb2ludCA9IGVjLmcubXVsKGQpO1xuICAgIHJldHVybiB0b1B1YmxpY0tleShwb2ludC5nZXRYKCksIHBvaW50LmdldFkoKSwgY29tcHJlc3NlZCk7XG59O1xuZXhwb3J0cy5wcml2YXRlS2V5TW9kSW52ZXJzZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgdmFyIGJuID0gbmV3IEJOKHByaXZhdGVLZXkpO1xuICAgIGlmIChibi51Y21wKGVjcGFyYW1zLm4pID49IDAgfHwgYm4uaXNaZXJvKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcml2YXRlIGtleSByYW5nZSBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICAgIHJldHVybiBibi5pbnZtKGVjcGFyYW1zLm4pLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpO1xufTtcbmV4cG9ydHMuc2lnbmF0dXJlSW1wb3J0ID0gZnVuY3Rpb24gKHNpZ09iaikge1xuICAgIHZhciByID0gbmV3IEJOKHNpZ09iai5yKTtcbiAgICBpZiAoci51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICAgICAgciA9IG5ldyBCTigwKTtcbiAgICB9XG4gICAgdmFyIHMgPSBuZXcgQk4oc2lnT2JqLnMpO1xuICAgIGlmIChzLnVjbXAoZWNwYXJhbXMubikgPj0gMCkge1xuICAgICAgICBzID0gbmV3IEJOKDApO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbci50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKSwgcy50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKV0pO1xufTtcbmV4cG9ydHMuZWNkaFVuc2FmZSA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgICBpZiAoY29tcHJlc3NlZCA9PT0gdm9pZCAwKSB7IGNvbXByZXNzZWQgPSB0cnVlOyB9XG4gICAgdmFyIHBvaW50ID0gZWMua2V5RnJvbVB1YmxpYyhwdWJsaWNLZXkpO1xuICAgIHZhciBzY2FsYXIgPSBuZXcgQk4ocHJpdmF0ZUtleSk7XG4gICAgaWYgKHNjYWxhci51Y21wKGVjcGFyYW1zLm4pID49IDAgfHwgc2NhbGFyLmlzWmVybygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2NhbGFyIHdhcyBpbnZhbGlkICh6ZXJvIG9yIG92ZXJmbG93KScpO1xuICAgIH1cbiAgICB2YXIgc2hhcmVkID0gcG9pbnQucHViLm11bChzY2FsYXIpO1xuICAgIHJldHVybiB0b1B1YmxpY0tleShzaGFyZWQuZ2V0WCgpLCBzaGFyZWQuZ2V0WSgpLCBjb21wcmVzc2VkKTtcbn07XG52YXIgdG9QdWJsaWNLZXkgPSBmdW5jdGlvbiAoeCwgeSwgY29tcHJlc3NlZCkge1xuICAgIHZhciBwdWJsaWNLZXk7XG4gICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgcHVibGljS2V5ID0gQnVmZmVyLmFsbG9jKDMzKTtcbiAgICAgICAgcHVibGljS2V5WzBdID0geS5pc09kZCgpID8gMHgwMyA6IDB4MDI7XG4gICAgICAgIHgudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMikuY29weShwdWJsaWNLZXksIDEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHVibGljS2V5ID0gQnVmZmVyLmFsbG9jKDY1KTtcbiAgICAgICAgcHVibGljS2V5WzBdID0gMHgwNDtcbiAgICAgICAgeC50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKS5jb3B5KHB1YmxpY0tleSwgMSk7XG4gICAgICAgIHkudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMikuY29weShwdWJsaWNLZXksIDMzKTtcbiAgICB9XG4gICAgcmV0dXJuIHB1YmxpY0tleTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGRlZmF1bHRCYXNlID0gc2VsZi5sb2NhdGlvbiA/XG4gICAgc2VsZi5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBzZWxmLmxvY2F0aW9uLmhvc3QgOlxuICAgICcnO1xuY29uc3QgVVJMID0gc2VsZi5VUkw7XG5cbmNsYXNzIFVSTFdpdGhMZWdhY3lTdXBwb3J0IHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwgPSAnJywgYmFzZSA9IGRlZmF1bHRCYXNlKSB7XG4gICAgICAgIHRoaXMuc3VwZXIgPSBuZXcgVVJMKHVybCwgYmFzZSk7XG4gICAgICAgIHRoaXMucGF0aCA9IHRoaXMucGF0aG5hbWUgKyB0aGlzLnNlYXJjaDtcbiAgICAgICAgdGhpcy5hdXRoID1cbiAgICAgICAgICAgIHRoaXMudXNlcm5hbWUgJiYgdGhpcy5wYXNzd29yZCA/XG4gICAgICAgICAgICAgICAgdGhpcy51c2VybmFtZSArICc6JyArIHRoaXMucGFzc3dvcmQgOlxuICAgICAgICAgICAgICAgIG51bGw7XG5cbiAgICAgICAgdGhpcy5xdWVyeSA9XG4gICAgICAgICAgICB0aGlzLnNlYXJjaCAmJiB0aGlzLnNlYXJjaC5zdGFydHNXaXRoKCc/JykgP1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLnNsaWNlKDEpIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIGdldCBoYXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5oYXNoO1xuICAgIH1cbiAgICBnZXQgaG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIuaG9zdDtcbiAgICB9XG4gICAgZ2V0IGhvc3RuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5ob3N0bmFtZTtcbiAgICB9XG4gICAgZ2V0IGhyZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLmhyZWY7XG4gICAgfVxuICAgIGdldCBvcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLm9yaWdpbjtcbiAgICB9XG4gICAgZ2V0IHBhc3N3b3JkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5wYXNzd29yZDtcbiAgICB9XG4gICAgZ2V0IHBhdGhuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5wYXRobmFtZTtcbiAgICB9XG4gICAgZ2V0IHBvcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLnBvcnQ7XG4gICAgfVxuICAgIGdldCBwcm90b2NvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIucHJvdG9jb2w7XG4gICAgfVxuICAgIGdldCBzZWFyY2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLnNlYXJjaDtcbiAgICB9XG4gICAgZ2V0IHNlYXJjaFBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIuc2VhcmNoUGFyYW1zO1xuICAgIH1cbiAgICBnZXQgdXNlcm5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLnVzZXJuYW1lO1xuICAgIH1cblxuICAgIHNldCBoYXNoKGhhc2gpIHtcbiAgICAgICAgdGhpcy5zdXBlci5oYXNoID0gaGFzaDtcbiAgICB9XG4gICAgc2V0IGhvc3QoaG9zdCkge1xuICAgICAgICB0aGlzLnN1cGVyLmhvc3QgPSBob3N0O1xuICAgIH1cbiAgICBzZXQgaG9zdG5hbWUoaG9zdG5hbWUpIHtcbiAgICAgICAgdGhpcy5zdXBlci5ob3N0bmFtZSA9IGhvc3RuYW1lO1xuICAgIH1cbiAgICBzZXQgaHJlZihocmVmKSB7XG4gICAgICAgIHRoaXMuc3VwZXIuaHJlZiA9IGhyZWY7XG4gICAgfVxuICAgIHNldCBvcmlnaW4ob3JpZ2luKSB7XG4gICAgICAgIHRoaXMuc3VwZXIub3JpZ2luID0gb3JpZ2luO1xuICAgIH1cbiAgICBzZXQgcGFzc3dvcmQocGFzc3dvcmQpIHtcbiAgICAgICAgdGhpcy5zdXBlci5wYXNzd29yZCA9IHBhc3N3b3JkO1xuICAgIH1cbiAgICBzZXQgcGF0aG5hbWUocGF0aG5hbWUpIHtcbiAgICAgICAgdGhpcy5zdXBlci5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgIH1cbiAgICBzZXQgcG9ydChwb3J0KSB7XG4gICAgICAgIHRoaXMuc3VwZXIucG9ydCA9IHBvcnQ7XG4gICAgfVxuICAgIHNldCBwcm90b2NvbChwcm90b2NvbCkge1xuICAgICAgICB0aGlzLnN1cGVyLnByb3RvY29sID0gcHJvdG9jb2w7XG4gICAgfVxuICAgIHNldCBzZWFyY2goc2VhcmNoKSB7XG4gICAgICAgIHRoaXMuc3VwZXIuc2VhcmNoID0gc2VhcmNoO1xuICAgIH1cbiAgICBzZXQgc2VhcmNoUGFyYW1zKHNlYXJjaFBhcmFtcykge1xuICAgICAgICB0aGlzLnN1cGVyLnNlYXJjaFBhcmFtcyA9IHNlYXJjaFBhcmFtcztcbiAgICB9XG4gICAgc2V0IHVzZXJuYW1lKHVzZXJuYW1lKSB7XG4gICAgICAgIHRoaXMuc3VwZXIudXNlcm5hbWUgPSB1c2VybmFtZTtcbiAgICB9XG5cbiAgICBjcmVhdGVPYmplY3RVUkwobykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5jcmVhdGVPYmplY3RVUkwobyk7XG4gICAgfVxuICAgIHJldm9rZU9iamVjdFVSTChvKSB7XG4gICAgICAgIHRoaXMuc3VwZXIucmV2b2tlT2JqZWN0VVJMKG8pO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLnRvSlNPTigpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0KG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKG9iaik7XG5cbiAgICAgICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgY29uc3QgdXNlclBhc3MgPVxuICAgICAgICAgICAgb2JqLnVzZXJuYW1lICYmIG9iai5wYXNzd29yZCA/XG4gICAgICAgICAgICAgICAgYCR7b2JqLnVzZXJuYW1lfToke29iai5wYXNzd29yZH1AYCA6XG4gICAgICAgICAgICAgICAgJyc7XG4gICAgICAgIGNvbnN0IGF1dGggPSBvYmouYXV0aCA/IG9iai5hdXRoICsgJ0AnIDogJyc7XG4gICAgICAgIGNvbnN0IHBvcnQgPSBvYmoucG9ydCA/ICc6JyArIG9iai5wb3J0IDogJyc7XG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gb2JqLnByb3RvY29sID8gb2JqLnByb3RvY29sICsgJy8vJyA6ICcnO1xuICAgICAgICBjb25zdCBob3N0ID0gb2JqLmhvc3QgfHwgJyc7XG4gICAgICAgIGNvbnN0IGhvc3RuYW1lID0gb2JqLmhvc3RuYW1lIHx8ICcnO1xuICAgICAgICBjb25zdCBzZWFyY2ggPSBvYmouc2VhcmNoIHx8IChvYmoucXVlcnkgPyAnPycgKyBvYmoucXVlcnkgOiAnJyk7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBvYmouaGFzaCB8fCAnJztcbiAgICAgICAgY29uc3QgcGF0aG5hbWUgPSBvYmoucGF0aG5hbWUgfHwgJyc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBvYmoucGF0aCB8fCBwYXRobmFtZSArIHNlYXJjaDtcblxuICAgICAgICByZXR1cm4gYCR7cHJvdG9jb2x9JHt1c2VyUGFzcyB8fCBhdXRofSR7aG9zdCB8fFxuICAgICAgICAgICAgaG9zdG5hbWUgKyBwb3J0fSR7cGF0aH0ke2hhc2h9YDtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFVSTFdpdGhMZWdhY3lTdXBwb3J0LFxuICAgIFVSTFNlYXJjaFBhcmFtczogc2VsZi5VUkxTZWFyY2hQYXJhbXMsXG4gICAgZGVmYXVsdEJhc2UsXG4gICAgZm9ybWF0XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IFVSTFdpdGhMZWdhY3lTdXBwb3J0LCBmb3JtYXQgfSA9IHJlcXVpcmUoJy4vdXJsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKHVybCwgbG9jYXRpb24gPSB7fSwgcHJvdG9jb2xNYXAgPSB7fSwgZGVmYXVsdFByb3RvY29sKSA9PiB7XG4gICAgbGV0IHByb3RvY29sID0gbG9jYXRpb24ucHJvdG9jb2wgP1xuICAgICAgICBsb2NhdGlvbi5wcm90b2NvbC5yZXBsYWNlKCc6JywgJycpIDpcbiAgICAgICAgJ2h0dHAnO1xuXG4gICAgLy8gQ2hlY2sgcHJvdG9jb2wgbWFwXG4gICAgcHJvdG9jb2wgPSAocHJvdG9jb2xNYXBbcHJvdG9jb2xdIHx8IGRlZmF1bHRQcm90b2NvbCB8fCBwcm90b2NvbCkgKyAnOic7XG4gICAgbGV0IHVybFBhcnNlZDtcblxuICAgIHRyeSB7XG4gICAgICAgIHVybFBhcnNlZCA9IG5ldyBVUkxXaXRoTGVnYWN5U3VwcG9ydCh1cmwpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB1cmxQYXJzZWQgPSB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBiYXNlID0gT2JqZWN0LmFzc2lnbih7fSwgbG9jYXRpb24sIHtcbiAgICAgICAgcHJvdG9jb2w6IHByb3RvY29sIHx8IHVybFBhcnNlZC5wcm90b2NvbCxcbiAgICAgICAgaG9zdDogbG9jYXRpb24uaG9zdCB8fCB1cmxQYXJzZWQuaG9zdFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBVUkxXaXRoTGVnYWN5U3VwcG9ydCh1cmwsIGZvcm1hdChiYXNlKSkudG9TdHJpbmcoKTtcbn07XG4iLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgSW4gdGhlXG4vLyBicm93c2VyIHRoaXMgaXMgYSBsaXR0bGUgY29tcGxpY2F0ZWQgZHVlIHRvIHVua25vd24gcXVhbGl0eSBvZiBNYXRoLnJhbmRvbSgpXG4vLyBhbmQgaW5jb25zaXN0ZW50IHN1cHBvcnQgZm9yIHRoZSBgY3J5cHRvYCBBUEkuICBXZSBkbyB0aGUgYmVzdCB3ZSBjYW4gdmlhXG4vLyBmZWF0dXJlLWRldGVjdGlvblxuXG4vLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG9cbi8vIGltcGxlbWVudGF0aW9uLiBBbHNvLCBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gb24gSUUxMS5cbnZhciBnZXRSYW5kb21WYWx1ZXMgPSAodHlwZW9mKGNyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mKG1zQ3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93Lm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKSk7XG5cbmlmIChnZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0byBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIHZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG4gICAgcmV0dXJuIHJuZHM4O1xuICB9O1xufSBlbHNlIHtcbiAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAvL1xuICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAvLyBxdWFsaXR5LlxuICB2YXIgcm5kcyA9IG5ldyBBcnJheSgxNik7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXRoUk5HKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBybmRzO1xuICB9O1xufVxuIiwiLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9VdWlkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBidGggPSBieXRlVG9IZXg7XG4gIC8vIGpvaW4gdXNlZCB0byBmaXggbWVtb3J5IGlzc3VlIGNhdXNlZCBieSBjb25jYXRlbmF0aW9uOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMTc1I2M0XG4gIHJldHVybiAoW2J0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sIFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV1dKS5qb2luKCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBieXRlc1RvVXVpZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChldGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0eEhhc2gsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGNvdW50ID0gMDtcblxuICAgIHZhciB0aW1lb3V0ID0gZXRoLm9wdGlvbnMudGltZW91dCB8fCA4MDAwMDA7XG4gICAgdmFyIGludGVydmFsID0gZXRoLm9wdGlvbnMuaW50ZXJ2YWwgfHwgNzAwMDtcblxuICAgIHZhciBwcm9tID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHR4SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV0aC5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHR4SW50ZXJ2YWwpO1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFlcnIgJiYgcmVzdWx0KSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHR4SW50ZXJ2YWwpO1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGNvdW50ID49IHRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKHR4SW50ZXJ2YWwpO1xuICAgICAgICAgIHZhciBlcnJNZXNzYWdlID0gXCJSZWNlaXB0IHRpbWVvdXQgd2FpdGluZyBmb3IgdHggaGFzaDogXCIgKyB0eEhhc2g7XG4gICAgICAgICAgcmVqZWN0KGVyck1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgY291bnQgKz0gaW50ZXJ2YWw7XG4gICAgICB9LCBpbnRlcnZhbCk7XG4gICAgfSk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHByb20udGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXMpO1xuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbGxiYWNrID8gbnVsbCA6IHByb207XG4gIH07XG59OyIsIihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBVdGlsc1xuICBmdW5jdGlvbiBhc3NlcnQgKHZhbCwgbXNnKSB7XG4gICAgaWYgKCF2YWwpIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgfVxuXG4gIC8vIENvdWxkIHVzZSBgaW5oZXJpdHNgIG1vZHVsZSwgYnV0IGRvbid0IHdhbnQgdG8gbW92ZSBmcm9tIHNpbmdsZSBmaWxlXG4gIC8vIGFyY2hpdGVjdHVyZSB5ZXQuXG4gIGZ1bmN0aW9uIGluaGVyaXRzIChjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7XG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuICB9XG5cbiAgLy8gQk5cblxuICBmdW5jdGlvbiBCTiAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAoQk4uaXNCTihudW1iZXIpKSB7XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIHRoaXMud29yZHMgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIC8vIFJlZHVjdGlvbiBjb250ZXh0XG4gICAgdGhpcy5yZWQgPSBudWxsO1xuXG4gICAgaWYgKG51bWJlciAhPT0gbnVsbCkge1xuICAgICAgaWYgKGJhc2UgPT09ICdsZScgfHwgYmFzZSA9PT0gJ2JlJykge1xuICAgICAgICBlbmRpYW4gPSBiYXNlO1xuICAgICAgICBiYXNlID0gMTA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2luaXQobnVtYmVyIHx8IDAsIGJhc2UgfHwgMTAsIGVuZGlhbiB8fCAnYmUnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCTjtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLkJOID0gQk47XG4gIH1cblxuICBCTi5CTiA9IEJOO1xuICBCTi53b3JkU2l6ZSA9IDI2O1xuXG4gIHZhciBCdWZmZXI7XG4gIHRyeSB7XG4gICAgQnVmZmVyID0gcmVxdWlyZSgnYnVmJyArICdmZXInKS5CdWZmZXI7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuXG4gIEJOLmlzQk4gPSBmdW5jdGlvbiBpc0JOIChudW0pIHtcbiAgICBpZiAobnVtIGluc3RhbmNlb2YgQk4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBudW0gIT09IG51bGwgJiYgdHlwZW9mIG51bSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG51bS5jb25zdHJ1Y3Rvci53b3JkU2l6ZSA9PT0gQk4ud29yZFNpemUgJiYgQXJyYXkuaXNBcnJheShudW0ud29yZHMpO1xuICB9O1xuXG4gIEJOLm1heCA9IGZ1bmN0aW9uIG1heCAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5jbXAocmlnaHQpID4gMCkgcmV0dXJuIGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIEJOLm1pbiA9IGZ1bmN0aW9uIG1pbiAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5jbXAocmlnaHQpIDwgMCkgcmV0dXJuIGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdE51bWJlcihudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdEFycmF5KG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIGJhc2UgPSAxNjtcbiAgICB9XG4gICAgYXNzZXJ0KGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpO1xuXG4gICAgbnVtYmVyID0gbnVtYmVyLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcbiAgICAgIHN0YXJ0Kys7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09IDE2KSB7XG4gICAgICB0aGlzLl9wYXJzZUhleChudW1iZXIsIHN0YXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpO1xuICAgIH1cblxuICAgIGlmIChudW1iZXJbMF0gPT09ICctJykge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5zdHJpcCgpO1xuXG4gICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG4gICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdE51bWJlciA9IGZ1bmN0aW9uIF9pbml0TnVtYmVyIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIG51bWJlciA9IC1udW1iZXI7XG4gICAgfVxuICAgIGlmIChudW1iZXIgPCAweDQwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbIG51bWJlciAmIDB4M2ZmZmZmZiBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgMHgxMDAwMDAwMDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZlxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG51bWJlciA8IDB4MjAwMDAwMDAwMDAwMDApOyAvLyAyIF4gNTMgKHVuc2FmZSlcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmYsXG4gICAgICAgIDFcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDM7XG4gICAgfVxuXG4gICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG4gICAgLy8gUmV2ZXJzZSB0aGUgYnl0ZXNcbiAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0QXJyYXkgPSBmdW5jdGlvbiBfaW5pdEFycmF5IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIC8vIFBlcmhhcHMgYSBVaW50OEFycmF5XG4gICAgYXNzZXJ0KHR5cGVvZiBudW1iZXIubGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgaWYgKG51bWJlci5sZW5ndGggPD0gMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwobnVtYmVyLmxlbmd0aCAvIDMpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGosIHc7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuICAgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDEsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpIC0gMV0gPDwgOCkgfCAobnVtYmVyW2kgLSAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVuZGlhbiA9PT0gJ2xlJykge1xuICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSArIDFdIDw8IDgpIHwgKG51bWJlcltpICsgMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VIZXggKHN0ciwgc3RhcnQsIGVuZCkge1xuICAgIHZhciByID0gMDtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG4gICAgICByIDw8PSA0O1xuXG4gICAgICAvLyAnYScgLSAnZidcbiAgICAgIGlmIChjID49IDQ5ICYmIGMgPD0gNTQpIHtcbiAgICAgICAgciB8PSBjIC0gNDkgKyAweGE7XG5cbiAgICAgIC8vICdBJyAtICdGJ1xuICAgICAgfSBlbHNlIGlmIChjID49IDE3ICYmIGMgPD0gMjIpIHtcbiAgICAgICAgciB8PSBjIC0gMTcgKyAweGE7XG5cbiAgICAgIC8vICcwJyAtICc5J1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciB8PSBjICYgMHhmO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VIZXggPSBmdW5jdGlvbiBfcGFyc2VIZXggKG51bWJlciwgc3RhcnQpIHtcbiAgICAvLyBDcmVhdGUgcG9zc2libHkgYmlnZ2VyIGFycmF5IHRvIGVuc3VyZSB0aGF0IGl0IGZpdHMgdGhlIG51bWJlclxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKChudW1iZXIubGVuZ3RoIC0gc3RhcnQpIC8gNik7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICB2YXIgaiwgdztcbiAgICAvLyBTY2FuIDI0LWJpdCBjaHVua3MgYW5kIGFkZCB0aGVtIHRvIHRoZSBudW1iZXJcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gNiwgaiA9IDA7IGkgPj0gc3RhcnQ7IGkgLT0gNikge1xuICAgICAgdyA9IHBhcnNlSGV4KG51bWJlciwgaSwgaSArIDYpO1xuICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgLy8gTk9URTogYDB4M2ZmZmZmYCBpcyBpbnRlbnRpb25hbCBoZXJlLCAyNmJpdHMgbWF4IHNoaWZ0ICsgMjRiaXQgaGV4IGxpbWJcbiAgICAgIHRoaXMud29yZHNbaiArIDFdIHw9IHcgPj4+ICgyNiAtIG9mZikgJiAweDNmZmZmZjtcbiAgICAgIG9mZiArPSAyNDtcbiAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpICsgNiAhPT0gc3RhcnQpIHtcbiAgICAgIHcgPSBwYXJzZUhleChudW1iZXIsIHN0YXJ0LCBpICsgNik7XG4gICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ogKyAxXSB8PSB3ID4+PiAoMjYgLSBvZmYpICYgMHgzZmZmZmY7XG4gICAgfVxuICAgIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUJhc2UgKHN0ciwgc3RhcnQsIGVuZCwgbXVsKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICAgIHIgKj0gbXVsO1xuXG4gICAgICAvLyAnYSdcbiAgICAgIGlmIChjID49IDQ5KSB7XG4gICAgICAgIHIgKz0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgICAvLyAnQSdcbiAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNykge1xuICAgICAgICByICs9IGMgLSAxNyArIDB4YTtcblxuICAgICAgLy8gJzAnIC0gJzknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByICs9IGM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbiBfcGFyc2VCYXNlIChudW1iZXIsIGJhc2UsIHN0YXJ0KSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBhcyB6ZXJvXG4gICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcblxuICAgIC8vIEZpbmQgbGVuZ3RoIG9mIGxpbWIgaW4gYmFzZVxuICAgIGZvciAodmFyIGxpbWJMZW4gPSAwLCBsaW1iUG93ID0gMTsgbGltYlBvdyA8PSAweDNmZmZmZmY7IGxpbWJQb3cgKj0gYmFzZSkge1xuICAgICAgbGltYkxlbisrO1xuICAgIH1cbiAgICBsaW1iTGVuLS07XG4gICAgbGltYlBvdyA9IChsaW1iUG93IC8gYmFzZSkgfCAwO1xuXG4gICAgdmFyIHRvdGFsID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG4gICAgdmFyIGVuZCA9IE1hdGgubWluKHRvdGFsLCB0b3RhbCAtIG1vZCkgKyBzdGFydDtcblxuICAgIHZhciB3b3JkID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gbGltYkxlbikge1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIGkgKyBsaW1iTGVuLCBiYXNlKTtcblxuICAgICAgdGhpcy5pbXVsbihsaW1iUG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kICE9PSAwKSB7XG4gICAgICB2YXIgcG93ID0gMTtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBudW1iZXIubGVuZ3RoLCBiYXNlKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG1vZDsgaSsrKSB7XG4gICAgICAgIHBvdyAqPSBiYXNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmltdWxuKHBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoZGVzdCkge1xuICAgIGRlc3Qud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzdC53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgfVxuICAgIGRlc3QubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgZGVzdC5uZWdhdGl2ZSA9IHRoaXMubmVnYXRpdmU7XG4gICAgZGVzdC5yZWQgPSB0aGlzLnJlZDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHIgPSBuZXcgQk4obnVsbCk7XG4gICAgdGhpcy5jb3B5KHIpO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZXhwYW5kID0gZnVuY3Rpb24gX2V4cGFuZCAoc2l6ZSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBSZW1vdmUgbGVhZGluZyBgMGAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN0cmlwID0gZnVuY3Rpb24gc3RyaXAgKCkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX25vcm1TaWduID0gZnVuY3Rpb24gX25vcm1TaWduICgpIHtcbiAgICAvLyAtMCA9IDBcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlZCA/ICc8Qk4tUjogJyA6ICc8Qk46ICcpICsgdGhpcy50b1N0cmluZygxNikgKyAnPic7XG4gIH07XG5cbiAgLypcblxuICB2YXIgemVyb3MgPSBbXTtcbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXTtcbiAgdmFyIGdyb3VwQmFzZXMgPSBbXTtcblxuICB2YXIgcyA9ICcnO1xuICB2YXIgaSA9IC0xO1xuICB3aGlsZSAoKytpIDwgQk4ud29yZFNpemUpIHtcbiAgICB6ZXJvc1tpXSA9IHM7XG4gICAgcyArPSAnMCc7XG4gIH1cbiAgZ3JvdXBTaXplc1swXSA9IDA7XG4gIGdyb3VwU2l6ZXNbMV0gPSAwO1xuICBncm91cEJhc2VzWzBdID0gMDtcbiAgZ3JvdXBCYXNlc1sxXSA9IDA7XG4gIHZhciBiYXNlID0gMiAtIDE7XG4gIHdoaWxlICgrK2Jhc2UgPCAzNiArIDEpIHtcbiAgICB2YXIgZ3JvdXBTaXplID0gMDtcbiAgICB2YXIgZ3JvdXBCYXNlID0gMTtcbiAgICB3aGlsZSAoZ3JvdXBCYXNlIDwgKDEgPDwgQk4ud29yZFNpemUpIC8gYmFzZSkge1xuICAgICAgZ3JvdXBCYXNlICo9IGJhc2U7XG4gICAgICBncm91cFNpemUgKz0gMTtcbiAgICB9XG4gICAgZ3JvdXBTaXplc1tiYXNlXSA9IGdyb3VwU2l6ZTtcbiAgICBncm91cEJhc2VzW2Jhc2VdID0gZ3JvdXBCYXNlO1xuICB9XG5cbiAgKi9cblxuICB2YXIgemVyb3MgPSBbXG4gICAgJycsXG4gICAgJzAnLFxuICAgICcwMCcsXG4gICAgJzAwMCcsXG4gICAgJzAwMDAnLFxuICAgICcwMDAwMCcsXG4gICAgJzAwMDAwMCcsXG4gICAgJzAwMDAwMDAnLFxuICAgICcwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gIF07XG5cbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXG4gICAgMCwgMCxcbiAgICAyNSwgMTYsIDEyLCAxMSwgMTAsIDksIDgsXG4gICAgOCwgNywgNywgNywgNywgNiwgNixcbiAgICA2LCA2LCA2LCA2LCA2LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNVxuICBdO1xuXG4gIHZhciBncm91cEJhc2VzID0gW1xuICAgIDAsIDAsXG4gICAgMzM1NTQ0MzIsIDQzMDQ2NzIxLCAxNjc3NzIxNiwgNDg4MjgxMjUsIDYwNDY2MTc2LCA0MDM1MzYwNywgMTY3NzcyMTYsXG4gICAgNDMwNDY3MjEsIDEwMDAwMDAwLCAxOTQ4NzE3MSwgMzU4MzE4MDgsIDYyNzQ4NTE3LCA3NTI5NTM2LCAxMTM5MDYyNSxcbiAgICAxNjc3NzIxNiwgMjQxMzc1NjksIDM0MDEyMjI0LCA0NzA0NTg4MSwgNjQwMDAwMDAsIDQwODQxMDEsIDUxNTM2MzIsXG4gICAgNjQzNjM0MywgNzk2MjYyNCwgOTc2NTYyNSwgMTE4ODEzNzYsIDE0MzQ4OTA3LCAxNzIxMDM2OCwgMjA1MTExNDksXG4gICAgMjQzMDAwMDAsIDI4NjI5MTUxLCAzMzU1NDQzMiwgMzkxMzUzOTMsIDQ1NDM1NDI0LCA1MjUyMTg3NSwgNjA0NjYxNzZcbiAgXTtcblxuICBCTi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoYmFzZSwgcGFkZGluZykge1xuICAgIGJhc2UgPSBiYXNlIHx8IDEwO1xuICAgIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuXG4gICAgdmFyIG91dDtcbiAgICBpZiAoYmFzZSA9PT0gMTYgfHwgYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgICAgdmFyIHdvcmQgPSAoKCh3IDw8IG9mZikgfCBjYXJyeSkgJiAweGZmZmZmZikudG9TdHJpbmcoMTYpO1xuICAgICAgICBjYXJyeSA9ICh3ID4+PiAoMjQgLSBvZmYpKSAmIDB4ZmZmZmZmO1xuICAgICAgICBpZiAoY2FycnkgIT09IDAgfHwgaSAhPT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbNiAtIHdvcmQubGVuZ3RoXSArIHdvcmQgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gd29yZCArIG91dDtcbiAgICAgICAgfVxuICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgICBvdXQgPSBjYXJyeS50b1N0cmluZygxNikgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNikge1xuICAgICAgLy8gdmFyIGdyb3VwU2l6ZSA9IE1hdGguZmxvb3IoQk4ud29yZFNpemUgKiBNYXRoLkxOMiAvIE1hdGgubG9nKGJhc2UpKTtcbiAgICAgIHZhciBncm91cFNpemUgPSBncm91cFNpemVzW2Jhc2VdO1xuICAgICAgLy8gdmFyIGdyb3VwQmFzZSA9IE1hdGgucG93KGJhc2UsIGdyb3VwU2l6ZSk7XG4gICAgICB2YXIgZ3JvdXBCYXNlID0gZ3JvdXBCYXNlc1tiYXNlXTtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XG4gICAgICBjLm5lZ2F0aXZlID0gMDtcbiAgICAgIHdoaWxlICghYy5pc1plcm8oKSkge1xuICAgICAgICB2YXIgciA9IGMubW9kbihncm91cEJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICBjID0gYy5pZGl2bihncm91cEJhc2UpO1xuXG4gICAgICAgIGlmICghYy5pc1plcm8oKSkge1xuICAgICAgICAgIG91dCA9IHplcm9zW2dyb3VwU2l6ZSAtIHIubGVuZ3RoXSArIHIgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gciArIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGZhbHNlLCAnQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNicpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyICgpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy53b3Jkc1swXTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldCArPSB0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDMgJiYgdGhpcy53b3Jkc1syXSA9PT0gMHgwMSkge1xuICAgICAgLy8gTk9URTogYXQgdGhpcyBzdGFnZSBpdCBpcyBrbm93biB0aGF0IHRoZSB0b3AgYml0IGlzIHNldFxuICAgICAgcmV0ICs9IDB4MTAwMDAwMDAwMDAwMDAgKyAodGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ051bWJlciBjYW4gb25seSBzYWZlbHkgc3RvcmUgdXAgdG8gNTMgYml0cycpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMubmVnYXRpdmUgIT09IDApID8gLXJldCA6IHJldDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKTtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShCdWZmZXIsIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQXJyYXksIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheUxpa2UgPSBmdW5jdGlvbiB0b0FycmF5TGlrZSAoQXJyYXlUeXBlLCBlbmRpYW4sIGxlbmd0aCkge1xuICAgIHZhciBieXRlTGVuZ3RoID0gdGhpcy5ieXRlTGVuZ3RoKCk7XG4gICAgdmFyIHJlcUxlbmd0aCA9IGxlbmd0aCB8fCBNYXRoLm1heCgxLCBieXRlTGVuZ3RoKTtcbiAgICBhc3NlcnQoYnl0ZUxlbmd0aCA8PSByZXFMZW5ndGgsICdieXRlIGFycmF5IGxvbmdlciB0aGFuIGRlc2lyZWQgbGVuZ3RoJyk7XG4gICAgYXNzZXJ0KHJlcUxlbmd0aCA+IDAsICdSZXF1ZXN0ZWQgYXJyYXkgbGVuZ3RoIDw9IDAnKTtcblxuICAgIHRoaXMuc3RyaXAoKTtcbiAgICB2YXIgbGl0dGxlRW5kaWFuID0gZW5kaWFuID09PSAnbGUnO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXlUeXBlKHJlcUxlbmd0aCk7XG5cbiAgICB2YXIgYiwgaTtcbiAgICB2YXIgcSA9IHRoaXMuY2xvbmUoKTtcbiAgICBpZiAoIWxpdHRsZUVuZGlhbikge1xuICAgICAgLy8gQXNzdW1lIGJpZy1lbmRpYW5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCByZXFMZW5ndGggLSBieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgIXEuaXNaZXJvKCk7IGkrKykge1xuICAgICAgICBiID0gcS5hbmRsbigweGZmKTtcbiAgICAgICAgcS5pdXNocm4oOCk7XG5cbiAgICAgICAgcmVzW3JlcUxlbmd0aCAtIGkgLSAxXSA9IGI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7ICFxLmlzWmVybygpOyBpKyspIHtcbiAgICAgICAgYiA9IHEuYW5kbG4oMHhmZik7XG4gICAgICAgIHEuaXVzaHJuKDgpO1xuXG4gICAgICAgIHJlc1tpXSA9IGI7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBpIDwgcmVxTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIGlmIChNYXRoLmNsejMyKSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICB2YXIgdCA9IHc7XG4gICAgICB2YXIgciA9IDA7XG4gICAgICBpZiAodCA+PSAweDEwMDApIHtcbiAgICAgICAgciArPSAxMztcbiAgICAgICAgdCA+Pj49IDEzO1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg0MCkge1xuICAgICAgICByICs9IDc7XG4gICAgICAgIHQgPj4+PSA3O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg4KSB7XG4gICAgICAgIHIgKz0gNDtcbiAgICAgICAgdCA+Pj49IDQ7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDAyKSB7XG4gICAgICAgIHIgKz0gMjtcbiAgICAgICAgdCA+Pj49IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gciArIHQ7XG4gICAgfTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbiBfemVyb0JpdHMgKHcpIHtcbiAgICAvLyBTaG9ydC1jdXRcbiAgICBpZiAodyA9PT0gMCkgcmV0dXJuIDI2O1xuXG4gICAgdmFyIHQgPSB3O1xuICAgIHZhciByID0gMDtcbiAgICBpZiAoKHQgJiAweDFmZmYpID09PSAwKSB7XG4gICAgICByICs9IDEzO1xuICAgICAgdCA+Pj49IDEzO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDdmKSA9PT0gMCkge1xuICAgICAgciArPSA3O1xuICAgICAgdCA+Pj49IDc7XG4gICAgfVxuICAgIGlmICgodCAmIDB4ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNDtcbiAgICAgIHQgPj4+PSA0O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDMpID09PSAwKSB7XG4gICAgICByICs9IDI7XG4gICAgICB0ID4+Pj0gMjtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgxKSA9PT0gMCkge1xuICAgICAgcisrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICAvLyBSZXR1cm4gbnVtYmVyIG9mIHVzZWQgYml0cyBpbiBhIEJOXG4gIEJOLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiBiaXRMZW5ndGggKCkge1xuICAgIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBoaSA9IHRoaXMuX2NvdW50Qml0cyh3KTtcbiAgICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIGhpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRvQml0QXJyYXkgKG51bSkge1xuICAgIHZhciB3ID0gbmV3IEFycmF5KG51bS5iaXRMZW5ndGgoKSk7XG5cbiAgICBmb3IgKHZhciBiaXQgPSAwOyBiaXQgPCB3Lmxlbmd0aDsgYml0KyspIHtcbiAgICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICAgIHdbYml0XSA9IChudW0ud29yZHNbb2ZmXSAmICgxIDw8IHdiaXQpKSA+Pj4gd2JpdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfVxuXG4gIC8vIE51bWJlciBvZiB0cmFpbGluZyB6ZXJvIGJpdHNcbiAgQk4ucHJvdG90eXBlLnplcm9CaXRzID0gZnVuY3Rpb24gemVyb0JpdHMgKCkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gMDtcblxuICAgIHZhciByID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBiID0gdGhpcy5femVyb0JpdHModGhpcy53b3Jkc1tpXSk7XG4gICAgICByICs9IGI7XG4gICAgICBpZiAoYiAhPT0gMjYpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGggKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5iaXRMZW5ndGgoKSAvIDgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbiB0b1R3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmFicygpLmlub3RuKHdpZHRoKS5pYWRkbigxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbiBmcm9tVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy50ZXN0bih3aWR0aCAtIDEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3RuKHdpZHRoKS5pYWRkbigxKS5pbmVnKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gaXNOZWcgKCkge1xuICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmluZWcgPSBmdW5jdGlvbiBpbmVnICgpIHtcbiAgICBpZiAoIXRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVvciA9IGZ1bmN0aW9uIGl1b3IgKG51bSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pb3IgPSBmdW5jdGlvbiBpb3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1b3IobnVtKTtcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pb3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51b3IgPSBmdW5jdGlvbiB1b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdW9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbiBpdWFuZCAobnVtKSB7XG4gICAgLy8gYiA9IG1pbi1sZW5ndGgobnVtLCB0aGlzKVxuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gJiBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBiLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhbmQgPSBmdW5jdGlvbiBpYW5kIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdWFuZChudW0pO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFuZCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uIHVhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVhbmQodGhpcyk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXhvciA9IGZ1bmN0aW9uIGl1eG9yIChudW0pIHtcbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGE7XG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXSBeIGIud29yZHNbaV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMgIT09IGEpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXhvciA9IGZ1bmN0aW9uIGl4b3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1eG9yKG51bSk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51eG9yID0gZnVuY3Rpb24gdXhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdXhvcih0aGlzKTtcbiAgfTtcblxuICAvLyBOb3QgYGB0aGlzYGAgd2l0aCBgYHdpZHRoYGAgYml0d2lkdGhcbiAgQk4ucHJvdG90eXBlLmlub3RuID0gZnVuY3Rpb24gaW5vdG4gKHdpZHRoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgJiYgd2lkdGggPj0gMCk7XG5cbiAgICB2YXIgYnl0ZXNOZWVkZWQgPSBNYXRoLmNlaWwod2lkdGggLyAyNikgfCAwO1xuICAgIHZhciBiaXRzTGVmdCA9IHdpZHRoICUgMjY7XG5cbiAgICAvLyBFeHRlbmQgdGhlIGJ1ZmZlciB3aXRoIGxlYWRpbmcgemVyb2VzXG4gICAgdGhpcy5fZXhwYW5kKGJ5dGVzTmVlZGVkKTtcblxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIGJ5dGVzTmVlZGVkLS07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGNvbXBsZXRlIHdvcmRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlc05lZWRlZDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSByZXNpZHVlXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgKDB4M2ZmZmZmZiA+PiAoMjYgLSBiaXRzTGVmdCkpO1xuICAgIH1cblxuICAgIC8vIEFuZCByZW1vdmUgbGVhZGluZyB6ZXJvZXNcbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ub3RuID0gZnVuY3Rpb24gbm90biAod2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlub3RuKHdpZHRoKTtcbiAgfTtcblxuICAvLyBTZXQgYGJpdGAgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24gc2V0biAoYml0LCB2YWwpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXG4gICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICB0aGlzLl9leHBhbmQob2ZmICsgMSk7XG5cbiAgICBpZiAodmFsKSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gfCAoMSA8PCB3Yml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdICYgfigxIDw8IHdiaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKG51bSkge1xuICAgIHZhciByO1xuXG4gICAgLy8gbmVnYXRpdmUgKyBwb3NpdGl2ZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblxuICAgIC8vIHBvc2l0aXZlICsgbmVnYXRpdmVcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcbiAgICB9IGVsc2UgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG51bSkge1xuICAgIHZhciByZXM7XG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCAmJiB0aGlzLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gdGhpcy5zdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2UgaWYgKG51bS5uZWdhdGl2ZSA9PT0gMCAmJiB0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IG51bS5zdWIodGhpcyk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkKG51bSk7XG5cbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFkZCh0aGlzKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKG51bSkge1xuICAgIC8vIHRoaXMgLSAoLW51bSkgPSB0aGlzICsgbnVtXG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHZhciByID0gdGhpcy5pYWRkKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG5cbiAgICAvLyAtdGhpcyAtIG51bSA9IC0odGhpcyArIG51bSlcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZVxuICAgIHZhciBjbXAgPSB0aGlzLmNtcChudW0pO1xuXG4gICAgLy8gT3B0aW1pemF0aW9uIC0gemVyb2lmeVxuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBhID4gYlxuICAgIHZhciBhLCBiO1xuICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgLSAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gQ29weSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIGlmIChjYXJyeSA9PT0gMCAmJiBpIDwgYS5sZW5ndGggJiYgYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkpO1xuXG4gICAgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3ViKG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc21hbGxNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIHZhciBsZW4gPSAoc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoKSB8IDA7XG4gICAgb3V0Lmxlbmd0aCA9IGxlbjtcbiAgICBsZW4gPSAobGVuIC0gMSkgfCAwO1xuXG4gICAgLy8gUGVlbCBvbmUgaXRlcmF0aW9uIChjb21waWxlciBjYW4ndCBkbyBpdCwgYmVjYXVzZSBvZiBjb2RlIGNvbXBsZXhpdHkpXG4gICAgdmFyIGEgPSBzZWxmLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgYiA9IG51bS53b3Jkc1swXSB8IDA7XG4gICAgdmFyIHIgPSBhICogYjtcblxuICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgdmFyIGNhcnJ5ID0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICBvdXQud29yZHNbMF0gPSBsbztcblxuICAgIGZvciAodmFyIGsgPSAxOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gY2FycnkgPj4+IDI2O1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSAoayAtIGopIHwgMDtcbiAgICAgICAgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgciA9IGEgKiBiICsgcndvcmQ7XG4gICAgICAgIG5jYXJyeSArPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgICByd29yZCA9IHIgJiAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZCB8IDA7XG4gICAgICBjYXJyeSA9IG5jYXJyeSB8IDA7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2FycnkgfCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuICB9XG5cbiAgLy8gVE9ETyhpbmR1dG55KTogaXQgbWF5IGJlIHJlYXNvbmFibGUgdG8gb21pdCBpdCBmb3IgdXNlcnMgd2hvIGRvbid0IG5lZWRcbiAgLy8gdG8gd29yayB3aXRoIDI1Ni1iaXQgbnVtYmVycywgb3RoZXJ3aXNlIGl0IGdpdmVzIDIwJSBpbXByb3ZlbWVudCBmb3IgMjU2LWJpdFxuICAvLyBtdWx0aXBsaWNhdGlvbiAobGlrZSBlbGxpcHRpYyBzZWNwMjU2azEpLlxuICB2YXIgY29tYjEwTXVsVG8gPSBmdW5jdGlvbiBjb21iMTBNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICB2YXIgYSA9IHNlbGYud29yZHM7XG4gICAgdmFyIGIgPSBudW0ud29yZHM7XG4gICAgdmFyIG8gPSBvdXQud29yZHM7XG4gICAgdmFyIGMgPSAwO1xuICAgIHZhciBsbztcbiAgICB2YXIgbWlkO1xuICAgIHZhciBoaTtcbiAgICB2YXIgYTAgPSBhWzBdIHwgMDtcbiAgICB2YXIgYWwwID0gYTAgJiAweDFmZmY7XG4gICAgdmFyIGFoMCA9IGEwID4+PiAxMztcbiAgICB2YXIgYTEgPSBhWzFdIHwgMDtcbiAgICB2YXIgYWwxID0gYTEgJiAweDFmZmY7XG4gICAgdmFyIGFoMSA9IGExID4+PiAxMztcbiAgICB2YXIgYTIgPSBhWzJdIHwgMDtcbiAgICB2YXIgYWwyID0gYTIgJiAweDFmZmY7XG4gICAgdmFyIGFoMiA9IGEyID4+PiAxMztcbiAgICB2YXIgYTMgPSBhWzNdIHwgMDtcbiAgICB2YXIgYWwzID0gYTMgJiAweDFmZmY7XG4gICAgdmFyIGFoMyA9IGEzID4+PiAxMztcbiAgICB2YXIgYTQgPSBhWzRdIHwgMDtcbiAgICB2YXIgYWw0ID0gYTQgJiAweDFmZmY7XG4gICAgdmFyIGFoNCA9IGE0ID4+PiAxMztcbiAgICB2YXIgYTUgPSBhWzVdIHwgMDtcbiAgICB2YXIgYWw1ID0gYTUgJiAweDFmZmY7XG4gICAgdmFyIGFoNSA9IGE1ID4+PiAxMztcbiAgICB2YXIgYTYgPSBhWzZdIHwgMDtcbiAgICB2YXIgYWw2ID0gYTYgJiAweDFmZmY7XG4gICAgdmFyIGFoNiA9IGE2ID4+PiAxMztcbiAgICB2YXIgYTcgPSBhWzddIHwgMDtcbiAgICB2YXIgYWw3ID0gYTcgJiAweDFmZmY7XG4gICAgdmFyIGFoNyA9IGE3ID4+PiAxMztcbiAgICB2YXIgYTggPSBhWzhdIHwgMDtcbiAgICB2YXIgYWw4ID0gYTggJiAweDFmZmY7XG4gICAgdmFyIGFoOCA9IGE4ID4+PiAxMztcbiAgICB2YXIgYTkgPSBhWzldIHwgMDtcbiAgICB2YXIgYWw5ID0gYTkgJiAweDFmZmY7XG4gICAgdmFyIGFoOSA9IGE5ID4+PiAxMztcbiAgICB2YXIgYjAgPSBiWzBdIHwgMDtcbiAgICB2YXIgYmwwID0gYjAgJiAweDFmZmY7XG4gICAgdmFyIGJoMCA9IGIwID4+PiAxMztcbiAgICB2YXIgYjEgPSBiWzFdIHwgMDtcbiAgICB2YXIgYmwxID0gYjEgJiAweDFmZmY7XG4gICAgdmFyIGJoMSA9IGIxID4+PiAxMztcbiAgICB2YXIgYjIgPSBiWzJdIHwgMDtcbiAgICB2YXIgYmwyID0gYjIgJiAweDFmZmY7XG4gICAgdmFyIGJoMiA9IGIyID4+PiAxMztcbiAgICB2YXIgYjMgPSBiWzNdIHwgMDtcbiAgICB2YXIgYmwzID0gYjMgJiAweDFmZmY7XG4gICAgdmFyIGJoMyA9IGIzID4+PiAxMztcbiAgICB2YXIgYjQgPSBiWzRdIHwgMDtcbiAgICB2YXIgYmw0ID0gYjQgJiAweDFmZmY7XG4gICAgdmFyIGJoNCA9IGI0ID4+PiAxMztcbiAgICB2YXIgYjUgPSBiWzVdIHwgMDtcbiAgICB2YXIgYmw1ID0gYjUgJiAweDFmZmY7XG4gICAgdmFyIGJoNSA9IGI1ID4+PiAxMztcbiAgICB2YXIgYjYgPSBiWzZdIHwgMDtcbiAgICB2YXIgYmw2ID0gYjYgJiAweDFmZmY7XG4gICAgdmFyIGJoNiA9IGI2ID4+PiAxMztcbiAgICB2YXIgYjcgPSBiWzddIHwgMDtcbiAgICB2YXIgYmw3ID0gYjcgJiAweDFmZmY7XG4gICAgdmFyIGJoNyA9IGI3ID4+PiAxMztcbiAgICB2YXIgYjggPSBiWzhdIHwgMDtcbiAgICB2YXIgYmw4ID0gYjggJiAweDFmZmY7XG4gICAgdmFyIGJoOCA9IGI4ID4+PiAxMztcbiAgICB2YXIgYjkgPSBiWzldIHwgMDtcbiAgICB2YXIgYmw5ID0gYjkgJiAweDFmZmY7XG4gICAgdmFyIGJoOSA9IGI5ID4+PiAxMztcblxuICAgIG91dC5uZWdhdGl2ZSA9IHNlbGYubmVnYXRpdmUgXiBudW0ubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IDE5O1xuICAgIC8qIGsgPSAwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDAsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDAsIGJoMCk7XG4gICAgdmFyIHcwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MCA+Pj4gMjYpKSB8IDA7XG4gICAgdzAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDEsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgxKSkgfCAwO1xuICAgIHZhciB3MSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEgPj4+IDI2KSkgfCAwO1xuICAgIHcxICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgyLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDIpKSB8IDA7XG4gICAgdmFyIHcyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MiA+Pj4gMjYpKSB8IDA7XG4gICAgdzIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDMsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDMsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDMpKSB8IDA7XG4gICAgdmFyIHczID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MyA+Pj4gMjYpKSB8IDA7XG4gICAgdzMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDQsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg0KSkgfCAwO1xuICAgIHZhciB3NCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzQgPj4+IDI2KSkgfCAwO1xuICAgIHc0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg1LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDUpKSB8IDA7XG4gICAgdmFyIHc1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NSA+Pj4gMjYpKSB8IDA7XG4gICAgdzUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDYsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDYsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDYpKSB8IDA7XG4gICAgdmFyIHc2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NiA+Pj4gMjYpKSB8IDA7XG4gICAgdzYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDcsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg3KSkgfCAwO1xuICAgIHZhciB3NyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzcgPj4+IDI2KSkgfCAwO1xuICAgIHc3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg4LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDgpKSB8IDA7XG4gICAgdmFyIHc4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OCA+Pj4gMjYpKSB8IDA7XG4gICAgdzggJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA5ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDkpKSB8IDA7XG4gICAgdmFyIHc5ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OSA+Pj4gMjYpKSB8IDA7XG4gICAgdzkgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwxKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDEpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDEpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDEpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEwID4+PiAyNikpIHwgMDtcbiAgICB3MTAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwyKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDIpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDIpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDIpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzExID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTEgPj4+IDI2KSkgfCAwO1xuICAgIHcxMSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDMpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEyID4+PiAyNikpIHwgMDtcbiAgICB3MTIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw0KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDQpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDQpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDQpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEzID4+PiAyNikpIHwgMDtcbiAgICB3MTMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw1KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDUpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDUpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDUpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTQgPj4+IDI2KSkgfCAwO1xuICAgIHcxNCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDYpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE1ID4+PiAyNikpIHwgMDtcbiAgICB3MTUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw3KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDcpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDcpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDcpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE2ID4+PiAyNikpIHwgMDtcbiAgICB3MTYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw4KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDgpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDgpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDgpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTcgPj4+IDI2KSkgfCAwO1xuICAgIHcxNyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDkpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOSk7XG4gICAgdmFyIHcxOCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE4ID4+PiAyNikpIHwgMDtcbiAgICB3MTggJj0gMHgzZmZmZmZmO1xuICAgIG9bMF0gPSB3MDtcbiAgICBvWzFdID0gdzE7XG4gICAgb1syXSA9IHcyO1xuICAgIG9bM10gPSB3MztcbiAgICBvWzRdID0gdzQ7XG4gICAgb1s1XSA9IHc1O1xuICAgIG9bNl0gPSB3NjtcbiAgICBvWzddID0gdzc7XG4gICAgb1s4XSA9IHc4O1xuICAgIG9bOV0gPSB3OTtcbiAgICBvWzEwXSA9IHcxMDtcbiAgICBvWzExXSA9IHcxMTtcbiAgICBvWzEyXSA9IHcxMjtcbiAgICBvWzEzXSA9IHcxMztcbiAgICBvWzE0XSA9IHcxNDtcbiAgICBvWzE1XSA9IHcxNTtcbiAgICBvWzE2XSA9IHcxNjtcbiAgICBvWzE3XSA9IHcxNztcbiAgICBvWzE4XSA9IHcxODtcbiAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgb1sxOV0gPSBjO1xuICAgICAgb3V0Lmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIC8vIFBvbHlmaWxsIGNvbWJcbiAgaWYgKCFNYXRoLmltdWwpIHtcbiAgICBjb21iMTBNdWxUbyA9IHNtYWxsTXVsVG87XG4gIH1cblxuICBmdW5jdGlvbiBiaWdNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSBzZWxmLmxlbmd0aCArIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIHZhciBobmNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IG91dC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICAgIGhuY2FycnkgPSAwO1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSBrIC0gajtcbiAgICAgICAgdmFyIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcbiAgICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xuICAgICAgICByd29yZCA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcblxuICAgICAgICBobmNhcnJ5ICs9IG5jYXJyeSA+Pj4gMjY7XG4gICAgICAgIG5jYXJyeSAmPSAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5O1xuICAgICAgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGp1bWJvTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgdmFyIGZmdG0gPSBuZXcgRkZUTSgpO1xuICAgIHJldHVybiBmZnRtLm11bHAoc2VsZiwgbnVtLCBvdXQpO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gbXVsVG8gKG51bSwgb3V0KSB7XG4gICAgdmFyIHJlcztcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMTAgJiYgbnVtLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgIHJlcyA9IGNvbWIxME11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDYzKSB7XG4gICAgICByZXMgPSBzbWFsbE11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDEwMjQpIHtcbiAgICAgIHJlcyA9IGJpZ011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb29sZXktVHVrZXkgYWxnb3JpdGhtIGZvciBGRlRcbiAgLy8gc2xpZ2h0bHkgcmV2aXNpdGVkIHRvIHJlbHkgb24gbG9vcGluZyBpbnN0ZWFkIG9mIHJlY3Vyc2lvblxuXG4gIGZ1bmN0aW9uIEZGVE0gKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBGRlRNLnByb3RvdHlwZS5tYWtlUkJUID0gZnVuY3Rpb24gbWFrZVJCVCAoTikge1xuICAgIHZhciB0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBsID0gQk4ucHJvdG90eXBlLl9jb3VudEJpdHMoTikgLSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB0W2ldID0gdGhpcy5yZXZCaW4oaSwgbCwgTik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBiaW5hcnktcmV2ZXJzZWQgcmVwcmVzZW50YXRpb24gb2YgYHhgXG4gIEZGVE0ucHJvdG90eXBlLnJldkJpbiA9IGZ1bmN0aW9uIHJldkJpbiAoeCwgbCwgTikge1xuICAgIGlmICh4ID09PSAwIHx8IHggPT09IE4gLSAxKSByZXR1cm4geDtcblxuICAgIHZhciByYiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJiIHw9ICh4ICYgMSkgPDwgKGwgLSBpIC0gMSk7XG4gICAgICB4ID4+PSAxO1xuICAgIH1cblxuICAgIHJldHVybiByYjtcbiAgfTtcblxuICAvLyBQZXJmb3JtcyBcInR3ZWVkbGluZ1wiIHBoYXNlLCB0aGVyZWZvcmUgJ2VtdWxhdGluZydcbiAgLy8gYmVoYXZpb3VyIG9mIHRoZSByZWN1cnNpdmUgYWxnb3JpdGhtXG4gIEZGVE0ucHJvdG90eXBlLnBlcm11dGUgPSBmdW5jdGlvbiBwZXJtdXRlIChyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHJ0d3NbaV0gPSByd3NbcmJ0W2ldXTtcbiAgICAgIGl0d3NbaV0gPSBpd3NbcmJ0W2ldXTtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtIChyd3MsIGl3cywgcnR3cywgaXR3cywgTiwgcmJ0KSB7XG4gICAgdGhpcy5wZXJtdXRlKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pO1xuXG4gICAgZm9yICh2YXIgcyA9IDE7IHMgPCBOOyBzIDw8PSAxKSB7XG4gICAgICB2YXIgbCA9IHMgPDwgMTtcblxuICAgICAgdmFyIHJ0d2RmID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgLyBsKTtcbiAgICAgIHZhciBpdHdkZiA9IE1hdGguc2luKDIgKiBNYXRoLlBJIC8gbCk7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgTjsgcCArPSBsKSB7XG4gICAgICAgIHZhciBydHdkZl8gPSBydHdkZjtcbiAgICAgICAgdmFyIGl0d2RmXyA9IGl0d2RmO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgczsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlID0gcnR3c1twICsgal07XG4gICAgICAgICAgdmFyIGllID0gaXR3c1twICsgal07XG5cbiAgICAgICAgICB2YXIgcm8gPSBydHdzW3AgKyBqICsgc107XG4gICAgICAgICAgdmFyIGlvID0gaXR3c1twICsgaiArIHNdO1xuXG4gICAgICAgICAgdmFyIHJ4ID0gcnR3ZGZfICogcm8gLSBpdHdkZl8gKiBpbztcblxuICAgICAgICAgIGlvID0gcnR3ZGZfICogaW8gKyBpdHdkZl8gKiBybztcbiAgICAgICAgICBybyA9IHJ4O1xuXG4gICAgICAgICAgcnR3c1twICsgal0gPSByZSArIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGpdID0gaWUgKyBpbztcblxuICAgICAgICAgIHJ0d3NbcCArIGogKyBzXSA9IHJlIC0gcm87XG4gICAgICAgICAgaXR3c1twICsgaiArIHNdID0gaWUgLSBpbztcblxuICAgICAgICAgIC8qIGpzaGludCBtYXhkZXB0aCA6IGZhbHNlICovXG4gICAgICAgICAgaWYgKGogIT09IGwpIHtcbiAgICAgICAgICAgIHJ4ID0gcnR3ZGYgKiBydHdkZl8gLSBpdHdkZiAqIGl0d2RmXztcblxuICAgICAgICAgICAgaXR3ZGZfID0gcnR3ZGYgKiBpdHdkZl8gKyBpdHdkZiAqIHJ0d2RmXztcbiAgICAgICAgICAgIHJ0d2RmXyA9IHJ4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ndWVzc0xlbjEzYiA9IGZ1bmN0aW9uIGd1ZXNzTGVuMTNiIChuLCBtKSB7XG4gICAgdmFyIE4gPSBNYXRoLm1heChtLCBuKSB8IDE7XG4gICAgdmFyIG9kZCA9IE4gJiAxO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKE4gPSBOIC8gMiB8IDA7IE47IE4gPSBOID4+PiAxKSB7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIDEgPDwgaSArIDEgKyBvZGQ7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24gY29uanVnYXRlIChyd3MsIGl3cywgTikge1xuICAgIGlmIChOIDw9IDEpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHQgPSByd3NbaV07XG5cbiAgICAgIHJ3c1tpXSA9IHJ3c1tOIC0gaSAtIDFdO1xuICAgICAgcndzW04gLSBpIC0gMV0gPSB0O1xuXG4gICAgICB0ID0gaXdzW2ldO1xuXG4gICAgICBpd3NbaV0gPSAtaXdzW04gLSBpIC0gMV07XG4gICAgICBpd3NbTiAtIGkgLSAxXSA9IC10O1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ub3JtYWxpemUxM2IgPSBmdW5jdGlvbiBub3JtYWxpemUxM2IgKHdzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB3ID0gTWF0aC5yb3VuZCh3c1syICogaSArIDFdIC8gTikgKiAweDIwMDAgK1xuICAgICAgICBNYXRoLnJvdW5kKHdzWzIgKiBpXSAvIE4pICtcbiAgICAgICAgY2Fycnk7XG5cbiAgICAgIHdzW2ldID0gdyAmIDB4M2ZmZmZmZjtcblxuICAgICAgaWYgKHcgPCAweDQwMDAwMDApIHtcbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3IC8gMHg0MDAwMDAwIHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd3M7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29udmVydDEzYiA9IGZ1bmN0aW9uIGNvbnZlcnQxM2IgKHdzLCBsZW4sIHJ3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FycnkgPSBjYXJyeSArICh3c1tpXSB8IDApO1xuXG4gICAgICByd3NbMiAqIGldID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgICAgcndzWzIgKiBpICsgMV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgfVxuXG4gICAgLy8gUGFkIHdpdGggemVyb2VzXG4gICAgZm9yIChpID0gMiAqIGxlbjsgaSA8IE47ICsraSkge1xuICAgICAgcndzW2ldID0gMDtcbiAgICB9XG5cbiAgICBhc3NlcnQoY2FycnkgPT09IDApO1xuICAgIGFzc2VydCgoY2FycnkgJiB+MHgxZmZmKSA9PT0gMCk7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuc3R1YiA9IGZ1bmN0aW9uIHN0dWIgKE4pIHtcbiAgICB2YXIgcGggPSBuZXcgQXJyYXkoTik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHBoW2ldID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGg7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubXVscCA9IGZ1bmN0aW9uIG11bHAgKHgsIHksIG91dCkge1xuICAgIHZhciBOID0gMiAqIHRoaXMuZ3Vlc3NMZW4xM2IoeC5sZW5ndGgsIHkubGVuZ3RoKTtcblxuICAgIHZhciByYnQgPSB0aGlzLm1ha2VSQlQoTik7XG5cbiAgICB2YXIgXyA9IHRoaXMuc3R1YihOKTtcblxuICAgIHZhciByd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIHJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGl3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgbnJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbnJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5pd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIHJtd3MgPSBvdXQud29yZHM7XG4gICAgcm13cy5sZW5ndGggPSBOO1xuXG4gICAgdGhpcy5jb252ZXJ0MTNiKHgud29yZHMsIHgubGVuZ3RoLCByd3MsIE4pO1xuICAgIHRoaXMuY29udmVydDEzYih5LndvcmRzLCB5Lmxlbmd0aCwgbnJ3cywgTik7XG5cbiAgICB0aGlzLnRyYW5zZm9ybShyd3MsIF8sIHJ3c3QsIGl3c3QsIE4sIHJidCk7XG4gICAgdGhpcy50cmFuc2Zvcm0obnJ3cywgXywgbnJ3c3QsIG5pd3N0LCBOLCByYnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHZhciByeCA9IHJ3c3RbaV0gKiBucndzdFtpXSAtIGl3c3RbaV0gKiBuaXdzdFtpXTtcbiAgICAgIGl3c3RbaV0gPSByd3N0W2ldICogbml3c3RbaV0gKyBpd3N0W2ldICogbnJ3c3RbaV07XG4gICAgICByd3N0W2ldID0gcng7XG4gICAgfVxuXG4gICAgdGhpcy5jb25qdWdhdGUocndzdCwgaXdzdCwgTik7XG4gICAgdGhpcy50cmFuc2Zvcm0ocndzdCwgaXdzdCwgcm13cywgXywgTiwgcmJ0KTtcbiAgICB0aGlzLmNvbmp1Z2F0ZShybXdzLCBfLCBOKTtcbiAgICB0aGlzLm5vcm1hbGl6ZTEzYihybXdzLCBOKTtcblxuICAgIG91dC5uZWdhdGl2ZSA9IHgubmVnYXRpdmUgXiB5Lm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSB4Lmxlbmd0aCArIHkubGVuZ3RoO1xuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBgdGhpc2AgYnkgYG51bWBcbiAgQk4ucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5tdWxUbyhudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgZW1wbG95aW5nIEZGVFxuICBCTi5wcm90b3R5cGUubXVsZiA9IGZ1bmN0aW9uIG11bGYgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIE11bHRpcGxpY2F0aW9uXG4gIEJOLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5tdWxUbyhudW0sIHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbXVsbiA9IGZ1bmN0aW9uIGltdWxuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuXG4gICAgLy8gQ2FycnlcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICogbnVtO1xuICAgICAgdmFyIGxvID0gKHcgJiAweDNmZmZmZmYpICsgKGNhcnJ5ICYgMHgzZmZmZmZmKTtcbiAgICAgIGNhcnJ5ID4+PSAyNjtcbiAgICAgIGNhcnJ5ICs9ICh3IC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAvLyBOT1RFOiBsbyBpcyAyN2JpdCBtYXhpbXVtXG4gICAgICBjYXJyeSArPSBsbyA+Pj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tdWxuID0gZnVuY3Rpb24gbXVsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbXVsbihudW0pO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwodGhpcyk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bCh0aGlzLmNsb25lKCkpO1xuICB9O1xuXG4gIC8vIE1hdGgucG93KGB0aGlzYCwgYG51bWApXG4gIEJOLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKG51bSkge1xuICAgIHZhciB3ID0gdG9CaXRBcnJheShudW0pO1xuICAgIGlmICh3Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5ldyBCTigxKTtcblxuICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXNcbiAgICB2YXIgcmVzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcubGVuZ3RoOyBpKyssIHJlcyA9IHJlcy5zcXIoKSkge1xuICAgICAgaWYgKHdbaV0gIT09IDApIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICgrK2kgPCB3Lmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgcSA9IHJlcy5zcXIoKTsgaSA8IHcubGVuZ3RoOyBpKyssIHEgPSBxLnNxcigpKSB7XG4gICAgICAgIGlmICh3W2ldID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSByZXMubXVsKHEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVzaGxuID0gZnVuY3Rpb24gaXVzaGxuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuICAgIHZhciBjYXJyeU1hc2sgPSAoMHgzZmZmZmZmID4+PiAoMjYgLSByKSkgPDwgKDI2IC0gcik7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5ld0NhcnJ5ID0gdGhpcy53b3Jkc1tpXSAmIGNhcnJ5TWFzaztcbiAgICAgICAgdmFyIGMgPSAoKHRoaXMud29yZHNbaV0gfCAwKSAtIG5ld0NhcnJ5KSA8PCByO1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYyB8IGNhcnJ5O1xuICAgICAgICBjYXJyeSA9IG5ld0NhcnJ5ID4+PiAoMjYgLSByKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhcnJ5KSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocyAhPT0gMCkge1xuICAgICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoICs9IHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbiBpc2hsbiAoYml0cykge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHQgaW4tcGxhY2VcbiAgLy8gTk9URTogYGhpbnRgIGlzIGEgbG93ZXN0IGJpdCBiZWZvcmUgdHJhaWxpbmcgemVyb2VzXG4gIC8vIE5PVEU6IGlmIGBleHRlbmRlZGAgaXMgcHJlc2VudCAtIGl0IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVzdHJveWVkIGJpdHNcbiAgQk4ucHJvdG90eXBlLml1c2hybiA9IGZ1bmN0aW9uIGl1c2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIGg7XG4gICAgaWYgKGhpbnQpIHtcbiAgICAgIGggPSAoaGludCAtIChoaW50ICUgMjYpKSAvIDI2O1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gMDtcbiAgICB9XG5cbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IE1hdGgubWluKChiaXRzIC0gcikgLyAyNiwgdGhpcy5sZW5ndGgpO1xuICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgIHZhciBtYXNrZWRXb3JkcyA9IGV4dGVuZGVkO1xuXG4gICAgaCAtPSBzO1xuICAgIGggPSBNYXRoLm1heCgwLCBoKTtcblxuICAgIC8vIEV4dGVuZGVkIG1vZGUsIGNvcHkgbWFza2VkIHBhcnRcbiAgICBpZiAobWFza2VkV29yZHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIG1hc2tlZFdvcmRzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG4gICAgfVxuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IHMpIHtcbiAgICAgIHRoaXMubGVuZ3RoIC09IHM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpICsgc107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDAgJiYgKGNhcnJ5ICE9PSAwIHx8IGkgPj0gaCk7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAoY2FycnkgPDwgKDI2IC0gcikpIHwgKHdvcmQgPj4+IHIpO1xuICAgICAgY2FycnkgPSB3b3JkICYgbWFzaztcbiAgICB9XG5cbiAgICAvLyBQdXNoIGNhcnJpZWQgYml0cyBhcyBhIG1hc2tcbiAgICBpZiAobWFza2VkV29yZHMgJiYgY2FycnkgIT09IDApIHtcbiAgICAgIG1hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNocm4gPSBmdW5jdGlvbiBpc2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKTtcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0XG4gIEJOLnByb3RvdHlwZS5zaGxuID0gZnVuY3Rpb24gc2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaGxuID0gZnVuY3Rpb24gdXNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodFxuICBCTi5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uIHNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hybiA9IGZ1bmN0aW9uIHVzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNocm4oYml0cyk7XG4gIH07XG5cbiAgLy8gVGVzdCBpZiBuIGJpdCBpcyBzZXRcbiAgQk4ucHJvdG90eXBlLnRlc3RuID0gZnVuY3Rpb24gdGVzdG4gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgYml0IGFuZCByZXR1cm5cbiAgICB2YXIgdyA9IHRoaXMud29yZHNbc107XG5cbiAgICByZXR1cm4gISEodyAmIHEpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlciAoaW4tcGxhY2UpXG4gIEJOLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG5cbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ2ltYXNrbiB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmUgbnVtYmVycycpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICBzKys7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5taW4ocywgdGhpcy5sZW5ndGgpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IG1hc2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXJcbiAgQk4ucHJvdG90eXBlLm1hc2tuID0gZnVuY3Rpb24gbWFza24gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihiaXRzKTtcbiAgfTtcblxuICAvLyBBZGQgcGxhaW4gbnVtYmVyIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbiBpYWRkbiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaXN1Ym4oLW51bSk7XG5cbiAgICAvLyBQb3NzaWJsZSBzaWduIGNoYW5nZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgKHRoaXMud29yZHNbMF0gfCAwKSA8IG51bSkge1xuICAgICAgICB0aGlzLndvcmRzWzBdID0gbnVtIC0gKHRoaXMud29yZHNbMF0gfCAwKTtcbiAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaXN1Ym4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhvdXQgY2hlY2tzXG4gICAgcmV0dXJuIHRoaXMuX2lhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pYWRkbiA9IGZ1bmN0aW9uIF9pYWRkbiAobnVtKSB7XG4gICAgdGhpcy53b3Jkc1swXSArPSBudW07XG5cbiAgICAvLyBDYXJyeVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA+PSAweDQwMDAwMDA7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSAtPSAweDQwMDAwMDA7XG4gICAgICBpZiAoaSA9PT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdKys7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkgKyAxKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IHBsYWluIG51bWJlciBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaXN1Ym4gPSBmdW5jdGlvbiBpc3VibiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaWFkZG4oLW51bSk7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGRuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMud29yZHNbMF0gLT0gbnVtO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPCAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gLXRoaXMud29yZHNbMF07XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FycnlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA8IDA7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldICs9IDB4NDAwMDAwMDtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gLT0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hZGRuID0gZnVuY3Rpb24gYWRkbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5zdWJuID0gZnVuY3Rpb24gc3VibiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicyAoKSB7XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhYnMoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lzaGxuc3VibXVsID0gZnVuY3Rpb24gX2lzaGxuc3VibXVsIChudW0sIG11bCwgc2hpZnQpIHtcbiAgICB2YXIgbGVuID0gbnVtLmxlbmd0aCArIHNoaWZ0O1xuICAgIHZhciBpO1xuXG4gICAgdGhpcy5fZXhwYW5kKGxlbik7XG5cbiAgICB2YXIgdztcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIHZhciByaWdodCA9IChudW0ud29yZHNbaV0gfCAwKSAqIG11bDtcbiAgICAgIHcgLT0gcmlnaHQgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9ICh3ID4+IDI2KSAtICgocmlnaHQgLyAweDQwMDAwMDApIHwgMCk7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gc2hpZnQ7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgPT09IDApIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cbiAgICAvLyBTdWJ0cmFjdGlvbiBvdmVyZmxvd1xuICAgIGFzc2VydChjYXJyeSA9PT0gLTEpO1xuICAgIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9IC0odGhpcy53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uIF93b3JkRGl2IChudW0sIG1vZGUpIHtcbiAgICB2YXIgc2hpZnQgPSB0aGlzLmxlbmd0aCAtIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bTtcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIHZhciBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIHZhciBiaGlCaXRzID0gdGhpcy5fY291bnRCaXRzKGJoaSk7XG4gICAgc2hpZnQgPSAyNiAtIGJoaUJpdHM7XG4gICAgaWYgKHNoaWZ0ICE9PSAwKSB7XG4gICAgICBiID0gYi51c2hsbihzaGlmdCk7XG4gICAgICBhLml1c2hsbihzaGlmdCk7XG4gICAgICBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgcXVvdGllbnRcbiAgICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgdmFyIHE7XG5cbiAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgIHEgPSBuZXcgQk4obnVsbCk7XG4gICAgICBxLmxlbmd0aCA9IG0gKyAxO1xuICAgICAgcS53b3JkcyA9IG5ldyBBcnJheShxLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcS53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSBhLmNsb25lKCkuX2lzaGxuc3VibXVsKGIsIDEsIG0pO1xuICAgIGlmIChkaWZmLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBhID0gZGlmZjtcbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbbV0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSBtIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIHZhciBxaiA9IChhLndvcmRzW2IubGVuZ3RoICsgal0gfCAwKSAqIDB4NDAwMDAwMCArXG4gICAgICAgIChhLndvcmRzW2IubGVuZ3RoICsgaiAtIDFdIHwgMCk7XG5cbiAgICAgIC8vIE5PVEU6IChxaiAvIGJoaSkgaXMgKDB4M2ZmZmZmZiAqIDB4NDAwMDAwMCArIDB4M2ZmZmZmZikgLyAweDIwMDAwMDAgbWF4XG4gICAgICAvLyAoMHg3ZmZmZmZmKVxuICAgICAgcWogPSBNYXRoLm1pbigocWogLyBiaGkpIHwgMCwgMHgzZmZmZmZmKTtcblxuICAgICAgYS5faXNobG5zdWJtdWwoYiwgcWosIGopO1xuICAgICAgd2hpbGUgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgcWotLTtcbiAgICAgICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIGEuX2lzaGxuc3VibXVsKGIsIDEsIGopO1xuICAgICAgICBpZiAoIWEuaXNaZXJvKCkpIHtcbiAgICAgICAgICBhLm5lZ2F0aXZlIF49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbal0gPSBxajtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHEpIHtcbiAgICAgIHEuc3RyaXAoKTtcbiAgICB9XG4gICAgYS5zdHJpcCgpO1xuXG4gICAgLy8gRGVub3JtYWxpemVcbiAgICBpZiAobW9kZSAhPT0gJ2RpdicgJiYgc2hpZnQgIT09IDApIHtcbiAgICAgIGEuaXVzaHJuKHNoaWZ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGl2OiBxIHx8IG51bGwsXG4gICAgICBtb2Q6IGFcbiAgICB9O1xuICB9O1xuXG4gIC8vIE5PVEU6IDEpIGBtb2RlYCBjYW4gYmUgc2V0IHRvIGBtb2RgIHRvIHJlcXVlc3QgbW9kIG9ubHksXG4gIC8vICAgICAgIHRvIGBkaXZgIHRvIHJlcXVlc3QgZGl2IG9ubHksIG9yIGJlIGFic2VudCB0b1xuICAvLyAgICAgICByZXF1ZXN0IGJvdGggZGl2ICYgbW9kXG4gIC8vICAgICAgIDIpIGBwb3NpdGl2ZWAgaXMgdHJ1ZSBpZiB1bnNpZ25lZCBtb2QgaXMgcmVxdWVzdGVkXG4gIEJOLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbiBkaXZtb2QgKG51bSwgbW9kZSwgcG9zaXRpdmUpIHtcbiAgICBhc3NlcnQoIW51bS5pc1plcm8oKSk7XG5cbiAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogbmV3IEJOKDApXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkaXYsIG1vZCwgcmVzO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlhZGQobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogcmVzLm1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoKHRoaXMubmVnYXRpdmUgJiBudW0ubmVnYXRpdmUpICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pc3ViKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiByZXMuZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCb3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlIGF0IHRoaXMgcG9pbnRcblxuICAgIC8vIFN0cmlwIGJvdGggbnVtYmVycyB0byBhcHByb3hpbWF0ZSBzaGlmdCB2YWx1ZVxuICAgIGlmIChudW0ubGVuZ3RoID4gdGhpcy5sZW5ndGggfHwgdGhpcy5jbXAobnVtKSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IHRoaXNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVmVyeSBzaG9ydCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKG1vZGUgPT09ICdkaXYnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgICBtb2Q6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgPT09ICdtb2QnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiBudWxsLFxuICAgICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dvcmREaXYobnVtLCBtb2RlKTtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAvIGBudW1gXG4gIEJOLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiBkaXYgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdkaXYnLCBmYWxzZSkuZGl2O1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgICUgYG51bWBcbiAgQk4ucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIGZhbHNlKS5tb2Q7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbiB1bW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgdHJ1ZSkubW9kO1xuICB9O1xuXG4gIC8vIEZpbmQgUm91bmQoYHRoaXNgIC8gYG51bWApXG4gIEJOLnByb3RvdHlwZS5kaXZSb3VuZCA9IGZ1bmN0aW9uIGRpdlJvdW5kIChudW0pIHtcbiAgICB2YXIgZG0gPSB0aGlzLmRpdm1vZChudW0pO1xuXG4gICAgLy8gRmFzdCBjYXNlIC0gZXhhY3QgZGl2aXNpb25cbiAgICBpZiAoZG0ubW9kLmlzWmVybygpKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgdmFyIG1vZCA9IGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLm1vZC5pc3ViKG51bSkgOiBkbS5tb2Q7XG5cbiAgICB2YXIgaGFsZiA9IG51bS51c2hybigxKTtcbiAgICB2YXIgcjIgPSBudW0uYW5kbG4oMSk7XG4gICAgdmFyIGNtcCA9IG1vZC5jbXAoaGFsZik7XG5cbiAgICAvLyBSb3VuZCBkb3duXG4gICAgaWYgKGNtcCA8IDAgfHwgcjIgPT09IDEgJiYgY21wID09PSAwKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgLy8gUm91bmQgdXBcbiAgICByZXR1cm4gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0uZGl2LmlzdWJuKDEpIDogZG0uZGl2LmlhZGRuKDEpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tb2RuID0gZnVuY3Rpb24gbW9kbiAobnVtKSB7XG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuICAgIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xuXG4gICAgdmFyIGFjYyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGFjYyA9IChwICogYWNjICsgKHRoaXMud29yZHNbaV0gfCAwKSkgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBkaXZpc2lvbiBieSBudW1iZXJcbiAgQk4ucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24gaWRpdm4gKG51bSkge1xuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5ICogMHg0MDAwMDAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9ICh3IC8gbnVtKSB8IDA7XG4gICAgICBjYXJyeSA9IHcgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZGl2biA9IGZ1bmN0aW9uIGRpdm4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWRpdm4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uIGVnY2QgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciB4ID0gdGhpcztcbiAgICB2YXIgeSA9IHAuY2xvbmUoKTtcblxuICAgIGlmICh4Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB4ID0geC51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geC5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8vIEEgKiB4ICsgQiAqIHkgPSB4XG4gICAgdmFyIEEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIEIgPSBuZXcgQk4oMCk7XG5cbiAgICAvLyBDICogeCArIEQgKiB5ID0geVxuICAgIHZhciBDID0gbmV3IEJOKDApO1xuICAgIHZhciBEID0gbmV3IEJOKDEpO1xuXG4gICAgdmFyIGcgPSAwO1xuXG4gICAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xuICAgICAgeC5pdXNocm4oMSk7XG4gICAgICB5Lml1c2hybigxKTtcbiAgICAgICsrZztcbiAgICB9XG5cbiAgICB2YXIgeXAgPSB5LmNsb25lKCk7XG4gICAgdmFyIHhwID0geC5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKCF4LmlzWmVybygpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoeC53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHguaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmIChBLmlzT2RkKCkgfHwgQi5pc09kZCgpKSB7XG4gICAgICAgICAgICBBLmlhZGQoeXApO1xuICAgICAgICAgICAgQi5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBBLml1c2hybigxKTtcbiAgICAgICAgICBCLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoeS53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIHkuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmIChDLmlzT2RkKCkgfHwgRC5pc09kZCgpKSB7XG4gICAgICAgICAgICBDLmlhZGQoeXApO1xuICAgICAgICAgICAgRC5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBDLml1c2hybigxKTtcbiAgICAgICAgICBELml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeC5jbXAoeSkgPj0gMCkge1xuICAgICAgICB4LmlzdWIoeSk7XG4gICAgICAgIEEuaXN1YihDKTtcbiAgICAgICAgQi5pc3ViKEQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeS5pc3ViKHgpO1xuICAgICAgICBDLmlzdWIoQSk7XG4gICAgICAgIEQuaXN1YihCKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYTogQyxcbiAgICAgIGI6IEQsXG4gICAgICBnY2Q6IHkuaXVzaGxuKGcpXG4gICAgfTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHJlZHVjZWQgaW5jYXJuYXRpb24gb2YgdGhlIGJpbmFyeSBFRUFcbiAgLy8gYWJvdmUsIGRlc2lnbmF0ZWQgdG8gaW52ZXJ0IG1lbWJlcnMgb2YgdGhlXG4gIC8vIF9wcmltZV8gZmllbGRzIEYocCkgYXQgYSBtYXhpbWFsIHNwZWVkXG4gIEJOLnByb3RvdHlwZS5faW52bXAgPSBmdW5jdGlvbiBfaW52bXAgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciBhID0gdGhpcztcbiAgICB2YXIgYiA9IHAuY2xvbmUoKTtcblxuICAgIGlmIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBhID0gYS51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgICB2YXIgeDIgPSBuZXcgQk4oMCk7XG5cbiAgICB2YXIgZGVsdGEgPSBiLmNsb25lKCk7XG5cbiAgICB3aGlsZSAoYS5jbXBuKDEpID4gMCAmJiBiLmNtcG4oMSkgPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoYS53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGEuaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmICh4MS5pc09kZCgpKSB7XG4gICAgICAgICAgICB4MS5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MS5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKGIud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICBiLml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDIuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDIuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhLmNtcChiKSA+PSAwKSB7XG4gICAgICAgIGEuaXN1YihiKTtcbiAgICAgICAgeDEuaXN1Yih4Mik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiLmlzdWIoYSk7XG4gICAgICAgIHgyLmlzdWIoeDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXM7XG4gICAgaWYgKGEuY21wbigxKSA9PT0gMCkge1xuICAgICAgcmVzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHgyO1xuICAgIH1cblxuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHApO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uIGdjZCAobnVtKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBudW0uYWJzKCk7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIHRoaXMuYWJzKCk7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bS5jbG9uZSgpO1xuICAgIGEubmVnYXRpdmUgPSAwO1xuICAgIGIubmVnYXRpdmUgPSAwO1xuXG4gICAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXG4gICAgZm9yICh2YXIgc2hpZnQgPSAwOyBhLmlzRXZlbigpICYmIGIuaXNFdmVuKCk7IHNoaWZ0KyspIHtcbiAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgYi5pdXNocm4oMSk7XG4gICAgfVxuXG4gICAgZG8ge1xuICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcbiAgICAgICAgYS5pdXNocm4oMSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xuICAgICAgICBiLml1c2hybigxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHIgPSBhLmNtcChiKTtcbiAgICAgIGlmIChyIDwgMCkge1xuICAgICAgICAvLyBTd2FwIGBhYCBhbmQgYGJgIHRvIG1ha2UgYGFgIGFsd2F5cyBiaWdnZXIgdGhhbiBgYmBcbiAgICAgICAgdmFyIHQgPSBhO1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYiA9IHQ7XG4gICAgICB9IGVsc2UgaWYgKHIgPT09IDAgfHwgYi5jbXBuKDEpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBhLmlzdWIoYik7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICByZXR1cm4gYi5pdXNobG4oc2hpZnQpO1xuICB9O1xuXG4gIC8vIEludmVydCBudW1iZXIgaW4gdGhlIGZpZWxkIEYobnVtKVxuICBCTi5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmVnY2QobnVtKS5hLnVtb2QobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG4gIH07XG5cbiAgLy8gQW5kIGZpcnN0IHdvcmQgYW5kIG51bVxuICBCTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBudW07XG4gIH07XG5cbiAgLy8gSW5jcmVtZW50IGF0IHRoZSBiaXQgcG9zaXRpb24gaW4tbGluZVxuICBCTi5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbiBiaW5jbiAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICB0aGlzLl9leHBhbmQocyArIDEpO1xuICAgICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJpdCBhbmQgcHJvcGFnYXRlLCBpZiBuZWVkZWRcbiAgICB2YXIgY2FycnkgPSBxO1xuICAgIGZvciAodmFyIGkgPSBzOyBjYXJyeSAhPT0gMCAmJiBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHcgKz0gY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4+IDI2O1xuICAgICAgdyAmPSAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdztcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uIGNtcG4gKG51bSkge1xuICAgIHZhciBuZWdhdGl2ZSA9IG51bSA8IDA7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiAhbmVnYXRpdmUpIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBuZWdhdGl2ZSkgcmV0dXJuIDE7XG5cbiAgICB0aGlzLnN0cmlwKCk7XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICBudW0gPSAtbnVtO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZiwgJ051bWJlciBpcyB0b28gYmlnJyk7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1swXSB8IDA7XG4gICAgICByZXMgPSB3ID09PSBudW0gPyAwIDogdyA8IG51bSA/IC0xIDogMTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvbXBhcmUgdHdvIG51bWJlcnMgYW5kIHJldHVybjpcbiAgLy8gMSAtIGlmIGB0aGlzYCA+IGBudW1gXG4gIC8vIDAgLSBpZiBgdGhpc2AgPT0gYG51bWBcbiAgLy8gLTEgLSBpZiBgdGhpc2AgPCBgbnVtYFxuICBCTi5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24gY21wIChudW0pIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHJldHVybiAxO1xuXG4gICAgdmFyIHJlcyA9IHRoaXMudWNtcChudW0pO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBVbnNpZ25lZCBjb21wYXJpc29uXG4gIEJOLnByb3RvdHlwZS51Y21wID0gZnVuY3Rpb24gdWNtcCAobnVtKSB7XG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgaGF2ZSB0aGUgc2FtZSBzaWduXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIDE7XG4gICAgaWYgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkgcmV0dXJuIC0xO1xuXG4gICAgdmFyIHJlcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB2YXIgYiA9IG51bS53b3Jkc1tpXSB8IDA7XG5cbiAgICAgIGlmIChhID09PSBiKSBjb250aW51ZTtcbiAgICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXMgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmVzID0gMTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndG4gPSBmdW5jdGlvbiBndG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiBndCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZW4gPSBmdW5jdGlvbiBndGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlID0gZnVuY3Rpb24gZ3RlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdG4gPSBmdW5jdGlvbiBsdG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gbHQgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlbiA9IGZ1bmN0aW9uIGx0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGUgPSBmdW5jdGlvbiBsdGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxbiA9IGZ1bmN0aW9uIGVxbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMDtcbiAgfTtcblxuICAvL1xuICAvLyBBIHJlZHVjZSBjb250ZXh0LCBjb3VsZCBiZSB1c2luZyBtb250Z29tZXJ5IG9yIHNvbWV0aGluZyBiZXR0ZXIsIGRlcGVuZGluZ1xuICAvLyBvbiB0aGUgYG1gIGl0c2VsZi5cbiAgLy9cbiAgQk4ucmVkID0gZnVuY3Rpb24gcmVkIChudW0pIHtcbiAgICByZXR1cm4gbmV3IFJlZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1JlZCA9IGZ1bmN0aW9uIHRvUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICByZXR1cm4gY3R4LmNvbnZlcnRUbyh0aGlzKS5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVJlZCA9IGZ1bmN0aW9uIGZyb21SZWQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ2Zyb21SZWQgd29ya3Mgb25seSB3aXRoIG51bWJlcnMgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuY29udmVydEZyb20odGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9mb3JjZVJlZCA9IGZ1bmN0aW9uIF9mb3JjZVJlZCAoY3R4KSB7XG4gICAgdGhpcy5yZWQgPSBjdHg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZvcmNlUmVkID0gZnVuY3Rpb24gZm9yY2VSZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEFkZCA9IGZ1bmN0aW9uIHJlZEFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5hZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSUFkZCA9IGZ1bmN0aW9uIHJlZElBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlhZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3ViID0gZnVuY3Rpb24gcmVkU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3ViID0gZnVuY3Rpb24gcmVkSVN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTaGwgPSBmdW5jdGlvbiByZWRTaGwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc2hsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZE11bCA9IGZ1bmN0aW9uIHJlZE11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJTXVsID0gZnVuY3Rpb24gcmVkSU11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmltdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3FyID0gZnVuY3Rpb24gcmVkU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVNxciA9IGZ1bmN0aW9uIHJlZElTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzcXIodGhpcyk7XG4gIH07XG5cbiAgLy8gU3F1YXJlIHJvb3Qgb3ZlciBwXG4gIEJOLnByb3RvdHlwZS5yZWRTcXJ0ID0gZnVuY3Rpb24gcmVkU3FydCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FydCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FydCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSW52bSA9IGZ1bmN0aW9uIHJlZEludm0gKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEludm0gd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmludm0odGhpcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYCAlIGByZWQgbW9kdWxvYFxuICBCTi5wcm90b3R5cGUucmVkTmVnID0gZnVuY3Rpb24gcmVkTmVnICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm5lZyh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkUG93ID0gZnVuY3Rpb24gcmVkUG93IChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQgJiYgIW51bS5yZWQsICdyZWRQb3cobm9ybWFsTnVtKScpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5wb3codGhpcywgbnVtKTtcbiAgfTtcblxuICAvLyBQcmltZSBudW1iZXJzIHdpdGggZWZmaWNpZW50IHJlZHVjdGlvblxuICB2YXIgcHJpbWVzID0ge1xuICAgIGsyNTY6IG51bGwsXG4gICAgcDIyNDogbnVsbCxcbiAgICBwMTkyOiBudWxsLFxuICAgIHAyNTUxOTogbnVsbFxuICB9O1xuXG4gIC8vIFBzZXVkby1NZXJzZW5uZSBwcmltZVxuICBmdW5jdGlvbiBNUHJpbWUgKG5hbWUsIHApIHtcbiAgICAvLyBQID0gMiBeIE4gLSBLXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnAgPSBuZXcgQk4ocCwgMTYpO1xuICAgIHRoaXMubiA9IHRoaXMucC5iaXRMZW5ndGgoKTtcbiAgICB0aGlzLmsgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMubikuaXN1Yih0aGlzLnApO1xuXG4gICAgdGhpcy50bXAgPSB0aGlzLl90bXAoKTtcbiAgfVxuXG4gIE1QcmltZS5wcm90b3R5cGUuX3RtcCA9IGZ1bmN0aW9uIF90bXAgKCkge1xuICAgIHZhciB0bXAgPSBuZXcgQk4obnVsbCk7XG4gICAgdG1wLndvcmRzID0gbmV3IEFycmF5KE1hdGguY2VpbCh0aGlzLm4gLyAxMykpO1xuICAgIHJldHVybiB0bXA7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pcmVkdWNlID0gZnVuY3Rpb24gaXJlZHVjZSAobnVtKSB7XG4gICAgLy8gQXNzdW1lcyB0aGF0IGBudW1gIGlzIGxlc3MgdGhhbiBgUF4yYFxuICAgIC8vIG51bSA9IEhJICogKDIgXiBOIC0gSykgKyBISSAqIEsgKyBMTyA9IEhJICogSyArIExPIChtb2QgUClcbiAgICB2YXIgciA9IG51bTtcbiAgICB2YXIgcmxlbjtcblxuICAgIGRvIHtcbiAgICAgIHRoaXMuc3BsaXQociwgdGhpcy50bXApO1xuICAgICAgciA9IHRoaXMuaW11bEsocik7XG4gICAgICByID0gci5pYWRkKHRoaXMudG1wKTtcbiAgICAgIHJsZW4gPSByLmJpdExlbmd0aCgpO1xuICAgIH0gd2hpbGUgKHJsZW4gPiB0aGlzLm4pO1xuXG4gICAgdmFyIGNtcCA9IHJsZW4gPCB0aGlzLm4gPyAtMSA6IHIudWNtcCh0aGlzLnApO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHIud29yZHNbMF0gPSAwO1xuICAgICAgci5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgci5pc3ViKHRoaXMucCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIuc3RyaXAoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXQpIHtcbiAgICBpbnB1dC5pdXNocm4odGhpcy5uLCAwLCBvdXQpO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgcmV0dXJuIG51bS5pbXVsKHRoaXMuayk7XG4gIH07XG5cbiAgZnVuY3Rpb24gSzI1NiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ2syNTYnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyk7XG4gIH1cbiAgaW5oZXJpdHMoSzI1NiwgTVByaW1lKTtcblxuICBLMjU2LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0cHV0KSB7XG4gICAgLy8gMjU2ID0gOSAqIDI2ICsgMjJcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmO1xuXG4gICAgdmFyIG91dExlbiA9IE1hdGgubWluKGlucHV0Lmxlbmd0aCwgOSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRMZW47IGkrKykge1xuICAgICAgb3V0cHV0LndvcmRzW2ldID0gaW5wdXQud29yZHNbaV07XG4gICAgfVxuICAgIG91dHB1dC5sZW5ndGggPSBvdXRMZW47XG5cbiAgICBpZiAoaW5wdXQubGVuZ3RoIDw9IDkpIHtcbiAgICAgIGlucHV0LndvcmRzWzBdID0gMDtcbiAgICAgIGlucHV0Lmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2hpZnQgYnkgOSBsaW1ic1xuICAgIHZhciBwcmV2ID0gaW5wdXQud29yZHNbOV07XG4gICAgb3V0cHV0LndvcmRzW291dHB1dC5sZW5ndGgrK10gPSBwcmV2ICYgbWFzaztcblxuICAgIGZvciAoaSA9IDEwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0ID0gaW5wdXQud29yZHNbaV0gfCAwO1xuICAgICAgaW5wdXQud29yZHNbaSAtIDEwXSA9ICgobmV4dCAmIG1hc2spIDw8IDQpIHwgKHByZXYgPj4+IDIyKTtcbiAgICAgIHByZXYgPSBuZXh0O1xuICAgIH1cbiAgICBwcmV2ID4+Pj0gMjI7XG4gICAgaW5wdXQud29yZHNbaSAtIDEwXSA9IHByZXY7XG4gICAgaWYgKHByZXYgPT09IDAgJiYgaW5wdXQubGVuZ3RoID4gMTApIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQubGVuZ3RoIC09IDk7XG4gICAgfVxuICB9O1xuXG4gIEsyNTYucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEwMDAwMDNkMSA9IFsgMHg0MCwgMHgzZDEgXVxuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoXSA9IDA7XG4gICAgbnVtLndvcmRzW251bS5sZW5ndGggKyAxXSA9IDA7XG4gICAgbnVtLmxlbmd0aCArPSAyO1xuXG4gICAgLy8gYm91bmRlZCBhdDogMHg0MCAqIDB4M2ZmZmZmZiArIDB4M2QwID0gMHgxMDAwMDAzOTBcbiAgICB2YXIgbG8gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IG51bS53b3Jkc1tpXSB8IDA7XG4gICAgICBsbyArPSB3ICogMHgzZDE7XG4gICAgICBudW0ud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgIGxvID0gdyAqIDB4NDAgKyAoKGxvIC8gMHg0MDAwMDAwKSB8IDApO1xuICAgIH1cblxuICAgIC8vIEZhc3QgbGVuZ3RoIHJlZHVjdGlvblxuICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICBudW0ubGVuZ3RoLS07XG4gICAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgICBudW0ubGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgZnVuY3Rpb24gUDIyNCAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AyMjQnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDIyNCwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMTkyICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncDE5MicsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnKTtcbiAgfVxuICBpbmhlcml0cyhQMTkyLCBNUHJpbWUpO1xuXG4gIGZ1bmN0aW9uIFAyNTUxOSAoKSB7XG4gICAgLy8gMiBeIDI1NSAtIDE5XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJzI1NTE5JyxcbiAgICAgICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDI1NTE5LCBNUHJpbWUpO1xuXG4gIFAyNTUxOS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgLy8gSyA9IDB4MTNcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGkgPSAobnVtLndvcmRzW2ldIHwgMCkgKiAweDEzICsgY2Fycnk7XG4gICAgICB2YXIgbG8gPSBoaSAmIDB4M2ZmZmZmZjtcbiAgICAgIGhpID4+Pj0gMjY7XG5cbiAgICAgIG51bS53b3Jkc1tpXSA9IGxvO1xuICAgICAgY2FycnkgPSBoaTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBudW0ud29yZHNbbnVtLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIC8vIEV4cG9ydGVkIG1vc3RseSBmb3IgdGVzdGluZyBwdXJwb3NlcywgdXNlIHBsYWluIG5hbWUgaW5zdGVhZFxuICBCTi5fcHJpbWUgPSBmdW5jdGlvbiBwcmltZSAobmFtZSkge1xuICAgIC8vIENhY2hlZCB2ZXJzaW9uIG9mIHByaW1lXG4gICAgaWYgKHByaW1lc1tuYW1lXSkgcmV0dXJuIHByaW1lc1tuYW1lXTtcblxuICAgIHZhciBwcmltZTtcbiAgICBpZiAobmFtZSA9PT0gJ2syNTYnKSB7XG4gICAgICBwcmltZSA9IG5ldyBLMjU2KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDIyNCcpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyMjQoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMTkyJykge1xuICAgICAgcHJpbWUgPSBuZXcgUDE5MigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyNTUxOScpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyNTUxOSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJpbWUgJyArIG5hbWUpO1xuICAgIH1cbiAgICBwcmltZXNbbmFtZV0gPSBwcmltZTtcblxuICAgIHJldHVybiBwcmltZTtcbiAgfTtcblxuICAvL1xuICAvLyBCYXNlIHJlZHVjdGlvbiBlbmdpbmVcbiAgLy9cbiAgZnVuY3Rpb24gUmVkIChtKSB7XG4gICAgaWYgKHR5cGVvZiBtID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHByaW1lID0gQk4uX3ByaW1lKG0pO1xuICAgICAgdGhpcy5tID0gcHJpbWUucDtcbiAgICAgIHRoaXMucHJpbWUgPSBwcmltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG0uZ3RuKDEpLCAnbW9kdWx1cyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxJyk7XG4gICAgICB0aGlzLm0gPSBtO1xuICAgICAgdGhpcy5wcmltZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uIF92ZXJpZnkxIChhKSB7XG4gICAgYXNzZXJ0KGEubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLl92ZXJpZnkyID0gZnVuY3Rpb24gX3ZlcmlmeTIgKGEsIGIpIHtcbiAgICBhc3NlcnQoKGEubmVnYXRpdmUgfCBiLm5lZ2F0aXZlKSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgYXNzZXJ0KGEucmVkICYmIGEucmVkID09PSBiLnJlZCxcbiAgICAgICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbW9kID0gZnVuY3Rpb24gaW1vZCAoYSkge1xuICAgIGlmICh0aGlzLnByaW1lKSByZXR1cm4gdGhpcy5wcmltZS5pcmVkdWNlKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgICByZXR1cm4gYS51bW9kKHRoaXMubSkuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnIChhKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiBhLmNsb25lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubS5zdWIoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmFkZChiKTtcbiAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuaWFkZChiKTtcbiAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuc3ViKGIpO1xuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuaXN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc2hsID0gZnVuY3Rpb24gc2hsIChhLCBudW0pIHtcbiAgICB0aGlzLl92ZXJpZnkxKGEpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS51c2hsbihudW0pKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEuaW11bChiKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS5tdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKGEpIHtcbiAgICByZXR1cm4gdGhpcy5pbXVsKGEsIGEuY2xvbmUoKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKGEpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwoYSwgYSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gc3FydCAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIG1vZDMgPSB0aGlzLm0uYW5kbG4oMyk7XG4gICAgYXNzZXJ0KG1vZDMgJSAyID09PSAxKTtcblxuICAgIC8vIEZhc3QgY2FzZVxuICAgIGlmIChtb2QzID09PSAzKSB7XG4gICAgICB2YXIgcG93ID0gdGhpcy5tLmFkZChuZXcgQk4oMSkpLml1c2hybigyKTtcbiAgICAgIHJldHVybiB0aGlzLnBvdyhhLCBwb3cpO1xuICAgIH1cblxuICAgIC8vIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobSAoVG90YWxseSB1bm9wdGltaXplZCBhbmQgc2xvdylcbiAgICAvL1xuICAgIC8vIEZpbmQgUSBhbmQgUywgdGhhdCBRICogMiBeIFMgPSAoUCAtIDEpXG4gICAgdmFyIHEgPSB0aGlzLm0uc3VibigxKTtcbiAgICB2YXIgcyA9IDA7XG4gICAgd2hpbGUgKCFxLmlzWmVybygpICYmIHEuYW5kbG4oMSkgPT09IDApIHtcbiAgICAgIHMrKztcbiAgICAgIHEuaXVzaHJuKDEpO1xuICAgIH1cbiAgICBhc3NlcnQoIXEuaXNaZXJvKCkpO1xuXG4gICAgdmFyIG9uZSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICB2YXIgbk9uZSA9IG9uZS5yZWROZWcoKTtcblxuICAgIC8vIEZpbmQgcXVhZHJhdGljIG5vbi1yZXNpZHVlXG4gICAgLy8gTk9URTogTWF4IGlzIHN1Y2ggYmVjYXVzZSBvZiBnZW5lcmFsaXplZCBSaWVtYW5uIGh5cG90aGVzaXMuXG4gICAgdmFyIGxwb3cgPSB0aGlzLm0uc3VibigxKS5pdXNocm4oMSk7XG4gICAgdmFyIHogPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgeiA9IG5ldyBCTigyICogeiAqIHopLnRvUmVkKHRoaXMpO1xuXG4gICAgd2hpbGUgKHRoaXMucG93KHosIGxwb3cpLmNtcChuT25lKSAhPT0gMCkge1xuICAgICAgei5yZWRJQWRkKG5PbmUpO1xuICAgIH1cblxuICAgIHZhciBjID0gdGhpcy5wb3coeiwgcSk7XG4gICAgdmFyIHIgPSB0aGlzLnBvdyhhLCBxLmFkZG4oMSkuaXVzaHJuKDEpKTtcbiAgICB2YXIgdCA9IHRoaXMucG93KGEsIHEpO1xuICAgIHZhciBtID0gcztcbiAgICB3aGlsZSAodC5jbXAob25lKSAhPT0gMCkge1xuICAgICAgdmFyIHRtcCA9IHQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgdG1wLmNtcChvbmUpICE9PSAwOyBpKyspIHtcbiAgICAgICAgdG1wID0gdG1wLnJlZFNxcigpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGkgPCBtKTtcbiAgICAgIHZhciBiID0gdGhpcy5wb3coYywgbmV3IEJOKDEpLml1c2hsbihtIC0gaSAtIDEpKTtcblxuICAgICAgciA9IHIucmVkTXVsKGIpO1xuICAgICAgYyA9IGIucmVkU3FyKCk7XG4gICAgICB0ID0gdC5yZWRNdWwoYyk7XG4gICAgICBtID0gaTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgdmFyIGludiA9IGEuX2ludm1wKHRoaXMubSk7XG4gICAgaWYgKGludi5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaW52Lm5lZ2F0aXZlID0gMDtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KS5yZWROZWcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpO1xuICAgIH1cbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAoYSwgbnVtKSB7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigxKTtcbiAgICBpZiAobnVtLmNtcG4oMSkgPT09IDApIHJldHVybiBhLmNsb25lKCk7XG5cbiAgICB2YXIgd2luZG93U2l6ZSA9IDQ7XG4gICAgdmFyIHduZCA9IG5ldyBBcnJheSgxIDw8IHdpbmRvd1NpemUpO1xuICAgIHduZFswXSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICB3bmRbMV0gPSBhO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgd25kLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3bmRbaV0gPSB0aGlzLm11bCh3bmRbaSAtIDFdLCBhKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gd25kWzBdO1xuICAgIHZhciBjdXJyZW50ID0gMDtcbiAgICB2YXIgY3VycmVudExlbiA9IDA7XG4gICAgdmFyIHN0YXJ0ID0gbnVtLmJpdExlbmd0aCgpICUgMjY7XG4gICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICBzdGFydCA9IDI2O1xuICAgIH1cblxuICAgIGZvciAoaSA9IG51bS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSBudW0ud29yZHNbaV07XG4gICAgICBmb3IgKHZhciBqID0gc3RhcnQgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICB2YXIgYml0ID0gKHdvcmQgPj4gaikgJiAxO1xuICAgICAgICBpZiAocmVzICE9PSB3bmRbMF0pIHtcbiAgICAgICAgICByZXMgPSB0aGlzLnNxcihyZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJpdCA9PT0gMCAmJiBjdXJyZW50ID09PSAwKSB7XG4gICAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50IDw8PSAxO1xuICAgICAgICBjdXJyZW50IHw9IGJpdDtcbiAgICAgICAgY3VycmVudExlbisrO1xuICAgICAgICBpZiAoY3VycmVudExlbiAhPT0gd2luZG93U2l6ZSAmJiAoaSAhPT0gMCB8fCBqICE9PSAwKSkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gdGhpcy5tdWwocmVzLCB3bmRbY3VycmVudF0pO1xuICAgICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgICAgY3VycmVudCA9IDA7XG4gICAgICB9XG4gICAgICBzdGFydCA9IDI2O1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHZhciByID0gbnVtLnVtb2QodGhpcy5tKTtcblxuICAgIHJldHVybiByID09PSBudW0gPyByLmNsb25lKCkgOiByO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG4gICAgdmFyIHJlcyA9IG51bS5jbG9uZSgpO1xuICAgIHJlcy5yZWQgPSBudWxsO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy9cbiAgLy8gTW9udGdvbWVyeSBtZXRob2QgZW5naW5lXG4gIC8vXG5cbiAgQk4ubW9udCA9IGZ1bmN0aW9uIG1vbnQgKG51bSkge1xuICAgIHJldHVybiBuZXcgTW9udChudW0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIE1vbnQgKG0pIHtcbiAgICBSZWQuY2FsbCh0aGlzLCBtKTtcblxuICAgIHRoaXMuc2hpZnQgPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgaWYgKHRoaXMuc2hpZnQgJSAyNiAhPT0gMCkge1xuICAgICAgdGhpcy5zaGlmdCArPSAyNiAtICh0aGlzLnNoaWZ0ICUgMjYpO1xuICAgIH1cblxuICAgIHRoaXMuciA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5zaGlmdCk7XG4gICAgdGhpcy5yMiA9IHRoaXMuaW1vZCh0aGlzLnIuc3FyKCkpO1xuICAgIHRoaXMucmludiA9IHRoaXMuci5faW52bXAodGhpcy5tKTtcblxuICAgIHRoaXMubWludiA9IHRoaXMucmludi5tdWwodGhpcy5yKS5pc3VibigxKS5kaXYodGhpcy5tKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLm1pbnYudW1vZCh0aGlzLnIpO1xuICAgIHRoaXMubWludiA9IHRoaXMuci5zdWIodGhpcy5taW52KTtcbiAgfVxuICBpbmhlcml0cyhNb250LCBSZWQpO1xuXG4gIE1vbnQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChudW0udXNobG4odGhpcy5zaGlmdCkpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByID0gdGhpcy5pbW9kKG51bS5tdWwodGhpcy5yaW52KSk7XG4gICAgci5yZWQgPSBudWxsO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkge1xuICAgICAgYS53b3Jkc1swXSA9IDA7XG4gICAgICBhLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IGEuaW11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcblxuICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigwKS5fZm9yY2VSZWQodGhpcyk7XG5cbiAgICB2YXIgdCA9IGEubXVsKGIpO1xuICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICAgIHZhciByZXMgPSB1O1xuICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcbiAgICAvLyAoQVIpXi0xICogUl4yID0gKEFeLTEgKiBSXi0xKSAqIFJeMiA9IEFeLTEgKiBSXG4gICAgdmFyIHJlcyA9IHRoaXMuaW1vZChhLl9pbnZtcCh0aGlzLm0pLm11bCh0aGlzLnIyKSk7XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG59KSh0eXBlb2YgbW9kdWxlID09PSAndW5kZWZpbmVkJyB8fCBtb2R1bGUsIHRoaXMpO1xuIiwiLyoqXHJcbiAqIFtqcy1zaGEzXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZW1uMTc4L2pzLXNoYTN9XHJcbiAqXHJcbiAqIEB2ZXJzaW9uIDAuNS41XHJcbiAqIEBhdXRob3IgQ2hlbiwgWWktQ3l1YW4gW2VtbjE3OEBnbWFpbC5jb21dXHJcbiAqIEBjb3B5cmlnaHQgQ2hlbiwgWWktQ3l1YW4gMjAxNS0yMDE2XHJcbiAqIEBsaWNlbnNlIE1JVFxyXG4gKi9cclxuKGZ1bmN0aW9uIChyb290KSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB2YXIgTk9ERV9KUyA9IHR5cGVvZiBwcm9jZXNzID09ICdvYmplY3QnICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO1xyXG4gIGlmIChOT0RFX0pTKSB7XHJcbiAgICByb290ID0gZ2xvYmFsO1xyXG4gIH1cclxuICB2YXIgQ09NTU9OX0pTID0gIXJvb3QuSlNfU0hBM19URVNUICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHM7XHJcbiAgdmFyIEhFWF9DSEFSUyA9ICcwMTIzNDU2Nzg5YWJjZGVmJy5zcGxpdCgnJyk7XHJcbiAgdmFyIFNIQUtFX1BBRERJTkcgPSBbMzEsIDc5MzYsIDIwMzE2MTYsIDUyMDA5MzY5Nl07XHJcbiAgdmFyIEtFQ0NBS19QQURESU5HID0gWzEsIDI1NiwgNjU1MzYsIDE2Nzc3MjE2XTtcclxuICB2YXIgUEFERElORyA9IFs2LCAxNTM2LCAzOTMyMTYsIDEwMDY2MzI5Nl07XHJcbiAgdmFyIFNISUZUID0gWzAsIDgsIDE2LCAyNF07XHJcbiAgdmFyIFJDID0gWzEsIDAsIDMyODk4LCAwLCAzMjkwNiwgMjE0NzQ4MzY0OCwgMjE0NzUxNjQxNiwgMjE0NzQ4MzY0OCwgMzI5MDcsIDAsIDIxNDc0ODM2NDksXHJcbiAgICAgICAgICAgIDAsIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyNzc3LCAyMTQ3NDgzNjQ4LCAxMzgsIDAsIDEzNiwgMCwgMjE0NzUxNjQyNSwgMCwgXHJcbiAgICAgICAgICAgIDIxNDc0ODM2NTgsIDAsIDIxNDc1MTY1NTUsIDAsIDEzOSwgMjE0NzQ4MzY0OCwgMzI5MDUsIDIxNDc0ODM2NDgsIDMyNzcxLCBcclxuICAgICAgICAgICAgMjE0NzQ4MzY0OCwgMzI3NzAsIDIxNDc0ODM2NDgsIDEyOCwgMjE0NzQ4MzY0OCwgMzI3NzgsIDAsIDIxNDc0ODM2NTgsIDIxNDc0ODM2NDgsXHJcbiAgICAgICAgICAgIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyODk2LCAyMTQ3NDgzNjQ4LCAyMTQ3NDgzNjQ5LCAwLCAyMTQ3NTE2NDI0LCAyMTQ3NDgzNjQ4XTtcclxuICB2YXIgQklUUyA9IFsyMjQsIDI1NiwgMzg0LCA1MTJdO1xyXG4gIHZhciBTSEFLRV9CSVRTID0gWzEyOCwgMjU2XTtcclxuICB2YXIgT1VUUFVUX1RZUEVTID0gWydoZXgnLCAnYnVmZmVyJywgJ2FycmF5QnVmZmVyJywgJ2FycmF5J107XHJcblxyXG4gIHZhciBjcmVhdGVPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZywgb3V0cHV0VHlwZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIGJpdHMpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIG91dHB1dEJpdHMpIHtcclxuICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cykudXBkYXRlKG1lc3NhZ2UpW291dHB1dFR5cGVdKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nKSB7XHJcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsICdoZXgnKTtcclxuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIGJpdHMpO1xyXG4gICAgfTtcclxuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZSgpLnVwZGF0ZShtZXNzYWdlKTtcclxuICAgIH07XHJcbiAgICBmb3IgKHZhciBpID0gMDtpIDwgT1VUUFVUX1RZUEVTLmxlbmd0aDsrK2kpIHtcclxuICAgICAgdmFyIHR5cGUgPSBPVVRQVVRfVFlQRVNbaV07XHJcbiAgICAgIG1ldGhvZFt0eXBlXSA9IGNyZWF0ZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCB0eXBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtZXRob2Q7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGNyZWF0ZVNoYWtlTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcpIHtcclxuICAgIHZhciBtZXRob2QgPSBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7XHJcbiAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKG91dHB1dEJpdHMpIHtcclxuICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cyk7XHJcbiAgICB9O1xyXG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvdXRwdXRCaXRzKSB7XHJcbiAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKG91dHB1dEJpdHMpLnVwZGF0ZShtZXNzYWdlKTtcclxuICAgIH07XHJcbiAgICBmb3IgKHZhciBpID0gMDtpIDwgT1VUUFVUX1RZUEVTLmxlbmd0aDsrK2kpIHtcclxuICAgICAgdmFyIHR5cGUgPSBPVVRQVVRfVFlQRVNbaV07XHJcbiAgICAgIG1ldGhvZFt0eXBlXSA9IGNyZWF0ZVNoYWtlT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsIHR5cGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1ldGhvZDtcclxuICB9O1xyXG5cclxuICB2YXIgYWxnb3JpdGhtcyA9IFtcclxuICAgIHtuYW1lOiAna2VjY2FrJywgcGFkZGluZzogS0VDQ0FLX1BBRERJTkcsIGJpdHM6IEJJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlTWV0aG9kfSxcclxuICAgIHtuYW1lOiAnc2hhMycsIHBhZGRpbmc6IFBBRERJTkcsIGJpdHM6IEJJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlTWV0aG9kfSxcclxuICAgIHtuYW1lOiAnc2hha2UnLCBwYWRkaW5nOiBTSEFLRV9QQURESU5HLCBiaXRzOiBTSEFLRV9CSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZVNoYWtlTWV0aG9kfVxyXG4gIF07XHJcblxyXG4gIHZhciBtZXRob2RzID0ge307XHJcblxyXG4gIGZvciAodmFyIGkgPSAwO2kgPCBhbGdvcml0aG1zLmxlbmd0aDsrK2kpIHtcclxuICAgIHZhciBhbGdvcml0aG0gPSBhbGdvcml0aG1zW2ldO1xyXG4gICAgdmFyIGJpdHMgID0gYWxnb3JpdGhtLmJpdHM7XHJcbiAgICBmb3IgKHZhciBqID0gMDtqIDwgYml0cy5sZW5ndGg7KytqKSB7XHJcbiAgICAgIG1ldGhvZHNbYWxnb3JpdGhtLm5hbWUgKydfJyArIGJpdHNbal1dID0gYWxnb3JpdGhtLmNyZWF0ZU1ldGhvZChiaXRzW2pdLCBhbGdvcml0aG0ucGFkZGluZyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBLZWNjYWsoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cykge1xyXG4gICAgdGhpcy5ibG9ja3MgPSBbXTtcclxuICAgIHRoaXMucyA9IFtdO1xyXG4gICAgdGhpcy5wYWRkaW5nID0gcGFkZGluZztcclxuICAgIHRoaXMub3V0cHV0Qml0cyA9IG91dHB1dEJpdHM7XHJcbiAgICB0aGlzLnJlc2V0ID0gdHJ1ZTtcclxuICAgIHRoaXMuYmxvY2sgPSAwO1xyXG4gICAgdGhpcy5zdGFydCA9IDA7XHJcbiAgICB0aGlzLmJsb2NrQ291bnQgPSAoMTYwMCAtIChiaXRzIDw8IDEpKSA+PiA1O1xyXG4gICAgdGhpcy5ieXRlQ291bnQgPSB0aGlzLmJsb2NrQ291bnQgPDwgMjtcclxuICAgIHRoaXMub3V0cHV0QmxvY2tzID0gb3V0cHV0Qml0cyA+PiA1O1xyXG4gICAgdGhpcy5leHRyYUJ5dGVzID0gKG91dHB1dEJpdHMgJiAzMSkgPj4gMztcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDtpIDwgNTA7KytpKSB7XHJcbiAgICAgIHRoaXMuc1tpXSA9IDA7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgS2VjY2FrLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgdmFyIG5vdFN0cmluZyA9IHR5cGVvZiBtZXNzYWdlICE9ICdzdHJpbmcnO1xyXG4gICAgaWYgKG5vdFN0cmluZyAmJiBtZXNzYWdlLmNvbnN0cnVjdG9yID09IHJvb3QuQXJyYXlCdWZmZXIpIHtcclxuICAgICAgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgdmFyIGxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoLCBibG9ja3MgPSB0aGlzLmJsb2NrcywgYnl0ZUNvdW50ID0gdGhpcy5ieXRlQ291bnQsIFxyXG4gICAgICAgIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIGluZGV4ID0gMCwgcyA9IHRoaXMucywgaSwgY29kZTtcclxuICAgIFxyXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgIGlmICh0aGlzLnJlc2V0KSB7XHJcbiAgICAgICAgdGhpcy5yZXNldCA9IGZhbHNlO1xyXG4gICAgICAgIGJsb2Nrc1swXSA9IHRoaXMuYmxvY2s7XHJcbiAgICAgICAgZm9yIChpID0gMTtpIDwgYmxvY2tDb3VudCArIDE7KytpKSB7XHJcbiAgICAgICAgICBibG9ja3NbaV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAobm90U3RyaW5nKSB7XHJcbiAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDtpbmRleCA8IGxlbmd0aCAmJiBpIDwgYnl0ZUNvdW50OysraW5kZXgpIHtcclxuICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9IG1lc3NhZ2VbaW5kZXhdIDw8IFNISUZUW2krKyAmIDNdO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0O2luZGV4IDwgbGVuZ3RoICYmIGkgPCBieXRlQ291bnQ7KytpbmRleCkge1xyXG4gICAgICAgICAgY29kZSA9IG1lc3NhZ2UuY2hhckNvZGVBdChpbmRleCk7XHJcbiAgICAgICAgICBpZiAoY29kZSA8IDB4ODApIHtcclxuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gY29kZSA8PCBTSElGVFtpKysgJiAzXTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGMwIHwgKGNvZGUgPj4gNikpIDw8IFNISUZUW2krKyAmIDNdO1xyXG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGUwIHwgKGNvZGUgPj4gMTIpKSA8PCBTSElGVFtpKysgJiAzXTtcclxuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XHJcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKG1lc3NhZ2UuY2hhckNvZGVBdCgrK2luZGV4KSAmIDB4M2ZmKSk7XHJcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGYwIHwgKGNvZGUgPj4gMTgpKSA8PCBTSElGVFtpKysgJiAzXTtcclxuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gMTIpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xyXG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcclxuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5sYXN0Qnl0ZUluZGV4ID0gaTtcclxuICAgICAgaWYgKGkgPj0gYnl0ZUNvdW50KSB7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IGkgLSBieXRlQ291bnQ7XHJcbiAgICAgICAgdGhpcy5ibG9jayA9IGJsb2Nrc1tibG9ja0NvdW50XTtcclxuICAgICAgICBmb3IgKGkgPSAwO2kgPCBibG9ja0NvdW50OysraSkge1xyXG4gICAgICAgICAgc1tpXSBePSBibG9ja3NbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGYocyk7XHJcbiAgICAgICAgdGhpcy5yZXNldCA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IGk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIEtlY2Nhay5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGkgPSB0aGlzLmxhc3RCeXRlSW5kZXgsIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnM7XHJcbiAgICBibG9ja3NbaSA+PiAyXSB8PSB0aGlzLnBhZGRpbmdbaSAmIDNdO1xyXG4gICAgaWYgKHRoaXMubGFzdEJ5dGVJbmRleCA9PSB0aGlzLmJ5dGVDb3VudCkge1xyXG4gICAgICBibG9ja3NbMF0gPSBibG9ja3NbYmxvY2tDb3VudF07XHJcbiAgICAgIGZvciAoaSA9IDE7aSA8IGJsb2NrQ291bnQgKyAxOysraSkge1xyXG4gICAgICAgIGJsb2Nrc1tpXSA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGJsb2Nrc1tibG9ja0NvdW50IC0gMV0gfD0gMHg4MDAwMDAwMDtcclxuICAgIGZvciAoaSA9IDA7aSA8IGJsb2NrQ291bnQ7KytpKSB7XHJcbiAgICAgIHNbaV0gXj0gYmxvY2tzW2ldO1xyXG4gICAgfVxyXG4gICAgZihzKTtcclxuICB9O1xyXG5cclxuICBLZWNjYWsucHJvdG90eXBlLnRvU3RyaW5nID0gS2VjY2FrLnByb3RvdHlwZS5oZXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmZpbmFsaXplKCk7XHJcblxyXG4gICAgdmFyIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnMsIG91dHB1dEJsb2NrcyA9IHRoaXMub3V0cHV0QmxvY2tzLCBcclxuICAgICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XHJcbiAgICB2YXIgaGV4ID0gJycsIGJsb2NrO1xyXG4gICAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHtcclxuICAgICAgZm9yIChpID0gMDtpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOysraSwgKytqKSB7XHJcbiAgICAgICAgYmxvY2sgPSBzW2ldO1xyXG4gICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbYmxvY2sgJiAweDBGXSArXHJcbiAgICAgICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDgpICYgMHgwRl0gK1xyXG4gICAgICAgICAgICAgICBIRVhfQ0hBUlNbKGJsb2NrID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiAxNikgJiAweDBGXSArXHJcbiAgICAgICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDI0KSAmIDB4MEZdO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PSAwKSB7XHJcbiAgICAgICAgZihzKTtcclxuICAgICAgICBpID0gMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGV4dHJhQnl0ZXMpIHtcclxuICAgICAgYmxvY2sgPSBzW2ldO1xyXG4gICAgICBpZiAoZXh0cmFCeXRlcyA+IDApIHtcclxuICAgICAgICBoZXggKz0gSEVYX0NIQVJTWyhibG9jayA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2Jsb2NrICYgMHgwRl07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAxKSB7XHJcbiAgICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDgpICYgMHgwRl07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAyKSB7XHJcbiAgICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDE2KSAmIDB4MEZdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGV4O1xyXG4gIH07XHJcblxyXG4gIEtlY2Nhay5wcm90b3R5cGUuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmZpbmFsaXplKCk7XHJcblxyXG4gICAgdmFyIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnMsIG91dHB1dEJsb2NrcyA9IHRoaXMub3V0cHV0QmxvY2tzLCBcclxuICAgICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XHJcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLm91dHB1dEJpdHMgPj4gMztcclxuICAgIHZhciBidWZmZXI7XHJcbiAgICBpZiAoZXh0cmFCeXRlcykge1xyXG4gICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoKG91dHB1dEJsb2NrcyArIDEpIDw8IDIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzKTtcclxuICAgIH1cclxuICAgIHZhciBhcnJheSA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xyXG4gICAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHtcclxuICAgICAgZm9yIChpID0gMDtpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOysraSwgKytqKSB7XHJcbiAgICAgICAgYXJyYXlbal0gPSBzW2ldO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PSAwKSB7XHJcbiAgICAgICAgZihzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGV4dHJhQnl0ZXMpIHtcclxuICAgICAgYXJyYXlbaV0gPSBzW2ldO1xyXG4gICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoMCwgYnl0ZXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJ1ZmZlcjtcclxuICB9O1xyXG5cclxuICBLZWNjYWsucHJvdG90eXBlLmJ1ZmZlciA9IEtlY2Nhay5wcm90b3R5cGUuYXJyYXlCdWZmZXI7XHJcblxyXG4gIEtlY2Nhay5wcm90b3R5cGUuZGlnZXN0ID0gS2VjY2FrLnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuZmluYWxpemUoKTtcclxuXHJcbiAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsIFxyXG4gICAgICAgIGV4dHJhQnl0ZXMgPSB0aGlzLmV4dHJhQnl0ZXMsIGkgPSAwLCBqID0gMDtcclxuICAgIHZhciBhcnJheSA9IFtdLCBvZmZzZXQsIGJsb2NrO1xyXG4gICAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHtcclxuICAgICAgZm9yIChpID0gMDtpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOysraSwgKytqKSB7XHJcbiAgICAgICAgb2Zmc2V0ID0gaiA8PCAyO1xyXG4gICAgICAgIGJsb2NrID0gc1tpXTtcclxuICAgICAgICBhcnJheVtvZmZzZXRdID0gYmxvY2sgJiAweEZGO1xyXG4gICAgICAgIGFycmF5W29mZnNldCArIDFdID0gKGJsb2NrID4+IDgpICYgMHhGRjtcclxuICAgICAgICBhcnJheVtvZmZzZXQgKyAyXSA9IChibG9jayA+PiAxNikgJiAweEZGO1xyXG4gICAgICAgIGFycmF5W29mZnNldCArIDNdID0gKGJsb2NrID4+IDI0KSAmIDB4RkY7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGogJSBibG9ja0NvdW50ID09IDApIHtcclxuICAgICAgICBmKHMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoZXh0cmFCeXRlcykge1xyXG4gICAgICBvZmZzZXQgPSBqIDw8IDI7XHJcbiAgICAgIGJsb2NrID0gc1tpXTtcclxuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAwKSB7XHJcbiAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IGJsb2NrICYgMHhGRjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZXh0cmFCeXRlcyA+IDEpIHtcclxuICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IChibG9jayA+PiA4KSAmIDB4RkY7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAyKSB7XHJcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSAoYmxvY2sgPj4gMTYpICYgMHhGRjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycmF5O1xyXG4gIH07XHJcblxyXG4gIHZhciBmID0gZnVuY3Rpb24gKHMpIHtcclxuICAgIHZhciBoLCBsLCBuLCBjMCwgYzEsIGMyLCBjMywgYzQsIGM1LCBjNiwgYzcsIGM4LCBjOSwgXHJcbiAgICAgICAgYjAsIGIxLCBiMiwgYjMsIGI0LCBiNSwgYjYsIGI3LCBiOCwgYjksIGIxMCwgYjExLCBiMTIsIGIxMywgYjE0LCBiMTUsIGIxNiwgYjE3LCBcclxuICAgICAgICBiMTgsIGIxOSwgYjIwLCBiMjEsIGIyMiwgYjIzLCBiMjQsIGIyNSwgYjI2LCBiMjcsIGIyOCwgYjI5LCBiMzAsIGIzMSwgYjMyLCBiMzMsIFxyXG4gICAgICAgIGIzNCwgYjM1LCBiMzYsIGIzNywgYjM4LCBiMzksIGI0MCwgYjQxLCBiNDIsIGI0MywgYjQ0LCBiNDUsIGI0NiwgYjQ3LCBiNDgsIGI0OTtcclxuICAgIGZvciAobiA9IDA7biA8IDQ4O24gKz0gMikge1xyXG4gICAgICBjMCA9IHNbMF0gXiBzWzEwXSBeIHNbMjBdIF4gc1szMF0gXiBzWzQwXTtcclxuICAgICAgYzEgPSBzWzFdIF4gc1sxMV0gXiBzWzIxXSBeIHNbMzFdIF4gc1s0MV07XHJcbiAgICAgIGMyID0gc1syXSBeIHNbMTJdIF4gc1syMl0gXiBzWzMyXSBeIHNbNDJdO1xyXG4gICAgICBjMyA9IHNbM10gXiBzWzEzXSBeIHNbMjNdIF4gc1szM10gXiBzWzQzXTtcclxuICAgICAgYzQgPSBzWzRdIF4gc1sxNF0gXiBzWzI0XSBeIHNbMzRdIF4gc1s0NF07XHJcbiAgICAgIGM1ID0gc1s1XSBeIHNbMTVdIF4gc1syNV0gXiBzWzM1XSBeIHNbNDVdO1xyXG4gICAgICBjNiA9IHNbNl0gXiBzWzE2XSBeIHNbMjZdIF4gc1szNl0gXiBzWzQ2XTtcclxuICAgICAgYzcgPSBzWzddIF4gc1sxN10gXiBzWzI3XSBeIHNbMzddIF4gc1s0N107XHJcbiAgICAgIGM4ID0gc1s4XSBeIHNbMThdIF4gc1syOF0gXiBzWzM4XSBeIHNbNDhdO1xyXG4gICAgICBjOSA9IHNbOV0gXiBzWzE5XSBeIHNbMjldIF4gc1szOV0gXiBzWzQ5XTtcclxuXHJcbiAgICAgIGggPSBjOCBeICgoYzIgPDwgMSkgfCAoYzMgPj4+IDMxKSk7XHJcbiAgICAgIGwgPSBjOSBeICgoYzMgPDwgMSkgfCAoYzIgPj4+IDMxKSk7XHJcbiAgICAgIHNbMF0gXj0gaDtcclxuICAgICAgc1sxXSBePSBsO1xyXG4gICAgICBzWzEwXSBePSBoO1xyXG4gICAgICBzWzExXSBePSBsO1xyXG4gICAgICBzWzIwXSBePSBoO1xyXG4gICAgICBzWzIxXSBePSBsO1xyXG4gICAgICBzWzMwXSBePSBoO1xyXG4gICAgICBzWzMxXSBePSBsO1xyXG4gICAgICBzWzQwXSBePSBoO1xyXG4gICAgICBzWzQxXSBePSBsO1xyXG4gICAgICBoID0gYzAgXiAoKGM0IDw8IDEpIHwgKGM1ID4+PiAzMSkpO1xyXG4gICAgICBsID0gYzEgXiAoKGM1IDw8IDEpIHwgKGM0ID4+PiAzMSkpO1xyXG4gICAgICBzWzJdIF49IGg7XHJcbiAgICAgIHNbM10gXj0gbDtcclxuICAgICAgc1sxMl0gXj0gaDtcclxuICAgICAgc1sxM10gXj0gbDtcclxuICAgICAgc1syMl0gXj0gaDtcclxuICAgICAgc1syM10gXj0gbDtcclxuICAgICAgc1szMl0gXj0gaDtcclxuICAgICAgc1szM10gXj0gbDtcclxuICAgICAgc1s0Ml0gXj0gaDtcclxuICAgICAgc1s0M10gXj0gbDtcclxuICAgICAgaCA9IGMyIF4gKChjNiA8PCAxKSB8IChjNyA+Pj4gMzEpKTtcclxuICAgICAgbCA9IGMzIF4gKChjNyA8PCAxKSB8IChjNiA+Pj4gMzEpKTtcclxuICAgICAgc1s0XSBePSBoO1xyXG4gICAgICBzWzVdIF49IGw7XHJcbiAgICAgIHNbMTRdIF49IGg7XHJcbiAgICAgIHNbMTVdIF49IGw7XHJcbiAgICAgIHNbMjRdIF49IGg7XHJcbiAgICAgIHNbMjVdIF49IGw7XHJcbiAgICAgIHNbMzRdIF49IGg7XHJcbiAgICAgIHNbMzVdIF49IGw7XHJcbiAgICAgIHNbNDRdIF49IGg7XHJcbiAgICAgIHNbNDVdIF49IGw7XHJcbiAgICAgIGggPSBjNCBeICgoYzggPDwgMSkgfCAoYzkgPj4+IDMxKSk7XHJcbiAgICAgIGwgPSBjNSBeICgoYzkgPDwgMSkgfCAoYzggPj4+IDMxKSk7XHJcbiAgICAgIHNbNl0gXj0gaDtcclxuICAgICAgc1s3XSBePSBsO1xyXG4gICAgICBzWzE2XSBePSBoO1xyXG4gICAgICBzWzE3XSBePSBsO1xyXG4gICAgICBzWzI2XSBePSBoO1xyXG4gICAgICBzWzI3XSBePSBsO1xyXG4gICAgICBzWzM2XSBePSBoO1xyXG4gICAgICBzWzM3XSBePSBsO1xyXG4gICAgICBzWzQ2XSBePSBoO1xyXG4gICAgICBzWzQ3XSBePSBsO1xyXG4gICAgICBoID0gYzYgXiAoKGMwIDw8IDEpIHwgKGMxID4+PiAzMSkpO1xyXG4gICAgICBsID0gYzcgXiAoKGMxIDw8IDEpIHwgKGMwID4+PiAzMSkpO1xyXG4gICAgICBzWzhdIF49IGg7XHJcbiAgICAgIHNbOV0gXj0gbDtcclxuICAgICAgc1sxOF0gXj0gaDtcclxuICAgICAgc1sxOV0gXj0gbDtcclxuICAgICAgc1syOF0gXj0gaDtcclxuICAgICAgc1syOV0gXj0gbDtcclxuICAgICAgc1szOF0gXj0gaDtcclxuICAgICAgc1szOV0gXj0gbDtcclxuICAgICAgc1s0OF0gXj0gaDtcclxuICAgICAgc1s0OV0gXj0gbDtcclxuXHJcbiAgICAgIGIwID0gc1swXTtcclxuICAgICAgYjEgPSBzWzFdO1xyXG4gICAgICBiMzIgPSAoc1sxMV0gPDwgNCkgfCAoc1sxMF0gPj4+IDI4KTtcclxuICAgICAgYjMzID0gKHNbMTBdIDw8IDQpIHwgKHNbMTFdID4+PiAyOCk7XHJcbiAgICAgIGIxNCA9IChzWzIwXSA8PCAzKSB8IChzWzIxXSA+Pj4gMjkpO1xyXG4gICAgICBiMTUgPSAoc1syMV0gPDwgMykgfCAoc1syMF0gPj4+IDI5KTtcclxuICAgICAgYjQ2ID0gKHNbMzFdIDw8IDkpIHwgKHNbMzBdID4+PiAyMyk7XHJcbiAgICAgIGI0NyA9IChzWzMwXSA8PCA5KSB8IChzWzMxXSA+Pj4gMjMpO1xyXG4gICAgICBiMjggPSAoc1s0MF0gPDwgMTgpIHwgKHNbNDFdID4+PiAxNCk7XHJcbiAgICAgIGIyOSA9IChzWzQxXSA8PCAxOCkgfCAoc1s0MF0gPj4+IDE0KTtcclxuICAgICAgYjIwID0gKHNbMl0gPDwgMSkgfCAoc1szXSA+Pj4gMzEpO1xyXG4gICAgICBiMjEgPSAoc1szXSA8PCAxKSB8IChzWzJdID4+PiAzMSk7XHJcbiAgICAgIGIyID0gKHNbMTNdIDw8IDEyKSB8IChzWzEyXSA+Pj4gMjApO1xyXG4gICAgICBiMyA9IChzWzEyXSA8PCAxMikgfCAoc1sxM10gPj4+IDIwKTtcclxuICAgICAgYjM0ID0gKHNbMjJdIDw8IDEwKSB8IChzWzIzXSA+Pj4gMjIpO1xyXG4gICAgICBiMzUgPSAoc1syM10gPDwgMTApIHwgKHNbMjJdID4+PiAyMik7XHJcbiAgICAgIGIxNiA9IChzWzMzXSA8PCAxMykgfCAoc1szMl0gPj4+IDE5KTtcclxuICAgICAgYjE3ID0gKHNbMzJdIDw8IDEzKSB8IChzWzMzXSA+Pj4gMTkpO1xyXG4gICAgICBiNDggPSAoc1s0Ml0gPDwgMikgfCAoc1s0M10gPj4+IDMwKTtcclxuICAgICAgYjQ5ID0gKHNbNDNdIDw8IDIpIHwgKHNbNDJdID4+PiAzMCk7XHJcbiAgICAgIGI0MCA9IChzWzVdIDw8IDMwKSB8IChzWzRdID4+PiAyKTtcclxuICAgICAgYjQxID0gKHNbNF0gPDwgMzApIHwgKHNbNV0gPj4+IDIpO1xyXG4gICAgICBiMjIgPSAoc1sxNF0gPDwgNikgfCAoc1sxNV0gPj4+IDI2KTtcclxuICAgICAgYjIzID0gKHNbMTVdIDw8IDYpIHwgKHNbMTRdID4+PiAyNik7XHJcbiAgICAgIGI0ID0gKHNbMjVdIDw8IDExKSB8IChzWzI0XSA+Pj4gMjEpO1xyXG4gICAgICBiNSA9IChzWzI0XSA8PCAxMSkgfCAoc1syNV0gPj4+IDIxKTtcclxuICAgICAgYjM2ID0gKHNbMzRdIDw8IDE1KSB8IChzWzM1XSA+Pj4gMTcpO1xyXG4gICAgICBiMzcgPSAoc1szNV0gPDwgMTUpIHwgKHNbMzRdID4+PiAxNyk7XHJcbiAgICAgIGIxOCA9IChzWzQ1XSA8PCAyOSkgfCAoc1s0NF0gPj4+IDMpO1xyXG4gICAgICBiMTkgPSAoc1s0NF0gPDwgMjkpIHwgKHNbNDVdID4+PiAzKTtcclxuICAgICAgYjEwID0gKHNbNl0gPDwgMjgpIHwgKHNbN10gPj4+IDQpO1xyXG4gICAgICBiMTEgPSAoc1s3XSA8PCAyOCkgfCAoc1s2XSA+Pj4gNCk7XHJcbiAgICAgIGI0MiA9IChzWzE3XSA8PCAyMykgfCAoc1sxNl0gPj4+IDkpO1xyXG4gICAgICBiNDMgPSAoc1sxNl0gPDwgMjMpIHwgKHNbMTddID4+PiA5KTtcclxuICAgICAgYjI0ID0gKHNbMjZdIDw8IDI1KSB8IChzWzI3XSA+Pj4gNyk7XHJcbiAgICAgIGIyNSA9IChzWzI3XSA8PCAyNSkgfCAoc1syNl0gPj4+IDcpO1xyXG4gICAgICBiNiA9IChzWzM2XSA8PCAyMSkgfCAoc1szN10gPj4+IDExKTtcclxuICAgICAgYjcgPSAoc1szN10gPDwgMjEpIHwgKHNbMzZdID4+PiAxMSk7XHJcbiAgICAgIGIzOCA9IChzWzQ3XSA8PCAyNCkgfCAoc1s0Nl0gPj4+IDgpO1xyXG4gICAgICBiMzkgPSAoc1s0Nl0gPDwgMjQpIHwgKHNbNDddID4+PiA4KTtcclxuICAgICAgYjMwID0gKHNbOF0gPDwgMjcpIHwgKHNbOV0gPj4+IDUpO1xyXG4gICAgICBiMzEgPSAoc1s5XSA8PCAyNykgfCAoc1s4XSA+Pj4gNSk7XHJcbiAgICAgIGIxMiA9IChzWzE4XSA8PCAyMCkgfCAoc1sxOV0gPj4+IDEyKTtcclxuICAgICAgYjEzID0gKHNbMTldIDw8IDIwKSB8IChzWzE4XSA+Pj4gMTIpO1xyXG4gICAgICBiNDQgPSAoc1syOV0gPDwgNykgfCAoc1syOF0gPj4+IDI1KTtcclxuICAgICAgYjQ1ID0gKHNbMjhdIDw8IDcpIHwgKHNbMjldID4+PiAyNSk7XHJcbiAgICAgIGIyNiA9IChzWzM4XSA8PCA4KSB8IChzWzM5XSA+Pj4gMjQpO1xyXG4gICAgICBiMjcgPSAoc1szOV0gPDwgOCkgfCAoc1szOF0gPj4+IDI0KTtcclxuICAgICAgYjggPSAoc1s0OF0gPDwgMTQpIHwgKHNbNDldID4+PiAxOCk7XHJcbiAgICAgIGI5ID0gKHNbNDldIDw8IDE0KSB8IChzWzQ4XSA+Pj4gMTgpO1xyXG5cclxuICAgICAgc1swXSA9IGIwIF4gKH5iMiAmIGI0KTtcclxuICAgICAgc1sxXSA9IGIxIF4gKH5iMyAmIGI1KTtcclxuICAgICAgc1sxMF0gPSBiMTAgXiAofmIxMiAmIGIxNCk7XHJcbiAgICAgIHNbMTFdID0gYjExIF4gKH5iMTMgJiBiMTUpO1xyXG4gICAgICBzWzIwXSA9IGIyMCBeICh+YjIyICYgYjI0KTtcclxuICAgICAgc1syMV0gPSBiMjEgXiAofmIyMyAmIGIyNSk7XHJcbiAgICAgIHNbMzBdID0gYjMwIF4gKH5iMzIgJiBiMzQpO1xyXG4gICAgICBzWzMxXSA9IGIzMSBeICh+YjMzICYgYjM1KTtcclxuICAgICAgc1s0MF0gPSBiNDAgXiAofmI0MiAmIGI0NCk7XHJcbiAgICAgIHNbNDFdID0gYjQxIF4gKH5iNDMgJiBiNDUpO1xyXG4gICAgICBzWzJdID0gYjIgXiAofmI0ICYgYjYpO1xyXG4gICAgICBzWzNdID0gYjMgXiAofmI1ICYgYjcpO1xyXG4gICAgICBzWzEyXSA9IGIxMiBeICh+YjE0ICYgYjE2KTtcclxuICAgICAgc1sxM10gPSBiMTMgXiAofmIxNSAmIGIxNyk7XHJcbiAgICAgIHNbMjJdID0gYjIyIF4gKH5iMjQgJiBiMjYpO1xyXG4gICAgICBzWzIzXSA9IGIyMyBeICh+YjI1ICYgYjI3KTtcclxuICAgICAgc1szMl0gPSBiMzIgXiAofmIzNCAmIGIzNik7XHJcbiAgICAgIHNbMzNdID0gYjMzIF4gKH5iMzUgJiBiMzcpO1xyXG4gICAgICBzWzQyXSA9IGI0MiBeICh+YjQ0ICYgYjQ2KTtcclxuICAgICAgc1s0M10gPSBiNDMgXiAofmI0NSAmIGI0Nyk7XHJcbiAgICAgIHNbNF0gPSBiNCBeICh+YjYgJiBiOCk7XHJcbiAgICAgIHNbNV0gPSBiNSBeICh+YjcgJiBiOSk7XHJcbiAgICAgIHNbMTRdID0gYjE0IF4gKH5iMTYgJiBiMTgpO1xyXG4gICAgICBzWzE1XSA9IGIxNSBeICh+YjE3ICYgYjE5KTtcclxuICAgICAgc1syNF0gPSBiMjQgXiAofmIyNiAmIGIyOCk7XHJcbiAgICAgIHNbMjVdID0gYjI1IF4gKH5iMjcgJiBiMjkpO1xyXG4gICAgICBzWzM0XSA9IGIzNCBeICh+YjM2ICYgYjM4KTtcclxuICAgICAgc1szNV0gPSBiMzUgXiAofmIzNyAmIGIzOSk7XHJcbiAgICAgIHNbNDRdID0gYjQ0IF4gKH5iNDYgJiBiNDgpO1xyXG4gICAgICBzWzQ1XSA9IGI0NSBeICh+YjQ3ICYgYjQ5KTtcclxuICAgICAgc1s2XSA9IGI2IF4gKH5iOCAmIGIwKTtcclxuICAgICAgc1s3XSA9IGI3IF4gKH5iOSAmIGIxKTtcclxuICAgICAgc1sxNl0gPSBiMTYgXiAofmIxOCAmIGIxMCk7XHJcbiAgICAgIHNbMTddID0gYjE3IF4gKH5iMTkgJiBiMTEpO1xyXG4gICAgICBzWzI2XSA9IGIyNiBeICh+YjI4ICYgYjIwKTtcclxuICAgICAgc1syN10gPSBiMjcgXiAofmIyOSAmIGIyMSk7XHJcbiAgICAgIHNbMzZdID0gYjM2IF4gKH5iMzggJiBiMzApO1xyXG4gICAgICBzWzM3XSA9IGIzNyBeICh+YjM5ICYgYjMxKTtcclxuICAgICAgc1s0Nl0gPSBiNDYgXiAofmI0OCAmIGI0MCk7XHJcbiAgICAgIHNbNDddID0gYjQ3IF4gKH5iNDkgJiBiNDEpO1xyXG4gICAgICBzWzhdID0gYjggXiAofmIwICYgYjIpO1xyXG4gICAgICBzWzldID0gYjkgXiAofmIxICYgYjMpO1xyXG4gICAgICBzWzE4XSA9IGIxOCBeICh+YjEwICYgYjEyKTtcclxuICAgICAgc1sxOV0gPSBiMTkgXiAofmIxMSAmIGIxMyk7XHJcbiAgICAgIHNbMjhdID0gYjI4IF4gKH5iMjAgJiBiMjIpO1xyXG4gICAgICBzWzI5XSA9IGIyOSBeICh+YjIxICYgYjIzKTtcclxuICAgICAgc1szOF0gPSBiMzggXiAofmIzMCAmIGIzMik7XHJcbiAgICAgIHNbMzldID0gYjM5IF4gKH5iMzEgJiBiMzMpO1xyXG4gICAgICBzWzQ4XSA9IGI0OCBeICh+YjQwICYgYjQyKTtcclxuICAgICAgc1s0OV0gPSBiNDkgXiAofmI0MSAmIGI0Myk7XHJcblxyXG4gICAgICBzWzBdIF49IFJDW25dO1xyXG4gICAgICBzWzFdIF49IFJDW24gKyAxXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChDT01NT05fSlMpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gbWV0aG9kcztcclxuICB9IGVsc2UgaWYgKHJvb3QpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XHJcbiAgICAgIHJvb3Rba2V5XSA9IG1ldGhvZHNba2V5XTtcclxuICAgIH1cclxuICB9XHJcbn0odGhpcykpO1xyXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0hleFByZWZpeGVkID0gcmVxdWlyZSgnaXMtaGV4LXByZWZpeGVkJyk7XG52YXIgc3RyaXBIZXhQcmVmaXggPSByZXF1aXJlKCdzdHJpcC1oZXgtcHJlZml4Jyk7XG5cbi8qKlxuICogUGFkcyBhIGBTdHJpbmdgIHRvIGhhdmUgYW4gZXZlbiBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gcGFkVG9FdmVuKHZhbHVlKSB7XG4gIHZhciBhID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAodHlwZW9mIGEgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gd2hpbGUgcGFkZGluZyB0byBldmVuLCB2YWx1ZSBtdXN0IGJlIHN0cmluZywgaXMgY3VycmVudGx5ICcgKyB0eXBlb2YgYSArICcsIHdoaWxlIHBhZFRvRXZlbi4nKTtcbiAgfVxuXG4gIGlmIChhLmxlbmd0aCAlIDIpIHtcbiAgICBhID0gJzAnICsgYTtcbiAgfVxuXG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgYE51bWJlcmAgaW50byBhIGhleCBgU3RyaW5nYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaW50VG9IZXgoaSkge1xuICB2YXIgaGV4ID0gaS50b1N0cmluZygxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICByZXR1cm4gJzB4JyArIHBhZFRvRXZlbihoZXgpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIGBOdW1iZXJgIHRvIGEgYEJ1ZmZlcmBcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGludFRvQnVmZmVyKGkpIHtcbiAgdmFyIGhleCA9IGludFRvSGV4KGkpO1xuXG4gIHJldHVybiBCdWZmZXIuZnJvbShoZXguc2xpY2UoMiksICdoZXgnKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGJpbmFyeSBzaXplIG9mIGEgc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldEJpbmFyeVNpemUoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIHdoaWxlIGdldHRpbmcgYmluYXJ5IHNpemUsIG1ldGhvZCBnZXRCaW5hcnlTaXplIHJlcXVpcmVzIGlucHV0IFxcJ3N0clxcJyB0byBiZSB0eXBlIFN0cmluZywgZ290IFxcJycgKyB0eXBlb2Ygc3RyICsgJ1xcJy4nKTtcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuYnl0ZUxlbmd0aChzdHIsICd1dGY4Jyk7XG59XG5cbi8qKlxuICogUmV0dXJucyBUUlVFIGlmIHRoZSBmaXJzdCBzcGVjaWZpZWQgYXJyYXkgY29udGFpbnMgYWxsIGVsZW1lbnRzXG4gKiBmcm9tIHRoZSBzZWNvbmQgb25lLiBGQUxTRSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHthcnJheX0gc3VwZXJzZXRcbiAqIEBwYXJhbSB7YXJyYXl9IHN1YnNldFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBhcnJheUNvbnRhaW5zQXJyYXkoc3VwZXJzZXQsIHN1YnNldCwgc29tZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzdXBlcnNldCkgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgYXJyYXlDb250YWluc0FycmF5IHJlcXVpcmVzIGlucHV0IFxcJ3N1cGVyc2V0XFwnIHRvIGJlIGFuIGFycmF5IGdvdCB0eXBlIFxcJycgKyB0eXBlb2Ygc3VwZXJzZXQgKyAnXFwnJyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3Vic2V0KSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBhcnJheUNvbnRhaW5zQXJyYXkgcmVxdWlyZXMgaW5wdXQgXFwnc3Vic2V0XFwnIHRvIGJlIGFuIGFycmF5IGdvdCB0eXBlIFxcJycgKyB0eXBlb2Ygc3Vic2V0ICsgJ1xcJycpO1xuICB9XG5cbiAgcmV0dXJuIHN1YnNldFtCb29sZWFuKHNvbWUpICYmICdzb21lJyB8fCAnZXZlcnknXShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gc3VwZXJzZXQuaW5kZXhPZih2YWx1ZSkgPj0gMDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgdXRmOCBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b1V0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvVXRmOChoZXgpIHtcbiAgdmFyIGJ1ZmZlclZhbHVlID0gbmV3IEJ1ZmZlcihwYWRUb0V2ZW4oc3RyaXBIZXhQcmVmaXgoaGV4KS5yZXBsYWNlKC9eMCt8MCskL2csICcnKSksICdoZXgnKTtcblxuICByZXR1cm4gYnVmZmVyVmFsdWUudG9TdHJpbmcoJ3V0ZjgnKTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBhc2NpaSBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b0FzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b0FzY2lpKGhleCkge1xuICB2YXIgc3RyID0gJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdmFyIGkgPSAwLFxuICAgICAgbCA9IGhleC5sZW5ndGg7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAoaGV4LnN1YnN0cmluZygwLCAyKSA9PT0gJzB4Jykge1xuICAgIGkgPSAyO1xuICB9XG5cbiAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICB2YXIgY29kZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgdXRmOCBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tVXRmOChzdHJpbmdWYWx1ZSkge1xuICB2YXIgc3RyID0gbmV3IEJ1ZmZlcihzdHJpbmdWYWx1ZSwgJ3V0ZjgnKTtcblxuICByZXR1cm4gJzB4JyArIHBhZFRvRXZlbihzdHIudG9TdHJpbmcoJ2hleCcpKS5yZXBsYWNlKC9eMCt8MCskL2csICcnKTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiBhc2NpaSBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZnJvbUFzY2lpKHN0cmluZ1ZhbHVlKSB7XG4gIHZhciBoZXggPSAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciBjb2RlID0gc3RyaW5nVmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICB2YXIgbiA9IGNvZGUudG9TdHJpbmcoMTYpO1xuICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyAnMCcgKyBuIDogbjtcbiAgfVxuXG4gIHJldHVybiAnMHgnICsgaGV4O1xufVxuXG4vKipcbiAqIGdldEtleXMoW3thOiAxLCBiOiAyfSwge2E6IDMsIGI6IDR9XSwgJ2EnKSA9PiBbMSwgM11cbiAqXG4gKiBAbWV0aG9kIGdldEtleXMgZ2V0IHNwZWNpZmljIGtleSBmcm9tIGlubmVyIG9iamVjdCBhcnJheSBvZiBvYmplY3RzXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFsbG93RW1wdHlcbiAqIEByZXR1cm5zIHtBcnJheX0gb3V0cHV0IGp1c3QgYSBzaW1wbGUgYXJyYXkgb2Ygb3V0cHV0IGtleXNcbiAqL1xuZnVuY3Rpb24gZ2V0S2V5cyhwYXJhbXMsIGtleSwgYWxsb3dFbXB0eSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBnZXRLZXlzIGV4cGVjdGluZyB0eXBlIEFycmF5IGFzIFxcJ3BhcmFtc1xcJyBpbnB1dCwgZ290IFxcJycgKyB0eXBlb2YgcGFyYW1zICsgJ1xcJycpO1xuICB9XG4gIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBnZXRLZXlzIGV4cGVjdGluZyB0eXBlIFN0cmluZyBmb3IgaW5wdXQgXFwna2V5XFwnIGdvdCBcXCcnICsgdHlwZW9mIGtleSArICdcXCcuJyk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgdmFsdWUgPSBwYXJhbXNbaV1ba2V5XTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGlmIChhbGxvd0VtcHR5ICYmICF2YWx1ZSkge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhYmknKTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBJcyB0aGUgc3RyaW5nIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAbWV0aG9kIGNoZWNrIGlmIHN0cmluZyBpcyBoZXggc3RyaW5nIG9mIHNwZWNpZmljIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gb3V0cHV0IHRoZSBzdHJpbmcgaXMgYSBoZXggc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobGVuZ3RoICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFycmF5Q29udGFpbnNBcnJheTogYXJyYXlDb250YWluc0FycmF5LFxuICBpbnRUb0J1ZmZlcjogaW50VG9CdWZmZXIsXG4gIGdldEJpbmFyeVNpemU6IGdldEJpbmFyeVNpemUsXG4gIGlzSGV4UHJlZml4ZWQ6IGlzSGV4UHJlZml4ZWQsXG4gIHN0cmlwSGV4UHJlZml4OiBzdHJpcEhleFByZWZpeCxcbiAgcGFkVG9FdmVuOiBwYWRUb0V2ZW4sXG4gIGludFRvSGV4OiBpbnRUb0hleCxcbiAgZnJvbUFzY2lpOiBmcm9tQXNjaWksXG4gIGZyb21VdGY4OiBmcm9tVXRmOCxcbiAgdG9Bc2NpaTogdG9Bc2NpaSxcbiAgdG9VdGY4OiB0b1V0ZjgsXG4gIGdldEtleXM6IGdldEtleXMsXG4gIGlzSGV4U3RyaW5nOiBpc0hleFN0cmluZ1xufTsiLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaW5kZXguanMnKTtcbnZhciB1aW50MjU2Q29kZXIgPSB1dGlscy51aW50MjU2Q29kZXI7XG52YXIgY29kZXJCb29sZWFuID0gdXRpbHMuY29kZXJCb29sZWFuO1xudmFyIGNvZGVyRml4ZWRCeXRlcyA9IHV0aWxzLmNvZGVyRml4ZWRCeXRlcztcbnZhciBjb2RlckFkZHJlc3MgPSB1dGlscy5jb2RlckFkZHJlc3M7XG52YXIgY29kZXJEeW5hbWljQnl0ZXMgPSB1dGlscy5jb2RlckR5bmFtaWNCeXRlcztcbnZhciBjb2RlclN0cmluZyA9IHV0aWxzLmNvZGVyU3RyaW5nO1xudmFyIGNvZGVyQXJyYXkgPSB1dGlscy5jb2RlckFycmF5O1xudmFyIHBhcmFtVHlwZVBhcnQgPSB1dGlscy5wYXJhbVR5cGVQYXJ0O1xudmFyIGdldFBhcmFtQ29kZXIgPSB1dGlscy5nZXRQYXJhbUNvZGVyO1xuXG5mdW5jdGlvbiBSZXN1bHQoKSB7fVxuXG5mdW5jdGlvbiBlbmNvZGVQYXJhbXModHlwZXMsIHZhbHVlcykge1xuICBpZiAodHlwZXMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtYWJpXSB3aGlsZSBlbmNvZGluZyBwYXJhbXMsIHR5cGVzL3ZhbHVlcyBtaXNtYXRjaCwgWW91ciBjb250cmFjdCByZXF1aXJlcyAnICsgdHlwZXMubGVuZ3RoICsgJyB0eXBlcyAoYXJndW1lbnRzKSwgYW5kIHlvdSBwYXNzZWQgaW4gJyArIHZhbHVlcy5sZW5ndGgpO1xuICB9XG5cbiAgdmFyIHBhcnRzID0gW107XG5cbiAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSwgaW5kZXgpIHtcbiAgICB2YXIgY29kZXIgPSBnZXRQYXJhbUNvZGVyKHR5cGUpO1xuICAgIHBhcnRzLnB1c2goeyBkeW5hbWljOiBjb2Rlci5keW5hbWljLCB2YWx1ZTogY29kZXIuZW5jb2RlKHZhbHVlc1tpbmRleF0pIH0pO1xuICB9KTtcblxuICBmdW5jdGlvbiBhbGlnblNpemUoc2l6ZSkge1xuICAgIHJldHVybiBwYXJzZUludCgzMiAqIE1hdGguY2VpbChzaXplIC8gMzIpKTtcbiAgfVxuXG4gIHZhciBzdGF0aWNTaXplID0gMCxcbiAgICAgIGR5bmFtaWNTaXplID0gMDtcbiAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuICAgIGlmIChwYXJ0LmR5bmFtaWMpIHtcbiAgICAgIHN0YXRpY1NpemUgKz0gMzI7XG4gICAgICBkeW5hbWljU2l6ZSArPSBhbGlnblNpemUocGFydC52YWx1ZS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0aWNTaXplICs9IGFsaWduU2l6ZShwYXJ0LnZhbHVlLmxlbmd0aCk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgb2Zmc2V0ID0gMCxcbiAgICAgIGR5bmFtaWNPZmZzZXQgPSBzdGF0aWNTaXplO1xuICB2YXIgZGF0YSA9IG5ldyBCdWZmZXIoc3RhdGljU2l6ZSArIGR5bmFtaWNTaXplKTtcblxuICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0LCBpbmRleCkge1xuICAgIGlmIChwYXJ0LmR5bmFtaWMpIHtcbiAgICAgIHVpbnQyNTZDb2Rlci5lbmNvZGUoZHluYW1pY09mZnNldCkuY29weShkYXRhLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IDMyO1xuXG4gICAgICBwYXJ0LnZhbHVlLmNvcHkoZGF0YSwgZHluYW1pY09mZnNldCk7XG4gICAgICBkeW5hbWljT2Zmc2V0ICs9IGFsaWduU2l6ZShwYXJ0LnZhbHVlLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnQudmFsdWUuY29weShkYXRhLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGFsaWduU2l6ZShwYXJ0LnZhbHVlLmxlbmd0aCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gJzB4JyArIGRhdGEudG9TdHJpbmcoJ2hleCcpO1xufVxuXG4vLyBkZWNvZGUgYnl0ZWNvZGUgZGF0YSBmcm9tIG91dHB1dCBuYW1lcyBhbmQgdHlwZXNcbmZ1bmN0aW9uIGRlY29kZVBhcmFtcyhuYW1lcywgdHlwZXMsIGRhdGEpIHtcbiAgdmFyIHVzZU51bWJlcmVkUGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuXG4gIC8vIE5hbWVzIGlzIG9wdGlvbmFsLCBzbyBzaGlmdCBvdmVyIGFsbCB0aGUgcGFyYW1ldGVycyBpZiBub3QgcHJvdmlkZWRcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgZGF0YSA9IHR5cGVzO1xuICAgIHR5cGVzID0gbmFtZXM7XG4gICAgbmFtZXMgPSBbXTtcbiAgfVxuXG4gIGRhdGEgPSB1dGlscy5oZXhPckJ1ZmZlcihkYXRhKTtcbiAgdmFyIHZhbHVlcyA9IG5ldyBSZXN1bHQoKTtcblxuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSwgaW5kZXgpIHtcbiAgICB2YXIgY29kZXIgPSBnZXRQYXJhbUNvZGVyKHR5cGUpO1xuXG4gICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgIHZhciBkeW5hbWljT2Zmc2V0ID0gdWludDI1NkNvZGVyLmRlY29kZShkYXRhLCBvZmZzZXQpO1xuICAgICAgdmFyIHJlc3VsdCA9IGNvZGVyLmRlY29kZShkYXRhLCBkeW5hbWljT2Zmc2V0LnZhbHVlLnRvTnVtYmVyKCkpO1xuICAgICAgb2Zmc2V0ICs9IGR5bmFtaWNPZmZzZXQuY29uc3VtZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb2Rlci5kZWNvZGUoZGF0YSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSByZXN1bHQuY29uc3VtZWQ7XG4gICAgfVxuXG4gICAgaWYgKHVzZU51bWJlcmVkUGFyYW1zKSB7XG4gICAgICB2YWx1ZXNbaW5kZXhdID0gcmVzdWx0LnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChuYW1lc1tpbmRleF0pIHtcbiAgICAgIHZhbHVlc1tuYW1lc1tpbmRleF1dID0gcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB2YWx1ZXM7XG59XG5cbi8vIGNyZWF0ZSBhbiBlbmNvZGVkIG1ldGhvZCBzaWduYXR1cmUgZnJvbSBhbiBBQkkgb2JqZWN0XG5mdW5jdGlvbiBlbmNvZGVTaWduYXR1cmUobWV0aG9kKSB7XG4gIHZhciBzaWduYXR1cmUgPSBtZXRob2QubmFtZSArICcoJyArIHV0aWxzLmdldEtleXMobWV0aG9kLmlucHV0cywgJ3R5cGUnKS5qb2luKCcsJykgKyAnKSc7XG4gIHZhciBzaWduYXR1cmVFbmNvZGVkID0gJzB4JyArIG5ldyBCdWZmZXIodXRpbHMua2VjY2FrMjU2KHNpZ25hdHVyZSksICdoZXgnKS5zbGljZSgwLCA0KS50b1N0cmluZygnaGV4Jyk7XG5cbiAgcmV0dXJuIHNpZ25hdHVyZUVuY29kZWQ7XG59XG5cbi8vIGVuY29kZSBtZXRob2QgQUJJIG9iamVjdCB3aXRoIHZhbHVlcyBpbiBhbiBhcnJheSwgb3V0cHV0IGJ5dGVjb2RlXG5mdW5jdGlvbiBlbmNvZGVNZXRob2QobWV0aG9kLCB2YWx1ZXMpIHtcbiAgdmFyIHBhcmFtc0VuY29kZWQgPSBlbmNvZGVQYXJhbXModXRpbHMuZ2V0S2V5cyhtZXRob2QuaW5wdXRzLCAndHlwZScpLCB2YWx1ZXMpLnN1YnN0cmluZygyKTtcblxuICByZXR1cm4gJycgKyBlbmNvZGVTaWduYXR1cmUobWV0aG9kKSArIHBhcmFtc0VuY29kZWQ7XG59XG5cbi8vIGRlY29kZSBtZXRob2QgZGF0YSBieXRlY29kZSwgZnJvbSBtZXRob2QgQUJJIG9iamVjdFxuZnVuY3Rpb24gZGVjb2RlTWV0aG9kKG1ldGhvZCwgZGF0YSkge1xuICB2YXIgb3V0cHV0TmFtZXMgPSB1dGlscy5nZXRLZXlzKG1ldGhvZC5vdXRwdXRzLCAnbmFtZScsIHRydWUpO1xuICB2YXIgb3V0cHV0VHlwZXMgPSB1dGlscy5nZXRLZXlzKG1ldGhvZC5vdXRwdXRzLCAndHlwZScpO1xuXG4gIHJldHVybiBkZWNvZGVQYXJhbXMob3V0cHV0TmFtZXMsIG91dHB1dFR5cGVzLCB1dGlscy5oZXhPckJ1ZmZlcihkYXRhKSk7XG59XG5cbi8vIGRlY29kZSBtZXRob2QgZGF0YSBieXRlY29kZSwgZnJvbSBtZXRob2QgQUJJIG9iamVjdFxuZnVuY3Rpb24gZW5jb2RlRXZlbnQoZXZlbnRPYmplY3QsIHZhbHVlcykge1xuICByZXR1cm4gZW5jb2RlTWV0aG9kKGV2ZW50T2JqZWN0LCB2YWx1ZXMpO1xufVxuXG5mdW5jdGlvbiBldmVudFNpZ25hdHVyZShldmVudE9iamVjdCkge1xuICB2YXIgc2lnbmF0dXJlID0gZXZlbnRPYmplY3QubmFtZSArICcoJyArIHV0aWxzLmdldEtleXMoZXZlbnRPYmplY3QuaW5wdXRzLCAndHlwZScpLmpvaW4oJywnKSArICcpJztcblxuICByZXR1cm4gJzB4JyArIHV0aWxzLmtlY2NhazI1NihzaWduYXR1cmUpO1xufVxuXG4vLyBkZWNvZGUgbWV0aG9kIGRhdGEgYnl0ZWNvZGUsIGZyb20gbWV0aG9kIEFCSSBvYmplY3RcbmZ1bmN0aW9uIGRlY29kZUV2ZW50KGV2ZW50T2JqZWN0LCBkYXRhLCB0b3BpY3MpIHtcbiAgdmFyIHVzZU51bWJlcmVkUGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuXG4gIHZhciBub25JbmRleGVkID0gZXZlbnRPYmplY3QuaW5wdXRzLmZpbHRlcihmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gIWlucHV0LmluZGV4ZWQ7XG4gIH0pO1xuICB2YXIgbm9uSW5kZXhlZE5hbWVzID0gdXRpbHMuZ2V0S2V5cyhub25JbmRleGVkLCAnbmFtZScsIHRydWUpO1xuICB2YXIgbm9uSW5kZXhlZFR5cGVzID0gdXRpbHMuZ2V0S2V5cyhub25JbmRleGVkLCAndHlwZScpO1xuICB2YXIgZXZlbnQgPSBkZWNvZGVQYXJhbXMobm9uSW5kZXhlZE5hbWVzLCBub25JbmRleGVkVHlwZXMsIHV0aWxzLmhleE9yQnVmZmVyKGRhdGEpLCB1c2VOdW1iZXJlZFBhcmFtcyk7XG4gIHZhciB0b3BpY09mZnNldCA9IGV2ZW50T2JqZWN0LmFub255bW91cyA/IDAgOiAxO1xuXG4gIGV2ZW50T2JqZWN0LmlucHV0cy5maWx0ZXIoZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LmluZGV4ZWQ7XG4gIH0pLm1hcChmdW5jdGlvbiAoaW5wdXQsIGkpIHtcbiAgICB2YXIgdG9waWMgPSBuZXcgQnVmZmVyKHRvcGljc1tpICsgdG9waWNPZmZzZXRdLnNsaWNlKDIpLCAnaGV4Jyk7XG4gICAgdmFyIGNvZGVyID0gZ2V0UGFyYW1Db2RlcihpbnB1dC50eXBlKTtcbiAgICBldmVudFtpbnB1dC5uYW1lXSA9IGNvZGVyLmRlY29kZSh0b3BpYywgMCkudmFsdWU7XG4gIH0pO1xuXG4gIGV2ZW50Ll9ldmVudE5hbWUgPSBldmVudE9iamVjdC5uYW1lO1xuXG4gIHJldHVybiBldmVudDtcbn1cblxuLy8gRGVjb2RlIGEgc3BlY2lmaWMgbG9nIGl0ZW0gd2l0aCBhIHNwZWNpZmljIGV2ZW50IGFiaVxuZnVuY3Rpb24gZGVjb2RlTG9nSXRlbShldmVudE9iamVjdCwgbG9nKSB7XG4gIHZhciB1c2VOdW1iZXJlZFBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcblxuICBpZiAoZXZlbnRPYmplY3QgJiYgbG9nLnRvcGljc1swXSA9PT0gZXZlbnRTaWduYXR1cmUoZXZlbnRPYmplY3QpKSB7XG4gICAgcmV0dXJuIGRlY29kZUV2ZW50KGV2ZW50T2JqZWN0LCBsb2cuZGF0YSwgbG9nLnRvcGljcywgdXNlTnVtYmVyZWRQYXJhbXMpO1xuICB9XG59XG5cbi8vIENyZWF0ZSBhIGRlY29kZXIgZm9yIGFsbCBldmVudHMgZGVmaW5lZCBpbiBhbiBhYmkuIEl0IHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWRcbi8vIG9uIGFuIGFycmF5IG9mIGxvZyBlbnRyaWVzIHN1Y2ggYXMgcmVjZWl2ZWQgZnJvbSBnZXRMb2dzIG9yIGdldFRyYW5zYWN0aW9uUmVjZWlwdCBhbmQgcGFyc2VzXG4vLyBhbnkgbWF0Y2hpbmcgbG9nIGVudHJpZXNcbmZ1bmN0aW9uIGxvZ0RlY29kZXIoYWJpKSB7XG4gIHZhciB1c2VOdW1iZXJlZFBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICB2YXIgZXZlbnRNYXAgPSB7fTtcbiAgYWJpLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiBpdGVtLnR5cGUgPT09ICdldmVudCc7XG4gIH0pLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGV2ZW50TWFwW2V2ZW50U2lnbmF0dXJlKGl0ZW0pXSA9IGl0ZW07XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gKGxvZ0l0ZW1zKSB7XG4gICAgcmV0dXJuIGxvZ0l0ZW1zLm1hcChmdW5jdGlvbiAobG9nKSB7XG4gICAgICByZXR1cm4gZGVjb2RlTG9nSXRlbShldmVudE1hcFtsb2cudG9waWNzWzBdXSwgbG9nLCB1c2VOdW1iZXJlZFBhcmFtcyk7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVuY29kZVBhcmFtczogZW5jb2RlUGFyYW1zLFxuICBkZWNvZGVQYXJhbXM6IGRlY29kZVBhcmFtcyxcbiAgZW5jb2RlTWV0aG9kOiBlbmNvZGVNZXRob2QsXG4gIGRlY29kZU1ldGhvZDogZGVjb2RlTWV0aG9kLFxuICBlbmNvZGVFdmVudDogZW5jb2RlRXZlbnQsXG4gIGRlY29kZUV2ZW50OiBkZWNvZGVFdmVudCxcbiAgZGVjb2RlTG9nSXRlbTogZGVjb2RlTG9nSXRlbSxcbiAgbG9nRGVjb2RlcjogbG9nRGVjb2RlcixcbiAgZXZlbnRTaWduYXR1cmU6IGV2ZW50U2lnbmF0dXJlLFxuICBlbmNvZGVTaWduYXR1cmU6IGVuY29kZVNpZ25hdHVyZVxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yJyk7XG5cbnZhciBfcmVnZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVnZW5lcmF0b3IpO1xuXG52YXIgX3N0cmluZ2lmeSA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeScpO1xuXG52YXIgX3N0cmluZ2lmeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHJpbmdpZnkpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3InKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FzeW5jVG9HZW5lcmF0b3IyKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5Jyk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG52YXIgX2tleXMgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXMnKTtcblxudmFyIF9rZXlzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleXMpO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduJyk7XG5cbnZhciBfYXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2lnbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIGZvcm1hdCA9IHJlcXVpcmUoJ2V0aGpzLWZvcm1hdCcpO1xudmFyIEV0aFJQQyA9IHJlcXVpcmUoJ2V0aGpzLXJwYycpO1xudmFyIHByb21pc2VUb0NhbGxiYWNrID0gcmVxdWlyZSgncHJvbWlzZS10by1jYWxsYmFjaycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV0aDtcblxuZnVuY3Rpb24gRXRoKHByb3ZpZGVyLCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG9wdGlvbnNPYmplY3QgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFdGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtcXVlcnldIHRoZSBFdGggb2JqZWN0IHJlcXVpcmVzIHRoZSBcIm5ld1wiIGZsYWcgaW4gb3JkZXIgdG8gZnVuY3Rpb24gbm9ybWFsbHkgKGkuZS4gYGNvbnN0IGV0aCA9IG5ldyBFdGgocHJvdmlkZXIpO2ApLicpO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvdmlkZXIgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtcXVlcnldIHRoZSBFdGggb2JqZWN0IHJlcXVpcmVzIHRoYXQgdGhlIGZpcnN0IGlucHV0IFxcJ3Byb3ZpZGVyXFwnIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgXFwnJyArIHR5cGVvZiBwcm92aWRlciArICdcXCcgKGkuZS4gXFwnY29uc3QgZXRoID0gbmV3IEV0aChwcm92aWRlcik7XFwnKScpO1xuICB9XG5cbiAgc2VsZi5vcHRpb25zID0gKDAsIF9hc3NpZ24yWydkZWZhdWx0J10pKHtcbiAgICBkZWJ1Zzogb3B0aW9uc09iamVjdC5kZWJ1ZyB8fCBmYWxzZSxcbiAgICBsb2dnZXI6IG9wdGlvbnNPYmplY3QubG9nZ2VyIHx8IGNvbnNvbGUsXG4gICAganNvblNwYWNlOiBvcHRpb25zT2JqZWN0Lmpzb25TcGFjZSB8fCAwXG4gIH0pO1xuICBzZWxmLnJwYyA9IG5ldyBFdGhSUEMocHJvdmlkZXIpO1xuICBzZWxmLnNldFByb3ZpZGVyID0gc2VsZi5ycGMuc2V0UHJvdmlkZXI7XG59XG5cbkV0aC5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gbG9nKG1lc3NhZ2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoc2VsZi5vcHRpb25zLmRlYnVnKSBzZWxmLm9wdGlvbnMubG9nZ2VyLmxvZygnW2V0aGpzLXF1ZXJ5IGxvZ10gJyArIG1lc3NhZ2UpO1xufTtcblxuKDAsIF9rZXlzMlsnZGVmYXVsdCddKShmb3JtYXQuc2NoZW1hLm1ldGhvZHMpLmZvckVhY2goZnVuY3Rpb24gKHJwY01ldGhvZE5hbWUpIHtcbiAgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbJ2RlZmF1bHQnXSkoRXRoLnByb3RvdHlwZSwgcnBjTWV0aG9kTmFtZS5yZXBsYWNlKCdldGhfJywgJycpLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZ2VuZXJhdGVGbkZvcihycGNNZXRob2ROYW1lLCBmb3JtYXQuc2NoZW1hLm1ldGhvZHNbcnBjTWV0aG9kTmFtZV0pXG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlRm5Gb3IocnBjTWV0aG9kTmFtZSwgbWV0aG9kT2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBvdXRwdXRNZXRob2QoKSB7XG4gICAgdmFyIHBlcmZvcm1DYWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWYgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IzWydkZWZhdWx0J10pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yMlsnZGVmYXVsdCddLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgbWV0aG9kT3V0cHV0cywgb3V0cHV0RXJyb3I7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IyWydkZWZhdWx0J10ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoIShhcmdzLmxlbmd0aCA8IG1ldGhvZE9iamVjdFsyXSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtcXVlcnldIG1ldGhvZCBcXCcnICsgcHJvdG9NZXRob2ROYW1lICsgJ1xcJyByZXF1aXJlcyBhdCBsZWFzdCAnICsgbWV0aG9kT2JqZWN0WzJdICsgJyBpbnB1dCAoZm9ybWF0IHR5cGUgJyArIG1ldGhvZE9iamVjdFswXVswXSArICcpLCAnICsgYXJncy5sZW5ndGggKyAnIHByb3ZpZGVkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiB2aXNpdDogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9KU09OLVJQQyMnICsgcnBjTWV0aG9kTmFtZS50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgaWYgKCEoYXJncy5sZW5ndGggPiBtZXRob2RPYmplY3RbMF0ubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy1xdWVyeV0gbWV0aG9kIFxcJycgKyBwcm90b01ldGhvZE5hbWUgKyAnXFwnIHJlcXVpcmVzIGF0IG1vc3QgJyArIG1ldGhvZE9iamVjdFswXS5sZW5ndGggKyAnIHBhcmFtcywgJyArIGFyZ3MubGVuZ3RoICsgJyBwcm92aWRlZCBcXCcnICsgKDAsIF9zdHJpbmdpZnkyWydkZWZhdWx0J10pKGFyZ3MsIG51bGwsIHNlbGYub3B0aW9ucy5qc29uU3BhY2UpICsgJ1xcJy4gRm9yIG1vcmUgaW5mb3JtYXRpb24gdmlzaXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvSlNPTi1SUEMjJyArIHJwY01ldGhvZE5hbWUudG9Mb3dlckNhc2UoKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuXG4gICAgICAgICAgICAgICAgLy8gc2V0IGRlZmF1bHQgYmxvY2tcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kT2JqZWN0WzNdICYmIGFyZ3MubGVuZ3RoIDwgbWV0aG9kT2JqZWN0WzNdKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzLnB1c2goJ2xhdGVzdCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGZvcm1hdCBpbnB1dHNcbiAgICAgICAgICAgICAgICB0aGlzLmxvZygnYXR0ZW1wdGluZyBtZXRob2QgZm9ybWF0dGluZyBmb3IgXFwnJyArIHByb3RvTWV0aG9kTmFtZSArICdcXCcgd2l0aCBpbnB1dHMgJyArICgwLCBfc3RyaW5naWZ5MlsnZGVmYXVsdCddKShhcmdzLCBudWxsLCB0aGlzLm9wdGlvbnMuanNvblNwYWNlKSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDY7XG5cbiAgICAgICAgICAgICAgICBpbnB1dHMgPSBmb3JtYXQuZm9ybWF0SW5wdXRzKHJwY01ldGhvZE5hbWUsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKCdtZXRob2QgZm9ybWF0dGluZyBzdWNjZXNzIGZvciBcXCcnICsgcHJvdG9NZXRob2ROYW1lICsgJ1xcJyB3aXRoIGZvcm1hdHRlZCByZXN1bHQ6ICcgKyAoMCwgX3N0cmluZ2lmeTJbJ2RlZmF1bHQnXSkoaW5wdXRzLCBudWxsLCB0aGlzLm9wdGlvbnMuanNvblNwYWNlKSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDExO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbJ2NhdGNoJ10oNik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtcXVlcnldIHdoaWxlIGZvcm1hdHRpbmcgaW5wdXRzIFxcJycgKyAoMCwgX3N0cmluZ2lmeTJbJ2RlZmF1bHQnXSkoYXJncywgbnVsbCwgdGhpcy5vcHRpb25zLmpzb25TcGFjZSkgKyAnXFwnIGZvciBtZXRob2QgXFwnJyArIHByb3RvTWV0aG9kTmFtZSArICdcXCcgZXJyb3I6ICcgKyBfY29udGV4dC50MCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLnNlbmRBc3luYyh7IG1ldGhvZDogcnBjTWV0aG9kTmFtZSwgcGFyYW1zOiBpbnB1dHMgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxNztcblxuICAgICAgICAgICAgICAgIHRoaXMubG9nKCdhdHRlbXB0aW5nIG1ldGhvZCBmb3JtYXR0aW5nIGZvciBcXCcnICsgcHJvdG9NZXRob2ROYW1lICsgJ1xcJyB3aXRoIHJhdyBvdXRwdXRzOiAnICsgKDAsIF9zdHJpbmdpZnkyWydkZWZhdWx0J10pKHJlc3VsdCwgbnVsbCwgdGhpcy5vcHRpb25zLmpzb25TcGFjZSkpO1xuICAgICAgICAgICAgICAgIG1ldGhvZE91dHB1dHMgPSBmb3JtYXQuZm9ybWF0T3V0cHV0cyhycGNNZXRob2ROYW1lLCByZXN1bHQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5sb2coJ21ldGhvZCBmb3JtYXR0aW5nIHN1Y2Nlc3MgZm9yIFxcJycgKyBwcm90b01ldGhvZE5hbWUgKyAnXFwnIGZvcm1hdHRlZCByZXN1bHQ6ICcgKyAoMCwgX3N0cmluZ2lmeTJbJ2RlZmF1bHQnXSkobWV0aG9kT3V0cHV0cywgbnVsbCwgdGhpcy5vcHRpb25zLmpzb25TcGFjZSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoJ3JldHVybicsIG1ldGhvZE91dHB1dHMpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDI0O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LnQxID0gX2NvbnRleHRbJ2NhdGNoJ10oMTcpO1xuICAgICAgICAgICAgICAgIG91dHB1dEVycm9yID0gbmV3IEVycm9yKCdbZXRoanMtcXVlcnldIHdoaWxlIGZvcm1hdHRpbmcgb3V0cHV0cyBmcm9tIFJQQyBcXCcnICsgKDAsIF9zdHJpbmdpZnkyWydkZWZhdWx0J10pKHJlc3VsdCwgbnVsbCwgdGhpcy5vcHRpb25zLmpzb25TcGFjZSkgKyAnXFwnIGZvciBtZXRob2QgXFwnJyArIHByb3RvTWV0aG9kTmFtZSArICdcXCcgJyArIF9jb250ZXh0LnQxKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBvdXRwdXRFcnJvcjtcblxuICAgICAgICAgICAgICBjYXNlIDI4OlxuICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzYsIDExXSwgWzE3LCAyNF1dKTtcbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBlcmZvcm1DYWxsKCkge1xuICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICB2YXIgY2FsbGJhY2sgPSBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIGlucHV0cyA9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgaW5wdXRFcnJvciA9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgcHJvdG9NZXRob2ROYW1lID0gcnBjTWV0aG9kTmFtZS5yZXBsYWNlKCdldGhfJywgJycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBpZiAoYXJncy5sZW5ndGggPiAwICYmIHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IHBlcmZvcm1DYWxsLmNhbGwodGhpcyk7XG5cbiAgICAvLyBpZiBjYWxsYmFjayBwcm92aWRlZCwgY29udmVydCBwcm9taXNlIHRvIGNhbGxiYWNrXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVRvQ2FsbGJhY2socHJvbWlzZSkoY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8vIG9ubHkgcmV0dXJuIHByb21pc2UgaWYgbm8gY2FsbGJhY2sgcHJvdmlkZWRcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24nKTtcblxudmFyIF9hc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXNzaWduKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgYWJpID0gcmVxdWlyZSgnZXRoanMtYWJpJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbnZhciBrZWNjYWsyNTYgPSByZXF1aXJlKCdqcy1zaGEzJykua2VjY2FrXzI1NjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxudmFyIEV0aEZpbHRlciA9IHJlcXVpcmUoJ2V0aGpzLWZpbHRlcicpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJ2V0aGpzLXV0aWwnKS5nZXRLZXlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG52YXIgQ29udHJhY3QgPSByZXF1aXJlKCcuL2NvbnRyYWN0Jyk7XG52YXIgaGFzVHJhbnNhY3Rpb25PYmplY3QgPSByZXF1aXJlKCcuL2hhcy10eC1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdGhDb250cmFjdDtcblxuZnVuY3Rpb24gRXRoQ29udHJhY3QocXVlcnkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbnRyYWN0RmFjdG9yeShjb250cmFjdEFCSSwgY29udHJhY3RCeXRlY29kZSwgY29udHJhY3REZWZhdWx0VHhPYmplY3QpIHtcbiAgICAvLyB2YWxpZGF0ZSBwYXJhbXNcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29udHJhY3RBQkkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy1jb250cmFjdF0gQ29udHJhY3QgQUJJIG11c3QgYmUgdHlwZSBBcnJheSwgZ290IHR5cGUgJyArIHR5cGVvZiBjb250cmFjdEFCSSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29udHJhY3RCeXRlY29kZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnRyYWN0Qnl0ZWNvZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy1jb250cmFjdF0gQ29udHJhY3QgYnl0ZWNvZGUgbXVzdCBiZSB0eXBlIFN0cmluZywgZ290IHR5cGUgJyArIHR5cGVvZiBjb250cmFjdEJ5dGVjb2RlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb250cmFjdERlZmF1bHRUeE9iamVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnRyYWN0RGVmYXVsdFR4T2JqZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtY29udHJhY3RdIENvbnRyYWN0IGRlZmF1bHQgdHggb2JqZWN0IG11c3QgYmUgdHlwZSBPYmplY3QsIGdvdCB0eXBlICcgKyB0eXBlb2YgY29udHJhY3RBQkkpO1xuICAgIH1cblxuICAgIC8vIGJ1aWxkIGNvbnRyYWN0IG9iamVjdFxuICAgIHZhciBvdXRwdXQgPSB7fTtcbiAgICBvdXRwdXQuYXQgPSBmdW5jdGlvbiBjb250cmFjdEF0QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgICByZXR1cm4gbmV3IENvbnRyYWN0KHtcbiAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICBjb250cmFjdEJ5dGVjb2RlOiBjb250cmFjdEJ5dGVjb2RlLFxuICAgICAgICBjb250cmFjdERlZmF1bHRUeE9iamVjdDogY29udHJhY3REZWZhdWx0VHhPYmplY3QsXG4gICAgICAgIGNvbnRyYWN0QUJJOiBjb250cmFjdEFCSVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIG91dHB1dFsnbmV3J10gPSBmdW5jdGlvbiBuZXdDb250cmFjdCgpIHtcbiAgICAgIHZhciBwcm92aWRlZFR4T2JqZWN0ID0ge307IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHZhciBuZXdNZXRob2RDYWxsYmFjayA9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHZhciBuZXdNZXRob2RBcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBpZiAodHlwZW9mIG5ld01ldGhvZEFyZ3NbbmV3TWV0aG9kQXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykgbmV3TWV0aG9kQ2FsbGJhY2sgPSBuZXdNZXRob2RBcmdzLnBvcCgpO1xuICAgICAgaWYgKGhhc1RyYW5zYWN0aW9uT2JqZWN0KG5ld01ldGhvZEFyZ3MpKSBwcm92aWRlZFR4T2JqZWN0ID0gbmV3TWV0aG9kQXJncy5wb3AoKTtcbiAgICAgIHZhciBjb25zdHJ1Y3Rvck1ldGhvZCA9IGdldENvbnN0cnVjdG9yRnJvbUFCSShjb250cmFjdEFCSSk7XG4gICAgICB2YXIgYXNzZW1ibGVUeE9iamVjdCA9ICgwLCBfYXNzaWduMlsnZGVmYXVsdCddKSh7fSwgY29udHJhY3REZWZhdWx0VHhPYmplY3QsIHByb3ZpZGVkVHhPYmplY3QpO1xuXG4gICAgICAvLyBzZXQgY29udHJhY3QgZGVwbG95IGJ5dGVjb2RlXG4gICAgICBpZiAoY29udHJhY3RCeXRlY29kZSkge1xuICAgICAgICBhc3NlbWJsZVR4T2JqZWN0LmRhdGEgPSBjb250cmFjdEJ5dGVjb2RlO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBlbmQgZW5jb2RlZCBjb25zdHJ1Y3RvciBhcmd1bWVudHNcbiAgICAgIGlmIChjb25zdHJ1Y3Rvck1ldGhvZCkge1xuICAgICAgICB2YXIgY29uc3RydWN0b3JCeXRlY29kZSA9IGFiaS5lbmNvZGVQYXJhbXMoZ2V0S2V5cyhjb25zdHJ1Y3Rvck1ldGhvZC5pbnB1dHMsICd0eXBlJyksIG5ld01ldGhvZEFyZ3MpLnN1YnN0cmluZygyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICBhc3NlbWJsZVR4T2JqZWN0LmRhdGEgPSAnJyArIGFzc2VtYmxlVHhPYmplY3QuZGF0YSArIGNvbnN0cnVjdG9yQnl0ZWNvZGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdNZXRob2RDYWxsYmFjayA/IHF1ZXJ5LnNlbmRUcmFuc2FjdGlvbihhc3NlbWJsZVR4T2JqZWN0LCBuZXdNZXRob2RDYWxsYmFjaykgOiBxdWVyeS5zZW5kVHJhbnNhY3Rpb24oYXNzZW1ibGVUeE9iamVjdCk7XG4gICAgfTtcblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENvbnN0cnVjdG9yRnJvbUFCSShjb250cmFjdEFCSSkge1xuICByZXR1cm4gY29udHJhY3RBQkkuZmlsdGVyKGZ1bmN0aW9uIChqc29uKSB7XG4gICAgcmV0dXJuIGpzb24udHlwZSA9PT0gJ2NvbnN0cnVjdG9yJztcbiAgfSlbMF07XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHByb2Nlc3NOZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gX2lzVWludDhBcnJheShjaHVuaykgJiYgIXN0YXRlLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHByb2Nlc3NOZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3NOZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzc05leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxudmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5mb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzc05leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwcm9jZXNzTmV4dFRpY2soY2IsIGVycik7XG59O1xuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbiAgdGhpcy53cml0ZWVuY29kaW5nID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUodGhpcyk7XG5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKHN0cmVhbSwgZXIsIGRhdGEpO1xuICAgIH0pO2Vsc2UgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgICBfdGhpcy5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLy8gVE9ETyhibWV1cmVyKTogQ2hhbmdlIHRoaXMgYmFjayB0byBjb25zdCBvbmNlIGhvbGUgY2hlY2tzIGFyZVxuLy8gcHJvcGVybHkgb3B0aW1pemVkIGF3YXkgZWFybHkgaW4gSWduaXRpb24rVHVyYm9GYW4uXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gICAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICAgIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICBjYihlcnIpO1xufTtcblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICAgIGlmIChlcikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50JykpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwcm9jZXNzTmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3NOZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHsgaGFzVW5waXBlZDogZmFsc2UgfTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3NOZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgc2VsZi5lbWl0LmJpbmQoc2VsZiwga1Byb3h5RXZlbnRzW25dKSk7XG4gIH1cblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn07XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwibW9kdWxlLmV4cG9ydHMgICAgICA9IGlzVHlwZWRBcnJheVxuaXNUeXBlZEFycmF5LnN0cmljdCA9IGlzU3RyaWN0VHlwZWRBcnJheVxuaXNUeXBlZEFycmF5Lmxvb3NlICA9IGlzTG9vc2VUeXBlZEFycmF5XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbnZhciBuYW1lcyA9IHtcbiAgICAnW29iamVjdCBJbnQ4QXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IEludDE2QXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IEludDMyQXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IFVpbnQ4QXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBVaW50MTZBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgVWludDMyQXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc6IHRydWVcbn1cblxuZnVuY3Rpb24gaXNUeXBlZEFycmF5KGFycikge1xuICByZXR1cm4gKFxuICAgICAgIGlzU3RyaWN0VHlwZWRBcnJheShhcnIpXG4gICAgfHwgaXNMb29zZVR5cGVkQXJyYXkoYXJyKVxuICApXG59XG5cbmZ1bmN0aW9uIGlzU3RyaWN0VHlwZWRBcnJheShhcnIpIHtcbiAgcmV0dXJuIChcbiAgICAgICBhcnIgaW5zdGFuY2VvZiBJbnQ4QXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBJbnQxNkFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgSW50MzJBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIFVpbnQxNkFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgVWludDMyQXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXlcbiAgKVxufVxuXG5mdW5jdGlvbiBpc0xvb3NlVHlwZWRBcnJheShhcnIpIHtcbiAgcmV0dXJuIG5hbWVzW3RvU3RyaW5nLmNhbGwoYXJyKV1cbn1cbiIsIid1c2Ugc3RyaWN0Jztcbi8vYmFzZWQgb2ZmIHJzdnAgaHR0cHM6Ly9naXRodWIuY29tL3RpbGRlaW8vcnN2cC5qc1xuLy9saWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS90aWxkZWlvL3JzdnAuanMvYmxvYi9tYXN0ZXIvTElDRU5TRVxuLy9odHRwczovL2dpdGh1Yi5jb20vdGlsZGVpby9yc3ZwLmpzL2Jsb2IvbWFzdGVyL2xpYi9yc3ZwL2FzYXAuanNcblxudmFyIE11dGF0aW9uID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG5cbmV4cG9ydHMudGVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE11dGF0aW9uO1xufTtcblxuZXhwb3J0cy5pbnN0YWxsID0gZnVuY3Rpb24gKGhhbmRsZSkge1xuICB2YXIgY2FsbGVkID0gMDtcbiAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uKGhhbmRsZSk7XG4gIHZhciBlbGVtZW50ID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7XG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBlbGVtZW50LmRhdGEgPSAoY2FsbGVkID0gKytjYWxsZWQgJSAyKTtcbiAgfTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLnRlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgLy8gd2UgY2FuIG9ubHkgZ2V0IGhlcmUgaW4gSUUxMFxuICAgIC8vIHdoaWNoIGRvZXNuJ3QgaGFuZGVsIHBvc3RNZXNzYWdlIHdlbGxcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBnbG9iYWwuTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xufTtcblxuZXhwb3J0cy5pbnN0YWxsID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKCk7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuYztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICB9O1xufTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMudGVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdkb2N1bWVudCcgaW4gZ2xvYmFsICYmICdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbn07XG5cbmV4cG9ydHMuaW5zdGFsbCA9IGZ1bmN0aW9uIChoYW5kbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgdmFyIHNjcmlwdEVsID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHNjcmlwdEVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGhhbmRsZSgpO1xuXG4gICAgICBzY3JpcHRFbC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgc2NyaXB0RWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHRFbCk7XG4gICAgICBzY3JpcHRFbCA9IG51bGw7XG4gICAgfTtcbiAgICBnbG9iYWwuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdEVsKTtcblxuICAgIHJldHVybiBoYW5kbGU7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcbmV4cG9ydHMudGVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnRzLmluc3RhbGwgPSBmdW5jdGlvbiAodCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQodCwgMCk7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcbmV4cG9ydHMudGVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICByZXR1cm4gKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykgJiYgIXByb2Nlc3MuYnJvd3Nlcjtcbn07XG5cbmV4cG9ydHMuaW5zdGFsbCA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jKTtcbiAgfTtcbn07XG4iLCJ2YXIgQWJzdHJhY3RJdGVyYXRvciA9IHJlcXVpcmUoJ2Fic3RyYWN0LWxldmVsZG93bicpLkFic3RyYWN0SXRlcmF0b3JcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuZnVuY3Rpb24gRGVmZXJyZWRJdGVyYXRvciAob3B0aW9ucykge1xuICBBYnN0cmFjdEl0ZXJhdG9yLmNhbGwodGhpcywgb3B0aW9ucylcblxuICB0aGlzLl9vcHRpb25zID0gb3B0aW9uc1xuICB0aGlzLl9pdGVyYXRvciA9IG51bGxcbiAgdGhpcy5fb3BlcmF0aW9ucyA9IFtdXG59XG5cbmluaGVyaXRzKERlZmVycmVkSXRlcmF0b3IsIEFic3RyYWN0SXRlcmF0b3IpXG5cbkRlZmVycmVkSXRlcmF0b3IucHJvdG90eXBlLnNldERiID0gZnVuY3Rpb24gKGRiKSB7XG4gIHZhciBpdCA9IHRoaXMuX2l0ZXJhdG9yID0gZGIuaXRlcmF0b3IodGhpcy5fb3B0aW9ucylcbiAgdGhpcy5fb3BlcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcCkge1xuICAgIGl0W29wLm1ldGhvZF0uYXBwbHkoaXQsIG9wLmFyZ3MpXG4gIH0pXG59XG5cbkRlZmVycmVkSXRlcmF0b3IucHJvdG90eXBlLl9vcGVyYXRpb24gPSBmdW5jdGlvbiAobWV0aG9kLCBhcmdzKSB7XG4gIGlmICh0aGlzLl9pdGVyYXRvcikgcmV0dXJuIHRoaXMuX2l0ZXJhdG9yW21ldGhvZF0uYXBwbHkodGhpcy5faXRlcmF0b3IsIGFyZ3MpXG4gIHRoaXMuX29wZXJhdGlvbnMucHVzaCh7IG1ldGhvZDogbWV0aG9kLCBhcmdzOiBhcmdzIH0pXG59XG5cbiduZXh0IGVuZCcuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gIERlZmVycmVkSXRlcmF0b3IucHJvdG90eXBlWydfJyArIG1dID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX29wZXJhdGlvbihtLCBhcmd1bWVudHMpXG4gIH1cbn0pXG5cbi8vIE11c3QgZGVmZXIgc2VlaygpIHJhdGhlciB0aGFuIF9zZWVrKCkgYmVjYXVzZSBpdCByZXF1aXJlcyBkYi5fc2VyaWFsaXplS2V5IHRvIGJlIGF2YWlsYWJsZVxuRGVmZXJyZWRJdGVyYXRvci5wcm90b3R5cGUuc2VlayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fb3BlcmF0aW9uKCdzZWVrJywgYXJndW1lbnRzKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmVycmVkSXRlcmF0b3JcbiIsInZhciBhbGwgPSBtb2R1bGUuZXhwb3J0cy5hbGwgPSBbXG4gIHtcbiAgICBlcnJubzogLTIsXG4gICAgY29kZTogJ0VOT0VOVCcsXG4gICAgZGVzY3JpcHRpb246ICdubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5J1xuICB9LFxuICB7XG4gICAgZXJybm86IC0xLFxuICAgIGNvZGU6ICdVTktOT1dOJyxcbiAgICBkZXNjcmlwdGlvbjogJ3Vua25vd24gZXJyb3InXG4gIH0sXG4gIHtcbiAgICBlcnJubzogMCxcbiAgICBjb2RlOiAnT0snLFxuICAgIGRlc2NyaXB0aW9uOiAnc3VjY2VzcydcbiAgfSxcbiAge1xuICAgIGVycm5vOiAxLFxuICAgIGNvZGU6ICdFT0YnLFxuICAgIGRlc2NyaXB0aW9uOiAnZW5kIG9mIGZpbGUnXG4gIH0sXG4gIHtcbiAgICBlcnJubzogMixcbiAgICBjb2RlOiAnRUFERFJJTkZPJyxcbiAgICBkZXNjcmlwdGlvbjogJ2dldGFkZHJpbmZvIGVycm9yJ1xuICB9LFxuICB7XG4gICAgZXJybm86IDMsXG4gICAgY29kZTogJ0VBQ0NFUycsXG4gICAgZGVzY3JpcHRpb246ICdwZXJtaXNzaW9uIGRlbmllZCdcbiAgfSxcbiAge1xuICAgIGVycm5vOiA0LFxuICAgIGNvZGU6ICdFQUdBSU4nLFxuICAgIGRlc2NyaXB0aW9uOiAncmVzb3VyY2UgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUnXG4gIH0sXG4gIHtcbiAgICBlcnJubzogNSxcbiAgICBjb2RlOiAnRUFERFJJTlVTRScsXG4gICAgZGVzY3JpcHRpb246ICdhZGRyZXNzIGFscmVhZHkgaW4gdXNlJ1xuICB9LFxuICB7XG4gICAgZXJybm86IDYsXG4gICAgY29kZTogJ0VBRERSTk9UQVZBSUwnLFxuICAgIGRlc2NyaXB0aW9uOiAnYWRkcmVzcyBub3QgYXZhaWxhYmxlJ1xuICB9LFxuICB7XG4gICAgZXJybm86IDcsXG4gICAgY29kZTogJ0VBRk5PU1VQUE9SVCcsXG4gICAgZGVzY3JpcHRpb246ICdhZGRyZXNzIGZhbWlseSBub3Qgc3VwcG9ydGVkJ1xuICB9LFxuICB7XG4gICAgZXJybm86IDgsXG4gICAgY29kZTogJ0VBTFJFQURZJyxcbiAgICBkZXNjcmlwdGlvbjogJ2Nvbm5lY3Rpb24gYWxyZWFkeSBpbiBwcm9ncmVzcydcbiAgfSxcbiAge1xuICAgIGVycm5vOiA5LFxuICAgIGNvZGU6ICdFQkFERicsXG4gICAgZGVzY3JpcHRpb246ICdiYWQgZmlsZSBkZXNjcmlwdG9yJ1xuICB9LFxuICB7XG4gICAgZXJybm86IDEwLFxuICAgIGNvZGU6ICdFQlVTWScsXG4gICAgZGVzY3JpcHRpb246ICdyZXNvdXJjZSBidXN5IG9yIGxvY2tlZCdcbiAgfSxcbiAge1xuICAgIGVycm5vOiAxMSxcbiAgICBjb2RlOiAnRUNPTk5BQk9SVEVEJyxcbiAgICBkZXNjcmlwdGlvbjogJ3NvZnR3YXJlIGNhdXNlZCBjb25uZWN0aW9uIGFib3J0J1xuICB9LFxuICB7XG4gICAgZXJybm86IDEyLFxuICAgIGNvZGU6ICdFQ09OTlJFRlVTRUQnLFxuICAgIGRlc2NyaXB0aW9uOiAnY29ubmVjdGlvbiByZWZ1c2VkJ1xuICB9LFxuICB7XG4gICAgZXJybm86IDEzLFxuICAgIGNvZGU6ICdFQ09OTlJFU0VUJyxcbiAgICBkZXNjcmlwdGlvbjogJ2Nvbm5lY3Rpb24gcmVzZXQgYnkgcGVlcidcbiAgfSxcbiAge1xuICAgIGVycm5vOiAxNCxcbiAgICBjb2RlOiAnRURFU1RBRERSUkVRJyxcbiAgICBkZXNjcmlwdGlvbjogJ2Rlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQnXG4gIH0sXG4gIHtcbiAgICBlcnJubzogMTUsXG4gICAgY29kZTogJ0VGQVVMVCcsXG4gICAgZGVzY3JpcHRpb246ICdiYWQgYWRkcmVzcyBpbiBzeXN0ZW0gY2FsbCBhcmd1bWVudCdcbiAgfSxcbiAge1xuICAgIGVycm5vOiAxNixcbiAgICBjb2RlOiAnRUhPU1RVTlJFQUNIJyxcbiAgICBkZXNjcmlwdGlvbjogJ2hvc3QgaXMgdW5yZWFjaGFibGUnXG4gIH0sXG4gIHtcbiAgICBlcnJubzogMTcsXG4gICAgY29kZTogJ0VJTlRSJyxcbiAgICBkZXNjcmlwdGlvbjogJ2ludGVycnVwdGVkIHN5c3RlbSBjYWxsJ1xuICB9LFxuICB7XG4gICAgZXJybm86IDE4LFxuICAgIGNvZGU6ICdFSU5WQUwnLFxuICAgIGRlc2NyaXB0aW9uOiAnaW52YWxpZCBhcmd1bWVudCdcbiAgfSxcbiAge1xuICAgIGVycm5vOiAxOSxcbiAgICBjb2RlOiAnRUlTQ09OTicsXG4gICAgZGVzY3JpcHRpb246ICdzb2NrZXQgaXMgYWxyZWFkeSBjb25uZWN0ZWQnXG4gIH0sXG4gIHtcbiAgICBlcnJubzogMjAsXG4gICAgY29kZTogJ0VNRklMRScsXG4gICAgZGVzY3JpcHRpb246ICd0b28gbWFueSBvcGVuIGZpbGVzJ1xuICB9LFxuICB7XG4gICAgZXJybm86IDIxLFxuICAgIGNvZGU6ICdFTVNHU0laRScsXG4gICAgZGVzY3JpcHRpb246ICdtZXNzYWdlIHRvbyBsb25nJ1xuICB9LFxuICB7XG4gICAgZXJybm86IDIyLFxuICAgIGNvZGU6ICdFTkVURE9XTicsXG4gICAgZGVzY3JpcHRpb246ICduZXR3b3JrIGlzIGRvd24nXG4gIH0sXG4gIHtcbiAgICBlcnJubzogMjMsXG4gICAgY29kZTogJ0VORVRVTlJFQUNIJyxcbiAgICBkZXNjcmlwdGlvbjogJ25ldHdvcmsgaXMgdW5yZWFjaGFibGUnXG4gIH0sXG4gIHtcbiAgICBlcnJubzogMjQsXG4gICAgY29kZTogJ0VORklMRScsXG4gICAgZGVzY3JpcHRpb246ICdmaWxlIHRhYmxlIG92ZXJmbG93J1xuICB9LFxuICB7XG4gICAgZXJybm86IDI1LFxuICAgIGNvZGU6ICdFTk9CVUZTJyxcbiAgICBkZXNjcmlwdGlvbjogJ25vIGJ1ZmZlciBzcGFjZSBhdmFpbGFibGUnXG4gIH0sXG4gIHtcbiAgICBlcnJubzogMjYsXG4gICAgY29kZTogJ0VOT01FTScsXG4gICAgZGVzY3JpcHRpb246ICdub3QgZW5vdWdoIG1lbW9yeSdcbiAgfSxcbiAge1xuICAgIGVycm5vOiAyNyxcbiAgICBjb2RlOiAnRU5PVERJUicsXG4gICAgZGVzY3JpcHRpb246ICdub3QgYSBkaXJlY3RvcnknXG4gIH0sXG4gIHtcbiAgICBlcnJubzogMjgsXG4gICAgY29kZTogJ0VJU0RJUicsXG4gICAgZGVzY3JpcHRpb246ICdpbGxlZ2FsIG9wZXJhdGlvbiBvbiBhIGRpcmVjdG9yeSdcbiAgfSxcbiAge1xuICAgIGVycm5vOiAyOSxcbiAgICBjb2RlOiAnRU5PTkVUJyxcbiAgICBkZXNjcmlwdGlvbjogJ21hY2hpbmUgaXMgbm90IG9uIHRoZSBuZXR3b3JrJ1xuICB9LFxuICB7XG4gICAgZXJybm86IDMxLFxuICAgIGNvZGU6ICdFTk9UQ09OTicsXG4gICAgZGVzY3JpcHRpb246ICdzb2NrZXQgaXMgbm90IGNvbm5lY3RlZCdcbiAgfSxcbiAge1xuICAgIGVycm5vOiAzMixcbiAgICBjb2RlOiAnRU5PVFNPQ0snLFxuICAgIGRlc2NyaXB0aW9uOiAnc29ja2V0IG9wZXJhdGlvbiBvbiBub24tc29ja2V0J1xuICB9LFxuICB7XG4gICAgZXJybm86IDMzLFxuICAgIGNvZGU6ICdFTk9UU1VQJyxcbiAgICBkZXNjcmlwdGlvbjogJ29wZXJhdGlvbiBub3Qgc3VwcG9ydGVkIG9uIHNvY2tldCdcbiAgfSxcbiAge1xuICAgIGVycm5vOiAzNCxcbiAgICBjb2RlOiAnRU5PRU5UJyxcbiAgICBkZXNjcmlwdGlvbjogJ25vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnknXG4gIH0sXG4gIHtcbiAgICBlcnJubzogMzUsXG4gICAgY29kZTogJ0VOT1NZUycsXG4gICAgZGVzY3JpcHRpb246ICdmdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQnXG4gIH0sXG4gIHtcbiAgICBlcnJubzogMzYsXG4gICAgY29kZTogJ0VQSVBFJyxcbiAgICBkZXNjcmlwdGlvbjogJ2Jyb2tlbiBwaXBlJ1xuICB9LFxuICB7XG4gICAgZXJybm86IDM3LFxuICAgIGNvZGU6ICdFUFJPVE8nLFxuICAgIGRlc2NyaXB0aW9uOiAncHJvdG9jb2wgZXJyb3InXG4gIH0sXG4gIHtcbiAgICBlcnJubzogMzgsXG4gICAgY29kZTogJ0VQUk9UT05PU1VQUE9SVCcsXG4gICAgZGVzY3JpcHRpb246ICdwcm90b2NvbCBub3Qgc3VwcG9ydGVkJ1xuICB9LFxuICB7XG4gICAgZXJybm86IDM5LFxuICAgIGNvZGU6ICdFUFJPVE9UWVBFJyxcbiAgICBkZXNjcmlwdGlvbjogJ3Byb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldCdcbiAgfSxcbiAge1xuICAgIGVycm5vOiA0MCxcbiAgICBjb2RlOiAnRVRJTUVET1VUJyxcbiAgICBkZXNjcmlwdGlvbjogJ2Nvbm5lY3Rpb24gdGltZWQgb3V0J1xuICB9LFxuICB7XG4gICAgZXJybm86IDQxLFxuICAgIGNvZGU6ICdFQ0hBUlNFVCcsXG4gICAgZGVzY3JpcHRpb246ICdpbnZhbGlkIFVuaWNvZGUgY2hhcmFjdGVyJ1xuICB9LFxuICB7XG4gICAgZXJybm86IDQyLFxuICAgIGNvZGU6ICdFQUlGQU1OT1NVUFBPUlQnLFxuICAgIGRlc2NyaXB0aW9uOiAnYWRkcmVzcyBmYW1pbHkgZm9yIGhvc3RuYW1lIG5vdCBzdXBwb3J0ZWQnXG4gIH0sXG4gIHtcbiAgICBlcnJubzogNDQsXG4gICAgY29kZTogJ0VBSVNFUlZJQ0UnLFxuICAgIGRlc2NyaXB0aW9uOiAnc2Vydm5hbWUgbm90IHN1cHBvcnRlZCBmb3IgYWlfc29ja3R5cGUnXG4gIH0sXG4gIHtcbiAgICBlcnJubzogNDUsXG4gICAgY29kZTogJ0VBSVNPQ0tUWVBFJyxcbiAgICBkZXNjcmlwdGlvbjogJ2FpX3NvY2t0eXBlIG5vdCBzdXBwb3J0ZWQnXG4gIH0sXG4gIHtcbiAgICBlcnJubzogNDYsXG4gICAgY29kZTogJ0VTSFVURE9XTicsXG4gICAgZGVzY3JpcHRpb246ICdjYW5ub3Qgc2VuZCBhZnRlciB0cmFuc3BvcnQgZW5kcG9pbnQgc2h1dGRvd24nXG4gIH0sXG4gIHtcbiAgICBlcnJubzogNDcsXG4gICAgY29kZTogJ0VFWElTVCcsXG4gICAgZGVzY3JpcHRpb246ICdmaWxlIGFscmVhZHkgZXhpc3RzJ1xuICB9LFxuICB7XG4gICAgZXJybm86IDQ4LFxuICAgIGNvZGU6ICdFU1JDSCcsXG4gICAgZGVzY3JpcHRpb246ICdubyBzdWNoIHByb2Nlc3MnXG4gIH0sXG4gIHtcbiAgICBlcnJubzogNDksXG4gICAgY29kZTogJ0VOQU1FVE9PTE9ORycsXG4gICAgZGVzY3JpcHRpb246ICduYW1lIHRvbyBsb25nJ1xuICB9LFxuICB7XG4gICAgZXJybm86IDUwLFxuICAgIGNvZGU6ICdFUEVSTScsXG4gICAgZGVzY3JpcHRpb246ICdvcGVyYXRpb24gbm90IHBlcm1pdHRlZCdcbiAgfSxcbiAge1xuICAgIGVycm5vOiA1MSxcbiAgICBjb2RlOiAnRUxPT1AnLFxuICAgIGRlc2NyaXB0aW9uOiAndG9vIG1hbnkgc3ltYm9saWMgbGlua3MgZW5jb3VudGVyZWQnXG4gIH0sXG4gIHtcbiAgICBlcnJubzogNTIsXG4gICAgY29kZTogJ0VYREVWJyxcbiAgICBkZXNjcmlwdGlvbjogJ2Nyb3NzLWRldmljZSBsaW5rIG5vdCBwZXJtaXR0ZWQnXG4gIH0sXG4gIHtcbiAgICBlcnJubzogNTMsXG4gICAgY29kZTogJ0VOT1RFTVBUWScsXG4gICAgZGVzY3JpcHRpb246ICdkaXJlY3Rvcnkgbm90IGVtcHR5J1xuICB9LFxuICB7XG4gICAgZXJybm86IDU0LFxuICAgIGNvZGU6ICdFTk9TUEMnLFxuICAgIGRlc2NyaXB0aW9uOiAnbm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UnXG4gIH0sXG4gIHtcbiAgICBlcnJubzogNTUsXG4gICAgY29kZTogJ0VJTycsXG4gICAgZGVzY3JpcHRpb246ICdpL28gZXJyb3InXG4gIH0sXG4gIHtcbiAgICBlcnJubzogNTYsXG4gICAgY29kZTogJ0VST0ZTJyxcbiAgICBkZXNjcmlwdGlvbjogJ3JlYWQtb25seSBmaWxlIHN5c3RlbSdcbiAgfSxcbiAge1xuICAgIGVycm5vOiA1NyxcbiAgICBjb2RlOiAnRU5PREVWJyxcbiAgICBkZXNjcmlwdGlvbjogJ25vIHN1Y2ggZGV2aWNlJ1xuICB9LFxuICB7XG4gICAgZXJybm86IDU4LFxuICAgIGNvZGU6ICdFU1BJUEUnLFxuICAgIGRlc2NyaXB0aW9uOiAnaW52YWxpZCBzZWVrJ1xuICB9LFxuICB7XG4gICAgZXJybm86IDU5LFxuICAgIGNvZGU6ICdFQ0FOQ0VMRUQnLFxuICAgIGRlc2NyaXB0aW9uOiAnb3BlcmF0aW9uIGNhbmNlbGVkJ1xuICB9XG5dXG5cbm1vZHVsZS5leHBvcnRzLmVycm5vID0ge31cbm1vZHVsZS5leHBvcnRzLmNvZGUgPSB7fVxuXG5hbGwuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgbW9kdWxlLmV4cG9ydHMuZXJybm9bZXJyb3IuZXJybm9dID0gZXJyb3JcbiAgbW9kdWxlLmV4cG9ydHMuY29kZVtlcnJvci5jb2RlXSA9IGVycm9yXG59KVxuXG5tb2R1bGUuZXhwb3J0cy5jdXN0b20gPSByZXF1aXJlKCcuL2N1c3RvbScpKG1vZHVsZS5leHBvcnRzKVxubW9kdWxlLmV4cG9ydHMuY3JlYXRlID0gbW9kdWxlLmV4cG9ydHMuY3VzdG9tLmNyZWF0ZUVycm9yXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuZXhwb3J0cy5maW5pc2hlZCA9IHJlcXVpcmUoJy4vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcycpO1xuZXhwb3J0cy5waXBlbGluZSA9IHJlcXVpcmUoJy4vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcXVldWU7XG5cbnZhciBfYmFzZUluZGV4T2YgPSByZXF1aXJlKCdsb2Rhc2gvX2Jhc2VJbmRleE9mJyk7XG5cbnZhciBfYmFzZUluZGV4T2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZUluZGV4T2YpO1xuXG52YXIgX2lzQXJyYXkgPSByZXF1aXJlKCdsb2Rhc2gvaXNBcnJheScpO1xuXG52YXIgX2lzQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNBcnJheSk7XG5cbnZhciBfbm9vcCA9IHJlcXVpcmUoJ2xvZGFzaC9ub29wJyk7XG5cbnZhciBfbm9vcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub29wKTtcblxudmFyIF9vbmx5T25jZSA9IHJlcXVpcmUoJy4vb25seU9uY2UnKTtcblxudmFyIF9vbmx5T25jZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vbmx5T25jZSk7XG5cbnZhciBfc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgnLi9zZXRJbW1lZGlhdGUnKTtcblxudmFyIF9zZXRJbW1lZGlhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0SW1tZWRpYXRlKTtcblxudmFyIF9Eb3VibHlMaW5rZWRMaXN0ID0gcmVxdWlyZSgnLi9Eb3VibHlMaW5rZWRMaXN0Jyk7XG5cbnZhciBfRG91Ymx5TGlua2VkTGlzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Eb3VibHlMaW5rZWRMaXN0KTtcblxudmFyIF93cmFwQXN5bmMgPSByZXF1aXJlKCcuL3dyYXBBc3luYycpO1xuXG52YXIgX3dyYXBBc3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93cmFwQXN5bmMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBxdWV1ZSh3b3JrZXIsIGNvbmN1cnJlbmN5LCBwYXlsb2FkKSB7XG4gICAgaWYgKGNvbmN1cnJlbmN5ID09IG51bGwpIHtcbiAgICAgICAgY29uY3VycmVuY3kgPSAxO1xuICAgIH0gZWxzZSBpZiAoY29uY3VycmVuY3kgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25jdXJyZW5jeSBtdXN0IG5vdCBiZSB6ZXJvJyk7XG4gICAgfVxuXG4gICAgdmFyIF93b3JrZXIgPSAoMCwgX3dyYXBBc3luYzIuZGVmYXVsdCkod29ya2VyKTtcbiAgICB2YXIgbnVtUnVubmluZyA9IDA7XG4gICAgdmFyIHdvcmtlcnNMaXN0ID0gW107XG5cbiAgICB2YXIgcHJvY2Vzc2luZ1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIF9pbnNlcnQoZGF0YSwgaW5zZXJ0QXRGcm9udCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rhc2sgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcS5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCEoMCwgX2lzQXJyYXkyLmRlZmF1bHQpKGRhdGEpKSB7XG4gICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCAmJiBxLmlkbGUoKSkge1xuICAgICAgICAgICAgLy8gY2FsbCBkcmFpbiBpbW1lZGlhdGVseSBpZiB0aGVyZSBhcmUgbm8gdGFza3NcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3NldEltbWVkaWF0ZTIuZGVmYXVsdCkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YVtpXSxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2sgfHwgX25vb3AyLmRlZmF1bHRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChpbnNlcnRBdEZyb250KSB7XG4gICAgICAgICAgICAgICAgcS5fdGFza3MudW5zaGlmdChpdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcS5fdGFza3MucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJvY2Vzc2luZ1NjaGVkdWxlZCkge1xuICAgICAgICAgICAgcHJvY2Vzc2luZ1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgICAoMCwgX3NldEltbWVkaWF0ZTIuZGVmYXVsdCkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX25leHQodGFza3MpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG51bVJ1bm5pbmcgLT0gMTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0YXNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzW2ldO1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gKDAsIF9iYXNlSW5kZXhPZjIuZGVmYXVsdCkod29ya2Vyc0xpc3QsIHRhc2ssIDApO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXJzTGlzdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcnNMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGFzay5jYWxsYmFjay5hcHBseSh0YXNrLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHEuZXJyb3IoZXJyLCB0YXNrLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG51bVJ1bm5pbmcgPD0gcS5jb25jdXJyZW5jeSAtIHEuYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcS51bnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocS5pZGxlKCkpIHtcbiAgICAgICAgICAgICAgICBxLmRyYWluKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgdmFyIHEgPSB7XG4gICAgICAgIF90YXNrczogbmV3IF9Eb3VibHlMaW5rZWRMaXN0Mi5kZWZhdWx0KCksXG4gICAgICAgIGNvbmN1cnJlbmN5OiBjb25jdXJyZW5jeSxcbiAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgc2F0dXJhdGVkOiBfbm9vcDIuZGVmYXVsdCxcbiAgICAgICAgdW5zYXR1cmF0ZWQ6IF9ub29wMi5kZWZhdWx0LFxuICAgICAgICBidWZmZXI6IGNvbmN1cnJlbmN5IC8gNCxcbiAgICAgICAgZW1wdHk6IF9ub29wMi5kZWZhdWx0LFxuICAgICAgICBkcmFpbjogX25vb3AyLmRlZmF1bHQsXG4gICAgICAgIGVycm9yOiBfbm9vcDIuZGVmYXVsdCxcbiAgICAgICAgc3RhcnRlZDogZmFsc2UsXG4gICAgICAgIHBhdXNlZDogZmFsc2UsXG4gICAgICAgIHB1c2g6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgX2luc2VydChkYXRhLCBmYWxzZSwgY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBraWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBxLmRyYWluID0gX25vb3AyLmRlZmF1bHQ7XG4gICAgICAgICAgICBxLl90YXNrcy5lbXB0eSgpO1xuICAgICAgICB9LFxuICAgICAgICB1bnNoaWZ0OiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIF9pbnNlcnQoZGF0YSwgdHJ1ZSwgY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICh0ZXN0Rm4pIHtcbiAgICAgICAgICAgIHEuX3Rhc2tzLnJlbW92ZSh0ZXN0Rm4pO1xuICAgICAgICB9LFxuICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBBdm9pZCB0cnlpbmcgdG8gc3RhcnQgdG9vIG1hbnkgcHJvY2Vzc2luZyBvcGVyYXRpb25zLiBUaGlzIGNhbiBvY2N1clxuICAgICAgICAgICAgLy8gd2hlbiBjYWxsYmFja3MgcmVzb2x2ZSBzeW5jaHJvbm91c2x5ICgjMTI2NykuXG4gICAgICAgICAgICBpZiAoaXNQcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlICghcS5wYXVzZWQgJiYgbnVtUnVubmluZyA8IHEuY29uY3VycmVuY3kgJiYgcS5fdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhc2tzID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IHEuX3Rhc2tzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAocS5wYXlsb2FkKSBsID0gTWF0aC5taW4obCwgcS5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHEuX3Rhc2tzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcnNMaXN0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChub2RlLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG51bVJ1bm5pbmcgKz0gMTtcblxuICAgICAgICAgICAgICAgIGlmIChxLl90YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcS5lbXB0eSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChudW1SdW5uaW5nID09PSBxLmNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICAgICAgICAgIHEuc2F0dXJhdGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNiID0gKDAsIF9vbmx5T25jZTIuZGVmYXVsdCkoX25leHQodGFza3MpKTtcbiAgICAgICAgICAgICAgICBfd29ya2VyKGRhdGEsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBxLl90YXNrcy5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIHJ1bm5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1SdW5uaW5nO1xuICAgICAgICB9LFxuICAgICAgICB3b3JrZXJzTGlzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdvcmtlcnNMaXN0O1xuICAgICAgICB9LFxuICAgICAgICBpZGxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcS5fdGFza3MubGVuZ3RoICsgbnVtUnVubmluZyA9PT0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHEucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocS5wYXVzZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcS5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICgwLCBfc2V0SW1tZWRpYXRlMi5kZWZhdWx0KShxLnByb2Nlc3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIi8qIEBmbG93ICovXG4ndXNlIHN0cmljdCdcblxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtJylcblxuLyogOjpcbmltcG9ydCB0eXBlIHtLZXksIERhdGFzdG9yZSwgQmF0Y2gsIFF1ZXJ5LCBRdWVyeVJlc3VsdCwgQ2FsbGJhY2t9IGZyb20gJ2ludGVyZmFjZS1kYXRhc3RvcmUnXG4qL1xuXG4vKipcbiAqIEFuIG9iamVjdCB3aXRoIGEgcGFpciBvZiBmdW5jdGlvbnMgZm9yIChpbnZlcnRpYmx5KSB0cmFuc2Zvcm1pbmcga2V5c1xuICovXG4vKiA6OlxudHlwZSBLZXlUcmFuc2Zvcm0gPSB7XG4gIGNvbnZlcnQ6IEtleU1hcHBpbmcsXG4gIGludmVydDogS2V5TWFwcGluZ1xufVxuKi9cblxuLyoqXG4gKiBNYXAgb25lIGtleSBvbnRvIGFub3RoZXIga2V5LlxuICovXG4vKiA6OlxudHlwZSBLZXlNYXBwaW5nID0gKEtleSkgPT4gS2V5XG4qL1xuXG4vKipcbiAqIEEgZGF0YXN0b3JlIHNoaW0sIHRoYXQgd3JhcHMgYXJvdW5kIGEgZ2l2ZW4gZGF0YXN0b3JlLCBjaGFuZ2luZ1xuICogdGhlIHdheSBrZXlzIGxvb2sgdG8gdGhlIHVzZXIsIGZvciBleGFtcGxlIG5hbWVzcGFjaW5nXG4gKiBrZXlzLCByZXZlcnNpbmcgdGhlbSwgZXRjLlxuICovXG5jbGFzcyBLZXlUcmFuc2Zvcm1EYXRhc3RvcmUgLyogOjogPFZhbHVlPiAqLyB7XG4gIC8qIDo6IGNoaWxkOiBEYXRhc3RvcmU8VmFsdWU+ICovXG4gIC8qIDo6IHRyYW5zZm9ybTogS2V5VHJhbnNmb3JtICovXG5cbiAgY29uc3RydWN0b3IgKGNoaWxkIC8qIDogRGF0YXN0b3JlPFZhbHVlPiAqLywgdHJhbnNmb3JtIC8qIDogS2V5VHJhbnNmb3JtICovKSB7XG4gICAgdGhpcy5jaGlsZCA9IGNoaWxkXG4gICAgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbiAgfVxuXG4gIG9wZW4gKGNhbGxiYWNrIC8qIDogQ2FsbGJhY2s8dm9pZD4gKi8pIC8qIDogdm9pZCAqLyB7XG4gICAgdGhpcy5jaGlsZC5vcGVuKGNhbGxiYWNrKVxuICB9XG5cbiAgcHV0IChrZXkgLyogOiBLZXkgKi8sIHZhbCAvKiA6IFZhbHVlICovLCBjYWxsYmFjayAvKiA6IENhbGxiYWNrPHZvaWQ+ICovKSAvKiA6IHZvaWQgKi8ge1xuICAgIHRoaXMuY2hpbGQucHV0KHRoaXMudHJhbnNmb3JtLmNvbnZlcnQoa2V5KSwgdmFsLCBjYWxsYmFjaylcbiAgfVxuXG4gIGdldCAoa2V5IC8qIDogS2V5ICovLCBjYWxsYmFjayAvKiA6IENhbGxiYWNrPFZhbHVlPiAqLykgLyogOiB2b2lkICovIHtcbiAgICB0aGlzLmNoaWxkLmdldCh0aGlzLnRyYW5zZm9ybS5jb252ZXJ0KGtleSksIGNhbGxiYWNrKVxuICB9XG5cbiAgaGFzIChrZXkgLyogOiBLZXkgKi8sIGNhbGxiYWNrIC8qIDogQ2FsbGJhY2s8Ym9vbD4gKi8pIC8qIDogdm9pZCAqLyB7XG4gICAgdGhpcy5jaGlsZC5oYXModGhpcy50cmFuc2Zvcm0uY29udmVydChrZXkpLCBjYWxsYmFjaylcbiAgfVxuXG4gIGRlbGV0ZSAoa2V5IC8qIDogS2V5ICovLCBjYWxsYmFjayAvKiA6IENhbGxiYWNrPHZvaWQ+ICovKSAvKiA6IHZvaWQgKi8ge1xuICAgIHRoaXMuY2hpbGQuZGVsZXRlKHRoaXMudHJhbnNmb3JtLmNvbnZlcnQoa2V5KSwgY2FsbGJhY2spXG4gIH1cblxuICBiYXRjaCAoKSAvKiA6IEJhdGNoPFZhbHVlPiAqLyB7XG4gICAgY29uc3QgYiA9IHRoaXMuY2hpbGQuYmF0Y2goKVxuICAgIHJldHVybiB7XG4gICAgICBwdXQ6IChrZXkgLyogOiBLZXkgKi8sIHZhbHVlIC8qIDogVmFsdWUgKi8pIC8qIDogdm9pZCAqLyA9PiB7XG4gICAgICAgIGIucHV0KHRoaXMudHJhbnNmb3JtLmNvbnZlcnQoa2V5KSwgdmFsdWUpXG4gICAgICB9LFxuICAgICAgZGVsZXRlOiAoa2V5IC8qIDogS2V5ICovKSAvKiA6IHZvaWQgKi8gPT4ge1xuICAgICAgICBiLmRlbGV0ZSh0aGlzLnRyYW5zZm9ybS5jb252ZXJ0KGtleSkpXG4gICAgICB9LFxuICAgICAgY29tbWl0OiAoY2FsbGJhY2sgLyogOiBDYWxsYmFjazx2b2lkPiAqLykgLyogOiB2b2lkICovID0+IHtcbiAgICAgICAgYi5jb21taXQoY2FsbGJhY2spXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcXVlcnkgKHEgLyogOiBRdWVyeTxWYWx1ZT4gKi8pIC8qIDogUXVlcnlSZXN1bHQ8VmFsdWU+ICovIHtcbiAgICByZXR1cm4gcHVsbChcbiAgICAgIHRoaXMuY2hpbGQucXVlcnkocSksXG4gICAgICBwdWxsLm1hcChlID0+IHtcbiAgICAgICAgZS5rZXkgPSB0aGlzLnRyYW5zZm9ybS5pbnZlcnQoZS5rZXkpXG4gICAgICAgIHJldHVybiBlXG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIGNsb3NlIChjYWxsYmFjayAvKiA6IENhbGxiYWNrPHZvaWQ+ICovKSAvKiA6IHZvaWQgKi8ge1xuICAgIHRoaXMuY2hpbGQuY2xvc2UoY2FsbGJhY2spXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBLZXlUcmFuc2Zvcm1EYXRhc3RvcmVcbiIsIi8qIEBmbG93ICovXG4ndXNlIHN0cmljdCdcblxuY29uc3QgS2V5ID0gcmVxdWlyZSgnaW50ZXJmYWNlLWRhdGFzdG9yZScpLktleVxuY29uc3QgS2V5dHJhbnNmb3JtRGF0YXN0b3JlID0gcmVxdWlyZSgnLi9rZXl0cmFuc2Zvcm0nKVxuXG4vKiA6OlxuaW1wb3J0IHR5cGUge0NhbGxiYWNrLCBEYXRhc3RvcmUsIFF1ZXJ5LCBRdWVyeVJlc3VsdH0gZnJvbSAnaW50ZXJmYWNlLWRhdGFzdG9yZSdcbiovXG5cbi8qKlxuICogV3JhcHMgYSBnaXZlbiBkYXRhc3RvcmUgaW50byBhIGtleXRyYW5zZm9ybSB3aGljaFxuICogbWFrZXMgYSBnaXZlbiBwcmVmaXggdHJhbnNwYXJlbnQuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHRoZSBwcmVmaXggaXMgYG5ldyBLZXkoL2hlbGxvKWAgYSBjYWxsXG4gKiB0byBgc3RvcmUucHV0KG5ldyBLZXkoJy93b3JsZCcpLCBteWRhdGEpYCB3b3VsZCBzdG9yZSB0aGUgZGF0YSB1bmRlclxuICogYC9oZWxsby93b3JsZGAuXG4gKlxuICovXG5jbGFzcyBOYW1lc3BhY2VEYXRhc3RvcmUvKiA6OiA8VmFsdWU+ICovIGV4dGVuZHMgS2V5dHJhbnNmb3JtRGF0YXN0b3JlIC8qIDo6IDxWYWx1ZT4gKi8ge1xuICAvKiA6OiBwcmVmaXg6IEtleSAqL1xuXG4gIGNvbnN0cnVjdG9yIChjaGlsZC8qIDogRGF0YXN0b3JlPFZhbHVlPiAqLywgcHJlZml4LyogOiBLZXkgKi8pIHtcbiAgICBzdXBlcihjaGlsZCwge1xuICAgICAgY29udmVydCAoa2V5LyogOiBLZXkgKi8pLyogOiBLZXkgKi8ge1xuICAgICAgICByZXR1cm4gcHJlZml4LmNoaWxkKGtleSlcbiAgICAgIH0sXG4gICAgICBpbnZlcnQgKGtleS8qIDogS2V5ICovKS8qIDogS2V5ICovIHtcbiAgICAgICAgaWYgKHByZWZpeC50b1N0cmluZygpID09PSAnLycpIHtcbiAgICAgICAgICByZXR1cm4ga2V5XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByZWZpeC5pc0FuY2VzdG9yT2Yoa2V5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgcHJlZml4OiAoJHtwcmVmaXgudG9TdHJpbmcoKX0pIGluIGtleTogJHtrZXkudG9TdHJpbmcoKX1gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBLZXkoa2V5LnRvU3RyaW5nKCkuc2xpY2UocHJlZml4LnRvU3RyaW5nKCkubGVuZ3RoKSwgZmFsc2UpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMucHJlZml4ID0gcHJlZml4XG4gIH1cblxuICBxdWVyeSAocSAvKiA6IFF1ZXJ5PFZhbHVlPiAqLykvKiA6IFF1ZXJ5UmVzdWx0PFZhbHVlPiAqLyB7XG4gICAgaWYgKHEucHJlZml4ICYmIHRoaXMucHJlZml4LnRvU3RyaW5nKCkgIT09ICcvJykge1xuICAgICAgcmV0dXJuIHN1cGVyLnF1ZXJ5KE9iamVjdC5hc3NpZ24oe30sIHEsIHtcbiAgICAgICAgcHJlZml4OiB0aGlzLnByZWZpeC5jaGlsZChuZXcgS2V5KHEucHJlZml4KSkudG9TdHJpbmcoKVxuICAgICAgfSkpXG4gICAgfVxuICAgIHJldHVybiBzdXBlci5xdWVyeShxKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTmFtZXNwYWNlRGF0YXN0b3JlXG4iLCIvKiBAZmxvdyAqL1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEtleSA9IHJlcXVpcmUoJ2ludGVyZmFjZS1kYXRhc3RvcmUnKS5LZXlcblxuY29uc3QgcmVhZG1lID0gcmVxdWlyZSgnLi9zaGFyZC1yZWFkbWUnKVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbi8qOjogaW1wb3J0IHR5cGUge0RhdGFzdG9yZSwgQ2FsbGJhY2t9IGZyb20gJ2ludGVyZmFjZS1kYXRhc3RvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hhcmRWMSB7XG4gIG5hbWU6IHN0cmluZztcbiAgcGFyYW06IG51bWJlcjtcbiAgZnVuKHN0cmluZyk6IHN0cmluZztcbiAgdG9TdHJpbmcoKTogc3RyaW5nO1xufVxuKi9cblxuY29uc3QgUFJFRklYID0gZXhwb3J0cy5QUkVGSVggPSAnL3JlcG8vZmxhdGZzL3NoYXJkLydcbmNvbnN0IFNIQVJESU5HX0ZOID0gZXhwb3J0cy5TSEFSRElOR19GTiA9ICdTSEFSRElORydcbmV4cG9ydHMuUkVBRE1FX0ZOID0gJ19SRUFETUUnXG5cbmNsYXNzIFNoYXJkIHtcbiAgLyogOjogbmFtZTogc3RyaW5nICovXG4gIC8qIDo6IHBhcmFtOiBudW1iZXIgKi9cbiAgLyogOjogX3BhZGRpbmc6IHN0cmluZyAqL1xuXG4gIGNvbnN0cnVjdG9yIChwYXJhbSAvKiA6IG51bWJlciAqLykge1xuICAgIHRoaXMucGFyYW0gPSBwYXJhbVxuICB9XG5cbiAgZnVuIChzdHIgLyogOiBzdHJpbmcgKi8pIC8qIDogc3RyaW5nICovIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ltcGxlbWVudCBtZScpXG4gIH1cblxuICB0b1N0cmluZyAoKSAvKiA6IHN0cmluZyAqLyB7XG4gICAgcmV0dXJuIGAke1BSRUZJWH12MS8ke3RoaXMubmFtZX0vJHt0aGlzLnBhcmFtfWBcbiAgfVxufVxuXG5jbGFzcyBQcmVmaXggZXh0ZW5kcyBTaGFyZCB7XG4gIGNvbnN0cnVjdG9yIChwcmVmaXhMZW4gLyogOiBudW1iZXIgKi8pIHtcbiAgICBzdXBlcihwcmVmaXhMZW4pXG4gICAgdGhpcy5fcGFkZGluZyA9ICcnLnBhZFN0YXJ0KHByZWZpeExlbiwgJ18nKVxuICAgIHRoaXMubmFtZSA9ICdwcmVmaXgnXG4gIH1cblxuICBmdW4gKG5vc2xhc2ggLyogOiBzdHJpbmcgKi8pIC8qIDogc3RyaW5nICovIHtcbiAgICByZXR1cm4gKG5vc2xhc2ggKyB0aGlzLl9wYWRkaW5nKS5zbGljZSgwLCB0aGlzLnBhcmFtKVxuICB9XG59XG5cbmNsYXNzIFN1ZmZpeCBleHRlbmRzIFNoYXJkIHtcbiAgY29uc3RydWN0b3IgKHN1ZmZpeExlbiAvKiA6IG51bWJlciAqLykge1xuICAgIHN1cGVyKHN1ZmZpeExlbilcbiAgICB0aGlzLl9wYWRkaW5nID0gJycucGFkU3RhcnQoc3VmZml4TGVuLCAnXycpXG4gICAgdGhpcy5uYW1lID0gJ3N1ZmZpeCdcbiAgfVxuXG4gIGZ1biAobm9zbGFzaCAvKiA6IHN0cmluZyAqLykgLyogOiBzdHJpbmcgKi8ge1xuICAgIGNvbnN0IHMgPSB0aGlzLl9wYWRkaW5nICsgbm9zbGFzaFxuICAgIHJldHVybiBzLnNsaWNlKHMubGVuZ3RoIC0gdGhpcy5wYXJhbSlcbiAgfVxufVxuXG5jbGFzcyBOZXh0VG9MYXN0IGV4dGVuZHMgU2hhcmQge1xuICBjb25zdHJ1Y3RvciAoc3VmZml4TGVuIC8qIDogbnVtYmVyICovKSB7XG4gICAgc3VwZXIoc3VmZml4TGVuKVxuICAgIHRoaXMuX3BhZGRpbmcgPSAnJy5wYWRTdGFydChzdWZmaXhMZW4gKyAxLCAnXycpXG4gICAgdGhpcy5uYW1lID0gJ25leHQtdG8tbGFzdCdcbiAgfVxuXG4gIGZ1biAobm9zbGFzaCAvKiA6IHN0cmluZyAqLykgLyogOiBzdHJpbmcgKi8ge1xuICAgIGNvbnN0IHMgPSB0aGlzLl9wYWRkaW5nICsgbm9zbGFzaFxuICAgIGNvbnN0IG9mZnNldCA9IHMubGVuZ3RoIC0gdGhpcy5wYXJhbSAtIDFcbiAgICByZXR1cm4gcy5zbGljZShvZmZzZXQsIG9mZnNldCArIHRoaXMucGFyYW0pXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgZ2l2ZW4gc3RyaW5nIHRvIHRoZSBtYXRjaGluZyBzaGFyZGluZyBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U2hhcmRWMX1cbiAqL1xuZnVuY3Rpb24gcGFyc2VTaGFyZEZ1biAoc3RyIC8qIDogc3RyaW5nICovKSAvKiA6IFNoYXJkVjEgKi8ge1xuICBzdHIgPSBzdHIudHJpbSgpXG5cbiAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VtcHR5IHNoYXJkIHN0cmluZycpXG4gIH1cblxuICBpZiAoIXN0ci5zdGFydHNXaXRoKFBSRUZJWCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3Igbm8gcGF0aCBwcmVmaXg6ICR7c3RyfWApXG4gIH1cblxuICBjb25zdCBwYXJ0cyA9IHN0ci5zbGljZShQUkVGSVgubGVuZ3RoKS5zcGxpdCgnLycpXG4gIGNvbnN0IHZlcnNpb24gPSBwYXJ0c1swXVxuXG4gIGlmICh2ZXJzaW9uICE9PSAndjEnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3QgJ3YxJyB2ZXJzaW9uLCBnb3QgJyR7dmVyc2lvbn0nYClcbiAgfVxuXG4gIGNvbnN0IG5hbWUgPSBwYXJ0c1sxXVxuXG4gIGlmICghcGFydHNbMl0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcGFyYW0nKVxuICB9XG5cbiAgY29uc3QgcGFyYW0gPSBwYXJzZUludChwYXJ0c1syXSwgMTApXG5cbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAncHJlZml4JzpcbiAgICAgIHJldHVybiBuZXcgUHJlZml4KHBhcmFtKVxuICAgIGNhc2UgJ3N1ZmZpeCc6XG4gICAgICByZXR1cm4gbmV3IFN1ZmZpeChwYXJhbSlcbiAgICBjYXNlICduZXh0LXRvLWxhc3QnOlxuICAgICAgcmV0dXJuIG5ldyBOZXh0VG9MYXN0KHBhcmFtKVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua293biBzaGFyZGluZyBmdW5jdGlvbjogJHtuYW1lfWApXG4gIH1cbn1cblxuZXhwb3J0cy5yZWFkU2hhcmRGdW4gPSAocGF0aCAvKiA6IHN0cmluZyAqLywgc3RvcmUgLyogOiBEYXRhc3RvcmU8QnVmZmVyPiAqLywgY2FsbGJhY2sgLyogOiBDYWxsYmFjazxTaGFyZFYxPiAqLykgLyogOiB2b2lkICovID0+IHtcbiAgY29uc3Qga2V5ID0gbmV3IEtleShwYXRoKS5jaGlsZChuZXcgS2V5KFNIQVJESU5HX0ZOKSlcbiAgY29uc3QgZ2V0ID0gdHlwZW9mIHN0b3JlLmdldFJhdyA9PT0gJ2Z1bmN0aW9uJyA/IHN0b3JlLmdldFJhdy5iaW5kKHN0b3JlKSA6IHN0b3JlLmdldC5iaW5kKHN0b3JlKVxuXG4gIGdldChrZXksIChlcnIsIHJlcykgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuXG4gICAgbGV0IHNoYXJkXG4gICAgdHJ5IHtcbiAgICAgIHNoYXJkID0gcGFyc2VTaGFyZEZ1bigocmVzIHx8ICcnKS50b1N0cmluZygpLnRyaW0oKSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgc2hhcmQpXG4gIH0pXG59XG5cbmV4cG9ydHMucmVhZG1lID0gcmVhZG1lXG5leHBvcnRzLnBhcnNlU2hhcmRGdW4gPSBwYXJzZVNoYXJkRnVuXG5leHBvcnRzLlByZWZpeCA9IFByZWZpeFxuZXhwb3J0cy5TdWZmaXggPSBTdWZmaXhcbmV4cG9ydHMuTmV4dFRvTGFzdCA9IE5leHRUb0xhc3RcbiIsIi8qIEBmbG93ICovXG4ndXNlIHN0cmljdCdcblxuY29uc3Qgd2F0ZXJmYWxsID0gcmVxdWlyZSgnYXN5bmMvd2F0ZXJmYWxsJylcbmNvbnN0IHBhcmFsbGVsID0gcmVxdWlyZSgnYXN5bmMvcGFyYWxsZWwnKVxuY29uc3QgS2V5ID0gcmVxdWlyZSgnaW50ZXJmYWNlLWRhdGFzdG9yZScpLktleVxuXG5jb25zdCBzaCA9IHJlcXVpcmUoJy4vc2hhcmQnKVxuY29uc3QgS2V5dHJhbnNmb3JtU3RvcmUgPSByZXF1aXJlKCcuL2tleXRyYW5zZm9ybScpXG5cbmNvbnN0IHNoYXJkS2V5ID0gbmV3IEtleShzaC5TSEFSRElOR19GTilcbmNvbnN0IHNoYXJkUmVhZG1lS2V5ID0gbmV3IEtleShzaC5SRUFETUVfRk4pXG5cbi8qIDo6XG5pbXBvcnQgdHlwZSB7RGF0YXN0b3JlLCBCYXRjaCwgUXVlcnksIFF1ZXJ5UmVzdWx0LCBDYWxsYmFja30gZnJvbSAnaW50ZXJmYWNlLWRhdGFzdG9yZSdcblxuaW1wb3J0IHR5cGUge1NoYXJkVjF9IGZyb20gJy4vc2hhcmQnXG4qL1xuXG4vKipcbiAqIEJhY2tlbmQgaW5kZXBlbmRlbnQgYWJzdHJhY3Rpb24gb2YgZ28tZHMtZmxhdGZzLlxuICpcbiAqIFdyYXBzIGFub3RoZXIgZGF0YXN0b3JlIHN1Y2ggdGhhdCBhbGwgdmFsdWVzIGFyZSBzdG9yZWRcbiAqIHNoYXJkZWQgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBzaGFyZGluZyBmdW5jdGlvbi5cbiAqL1xuY2xhc3MgU2hhcmRpbmdEYXRhc3RvcmUge1xuICAvKiA6OiBzaGFyZDogU2hhcmRWMSAqL1xuICAvKiA6OiBjaGlsZDogRGF0YXN0b3JlPEJ1ZmZlcj4gKi9cblxuICBjb25zdHJ1Y3RvciAoc3RvcmUgLyogOiBEYXRhc3RvcmU8QnVmZmVyPiAqLywgc2hhcmQgLyogOiBTaGFyZFYxICovKSB7XG4gICAgdGhpcy5jaGlsZCA9IG5ldyBLZXl0cmFuc2Zvcm1TdG9yZShzdG9yZSwge1xuICAgICAgY29udmVydDogdGhpcy5fY29udmVydEtleS5iaW5kKHRoaXMpLFxuICAgICAgaW52ZXJ0OiB0aGlzLl9pbnZlcnRLZXkuYmluZCh0aGlzKVxuICAgIH0pXG4gICAgdGhpcy5zaGFyZCA9IHNoYXJkXG4gIH1cblxuICBvcGVuIChjYWxsYmFjayAvKiA6IENhbGxiYWNrPHZvaWQ+ICovKSAvKiA6IHZvaWQgKi8ge1xuICAgIHRoaXMuY2hpbGQub3BlbihjYWxsYmFjaylcbiAgfVxuXG4gIF9jb252ZXJ0S2V5IChrZXkvKiA6IEtleSAqLykvKiA6IEtleSAqLyB7XG4gICAgY29uc3QgcyA9IGtleS50b1N0cmluZygpXG4gICAgaWYgKHMgPT09IHNoYXJkS2V5LnRvU3RyaW5nKCkgfHwgcyA9PT0gc2hhcmRSZWFkbWVLZXkudG9TdHJpbmcoKSkge1xuICAgICAgcmV0dXJuIGtleVxuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudCA9IG5ldyBLZXkodGhpcy5zaGFyZC5mdW4ocykpXG4gICAgcmV0dXJuIHBhcmVudC5jaGlsZChrZXkpXG4gIH1cblxuICBfaW52ZXJ0S2V5IChrZXkvKiA6IEtleSAqLykvKiA6IEtleSAqLyB7XG4gICAgY29uc3QgcyA9IGtleS50b1N0cmluZygpXG4gICAgaWYgKHMgPT09IHNoYXJkS2V5LnRvU3RyaW5nKCkgfHwgcyA9PT0gc2hhcmRSZWFkbWVLZXkudG9TdHJpbmcoKSkge1xuICAgICAgcmV0dXJuIGtleVxuICAgIH1cbiAgICByZXR1cm4gS2V5LndpdGhOYW1lc3BhY2VzKGtleS5saXN0KCkuc2xpY2UoMSkpXG4gIH1cblxuICBzdGF0aWMgY3JlYXRlT3JPcGVuIChzdG9yZSAvKiA6IERhdGFzdG9yZTxCdWZmZXI+ICovLCBzaGFyZCAvKiA6IFNoYXJkVjEgKi8sIGNhbGxiYWNrIC8qIDogQ2FsbGJhY2s8U2hhcmRpbmdEYXRhc3RvcmU+ICovKSAvKiA6IHZvaWQgKi8ge1xuICAgIFNoYXJkaW5nRGF0YXN0b3JlLmNyZWF0ZShzdG9yZSwgc2hhcmQsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlICE9PSAnZGF0YXN0b3JlIGV4aXN0cycpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgU2hhcmRpbmdEYXRhc3RvcmUub3BlbihzdG9yZSwgY2FsbGJhY2spXG4gICAgfSlcbiAgfVxuXG4gIHN0YXRpYyBvcGVuIChzdG9yZSAvKiA6IERhdGFzdG9yZTxCdWZmZXI+ICovLCBjYWxsYmFjayAvKiA6IENhbGxiYWNrPFNoYXJkaW5nRGF0YXN0b3JlPiAqLykgLyogOiB2b2lkICovIHtcbiAgICB3YXRlcmZhbGwoW1xuICAgICAgKGNiKSA9PiBzaC5yZWFkU2hhcmRGdW4oJy8nLCBzdG9yZSwgY2IpLFxuICAgICAgKHNoYXJkLCBjYikgPT4ge1xuICAgICAgICBjYihudWxsLCBuZXcgU2hhcmRpbmdEYXRhc3RvcmUoc3RvcmUsIHNoYXJkKSlcbiAgICAgIH1cbiAgICBdLCBjYWxsYmFjaylcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGUgKHN0b3JlIC8qIDogRGF0YXN0b3JlPEJ1ZmZlcj4gKi8sIHNoYXJkIC8qIDogU2hhcmRWMSAqLywgY2FsbGJhY2sgLyogOiBDYWxsYmFjazx2b2lkPiAqLykgLyogOiB2b2lkICovIHtcbiAgICBzdG9yZS5oYXMoc2hhcmRLZXksIChlcnIsIGV4aXN0cykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICBjb25zdCBwdXQgPSB0eXBlb2Ygc3RvcmUucHV0UmF3ID09PSAnZnVuY3Rpb24nID8gc3RvcmUucHV0UmF3LmJpbmQoc3RvcmUpIDogc3RvcmUucHV0LmJpbmQoc3RvcmUpXG4gICAgICAgIHJldHVybiBwYXJhbGxlbChbXG4gICAgICAgICAgKGNiKSA9PiBwdXQoc2hhcmRLZXksIEJ1ZmZlci5mcm9tKHNoYXJkLnRvU3RyaW5nKCkgKyAnXFxuJyksIGNiKSxcbiAgICAgICAgICAoY2IpID0+IHB1dChzaGFyZFJlYWRtZUtleSwgQnVmZmVyLmZyb20oc2gucmVhZG1lKSwgY2IpXG4gICAgICAgIF0sIGVyciA9PiBjYWxsYmFjayhlcnIpKVxuICAgICAgfVxuXG4gICAgICBzaC5yZWFkU2hhcmRGdW4oJy8nLCBzdG9yZSwgKGVyciwgZGlza1NoYXJkKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYSA9IChkaXNrU2hhcmQgfHwgJycpLnRvU3RyaW5nKClcbiAgICAgICAgY29uc3QgYiA9IHNoYXJkLnRvU3RyaW5nKClcbiAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKGBzcGVjaWZpZWQgZnVuICR7Yn0gZG9lcyBub3QgbWF0Y2ggcmVwbyBzaGFyZCBmdW4gJHthfWApKVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdkYXRhc3RvcmUgZXhpc3RzJykpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBwdXQgKGtleSAvKiA6IEtleSAqLywgdmFsIC8qIDogQnVmZmVyICovLCBjYWxsYmFjayAvKiA6IENhbGxiYWNrPHZvaWQ+ICovKSAvKiA6IHZvaWQgKi8ge1xuICAgIHRoaXMuY2hpbGQucHV0KGtleSwgdmFsLCBjYWxsYmFjaylcbiAgfVxuXG4gIGdldCAoa2V5IC8qIDogS2V5ICovLCBjYWxsYmFjayAvKiA6IENhbGxiYWNrPEJ1ZmZlcj4gKi8pIC8qIDogdm9pZCAqLyB7XG4gICAgdGhpcy5jaGlsZC5nZXQoa2V5LCBjYWxsYmFjaylcbiAgfVxuXG4gIGhhcyAoa2V5IC8qIDogS2V5ICovLCBjYWxsYmFjayAvKiA6IENhbGxiYWNrPGJvb2w+ICovKSAvKiA6IHZvaWQgKi8ge1xuICAgIHRoaXMuY2hpbGQuaGFzKGtleSwgY2FsbGJhY2spXG4gIH1cblxuICBkZWxldGUgKGtleSAvKiA6IEtleSAqLywgY2FsbGJhY2sgLyogOiBDYWxsYmFjazx2b2lkPiAqLykgLyogOiB2b2lkICovIHtcbiAgICB0aGlzLmNoaWxkLmRlbGV0ZShrZXksIGNhbGxiYWNrKVxuICB9XG5cbiAgYmF0Y2ggKCkgLyogOiBCYXRjaDxCdWZmZXI+ICovIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZC5iYXRjaCgpXG4gIH1cblxuICBxdWVyeSAocSAvKiA6IFF1ZXJ5PEJ1ZmZlcj4gKi8pIC8qIDogUXVlcnlSZXN1bHQ8QnVmZmVyPiAqLyB7XG4gICAgY29uc3QgdHEvKiA6IFF1ZXJ5PEJ1ZmZlcj4gKi8gPSB7XG4gICAgICBrZXlzT25seTogcS5rZXlzT25seSxcbiAgICAgIG9mZnNldDogcS5vZmZzZXQsXG4gICAgICBsaW1pdDogcS5saW1pdCxcbiAgICAgIGZpbHRlcnM6IFtcbiAgICAgICAgKGUsIGNiKSA9PiBjYihudWxsLCBlLmtleS50b1N0cmluZygpICE9PSBzaGFyZEtleS50b1N0cmluZygpKSxcbiAgICAgICAgKGUsIGNiKSA9PiBjYihudWxsLCBlLmtleS50b1N0cmluZygpICE9PSBzaGFyZFJlYWRtZUtleS50b1N0cmluZygpKVxuICAgICAgXVxuICAgIH1cblxuICAgIGlmIChxLnByZWZpeCAhPSBudWxsKSB7XG4gICAgICB0cS5maWx0ZXJzLnB1c2goKGUsIGNiKSA9PiB7XG4gICAgICAgIGNiKG51bGwsIHRoaXMuX2ludmVydEtleShlLmtleSkudG9TdHJpbmcoKS5zdGFydHNXaXRoKHEucHJlZml4KSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHEuZmlsdGVycyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBmaWx0ZXJzID0gcS5maWx0ZXJzLm1hcCgoZikgPT4gKGUsIGNiKSA9PiB7XG4gICAgICAgIGYoT2JqZWN0LmFzc2lnbih7fSwgZSwge1xuICAgICAgICAgIGtleTogdGhpcy5faW52ZXJ0S2V5KGUua2V5KVxuICAgICAgICB9KSwgY2IpXG4gICAgICB9KVxuICAgICAgdHEuZmlsdGVycyA9IHRxLmZpbHRlcnMuY29uY2F0KGZpbHRlcnMpXG4gICAgfVxuXG4gICAgaWYgKHEub3JkZXJzICE9IG51bGwpIHtcbiAgICAgIHRxLm9yZGVycyA9IHEub3JkZXJzLm1hcCgobykgPT4gKHJlcywgY2IpID0+IHtcbiAgICAgICAgcmVzLmZvckVhY2goKGUpID0+IHsgZS5rZXkgPSB0aGlzLl9pbnZlcnRLZXkoZS5rZXkpIH0pXG4gICAgICAgIG8ocmVzLCAoZXJyLCBvcmRlcmVkKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgb3JkZXJlZC5mb3JFYWNoKChlKSA9PiB7IGUua2V5ID0gdGhpcy5fY29udmVydEtleShlLmtleSkgfSlcbiAgICAgICAgICBjYihudWxsLCBvcmRlcmVkKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGlsZC5xdWVyeSh0cSlcbiAgfVxuXG4gIGNsb3NlIChjYWxsYmFjayAvKiA6IENhbGxiYWNrPHZvaWQ+ICovKSAvKiA6IHZvaWQgKi8ge1xuICAgIHRoaXMuY2hpbGQuY2xvc2UoY2FsbGJhY2spXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGFyZGluZ0RhdGFzdG9yZVxuIiwiLyogQGZsb3cgKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBlYWNoID0gcmVxdWlyZSgnYXN5bmMvZWFjaCcpXG5jb25zdCBtYW55ID0gcmVxdWlyZSgncHVsbC1tYW55JylcbmNvbnN0IHB1bGwgPSByZXF1aXJlKCdwdWxsLXN0cmVhbScpXG5cbmNvbnN0IEtleSA9IHJlcXVpcmUoJ2ludGVyZmFjZS1kYXRhc3RvcmUnKS5LZXlcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJ2ludGVyZmFjZS1kYXRhc3RvcmUnKS5FcnJvcnNcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnaW50ZXJmYWNlLWRhdGFzdG9yZScpLnV0aWxzXG5jb25zdCBhc3luY0ZpbHRlciA9IHV0aWxzLmFzeW5jRmlsdGVyXG5jb25zdCBhc3luY1NvcnQgPSB1dGlscy5hc3luY1NvcnRcbmNvbnN0IHJlcGxhY2VTdGFydFdpdGggPSB1dGlscy5yZXBsYWNlU3RhcnRXaXRoXG5cbmNvbnN0IEtleXRyYW5zZm9ybSA9IHJlcXVpcmUoJy4va2V5dHJhbnNmb3JtJylcblxuLyogOjpcbmltcG9ydCB0eXBlIHtEYXRhc3RvcmUsIENhbGxiYWNrLCBCYXRjaCwgUXVlcnksIFF1ZXJ5UmVzdWx0fSBmcm9tICdpbnRlcmZhY2UtZGF0YXN0b3JlJ1xuXG50eXBlIE1vdW50PFZhbHVlPiA9IHtcbiAgcHJlZml4OiBLZXksXG4gIGRhdGFzdG9yZTogRGF0YXN0b3JlPFZhbHVlPlxufVxuKi9cblxuLyoqXG4gKiBBIGRhdGFzdG9yZSB0aGF0IGNhbiBjb21iaW5lIG11bHRpcGxlIHN0b3JlcyBpbnNpZGUgdmFyaW91c1xuICoga2V5IHByZWZpeHMuXG4gKi9cbmNsYXNzIE1vdW50RGF0YXN0b3JlIC8qIDo6IDxWYWx1ZT4gKi8ge1xuICAvKiA6OiBtb3VudHM6IEFycmF5PE1vdW50PFZhbHVlPj4gKi9cblxuICBjb25zdHJ1Y3RvciAobW91bnRzIC8qIDogQXJyYXk8TW91bnQ8VmFsdWU+PiAqLykge1xuICAgIHRoaXMubW91bnRzID0gbW91bnRzLnNsaWNlKClcbiAgfVxuXG4gIG9wZW4gKGNhbGxiYWNrIC8qIDogQ2FsbGJhY2s8dm9pZD4gKi8pIC8qIDogdm9pZCAqLyB7XG4gICAgZWFjaCh0aGlzLm1vdW50cywgKG0sIGNiKSA9PiB7XG4gICAgICBtLmRhdGFzdG9yZS5vcGVuKGNiKVxuICAgIH0sIGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIExvb2t1cCB0aGUgbWF0Y2hpbmcgZGF0YXN0b3JlIGZvciB0aGUgZ2l2ZW4ga2V5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0tleX0ga2V5XG4gICAqIEByZXR1cm5zIHt7RGF0YXN0b3JlLCBLZXksIEtleX19XG4gICAqL1xuICBfbG9va3VwIChrZXkgLyogOiBLZXkgKi8pIC8qIDogP3tkYXRhc3RvcmU6IERhdGFzdG9yZTxWYWx1ZT4sIG1vdW50cG9pbnQ6IEtleSwgcmVzdDogS2V5fSAqLyB7XG4gICAgZm9yIChsZXQgbW91bnQgb2YgdGhpcy5tb3VudHMpIHtcbiAgICAgIGlmIChtb3VudC5wcmVmaXgudG9TdHJpbmcoKSA9PT0ga2V5LnRvU3RyaW5nKCkgfHwgbW91bnQucHJlZml4LmlzQW5jZXN0b3JPZihrZXkpKSB7XG4gICAgICAgIGNvbnN0IHMgPSByZXBsYWNlU3RhcnRXaXRoKGtleS50b1N0cmluZygpLCBtb3VudC5wcmVmaXgudG9TdHJpbmcoKSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhc3RvcmU6IG1vdW50LmRhdGFzdG9yZSxcbiAgICAgICAgICBtb3VudHBvaW50OiBtb3VudC5wcmVmaXgsXG4gICAgICAgICAgcmVzdDogbmV3IEtleShzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHV0IChrZXkgLyogOiBLZXkgKi8sIHZhbHVlIC8qIDogVmFsdWUgKi8sIGNhbGxiYWNrIC8qIDogQ2FsbGJhY2s8dm9pZD4gKi8pIC8qIDogdm9pZCAqLyB7XG4gICAgY29uc3QgbWF0Y2ggPSB0aGlzLl9sb29rdXAoa2V5KVxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soXG4gICAgICAgIEVycm9ycy5kYldyaXRlRmFpbGVkRXJyb3IobmV3IEVycm9yKCdObyBkYXRhc3RvcmUgbW91bnRlZCBmb3IgdGhpcyBrZXknKSlcbiAgICAgIClcbiAgICB9XG5cbiAgICBtYXRjaC5kYXRhc3RvcmUucHV0KG1hdGNoLnJlc3QsIHZhbHVlLCBjYWxsYmFjaylcbiAgfVxuXG4gIGdldCAoa2V5IC8qIDogS2V5ICovLCBjYWxsYmFjayAvKiA6IENhbGxiYWNrPFZhbHVlPiAqLykgLyogOiB2b2lkICovIHtcbiAgICBjb25zdCBtYXRjaCA9IHRoaXMuX2xvb2t1cChrZXkpXG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhcbiAgICAgICAgRXJyb3JzLm5vdEZvdW5kRXJyb3IobmV3IEVycm9yKCdObyBkYXRhc3RvcmUgbW91bnRlZCBmb3IgdGhpcyBrZXknKSlcbiAgICAgIClcbiAgICB9XG5cbiAgICBtYXRjaC5kYXRhc3RvcmUuZ2V0KG1hdGNoLnJlc3QsIGNhbGxiYWNrKVxuICB9XG5cbiAgaGFzIChrZXkgLyogOiBLZXkgKi8sIGNhbGxiYWNrIC8qIDogQ2FsbGJhY2s8Ym9vbD4gKi8pIC8qIDogdm9pZCAqLyB7XG4gICAgY29uc3QgbWF0Y2ggPSB0aGlzLl9sb29rdXAoa2V5KVxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhudWxsLCBmYWxzZSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIG1hdGNoLmRhdGFzdG9yZS5oYXMobWF0Y2gucmVzdCwgY2FsbGJhY2spXG4gIH1cblxuICBkZWxldGUgKGtleSAvKiA6IEtleSAqLywgY2FsbGJhY2sgLyogOiBDYWxsYmFjazx2b2lkPiAqLykgLyogOiB2b2lkICovIHtcbiAgICBjb25zdCBtYXRjaCA9IHRoaXMuX2xvb2t1cChrZXkpXG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhcbiAgICAgICAgRXJyb3JzLmRiRGVsZXRlRmFpbGVkRXJyb3IobmV3IEVycm9yKCdObyBkYXRhc3RvcmUgbW91bnRlZCBmb3IgdGhpcyBrZXknKSlcbiAgICAgIClcbiAgICB9XG5cbiAgICBtYXRjaC5kYXRhc3RvcmUuZGVsZXRlKG1hdGNoLnJlc3QsIGNhbGxiYWNrKVxuICB9XG5cbiAgY2xvc2UgKGNhbGxiYWNrIC8qIDogQ2FsbGJhY2s8dm9pZD4gKi8pIC8qIDogdm9pZCAqLyB7XG4gICAgZWFjaCh0aGlzLm1vdW50cywgKG0sIGNiKSA9PiB7XG4gICAgICBtLmRhdGFzdG9yZS5jbG9zZShjYilcbiAgICB9LCBjYWxsYmFjaylcbiAgfVxuXG4gIGJhdGNoICgpIC8qIDogQmF0Y2g8VmFsdWU+ICovIHtcbiAgICBjb25zdCBiYXRjaE1vdW50cyA9IHt9XG4gICAgY29uc3QgbG9va3VwID0gKGtleSAvKiA6IEtleSAqLykgLyogOiB7YmF0Y2g6IEJhdGNoPFZhbHVlPiwgcmVzdDogS2V5fSAqLyA9PiB7XG4gICAgICBjb25zdCBtYXRjaCA9IHRoaXMuX2xvb2t1cChrZXkpXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRhdGFzdG9yZSBtb3VudGVkIGZvciB0aGlzIGtleScpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG0gPSBtYXRjaC5tb3VudHBvaW50LnRvU3RyaW5nKClcbiAgICAgIGlmIChiYXRjaE1vdW50c1ttXSA9PSBudWxsKSB7XG4gICAgICAgIGJhdGNoTW91bnRzW21dID0gbWF0Y2guZGF0YXN0b3JlLmJhdGNoKClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmF0Y2g6IGJhdGNoTW91bnRzW21dLFxuICAgICAgICByZXN0OiBtYXRjaC5yZXN0XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHB1dDogKGtleSAvKiA6IEtleSAqLywgdmFsdWUgLyogOiBWYWx1ZSAqLykgLyogOiB2b2lkICovID0+IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBsb29rdXAoa2V5KVxuICAgICAgICBtYXRjaC5iYXRjaC5wdXQobWF0Y2gucmVzdCwgdmFsdWUpXG4gICAgICB9LFxuICAgICAgZGVsZXRlOiAoa2V5IC8qIDogS2V5ICovKSAvKiA6IHZvaWQgKi8gPT4ge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGxvb2t1cChrZXkpXG4gICAgICAgIG1hdGNoLmJhdGNoLmRlbGV0ZShtYXRjaC5yZXN0KVxuICAgICAgfSxcbiAgICAgIGNvbW1pdDogKGNhbGxiYWNrIC8qIDogQ2FsbGJhY2s8dm9pZD4gKi8pIC8qIDogdm9pZCAqLyA9PiB7XG4gICAgICAgIGVhY2goT2JqZWN0LmtleXMoYmF0Y2hNb3VudHMpLCAocCwgY2IpID0+IHtcbiAgICAgICAgICBiYXRjaE1vdW50c1twXS5jb21taXQoY2IpXG4gICAgICAgIH0sIGNhbGxiYWNrKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHF1ZXJ5IChxIC8qIDogUXVlcnk8VmFsdWU+ICovKSAvKiA6IFF1ZXJ5UmVzdWx0PFZhbHVlPiAqLyB7XG4gICAgY29uc3QgcXMgPSB0aGlzLm1vdW50cy5tYXAobSA9PiB7XG4gICAgICBjb25zdCBrcyA9IG5ldyBLZXl0cmFuc2Zvcm0obS5kYXRhc3RvcmUsIHtcbiAgICAgICAgY29udmVydDogKGtleSAvKiA6IEtleSAqLykgLyogOiBLZXkgKi8gPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2hvdWxkIG5ldmVyIGJlIGNhbGxlZCcpXG4gICAgICAgIH0sXG4gICAgICAgIGludmVydDogKGtleSAvKiA6IEtleSAqLykgLyogOiBLZXkgKi8gPT4ge1xuICAgICAgICAgIHJldHVybiBtLnByZWZpeC5jaGlsZChrZXkpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGxldCBwcmVmaXhcbiAgICAgIGlmIChxLnByZWZpeCAhPSBudWxsKSB7XG4gICAgICAgIHByZWZpeCA9IHJlcGxhY2VTdGFydFdpdGgocS5wcmVmaXgsIG0ucHJlZml4LnRvU3RyaW5nKCkpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBrcy5xdWVyeSh7XG4gICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICBmaWx0ZXJzOiBxLmZpbHRlcnMsXG4gICAgICAgIGtleXNPbmx5OiBxLmtleXNPbmx5XG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBsZXQgdGFza3MgPSBbbWFueShxcyldXG5cbiAgICBpZiAocS5maWx0ZXJzICE9IG51bGwpIHtcbiAgICAgIHRhc2tzID0gdGFza3MuY29uY2F0KHEuZmlsdGVycy5tYXAoZiA9PiBhc3luY0ZpbHRlcihmKSkpXG4gICAgfVxuXG4gICAgaWYgKHEub3JkZXJzICE9IG51bGwpIHtcbiAgICAgIHRhc2tzID0gdGFza3MuY29uY2F0KHEub3JkZXJzLm1hcChvID0+IGFzeW5jU29ydChvKSkpXG4gICAgfVxuXG4gICAgaWYgKHEub2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgIGxldCBpID0gMFxuICAgICAgdGFza3MucHVzaChwdWxsLmZpbHRlcigoKSA9PiBpKysgPj0gcS5vZmZzZXQpKVxuICAgIH1cblxuICAgIGlmIChxLmxpbWl0ICE9IG51bGwpIHtcbiAgICAgIHRhc2tzLnB1c2gocHVsbC50YWtlKHEubGltaXQpKVxuICAgIH1cblxuICAgIHJldHVybiBwdWxsLmFwcGx5KG51bGwsIHRhc2tzKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW91bnREYXRhc3RvcmVcbiIsIi8qIEBmbG93ICovXG4ndXNlIHN0cmljdCdcblxuY29uc3QgZWFjaCA9IHJlcXVpcmUoJ2FzeW5jL2VhY2gnKVxuY29uc3Qgd2hpbHN0ID0gcmVxdWlyZSgnYXN5bmMvd2hpbHN0JylcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJ2ludGVyZmFjZS1kYXRhc3RvcmUnKS5FcnJvcnNcblxuLyogOjpcbmltcG9ydCB0eXBlIHtLZXksIERhdGFzdG9yZSwgQ2FsbGJhY2ssIEJhdGNoLCBRdWVyeSwgUXVlcnlSZXN1bHR9IGZyb20gJ2ludGVyZmFjZS1kYXRhc3RvcmUnXG4qL1xuXG4vKipcbiAqIEEgZGF0YXN0b3JlIHRoYXQgY2FuIGNvbWJpbmUgbXVsdGlwbGUgc3RvcmVzLiBQdXRzIGFuZCBkZWxldGVzXG4gKiB3aWxsIHdyaXRlIHRocm91Z2ggdG8gYWxsIGRhdGFzdG9yZXMuIEhhcyBhbmQgZ2V0IHdpbGxcbiAqIHRyeSBlYWNoIHN0b3JlIHNlcXVlbnRpYWxseS4gUXVlcnkgd2lsbCBhbHdheXMgdHJ5IHRoZVxuICogbGFzdCBvbmUgZmlyc3QuXG4gKlxuICovXG5jbGFzcyBUaWVyZWREYXRhc3RvcmUgLyogOjogPFZhbHVlPiAqLyB7XG4gIC8qIDo6IHN0b3JlczogQXJyYXk8RGF0YXN0b3JlPFZhbHVlPj4gKi9cblxuICBjb25zdHJ1Y3RvciAoc3RvcmVzIC8qIDogQXJyYXk8RGF0YXN0b3JlPFZhbHVlPj4gKi8pIHtcbiAgICB0aGlzLnN0b3JlcyA9IHN0b3Jlcy5zbGljZSgpXG4gIH1cblxuICBvcGVuIChjYWxsYmFjayAvKiA6IENhbGxiYWNrPHZvaWQ+ICovKSAvKiA6IHZvaWQgKi8ge1xuICAgIGVhY2godGhpcy5zdG9yZXMsIChzdG9yZSwgY2IpID0+IHtcbiAgICAgIHN0b3JlLm9wZW4oY2IpXG4gICAgfSwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soRXJyb3JzLmRiT3BlbkZhaWxlZEVycm9yKCkpXG4gICAgICB9XG4gICAgICBjYWxsYmFjaygpXG4gICAgfSlcbiAgfVxuXG4gIHB1dCAoa2V5IC8qIDogS2V5ICovLCB2YWx1ZSAvKiA6IFZhbHVlICovLCBjYWxsYmFjayAvKiA6IENhbGxiYWNrPHZvaWQ+ICovKSAvKiA6IHZvaWQgKi8ge1xuICAgIGVhY2godGhpcy5zdG9yZXMsIChzdG9yZSwgY2IpID0+IHtcbiAgICAgIHN0b3JlLnB1dChrZXksIHZhbHVlLCBjYilcbiAgICB9LCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhFcnJvcnMuZGJXcml0ZUZhaWxlZEVycm9yKCkpXG4gICAgICB9XG4gICAgICBjYWxsYmFjaygpXG4gICAgfSlcbiAgfVxuXG4gIGdldCAoa2V5IC8qIDogS2V5ICovLCBjYWxsYmFjayAvKiA6IENhbGxiYWNrPFZhbHVlPiAqLykgLyogOiB2b2lkICovIHtcbiAgICBjb25zdCBzdG9yZUxlbmd0aCA9IHRoaXMuc3RvcmVzLmxlbmd0aFxuICAgIGxldCBkb25lID0gZmFsc2VcbiAgICBsZXQgaSA9IDBcbiAgICB3aGlsc3QoKCkgPT4gIWRvbmUgJiYgaSA8IHN0b3JlTGVuZ3RoLCBjYiA9PiB7XG4gICAgICBjb25zdCBzdG9yZSA9IHRoaXMuc3RvcmVzW2krK11cbiAgICAgIHN0b3JlLmdldChrZXksIChlcnIsIHJlcykgPT4ge1xuICAgICAgICBpZiAoZXJyID09IG51bGwpIHtcbiAgICAgICAgICBkb25lID0gdHJ1ZVxuICAgICAgICAgIHJldHVybiBjYihudWxsLCByZXMpXG4gICAgICAgIH1cbiAgICAgICAgY2IoKVxuICAgICAgfSlcbiAgICB9LCAoZXJyLCByZXMpID0+IHtcbiAgICAgIGlmIChlcnIgfHwgIXJlcykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soRXJyb3JzLm5vdEZvdW5kRXJyb3IoKSlcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIHJlcylcbiAgICB9KVxuICB9XG5cbiAgaGFzIChrZXkgLyogOiBLZXkgKi8sIGNhbGxiYWNrIC8qIDogQ2FsbGJhY2s8Ym9vbD4gKi8pIC8qIDogdm9pZCAqLyB7XG4gICAgY29uc3Qgc3RvcmVMZW5ndGggPSB0aGlzLnN0b3Jlcy5sZW5ndGhcbiAgICBsZXQgZG9uZSA9IGZhbHNlXG4gICAgbGV0IGkgPSAwXG4gICAgd2hpbHN0KCgpID0+ICFkb25lICYmIGkgPCBzdG9yZUxlbmd0aCwgY2IgPT4ge1xuICAgICAgY29uc3Qgc3RvcmUgPSB0aGlzLnN0b3Jlc1tpKytdXG4gICAgICBzdG9yZS5oYXMoa2V5LCAoZXJyLCBleGlzdHMpID0+IHtcbiAgICAgICAgaWYgKGVyciA9PSBudWxsKSB7XG4gICAgICAgICAgZG9uZSA9IHRydWVcbiAgICAgICAgICByZXR1cm4gY2IobnVsbCwgZXhpc3RzKVxuICAgICAgICB9XG4gICAgICAgIGNiKClcbiAgICAgIH0pXG4gICAgfSwgY2FsbGJhY2spXG4gIH1cblxuICBkZWxldGUgKGtleSAvKiA6IEtleSAqLywgY2FsbGJhY2sgLyogOiBDYWxsYmFjazx2b2lkPiAqLykgLyogOiB2b2lkICovIHtcbiAgICBlYWNoKHRoaXMuc3RvcmVzLCAoc3RvcmUsIGNiKSA9PiB7XG4gICAgICBzdG9yZS5kZWxldGUoa2V5LCBjYilcbiAgICB9LCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhFcnJvcnMuZGJEZWxldGVGYWlsZWRFcnJvcigpKVxuICAgICAgfVxuICAgICAgY2FsbGJhY2soKVxuICAgIH0pXG4gIH1cblxuICBjbG9zZSAoY2FsbGJhY2sgLyogOiBDYWxsYmFjazx2b2lkPiAqLykgLyogOiB2b2lkICovIHtcbiAgICBlYWNoKHRoaXMuc3RvcmVzLCAoc3RvcmUsIGNiKSA9PiB7XG4gICAgICBzdG9yZS5jbG9zZShjYilcbiAgICB9LCBjYWxsYmFjaylcbiAgfVxuXG4gIGJhdGNoICgpIC8qIDogQmF0Y2g8VmFsdWU+ICovIHtcbiAgICBjb25zdCBiYXRjaGVzID0gdGhpcy5zdG9yZXMubWFwKHN0b3JlID0+IHN0b3JlLmJhdGNoKCkpXG5cbiAgICByZXR1cm4ge1xuICAgICAgcHV0OiAoa2V5IC8qIDogS2V5ICovLCB2YWx1ZSAvKiA6IFZhbHVlICovKSAvKiA6IHZvaWQgKi8gPT4ge1xuICAgICAgICBiYXRjaGVzLmZvckVhY2goYiA9PiBiLnB1dChrZXksIHZhbHVlKSlcbiAgICAgIH0sXG4gICAgICBkZWxldGU6IChrZXkgLyogOiBLZXkgKi8pIC8qIDogdm9pZCAqLyA9PiB7XG4gICAgICAgIGJhdGNoZXMuZm9yRWFjaChiID0+IGIuZGVsZXRlKGtleSkpXG4gICAgICB9LFxuICAgICAgY29tbWl0OiAoY2FsbGJhY2sgLyogOiBDYWxsYmFjazx2b2lkPiAqLykgLyogOiB2b2lkICovID0+IHtcbiAgICAgICAgZWFjaChiYXRjaGVzLCAoYiwgY2IpID0+IHtcbiAgICAgICAgICBiLmNvbW1pdChjYilcbiAgICAgICAgfSwgY2FsbGJhY2spXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcXVlcnkgKHEgLyogOiBRdWVyeTxWYWx1ZT4gKi8pIC8qIDogUXVlcnlSZXN1bHQ8VmFsdWU+ICovIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZXNbdGhpcy5zdG9yZXMubGVuZ3RoIC0gMV0ucXVlcnkocSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRpZXJlZERhdGFzdG9yZVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSByZWplY3Q7XG5cbnZhciBfZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcblxudmFyIF9maWx0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmlsdGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gcmVqZWN0KGVhY2hmbiwgYXJyLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAoMCwgX2ZpbHRlcjIuZGVmYXVsdCkoZWFjaGZuLCBhcnIsIGZ1bmN0aW9uICh2YWx1ZSwgY2IpIHtcbiAgICAgICAgaXRlcmF0ZWUodmFsdWUsIGZ1bmN0aW9uIChlcnIsIHYpIHtcbiAgICAgICAgICAgIGNiKGVyciwgIXYpO1xuICAgICAgICB9KTtcbiAgICB9LCBjYWxsYmFjayk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCdcblxudmFyIEFic3RyYWN0TGV2ZWxET1dOID0gcmVxdWlyZSgnYWJzdHJhY3QtbGV2ZWxkb3duJykuQWJzdHJhY3RMZXZlbERPV05cbnZhciBBYnN0cmFjdENoYWluZWRCYXRjaCA9IHJlcXVpcmUoJ2Fic3RyYWN0LWxldmVsZG93bicpLkFic3RyYWN0Q2hhaW5lZEJhdGNoXG52YXIgQWJzdHJhY3RJdGVyYXRvciA9IHJlcXVpcmUoJ2Fic3RyYWN0LWxldmVsZG93bicpLkFic3RyYWN0SXRlcmF0b3JcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBDb2RlYyA9IHJlcXVpcmUoJ2xldmVsLWNvZGVjJylcbnZhciBFbmNvZGluZ0Vycm9yID0gcmVxdWlyZSgnbGV2ZWwtZXJyb3JzJykuRW5jb2RpbmdFcnJvclxuXG5tb2R1bGUuZXhwb3J0cyA9IERCLmRlZmF1bHQgPSBEQlxuXG5mdW5jdGlvbiBEQiAoZGIsIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERCKSkgcmV0dXJuIG5ldyBEQihkYiwgb3B0cylcbiAgQWJzdHJhY3RMZXZlbERPV04uY2FsbCh0aGlzLCAnJylcblxuICBvcHRzID0gb3B0cyB8fCB7fVxuICBpZiAodHlwZW9mIG9wdHMua2V5RW5jb2RpbmcgPT09ICd1bmRlZmluZWQnKSBvcHRzLmtleUVuY29kaW5nID0gJ3V0ZjgnXG4gIGlmICh0eXBlb2Ygb3B0cy52YWx1ZUVuY29kaW5nID09PSAndW5kZWZpbmVkJykgb3B0cy52YWx1ZUVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdGhpcy5kYiA9IGRiXG4gIHRoaXMuY29kZWMgPSBuZXcgQ29kZWMob3B0cylcbn1cblxuaW5oZXJpdHMoREIsIEFic3RyYWN0TGV2ZWxET1dOKVxuXG5EQi5wcm90b3R5cGUuX3NlcmlhbGl6ZUtleSA9XG5EQi5wcm90b3R5cGUuX3NlcmlhbGl6ZVZhbHVlID0gZnVuY3Rpb24gKGRhdHVtKSB7XG4gIHJldHVybiBkYXR1bVxufVxuXG5EQi5wcm90b3R5cGUuX29wZW4gPSBmdW5jdGlvbiAob3B0cywgY2IpIHtcbiAgdGhpcy5kYi5vcGVuKG9wdHMsIGNiKVxufVxuXG5EQi5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24gKGNiKSB7XG4gIHRoaXMuZGIuY2xvc2UoY2IpXG59XG5cbkRCLnByb3RvdHlwZS5fcHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG9wdHMsIGNiKSB7XG4gIGtleSA9IHRoaXMuY29kZWMuZW5jb2RlS2V5KGtleSwgb3B0cylcbiAgdmFsdWUgPSB0aGlzLmNvZGVjLmVuY29kZVZhbHVlKHZhbHVlLCBvcHRzKVxuICB0aGlzLmRiLnB1dChrZXksIHZhbHVlLCBvcHRzLCBjYilcbn1cblxuREIucHJvdG90eXBlLl9nZXQgPSBmdW5jdGlvbiAoa2V5LCBvcHRzLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAga2V5ID0gdGhpcy5jb2RlYy5lbmNvZGVLZXkoa2V5LCBvcHRzKVxuICBvcHRzLmFzQnVmZmVyID0gdGhpcy5jb2RlYy52YWx1ZUFzQnVmZmVyKG9wdHMpXG4gIHRoaXMuZGIuZ2V0KGtleSwgb3B0cywgZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IHNlbGYuY29kZWMuZGVjb2RlVmFsdWUodmFsdWUsIG9wdHMpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gY2IobmV3IEVuY29kaW5nRXJyb3IoZXJyKSlcbiAgICB9XG4gICAgY2IobnVsbCwgdmFsdWUpXG4gIH0pXG59XG5cbkRCLnByb3RvdHlwZS5fZGVsID0gZnVuY3Rpb24gKGtleSwgb3B0cywgY2IpIHtcbiAga2V5ID0gdGhpcy5jb2RlYy5lbmNvZGVLZXkoa2V5LCBvcHRzKVxuICB0aGlzLmRiLmRlbChrZXksIG9wdHMsIGNiKVxufVxuXG5EQi5wcm90b3R5cGUuX2NoYWluZWRCYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBCYXRjaCh0aGlzKVxufVxuXG5EQi5wcm90b3R5cGUuX2JhdGNoID0gZnVuY3Rpb24gKG9wcywgb3B0cywgY2IpIHtcbiAgb3BzID0gdGhpcy5jb2RlYy5lbmNvZGVCYXRjaChvcHMsIG9wdHMpXG4gIHRoaXMuZGIuYmF0Y2gob3BzLCBvcHRzLCBjYilcbn1cblxuREIucHJvdG90eXBlLl9pdGVyYXRvciA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMua2V5QXNCdWZmZXIgPSB0aGlzLmNvZGVjLmtleUFzQnVmZmVyKG9wdHMpXG4gIG9wdHMudmFsdWVBc0J1ZmZlciA9IHRoaXMuY29kZWMudmFsdWVBc0J1ZmZlcihvcHRzKVxuICByZXR1cm4gbmV3IEl0ZXJhdG9yKHRoaXMsIG9wdHMpXG59XG5cbkRCLnByb3RvdHlwZS5hcHByb3hpbWF0ZVNpemUgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgb3B0cywgY2IpIHtcbiAgc3RhcnQgPSB0aGlzLmNvZGVjLmVuY29kZUtleShzdGFydCwgb3B0cylcbiAgZW5kID0gdGhpcy5jb2RlYy5lbmNvZGVLZXkoZW5kLCBvcHRzKVxuICByZXR1cm4gdGhpcy5kYi5hcHByb3hpbWF0ZVNpemUoc3RhcnQsIGVuZCwgb3B0cywgY2IpXG59XG5cbmZ1bmN0aW9uIEl0ZXJhdG9yIChkYiwgb3B0cykge1xuICBBYnN0cmFjdEl0ZXJhdG9yLmNhbGwodGhpcywgZGIpXG4gIHRoaXMuY29kZWMgPSBkYi5jb2RlY1xuICB0aGlzLmtleXMgPSBvcHRzLmtleXNcbiAgdGhpcy52YWx1ZXMgPSBvcHRzLnZhbHVlc1xuICB0aGlzLm9wdHMgPSB0aGlzLmNvZGVjLmVuY29kZUx0Z3Qob3B0cylcbiAgdGhpcy5pdCA9IGRiLmRiLml0ZXJhdG9yKHRoaXMub3B0cylcbn1cblxuaW5oZXJpdHMoSXRlcmF0b3IsIEFic3RyYWN0SXRlcmF0b3IpXG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uIChjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5pdC5uZXh0KGZ1bmN0aW9uIChlcnIsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHRyeSB7XG4gICAgICBpZiAoc2VsZi5rZXlzICYmIHR5cGVvZiBrZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGtleSA9IHNlbGYuY29kZWMuZGVjb2RlS2V5KGtleSwgc2VsZi5vcHRzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5ID0gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnZhbHVlcyAmJiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhbHVlID0gc2VsZi5jb2RlYy5kZWNvZGVWYWx1ZSh2YWx1ZSwgc2VsZi5vcHRzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBjYihuZXcgRW5jb2RpbmdFcnJvcihlcnIpKVxuICAgIH1cbiAgICBjYihudWxsLCBrZXksIHZhbHVlKVxuICB9KVxufVxuXG5JdGVyYXRvci5wcm90b3R5cGUuX3NlZWsgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGtleSA9IHRoaXMuY29kZWMuZW5jb2RlS2V5KGtleSwgdGhpcy5vcHRzKVxuICB0aGlzLml0LnNlZWsoa2V5KVxufVxuXG5JdGVyYXRvci5wcm90b3R5cGUuX2VuZCA9IGZ1bmN0aW9uIChjYikge1xuICB0aGlzLml0LmVuZChjYilcbn1cblxuZnVuY3Rpb24gQmF0Y2ggKGRiLCBjb2RlYykge1xuICBBYnN0cmFjdENoYWluZWRCYXRjaC5jYWxsKHRoaXMsIGRiKVxuICB0aGlzLmNvZGVjID0gZGIuY29kZWNcbiAgdGhpcy5iYXRjaCA9IGRiLmRiLmJhdGNoKClcbn1cblxuaW5oZXJpdHMoQmF0Y2gsIEFic3RyYWN0Q2hhaW5lZEJhdGNoKVxuXG5CYXRjaC5wcm90b3R5cGUuX3B1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIGtleSA9IHRoaXMuY29kZWMuZW5jb2RlS2V5KGtleSlcbiAgdmFsdWUgPSB0aGlzLmNvZGVjLmVuY29kZVZhbHVlKHZhbHVlKVxuICB0aGlzLmJhdGNoLnB1dChrZXksIHZhbHVlKVxufVxuXG5CYXRjaC5wcm90b3R5cGUuX2RlbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAga2V5ID0gdGhpcy5jb2RlYy5lbmNvZGVLZXkoa2V5KVxuICB0aGlzLmJhdGNoLmRlbChrZXkpXG59XG5cbkJhdGNoLnByb3RvdHlwZS5fY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYmF0Y2guY2xlYXIoKVxufVxuXG5CYXRjaC5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKG9wdHMsIGNiKSB7XG4gIHRoaXMuYmF0Y2gud3JpdGUob3B0cywgY2IpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IExldmVsXG5cbnZhciBBYnN0cmFjdExldmVsRE9XTiA9IHJlcXVpcmUoJ2Fic3RyYWN0LWxldmVsZG93bicpLkFic3RyYWN0TGV2ZWxET1dOXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxudmFyIEl0ZXJhdG9yID0gcmVxdWlyZSgnLi9pdGVyYXRvcicpXG52YXIgeHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG5cbmZ1bmN0aW9uIExldmVsKGxvY2F0aW9uKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMZXZlbCkpIHJldHVybiBuZXcgTGV2ZWwobG9jYXRpb24pXG5cbiAgQWJzdHJhY3RMZXZlbERPV04uY2FsbCh0aGlzLCBsb2NhdGlvbilcbn1cblxudXRpbC5pbmhlcml0cyhMZXZlbCwgQWJzdHJhY3RMZXZlbERPV04pXG5cbi8qKlxuICogT3BlbiBhIGRhdGFiYXNlIGFuZCBvcHRpb25hbGx5IGNyZWF0ZSBpZiBtaXNzaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gIHN0b3JlTmFtZSBhbmQgb3RoZXIgb3B0aW9ucyBwYXNzZWQgdG8gaW5kZXhlZERCXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuIGFuZCBjcmVhdGVPYmplY3RTdG9yZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICBGaXJzdCBwYXJhbWV0ZXIgd2lsbCBiZSBhbiBlcnJvciBvYmplY3Qgb3IgbnVsbC5cbiAqL1xuTGV2ZWwucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgLy8gYXNzdW1lIGNyZWF0ZUlmTWlzc2luZyBhbmQgZXJyb3JJZkV4aXN0cyBhcmUgaW5pdGlhbGl6ZWQgYnkgYWJzdHJhY3QtbGV2ZWxkb3duXG4gIHRoaXMuX2lkYk9wdHMgPSB4dGVuZCh7XG4gICAgc3RvcmVOYW1lOiB0aGlzLmxvY2F0aW9uLFxuICAgIGtleUVuY29kaW5nOiAnbm9uZScsXG4gICAgdmFsdWVFbmNvZGluZzogJ25vbmUnXG4gIH0sIG9wdGlvbnMpXG5cbiAgLy8gc3VwcG9ydCBwYXNzaW5nIGFuIG9wZW4gZGF0YWJhc2VcbiAgaWYgKHRoaXMuX2lkYk9wdHMuaWRiKSB7XG4gICAgb25zdWNjZXNzKHRoaXMuX2lkYk9wdHMuaWRiKVxuICB9IGVsc2Uge1xuICAgIHZhciByZXEgPSBpbmRleGVkREIub3Blbih0aGlzLmxvY2F0aW9uKSAvLyB1c2UgdGhlIGRhdGFiYXNlcyBjdXJyZW50IHZlcnNpb25cbiAgICByZXEub25lcnJvciA9IG9uZXJyb3JcbiAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICBvbnN1Y2Nlc3MocmVxLnJlc3VsdClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVycm9yKGV2KSB7XG4gICAgY2FsbGJhY2soZXYudGFyZ2V0LmVycm9yKVxuICB9XG5cbiAgLy8gaWYgdGhlIHN0b3JlIGRvZXMgbm90IGV4aXN0IGFuZCBjcmVhdGVJZk1pc3NpbmcgaXMgdHJ1ZSwgY3JlYXRlIHRoZSBvYmplY3Qgc3RvcmVcbiAgZnVuY3Rpb24gb25zdWNjZXNzKGRiKSB7XG4gICAgc2VsZi5fZGIgPSBkYlxuXG4gICAgdmFyIGV4aXN0cyA9IHNlbGYuX2RiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoc2VsZi5faWRiT3B0cy5zdG9yZU5hbWUpXG5cbiAgICBpZiAob3B0aW9ucy5lcnJvcklmRXhpc3RzICYmIGV4aXN0cykge1xuICAgICAgc2VsZi5fZGIuY2xvc2UoKVxuICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdzdG9yZSBhbHJlYWR5IGV4aXN0cycpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLmNyZWF0ZUlmTWlzc2luZyAmJiAhZXhpc3RzKSB7XG4gICAgICBzZWxmLl9kYi5jbG9zZSgpXG4gICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ3N0b3JlIGRvZXMgbm90IGV4aXN0JykpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jcmVhdGVJZk1pc3NpbmcgJiYgIWV4aXN0cykge1xuICAgICAgc2VsZi5fZGIuY2xvc2UoKVxuXG4gICAgICB2YXIgcmVxMiA9IGluZGV4ZWREQi5vcGVuKHNlbGYubG9jYXRpb24sIHNlbGYuX2RiLnZlcnNpb24gKyAxKVxuXG4gICAgICByZXEyLm9uZXJyb3IgPSBmdW5jdGlvbihldikge1xuICAgICAgICBjYWxsYmFjayhldi50YXJnZXQuZXJyb3IpXG4gICAgICB9XG5cbiAgICAgIHJlcTIub251cGdyYWRlbmVlZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYiA9IHJlcTIucmVzdWx0XG4gICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKHNlbGYuX2lkYk9wdHMuc3RvcmVOYW1lLCBzZWxmLl9pZGJPcHRzKVxuICAgICAgfVxuXG4gICAgICByZXEyLm9uc3VjY2VzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLl9kYiA9IHJlcTIucmVzdWx0XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHNlbGYpXG4gICAgICB9XG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIHNlbGYpXG4gIH1cbn1cblxuTGV2ZWwucHJvdG90eXBlLl9nZXQgPSBmdW5jdGlvbihrZXksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIG9wdGlvbnMgPSB4dGVuZCh0aGlzLl9pZGJPcHRzLCBvcHRpb25zKVxuXG4gIHZhciBvcmlnS2V5ID0ga2V5XG5cbiAgLy8gc3VwcG9ydCBiaW5hcnkga2V5cyBmb3IgYW55IGl0ZXJhYmxlIHR5cGUgdmlhIGFycmF5IChBcnJheUJ1ZmZlcnMgYXMga2V5cyBhcmUgb25seSBzdXBwb3J0ZWQgaW4gSW5kZXhlZERCIFNlY29uZCBFZGl0aW9uKVxuICBpZiAob3B0aW9ucy5rZXlFbmNvZGluZyA9PT0gJ2JpbmFyeScgJiYgIUFycmF5LmlzQXJyYXkoa2V5KSkga2V5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoa2V5KVxuXG4gIHZhciB0eCA9IHRoaXMuX2RiLnRyYW5zYWN0aW9uKHRoaXMuX2lkYk9wdHMuc3RvcmVOYW1lKVxuICB2YXIgcmVxID0gdHgub2JqZWN0U3RvcmUodGhpcy5faWRiT3B0cy5zdG9yZU5hbWUpLm9wZW5DdXJzb3IoSURCS2V5UmFuZ2Uub25seShrZXkpKVxuXG4gIHR4Lm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICBjYWxsYmFjayh0eC5lcnJvcilcbiAgfVxuXG4gIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3Vyc29yID0gcmVxLnJlc3VsdFxuICAgIGlmIChjdXJzb3IpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGN1cnNvci52YWx1ZVxuXG4gICAgICAvLyBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgVWludDhBcnJheSB2YWx1ZXMgdG8gQnVmZmVyXG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB2YWx1ZSA9IG5ldyBCdWZmZXIodmFsdWUpXG4gICAgICBpZiAob3B0aW9ucy52YWx1ZUVuY29kaW5nID09PSAnYmluYXJ5JyAmJiAhQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkgdmFsdWUgPSBuZXcgQnVmZmVyKHZhbHVlKVxuXG4gICAgICBpZiAob3B0aW9ucy5hc0J1ZmZlciAmJiAhQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBCdWZmZXIoMClcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgICAgdmFsdWUgPSBuZXcgQnVmZmVyKHZhbHVlKSAvLyBkZWZhdWx0cyB0byB1dGY4LCBzaG91bGQgdGhlIGVuY29kaW5nIGJlIHV0ZjE2PyAoRE9NU3RyaW5nKVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykgICB2YWx1ZSA9IG5ldyBCdWZmZXIoU3RyaW5nKHZhbHVlKSkgLy8gY29tcGF0aWJsZSB3aXRoIGxldmVsZGJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgICAgdmFsdWUgPSBuZXcgQnVmZmVyKFN0cmluZyh2YWx1ZSkpIC8vIGNvbXBhdGlibGUgd2l0aCBsZXZlbGRiXG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSAgICAgICAgIHZhbHVlID0gbmV3IEJ1ZmZlcihTdHJpbmcodmFsdWUpKSAvLyBjb21wYXRpYmxlIHdpdGggbGV2ZWxkYlxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpICB2YWx1ZSA9IG5ldyBCdWZmZXIodmFsdWUpXG4gICAgICAgIGVsc2UgcmV0dXJuIHZvaWQgY2FsbGJhY2sobmV3IFR5cGVFcnJvcignY2FuXFwndCBjb2VyY2UgYCcgKyB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lICsgJ2AgaW50byBhIEJ1ZmZlcicpKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgY2FsbGJhY2sobnVsbCwgdmFsdWUsIG9yaWdLZXkpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICdOb3RGb3VuZCcgZXJyb3IsIGNvbnNpc3RlbnQgd2l0aCBMZXZlbERPV04gQVBJXG4gICAgICByZXR1cm4gdm9pZCBjYWxsYmFjayhuZXcgRXJyb3IoJ05vdEZvdW5kJykpXG4gICAgfVxuICB9XG59XG5cbkxldmVsLnByb3RvdHlwZS5fZGVsID0gZnVuY3Rpb24oa2V5LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBvcHRpb25zID0geHRlbmQodGhpcy5faWRiT3B0cywgb3B0aW9ucylcblxuICAvLyBzdXBwb3J0IGJpbmFyeSBrZXlzIGZvciBhbnkgaXRlcmFibGUgdHlwZSB2aWEgYXJyYXkgKEFycmF5QnVmZmVycyBhcyBrZXlzIGFyZSBvbmx5IHN1cHBvcnRlZCBpbiBJbmRleGVkREIgU2Vjb25kIEVkaXRpb24pXG4gIGlmIChvcHRpb25zLmtleUVuY29kaW5nID09PSAnYmluYXJ5JyAmJiAhQXJyYXkuaXNBcnJheShrZXkpKSBrZXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChrZXkpXG5cbiAgdmFyIG1vZGUgPSAncmVhZHdyaXRlJ1xuICBpZiAob3B0aW9ucy5zeW5jID09PSB0cnVlKSB7XG4gICAgbW9kZSA9ICdyZWFkd3JpdGVmbHVzaCcgLy8gb25seSBzdXBwb3J0ZWQgaW4gRmlyZWZveCAod2l0aCBcImRvbS5pbmRleGVkREIuZXhwZXJpbWVudGFsXCIgcHJlZiBzZXQgdG8gdHJ1ZSlcbiAgfVxuICB2YXIgdHggPSB0aGlzLl9kYi50cmFuc2FjdGlvbih0aGlzLl9pZGJPcHRzLnN0b3JlTmFtZSwgbW9kZSlcbiAgdmFyIHJlcSA9IHR4Lm9iamVjdFN0b3JlKHRoaXMuX2lkYk9wdHMuc3RvcmVOYW1lKS5kZWxldGUoa2V5KVxuXG4gIHR4Lm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICBjYWxsYmFjayh0eC5lcnJvcilcbiAgfVxuXG4gIHR4Lm9uY29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICBjYWxsYmFjaygpXG4gIH1cbn1cblxuTGV2ZWwucHJvdG90eXBlLl9wdXQgPSBmdW5jdGlvbihrZXksIHZhbHVlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBvcHRpb25zID0geHRlbmQodGhpcy5faWRiT3B0cywgb3B0aW9ucylcblxuICAvLyBzdXBwb3J0IGJpbmFyeSBrZXlzIGZvciBhbnkgaXRlcmFibGUgdHlwZSB2aWEgYXJyYXkgKEFycmF5QnVmZmVycyBhcyBrZXlzIGFyZSBvbmx5IHN1cHBvcnRlZCBpbiBJbmRleGVkREIgU2Vjb25kIEVkaXRpb24pXG4gIGlmIChvcHRpb25zLmtleUVuY29kaW5nID09PSAnYmluYXJ5JyAmJiAhQXJyYXkuaXNBcnJheShrZXkpKSBrZXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChrZXkpXG5cbiAgdmFyIG1vZGUgPSAncmVhZHdyaXRlJ1xuICBpZiAob3B0aW9ucy5zeW5jID09PSB0cnVlKSB7XG4gICAgbW9kZSA9ICdyZWFkd3JpdGVmbHVzaCcgLy8gb25seSBzdXBwb3J0ZWQgaW4gRmlyZWZveCAod2l0aCBcImRvbS5pbmRleGVkREIuZXhwZXJpbWVudGFsXCIgcHJlZiBzZXQgdG8gdHJ1ZSlcbiAgfVxuICB2YXIgdHggPSB0aGlzLl9kYi50cmFuc2FjdGlvbih0aGlzLl9pZGJPcHRzLnN0b3JlTmFtZSwgbW9kZSlcbiAgdmFyIHJlcSA9IHR4Lm9iamVjdFN0b3JlKHRoaXMuX2lkYk9wdHMuc3RvcmVOYW1lKS5wdXQodmFsdWUsIGtleSlcblxuICB0eC5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgY2FsbGJhY2sodHguZXJyb3IpXG4gIH1cblxuICB0eC5vbmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgY2FsbGJhY2soKVxuICB9XG59XG5cbkxldmVsLnByb3RvdHlwZS5faXRlcmF0b3IgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgSXRlcmF0b3IodGhpcywgb3B0aW9ucylcbn1cblxuLy8gb25seSBzdXBwb3J0IHN5bmM6IHRydWUgb24gYmF0Y2ggbGV2ZWwsIG5vdCBvcGVyYXRpb24gbGV2ZWxcbkxldmVsLnByb3RvdHlwZS5fYmF0Y2ggPSBmdW5jdGlvbihhcnJheSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spXG5cbiAgdmFyIG1vZGUgPSAncmVhZHdyaXRlJ1xuICBpZiAob3B0aW9ucy5zeW5jID09PSB0cnVlKSB7XG4gICAgbW9kZSA9ICdyZWFkd3JpdGVmbHVzaCcgLy8gb25seSBzdXBwb3J0ZWQgaW4gRmlyZWZveCAod2l0aCBcImRvbS5pbmRleGVkREIuZXhwZXJpbWVudGFsXCIgcHJlZiBzZXQgdG8gdHJ1ZSlcbiAgfVxuICB2YXIgdHggPSB0aGlzLl9kYi50cmFuc2FjdGlvbih0aGlzLl9pZGJPcHRzLnN0b3JlTmFtZSwgbW9kZSlcbiAgdmFyIHN0b3JlID0gdHgub2JqZWN0U3RvcmUodGhpcy5faWRiT3B0cy5zdG9yZU5hbWUpXG5cbiAgdHgub25hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIGNhbGxiYWNrKHR4LmVycm9yKVxuICB9XG5cbiAgdHgub25jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGNhbGxiYWNrKClcbiAgfVxuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24oY3VycmVudE9wKSB7XG4gICAgdmFyIG9wdHMgPSB4dGVuZChvcHRpb25zLCBjdXJyZW50T3ApXG5cbiAgICAvLyBzdXBwb3J0IGJpbmFyeSBrZXlzIGZvciBhbnkgaXRlcmFibGUgdHlwZSB2aWEgYXJyYXkgKEFycmF5QnVmZmVycyBhcyBrZXlzIGFyZSBvbmx5IHN1cHBvcnRlZCBpbiBJbmRleGVkREIgU2Vjb25kIEVkaXRpb24pXG4gICAgaWYgKG9wdHMua2V5RW5jb2RpbmcgPT09ICdiaW5hcnknICYmICFBcnJheS5pc0FycmF5KGN1cnJlbnRPcC5rZXkpKSBjdXJyZW50T3Aua2V5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY3VycmVudE9wLmtleSlcblxuICAgIGlmIChjdXJyZW50T3AudHlwZSA9PT0gJ2RlbCcpIHtcbiAgICAgIHN0b3JlLmRlbGV0ZShjdXJyZW50T3Aua2V5KVxuICAgIH0gZWxzZSB7XG4gICAgICBzdG9yZS5wdXQoY3VycmVudE9wLnZhbHVlLCBjdXJyZW50T3Aua2V5KVxuICAgIH1cbiAgfSlcbn1cblxuTGV2ZWwucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLl9kYi5jbG9zZSgpXG4gIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spXG59XG5cbkxldmVsLnByb3RvdHlwZS5fYXBwcm94aW1hdGVTaXplID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGNhbGxiYWNrKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpXG4gIGlmIChjYWxsYmFjaylcbiAgICByZXR1cm4gdm9pZCBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgY2FsbGJhY2soZXJyKVxuICAgIH0pXG5cbiAgdGhyb3cgZXJyXG59XG5cbi8qKlxuICogRGVzdHJveSB0aGUgb2JqZWN0IHN0b3JlIGFuZCB0aGUgZGF0YWJhc2UgaWYgbm8gb3RoZXIgb2JqZWN0IHN0b3JlcyBleGlzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGxvY2F0aW9uICBOYW1lIG9mIHRoZSBkYXRhYmFzZSBvciBhIGRhdGFiYXNlIGluc3RhbmNlLlxuICovXG5MZXZlbC5kZXN0cm95ID0gZnVuY3Rpb24oZGIsIGNhbGxiYWNrKSB7XG4gIHZhciBpZGJPcHRzXG4gIGlmIChkYiAhPSBudWxsICYmIHR5cGVvZiBkYiA9PT0gJ29iamVjdCcpIHtcbiAgICBpZGJPcHRzID0geHRlbmQoe1xuICAgICAgbG9jYXRpb246IGRiLmxvY2F0aW9uLFxuICAgICAgc3RvcmVOYW1lOiBkYi5sb2NhdGlvblxuICAgIH0sIGRiLl9pZGJPcHRzKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBkYiA9PT0gJ3N0cmluZycpIHtcbiAgICBpZGJPcHRzID0ge1xuICAgICAgbG9jYXRpb246IGRiLFxuICAgICAgc3RvcmVOYW1lOiBkYlxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsb2NhdGlvbiBtdXN0IGJlIGEgc3RyaW5nIG9yIGFuIG9iamVjdCcpXG4gIH1cblxuICBpZiAodHlwZW9mIGlkYk9wdHMubG9jYXRpb24gIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdsb2NhdGlvbiBtdXN0IGJlIGEgc3RyaW5nJylcbiAgaWYgKHR5cGVvZiBpZGJPcHRzLnN0b3JlTmFtZSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RiLnN0b3JlTmFtZSBtdXN0IGJlIGEgc3RyaW5nJylcblxuICB2YXIgcmVxID0gaW5kZXhlZERCLm9wZW4oaWRiT3B0cy5sb2NhdGlvbikgLy8gdXNlIHRoZSBkYXRhYmFzZXMgY3VycmVudCB2ZXJzaW9uXG5cbiAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbihldikge1xuICAgIGNhbGxiYWNrKGV2LnRhcmdldC5lcnJvcilcbiAgfVxuXG4gIC8vIGlmIHRoZSBkYXRhYmFzZSBjb250YWlucyBubyBvdGhlciBzdG9yZXMsIGRlbGV0ZSB0aGUgZGF0YWJhc2UgYXMgd2VsbFxuICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRiID0gcmVxLnJlc3VsdFxuXG4gICAgZnVuY3Rpb24gZGVsZXRlRGF0YWJhc2UobmFtZSkge1xuICAgICAgdmFyIHJlcTIgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UobmFtZSlcbiAgICAgIHJlcTIub25lcnJvciA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGNhbGxiYWNrKGV2LnRhcmdldC5lcnJvcilcbiAgICAgIH1cbiAgICAgIHJlcTIub25zdWNjZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbGxiYWNrKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkYi5jbG9zZSgpXG5cbiAgICBpZiAoZGIub2JqZWN0U3RvcmVOYW1lcy5sZW5ndGggPT09IDApIHJldHVybiB2b2lkIGRlbGV0ZURhdGFiYXNlKGlkYk9wdHMubG9jYXRpb24pXG4gICAgaWYgKCFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKGlkYk9wdHMuc3RvcmVOYW1lKSkgcmV0dXJuIHZvaWQgY2FsbGJhY2soKVxuXG4gICAgLy8gZGVsZXRlIG9iamVjdCBzdG9yZSwgYW5kIGlmIG5vIG9iamVjdCBzdG9yZXMgcmVtYWluLCBkZWxldGUgZGF0YWJhc2VcbiAgICB2YXIgcmVxMiA9IGluZGV4ZWREQi5vcGVuKGlkYk9wdHMubG9jYXRpb24sIGRiLnZlcnNpb24gKyAxKVxuXG4gICAgcmVxMi5vbmVycm9yID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgIGNhbGxiYWNrKGV2LnRhcmdldC5lcnJvcilcbiAgICB9XG5cbiAgICByZXEyLm9udXBncmFkZW5lZWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGIgPSByZXEyLnJlc3VsdFxuICAgICAgZGIuZGVsZXRlT2JqZWN0U3RvcmUoaWRiT3B0cy5zdG9yZU5hbWUpXG4gICAgfVxuXG4gICAgcmVxMi5vbnN1Y2Nlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIGRiID0gcmVxMi5yZXN1bHRcbiAgICAgIGRiLmNsb3NlKClcblxuICAgICAgaWYgKGRiLm9iamVjdFN0b3JlTmFtZXMubGVuZ3RoID09PSAwKSBkZWxldGVEYXRhYmFzZShpZGJPcHRzLmxvY2F0aW9uKVxuICAgICAgZWxzZSBjYWxsYmFjaygpXG4gICAgfVxuICB9XG59XG4iLCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcbnZhciBleHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgRGVmZXJyZWRMZXZlbERPV04gPSByZXF1aXJlKCdkZWZlcnJlZC1sZXZlbGRvd24nKVxudmFyIEl0ZXJhdG9yU3RyZWFtID0gcmVxdWlyZSgnbGV2ZWwtaXRlcmF0b3Itc3RyZWFtJylcbnZhciBCYXRjaCA9IHJlcXVpcmUoJy4vYmF0Y2gnKVxudmFyIGVycm9ycyA9IHJlcXVpcmUoJ2xldmVsLWVycm9ycycpXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciBwcm9taXNpZnkgPSByZXF1aXJlKCcuL3Byb21pc2lmeScpXG52YXIgZ2V0Q2FsbGJhY2sgPSByZXF1aXJlKCcuL2NvbW1vbicpLmdldENhbGxiYWNrXG52YXIgZ2V0T3B0aW9ucyA9IHJlcXVpcmUoJy4vY29tbW9uJykuZ2V0T3B0aW9uc1xuXG52YXIgV3JpdGVFcnJvciA9IGVycm9ycy5Xcml0ZUVycm9yXG52YXIgUmVhZEVycm9yID0gZXJyb3JzLlJlYWRFcnJvclxudmFyIE5vdEZvdW5kRXJyb3IgPSBlcnJvcnMuTm90Rm91bmRFcnJvclxudmFyIE9wZW5FcnJvciA9IGVycm9ycy5PcGVuRXJyb3JcbnZhciBJbml0aWFsaXphdGlvbkVycm9yID0gZXJyb3JzLkluaXRpYWxpemF0aW9uRXJyb3JcblxuLy8gUG9zc2libGUgQWJzdHJhY3RMZXZlbERPV04jc3RhdHVzIHZhbHVlczpcbi8vICAtICduZXcnICAgICAtIG5ld2x5IGNyZWF0ZWQsIG5vdCBvcGVuZWQgb3IgY2xvc2VkXG4vLyAgLSAnb3BlbmluZycgLSB3YWl0aW5nIGZvciB0aGUgZGF0YWJhc2UgdG8gYmUgb3BlbmVkLCBwb3N0IG9wZW4oKVxuLy8gIC0gJ29wZW4nICAgIC0gc3VjY2Vzc2Z1bGx5IG9wZW5lZCB0aGUgZGF0YWJhc2UsIGF2YWlsYWJsZSBmb3IgdXNlXG4vLyAgLSAnY2xvc2luZycgLSB3YWl0aW5nIGZvciB0aGUgZGF0YWJhc2UgdG8gYmUgY2xvc2VkLCBwb3N0IGNsb3NlKClcbi8vICAtICdjbG9zZWQnICAtIGRhdGFiYXNlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBjbG9zZWQsIHNob3VsZCBub3QgYmVcbi8vICAgICAgICAgICAgICAgICB1c2VkIGV4Y2VwdCBmb3IgYW5vdGhlciBvcGVuKCkgb3BlcmF0aW9uXG5cbmZ1bmN0aW9uIExldmVsVVAgKGRiLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTGV2ZWxVUCkpIHtcbiAgICByZXR1cm4gbmV3IExldmVsVVAoZGIsIG9wdGlvbnMsIGNhbGxiYWNrKVxuICB9XG5cbiAgdmFyIGVycm9yXG5cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcylcbiAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoSW5maW5pdHkpXG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGlmICghZGIgfHwgdHlwZW9mIGRiICE9PSAnb2JqZWN0Jykge1xuICAgIGVycm9yID0gbmV3IEluaXRpYWxpemF0aW9uRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gYWJzdHJhY3QtbGV2ZWxkb3duIGNvbXBsaWFudCBzdG9yZScpXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIGVycm9yKVxuICAgIH1cbiAgICB0aHJvdyBlcnJvclxuICB9XG5cbiAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBkYi5zdGF0dXMsICdzdHJpbmcnLCAnLnN0YXR1cyByZXF1aXJlZCwgb2xkIGFic3RyYWN0LWxldmVsZG93bicpXG5cbiAgdGhpcy5vcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zKVxuICB0aGlzLl9kYiA9IGRiXG4gIHRoaXMuZGIgPSBuZXcgRGVmZXJyZWRMZXZlbERPV04oZGIpXG4gIHRoaXMub3BlbihjYWxsYmFjaylcbn1cblxuTGV2ZWxVUC5wcm90b3R5cGUuZW1pdCA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdFxuTGV2ZWxVUC5wcm90b3R5cGUub25jZSA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZVxuaW5oZXJpdHMoTGV2ZWxVUCwgRXZlbnRFbWl0dGVyKVxuXG5MZXZlbFVQLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgcHJvbWlzZVxuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0c1xuICAgIG9wdHMgPSBudWxsXG4gIH1cblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBwcm9taXNpZnkoKVxuICAgIHByb21pc2UgPSBjYWxsYmFjay5wcm9taXNlXG4gIH1cblxuICBpZiAoIW9wdHMpIHtcbiAgICBvcHRzID0gdGhpcy5vcHRpb25zXG4gIH1cblxuICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG51bGwsIHNlbGYpXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGlmICh0aGlzLl9pc09wZW5pbmcoKSkge1xuICAgIHRoaXMub25jZSgnb3BlbicsIGZ1bmN0aW9uICgpIHsgY2FsbGJhY2sobnVsbCwgc2VsZikgfSlcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgdGhpcy5lbWl0KCdvcGVuaW5nJylcblxuICB0aGlzLmRiLm9wZW4ob3B0cywgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgT3BlbkVycm9yKGVycikpXG4gICAgfVxuICAgIHNlbGYuZGIgPSBzZWxmLl9kYlxuICAgIGNhbGxiYWNrKG51bGwsIHNlbGYpXG4gICAgc2VsZi5lbWl0KCdvcGVuJylcbiAgICBzZWxmLmVtaXQoJ3JlYWR5JylcbiAgfSlcblxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5MZXZlbFVQLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHByb21pc2VcblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBwcm9taXNpZnkoKVxuICAgIHByb21pc2UgPSBjYWxsYmFjay5wcm9taXNlXG4gIH1cblxuICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgIHRoaXMuZGIuY2xvc2UoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5lbWl0KCdjbG9zZWQnKVxuICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH0pXG4gICAgdGhpcy5lbWl0KCdjbG9zaW5nJylcbiAgICB0aGlzLmRiID0gbmV3IERlZmVycmVkTGV2ZWxET1dOKHRoaXMuX2RiKVxuICB9IGVsc2UgaWYgKHRoaXMuaXNDbG9zZWQoKSkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spXG4gIH0gZWxzZSBpZiAodGhpcy5kYi5zdGF0dXMgPT09ICdjbG9zaW5nJykge1xuICAgIHRoaXMub25jZSgnY2xvc2VkJywgY2FsbGJhY2spXG4gIH0gZWxzZSBpZiAodGhpcy5faXNPcGVuaW5nKCkpIHtcbiAgICB0aGlzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmNsb3NlKGNhbGxiYWNrKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5MZXZlbFVQLnByb3RvdHlwZS5pc09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmRiLnN0YXR1cyA9PT0gJ29wZW4nXG59XG5cbkxldmVsVVAucHJvdG90eXBlLl9pc09wZW5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmRiLnN0YXR1cyA9PT0gJ29wZW5pbmcnXG59XG5cbkxldmVsVVAucHJvdG90eXBlLmlzQ2xvc2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKC9eY2xvc3xuZXcvKS50ZXN0KHRoaXMuZGIuc3RhdHVzKVxufVxuXG5MZXZlbFVQLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAoa2V5ID09PSBudWxsIHx8IGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFJlYWRFcnJvcignZ2V0KCkgcmVxdWlyZXMgYSBrZXkgYXJndW1lbnQnKVxuICB9XG5cbiAgdmFyIHByb21pc2VcblxuICBjYWxsYmFjayA9IGdldENhbGxiYWNrKG9wdGlvbnMsIGNhbGxiYWNrKVxuXG4gIGlmICghY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IHByb21pc2lmeSgpXG4gICAgcHJvbWlzZSA9IGNhbGxiYWNrLnByb21pc2VcbiAgfVxuXG4gIGlmIChtYXliZUVycm9yKHRoaXMsIGNhbGxiYWNrKSkgeyByZXR1cm4gcHJvbWlzZSB9XG5cbiAgb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucylcblxuICB0aGlzLmRiLmdldChrZXksIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgaWYgKCgvbm90Zm91bmQvaSkudGVzdChlcnIpIHx8IGVyci5ub3RGb3VuZCkge1xuICAgICAgICBlcnIgPSBuZXcgTm90Rm91bmRFcnJvcignS2V5IG5vdCBmb3VuZCBpbiBkYXRhYmFzZSBbJyArIGtleSArICddJywgZXJyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyID0gbmV3IFJlYWRFcnJvcihlcnIpXG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB2YWx1ZSlcbiAgfSlcblxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5MZXZlbFVQLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKGtleSA9PT0gbnVsbCB8fCBrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBXcml0ZUVycm9yKCdwdXQoKSByZXF1aXJlcyBhIGtleSBhcmd1bWVudCcpXG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHByb21pc2VcblxuICBjYWxsYmFjayA9IGdldENhbGxiYWNrKG9wdGlvbnMsIGNhbGxiYWNrKVxuXG4gIGlmICghY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IHByb21pc2lmeSgpXG4gICAgcHJvbWlzZSA9IGNhbGxiYWNrLnByb21pc2VcbiAgfVxuXG4gIGlmIChtYXliZUVycm9yKHRoaXMsIGNhbGxiYWNrKSkgeyByZXR1cm4gcHJvbWlzZSB9XG5cbiAgb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucylcblxuICB0aGlzLmRiLnB1dChrZXksIHZhbHVlLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBXcml0ZUVycm9yKGVycikpXG4gICAgfVxuICAgIHNlbGYuZW1pdCgncHV0Jywga2V5LCB2YWx1ZSlcbiAgICBjYWxsYmFjaygpXG4gIH0pXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuTGV2ZWxVUC5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24gKGtleSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKGtleSA9PT0gbnVsbCB8fCBrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBXcml0ZUVycm9yKCdkZWwoKSByZXF1aXJlcyBhIGtleSBhcmd1bWVudCcpXG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHByb21pc2VcblxuICBjYWxsYmFjayA9IGdldENhbGxiYWNrKG9wdGlvbnMsIGNhbGxiYWNrKVxuXG4gIGlmICghY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IHByb21pc2lmeSgpXG4gICAgcHJvbWlzZSA9IGNhbGxiYWNrLnByb21pc2VcbiAgfVxuXG4gIGlmIChtYXliZUVycm9yKHRoaXMsIGNhbGxiYWNrKSkgeyByZXR1cm4gcHJvbWlzZSB9XG5cbiAgb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucylcblxuICB0aGlzLmRiLmRlbChrZXksIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobmV3IFdyaXRlRXJyb3IoZXJyKSlcbiAgICB9XG4gICAgc2VsZi5lbWl0KCdkZWwnLCBrZXkpXG4gICAgY2FsbGJhY2soKVxuICB9KVxuXG4gIHJldHVybiBwcm9taXNlXG59XG5cbkxldmVsVVAucHJvdG90eXBlLmJhdGNoID0gZnVuY3Rpb24gKGFyciwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBCYXRjaCh0aGlzKVxuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICB0aHJvdyBuZXcgV3JpdGVFcnJvcignYmF0Y2goKSByZXF1aXJlcyBhbiBhcnJheSBhcmd1bWVudCcpXG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHByb21pc2VcblxuICBjYWxsYmFjayA9IGdldENhbGxiYWNrKG9wdGlvbnMsIGNhbGxiYWNrKVxuXG4gIGlmICghY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IHByb21pc2lmeSgpXG4gICAgcHJvbWlzZSA9IGNhbGxiYWNrLnByb21pc2VcbiAgfVxuXG4gIGlmIChtYXliZUVycm9yKHRoaXMsIGNhbGxiYWNrKSkgeyByZXR1cm4gcHJvbWlzZSB9XG5cbiAgb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucylcblxuICB0aGlzLmRiLmJhdGNoKGFyciwgb3B0aW9ucywgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgV3JpdGVFcnJvcihlcnIpKVxuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2JhdGNoJywgYXJyKVxuICAgIGNhbGxiYWNrKClcbiAgfSlcblxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5MZXZlbFVQLnByb3RvdHlwZS5pdGVyYXRvciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmRiLml0ZXJhdG9yKG9wdGlvbnMpXG59XG5cbkxldmVsVVAucHJvdG90eXBlLnJlYWRTdHJlYW0gPVxuTGV2ZWxVUC5wcm90b3R5cGUuY3JlYXRlUmVhZFN0cmVhbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBleHRlbmQoeyBrZXlzOiB0cnVlLCB2YWx1ZXM6IHRydWUgfSwgb3B0aW9ucylcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbWl0ICE9PSAnbnVtYmVyJykgeyBvcHRpb25zLmxpbWl0ID0gLTEgfVxuICByZXR1cm4gbmV3IEl0ZXJhdG9yU3RyZWFtKHRoaXMuZGIuaXRlcmF0b3Iob3B0aW9ucyksIG9wdGlvbnMpXG59XG5cbkxldmVsVVAucHJvdG90eXBlLmtleVN0cmVhbSA9XG5MZXZlbFVQLnByb3RvdHlwZS5jcmVhdGVLZXlTdHJlYW0gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5jcmVhdGVSZWFkU3RyZWFtKGV4dGVuZChvcHRpb25zLCB7IGtleXM6IHRydWUsIHZhbHVlczogZmFsc2UgfSkpXG59XG5cbkxldmVsVVAucHJvdG90eXBlLnZhbHVlU3RyZWFtID1cbkxldmVsVVAucHJvdG90eXBlLmNyZWF0ZVZhbHVlU3RyZWFtID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuY3JlYXRlUmVhZFN0cmVhbShleHRlbmQob3B0aW9ucywgeyBrZXlzOiBmYWxzZSwgdmFsdWVzOiB0cnVlIH0pKVxufVxuXG5MZXZlbFVQLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdMZXZlbFVQJ1xufVxuXG5mdW5jdGlvbiBtYXliZUVycm9yIChkYiwgY2FsbGJhY2spIHtcbiAgaWYgKCFkYi5faXNPcGVuaW5nKCkgJiYgIWRiLmlzT3BlbigpKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgbmV3IFJlYWRFcnJvcignRGF0YWJhc2UgaXMgbm90IG9wZW4nKSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbkxldmVsVVAuZXJyb3JzID0gZXJyb3JzXG5tb2R1bGUuZXhwb3J0cyA9IExldmVsVVAuZGVmYXVsdCA9IExldmVsVVBcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzaGEzID0gcmVxdWlyZSgnanMtc2hhMycpXG5jb25zdCBtdXJtdXIzID0gcmVxdWlyZSgnbXVybXVyaGFzaDNqcycpXG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBzaGEgPSByZXF1aXJlKCcuL2NyeXB0by1zaGExLTInKVxuXG5jb25zdCB0b0NhbGxiYWNrID0gdXRpbHMudG9DYWxsYmFja1xuY29uc3QgdG9CdWYgPSB1dGlscy50b0J1ZlxuY29uc3QgZnJvbVN0cmluZyA9IHV0aWxzLmZyb21TdHJpbmdcbmNvbnN0IGZyb21OdW1iZXJUbzMyQml0QnVmID0gdXRpbHMuZnJvbU51bWJlclRvMzJCaXRCdWZcblxuY29uc3QgZGJsU2hhMjI1NiA9IChidWYsIGNiKSA9PiB7XG4gIHNoYS5zaGEyMjU2KGJ1ZiwgKGVyciwgZmlyc3RIYXNoKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2IoZXJyKVxuICAgIH1cbiAgICBzaGEuc2hhMjI1NigoQnVmZmVyLmZyb20oZmlyc3RIYXNoKSksIGNiKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2hhMTogc2hhLnNoYTEsXG4gIHNoYTIyNTY6IHNoYS5zaGEyMjU2LFxuICBzaGEyNTEyOiBzaGEuc2hhMjUxMixcbiAgc2hhMzUxMjogdG9DYWxsYmFjayh0b0J1ZihzaGEzLnNoYTNfNTEyKSksXG4gIHNoYTMzODQ6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5zaGEzXzM4NCkpLFxuICBzaGEzMjU2OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMuc2hhM18yNTYpKSxcbiAgc2hhMzIyNDogdG9DYWxsYmFjayh0b0J1ZihzaGEzLnNoYTNfMjI0KSksXG4gIHNoYWtlMTI4OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMuc2hha2VfMTI4LCAxMjgpKSxcbiAgc2hha2UyNTY6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5zaGFrZV8yNTYsIDI1NikpLFxuICBrZWNjYWsyMjQ6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5rZWNjYWtfMjI0KSksXG4gIGtlY2NhazI1NjogdG9DYWxsYmFjayh0b0J1ZihzaGEzLmtlY2Nha18yNTYpKSxcbiAga2VjY2FrMzg0OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMua2VjY2FrXzM4NCkpLFxuICBrZWNjYWs1MTI6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5rZWNjYWtfNTEyKSksXG4gIG11cm11cjMxMjg6IHRvQ2FsbGJhY2sodG9CdWYoZnJvbVN0cmluZyhtdXJtdXIzLng2NC5oYXNoMTI4KSkpLFxuICBtdXJtdXIzMzI6IHRvQ2FsbGJhY2soZnJvbU51bWJlclRvMzJCaXRCdWYoZnJvbVN0cmluZyhtdXJtdXIzLng4Ni5oYXNoMzIpKSksXG4gIGFkZEJsYWtlOiByZXF1aXJlKCcuL2JsYWtlJyksXG4gIGRibFNoYTIyNTY6IGRibFNoYTIyNTZcbn1cbiIsIi8qKlxuICogQ2lwaGVyIGJhc2UgQVBJLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UuY2lwaGVyID0gZm9yZ2UuY2lwaGVyIHx8IHt9O1xuXG4vLyByZWdpc3RlcmVkIGFsZ29yaXRobXNcbmZvcmdlLmNpcGhlci5hbGdvcml0aG1zID0gZm9yZ2UuY2lwaGVyLmFsZ29yaXRobXMgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNpcGhlciBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBlbmNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuXG4gKiBhbGdvcml0aG0gYW5kIGtleS4gVGhlIGFsZ29yaXRobSBtYXkgYmUgcHJvdmlkZWQgYXMgYSBzdHJpbmcgdmFsdWUgZm9yIGFcbiAqIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBhbGdvcml0aG0gb3IgaXQgbWF5IGJlIGdpdmVuIGFzIGEgY2lwaGVyIGFsZ29yaXRobVxuICogQVBJIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYWxnb3JpdGhtIHRoZSBhbGdvcml0aG0gdG8gdXNlLCBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gYWxnb3JpdGhtIEFQSVxuICogICAgICAgICAgb2JqZWN0LlxuICogQHBhcmFtIGtleSB0aGUga2V5IHRvIHVzZSwgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3IgYVxuICogICAgICAgICAgYnl0ZSBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyID0gZnVuY3Rpb24oYWxnb3JpdGhtLCBrZXkpIHtcbiAgdmFyIGFwaSA9IGFsZ29yaXRobTtcbiAgaWYodHlwZW9mIGFwaSA9PT0gJ3N0cmluZycpIHtcbiAgICBhcGkgPSBmb3JnZS5jaXBoZXIuZ2V0QWxnb3JpdGhtKGFwaSk7XG4gICAgaWYoYXBpKSB7XG4gICAgICBhcGkgPSBhcGkoKTtcbiAgICB9XG4gIH1cbiAgaWYoIWFwaSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiAnICsgYWxnb3JpdGhtKTtcbiAgfVxuXG4gIC8vIGFzc3VtZSBibG9jayBjaXBoZXJcbiAgcmV0dXJuIG5ldyBmb3JnZS5jaXBoZXIuQmxvY2tDaXBoZXIoe1xuICAgIGFsZ29yaXRobTogYXBpLFxuICAgIGtleToga2V5LFxuICAgIGRlY3J5cHQ6IGZhbHNlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVjaXBoZXIgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZGVjcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlblxuICogYWxnb3JpdGhtIGFuZCBrZXkuIFRoZSBhbGdvcml0aG0gbWF5IGJlIHByb3ZpZGVkIGFzIGEgc3RyaW5nIHZhbHVlIGZvciBhXG4gKiBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgYWxnb3JpdGhtIG9yIGl0IG1heSBiZSBnaXZlbiBhcyBhIGNpcGhlciBhbGdvcml0aG1cbiAqIEFQSSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGFsZ29yaXRobSB0aGUgYWxnb3JpdGhtIHRvIHVzZSwgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIGFsZ29yaXRobSBBUElcbiAqICAgICAgICAgIG9iamVjdC5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1c2UsIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIG9yIGFcbiAqICAgICAgICAgIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyID0gZnVuY3Rpb24oYWxnb3JpdGhtLCBrZXkpIHtcbiAgdmFyIGFwaSA9IGFsZ29yaXRobTtcbiAgaWYodHlwZW9mIGFwaSA9PT0gJ3N0cmluZycpIHtcbiAgICBhcGkgPSBmb3JnZS5jaXBoZXIuZ2V0QWxnb3JpdGhtKGFwaSk7XG4gICAgaWYoYXBpKSB7XG4gICAgICBhcGkgPSBhcGkoKTtcbiAgICB9XG4gIH1cbiAgaWYoIWFwaSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiAnICsgYWxnb3JpdGhtKTtcbiAgfVxuXG4gIC8vIGFzc3VtZSBibG9jayBjaXBoZXJcbiAgcmV0dXJuIG5ldyBmb3JnZS5jaXBoZXIuQmxvY2tDaXBoZXIoe1xuICAgIGFsZ29yaXRobTogYXBpLFxuICAgIGtleToga2V5LFxuICAgIGRlY3J5cHQ6IHRydWVcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBhbGdvcml0aG0gYnkgbmFtZS4gSWYgdGhlIG5hbWUgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZCwgdGhlXG4gKiBhbGdvcml0aG0gQVBJIG9iamVjdCB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuICpcbiAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBhbGdvcml0aG0uXG4gKiBAcGFyYW0gYWxnb3JpdGhtIHRoZSBhbGdvcml0aG0gQVBJIG9iamVjdC5cbiAqL1xuZm9yZ2UuY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtID0gZnVuY3Rpb24obmFtZSwgYWxnb3JpdGhtKSB7XG4gIG5hbWUgPSBuYW1lLnRvVXBwZXJDYXNlKCk7XG4gIGZvcmdlLmNpcGhlci5hbGdvcml0aG1zW25hbWVdID0gYWxnb3JpdGhtO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgcmVnaXN0ZXJlZCBhbGdvcml0aG0gYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgYWxnb3JpdGhtLlxuICpcbiAqIEByZXR1cm4gdGhlIGFsZ29yaXRobSwgaWYgZm91bmQsIG51bGwgaWYgbm90LlxuICovXG5mb3JnZS5jaXBoZXIuZ2V0QWxnb3JpdGhtID0gZnVuY3Rpb24obmFtZSkge1xuICBuYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICBpZihuYW1lIGluIGZvcmdlLmNpcGhlci5hbGdvcml0aG1zKSB7XG4gICAgcmV0dXJuIGZvcmdlLmNpcGhlci5hbGdvcml0aG1zW25hbWVdO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIEJsb2NrQ2lwaGVyID0gZm9yZ2UuY2lwaGVyLkJsb2NrQ2lwaGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB0aGlzLmFsZ29yaXRobSA9IG9wdGlvbnMuYWxnb3JpdGhtO1xuICB0aGlzLm1vZGUgPSB0aGlzLmFsZ29yaXRobS5tb2RlO1xuICB0aGlzLmJsb2NrU2l6ZSA9IHRoaXMubW9kZS5ibG9ja1NpemU7XG4gIHRoaXMuX2ZpbmlzaCA9IGZhbHNlO1xuICB0aGlzLl9pbnB1dCA9IG51bGw7XG4gIHRoaXMub3V0cHV0ID0gbnVsbDtcbiAgdGhpcy5fb3AgPSBvcHRpb25zLmRlY3J5cHQgPyB0aGlzLm1vZGUuZGVjcnlwdCA6IHRoaXMubW9kZS5lbmNyeXB0O1xuICB0aGlzLl9kZWNyeXB0ID0gb3B0aW9ucy5kZWNyeXB0O1xuICB0aGlzLmFsZ29yaXRobS5pbml0aWFsaXplKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBTdGFydHMgb3IgcmVzdGFydHMgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBwcm9jZXNzLCB3aGljaGV2ZXJcbiAqIHdhcyBwcmV2aW91c2x5IGNvbmZpZ3VyZWQuXG4gKlxuICogRm9yIG5vbi1HQ00gbW9kZSwgdGhlIElWIG1heSBiZSBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXlcbiAqIG9mIGJ5dGVzLCBhIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgaW50ZWdlcnMuIElmIHRoZSBJViBpcyBpblxuICogYnl0ZXMsIHRoZW4gaXQgbXVzdCBiZSBOYiAoMTYpIGJ5dGVzIGluIGxlbmd0aC4gSWYgdGhlIElWIGlzIGdpdmVuIGluIGFzXG4gKiAzMi1iaXQgaW50ZWdlcnMsIHRoZW4gaXQgbXVzdCBiZSA0IGludGVnZXJzIGxvbmcuXG4gKlxuICogTm90ZTogYW4gSVYgaXMgbm90IHJlcXVpcmVkIG9yIHVzZWQgaW4gRUNCIG1vZGUuXG4gKlxuICogRm9yIEdDTS1tb2RlLCB0aGUgSVYgbXVzdCBiZSBnaXZlbiBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcyBvclxuICogYSBieXRlIGJ1ZmZlci4gVGhlIG51bWJlciBvZiBieXRlcyBzaG91bGQgYmUgMTIgKDk2IGJpdHMpIGFzIHJlY29tbWVuZGVkXG4gKiBieSBOSVNUIFNQLTgwMC0zOEQgYnV0IGFub3RoZXIgbGVuZ3RoIG1heSBiZSBnaXZlbi5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZSBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZlxuICogICAgICAgICAgICBieXRlcywgbnVsbCB0byByZXVzZSB0aGUgbGFzdCBjaXBoZXJlZCBibG9jayBmcm9tIGEgcHJldmlvdXNcbiAqICAgICAgICAgICAgdXBkYXRlKCkgKHRoaXMgXCJyZXNpZHVlXCIgbWV0aG9kIGlzIGZvciBsZWdhY3kgc3VwcG9ydCBvbmx5KS5cbiAqICAgICAgICAgIGFkZGl0aW9uYWxEYXRhIGFkZGl0aW9uYWwgYXV0aGVudGljYXRpb24gZGF0YSBhcyBhIGJpbmFyeS1lbmNvZGVkXG4gKiAgICAgICAgICAgIHN0cmluZyBvZiBieXRlcywgZm9yICdHQ00nIG1vZGUsIChkZWZhdWx0OiBub25lKS5cbiAqICAgICAgICAgIHRhZ0xlbmd0aCBkZXNpcmVkIGxlbmd0aCBvZiBhdXRoZW50aWNhdGlvbiB0YWcsIGluIGJpdHMsIGZvclxuICogICAgICAgICAgICAnR0NNJyBtb2RlICgwLTEyOCwgZGVmYXVsdDogMTI4KS5cbiAqICAgICAgICAgIHRhZyB0aGUgYXV0aGVudGljYXRpb24gdGFnIHRvIGNoZWNrIGlmIGRlY3J5cHRpbmcsIGFzIGFcbiAqICAgICAgICAgICAgIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqICAgICAgICAgIG91dHB1dCB0aGUgb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8sIG51bGwgdG8gY3JlYXRlIG9uZS5cbiAqL1xuQmxvY2tDaXBoZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIG9wdHMgPSB7fTtcbiAgZm9yKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgIG9wdHNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgfVxuICBvcHRzLmRlY3J5cHQgPSB0aGlzLl9kZWNyeXB0O1xuICB0aGlzLl9maW5pc2ggPSBmYWxzZTtcbiAgdGhpcy5faW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLm91dHB1dCA9IG9wdGlvbnMub3V0cHV0IHx8IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIHRoaXMubW9kZS5zdGFydChvcHRzKTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgbmV4dCBibG9jayBhY2NvcmRpbmcgdG8gdGhlIGNpcGhlciBtb2RlLlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgYnVmZmVyIHRvIHJlYWQgZnJvbS5cbiAqL1xuQmxvY2tDaXBoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGlmKGlucHV0KSB7XG4gICAgLy8gaW5wdXQgZ2l2ZW4sIHNvIGVtcHR5IGl0IGludG8gdGhlIGlucHV0IGJ1ZmZlclxuICAgIHRoaXMuX2lucHV0LnB1dEJ1ZmZlcihpbnB1dCk7XG4gIH1cblxuICAvLyBkbyBjaXBoZXIgb3BlcmF0aW9uIHVudGlsIGl0IG5lZWRzIG1vcmUgaW5wdXQgYW5kIG5vdCBmaW5pc2hlZFxuICB3aGlsZSghdGhpcy5fb3AuY2FsbCh0aGlzLm1vZGUsIHRoaXMuX2lucHV0LCB0aGlzLm91dHB1dCwgdGhpcy5fZmluaXNoKSAmJlxuICAgICF0aGlzLl9maW5pc2gpIHt9XG5cbiAgLy8gZnJlZSBjb25zdW1lZCBtZW1vcnkgZnJvbSBpbnB1dCBidWZmZXJcbiAgdGhpcy5faW5wdXQuY29tcGFjdCgpO1xufTtcblxuLyoqXG4gKiBGaW5pc2hlcyBlbmNyeXB0aW5nIG9yIGRlY3J5cHRpbmcuXG4gKlxuICogQHBhcmFtIHBhZCBhIHBhZGRpbmcgZnVuY3Rpb24gdG8gdXNlIGluIENCQyBtb2RlLCBudWxsIGZvciBkZWZhdWx0LFxuICogICAgICAgICAgc2lnbmF0dXJlKGJsb2NrU2l6ZSwgYnVmZmVyLCBkZWNyeXB0KS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgc3VjY2Vzc2Z1bCwgZmFsc2Ugb24gZXJyb3IuXG4gKi9cbkJsb2NrQ2lwaGVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbihwYWQpIHtcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgdy9kZXByZWNhdGVkIHBhZGRpbmcgQVBJXG4gIC8vIE5vdGU6IHdpbGwgb3ZlcndyaXRlIHBhZGRpbmcgZnVuY3Rpb25zIGV2ZW4gYWZ0ZXIgYW5vdGhlciBzdGFydCgpIGNhbGxcbiAgaWYocGFkICYmICh0aGlzLm1vZGUubmFtZSA9PT0gJ0VDQicgfHwgdGhpcy5tb2RlLm5hbWUgPT09ICdDQkMnKSkge1xuICAgIHRoaXMubW9kZS5wYWQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgcmV0dXJuIHBhZCh0aGlzLmJsb2NrU2l6ZSwgaW5wdXQsIGZhbHNlKTtcbiAgICB9O1xuICAgIHRoaXMubW9kZS51bnBhZCA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgcmV0dXJuIHBhZCh0aGlzLmJsb2NrU2l6ZSwgb3V0cHV0LCB0cnVlKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gYnVpbGQgb3B0aW9ucyBmb3IgcGFkZGluZyBhbmQgYWZ0ZXJGaW5pc2ggZnVuY3Rpb25zXG4gIHZhciBvcHRpb25zID0ge307XG4gIG9wdGlvbnMuZGVjcnlwdCA9IHRoaXMuX2RlY3J5cHQ7XG5cbiAgLy8gZ2V0ICMgb2YgYnl0ZXMgdGhhdCB3b24ndCBmaWxsIGEgYmxvY2tcbiAgb3B0aW9ucy5vdmVyZmxvdyA9IHRoaXMuX2lucHV0Lmxlbmd0aCgpICUgdGhpcy5ibG9ja1NpemU7XG5cbiAgaWYoIXRoaXMuX2RlY3J5cHQgJiYgdGhpcy5tb2RlLnBhZCkge1xuICAgIGlmKCF0aGlzLm1vZGUucGFkKHRoaXMuX2lucHV0LCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGRvIGZpbmFsIHVwZGF0ZVxuICB0aGlzLl9maW5pc2ggPSB0cnVlO1xuICB0aGlzLnVwZGF0ZSgpO1xuXG4gIGlmKHRoaXMuX2RlY3J5cHQgJiYgdGhpcy5tb2RlLnVucGFkKSB7XG4gICAgaWYoIXRoaXMubW9kZS51bnBhZCh0aGlzLm91dHB1dCwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZih0aGlzLm1vZGUuYWZ0ZXJGaW5pc2gpIHtcbiAgICBpZighdGhpcy5tb2RlLmFmdGVyRmluaXNoKHRoaXMub3V0cHV0LCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8qKlxuICogU3VwcG9ydGVkIGNpcGhlciBtb2Rlcy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG5mb3JnZS5jaXBoZXIgPSBmb3JnZS5jaXBoZXIgfHwge307XG5cbi8vIHN1cHBvcnRlZCBjaXBoZXIgbW9kZXNcbnZhciBtb2RlcyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UuY2lwaGVyLm1vZGVzID0gZm9yZ2UuY2lwaGVyLm1vZGVzIHx8IHt9O1xuXG4vKiogRWxlY3Ryb25pYyBjb2RlYm9vayAoRUNCKSAoRG9uJ3QgdXNlIHRoaXM7IGl0J3Mgbm90IHNlY3VyZSkgKiovXG5cbm1vZGVzLmVjYiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdFQ0InO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9vdXRCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbn07XG5cbm1vZGVzLmVjYi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7fTtcblxubW9kZXMuZWNiLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICBpZihpbnB1dC5sZW5ndGgoKSA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0Lmxlbmd0aCgpID4gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGdldCBuZXh0IGJsb2NrXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gd3JpdGUgb3V0cHV0XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG59O1xuXG5tb2Rlcy5lY2IucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBkZWNyeXB0XG4gIGlmKGlucHV0Lmxlbmd0aCgpIDwgdGhpcy5ibG9ja1NpemUgJiYgIShmaW5pc2ggJiYgaW5wdXQubGVuZ3RoKCkgPiAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZ2V0IG5leHQgYmxvY2tcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIHRoaXMuX2luQmxvY2tbaV0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB9XG5cbiAgLy8gZGVjcnlwdCBibG9ja1xuICB0aGlzLmNpcGhlci5kZWNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyB3cml0ZSBvdXRwdXRcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9vdXRCbG9ja1tpXSk7XG4gIH1cbn07XG5cbm1vZGVzLmVjYi5wcm90b3R5cGUucGFkID0gZnVuY3Rpb24oaW5wdXQsIG9wdGlvbnMpIHtcbiAgLy8gYWRkIFBLQ1MjNyBwYWRkaW5nIHRvIGJsb2NrIChlYWNoIHBhZCBieXRlIGlzIHRoZVxuICAvLyB2YWx1ZSBvZiB0aGUgbnVtYmVyIG9mIHBhZCBieXRlcylcbiAgdmFyIHBhZGRpbmcgPSAoaW5wdXQubGVuZ3RoKCkgPT09IHRoaXMuYmxvY2tTaXplID9cbiAgICB0aGlzLmJsb2NrU2l6ZSA6ICh0aGlzLmJsb2NrU2l6ZSAtIGlucHV0Lmxlbmd0aCgpKSk7XG4gIGlucHV0LmZpbGxXaXRoQnl0ZShwYWRkaW5nLCBwYWRkaW5nKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5tb2Rlcy5lY2IucHJvdG90eXBlLnVucGFkID0gZnVuY3Rpb24ob3V0cHV0LCBvcHRpb25zKSB7XG4gIC8vIGNoZWNrIGZvciBlcnJvcjogaW5wdXQgZGF0YSBub3QgYSBtdWx0aXBsZSBvZiBibG9ja1NpemVcbiAgaWYob3B0aW9ucy5vdmVyZmxvdyA+IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBlbnN1cmUgcGFkZGluZyBieXRlIGNvdW50IGlzIHZhbGlkXG4gIHZhciBsZW4gPSBvdXRwdXQubGVuZ3RoKCk7XG4gIHZhciBjb3VudCA9IG91dHB1dC5hdChsZW4gLSAxKTtcbiAgaWYoY291bnQgPiAodGhpcy5ibG9ja1NpemUgPDwgMikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyB0cmltIG9mZiBwYWRkaW5nIGJ5dGVzXG4gIG91dHB1dC50cnVuY2F0ZShjb3VudCk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqIENpcGhlci1ibG9jayBDaGFpbmluZyAoQ0JDKSAqKi9cblxubW9kZXMuY2JjID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5uYW1lID0gJ0NCQyc7XG4gIHRoaXMuY2lwaGVyID0gb3B0aW9ucy5jaXBoZXI7XG4gIHRoaXMuYmxvY2tTaXplID0gb3B0aW9ucy5ibG9ja1NpemUgfHwgMTY7XG4gIHRoaXMuX2ludHMgPSB0aGlzLmJsb2NrU2l6ZSAvIDQ7XG4gIHRoaXMuX2luQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX291dEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xufTtcblxubW9kZXMuY2JjLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgLy8gTm90ZTogbGVnYWN5IHN1cHBvcnQgZm9yIHVzaW5nIElWIHJlc2lkdWUgKGhhcyBzZWN1cml0eSBmbGF3cylcbiAgLy8gaWYgSVYgaXMgbnVsbCwgcmV1c2UgYmxvY2sgZnJvbSBwcmV2aW91cyBwcm9jZXNzaW5nXG4gIGlmKG9wdGlvbnMuaXYgPT09IG51bGwpIHtcbiAgICAvLyBtdXN0IGhhdmUgYSBwcmV2aW91cyBibG9ja1xuICAgIGlmKCF0aGlzLl9wcmV2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSVYgcGFyYW1ldGVyLicpO1xuICAgIH1cbiAgICB0aGlzLl9pdiA9IHRoaXMuX3ByZXYuc2xpY2UoMCk7XG4gIH0gZWxzZSBpZighKCdpdicgaW4gb3B0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSVYgcGFyYW1ldGVyLicpO1xuICB9IGVsc2Uge1xuICAgIC8vIHNhdmUgSVYgYXMgXCJwcmV2aW91c1wiIGJsb2NrXG4gICAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2LCB0aGlzLmJsb2NrU2l6ZSk7XG4gICAgdGhpcy5fcHJldiA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB9XG59O1xuXG5tb2Rlcy5jYmMucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBlbmNyeXB0XG4gIGlmKGlucHV0Lmxlbmd0aCgpIDwgdGhpcy5ibG9ja1NpemUgJiYgIShmaW5pc2ggJiYgaW5wdXQubGVuZ3RoKCkgPiAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZ2V0IG5leHQgYmxvY2tcbiAgLy8gQ0JDIFhPUidzIElWIChvciBwcmV2aW91cyBibG9jaykgd2l0aCBwbGFpbnRleHRcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9wcmV2W2ldIF4gaW5wdXQuZ2V0SW50MzIoKTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gd3JpdGUgb3V0cHV0LCBzYXZlIHByZXZpb3VzIGJsb2NrXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG4gIHRoaXMuX3ByZXYgPSB0aGlzLl9vdXRCbG9jaztcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGRlY3J5cHRcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPCB0aGlzLmJsb2NrU2l6ZSAmJiAhKGZpbmlzaCAmJiBpbnB1dC5sZW5ndGgoKSA+IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBnZXQgbmV4dCBibG9ja1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gIH1cblxuICAvLyBkZWNyeXB0IGJsb2NrXG4gIHRoaXMuY2lwaGVyLmRlY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIHdyaXRlIG91dHB1dCwgc2F2ZSBwcmV2aW91cyBjaXBoZXJlZCBibG9ja1xuICAvLyBDQkMgWE9SJ3MgSVYgKG9yIHByZXZpb3VzIGJsb2NrKSB3aXRoIGNpcGhlcnRleHRcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9wcmV2W2ldIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG4gIHRoaXMuX3ByZXYgPSB0aGlzLl9pbkJsb2NrLnNsaWNlKDApO1xufTtcblxubW9kZXMuY2JjLnByb3RvdHlwZS5wYWQgPSBmdW5jdGlvbihpbnB1dCwgb3B0aW9ucykge1xuICAvLyBhZGQgUEtDUyM3IHBhZGRpbmcgdG8gYmxvY2sgKGVhY2ggcGFkIGJ5dGUgaXMgdGhlXG4gIC8vIHZhbHVlIG9mIHRoZSBudW1iZXIgb2YgcGFkIGJ5dGVzKVxuICB2YXIgcGFkZGluZyA9IChpbnB1dC5sZW5ndGgoKSA9PT0gdGhpcy5ibG9ja1NpemUgP1xuICAgIHRoaXMuYmxvY2tTaXplIDogKHRoaXMuYmxvY2tTaXplIC0gaW5wdXQubGVuZ3RoKCkpKTtcbiAgaW5wdXQuZmlsbFdpdGhCeXRlKHBhZGRpbmcsIHBhZGRpbmcpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUudW5wYWQgPSBmdW5jdGlvbihvdXRwdXQsIG9wdGlvbnMpIHtcbiAgLy8gY2hlY2sgZm9yIGVycm9yOiBpbnB1dCBkYXRhIG5vdCBhIG11bHRpcGxlIG9mIGJsb2NrU2l6ZVxuICBpZihvcHRpb25zLm92ZXJmbG93ID4gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBwYWRkaW5nIGJ5dGUgY291bnQgaXMgdmFsaWRcbiAgdmFyIGxlbiA9IG91dHB1dC5sZW5ndGgoKTtcbiAgdmFyIGNvdW50ID0gb3V0cHV0LmF0KGxlbiAtIDEpO1xuICBpZihjb3VudCA+ICh0aGlzLmJsb2NrU2l6ZSA8PCAyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIHRyaW0gb2ZmIHBhZGRpbmcgYnl0ZXNcbiAgb3V0cHV0LnRydW5jYXRlKGNvdW50KTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKiogQ2lwaGVyIGZlZWRiYWNrIChDRkIpICoqL1xuXG5tb2Rlcy5jZmIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm5hbWUgPSAnQ0ZCJztcbiAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgdGhpcy5faW50cyA9IHRoaXMuYmxvY2tTaXplIC8gNDtcbiAgdGhpcy5faW5CbG9jayA9IG51bGw7XG4gIHRoaXMuX291dEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9wYXJ0aWFsQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY2ZiLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfVxuICAvLyB1c2UgSVYgYXMgZmlyc3QgaW5wdXRcbiAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2LCB0aGlzLmJsb2NrU2l6ZSk7XG4gIHRoaXMuX2luQmxvY2sgPSB0aGlzLl9pdi5zbGljZSgwKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbm1vZGVzLmNmYi5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGVuY3J5cHRcbiAgdmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoKCk7XG4gIGlmKGlucHV0TGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBlbmNyeXB0IGJsb2NrXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCwgd3JpdGUgaW5wdXQgYXMgb3V0cHV0XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCkgXiB0aGlzLl9vdXRCbG9ja1tpXTtcbiAgICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9pbkJsb2NrW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaGFuZGxlIHBhcnRpYWwgYmxvY2tcbiAgdmFyIHBhcnRpYWxCeXRlcyA9ICh0aGlzLmJsb2NrU2l6ZSAtIGlucHV0TGVuZ3RoKSAlIHRoaXMuYmxvY2tTaXplO1xuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgcGFydGlhbEJ5dGVzID0gdGhpcy5ibG9ja1NpemUgLSBwYXJ0aWFsQnl0ZXM7XG4gIH1cblxuICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXQsIHdyaXRlIGlucHV0IGFzIHBhcnRpYWwgb3V0cHV0XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQuY2xlYXIoKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIHRoaXMuX3BhcnRpYWxCbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCkgXiB0aGlzLl9vdXRCbG9ja1tpXTtcbiAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LnB1dEludDMyKHRoaXMuX3BhcnRpYWxCbG9ja1tpXSk7XG4gIH1cblxuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgLy8gYmxvY2sgc3RpbGwgaW5jb21wbGV0ZSwgcmVzdG9yZSBpbnB1dCBidWZmZXJcbiAgICBpbnB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICB9IGVsc2Uge1xuICAgIC8vIGJsb2NrIGNvbXBsZXRlLCB1cGRhdGUgaW5wdXQgYmxvY2tcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICB0aGlzLl9pbkJsb2NrW2ldID0gdGhpcy5fcGFydGlhbEJsb2NrW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXModGhpcy5fcGFydGlhbEJ5dGVzKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gcGFydGlhbEJ5dGVzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgaW5wdXRMZW5ndGggLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbm1vZGVzLmNmYi5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGRlY3J5cHRcbiAgdmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoKCk7XG4gIGlmKGlucHV0TGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBlbmNyeXB0IGJsb2NrIChDRkIgYWx3YXlzIHVzZXMgZW5jcnlwdGlvbiBtb2RlKVxuICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyBoYW5kbGUgZnVsbCBibG9ja1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPT09IDAgJiYgaW5wdXRMZW5ndGggPj0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXQsIHdyaXRlIGlucHV0IGFzIG91dHB1dFxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICAgICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX2luQmxvY2tbaV0gXiB0aGlzLl9vdXRCbG9ja1tpXSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGhhbmRsZSBwYXJ0aWFsIGJsb2NrXG4gIHZhciBwYXJ0aWFsQnl0ZXMgPSAodGhpcy5ibG9ja1NpemUgLSBpbnB1dExlbmd0aCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgaWYocGFydGlhbEJ5dGVzID4gMCkge1xuICAgIHBhcnRpYWxCeXRlcyA9IHRoaXMuYmxvY2tTaXplIC0gcGFydGlhbEJ5dGVzO1xuICB9XG5cbiAgLy8gWE9SIGlucHV0IHdpdGggb3V0cHV0LCB3cml0ZSBpbnB1dCBhcyBwYXJ0aWFsIG91dHB1dFxuICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmNsZWFyKCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLl9wYXJ0aWFsQmxvY2tbaV0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQucHV0SW50MzIodGhpcy5fcGFydGlhbEJsb2NrW2ldIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG5cbiAgaWYocGFydGlhbEJ5dGVzID4gMCkge1xuICAgIC8vIGJsb2NrIHN0aWxsIGluY29tcGxldGUsIHJlc3RvcmUgaW5wdXQgYnVmZmVyXG4gICAgaW5wdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBibG9jayBjb21wbGV0ZSwgdXBkYXRlIGlucHV0IGJsb2NrXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5faW5CbG9ja1tpXSA9IHRoaXMuX3BhcnRpYWxCbG9ja1tpXTtcbiAgICB9XG4gIH1cblxuICAvLyBza2lwIGFueSBwcmV2aW91cyBwYXJ0aWFsIGJ5dGVzXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA+IDApIHtcbiAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKHRoaXMuX3BhcnRpYWxCeXRlcyk7XG4gIH1cblxuICBpZihwYXJ0aWFsQnl0ZXMgPiAwICYmICFmaW5pc2gpIHtcbiAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgIHBhcnRpYWxCeXRlcyAtIHRoaXMuX3BhcnRpYWxCeXRlcykpO1xuICAgIHRoaXMuX3BhcnRpYWxCeXRlcyA9IHBhcnRpYWxCeXRlcztcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgIGlucHV0TGVuZ3RoIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG59O1xuXG4vKiogT3V0cHV0IGZlZWRiYWNrIChPRkIpICoqL1xuXG5tb2Rlcy5vZmIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm5hbWUgPSAnT0ZCJztcbiAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgdGhpcy5faW50cyA9IHRoaXMuYmxvY2tTaXplIC8gNDtcbiAgdGhpcy5faW5CbG9jayA9IG51bGw7XG4gIHRoaXMuX291dEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9wYXJ0aWFsT3V0cHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbm1vZGVzLm9mYi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmKCEoJ2l2JyBpbiBvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJViBwYXJhbWV0ZXIuJyk7XG4gIH1cbiAgLy8gdXNlIElWIGFzIGZpcnN0IGlucHV0XG4gIHRoaXMuX2l2ID0gdHJhbnNmb3JtSVYob3B0aW9ucy5pdiwgdGhpcy5ibG9ja1NpemUpO1xuICB0aGlzLl9pbkJsb2NrID0gdGhpcy5faXYuc2xpY2UoMCk7XG4gIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG59O1xuXG5tb2Rlcy5vZmIucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBlbmNyeXB0XG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCgpO1xuICBpZihpbnB1dC5sZW5ndGgoKSA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZW5jcnlwdCBibG9jayAoT0ZCIGFsd2F5cyB1c2VzIGVuY3J5cHRpb24gbW9kZSlcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gaGFuZGxlIGZ1bGwgYmxvY2tcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID09PSAwICYmIGlucHV0TGVuZ3RoID49IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgLy8gWE9SIGlucHV0IHdpdGggb3V0cHV0IGFuZCB1cGRhdGUgbmV4dCBpbnB1dFxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIG91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgICAgdGhpcy5faW5CbG9ja1tpXSA9IHRoaXMuX291dEJsb2NrW2ldO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICB2YXIgcGFydGlhbEJ5dGVzID0gKHRoaXMuYmxvY2tTaXplIC0gaW5wdXRMZW5ndGgpICUgdGhpcy5ibG9ja1NpemU7XG4gIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgfVxuXG4gIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dFxuICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmNsZWFyKCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LnB1dEludDMyKGlucHV0LmdldEludDMyKCkgXiB0aGlzLl9vdXRCbG9ja1tpXSk7XG4gIH1cblxuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgLy8gYmxvY2sgc3RpbGwgaW5jb21wbGV0ZSwgcmVzdG9yZSBpbnB1dCBidWZmZXJcbiAgICBpbnB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICB9IGVsc2Uge1xuICAgIC8vIGJsb2NrIGNvbXBsZXRlLCB1cGRhdGUgaW5wdXQgYmxvY2tcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICB0aGlzLl9pbkJsb2NrW2ldID0gdGhpcy5fb3V0QmxvY2tbaV07XG4gICAgfVxuICB9XG5cbiAgLy8gc2tpcCBhbnkgcHJldmlvdXMgcGFydGlhbCBieXRlc1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyh0aGlzLl9wYXJ0aWFsQnl0ZXMpO1xuICB9XG5cbiAgaWYocGFydGlhbEJ5dGVzID4gMCAmJiAhZmluaXNoKSB7XG4gICAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgICBwYXJ0aWFsQnl0ZXMgLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICBpbnB1dExlbmd0aCAtIHRoaXMuX3BhcnRpYWxCeXRlcykpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMub2ZiLnByb3RvdHlwZS5kZWNyeXB0ID0gbW9kZXMub2ZiLnByb3RvdHlwZS5lbmNyeXB0O1xuXG4vKiogQ291bnRlciAoQ1RSKSAqKi9cblxubW9kZXMuY3RyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5uYW1lID0gJ0NUUic7XG4gIHRoaXMuY2lwaGVyID0gb3B0aW9ucy5jaXBoZXI7XG4gIHRoaXMuYmxvY2tTaXplID0gb3B0aW9ucy5ibG9ja1NpemUgfHwgMTY7XG4gIHRoaXMuX2ludHMgPSB0aGlzLmJsb2NrU2l6ZSAvIDQ7XG4gIHRoaXMuX2luQmxvY2sgPSBudWxsO1xuICB0aGlzLl9vdXRCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgdGhpcy5fcGFydGlhbE91dHB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG59O1xuXG5tb2Rlcy5jdHIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZighKCdpdicgaW4gb3B0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSVYgcGFyYW1ldGVyLicpO1xuICB9XG4gIC8vIHVzZSBJViBhcyBmaXJzdCBpbnB1dFxuICB0aGlzLl9pdiA9IHRyYW5zZm9ybUlWKG9wdGlvbnMuaXYsIHRoaXMuYmxvY2tTaXplKTtcbiAgdGhpcy5faW5CbG9jayA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY3RyLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKENUUiBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dFxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIG91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICAgIHZhciBwYXJ0aWFsQnl0ZXMgPSAodGhpcy5ibG9ja1NpemUgLSBpbnB1dExlbmd0aCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgICB9XG5cbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmNsZWFyKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgIH1cblxuICAgIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAgIC8vIGJsb2NrIHN0aWxsIGluY29tcGxldGUsIHJlc3RvcmUgaW5wdXQgYnVmZmVyXG4gICAgICBpbnB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICAgIH1cblxuICAgIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKHRoaXMuX3BhcnRpYWxCeXRlcyk7XG4gICAgfVxuXG4gICAgaWYocGFydGlhbEJ5dGVzID4gMCAmJiAhZmluaXNoKSB7XG4gICAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgIGlucHV0TGVuZ3RoIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbiAgfVxuXG4gIC8vIGJsb2NrIGNvbXBsZXRlLCBpbmNyZW1lbnQgY291bnRlciAoaW5wdXQgYmxvY2spXG4gIGluYzMyKHRoaXMuX2luQmxvY2spO1xufTtcblxubW9kZXMuY3RyLnByb3RvdHlwZS5kZWNyeXB0ID0gbW9kZXMuY3RyLnByb3RvdHlwZS5lbmNyeXB0O1xuXG4vKiogR2Fsb2lzL0NvdW50ZXIgTW9kZSAoR0NNKSAqKi9cblxubW9kZXMuZ2NtID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5uYW1lID0gJ0dDTSc7XG4gIHRoaXMuY2lwaGVyID0gb3B0aW9ucy5jaXBoZXI7XG4gIHRoaXMuYmxvY2tTaXplID0gb3B0aW9ucy5ibG9ja1NpemUgfHwgMTY7XG4gIHRoaXMuX2ludHMgPSB0aGlzLmJsb2NrU2l6ZSAvIDQ7XG4gIHRoaXMuX2luQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX291dEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9wYXJ0aWFsT3V0cHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcblxuICAvLyBSIGlzIGFjdHVhbGx5IHRoaXMgdmFsdWUgY29uY2F0ZW5hdGVkIHdpdGggMTIwIG1vcmUgemVybyBiaXRzLCBidXRcbiAgLy8gd2Ugb25seSBYT1IgYWdhaW5zdCBSIHNvIHRoZSBvdGhlciB6ZXJvcyBoYXZlIG5vIGVmZmVjdCAtLSB3ZSBqdXN0XG4gIC8vIGFwcGx5IHRoaXMgdmFsdWUgdG8gdGhlIGZpcnN0IGludGVnZXIgaW4gYSBibG9ja1xuICB0aGlzLl9SID0gMHhFMTAwMDAwMDtcbn07XG5cbm1vZGVzLmdjbS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmKCEoJ2l2JyBpbiBvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJViBwYXJhbWV0ZXIuJyk7XG4gIH1cbiAgLy8gZW5zdXJlIElWIGlzIGEgYnl0ZSBidWZmZXJcbiAgdmFyIGl2ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy5pdik7XG5cbiAgLy8gbm8gY2lwaGVyZWQgZGF0YSBwcm9jZXNzZWQgeWV0XG4gIHRoaXMuX2NpcGhlckxlbmd0aCA9IDA7XG5cbiAgLy8gZGVmYXVsdCBhZGRpdGlvbmFsIGRhdGEgaXMgbm9uZVxuICB2YXIgYWRkaXRpb25hbERhdGE7XG4gIGlmKCdhZGRpdGlvbmFsRGF0YScgaW4gb3B0aW9ucykge1xuICAgIGFkZGl0aW9uYWxEYXRhID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy5hZGRpdGlvbmFsRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgYWRkaXRpb25hbERhdGEgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB9XG5cbiAgLy8gZGVmYXVsdCB0YWcgbGVuZ3RoIGlzIDEyOCBiaXRzXG4gIGlmKCd0YWdMZW5ndGgnIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLl90YWdMZW5ndGggPSBvcHRpb25zLnRhZ0xlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl90YWdMZW5ndGggPSAxMjg7XG4gIH1cblxuICAvLyBpZiB0YWcgaXMgZ2l2ZW4sIGVuc3VyZSB0YWcgbWF0Y2hlcyB0YWcgbGVuZ3RoXG4gIHRoaXMuX3RhZyA9IG51bGw7XG4gIGlmKG9wdGlvbnMuZGVjcnlwdCkge1xuICAgIC8vIHNhdmUgdGFnIHRvIGNoZWNrIGxhdGVyXG4gICAgdGhpcy5fdGFnID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy50YWcpLmdldEJ5dGVzKCk7XG4gICAgaWYodGhpcy5fdGFnLmxlbmd0aCAhPT0gKHRoaXMuX3RhZ0xlbmd0aCAvIDgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIHRhZyBkb2VzIG5vdCBtYXRjaCB0YWcgbGVuZ3RoLicpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNyZWF0ZSB0bXAgc3RvcmFnZSBmb3IgaGFzaCBjYWxjdWxhdGlvblxuICB0aGlzLl9oYXNoQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG5cbiAgLy8gbm8gdGFnIGdlbmVyYXRlZCB5ZXRcbiAgdGhpcy50YWcgPSBudWxsO1xuXG4gIC8vIGdlbmVyYXRlIGhhc2ggc3Via2V5XG4gIC8vIChhcHBseSBibG9jayBjaXBoZXIgdG8gXCJ6ZXJvXCIgYmxvY2spXG4gIHRoaXMuX2hhc2hTdWJrZXkgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQoWzAsIDAsIDAsIDBdLCB0aGlzLl9oYXNoU3Via2V5KTtcblxuICAvLyBnZW5lcmF0ZSB0YWJsZSBNXG4gIC8vIHVzZSA0LWJpdCB0YWJsZXMgKDMyIGNvbXBvbmVudCBkZWNvbXBvc2l0aW9uIG9mIGEgMTYgYnl0ZSB2YWx1ZSlcbiAgLy8gOC1iaXQgdGFibGVzIHRha2UgbW9yZSBzcGFjZSBhbmQgYXJlIGtub3duIHRvIGhhdmUgc2VjdXJpdHlcbiAgLy8gdnVsbmVyYWJpbGl0aWVzIChpbiBuYXRpdmUgaW1wbGVtZW50YXRpb25zKVxuICB0aGlzLmNvbXBvbmVudEJpdHMgPSA0O1xuICB0aGlzLl9tID0gdGhpcy5nZW5lcmF0ZUhhc2hUYWJsZSh0aGlzLl9oYXNoU3Via2V5LCB0aGlzLmNvbXBvbmVudEJpdHMpO1xuXG4gIC8vIE5vdGU6IHN1cHBvcnQgSVYgbGVuZ3RoIGRpZmZlcmVudCBmcm9tIDk2IGJpdHM/IChvbmx5IHN1cHBvcnRpbmdcbiAgLy8gOTYgYml0cyBpcyByZWNvbW1lbmRlZCBieSBOSVNUIFNQLTgwMC0zOEQpXG4gIC8vIGdlbmVyYXRlIEpfMFxuICB2YXIgaXZMZW5ndGggPSBpdi5sZW5ndGgoKTtcbiAgaWYoaXZMZW5ndGggPT09IDEyKSB7XG4gICAgLy8gOTYtYml0IElWXG4gICAgdGhpcy5fajAgPSBbaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgMV07XG4gIH0gZWxzZSB7XG4gICAgLy8gSVYgaXMgTk9UIDk2LWJpdHNcbiAgICB0aGlzLl9qMCA9IFswLCAwLCAwLCAwXTtcbiAgICB3aGlsZShpdi5sZW5ndGgoKSA+IDApIHtcbiAgICAgIHRoaXMuX2owID0gdGhpcy5naGFzaChcbiAgICAgICAgdGhpcy5faGFzaFN1YmtleSwgdGhpcy5fajAsXG4gICAgICAgIFtpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpXSk7XG4gICAgfVxuICAgIHRoaXMuX2owID0gdGhpcy5naGFzaChcbiAgICAgIHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuX2owLCBbMCwgMF0uY29uY2F0KGZyb202NFRvMzIoaXZMZW5ndGggKiA4KSkpO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgSUNCIChpbml0aWFsIGNvdW50ZXIgYmxvY2spXG4gIHRoaXMuX2luQmxvY2sgPSB0aGlzLl9qMC5zbGljZSgwKTtcbiAgaW5jMzIodGhpcy5faW5CbG9jayk7XG4gIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG5cbiAgLy8gY29uc3VtZSBhdXRoZW50aWNhdGlvbiBkYXRhXG4gIGFkZGl0aW9uYWxEYXRhID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoYWRkaXRpb25hbERhdGEpO1xuICAvLyBzYXZlIGFkZGl0aW9uYWwgZGF0YSBsZW5ndGggYXMgYSBCRSA2NC1iaXQgbnVtYmVyXG4gIHRoaXMuX2FEYXRhTGVuZ3RoID0gZnJvbTY0VG8zMihhZGRpdGlvbmFsRGF0YS5sZW5ndGgoKSAqIDgpO1xuICAvLyBwYWQgYWRkaXRpb25hbCBkYXRhIHRvIDEyOCBiaXQgKDE2IGJ5dGUpIGJsb2NrIHNpemVcbiAgdmFyIG92ZXJmbG93ID0gYWRkaXRpb25hbERhdGEubGVuZ3RoKCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgaWYob3ZlcmZsb3cpIHtcbiAgICBhZGRpdGlvbmFsRGF0YS5maWxsV2l0aEJ5dGUoMCwgdGhpcy5ibG9ja1NpemUgLSBvdmVyZmxvdyk7XG4gIH1cbiAgdGhpcy5fcyA9IFswLCAwLCAwLCAwXTtcbiAgd2hpbGUoYWRkaXRpb25hbERhdGEubGVuZ3RoKCkgPiAwKSB7XG4gICAgdGhpcy5fcyA9IHRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSwgdGhpcy5fcywgW1xuICAgICAgYWRkaXRpb25hbERhdGEuZ2V0SW50MzIoKSxcbiAgICAgIGFkZGl0aW9uYWxEYXRhLmdldEludDMyKCksXG4gICAgICBhZGRpdGlvbmFsRGF0YS5nZXRJbnQzMigpLFxuICAgICAgYWRkaXRpb25hbERhdGEuZ2V0SW50MzIoKVxuICAgIF0pO1xuICB9XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBlbmNyeXB0XG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCgpO1xuICBpZihpbnB1dExlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZW5jcnlwdCBibG9ja1xuICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyBoYW5kbGUgZnVsbCBibG9ja1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPT09IDAgJiYgaW5wdXRMZW5ndGggPj0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0gXj0gaW5wdXQuZ2V0SW50MzIoKSk7XG4gICAgfVxuICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICAgIHZhciBwYXJ0aWFsQnl0ZXMgPSAodGhpcy5ibG9ja1NpemUgLSBpbnB1dExlbmd0aCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgICB9XG5cbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmNsZWFyKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgIH1cblxuICAgIGlmKHBhcnRpYWxCeXRlcyA8PSAwIHx8IGZpbmlzaCkge1xuICAgICAgLy8gaGFuZGxlIG92ZXJmbG93IHByaW9yIHRvIGhhc2hpbmdcbiAgICAgIGlmKGZpbmlzaCkge1xuICAgICAgICAvLyBnZXQgYmxvY2sgb3ZlcmZsb3dcbiAgICAgICAgdmFyIG92ZXJmbG93ID0gaW5wdXRMZW5ndGggJSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgICAgdGhpcy5fY2lwaGVyTGVuZ3RoICs9IG92ZXJmbG93O1xuICAgICAgICAvLyB0cnVuY2F0ZSBmb3IgaGFzaCBmdW5jdGlvblxuICAgICAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LnRydW5jYXRlKHRoaXMuYmxvY2tTaXplIC0gb3ZlcmZsb3cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY2lwaGVyTGVuZ3RoICs9IHRoaXMuYmxvY2tTaXplO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgb3V0cHV0IGJsb2NrIGZvciBoYXNoaW5nXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICAgIHRoaXMuX291dEJsb2NrW2ldID0gdGhpcy5fcGFydGlhbE91dHB1dC5nZXRJbnQzMigpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICAgIH1cblxuICAgIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKHRoaXMuX3BhcnRpYWxCeXRlcyk7XG4gICAgfVxuXG4gICAgaWYocGFydGlhbEJ5dGVzID4gMCAmJiAhZmluaXNoKSB7XG4gICAgICAvLyBibG9jayBzdGlsbCBpbmNvbXBsZXRlLCByZXN0b3JlIGlucHV0IGJ1ZmZlciwgZ2V0IHBhcnRpYWwgb3V0cHV0LFxuICAgICAgLy8gYW5kIHJldHVybiBlYXJseVxuICAgICAgaW5wdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgICBwYXJ0aWFsQnl0ZXMgLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgICAgIHRoaXMuX3BhcnRpYWxCeXRlcyA9IHBhcnRpYWxCeXRlcztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgaW5wdXRMZW5ndGggLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xuICB9XG5cbiAgLy8gdXBkYXRlIGhhc2ggYmxvY2sgU1xuICB0aGlzLl9zID0gdGhpcy5naGFzaCh0aGlzLl9oYXNoU3Via2V5LCB0aGlzLl9zLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gaW5jcmVtZW50IGNvdW50ZXIgKGlucHV0IGJsb2NrKVxuICBpbmMzMih0aGlzLl9pbkJsb2NrKTtcbn07XG5cbm1vZGVzLmdjbS5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGRlY3J5cHRcbiAgdmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoKCk7XG4gIGlmKGlucHV0TGVuZ3RoIDwgdGhpcy5ibG9ja1NpemUgJiYgIShmaW5pc2ggJiYgaW5wdXRMZW5ndGggPiAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZW5jcnlwdCBibG9jayAoR0NNIGFsd2F5cyB1c2VzIGVuY3J5cHRpb24gbW9kZSlcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gaW5jcmVtZW50IGNvdW50ZXIgKGlucHV0IGJsb2NrKVxuICBpbmMzMih0aGlzLl9pbkJsb2NrKTtcblxuICAvLyB1cGRhdGUgaGFzaCBibG9jayBTXG4gIHRoaXMuX2hhc2hCbG9ja1swXSA9IGlucHV0LmdldEludDMyKCk7XG4gIHRoaXMuX2hhc2hCbG9ja1sxXSA9IGlucHV0LmdldEludDMyKCk7XG4gIHRoaXMuX2hhc2hCbG9ja1syXSA9IGlucHV0LmdldEludDMyKCk7XG4gIHRoaXMuX2hhc2hCbG9ja1szXSA9IGlucHV0LmdldEludDMyKCk7XG4gIHRoaXMuX3MgPSB0aGlzLmdoYXNoKHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuX3MsIHRoaXMuX2hhc2hCbG9jayk7XG5cbiAgLy8gWE9SIGhhc2ggaW5wdXQgd2l0aCBvdXRwdXRcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9vdXRCbG9ja1tpXSBeIHRoaXMuX2hhc2hCbG9ja1tpXSk7XG4gIH1cblxuICAvLyBpbmNyZW1lbnQgY2lwaGVyIGRhdGEgbGVuZ3RoXG4gIGlmKGlucHV0TGVuZ3RoIDwgdGhpcy5ibG9ja1NpemUpIHtcbiAgICB0aGlzLl9jaXBoZXJMZW5ndGggKz0gaW5wdXRMZW5ndGggJSB0aGlzLmJsb2NrU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jaXBoZXJMZW5ndGggKz0gdGhpcy5ibG9ja1NpemU7XG4gIH1cbn07XG5cbm1vZGVzLmdjbS5wcm90b3R5cGUuYWZ0ZXJGaW5pc2ggPSBmdW5jdGlvbihvdXRwdXQsIG9wdGlvbnMpIHtcbiAgdmFyIHJ2YWwgPSB0cnVlO1xuXG4gIC8vIGhhbmRsZSBvdmVyZmxvd1xuICBpZihvcHRpb25zLmRlY3J5cHQgJiYgb3B0aW9ucy5vdmVyZmxvdykge1xuICAgIG91dHB1dC50cnVuY2F0ZSh0aGlzLmJsb2NrU2l6ZSAtIG9wdGlvbnMub3ZlcmZsb3cpO1xuICB9XG5cbiAgLy8gaGFuZGxlIGF1dGhlbnRpY2F0aW9uIHRhZ1xuICB0aGlzLnRhZyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gY29uY2F0ZW5hdGUgYWRkaXRpb25hbCBkYXRhIGxlbmd0aCB3aXRoIGNpcGhlciBsZW5ndGhcbiAgdmFyIGxlbmd0aHMgPSB0aGlzLl9hRGF0YUxlbmd0aC5jb25jYXQoZnJvbTY0VG8zMih0aGlzLl9jaXBoZXJMZW5ndGggKiA4KSk7XG5cbiAgLy8gaW5jbHVkZSBsZW5ndGhzIGluIGhhc2hcbiAgdGhpcy5fcyA9IHRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSwgdGhpcy5fcywgbGVuZ3Rocyk7XG5cbiAgLy8gZG8gR0NUUihKXzAsIFMpXG4gIHZhciB0YWcgPSBbXTtcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9qMCwgdGFnKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIHRoaXMudGFnLnB1dEludDMyKHRoaXMuX3NbaV0gXiB0YWdbaV0pO1xuICB9XG5cbiAgLy8gdHJpbSB0YWcgdG8gbGVuZ3RoXG4gIHRoaXMudGFnLnRydW5jYXRlKHRoaXMudGFnLmxlbmd0aCgpICUgKHRoaXMuX3RhZ0xlbmd0aCAvIDgpKTtcblxuICAvLyBjaGVjayBhdXRoZW50aWNhdGlvbiB0YWdcbiAgaWYob3B0aW9ucy5kZWNyeXB0ICYmIHRoaXMudGFnLmJ5dGVzKCkgIT09IHRoaXMuX3RhZykge1xuICAgIHJ2YWwgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBTZWUgTklTVCBTUC04MDAtMzhEIDYuMyAoQWxnb3JpdGhtIDEpLiBUaGlzIGZ1bmN0aW9uIHBlcmZvcm1zIEdhbG9pc1xuICogZmllbGQgbXVsdGlwbGljYXRpb24uIFRoZSBmaWVsZCwgR0YoMl4xMjgpLCBpcyBkZWZpbmVkIGJ5IHRoZSBwb2x5bm9taWFsOlxuICpcbiAqIHheMTI4ICsgeF43ICsgeF4yICsgeCArIDFcbiAqXG4gKiBXaGljaCBpcyByZXByZXNlbnRlZCBpbiBsaXR0bGUtZW5kaWFuIGJpbmFyeSBmb3JtIGFzOiAxMTEwMDAwMSAoMHhlMSkuIFdoZW5cbiAqIHRoZSB2YWx1ZSBvZiBhIGNvZWZmaWNpZW50IGlzIDEsIGEgYml0IGlzIHNldC4gVGhlIHZhbHVlIFIsIGlzIHRoZVxuICogY29uY2F0ZW5hdGlvbiBvZiB0aGlzIHZhbHVlIGFuZCAxMjAgemVybyBiaXRzLCB5aWVsZGluZyBhIDEyOC1iaXQgdmFsdWVcbiAqIHdoaWNoIG1hdGNoZXMgdGhlIGJsb2NrIHNpemUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIG11bHRpcGx5IHR3byBlbGVtZW50cyAodmVjdG9ycyBvZiBieXRlcyksIFggYW5kIFksIGluXG4gKiB0aGUgZmllbGQgR0YoMl4xMjgpLiBUaGUgcmVzdWx0IGlzIGluaXRpYWxpemVkIHRvIHplcm8uIEZvciBlYWNoIGJpdCBvZlxuICogWCAob3V0IG9mIDEyOCksIHhfaSwgaWYgeF9pIGlzIHNldCwgdGhlbiB0aGUgcmVzdWx0IGlzIG11bHRpcGxpZWQgKFhPUidkKVxuICogYnkgdGhlIGN1cnJlbnQgdmFsdWUgb2YgWS4gRm9yIGVhY2ggYml0LCB0aGUgdmFsdWUgb2YgWSB3aWxsIGJlIHJhaXNlZCBieVxuICogYSBwb3dlciBvZiB4IChtdWx0aXBsaWVkIGJ5IHRoZSBwb2x5bm9taWFsIHgpLiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieVxuICogc2hpZnRpbmcgWSBvbmNlIHRvIHRoZSByaWdodC4gSWYgdGhlIGN1cnJlbnQgdmFsdWUgb2YgWSwgcHJpb3IgdG8gYmVpbmdcbiAqIG11bHRpcGxpZWQgYnkgeCwgaGFzIDAgYXMgaXRzIExTQiwgdGhlbiBpdCBpcyBhIDEyN3RoIGRlZ3JlZSBwb2x5bm9taWFsLlxuICogT3RoZXJ3aXNlLCB3ZSBtdXN0IGRpdmlkZSBieSBSIGFmdGVyIHNoaWZ0aW5nIHRvIGZpbmQgdGhlIHJlbWFpbmRlci5cbiAqXG4gKiBAcGFyYW0geCB0aGUgZmlyc3QgYmxvY2sgdG8gbXVsdGlwbHkgYnkgdGhlIHNlY29uZC5cbiAqIEBwYXJhbSB5IHRoZSBzZWNvbmQgYmxvY2sgdG8gbXVsdGlwbHkgYnkgdGhlIGZpcnN0LlxuICpcbiAqIEByZXR1cm4gdGhlIGJsb2NrIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uXG4gKi9cbm1vZGVzLmdjbS5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciB6X2kgPSBbMCwgMCwgMCwgMF07XG4gIHZhciB2X2kgPSB5LnNsaWNlKDApO1xuXG4gIC8vIGNhbGN1bGF0ZSBaXzEyOCAoYmxvY2sgaGFzIDEyOCBiaXRzKVxuICBmb3IodmFyIGkgPSAwOyBpIDwgMTI4OyArK2kpIHtcbiAgICAvLyBpZiB4X2kgaXMgMCwgWl97aSsxfSA9IFpfaSAodW5jaGFuZ2VkKVxuICAgIC8vIGVsc2UgWl97aSsxfSA9IFpfaSBeIFZfaVxuICAgIC8vIGdldCB4X2kgYnkgZmluZGluZyAzMi1iaXQgaW50IHBvc2l0aW9uLCB0aGVuIGxlZnQgc2hpZnQgMSBieSByZW1haW5kZXJcbiAgICB2YXIgeF9pID0geFsoaSAvIDMyKSB8IDBdICYgKDEgPDwgKDMxIC0gaSAlIDMyKSk7XG4gICAgaWYoeF9pKSB7XG4gICAgICB6X2lbMF0gXj0gdl9pWzBdO1xuICAgICAgel9pWzFdIF49IHZfaVsxXTtcbiAgICAgIHpfaVsyXSBePSB2X2lbMl07XG4gICAgICB6X2lbM10gXj0gdl9pWzNdO1xuICAgIH1cblxuICAgIC8vIGlmIExTQihWX2kpIGlzIDEsIFZfaSA9IFZfaSA+PiAxXG4gICAgLy8gZWxzZSBWX2kgPSAoVl9pID4+IDEpIF4gUlxuICAgIHRoaXMucG93KHZfaSwgdl9pKTtcbiAgfVxuXG4gIHJldHVybiB6X2k7XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uKHgsIG91dCkge1xuICAvLyBpZiBMU0IoeCkgaXMgMSwgeCA9IHggPj4+IDFcbiAgLy8gZWxzZSB4ID0gKHggPj4+IDEpIF4gUlxuICB2YXIgbHNiID0geFszXSAmIDE7XG5cbiAgLy8gYWx3YXlzIGRvIHggPj4+IDE6XG4gIC8vIHN0YXJ0aW5nIHdpdGggdGhlIHJpZ2h0bW9zdCBpbnRlZ2VyLCBzaGlmdCBlYWNoIGludGVnZXIgdG8gdGhlIHJpZ2h0XG4gIC8vIG9uZSBiaXQsIHB1bGxpbmcgaW4gdGhlIGJpdCBmcm9tIHRoZSBpbnRlZ2VyIHRvIHRoZSBsZWZ0IGFzIGl0cyB0b3BcbiAgLy8gbW9zdCBiaXQgKGRvIHRoaXMgZm9yIHRoZSBsYXN0IDMgaW50ZWdlcnMpXG4gIGZvcih2YXIgaSA9IDM7IGkgPiAwOyAtLWkpIHtcbiAgICBvdXRbaV0gPSAoeFtpXSA+Pj4gMSkgfCAoKHhbaSAtIDFdICYgMSkgPDwgMzEpO1xuICB9XG4gIC8vIHNoaWZ0IHRoZSBmaXJzdCBpbnRlZ2VyIG5vcm1hbGx5XG4gIG91dFswXSA9IHhbMF0gPj4+IDE7XG5cbiAgLy8gaWYgbHNiIHdhcyBub3Qgc2V0LCB0aGVuIHBvbHlub21pYWwgaGFkIGEgZGVncmVlIG9mIDEyNyBhbmQgZG9lc24ndFxuICAvLyBuZWVkIHRvIGRpdmlkZWQ7IG90aGVyd2lzZSwgWE9SIHdpdGggUiB0byBmaW5kIHRoZSByZW1haW5kZXI7IHdlIG9ubHlcbiAgLy8gbmVlZCB0byBYT1IgdGhlIGZpcnN0IGludGVnZXIgc2luY2UgUiB0ZWNobmljYWxseSBlbmRzIHcvMTIwIHplcm8gYml0c1xuICBpZihsc2IpIHtcbiAgICBvdXRbMF0gXj0gdGhpcy5fUjtcbiAgfVxufTtcblxubW9kZXMuZ2NtLnByb3RvdHlwZS50YWJsZU11bHRpcGx5ID0gZnVuY3Rpb24oeCkge1xuICAvLyBhc3N1bWVzIDQtYml0IHRhYmxlcyBhcmUgdXNlZFxuICB2YXIgeiA9IFswLCAwLCAwLCAwXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDMyOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gKGkgLyA4KSB8IDA7XG4gICAgdmFyIHhfaSA9ICh4W2lkeF0gPj4+ICgoNyAtIChpICUgOCkpICogNCkpICYgMHhGO1xuICAgIHZhciBhaCA9IHRoaXMuX21baV1beF9pXTtcbiAgICB6WzBdIF49IGFoWzBdO1xuICAgIHpbMV0gXj0gYWhbMV07XG4gICAgelsyXSBePSBhaFsyXTtcbiAgICB6WzNdIF49IGFoWzNdO1xuICB9XG4gIHJldHVybiB6O1xufTtcblxuLyoqXG4gKiBBIGNvbnRpbnVpbmcgdmVyc2lvbiBvZiB0aGUgR0hBU0ggYWxnb3JpdGhtIHRoYXQgb3BlcmF0ZXMgb24gYSBzaW5nbGVcbiAqIGJsb2NrLiBUaGUgaGFzaCBibG9jaywgbGFzdCBoYXNoIHZhbHVlIChZbSkgYW5kIHRoZSBuZXcgYmxvY2sgdG8gaGFzaFxuICogYXJlIGdpdmVuLlxuICpcbiAqIEBwYXJhbSBoIHRoZSBoYXNoIGJsb2NrLlxuICogQHBhcmFtIHkgdGhlIHByZXZpb3VzIHZhbHVlIGZvciBZbSwgdXNlIFswLCAwLCAwLCAwXSBmb3IgYSBuZXcgaGFzaC5cbiAqIEBwYXJhbSB4IHRoZSBibG9jayB0byBoYXNoLlxuICpcbiAqIEByZXR1cm4gdGhlIGhhc2hlZCB2YWx1ZSAoWW0pLlxuICovXG5tb2Rlcy5nY20ucHJvdG90eXBlLmdoYXNoID0gZnVuY3Rpb24oaCwgeSwgeCkge1xuICB5WzBdIF49IHhbMF07XG4gIHlbMV0gXj0geFsxXTtcbiAgeVsyXSBePSB4WzJdO1xuICB5WzNdIF49IHhbM107XG4gIHJldHVybiB0aGlzLnRhYmxlTXVsdGlwbHkoeSk7XG4gIC8vcmV0dXJuIHRoaXMubXVsdGlwbHkoeSwgaCk7XG59O1xuXG4vKipcbiAqIFByZWNvbXB1dGVzIGEgdGFibGUgZm9yIG11bHRpcGx5aW5nIGFnYWluc3QgdGhlIGhhc2ggc3Via2V5LiBUaGlzXG4gKiBtZWNoYW5pc20gcHJvdmlkZXMgYSBzdWJzdGFudGlhbCBzcGVlZCBpbmNyZWFzZSBvdmVyIG11bHRpcGxpY2F0aW9uXG4gKiBwZXJmb3JtZWQgd2l0aG91dCBhIHRhYmxlLiBUaGUgdGFibGUtYmFzZWQgbXVsdGlwbGljYXRpb24gdGhpcyB0YWJsZSBpc1xuICogZm9yIHNvbHZlcyBYICogSCBieSBtdWx0aXBseWluZyBlYWNoIGNvbXBvbmVudCBvZiBYIGJ5IEggYW5kIHRoZW5cbiAqIGNvbXBvc2luZyB0aGUgcmVzdWx0cyB0b2dldGhlciB1c2luZyBYT1IuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBnZW5lcmF0ZSB0YWJsZXMgd2l0aCBkaWZmZXJlbnQgYml0IHNpemVzXG4gKiBmb3IgdGhlIGNvbXBvbmVudHMsIGhvd2V2ZXIsIHRoaXMgaW1wbGVtZW50YXRpb24gYXNzdW1lcyB0aGVyZSBhcmVcbiAqIDMyIGNvbXBvbmVudHMgb2YgWCAod2hpY2ggaXMgYSAxNiBieXRlIHZlY3RvciksIHRoZXJlZm9yZSBlYWNoIGNvbXBvbmVudFxuICogdGFrZXMgNC1iaXRzIChzbyB0aGUgdGFibGUgaXMgY29uc3RydWN0ZWQgd2l0aCBiaXRzPTQpLlxuICpcbiAqIEBwYXJhbSBoIHRoZSBoYXNoIHN1YmtleS5cbiAqIEBwYXJhbSBiaXRzIHRoZSBiaXQgc2l6ZSBmb3IgYSBjb21wb25lbnQuXG4gKi9cbm1vZGVzLmdjbS5wcm90b3R5cGUuZ2VuZXJhdGVIYXNoVGFibGUgPSBmdW5jdGlvbihoLCBiaXRzKSB7XG4gIC8vIFRPRE86IFRoZXJlIGFyZSBmdXJ0aGVyIG9wdGltaXphdGlvbnMgdGhhdCB3b3VsZCB1c2Ugb25seSB0aGVcbiAgLy8gZmlyc3QgdGFibGUgTV8wIChvciBzb21lIHZhcmlhbnQpIGFsb25nIHdpdGggYSByZW1haW5kZXIgdGFibGU7XG4gIC8vIHRoaXMgY2FuIGJlIGV4cGxvcmVkIGluIHRoZSBmdXR1cmVcbiAgdmFyIG11bHRpcGxpZXIgPSA4IC8gYml0cztcbiAgdmFyIHBlckludCA9IDQgKiBtdWx0aXBsaWVyO1xuICB2YXIgc2l6ZSA9IDE2ICogbXVsdGlwbGllcjtcbiAgdmFyIG0gPSBuZXcgQXJyYXkoc2l6ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICB2YXIgdG1wID0gWzAsIDAsIDAsIDBdO1xuICAgIHZhciBpZHggPSAoaSAvIHBlckludCkgfCAwO1xuICAgIHZhciBzaGZ0ID0gKChwZXJJbnQgLSAxIC0gKGkgJSBwZXJJbnQpKSAqIGJpdHMpO1xuICAgIHRtcFtpZHhdID0gKDEgPDwgKGJpdHMgLSAxKSkgPDwgc2hmdDtcbiAgICBtW2ldID0gdGhpcy5nZW5lcmF0ZVN1Ykhhc2hUYWJsZSh0aGlzLm11bHRpcGx5KHRtcCwgaCksIGJpdHMpO1xuICB9XG4gIHJldHVybiBtO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSB0YWJsZSBmb3IgbXVsdGlwbHlpbmcgYWdhaW5zdCB0aGUgaGFzaCBzdWJrZXkgZm9yIG9uZVxuICogcGFydGljdWxhciBjb21wb25lbnQgKG91dCBvZiBhbGwgcG9zc2libGUgY29tcG9uZW50IHZhbHVlcykuXG4gKlxuICogQHBhcmFtIG1pZCB0aGUgcHJlLW11bHRpcGxpZWQgdmFsdWUgZm9yIHRoZSBtaWRkbGUga2V5IG9mIHRoZSB0YWJsZS5cbiAqIEBwYXJhbSBiaXRzIHRoZSBiaXQgc2l6ZSBmb3IgYSBjb21wb25lbnQuXG4gKi9cbm1vZGVzLmdjbS5wcm90b3R5cGUuZ2VuZXJhdGVTdWJIYXNoVGFibGUgPSBmdW5jdGlvbihtaWQsIGJpdHMpIHtcbiAgLy8gY29tcHV0ZSB0aGUgdGFibGUgcXVpY2tseSBieSBtaW5pbWl6aW5nIHRoZSBudW1iZXIgb2ZcbiAgLy8gUE9XIG9wZXJhdGlvbnMgLS0gdGhleSBvbmx5IG5lZWQgdG8gYmUgcGVyZm9ybWVkIGZvciBwb3dlcnMgb2YgMixcbiAgLy8gYWxsIG90aGVyIGVudHJpZXMgY2FuIGJlIGNvbXBvc2VkIGZyb20gdGhvc2UgcG93ZXJzIHVzaW5nIFhPUlxuICB2YXIgc2l6ZSA9IDEgPDwgYml0cztcbiAgdmFyIGhhbGYgPSBzaXplID4+PiAxO1xuICB2YXIgbSA9IG5ldyBBcnJheShzaXplKTtcbiAgbVtoYWxmXSA9IG1pZC5zbGljZSgwKTtcbiAgdmFyIGkgPSBoYWxmID4+PiAxO1xuICB3aGlsZShpID4gMCkge1xuICAgIC8vIHJhaXNlIG0wWzIgKiBpXSBhbmQgc3RvcmUgaW4gbTBbaV1cbiAgICB0aGlzLnBvdyhtWzIgKiBpXSwgbVtpXSA9IFtdKTtcbiAgICBpID4+PSAxO1xuICB9XG4gIGkgPSAyO1xuICB3aGlsZShpIDwgaGFsZikge1xuICAgIGZvcih2YXIgaiA9IDE7IGogPCBpOyArK2opIHtcbiAgICAgIHZhciBtX2kgPSBtW2ldO1xuICAgICAgdmFyIG1faiA9IG1bal07XG4gICAgICBtW2kgKyBqXSA9IFtcbiAgICAgICAgbV9pWzBdIF4gbV9qWzBdLFxuICAgICAgICBtX2lbMV0gXiBtX2pbMV0sXG4gICAgICAgIG1faVsyXSBeIG1falsyXSxcbiAgICAgICAgbV9pWzNdIF4gbV9qWzNdXG4gICAgICBdO1xuICAgIH1cbiAgICBpICo9IDI7XG4gIH1cbiAgbVswXSA9IFswLCAwLCAwLCAwXTtcbiAgLyogTm90ZTogV2UgY291bGQgYXZvaWQgc3RvcmluZyB0aGVzZSBieSBkb2luZyBjb21wb3NpdGlvbiBkdXJpbmcgbXVsdGlwbHlcbiAgY2FsY3VsYXRlIHRvcCBoYWxmIHVzaW5nIGNvbXBvc2l0aW9uIGJ5IHNwZWVkIGlzIHByZWZlcnJlZC4gKi9cbiAgZm9yKGkgPSBoYWxmICsgMTsgaSA8IHNpemU7ICsraSkge1xuICAgIHZhciBjID0gbVtpIF4gaGFsZl07XG4gICAgbVtpXSA9IFttaWRbMF0gXiBjWzBdLCBtaWRbMV0gXiBjWzFdLCBtaWRbMl0gXiBjWzJdLCBtaWRbM10gXiBjWzNdXTtcbiAgfVxuICByZXR1cm4gbTtcbn07XG5cbi8qKiBVdGlsaXR5IGZ1bmN0aW9ucyAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1JVihpdiwgYmxvY2tTaXplKSB7XG4gIGlmKHR5cGVvZiBpdiA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBjb252ZXJ0IGl2IHN0cmluZyBpbnRvIGJ5dGUgYnVmZmVyXG4gICAgaXYgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihpdik7XG4gIH1cblxuICBpZihmb3JnZS51dGlsLmlzQXJyYXkoaXYpICYmIGl2Lmxlbmd0aCA+IDQpIHtcbiAgICAvLyBjb252ZXJ0IGl2IGJ5dGUgYXJyYXkgaW50byBieXRlIGJ1ZmZlclxuICAgIHZhciB0bXAgPSBpdjtcbiAgICBpdiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7ICsraSkge1xuICAgICAgaXYucHV0Qnl0ZSh0bXBbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGlmKGl2Lmxlbmd0aCgpIDwgYmxvY2tTaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0ludmFsaWQgSVYgbGVuZ3RoOyBnb3QgJyArIGl2Lmxlbmd0aCgpICtcbiAgICAgICcgYnl0ZXMgYW5kIGV4cGVjdGVkICcgKyBibG9ja1NpemUgKyAnIGJ5dGVzLicpO1xuICB9XG5cbiAgaWYoIWZvcmdlLnV0aWwuaXNBcnJheShpdikpIHtcbiAgICAvLyBjb252ZXJ0IGl2IGJ5dGUgYnVmZmVyIGludG8gMzItYml0IGludGVnZXIgYXJyYXlcbiAgICB2YXIgaW50cyA9IFtdO1xuICAgIHZhciBibG9ja3MgPSBibG9ja1NpemUgLyA0O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBibG9ja3M7ICsraSkge1xuICAgICAgaW50cy5wdXNoKGl2LmdldEludDMyKCkpO1xuICAgIH1cbiAgICBpdiA9IGludHM7XG4gIH1cblxuICByZXR1cm4gaXY7XG59XG5cbmZ1bmN0aW9uIGluYzMyKGJsb2NrKSB7XG4gIC8vIGluY3JlbWVudCBsYXN0IDMyIGJpdHMgb2YgYmxvY2sgb25seVxuICBibG9ja1tibG9jay5sZW5ndGggLSAxXSA9IChibG9ja1tibG9jay5sZW5ndGggLSAxXSArIDEpICYgMHhGRkZGRkZGRjtcbn1cblxuZnVuY3Rpb24gZnJvbTY0VG8zMihudW0pIHtcbiAgLy8gY29udmVydCA2NC1iaXQgbnVtYmVyIHRvIHR3byBCRSBJbnQzMnNcbiAgcmV0dXJuIFsobnVtIC8gMHgxMDAwMDAwMDApIHwgMCwgbnVtICYgMHhGRkZGRkZGRl07XG59XG4iLCIvKipcbiAqIFNlY3VyZSBIYXNoIEFsZ29yaXRobSB3aXRoIDI1Ni1iaXQgZGlnZXN0IChTSEEtMjU2KSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBTZWUgRklQUyAxODAtMiBmb3IgZGV0YWlscy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vbWQnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgc2hhMjU2ID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5zaGEyNTYgPSBmb3JnZS5zaGEyNTYgfHwge307XG5mb3JnZS5tZC5zaGEyNTYgPSBmb3JnZS5tZC5hbGdvcml0aG1zLnNoYTI1NiA9IHNoYTI1NjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgU0hBLTI1NiBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKlxuICogQHJldHVybiBhIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqL1xuc2hhMjU2LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBkbyBpbml0aWFsaXphdGlvbiBhcyBuZWNlc3NhcnlcbiAgaWYoIV9pbml0aWFsaXplZCkge1xuICAgIF9pbml0KCk7XG4gIH1cblxuICAvLyBTSEEtMjU2IHN0YXRlIGNvbnRhaW5zIGVpZ2h0IDMyLWJpdCBpbnRlZ2Vyc1xuICB2YXIgX3N0YXRlID0gbnVsbDtcblxuICAvLyBpbnB1dCBidWZmZXJcbiAgdmFyIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gdXNlZCBmb3Igd29yZCBzdG9yYWdlXG4gIHZhciBfdyA9IG5ldyBBcnJheSg2NCk7XG5cbiAgLy8gbWVzc2FnZSBkaWdlc3Qgb2JqZWN0XG4gIHZhciBtZCA9IHtcbiAgICBhbGdvcml0aG06ICdzaGEyNTYnLFxuICAgIGJsb2NrTGVuZ3RoOiA2NCxcbiAgICBkaWdlc3RMZW5ndGg6IDMyLFxuICAgIC8vIDU2LWJpdCBsZW5ndGggb2YgbWVzc2FnZSBzbyBmYXIgKGRvZXMgbm90IGluY2x1ZGluZyBwYWRkaW5nKVxuICAgIG1lc3NhZ2VMZW5ndGg6IDAsXG4gICAgLy8gdHJ1ZSBtZXNzYWdlIGxlbmd0aFxuICAgIGZ1bGxNZXNzYWdlTGVuZ3RoOiBudWxsLFxuICAgIC8vIHNpemUgb2YgbWVzc2FnZSBsZW5ndGggaW4gYnl0ZXNcbiAgICBtZXNzYWdlTGVuZ3RoU2l6ZTogOFxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHVwIHRvIDU2LWJpdCBtZXNzYWdlIGxlbmd0aCBmb3IgY29udmVuaWVuY2VcbiAgICBtZC5tZXNzYWdlTGVuZ3RoID0gMDtcblxuICAgIC8vIGZ1bGwgbWVzc2FnZSBsZW5ndGggKHNldCBtZC5tZXNzYWdlTGVuZ3RoNjQgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5KVxuICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoID0gbWQubWVzc2FnZUxlbmd0aDY0ID0gW107XG4gICAgdmFyIGludDMycyA9IG1kLm1lc3NhZ2VMZW5ndGhTaXplIC8gNDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgaW50MzJzOyArK2kpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLnB1c2goMCk7XG4gICAgfVxuICAgIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgX3N0YXRlID0ge1xuICAgICAgaDA6IDB4NkEwOUU2NjcsXG4gICAgICBoMTogMHhCQjY3QUU4NSxcbiAgICAgIGgyOiAweDNDNkVGMzcyLFxuICAgICAgaDM6IDB4QTU0RkY1M0EsXG4gICAgICBoNDogMHg1MTBFNTI3RixcbiAgICAgIGg1OiAweDlCMDU2ODhDLFxuICAgICAgaDY6IDB4MUY4M0Q5QUIsXG4gICAgICBoNzogMHg1QkUwQ0QxOVxuICAgIH07XG4gICAgcmV0dXJuIG1kO1xuICB9O1xuICAvLyBzdGFydCBkaWdlc3QgYXV0b21hdGljYWxseSBmb3IgZmlyc3QgdGltZVxuICBtZC5zdGFydCgpO1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBkaWdlc3Qgd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZSBpbnB1dC4gVGhlIGdpdmVuIGlucHV0IGNhblxuICAgKiB0cmVhdGVkIGFzIHJhdyBpbnB1dCAobm8gZW5jb2Rpbmcgd2lsbCBiZSBhcHBsaWVkKSBvciBhbiBlbmNvZGluZyBvZlxuICAgKiAndXRmOCcgbWF5YmUgZ2l2ZW4gdG8gZW5jb2RlIHRoZSBpbnB1dCB1c2luZyBVVEYtOC5cbiAgICpcbiAgICogQHBhcmFtIG1zZyB0aGUgbWVzc2FnZSBpbnB1dCB0byB1cGRhdGUgd2l0aC5cbiAgICogQHBhcmFtIGVuY29kaW5nIHRoZSBlbmNvZGluZyB0byB1c2UgKGRlZmF1bHQ6ICdyYXcnLCBvdGhlcjogJ3V0ZjgnKS5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC51cGRhdGUgPSBmdW5jdGlvbihtc2csIGVuY29kaW5nKSB7XG4gICAgaWYoZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgbXNnID0gZm9yZ2UudXRpbC5lbmNvZGVVdGY4KG1zZyk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIG1lc3NhZ2UgbGVuZ3RoXG4gICAgdmFyIGxlbiA9IG1zZy5sZW5ndGg7XG4gICAgbWQubWVzc2FnZUxlbmd0aCArPSBsZW47XG4gICAgbGVuID0gWyhsZW4gLyAweDEwMDAwMDAwMCkgPj4+IDAsIGxlbiA+Pj4gMF07XG4gICAgZm9yKHZhciBpID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldICs9IGxlblsxXTtcbiAgICAgIGxlblsxXSA9IGxlblswXSArICgobWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gLyAweDEwMDAwMDAwMCkgPj4+IDApO1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA+Pj4gMDtcbiAgICAgIGxlblswXSA9ICgobGVuWzFdIC8gMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYnl0ZXMgdG8gaW5wdXQgYnVmZmVyXG4gICAgX2lucHV0LnB1dEJ5dGVzKG1zZyk7XG5cbiAgICAvLyBwcm9jZXNzIGJ5dGVzXG4gICAgX3VwZGF0ZShfc3RhdGUsIF93LCBfaW5wdXQpO1xuXG4gICAgLy8gY29tcGFjdCBpbnB1dCBidWZmZXIgZXZlcnkgMksgb3IgaWYgZW1wdHlcbiAgICBpZihfaW5wdXQucmVhZCA+IDIwNDggfHwgX2lucHV0Lmxlbmd0aCgpID09PSAwKSB7XG4gICAgICBfaW5wdXQuY29tcGFjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtZDtcbiAgfTtcblxuICAvKipcbiAgICogUHJvZHVjZXMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiBhIGJ5dGUgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGRpZ2VzdCB2YWx1ZS5cbiAgICovXG4gIG1kLmRpZ2VzdCA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIE5vdGU6IEhlcmUgd2UgY29weSB0aGUgcmVtYWluaW5nIGJ5dGVzIGluIHRoZSBpbnB1dCBidWZmZXIgYW5kXG4gICAgYWRkIHRoZSBhcHByb3ByaWF0ZSBTSEEtMjU2IHBhZGRpbmcuIFRoZW4gd2UgZG8gdGhlIGZpbmFsIHVwZGF0ZVxuICAgIG9uIGEgY29weSBvZiB0aGUgc3RhdGUgc28gdGhhdCBpZiB0aGUgdXNlciB3YW50cyB0byBnZXRcbiAgICBpbnRlcm1lZGlhdGUgZGlnZXN0cyB0aGV5IGNhbiBkbyBzby4gKi9cblxuICAgIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgbXVzdCBiZSBhZGRlZCB0byB0aGUgbWVzc2FnZVxuICAgIHRvIGVuc3VyZSBpdHMgbGVuZ3RoIGlzIGNvbmdydWVudCB0byA0NDggbW9kIDUxMi4gSW4gb3RoZXIgd29yZHMsXG4gICAgdGhlIGRhdGEgdG8gYmUgZGlnZXN0ZWQgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDUxMiBiaXRzIChvciAxMjggYnl0ZXMpLlxuICAgIFRoaXMgZGF0YSBpbmNsdWRlcyB0aGUgbWVzc2FnZSwgc29tZSBwYWRkaW5nLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICBtZXNzYWdlLiBTaW5jZSB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlIHdpbGwgYmUgZW5jb2RlZCBhcyA4IGJ5dGVzICg2NFxuICAgIGJpdHMpLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgZGF0YSBtdXN0IGhhdmUgNTYgYnl0ZXNcbiAgICAoNDQ4IGJpdHMpIG9mIG1lc3NhZ2UgYW5kIHBhZGRpbmcuIFRoZXJlZm9yZSwgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZVxuICAgIHBsdXMgdGhlIHBhZGRpbmcgbXVzdCBiZSBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIgYmVjYXVzZVxuICAgIDUxMiAtIDEyOCA9IDQ0OC5cblxuICAgIEluIG9yZGVyIHRvIGZpbGwgdXAgdGhlIG1lc3NhZ2UgbGVuZ3RoIGl0IG11c3QgYmUgZmlsbGVkIHdpdGhcbiAgICBwYWRkaW5nIHRoYXQgYmVnaW5zIHdpdGggMSBiaXQgZm9sbG93ZWQgYnkgYWxsIDAgYml0cy4gUGFkZGluZ1xuICAgIG11c3QgKmFsd2F5cyogYmUgcHJlc2VudCwgc28gaWYgdGhlIG1lc3NhZ2UgbGVuZ3RoIGlzIGFscmVhZHlcbiAgICBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIsIHRoZW4gNTEyIHBhZGRpbmcgYml0cyBtdXN0IGJlIGFkZGVkLiAqL1xuXG4gICAgdmFyIGZpbmFsQmxvY2sgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX2lucHV0LmJ5dGVzKCkpO1xuXG4gICAgLy8gY29tcHV0ZSByZW1haW5pbmcgc2l6ZSB0byBiZSBkaWdlc3RlZCAoaW5jbHVkZSBtZXNzYWdlIGxlbmd0aCBzaXplKVxuICAgIHZhciByZW1haW5pbmcgPSAoXG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFttZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxXSArXG4gICAgICBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSk7XG5cbiAgICAvLyBhZGQgcGFkZGluZyBmb3Igb3ZlcmZsb3cgYmxvY2tTaXplIC0gb3ZlcmZsb3dcbiAgICAvLyBfcGFkZGluZyBzdGFydHMgd2l0aCAxIGJ5dGUgd2l0aCBmaXJzdCBiaXQgaXMgc2V0IChieXRlIHZhbHVlIDEyOCksIHRoZW5cbiAgICAvLyB0aGVyZSBtYXkgYmUgdXAgdG8gKGJsb2NrU2l6ZSAtIDEpIG90aGVyIHBhZCBieXRlc1xuICAgIHZhciBvdmVyZmxvdyA9IHJlbWFpbmluZyAmIChtZC5ibG9ja0xlbmd0aCAtIDEpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX3BhZGRpbmcuc3Vic3RyKDAsIG1kLmJsb2NrTGVuZ3RoIC0gb3ZlcmZsb3cpKTtcblxuICAgIC8vIHNlcmlhbGl6ZSBtZXNzYWdlIGxlbmd0aCBpbiBiaXRzIGluIGJpZy1lbmRpYW4gb3JkZXI7IHNpbmNlIGxlbmd0aFxuICAgIC8vIGlzIHN0b3JlZCBpbiBieXRlcyB3ZSBtdWx0aXBseSBieSA4IGFuZCBhZGQgY2FycnkgZnJvbSBuZXh0IGludFxuICAgIHZhciBuZXh0LCBjYXJyeTtcbiAgICB2YXIgYml0cyA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoWzBdICogODtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBuZXh0ID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaSArIDFdICogODtcbiAgICAgIGNhcnJ5ID0gKG5leHQgLyAweDEwMDAwMDAwMCkgPj4+IDA7XG4gICAgICBiaXRzICs9IGNhcnJ5O1xuICAgICAgZmluYWxCbG9jay5wdXRJbnQzMihiaXRzID4+PiAwKTtcbiAgICAgIGJpdHMgPSBuZXh0ID4+PiAwO1xuICAgIH1cbiAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMpO1xuXG4gICAgdmFyIHMyID0ge1xuICAgICAgaDA6IF9zdGF0ZS5oMCxcbiAgICAgIGgxOiBfc3RhdGUuaDEsXG4gICAgICBoMjogX3N0YXRlLmgyLFxuICAgICAgaDM6IF9zdGF0ZS5oMyxcbiAgICAgIGg0OiBfc3RhdGUuaDQsXG4gICAgICBoNTogX3N0YXRlLmg1LFxuICAgICAgaDY6IF9zdGF0ZS5oNixcbiAgICAgIGg3OiBfc3RhdGUuaDdcbiAgICB9O1xuICAgIF91cGRhdGUoczIsIF93LCBmaW5hbEJsb2NrKTtcbiAgICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMSk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMik7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMyk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNSk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNik7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNyk7XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgcmV0dXJuIG1kO1xufTtcblxuLy8gc2hhLTI1NiBwYWRkaW5nIGJ5dGVzIG5vdCBpbml0aWFsaXplZCB5ZXRcbnZhciBfcGFkZGluZyA9IG51bGw7XG52YXIgX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8vIHRhYmxlIG9mIGNvbnN0YW50c1xudmFyIF9rID0gbnVsbDtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY29uc3RhbnQgdGFibGVzLlxuICovXG5mdW5jdGlvbiBfaW5pdCgpIHtcbiAgLy8gY3JlYXRlIHBhZGRpbmdcbiAgX3BhZGRpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyOCk7XG4gIF9wYWRkaW5nICs9IGZvcmdlLnV0aWwuZmlsbFN0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MDApLCA2NCk7XG5cbiAgLy8gY3JlYXRlIEsgdGFibGUgZm9yIFNIQS0yNTZcbiAgX2sgPSBbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSxcbiAgICAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsXG4gICAgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLFxuICAgIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNyxcbiAgICAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsXG4gICAgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLFxuICAgIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSxcbiAgICAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsXG4gICAgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMl07XG5cbiAgLy8gbm93IGluaXRpYWxpemVkXG4gIF9pbml0aWFsaXplZCA9IHRydWU7XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIFNIQS0yNTYgc3RhdGUgd2l0aCB0aGUgZ2l2ZW4gYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIHMgdGhlIFNIQS0yNTYgc3RhdGUgdG8gdXBkYXRlLlxuICogQHBhcmFtIHcgdGhlIGFycmF5IHRvIHVzZSB0byBzdG9yZSB3b3Jkcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gdXBkYXRlIHdpdGguXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGUocywgdywgYnl0ZXMpIHtcbiAgLy8gY29uc3VtZSA1MTIgYml0ICg2NCBieXRlKSBjaHVua3NcbiAgdmFyIHQxLCB0MiwgczAsIHMxLCBjaCwgbWFqLCBpLCBhLCBiLCBjLCBkLCBlLCBmLCBnLCBoO1xuICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoKCk7XG4gIHdoaWxlKGxlbiA+PSA2NCkge1xuICAgIC8vIHRoZSB3IGFycmF5IHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggc2l4dGVlbiAzMi1iaXQgYmlnLWVuZGlhbiB3b3Jkc1xuICAgIC8vIGFuZCB0aGVuIGV4dGVuZGVkIGludG8gNjQgMzItYml0IHdvcmRzIGFjY29yZGluZyB0byBTSEEtMjU2XG4gICAgZm9yKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgd1tpXSA9IGJ5dGVzLmdldEludDMyKCk7XG4gICAgfVxuICAgIGZvcig7IGkgPCA2NDsgKytpKSB7XG4gICAgICAvLyBYT1Igd29yZCAyIHdvcmRzIGFnbyByb3QgcmlnaHQgMTcsIHJvdCByaWdodCAxOSwgc2hmdCByaWdodCAxMFxuICAgICAgdDEgPSB3W2kgLSAyXTtcbiAgICAgIHQxID1cbiAgICAgICAgKCh0MSA+Pj4gMTcpIHwgKHQxIDw8IDE1KSkgXlxuICAgICAgICAoKHQxID4+PiAxOSkgfCAodDEgPDwgMTMpKSBeXG4gICAgICAgICh0MSA+Pj4gMTApO1xuICAgICAgLy8gWE9SIHdvcmQgMTUgd29yZHMgYWdvIHJvdCByaWdodCA3LCByb3QgcmlnaHQgMTgsIHNoZnQgcmlnaHQgM1xuICAgICAgdDIgPSB3W2kgLSAxNV07XG4gICAgICB0MiA9XG4gICAgICAgICgodDIgPj4+IDcpIHwgKHQyIDw8IDI1KSkgXlxuICAgICAgICAoKHQyID4+PiAxOCkgfCAodDIgPDwgMTQpKSBeXG4gICAgICAgICh0MiA+Pj4gMyk7XG4gICAgICAvLyBzdW0odDEsIHdvcmQgNyBhZ28sIHQyLCB3b3JkIDE2IGFnbykgbW9kdWxvIDJeMzJcbiAgICAgIHdbaV0gPSAodDEgKyB3W2kgLSA3XSArIHQyICsgd1tpIC0gMTZdKSB8IDA7XG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbGl6ZSBoYXNoIHZhbHVlIGZvciB0aGlzIGNodW5rXG4gICAgYSA9IHMuaDA7XG4gICAgYiA9IHMuaDE7XG4gICAgYyA9IHMuaDI7XG4gICAgZCA9IHMuaDM7XG4gICAgZSA9IHMuaDQ7XG4gICAgZiA9IHMuaDU7XG4gICAgZyA9IHMuaDY7XG4gICAgaCA9IHMuaDc7XG5cbiAgICAvLyByb3VuZCBmdW5jdGlvblxuICAgIGZvcihpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICAgIC8vIFN1bTEoZSlcbiAgICAgIHMxID1cbiAgICAgICAgKChlID4+PiA2KSB8IChlIDw8IDI2KSkgXlxuICAgICAgICAoKGUgPj4+IDExKSB8IChlIDw8IDIxKSkgXlxuICAgICAgICAoKGUgPj4+IDI1KSB8IChlIDw8IDcpKTtcbiAgICAgIC8vIENoKGUsIGYsIGcpIChvcHRpbWl6ZWQgdGhlIHNhbWUgd2F5IGFzIFNIQS0xKVxuICAgICAgY2ggPSBnIF4gKGUgJiAoZiBeIGcpKTtcbiAgICAgIC8vIFN1bTAoYSlcbiAgICAgIHMwID1cbiAgICAgICAgKChhID4+PiAyKSB8IChhIDw8IDMwKSkgXlxuICAgICAgICAoKGEgPj4+IDEzKSB8IChhIDw8IDE5KSkgXlxuICAgICAgICAoKGEgPj4+IDIyKSB8IChhIDw8IDEwKSk7XG4gICAgICAvLyBNYWooYSwgYiwgYykgKG9wdGltaXplZCB0aGUgc2FtZSB3YXkgYXMgU0hBLTEpXG4gICAgICBtYWogPSAoYSAmIGIpIHwgKGMgJiAoYSBeIGIpKTtcblxuICAgICAgLy8gbWFpbiBhbGdvcml0aG1cbiAgICAgIHQxID0gaCArIHMxICsgY2ggKyBfa1tpXSArIHdbaV07XG4gICAgICB0MiA9IHMwICsgbWFqO1xuICAgICAgaCA9IGc7XG4gICAgICBnID0gZjtcbiAgICAgIGYgPSBlO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICAvLyBjYW4ndCB0cnVuY2F0ZSB3aXRoIGB8IDBgXG4gICAgICBlID0gKGQgKyB0MSkgPj4+IDA7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBiO1xuICAgICAgYiA9IGE7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIC8vIGNhbid0IHRydW5jYXRlIHdpdGggYHwgMGBcbiAgICAgIGEgPSAodDEgKyB0MikgPj4+IDA7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGhhc2ggc3RhdGVcbiAgICBzLmgwID0gKHMuaDAgKyBhKSB8IDA7XG4gICAgcy5oMSA9IChzLmgxICsgYikgfCAwO1xuICAgIHMuaDIgPSAocy5oMiArIGMpIHwgMDtcbiAgICBzLmgzID0gKHMuaDMgKyBkKSB8IDA7XG4gICAgcy5oNCA9IChzLmg0ICsgZSkgfCAwO1xuICAgIHMuaDUgPSAocy5oNSArIGYpIHwgMDtcbiAgICBzLmg2ID0gKHMuaDYgKyBnKSB8IDA7XG4gICAgcy5oNyA9IChzLmg3ICsgaCkgfCAwO1xuICAgIGxlbiAtPSA2NDtcbiAgfVxufVxuIiwiLyoqXG4gKiBBIGphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmVcbiAqIFBzZXVkbyBSYW5kb20gTnVtYmVyIEdlbmVyYXRvciAoUFJORykuIFRoZSBGb3J0dW5hIGFsZ29yaXRobSBpcyBmb2xsb3dlZFxuICogaGVyZSB0aG91Z2ggdGhlIHVzZSBvZiBTSEEtMjU2IGlzIG5vdCBlbmZvcmNlZDsgd2hlbiBnZW5lcmF0aW5nIGFuXG4gKiBhIFBSTkcgY29udGV4dCwgdGhlIGhhc2hpbmcgYWxnb3JpdGhtIGFuZCBibG9jayBjaXBoZXIgdXNlZCBmb3JcbiAqIHRoZSBnZW5lcmF0b3IgYXJlIHNwZWNpZmllZCB2aWEgYSBwbHVnaW4uXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIF9jcnlwdG8gPSBudWxsO1xuaWYoZm9yZ2UudXRpbC5pc05vZGVqcyAmJiAhZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCAmJlxuICAhcHJvY2Vzcy52ZXJzaW9uc1snbm9kZS13ZWJraXQnXSkge1xuICBfY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG59XG5cbi8qIFBSTkcgQVBJICovXG52YXIgcHJuZyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucHJuZyA9IGZvcmdlLnBybmcgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBQUk5HIGNvbnRleHQuXG4gKlxuICogQSBQUk5HIHBsdWdpbiBtdXN0IGJlIHBhc3NlZCBpbiB0aGF0IHdpbGwgcHJvdmlkZTpcbiAqXG4gKiAxLiBBIGZ1bmN0aW9uIHRoYXQgaW5pdGlhbGl6ZXMgdGhlIGtleSBhbmQgc2VlZCBvZiBhIFBSTkcgY29udGV4dC4gSXRcbiAqICAgd2lsbCBiZSBnaXZlbiBhIDE2IGJ5dGUga2V5IGFuZCBhIDE2IGJ5dGUgc2VlZC4gQW55IGtleSBleHBhbnNpb25cbiAqICAgb3IgdHJhbnNmb3JtYXRpb24gb2YgdGhlIHNlZWQgZnJvbSBhIGJ5dGUgc3RyaW5nIGludG8gYW4gYXJyYXkgb2ZcbiAqICAgaW50ZWdlcnMgKG9yIHNpbWlsYXIpIHNob3VsZCBiZSBwZXJmb3JtZWQuXG4gKiAyLiBUaGUgY3J5cHRvZ3JhcGhpYyBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBnZW5lcmF0b3IuIEl0IHRha2VzIGEga2V5IGFuZFxuICogICBhIHNlZWQuXG4gKiAzLiBBIHNlZWQgaW5jcmVtZW50IGZ1bmN0aW9uLiBJdCB0YWtlcyB0aGUgc2VlZCBhbmQgcmV0dXJucyBzZWVkICsgMS5cbiAqIDQuIEFuIGFwaSB0byBjcmVhdGUgYSBtZXNzYWdlIGRpZ2VzdC5cbiAqXG4gKiBGb3IgYW4gZXhhbXBsZSwgc2VlIHJhbmRvbS5qcy5cbiAqXG4gKiBAcGFyYW0gcGx1Z2luIHRoZSBQUk5HIHBsdWdpbiB0byB1c2UuXG4gKi9cbnBybmcuY3JlYXRlID0gZnVuY3Rpb24ocGx1Z2luKSB7XG4gIHZhciBjdHggPSB7XG4gICAgcGx1Z2luOiBwbHVnaW4sXG4gICAga2V5OiBudWxsLFxuICAgIHNlZWQ6IG51bGwsXG4gICAgdGltZTogbnVsbCxcbiAgICAvLyBudW1iZXIgb2YgcmVzZWVkcyBzbyBmYXJcbiAgICByZXNlZWRzOiAwLFxuICAgIC8vIGFtb3VudCBvZiBkYXRhIGdlbmVyYXRlZCBzbyBmYXJcbiAgICBnZW5lcmF0ZWQ6IDAsXG4gICAgLy8gbm8gaW5pdGlhbCBrZXkgYnl0ZXNcbiAgICBrZXlCeXRlczogJydcbiAgfTtcblxuICAvLyBjcmVhdGUgMzIgZW50cm9weSBwb29scyAoZWFjaCBpcyBhIG1lc3NhZ2UgZGlnZXN0KVxuICB2YXIgbWQgPSBwbHVnaW4ubWQ7XG4gIHZhciBwb29scyA9IG5ldyBBcnJheSgzMik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgcG9vbHNbaV0gPSBtZC5jcmVhdGUoKTtcbiAgfVxuICBjdHgucG9vbHMgPSBwb29scztcblxuICAvLyBlbnRyb3B5IHBvb2xzIGFyZSB3cml0dGVuIHRvIGN5Y2xpY2FsbHksIHN0YXJ0aW5nIGF0IGluZGV4IDBcbiAgY3R4LnBvb2wgPSAwO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcmFuZG9tIGJ5dGVzLiBUaGUgYnl0ZXMgbWF5IGJlIGdlbmVyYXRlZCBzeW5jaHJvbm91c2x5IG9yXG4gICAqIGFzeW5jaHJvbm91c2x5LiBXZWIgd29ya2VycyBtdXN0IHVzZSB0aGUgYXN5bmNocm9ub3VzIGludGVyZmFjZSBvclxuICAgKiBlbHNlIHRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWQuXG4gICAqXG4gICAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cbiAgICogQHBhcmFtIFtjYWxsYmFjayhlcnIsIGJ5dGVzKV0gY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gICAqXG4gICAqIEByZXR1cm4gY291bnQgcmFuZG9tIGJ5dGVzIGFzIGEgc3RyaW5nLlxuICAgKi9cbiAgY3R4LmdlbmVyYXRlID0gZnVuY3Rpb24oY291bnQsIGNhbGxiYWNrKSB7XG4gICAgLy8gZG8gc3luY2hyb25vdXNseVxuICAgIGlmKCFjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGN0eC5nZW5lcmF0ZVN5bmMoY291bnQpO1xuICAgIH1cblxuICAgIC8vIHNpbXBsZSBnZW5lcmF0b3IgdXNpbmcgY291bnRlci1iYXNlZCBDQkNcbiAgICB2YXIgY2lwaGVyID0gY3R4LnBsdWdpbi5jaXBoZXI7XG4gICAgdmFyIGluY3JlbWVudCA9IGN0eC5wbHVnaW4uaW5jcmVtZW50O1xuICAgIHZhciBmb3JtYXRLZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleTtcbiAgICB2YXIgZm9ybWF0U2VlZCA9IGN0eC5wbHVnaW4uZm9ybWF0U2VlZDtcbiAgICB2YXIgYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICAvLyBwYXJhbm9pZCBkZXZpYXRpb24gZnJvbSBGb3J0dW5hOlxuICAgIC8vIHJlc2V0IGtleSBmb3IgZXZlcnkgcmVxdWVzdCB0byBwcm90ZWN0IHByZXZpb3VzbHlcbiAgICAvLyBnZW5lcmF0ZWQgcmFuZG9tIGJ5dGVzIHNob3VsZCB0aGUga2V5IGJlIGRpc2NvdmVyZWQ7XG4gICAgLy8gdGhlcmUgaXMgbm8gMTAwbXMgYmFzZWQgcmVzZWVkaW5nIGJlY2F1c2Ugb2YgdGhpc1xuICAgIC8vIGZvcmNlZCByZXNlZWQgZm9yIGV2ZXJ5IGBnZW5lcmF0ZWAgY2FsbFxuICAgIGN0eC5rZXkgPSBudWxsO1xuXG4gICAgZ2VuZXJhdGUoKTtcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlKGVycikge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICAvLyBzdWZmaWNpZW50IGJ5dGVzIGdlbmVyYXRlZFxuICAgICAgaWYoYi5sZW5ndGgoKSA+PSBjb3VudCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgYi5nZXRCeXRlcyhjb3VudCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBhbW91bnQgb2YgZGF0YSBnZW5lcmF0ZWQgaXMgZ3JlYXRlciB0aGFuIDEgTWlCLCB0cmlnZ2VyIHJlc2VlZFxuICAgICAgaWYoY3R4LmdlbmVyYXRlZCA+IDB4ZmZmZmYpIHtcbiAgICAgICAgY3R4LmtleSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmKGN0eC5rZXkgPT09IG51bGwpIHtcbiAgICAgICAgLy8gcHJldmVudCBzdGFjayBvdmVyZmxvd1xuICAgICAgICByZXR1cm4gZm9yZ2UudXRpbC5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICBfcmVzZWVkKGdlbmVyYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdlbmVyYXRlIHRoZSByYW5kb20gYnl0ZXNcbiAgICAgIHZhciBieXRlcyA9IGNpcGhlcihjdHgua2V5LCBjdHguc2VlZCk7XG4gICAgICBjdHguZ2VuZXJhdGVkICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuXG4gICAgICAvLyBnZW5lcmF0ZSBieXRlcyBmb3IgYSBuZXcga2V5IGFuZCBzZWVkXG4gICAgICBjdHgua2V5ID0gZm9ybWF0S2V5KGNpcGhlcihjdHgua2V5LCBpbmNyZW1lbnQoY3R4LnNlZWQpKSk7XG4gICAgICBjdHguc2VlZCA9IGZvcm1hdFNlZWQoY2lwaGVyKGN0eC5rZXksIGN0eC5zZWVkKSk7XG5cbiAgICAgIGZvcmdlLnV0aWwuc2V0SW1tZWRpYXRlKGdlbmVyYXRlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyByYW5kb20gYnl0ZXMgc3luY2hyb25vdXNseS5cbiAgICpcbiAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICAgKlxuICAgKiBAcmV0dXJuIGNvdW50IHJhbmRvbSBieXRlcyBhcyBhIHN0cmluZy5cbiAgICovXG4gIGN0eC5nZW5lcmF0ZVN5bmMgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIC8vIHNpbXBsZSBnZW5lcmF0b3IgdXNpbmcgY291bnRlci1iYXNlZCBDQkNcbiAgICB2YXIgY2lwaGVyID0gY3R4LnBsdWdpbi5jaXBoZXI7XG4gICAgdmFyIGluY3JlbWVudCA9IGN0eC5wbHVnaW4uaW5jcmVtZW50O1xuICAgIHZhciBmb3JtYXRLZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleTtcbiAgICB2YXIgZm9ybWF0U2VlZCA9IGN0eC5wbHVnaW4uZm9ybWF0U2VlZDtcblxuICAgIC8vIHBhcmFub2lkIGRldmlhdGlvbiBmcm9tIEZvcnR1bmE6XG4gICAgLy8gcmVzZXQga2V5IGZvciBldmVyeSByZXF1ZXN0IHRvIHByb3RlY3QgcHJldmlvdXNseVxuICAgIC8vIGdlbmVyYXRlZCByYW5kb20gYnl0ZXMgc2hvdWxkIHRoZSBrZXkgYmUgZGlzY292ZXJlZDtcbiAgICAvLyB0aGVyZSBpcyBubyAxMDBtcyBiYXNlZCByZXNlZWRpbmcgYmVjYXVzZSBvZiB0aGlzXG4gICAgLy8gZm9yY2VkIHJlc2VlZCBmb3IgZXZlcnkgYGdlbmVyYXRlU3luY2AgY2FsbFxuICAgIGN0eC5rZXkgPSBudWxsO1xuXG4gICAgdmFyIGIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHdoaWxlKGIubGVuZ3RoKCkgPCBjb3VudCkge1xuICAgICAgLy8gaWYgYW1vdW50IG9mIGRhdGEgZ2VuZXJhdGVkIGlzIGdyZWF0ZXIgdGhhbiAxIE1pQiwgdHJpZ2dlciByZXNlZWRcbiAgICAgIGlmKGN0eC5nZW5lcmF0ZWQgPiAweGZmZmZmKSB7XG4gICAgICAgIGN0eC5rZXkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZihjdHgua2V5ID09PSBudWxsKSB7XG4gICAgICAgIF9yZXNlZWRTeW5jKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdlbmVyYXRlIHRoZSByYW5kb20gYnl0ZXNcbiAgICAgIHZhciBieXRlcyA9IGNpcGhlcihjdHgua2V5LCBjdHguc2VlZCk7XG4gICAgICBjdHguZ2VuZXJhdGVkICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuXG4gICAgICAvLyBnZW5lcmF0ZSBieXRlcyBmb3IgYSBuZXcga2V5IGFuZCBzZWVkXG4gICAgICBjdHgua2V5ID0gZm9ybWF0S2V5KGNpcGhlcihjdHgua2V5LCBpbmNyZW1lbnQoY3R4LnNlZWQpKSk7XG4gICAgICBjdHguc2VlZCA9IGZvcm1hdFNlZWQoY2lwaGVyKGN0eC5rZXksIGN0eC5zZWVkKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGIuZ2V0Qnl0ZXMoY291bnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcml2YXRlIGZ1bmN0aW9uIHRoYXQgYXN5bmNocm9ub3VzbHkgcmVzZWVkcyBhIGdlbmVyYXRvci5cbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrKGVycikgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBfcmVzZWVkKGNhbGxiYWNrKSB7XG4gICAgaWYoY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGggPj0gMzIpIHtcbiAgICAgIF9zZWVkKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCBzZWVkIGRhdGEuLi5cbiAgICB2YXIgbmVlZGVkID0gKDMyIC0gY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGgpIDw8IDU7XG4gICAgY3R4LnNlZWRGaWxlKG5lZWRlZCwgZnVuY3Rpb24oZXJyLCBieXRlcykge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgY3R4LmNvbGxlY3QoYnl0ZXMpO1xuICAgICAgX3NlZWQoKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUHJpdmF0ZSBmdW5jdGlvbiB0aGF0IHN5bmNocm9ub3VzbHkgcmVzZWVkcyBhIGdlbmVyYXRvci5cbiAgICovXG4gIGZ1bmN0aW9uIF9yZXNlZWRTeW5jKCkge1xuICAgIGlmKGN0eC5wb29sc1swXS5tZXNzYWdlTGVuZ3RoID49IDMyKSB7XG4gICAgICByZXR1cm4gX3NlZWQoKTtcbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCBzZWVkIGRhdGEuLi5cbiAgICB2YXIgbmVlZGVkID0gKDMyIC0gY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGgpIDw8IDU7XG4gICAgY3R4LmNvbGxlY3QoY3R4LnNlZWRGaWxlU3luYyhuZWVkZWQpKTtcbiAgICBfc2VlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgZnVuY3Rpb24gdGhhdCBzZWVkcyBhIGdlbmVyYXRvciBvbmNlIGVub3VnaCBieXRlcyBhcmUgYXZhaWxhYmxlLlxuICAgKi9cbiAgZnVuY3Rpb24gX3NlZWQoKSB7XG4gICAgLy8gdXBkYXRlIHJlc2VlZCBjb3VudFxuICAgIGN0eC5yZXNlZWRzID0gKGN0eC5yZXNlZWRzID09PSAweGZmZmZmZmZmKSA/IDAgOiBjdHgucmVzZWVkcyArIDE7XG5cbiAgICAvLyBnb2FsIGlzIHRvIHVwZGF0ZSBga2V5YCB2aWE6XG4gICAgLy8ga2V5ID0gaGFzaChrZXkgKyBzKVxuICAgIC8vICAgd2hlcmUgJ3MnIGlzIGFsbCBjb2xsZWN0ZWQgZW50cm9weSBmcm9tIHNlbGVjdGVkIHBvb2xzLCB0aGVuLi4uXG5cbiAgICAvLyBjcmVhdGUgYSBwbHVnaW4tYmFzZWQgbWVzc2FnZSBkaWdlc3RcbiAgICB2YXIgbWQgPSBjdHgucGx1Z2luLm1kLmNyZWF0ZSgpO1xuXG4gICAgLy8gY29uc3VtZSBjdXJyZW50IGtleSBieXRlc1xuICAgIG1kLnVwZGF0ZShjdHgua2V5Qnl0ZXMpO1xuXG4gICAgLy8gZGlnZXN0IHRoZSBlbnRyb3B5IG9mIHBvb2xzIHdob3NlIGluZGV4IGsgbWVldCB0aGVcbiAgICAvLyBjb25kaXRpb24gJ24gbW9kIDJeayA9PSAwJyB3aGVyZSBuIGlzIHRoZSBudW1iZXIgb2YgcmVzZWVkc1xuICAgIHZhciBfMnBvd0sgPSAxO1xuICAgIGZvcih2YXIgayA9IDA7IGsgPCAzMjsgKytrKSB7XG4gICAgICBpZihjdHgucmVzZWVkcyAlIF8ycG93SyA9PT0gMCkge1xuICAgICAgICBtZC51cGRhdGUoY3R4LnBvb2xzW2tdLmRpZ2VzdCgpLmdldEJ5dGVzKCkpO1xuICAgICAgICBjdHgucG9vbHNba10uc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIF8ycG93SyA9IF8ycG93SyA8PCAxO1xuICAgIH1cblxuICAgIC8vIGdldCBkaWdlc3QgZm9yIGtleSBieXRlc1xuICAgIGN0eC5rZXlCeXRlcyA9IG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvLyBwYXJhbm9pZCBkZXZpYXRpb24gZnJvbSBGb3J0dW5hOlxuICAgIC8vIHVwZGF0ZSBgc2VlZGAgdmlhIGBzZWVkID0gaGFzaChrZXkpYFxuICAgIC8vIGluc3RlYWQgb2YgaW5pdGlhbGl6aW5nIHRvIHplcm8gb25jZSBhbmQgb25seVxuICAgIC8vIGV2ZXIgaW5jcmVtZW50aW5nIGl0XG4gICAgbWQuc3RhcnQoKTtcbiAgICBtZC51cGRhdGUoY3R4LmtleUJ5dGVzKTtcbiAgICB2YXIgc2VlZEJ5dGVzID0gbWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcblxuICAgIC8vIHVwZGF0ZSBzdGF0ZVxuICAgIGN0eC5rZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleShjdHgua2V5Qnl0ZXMpO1xuICAgIGN0eC5zZWVkID0gY3R4LnBsdWdpbi5mb3JtYXRTZWVkKHNlZWRCeXRlcyk7XG4gICAgY3R4LmdlbmVyYXRlZCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJ1aWx0LWluIGRlZmF1bHQgc2VlZEZpbGUuIFRoaXMgc2VlZEZpbGUgaXMgdXNlZCB3aGVuIGVudHJvcHlcbiAgICogaXMgbmVlZGVkIGltbWVkaWF0ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gbmVlZGVkIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBhcmUgbmVlZGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSByYW5kb20gYnl0ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBkZWZhdWx0U2VlZEZpbGUobmVlZGVkKSB7XG4gICAgLy8gdXNlIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHN0cm9uZyBzb3VyY2Ugb2YgZW50cm9weSBpZiBhdmFpbGFibGVcbiAgICB2YXIgZ2V0UmFuZG9tVmFsdWVzID0gbnVsbDtcbiAgICB2YXIgZ2xvYmFsU2NvcGUgPSBmb3JnZS51dGlsLmdsb2JhbFNjb3BlO1xuICAgIHZhciBfY3J5cHRvID0gZ2xvYmFsU2NvcGUuY3J5cHRvIHx8IGdsb2JhbFNjb3BlLm1zQ3J5cHRvO1xuICAgIGlmKF9jcnlwdG8gJiYgX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIGdldFJhbmRvbVZhbHVlcyA9IGZ1bmN0aW9uKGFycikge1xuICAgICAgICByZXR1cm4gX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGlmKGdldFJhbmRvbVZhbHVlcykge1xuICAgICAgd2hpbGUoYi5sZW5ndGgoKSA8IG5lZWRlZCkge1xuICAgICAgICAvLyBtYXggYnl0ZSBsZW5ndGggaXMgNjU1MzYgYmVmb3JlIFF1b3RhRXhjZWVkZWRFcnJvciBpcyB0aHJvd25cbiAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvV2ViQ3J5cHRvQVBJLyNSYW5kb21Tb3VyY2UtbWV0aG9kLWdldFJhbmRvbVZhbHVlc1xuICAgICAgICB2YXIgY291bnQgPSBNYXRoLm1heCgxLCBNYXRoLm1pbihuZWVkZWQgLSBiLmxlbmd0aCgpLCA2NTUzNikgLyA0KTtcbiAgICAgICAgdmFyIGVudHJvcHkgPSBuZXcgVWludDMyQXJyYXkoTWF0aC5mbG9vcihjb3VudCkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGdldFJhbmRvbVZhbHVlcyhlbnRyb3B5KTtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZW50cm9weS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYi5wdXRJbnQzMihlbnRyb3B5W2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIC8qIG9ubHkgaWdub3JlIFF1b3RhRXhjZWVkZWRFcnJvciAqL1xuICAgICAgICAgIGlmKCEodHlwZW9mIFF1b3RhRXhjZWVkZWRFcnJvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGUgaW5zdGFuY2VvZiBRdW90YUV4Y2VlZGVkRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGJlIHNhZCBhbmQgYWRkIHNvbWUgd2VhayByYW5kb20gZGF0YVxuICAgIGlmKGIubGVuZ3RoKCkgPCBuZWVkZWQpIHtcbiAgICAgIC8qIERyYXdzIGZyb20gUGFyay1NaWxsZXIgXCJtaW5pbWFsIHN0YW5kYXJkXCIgMzEgYml0IFBSTkcsXG4gICAgICBpbXBsZW1lbnRlZCB3aXRoIERhdmlkIEcuIENhcnRhJ3Mgb3B0aW1pemF0aW9uOiB3aXRoIDMyIGJpdCBtYXRoXG4gICAgICBhbmQgd2l0aG91dCBkaXZpc2lvbiAoUHVibGljIERvbWFpbikuICovXG4gICAgICB2YXIgaGksIGxvLCBuZXh0O1xuICAgICAgdmFyIHNlZWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweDAxMDAwMCk7XG4gICAgICB3aGlsZShiLmxlbmd0aCgpIDwgbmVlZGVkKSB7XG4gICAgICAgIGxvID0gMTY4MDcgKiAoc2VlZCAmIDB4RkZGRik7XG4gICAgICAgIGhpID0gMTY4MDcgKiAoc2VlZCA+PiAxNik7XG4gICAgICAgIGxvICs9IChoaSAmIDB4N0ZGRikgPDwgMTY7XG4gICAgICAgIGxvICs9IGhpID4+IDE1O1xuICAgICAgICBsbyA9IChsbyAmIDB4N0ZGRkZGRkYpICsgKGxvID4+IDMxKTtcbiAgICAgICAgc2VlZCA9IGxvICYgMHhGRkZGRkZGRjtcblxuICAgICAgICAvLyBjb25zdW1lIGxvd2VyIDMgYnl0ZXMgb2Ygc2VlZFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgLy8gdGhyb3cgaW4gbW9yZSBwc2V1ZG8gcmFuZG9tXG4gICAgICAgICAgbmV4dCA9IHNlZWQgPj4+IChpIDw8IDMpO1xuICAgICAgICAgIG5leHQgXj0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgwMTAwKTtcbiAgICAgICAgICBiLnB1dEJ5dGUoU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0ICYgMHhGRikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGIuZ2V0Qnl0ZXMobmVlZGVkKTtcbiAgfVxuICAvLyBpbml0aWFsaXplIHNlZWQgZmlsZSBBUElzXG4gIGlmKF9jcnlwdG8pIHtcbiAgICAvLyB1c2Ugbm9kZWpzIGFzeW5jIEFQSVxuICAgIGN0eC5zZWVkRmlsZSA9IGZ1bmN0aW9uKG5lZWRlZCwgY2FsbGJhY2spIHtcbiAgICAgIF9jcnlwdG8ucmFuZG9tQnl0ZXMobmVlZGVkLCBmdW5jdGlvbihlcnIsIGJ5dGVzKSB7XG4gICAgICAgIGlmKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGJ5dGVzLnRvU3RyaW5nKCkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyB1c2Ugbm9kZWpzIHN5bmMgQVBJXG4gICAgY3R4LnNlZWRGaWxlU3luYyA9IGZ1bmN0aW9uKG5lZWRlZCkge1xuICAgICAgcmV0dXJuIF9jcnlwdG8ucmFuZG9tQnl0ZXMobmVlZGVkKS50b1N0cmluZygpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY3R4LnNlZWRGaWxlID0gZnVuY3Rpb24obmVlZGVkLCBjYWxsYmFjaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZGVmYXVsdFNlZWRGaWxlKG5lZWRlZCkpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY3R4LnNlZWRGaWxlU3luYyA9IGRlZmF1bHRTZWVkRmlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGVudHJvcHkgdG8gYSBwcm5nIGN0eCdzIGFjY3VtdWxhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIG9mIGVudHJvcHkgYXMgYSBzdHJpbmcuXG4gICAqL1xuICBjdHguY29sbGVjdCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgLy8gaXRlcmF0ZSBvdmVyIHBvb2xzIGRpc3RyaWJ1dGluZyBlbnRyb3B5IGN5Y2xpY2FsbHlcbiAgICB2YXIgY291bnQgPSBieXRlcy5sZW5ndGg7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIGN0eC5wb29sc1tjdHgucG9vbF0udXBkYXRlKGJ5dGVzLnN1YnN0cihpLCAxKSk7XG4gICAgICBjdHgucG9vbCA9IChjdHgucG9vbCA9PT0gMzEpID8gMCA6IGN0eC5wb29sICsgMTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbGxlY3RzIGFuIGludGVnZXIgb2YgbiBiaXRzLlxuICAgKlxuICAgKiBAcGFyYW0gaSB0aGUgaW50ZWdlciBlbnRyb3B5LlxuICAgKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIuXG4gICAqL1xuICBjdHguY29sbGVjdEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgICB2YXIgYnl0ZXMgPSAnJztcbiAgICBmb3IodmFyIHggPSAwOyB4IDwgbjsgeCArPSA4KSB7XG4gICAgICBieXRlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpID4+IHgpICYgMHhGRik7XG4gICAgfVxuICAgIGN0eC5jb2xsZWN0KGJ5dGVzKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgV2ViIFdvcmtlciB0byByZWNlaXZlIGltbWVkaWF0ZSBlbnRyb3B5IGZyb20gdGhlIG1haW4gdGhyZWFkLlxuICAgKiBUaGlzIG1ldGhvZCBpcyByZXF1aXJlZCB1bnRpbCBXZWIgV29ya2VycyBjYW4gYWNjZXNzIHRoZSBuYXRpdmUgY3J5cHRvXG4gICAqIEFQSS4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCB0d2ljZSBmb3IgZWFjaCBjcmVhdGVkIHdvcmtlciwgb25jZSBpblxuICAgKiB0aGUgbWFpbiB0aHJlYWQsIGFuZCBvbmNlIGluIHRoZSB3b3JrZXIgaXRzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0gd29ya2VyIHRoZSB3b3JrZXIgdG8gcmVnaXN0ZXIuXG4gICAqL1xuICBjdHgucmVnaXN0ZXJXb3JrZXIgPSBmdW5jdGlvbih3b3JrZXIpIHtcbiAgICAvLyB3b3JrZXIgcmVjZWl2ZXMgcmFuZG9tIGJ5dGVzXG4gICAgaWYod29ya2VyID09PSBzZWxmKSB7XG4gICAgICBjdHguc2VlZEZpbGUgPSBmdW5jdGlvbihuZWVkZWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGZ1bmN0aW9uIGxpc3RlbmVyKGUpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgICBpZihkYXRhLmZvcmdlICYmIGRhdGEuZm9yZ2UucHJuZykge1xuICAgICAgICAgICAgc2VsZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgY2FsbGJhY2soZGF0YS5mb3JnZS5wcm5nLmVyciwgZGF0YS5mb3JnZS5wcm5nLmJ5dGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtmb3JnZToge3Bybmc6IHtuZWVkZWQ6IG5lZWRlZH19fSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtYWluIHRocmVhZCBzZW5kcyByYW5kb20gYnl0ZXMgdXBvbiByZXF1ZXN0XG4gICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgICAgICBpZihkYXRhLmZvcmdlICYmIGRhdGEuZm9yZ2UucHJuZykge1xuICAgICAgICAgIGN0eC5zZWVkRmlsZShkYXRhLmZvcmdlLnBybmcubmVlZGVkLCBmdW5jdGlvbihlcnIsIGJ5dGVzKSB7XG4gICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe2ZvcmdlOiB7cHJuZzoge2VycjogZXJyLCBieXRlczogYnl0ZXN9fX0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0byByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyIHdoZW4gdGhlIHdvcmtlciBkaWVzP1xuICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBjdHg7XG59O1xuIiwiLyoqXG4gKiBTZWN1cmUgSGFzaCBBbGdvcml0aG0gd2l0aCAxNjAtYml0IGRpZ2VzdCAoU0hBLTEpIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTUgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9tZCcpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBzaGExID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5zaGExID0gZm9yZ2Uuc2hhMSB8fCB7fTtcbmZvcmdlLm1kLnNoYTEgPSBmb3JnZS5tZC5hbGdvcml0aG1zLnNoYTEgPSBzaGExO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBTSEEtMSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKlxuICogQHJldHVybiBhIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqL1xuc2hhMS5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gZG8gaW5pdGlhbGl6YXRpb24gYXMgbmVjZXNzYXJ5XG4gIGlmKCFfaW5pdGlhbGl6ZWQpIHtcbiAgICBfaW5pdCgpO1xuICB9XG5cbiAgLy8gU0hBLTEgc3RhdGUgY29udGFpbnMgZml2ZSAzMi1iaXQgaW50ZWdlcnNcbiAgdmFyIF9zdGF0ZSA9IG51bGw7XG5cbiAgLy8gaW5wdXQgYnVmZmVyXG4gIHZhciBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIHVzZWQgZm9yIHdvcmQgc3RvcmFnZVxuICB2YXIgX3cgPSBuZXcgQXJyYXkoODApO1xuXG4gIC8vIG1lc3NhZ2UgZGlnZXN0IG9iamVjdFxuICB2YXIgbWQgPSB7XG4gICAgYWxnb3JpdGhtOiAnc2hhMScsXG4gICAgYmxvY2tMZW5ndGg6IDY0LFxuICAgIGRpZ2VzdExlbmd0aDogMjAsXG4gICAgLy8gNTYtYml0IGxlbmd0aCBvZiBtZXNzYWdlIHNvIGZhciAoZG9lcyBub3QgaW5jbHVkaW5nIHBhZGRpbmcpXG4gICAgbWVzc2FnZUxlbmd0aDogMCxcbiAgICAvLyB0cnVlIG1lc3NhZ2UgbGVuZ3RoXG4gICAgZnVsbE1lc3NhZ2VMZW5ndGg6IG51bGwsXG4gICAgLy8gc2l6ZSBvZiBtZXNzYWdlIGxlbmd0aCBpbiBieXRlc1xuICAgIG1lc3NhZ2VMZW5ndGhTaXplOiA4XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgZGlnZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRoaXMgZGlnZXN0IG9iamVjdC5cbiAgICovXG4gIG1kLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gdXAgdG8gNTYtYml0IG1lc3NhZ2UgbGVuZ3RoIGZvciBjb252ZW5pZW5jZVxuICAgIG1kLm1lc3NhZ2VMZW5ndGggPSAwO1xuXG4gICAgLy8gZnVsbCBtZXNzYWdlIGxlbmd0aCAoc2V0IG1kLm1lc3NhZ2VMZW5ndGg2NCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkpXG4gICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGggPSBtZC5tZXNzYWdlTGVuZ3RoNjQgPSBbXTtcbiAgICB2YXIgaW50MzJzID0gbWQubWVzc2FnZUxlbmd0aFNpemUgLyA0O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpbnQzMnM7ICsraSkge1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGgucHVzaCgwKTtcbiAgICB9XG4gICAgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBfc3RhdGUgPSB7XG4gICAgICBoMDogMHg2NzQ1MjMwMSxcbiAgICAgIGgxOiAweEVGQ0RBQjg5LFxuICAgICAgaDI6IDB4OThCQURDRkUsXG4gICAgICBoMzogMHgxMDMyNTQ3NixcbiAgICAgIGg0OiAweEMzRDJFMUYwXG4gICAgfTtcbiAgICByZXR1cm4gbWQ7XG4gIH07XG4gIC8vIHN0YXJ0IGRpZ2VzdCBhdXRvbWF0aWNhbGx5IGZvciBmaXJzdCB0aW1lXG4gIG1kLnN0YXJ0KCk7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGRpZ2VzdCB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlIGlucHV0LiBUaGUgZ2l2ZW4gaW5wdXQgY2FuXG4gICAqIHRyZWF0ZWQgYXMgcmF3IGlucHV0IChubyBlbmNvZGluZyB3aWxsIGJlIGFwcGxpZWQpIG9yIGFuIGVuY29kaW5nIG9mXG4gICAqICd1dGY4JyBtYXliZSBnaXZlbiB0byBlbmNvZGUgdGhlIGlucHV0IHVzaW5nIFVURi04LlxuICAgKlxuICAgKiBAcGFyYW0gbXNnIHRoZSBtZXNzYWdlIGlucHV0IHRvIHVwZGF0ZSB3aXRoLlxuICAgKiBAcGFyYW0gZW5jb2RpbmcgdGhlIGVuY29kaW5nIHRvIHVzZSAoZGVmYXVsdDogJ3JhdycsIG90aGVyOiAndXRmOCcpLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoaXMgZGlnZXN0IG9iamVjdC5cbiAgICovXG4gIG1kLnVwZGF0ZSA9IGZ1bmN0aW9uKG1zZywgZW5jb2RpbmcpIHtcbiAgICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICBtc2cgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgobXNnKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgbWVzc2FnZSBsZW5ndGhcbiAgICB2YXIgbGVuID0gbXNnLmxlbmd0aDtcbiAgICBtZC5tZXNzYWdlTGVuZ3RoICs9IGxlbjtcbiAgICBsZW4gPSBbKGxlbiAvIDB4MTAwMDAwMDAwKSA+Pj4gMCwgbGVuID4+PiAwXTtcbiAgICBmb3IodmFyIGkgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gKz0gbGVuWzFdO1xuICAgICAgbGVuWzFdID0gbGVuWzBdICsgKChtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSAvIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldID4+PiAwO1xuICAgICAgbGVuWzBdID0gKChsZW5bMV0gLyAweDEwMDAwMDAwMCkgPj4+IDApO1xuICAgIH1cblxuICAgIC8vIGFkZCBieXRlcyB0byBpbnB1dCBidWZmZXJcbiAgICBfaW5wdXQucHV0Qnl0ZXMobXNnKTtcblxuICAgIC8vIHByb2Nlc3MgYnl0ZXNcbiAgICBfdXBkYXRlKF9zdGF0ZSwgX3csIF9pbnB1dCk7XG5cbiAgICAvLyBjb21wYWN0IGlucHV0IGJ1ZmZlciBldmVyeSAySyBvciBpZiBlbXB0eVxuICAgIGlmKF9pbnB1dC5yZWFkID4gMjA0OCB8fCBfaW5wdXQubGVuZ3RoKCkgPT09IDApIHtcbiAgICAgIF9pbnB1dC5jb21wYWN0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyB0aGUgZGlnZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIGEgYnl0ZSBidWZmZXIgY29udGFpbmluZyB0aGUgZGlnZXN0IHZhbHVlLlxuICAgKi9cbiAgbWQuZGlnZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgLyogTm90ZTogSGVyZSB3ZSBjb3B5IHRoZSByZW1haW5pbmcgYnl0ZXMgaW4gdGhlIGlucHV0IGJ1ZmZlciBhbmRcbiAgICBhZGQgdGhlIGFwcHJvcHJpYXRlIFNIQS0xIHBhZGRpbmcuIFRoZW4gd2UgZG8gdGhlIGZpbmFsIHVwZGF0ZVxuICAgIG9uIGEgY29weSBvZiB0aGUgc3RhdGUgc28gdGhhdCBpZiB0aGUgdXNlciB3YW50cyB0byBnZXRcbiAgICBpbnRlcm1lZGlhdGUgZGlnZXN0cyB0aGV5IGNhbiBkbyBzby4gKi9cblxuICAgIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgbXVzdCBiZSBhZGRlZCB0byB0aGUgbWVzc2FnZVxuICAgIHRvIGVuc3VyZSBpdHMgbGVuZ3RoIGlzIGNvbmdydWVudCB0byA0NDggbW9kIDUxMi4gSW4gb3RoZXIgd29yZHMsXG4gICAgdGhlIGRhdGEgdG8gYmUgZGlnZXN0ZWQgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDUxMiBiaXRzIChvciAxMjggYnl0ZXMpLlxuICAgIFRoaXMgZGF0YSBpbmNsdWRlcyB0aGUgbWVzc2FnZSwgc29tZSBwYWRkaW5nLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICBtZXNzYWdlLiBTaW5jZSB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlIHdpbGwgYmUgZW5jb2RlZCBhcyA4IGJ5dGVzICg2NFxuICAgIGJpdHMpLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgZGF0YSBtdXN0IGhhdmUgNTYgYnl0ZXNcbiAgICAoNDQ4IGJpdHMpIG9mIG1lc3NhZ2UgYW5kIHBhZGRpbmcuIFRoZXJlZm9yZSwgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZVxuICAgIHBsdXMgdGhlIHBhZGRpbmcgbXVzdCBiZSBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIgYmVjYXVzZVxuICAgIDUxMiAtIDEyOCA9IDQ0OC5cblxuICAgIEluIG9yZGVyIHRvIGZpbGwgdXAgdGhlIG1lc3NhZ2UgbGVuZ3RoIGl0IG11c3QgYmUgZmlsbGVkIHdpdGhcbiAgICBwYWRkaW5nIHRoYXQgYmVnaW5zIHdpdGggMSBiaXQgZm9sbG93ZWQgYnkgYWxsIDAgYml0cy4gUGFkZGluZ1xuICAgIG11c3QgKmFsd2F5cyogYmUgcHJlc2VudCwgc28gaWYgdGhlIG1lc3NhZ2UgbGVuZ3RoIGlzIGFscmVhZHlcbiAgICBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIsIHRoZW4gNTEyIHBhZGRpbmcgYml0cyBtdXN0IGJlIGFkZGVkLiAqL1xuXG4gICAgdmFyIGZpbmFsQmxvY2sgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX2lucHV0LmJ5dGVzKCkpO1xuXG4gICAgLy8gY29tcHV0ZSByZW1haW5pbmcgc2l6ZSB0byBiZSBkaWdlc3RlZCAoaW5jbHVkZSBtZXNzYWdlIGxlbmd0aCBzaXplKVxuICAgIHZhciByZW1haW5pbmcgPSAoXG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFttZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxXSArXG4gICAgICBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSk7XG5cbiAgICAvLyBhZGQgcGFkZGluZyBmb3Igb3ZlcmZsb3cgYmxvY2tTaXplIC0gb3ZlcmZsb3dcbiAgICAvLyBfcGFkZGluZyBzdGFydHMgd2l0aCAxIGJ5dGUgd2l0aCBmaXJzdCBiaXQgaXMgc2V0IChieXRlIHZhbHVlIDEyOCksIHRoZW5cbiAgICAvLyB0aGVyZSBtYXkgYmUgdXAgdG8gKGJsb2NrU2l6ZSAtIDEpIG90aGVyIHBhZCBieXRlc1xuICAgIHZhciBvdmVyZmxvdyA9IHJlbWFpbmluZyAmIChtZC5ibG9ja0xlbmd0aCAtIDEpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX3BhZGRpbmcuc3Vic3RyKDAsIG1kLmJsb2NrTGVuZ3RoIC0gb3ZlcmZsb3cpKTtcblxuICAgIC8vIHNlcmlhbGl6ZSBtZXNzYWdlIGxlbmd0aCBpbiBiaXRzIGluIGJpZy1lbmRpYW4gb3JkZXI7IHNpbmNlIGxlbmd0aFxuICAgIC8vIGlzIHN0b3JlZCBpbiBieXRlcyB3ZSBtdWx0aXBseSBieSA4IGFuZCBhZGQgY2FycnkgZnJvbSBuZXh0IGludFxuICAgIHZhciBuZXh0LCBjYXJyeTtcbiAgICB2YXIgYml0cyA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoWzBdICogODtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBuZXh0ID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaSArIDFdICogODtcbiAgICAgIGNhcnJ5ID0gKG5leHQgLyAweDEwMDAwMDAwMCkgPj4+IDA7XG4gICAgICBiaXRzICs9IGNhcnJ5O1xuICAgICAgZmluYWxCbG9jay5wdXRJbnQzMihiaXRzID4+PiAwKTtcbiAgICAgIGJpdHMgPSBuZXh0ID4+PiAwO1xuICAgIH1cbiAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMpO1xuXG4gICAgdmFyIHMyID0ge1xuICAgICAgaDA6IF9zdGF0ZS5oMCxcbiAgICAgIGgxOiBfc3RhdGUuaDEsXG4gICAgICBoMjogX3N0YXRlLmgyLFxuICAgICAgaDM6IF9zdGF0ZS5oMyxcbiAgICAgIGg0OiBfc3RhdGUuaDRcbiAgICB9O1xuICAgIF91cGRhdGUoczIsIF93LCBmaW5hbEJsb2NrKTtcbiAgICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMSk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMik7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMyk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNCk7XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgcmV0dXJuIG1kO1xufTtcblxuLy8gc2hhLTEgcGFkZGluZyBieXRlcyBub3QgaW5pdGlhbGl6ZWQgeWV0XG52YXIgX3BhZGRpbmcgPSBudWxsO1xudmFyIF9pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBjb25zdGFudCB0YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIF9pbml0KCkge1xuICAvLyBjcmVhdGUgcGFkZGluZ1xuICBfcGFkZGluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI4KTtcbiAgX3BhZGRpbmcgKz0gZm9yZ2UudXRpbC5maWxsU3RyaW5nKFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCksIDY0KTtcblxuICAvLyBub3cgaW5pdGlhbGl6ZWRcbiAgX2luaXRpYWxpemVkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIGEgU0hBLTEgc3RhdGUgd2l0aCB0aGUgZ2l2ZW4gYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIHMgdGhlIFNIQS0xIHN0YXRlIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB3IHRoZSBhcnJheSB0byB1c2UgdG8gc3RvcmUgd29yZHMuXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyIHRvIHVwZGF0ZSB3aXRoLlxuICovXG5mdW5jdGlvbiBfdXBkYXRlKHMsIHcsIGJ5dGVzKSB7XG4gIC8vIGNvbnN1bWUgNTEyIGJpdCAoNjQgYnl0ZSkgY2h1bmtzXG4gIHZhciB0LCBhLCBiLCBjLCBkLCBlLCBmLCBpO1xuICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoKCk7XG4gIHdoaWxlKGxlbiA+PSA2NCkge1xuICAgIC8vIHRoZSB3IGFycmF5IHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggc2l4dGVlbiAzMi1iaXQgYmlnLWVuZGlhbiB3b3Jkc1xuICAgIC8vIGFuZCB0aGVuIGV4dGVuZGVkIGludG8gODAgMzItYml0IHdvcmRzIGFjY29yZGluZyB0byBTSEEtMSBhbGdvcml0aG1cbiAgICAvLyBhbmQgZm9yIDMyLTc5IHVzaW5nIE1heCBMb2NrdHl1a2hpbidzIG9wdGltaXphdGlvblxuXG4gICAgLy8gaW5pdGlhbGl6ZSBoYXNoIHZhbHVlIGZvciB0aGlzIGNodW5rXG4gICAgYSA9IHMuaDA7XG4gICAgYiA9IHMuaDE7XG4gICAgYyA9IHMuaDI7XG4gICAgZCA9IHMuaDM7XG4gICAgZSA9IHMuaDQ7XG5cbiAgICAvLyByb3VuZCAxXG4gICAgZm9yKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgdCA9IGJ5dGVzLmdldEludDMyKCk7XG4gICAgICB3W2ldID0gdDtcbiAgICAgIGYgPSBkIF4gKGIgJiAoYyBeIGQpKTtcbiAgICAgIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgMHg1QTgyNzk5OSArIHQ7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cbiAgICBmb3IoOyBpIDwgMjA7ICsraSkge1xuICAgICAgdCA9ICh3W2kgLSAzXSBeIHdbaSAtIDhdIF4gd1tpIC0gMTRdIF4gd1tpIC0gMTZdKTtcbiAgICAgIHQgPSAodCA8PCAxKSB8ICh0ID4+PiAzMSk7XG4gICAgICB3W2ldID0gdDtcbiAgICAgIGYgPSBkIF4gKGIgJiAoYyBeIGQpKTtcbiAgICAgIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgMHg1QTgyNzk5OSArIHQ7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cbiAgICAvLyByb3VuZCAyXG4gICAgZm9yKDsgaSA8IDMyOyArK2kpIHtcbiAgICAgIHQgPSAod1tpIC0gM10gXiB3W2kgLSA4XSBeIHdbaSAtIDE0XSBeIHdbaSAtIDE2XSk7XG4gICAgICB0ID0gKHQgPDwgMSkgfCAodCA+Pj4gMzEpO1xuICAgICAgd1tpXSA9IHQ7XG4gICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDZFRDlFQkExICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIGZvcig7IGkgPCA0MDsgKytpKSB7XG4gICAgICB0ID0gKHdbaSAtIDZdIF4gd1tpIC0gMTZdIF4gd1tpIC0gMjhdIF4gd1tpIC0gMzJdKTtcbiAgICAgIHQgPSAodCA8PCAyKSB8ICh0ID4+PiAzMCk7XG4gICAgICB3W2ldID0gdDtcbiAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIDB4NkVEOUVCQTEgKyB0O1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG4gICAgLy8gcm91bmQgM1xuICAgIGZvcig7IGkgPCA2MDsgKytpKSB7XG4gICAgICB0ID0gKHdbaSAtIDZdIF4gd1tpIC0gMTZdIF4gd1tpIC0gMjhdIF4gd1tpIC0gMzJdKTtcbiAgICAgIHQgPSAodCA8PCAyKSB8ICh0ID4+PiAzMCk7XG4gICAgICB3W2ldID0gdDtcbiAgICAgIGYgPSAoYiAmIGMpIHwgKGQgJiAoYiBeIGMpKTtcbiAgICAgIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgMHg4RjFCQkNEQyArIHQ7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cbiAgICAvLyByb3VuZCA0XG4gICAgZm9yKDsgaSA8IDgwOyArK2kpIHtcbiAgICAgIHQgPSAod1tpIC0gNl0gXiB3W2kgLSAxNl0gXiB3W2kgLSAyOF0gXiB3W2kgLSAzMl0pO1xuICAgICAgdCA9ICh0IDw8IDIpIHwgKHQgPj4+IDMwKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgMHhDQTYyQzFENiArIHQ7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBoYXNoIHN0YXRlXG4gICAgcy5oMCA9IChzLmgwICsgYSkgfCAwO1xuICAgIHMuaDEgPSAocy5oMSArIGIpIHwgMDtcbiAgICBzLmgyID0gKHMuaDIgKyBjKSB8IDA7XG4gICAgcy5oMyA9IChzLmgzICsgZCkgfCAwO1xuICAgIHMuaDQgPSAocy5oNCArIGUpIHwgMDtcblxuICAgIGxlbiAtPSA2NDtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzbjEgPSByZXF1aXJlKCdhc24xLmpzJylcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vLi4vdXRpbCcpXG5jb25zdCB0b0Jhc2U2NCA9IHV0aWwudG9CYXNlNjRcbmNvbnN0IHRvQm4gPSB1dGlsLnRvQm5cblxuY29uc3QgUlNBUHJpdmF0ZUtleSA9IGFzbjEuZGVmaW5lKCdSU0FQcml2YXRlS2V5JywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgndmVyc2lvbicpLmludCgpLFxuICAgIHRoaXMua2V5KCdtb2R1bHVzJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3B1YmxpY0V4cG9uZW50JykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3ByaXZhdGVFeHBvbmVudCcpLmludCgpLFxuICAgIHRoaXMua2V5KCdwcmltZTEnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHJpbWUyJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ2V4cG9uZW50MScpLmludCgpLFxuICAgIHRoaXMua2V5KCdleHBvbmVudDInKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnY29lZmZpY2llbnQnKS5pbnQoKVxuICApXG59KVxuXG5jb25zdCBBbGdvcml0aG1JZGVudGlmaWVyID0gYXNuMS5kZWZpbmUoJ0FsZ29yaXRobUlkZW50aWZpZXInLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdhbGdvcml0aG0nKS5vYmppZCh7XG4gICAgICAnMS4yLjg0MC4xMTM1NDkuMS4xLjEnOiAncnNhJ1xuICAgIH0pLFxuICAgIHRoaXMua2V5KCdub25lJykub3B0aW9uYWwoKS5udWxsXygpLFxuICAgIHRoaXMua2V5KCdjdXJ2ZScpLm9wdGlvbmFsKCkub2JqaWQoKSxcbiAgICB0aGlzLmtleSgncGFyYW1zJykub3B0aW9uYWwoKS5zZXEoKS5vYmooXG4gICAgICB0aGlzLmtleSgncCcpLmludCgpLFxuICAgICAgdGhpcy5rZXkoJ3EnKS5pbnQoKSxcbiAgICAgIHRoaXMua2V5KCdnJykuaW50KClcbiAgICApXG4gIClcbn0pXG5cbmNvbnN0IFB1YmxpY0tleSA9IGFzbjEuZGVmaW5lKCdSU0FQdWJsaWNLZXknLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdhbGdvcml0aG0nKS51c2UoQWxnb3JpdGhtSWRlbnRpZmllciksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3RQdWJsaWNLZXknKS5iaXRzdHIoKVxuICApXG59KVxuXG5jb25zdCBSU0FQdWJsaWNLZXkgPSBhc24xLmRlZmluZSgnUlNBUHVibGljS2V5JywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnbW9kdWx1cycpLmludCgpLFxuICAgIHRoaXMua2V5KCdwdWJsaWNFeHBvbmVudCcpLmludCgpXG4gIClcbn0pXG5cbi8vIENvbnZlcnQgYSBQS0NTIzEgaW4gQVNOMSBERVIgZm9ybWF0IHRvIGEgSldLIGtleVxuZXhwb3J0cy5wa2NzMVRvSndrID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gIGNvbnN0IGFzbjEgPSBSU0FQcml2YXRlS2V5LmRlY29kZShieXRlcywgJ2RlcicpXG5cbiAgcmV0dXJuIHtcbiAgICBrdHk6ICdSU0EnLFxuICAgIG46IHRvQmFzZTY0KGFzbjEubW9kdWx1cyksXG4gICAgZTogdG9CYXNlNjQoYXNuMS5wdWJsaWNFeHBvbmVudCksXG4gICAgZDogdG9CYXNlNjQoYXNuMS5wcml2YXRlRXhwb25lbnQpLFxuICAgIHA6IHRvQmFzZTY0KGFzbjEucHJpbWUxKSxcbiAgICBxOiB0b0Jhc2U2NChhc24xLnByaW1lMiksXG4gICAgZHA6IHRvQmFzZTY0KGFzbjEuZXhwb25lbnQxKSxcbiAgICBkcTogdG9CYXNlNjQoYXNuMS5leHBvbmVudDIpLFxuICAgIHFpOiB0b0Jhc2U2NChhc24xLmNvZWZmaWNpZW50KSxcbiAgICBhbGc6ICdSUzI1NicsXG4gICAga2lkOiAnMjAxMS0wNC0yOSdcbiAgfVxufVxuXG4vLyBDb252ZXJ0IGEgSldLIGtleSBpbnRvIFBLQ1MjMSBpbiBBU04xIERFUiBmb3JtYXRcbmV4cG9ydHMuandrVG9Qa2NzMSA9IGZ1bmN0aW9uIChqd2spIHtcbiAgcmV0dXJuIFJTQVByaXZhdGVLZXkuZW5jb2RlKHtcbiAgICB2ZXJzaW9uOiAwLFxuICAgIG1vZHVsdXM6IHRvQm4oandrLm4pLFxuICAgIHB1YmxpY0V4cG9uZW50OiB0b0JuKGp3ay5lKSxcbiAgICBwcml2YXRlRXhwb25lbnQ6IHRvQm4oandrLmQpLFxuICAgIHByaW1lMTogdG9Cbihqd2sucCksXG4gICAgcHJpbWUyOiB0b0JuKGp3ay5xKSxcbiAgICBleHBvbmVudDE6IHRvQm4oandrLmRwKSxcbiAgICBleHBvbmVudDI6IHRvQm4oandrLmRxKSxcbiAgICBjb2VmZmljaWVudDogdG9Cbihqd2sucWkpXG4gIH0sICdkZXInKVxufVxuXG4vLyBDb252ZXJ0IGEgUEtDSVggaW4gQVNOMSBERVIgZm9ybWF0IHRvIGEgSldLIGtleVxuZXhwb3J0cy5wa2l4VG9Kd2sgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgY29uc3QgbmRhdGEgPSBQdWJsaWNLZXkuZGVjb2RlKGJ5dGVzLCAnZGVyJylcbiAgY29uc3QgYXNuMSA9IFJTQVB1YmxpY0tleS5kZWNvZGUobmRhdGEuc3ViamVjdFB1YmxpY0tleS5kYXRhLCAnZGVyJylcblxuICByZXR1cm4ge1xuICAgIGt0eTogJ1JTQScsXG4gICAgbjogdG9CYXNlNjQoYXNuMS5tb2R1bHVzKSxcbiAgICBlOiB0b0Jhc2U2NChhc24xLnB1YmxpY0V4cG9uZW50KSxcbiAgICBhbGc6ICdSUzI1NicsXG4gICAga2lkOiAnMjAxMS0wNC0yOSdcbiAgfVxufVxuXG4vLyBDb252ZXJ0IGEgSldLIGtleSB0byBQS0NJWCBpbiBBU04xIERFUiBmb3JtYXRcbmV4cG9ydHMuandrVG9Qa2l4ID0gZnVuY3Rpb24gKGp3aykge1xuICByZXR1cm4gUHVibGljS2V5LmVuY29kZSh7XG4gICAgYWxnb3JpdGhtOiB7XG4gICAgICBhbGdvcml0aG06ICdyc2EnLFxuICAgICAgbm9uZTogbnVsbFxuICAgIH0sXG4gICAgc3ViamVjdFB1YmxpY0tleToge1xuICAgICAgZGF0YTogUlNBUHVibGljS2V5LmVuY29kZSh7XG4gICAgICAgIG1vZHVsdXM6IHRvQm4oandrLm4pLFxuICAgICAgICBwdWJsaWNFeHBvbmVudDogdG9Cbihqd2suZSlcbiAgICAgIH0sICdkZXInKVxuICAgIH1cbiAgfSwgJ2RlcicpXG59XG4iLCJ2YXIgb25maWVsZCA9IGZ1bmN0aW9uIChmLCByZXN1bHQpIHtcbiAgdmFyIHByZWZpeCA9IGYucmVwZWF0ZWQgPyAncmVwZWF0ZWQnIDogZi5yZXF1aXJlZCA/ICdyZXF1aXJlZCcgOiAnb3B0aW9uYWwnXG4gIGlmIChmLnR5cGUgPT09ICdtYXAnKSBwcmVmaXggPSAnbWFwPCcgKyBmLm1hcC5mcm9tICsgJywnICsgZi5tYXAudG8gKyAnPidcbiAgaWYgKGYub25lb2YpIHByZWZpeCA9ICcnXG5cbiAgdmFyIG9wdHMgPSBPYmplY3Qua2V5cyhmLm9wdGlvbnMgfHwge30pLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleSArICcgPSAnICsgZi5vcHRpb25zW2tleV1cbiAgfSkuam9pbignLCcpXG5cbiAgaWYgKG9wdHMpIG9wdHMgPSAnIFsnICsgb3B0cyArICddJ1xuXG4gIHJlc3VsdC5wdXNoKChwcmVmaXggPyBwcmVmaXggKyAnICcgOiAnJykgKyAoZi5tYXAgPT09ICdtYXAnID8gJycgOiBmLnR5cGUgKyAnICcpICsgZi5uYW1lICsgJyA9ICcgKyBmLnRhZyArIG9wdHMgKyAnOycpXG4gIHJldHVybiByZXN1bHRcbn1cblxudmFyIG9ubWVzc2FnZSA9IGZ1bmN0aW9uIChtLCByZXN1bHQpIHtcbiAgcmVzdWx0LnB1c2goJ21lc3NhZ2UgJyArIG0ubmFtZSArICcgeycpXG5cbiAgaWYgKCFtLmVudW1zKSBtLmVudW1zID0gW11cbiAgbS5lbnVtcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgcmVzdWx0LnB1c2gob25lbnVtKGUsIFtdKSlcbiAgfSlcblxuICBpZiAoIW0ubWVzc2FnZXMpIG0ubWVzc2FnZXMgPSBbXVxuICBtLm1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICByZXN1bHQucHVzaChvbm1lc3NhZ2UobSwgW10pKVxuICB9KVxuXG4gIHZhciBvbmVvZnMgPSB7fVxuXG4gIGlmICghbS5maWVsZHMpIG0uZmllbGRzID0gW11cbiAgbS5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgIGlmIChmLm9uZW9mKSB7XG4gICAgICBpZiAoIW9uZW9mc1tmLm9uZW9mXSkgb25lb2ZzW2Yub25lb2ZdID0gW11cbiAgICAgIG9uZW9mc1tmLm9uZW9mXS5wdXNoKG9uZmllbGQoZiwgW10pKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChvbmZpZWxkKGYsIFtdKSlcbiAgICB9XG4gIH0pXG5cbiAgT2JqZWN0LmtleXMob25lb2ZzKS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgb25lb2ZzW25dLnVuc2hpZnQoJ29uZW9mICcgKyBuICsgJyB7JylcbiAgICBvbmVvZnNbbl0ucHVzaCgnfScpXG4gICAgcmVzdWx0LnB1c2gob25lb2ZzW25dKVxuICB9KVxuXG4gIHJlc3VsdC5wdXNoKCd9JywgJycpXG4gIHJldHVybiByZXN1bHRcbn1cblxudmFyIG9uZW51bSA9IGZ1bmN0aW9uIChlLCByZXN1bHQpIHtcbiAgcmVzdWx0LnB1c2goJ2VudW0gJyArIGUubmFtZSArICcgeycpXG4gIGlmICghZS5vcHRpb25zKSBlLm9wdGlvbnMgPSB7fVxuICB2YXIgb3B0aW9ucyA9IG9ub3B0aW9uKGUub3B0aW9ucywgW10pXG4gIGlmIChvcHRpb25zLmxlbmd0aCA+IDEpIHtcbiAgICByZXN1bHQucHVzaChvcHRpb25zLnNsaWNlKDAsIC0xKSlcbiAgfVxuICBPYmplY3Qua2V5cyhlLnZhbHVlcykubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIHZhbCA9IG9uZW51bXZhbHVlKGUudmFsdWVzW3ZdKVxuICAgIHJlc3VsdC5wdXNoKFt2ICsgJyA9ICcgKyB2YWwgKyAnOyddKVxuICB9KVxuICByZXN1bHQucHVzaCgnfScsICcnKVxuICByZXR1cm4gcmVzdWx0XG59XG5cbnZhciBvbmVudW12YWx1ZSA9IGZ1bmN0aW9uICh2LCByZXN1bHQpIHtcbiAgdmFyIG9wdHMgPSBPYmplY3Qua2V5cyh2Lm9wdGlvbnMgfHwge30pLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleSArICcgPSAnICsgdi5vcHRpb25zW2tleV1cbiAgfSkuam9pbignLCcpXG5cbiAgaWYgKG9wdHMpIG9wdHMgPSAnIFsnICsgb3B0cyArICddJ1xuICB2YXIgdmFsID0gdi52YWx1ZSArIG9wdHNcbiAgcmV0dXJuIHZhbFxufVxuXG52YXIgb25vcHRpb24gPSBmdW5jdGlvbiAobywgcmVzdWx0KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMobylcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICB2YXIgdiA9IG9bb3B0aW9uXVxuICAgIGlmICh+b3B0aW9uLmluZGV4T2YoJy4nKSkgb3B0aW9uID0gJygnICsgb3B0aW9uICsgJyknXG5cbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2XG5cbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHYgPSBvbm9wdGlvbk1hcCh2LCBbXSlcbiAgICAgIGlmICh2Lmxlbmd0aCkgcmVzdWx0LnB1c2goJ29wdGlvbiAnICsgb3B0aW9uICsgJyA9IHsnLCB2LCAnfTsnKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgb3B0aW9uICE9PSAnb3B0aW1pemVfZm9yJykgdiA9ICdcIicgKyB2ICsgJ1wiJ1xuICAgICAgcmVzdWx0LnB1c2goJ29wdGlvbiAnICsgb3B0aW9uICsgJyA9ICcgKyB2ICsgJzsnKVxuICAgIH1cbiAgfSlcbiAgaWYgKGtleXMubGVuZ3RoID4gMCkge1xuICAgIHJlc3VsdC5wdXNoKCcnKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG52YXIgb25vcHRpb25NYXAgPSBmdW5jdGlvbiAobywgcmVzdWx0KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMobylcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHYgPSBvW2tdXG5cbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2XG5cbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgIHYuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgIHYgPSBvbm9wdGlvbk1hcCh2LCBbXSlcbiAgICAgICAgICBpZiAodi5sZW5ndGgpIHJlc3VsdC5wdXNoKGsgKyAnIHsnLCB2LCAnfScpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gb25vcHRpb25NYXAodiwgW10pXG4gICAgICAgIGlmICh2Lmxlbmd0aCkgcmVzdWx0LnB1c2goayArICcgeycsIHYsICd9JylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB2ID0gJ1wiJyArIHYgKyAnXCInXG4gICAgICByZXN1bHQucHVzaChrICsgJzogJyArIHYpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxudmFyIG9uc2VydmljZXMgPSBmdW5jdGlvbiAocywgcmVzdWx0KSB7XG4gIHJlc3VsdC5wdXNoKCdzZXJ2aWNlICcgKyBzLm5hbWUgKyAnIHsnKVxuXG4gIGlmICghcy5vcHRpb25zKSBzLm9wdGlvbnMgPSB7fVxuICBvbm9wdGlvbihzLm9wdGlvbnMsIHJlc3VsdClcbiAgaWYgKCFzLm1ldGhvZHMpIHMubWV0aG9kcyA9IFtdXG4gIHMubWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgcmVzdWx0LnB1c2gob25ycGMobSwgW10pKVxuICB9KVxuXG4gIHJlc3VsdC5wdXNoKCd9JywgJycpXG4gIHJldHVybiByZXN1bHRcbn1cblxudmFyIG9ucnBjID0gZnVuY3Rpb24gKHJwYywgcmVzdWx0KSB7XG4gIHZhciBkZWYgPSAncnBjICcgKyBycGMubmFtZSArICcoJ1xuICBpZiAocnBjLmNsaWVudF9zdHJlYW1pbmcpIGRlZiArPSAnc3RyZWFtICdcbiAgZGVmICs9IHJwYy5pbnB1dF90eXBlICsgJykgcmV0dXJucyAoJ1xuICBpZiAocnBjLnNlcnZlcl9zdHJlYW1pbmcpIGRlZiArPSAnc3RyZWFtICdcbiAgZGVmICs9IHJwYy5vdXRwdXRfdHlwZSArICcpJ1xuXG4gIGlmICghcnBjLm9wdGlvbnMpIHJwYy5vcHRpb25zID0ge31cblxuICB2YXIgb3B0aW9ucyA9IG9ub3B0aW9uKHJwYy5vcHRpb25zLCBbXSlcbiAgaWYgKG9wdGlvbnMubGVuZ3RoID4gMSkge1xuICAgIHJlc3VsdC5wdXNoKGRlZiArICcgeycsIG9wdGlvbnMuc2xpY2UoMCwgLTEpLCAnfScpXG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnB1c2goZGVmICsgJzsnKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG52YXIgaW5kZW50ID0gZnVuY3Rpb24gKGx2bCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShsaW5lKSkgcmV0dXJuIGxpbmUubWFwKGluZGVudChsdmwgKyAnICAnKSkuam9pbignXFxuJylcbiAgICByZXR1cm4gbHZsICsgbGluZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuICB2YXIgcmVzdWx0ID0gW11cblxuICByZXN1bHQucHVzaCgnc3ludGF4ID0gXCJwcm90bycgKyBzY2hlbWEuc3ludGF4ICsgJ1wiOycsICcnKVxuXG4gIGlmIChzY2hlbWEucGFja2FnZSkgcmVzdWx0LnB1c2goJ3BhY2thZ2UgJyArIHNjaGVtYS5wYWNrYWdlICsgJzsnLCAnJylcblxuICBpZiAoIXNjaGVtYS5vcHRpb25zKSBzY2hlbWEub3B0aW9ucyA9IHt9XG5cbiAgb25vcHRpb24oc2NoZW1hLm9wdGlvbnMsIHJlc3VsdClcblxuICBpZiAoIXNjaGVtYS5lbnVtcykgc2NoZW1hLmVudW1zID0gW11cbiAgc2NoZW1hLmVudW1zLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICBvbmVudW0oZSwgcmVzdWx0KVxuICB9KVxuXG4gIGlmICghc2NoZW1hLm1lc3NhZ2VzKSBzY2hlbWEubWVzc2FnZXMgPSBbXVxuICBzY2hlbWEubWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgIG9ubWVzc2FnZShtLCByZXN1bHQpXG4gIH0pXG5cbiAgaWYgKHNjaGVtYS5zZXJ2aWNlcykge1xuICAgIHNjaGVtYS5zZXJ2aWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICBvbnNlcnZpY2VzKHMsIHJlc3VsdClcbiAgICB9KVxuICB9XG4gIHJldHVybiByZXN1bHQubWFwKGluZGVudCgnJykpLmpvaW4oJ1xcbicpXG59XG4iLCJ2YXIgdG9rZW5pemUgPSByZXF1aXJlKCcuL3Rva2VuaXplJylcbnZhciBNQVhfUkFOR0UgPSAweDFGRkZGRkZGXG5cbi8vIFwiT25seSByZXBlYXRlZCBmaWVsZHMgb2YgcHJpbWl0aXZlIG51bWVyaWMgdHlwZXMgKHR5cGVzIHdoaWNoIHVzZSB0aGUgdmFyaW50LCAzMi1iaXQsIG9yIDY0LWJpdCB3aXJlIHR5cGVzKSBjYW4gYmUgZGVjbGFyZWQgXCJwYWNrZWRcIi5cIlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL2VuY29kaW5nI29wdGlvbmFsXG52YXIgUEFDS0FCTEVfVFlQRVMgPSBbXG4gIC8vIHZhcmludCB3aXJlIHR5cGVzXG4gICdpbnQzMicsICdpbnQ2NCcsICd1aW50MzInLCAndWludDY0JywgJ3NpbnQzMicsICdzaW50NjQnLCAnYm9vbCcsXG4gIC8vICsgRU5VTVNcbiAgLy8gNjQtYml0IHdpcmUgdHlwZXNcbiAgJ2ZpeGVkNjQnLCAnc2ZpeGVkNjQnLCAnZG91YmxlJyxcbiAgLy8gMzItYml0IHdpcmUgdHlwZXNcbiAgJ2ZpeGVkMzInLCAnc2ZpeGVkMzInLCAnZmxvYXQnXG5dXG5cbnZhciBvbmZpZWxkb3B0aW9ucyA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcbiAgdmFyIG9wdHMgPSB7fVxuXG4gIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgc3dpdGNoICh0b2tlbnNbMF0pIHtcbiAgICAgIGNhc2UgJ1snOlxuICAgICAgY2FzZSAnLCc6XG4gICAgICAgIHRva2Vucy5zaGlmdCgpXG4gICAgICAgIHZhciBuYW1lID0gdG9rZW5zLnNoaWZ0KClcbiAgICAgICAgaWYgKG5hbWUgPT09ICcoJykgeyAgICAgICAvLyBoYW5kbGluZyBbKEEpID0gQl1cbiAgICAgICAgICBuYW1lID0gdG9rZW5zLnNoaWZ0KClcbiAgICAgICAgICB0b2tlbnMuc2hpZnQoKSAgICAgICAgICAvLyByZW1vdmUgdGhlIGVuZCBvZiBicmFja2V0XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2Vuc1swXSAhPT0gJz0nKSB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdG9rZW4gaW4gZmllbGQgb3B0aW9uczogJyArIHRva2Vuc1swXSlcbiAgICAgICAgdG9rZW5zLnNoaWZ0KClcbiAgICAgICAgaWYgKHRva2Vuc1swXSA9PT0gJ10nKSB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgXSBpbiBmaWVsZCBvcHRpb24nKVxuICAgICAgICBvcHRzW25hbWVdID0gdG9rZW5zLnNoaWZ0KClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ10nOlxuICAgICAgICB0b2tlbnMuc2hpZnQoKVxuICAgICAgICByZXR1cm4gb3B0c1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdG9rZW4gaW4gZmllbGQgb3B0aW9uczogJyArIHRva2Vuc1swXSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNsb3NpbmcgdGFnIGZvciBmaWVsZCBvcHRpb25zJylcbn1cblxudmFyIG9uZmllbGQgPSBmdW5jdGlvbiAodG9rZW5zKSB7XG4gIHZhciBmaWVsZCA9IHtcbiAgICBuYW1lOiBudWxsLFxuICAgIHR5cGU6IG51bGwsXG4gICAgdGFnOiAtMSxcbiAgICBtYXA6IG51bGwsXG4gICAgb25lb2Y6IG51bGwsXG4gICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgIHJlcGVhdGVkOiBmYWxzZSxcbiAgICBvcHRpb25zOiB7fVxuICB9XG5cbiAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICBzd2l0Y2ggKHRva2Vuc1swXSkge1xuICAgICAgY2FzZSAnPSc6XG4gICAgICAgIHRva2Vucy5zaGlmdCgpXG4gICAgICAgIGZpZWxkLnRhZyA9IE51bWJlcih0b2tlbnMuc2hpZnQoKSlcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnbWFwJzpcbiAgICAgICAgZmllbGQudHlwZSA9ICdtYXAnXG4gICAgICAgIGZpZWxkLm1hcCA9IHtmcm9tOiBudWxsLCB0bzogbnVsbH1cbiAgICAgICAgdG9rZW5zLnNoaWZ0KClcbiAgICAgICAgaWYgKHRva2Vuc1swXSAhPT0gJzwnKSB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdG9rZW4gaW4gbWFwIHR5cGU6ICcgKyB0b2tlbnNbMF0pXG4gICAgICAgIHRva2Vucy5zaGlmdCgpXG4gICAgICAgIGZpZWxkLm1hcC5mcm9tID0gdG9rZW5zLnNoaWZ0KClcbiAgICAgICAgaWYgKHRva2Vuc1swXSAhPT0gJywnKSB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdG9rZW4gaW4gbWFwIHR5cGU6ICcgKyB0b2tlbnNbMF0pXG4gICAgICAgIHRva2Vucy5zaGlmdCgpXG4gICAgICAgIGZpZWxkLm1hcC50byA9IHRva2Vucy5zaGlmdCgpXG4gICAgICAgIGlmICh0b2tlbnNbMF0gIT09ICc+JykgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHRva2VuIGluIG1hcCB0eXBlOiAnICsgdG9rZW5zWzBdKVxuICAgICAgICB0b2tlbnMuc2hpZnQoKVxuICAgICAgICBmaWVsZC5uYW1lID0gdG9rZW5zLnNoaWZ0KClcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAncmVwZWF0ZWQnOlxuICAgICAgY2FzZSAncmVxdWlyZWQnOlxuICAgICAgY2FzZSAnb3B0aW9uYWwnOlxuICAgICAgICB2YXIgdCA9IHRva2Vucy5zaGlmdCgpXG4gICAgICAgIGZpZWxkLnJlcXVpcmVkID0gdCA9PT0gJ3JlcXVpcmVkJ1xuICAgICAgICBmaWVsZC5yZXBlYXRlZCA9IHQgPT09ICdyZXBlYXRlZCdcbiAgICAgICAgZmllbGQudHlwZSA9IHRva2Vucy5zaGlmdCgpXG4gICAgICAgIGZpZWxkLm5hbWUgPSB0b2tlbnMuc2hpZnQoKVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdbJzpcbiAgICAgICAgZmllbGQub3B0aW9ucyA9IG9uZmllbGRvcHRpb25zKHRva2VucylcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnOyc6XG4gICAgICAgIGlmIChmaWVsZC5uYW1lID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZmllbGQgbmFtZScpXG4gICAgICAgIGlmIChmaWVsZC50eXBlID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdHlwZSBpbiBtZXNzYWdlIGZpZWxkOiAnICsgZmllbGQubmFtZSlcbiAgICAgICAgaWYgKGZpZWxkLnRhZyA9PT0gLTEpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB0YWcgbnVtYmVyIGluIG1lc3NhZ2UgZmllbGQ6ICcgKyBmaWVsZC5uYW1lKVxuICAgICAgICB0b2tlbnMuc2hpZnQoKVxuICAgICAgICByZXR1cm4gZmllbGRcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHRva2VuIGluIG1lc3NhZ2UgZmllbGQ6ICcgKyB0b2tlbnNbMF0pXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdObyA7IGZvdW5kIGZvciBtZXNzYWdlIGZpZWxkJylcbn1cblxudmFyIG9ubWVzc2FnZWJvZHkgPSBmdW5jdGlvbiAodG9rZW5zKSB7XG4gIHZhciBib2R5ID0ge1xuICAgIGVudW1zOiBbXSxcbiAgICBtZXNzYWdlczogW10sXG4gICAgZmllbGRzOiBbXSxcbiAgICBleHRlbmRzOiBbXSxcbiAgICBleHRlbnNpb25zOiBudWxsXG4gIH1cblxuICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgIHN3aXRjaCAodG9rZW5zWzBdKSB7XG4gICAgICBjYXNlICdtYXAnOlxuICAgICAgY2FzZSAncmVwZWF0ZWQnOlxuICAgICAgY2FzZSAnb3B0aW9uYWwnOlxuICAgICAgY2FzZSAncmVxdWlyZWQnOlxuICAgICAgICBib2R5LmZpZWxkcy5wdXNoKG9uZmllbGQodG9rZW5zKSlcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnZW51bSc6XG4gICAgICAgIGJvZHkuZW51bXMucHVzaChvbmVudW0odG9rZW5zKSlcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnbWVzc2FnZSc6XG4gICAgICAgIGJvZHkubWVzc2FnZXMucHVzaChvbm1lc3NhZ2UodG9rZW5zKSlcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnZXh0ZW5zaW9ucyc6XG4gICAgICAgIGJvZHkuZXh0ZW5zaW9ucyA9IG9uZXh0ZW5zaW9ucyh0b2tlbnMpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ29uZW9mJzpcbiAgICAgICAgdG9rZW5zLnNoaWZ0KClcbiAgICAgICAgdmFyIG5hbWUgPSB0b2tlbnMuc2hpZnQoKVxuICAgICAgICBpZiAodG9rZW5zWzBdICE9PSAneycpIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB0b2tlbiBpbiBvbmVvZjogJyArIHRva2Vuc1swXSlcbiAgICAgICAgdG9rZW5zLnNoaWZ0KClcbiAgICAgICAgd2hpbGUgKHRva2Vuc1swXSAhPT0gJ30nKSB7XG4gICAgICAgICAgdG9rZW5zLnVuc2hpZnQoJ29wdGlvbmFsJylcbiAgICAgICAgICB2YXIgZmllbGQgPSBvbmZpZWxkKHRva2VucylcbiAgICAgICAgICBmaWVsZC5vbmVvZiA9IG5hbWVcbiAgICAgICAgICBib2R5LmZpZWxkcy5wdXNoKGZpZWxkKVxuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5zaGlmdCgpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ2V4dGVuZCc6XG4gICAgICAgIGJvZHkuZXh0ZW5kcy5wdXNoKG9uZXh0ZW5kKHRva2VucykpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJzsnOlxuICAgICAgICB0b2tlbnMuc2hpZnQoKVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdyZXNlcnZlZCc6XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICB0b2tlbnMuc2hpZnQoKVxuICAgICAgICB3aGlsZSAodG9rZW5zWzBdICE9PSAnOycpIHtcbiAgICAgICAgICB0b2tlbnMuc2hpZnQoKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIHByb3RvMyBkb2VzIG5vdCByZXF1aXJlIHRoZSB1c2Ugb2Ygb3B0aW9uYWwvcmVxdWlyZWQsIGFzc3VtZWQgYXMgb3B0aW9uYWxcbiAgICAgICAgLy8gXCJzaW5ndWxhcjogYSB3ZWxsLWZvcm1lZCBtZXNzYWdlIGNhbiBoYXZlIHplcm8gb3Igb25lIG9mIHRoaXMgZmllbGQgKGJ1dCBub3QgbW9yZSB0aGFuIG9uZSkuXCJcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL3Byb3RvMyNzcGVjaWZ5aW5nLWZpZWxkLXJ1bGVzXG4gICAgICAgIHRva2Vucy51bnNoaWZ0KCdvcHRpb25hbCcpXG4gICAgICAgIGJvZHkuZmllbGRzLnB1c2gob25maWVsZCh0b2tlbnMpKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBib2R5XG59XG5cbnZhciBvbmV4dGVuZCA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcbiAgdmFyIG91dCA9IHtcbiAgICBuYW1lOiB0b2tlbnNbMV0sXG4gICAgbWVzc2FnZTogb25tZXNzYWdlKHRva2VucylcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbnZhciBvbmV4dGVuc2lvbnMgPSBmdW5jdGlvbiAodG9rZW5zKSB7XG4gIHRva2Vucy5zaGlmdCgpXG4gIHZhciBmcm9tID0gTnVtYmVyKHRva2Vucy5zaGlmdCgpKVxuICBpZiAoaXNOYU4oZnJvbSkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmcm9tIGluIGV4dGVuc2lvbnMgZGVmaW5pdGlvbicpXG4gIGlmICh0b2tlbnMuc2hpZnQoKSAhPT0gJ3RvJykgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQga2V5d29yZCAndG8nIGluIGV4dGVuc2lvbnMgZGVmaW5pdGlvblwiKVxuICB2YXIgdG8gPSB0b2tlbnMuc2hpZnQoKVxuICBpZiAodG8gPT09ICdtYXgnKSB0byA9IE1BWF9SQU5HRVxuICB0byA9IE51bWJlcih0bylcbiAgaWYgKGlzTmFOKHRvKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRvIGluIGV4dGVuc2lvbnMgZGVmaW5pdGlvbicpXG4gIGlmICh0b2tlbnMuc2hpZnQoKSAhPT0gJzsnKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgOyBpbiBleHRlbnNpb25zIGRlZmluaXRpb24nKVxuICByZXR1cm4ge2Zyb206IGZyb20sIHRvOiB0b31cbn1cbnZhciBvbm1lc3NhZ2UgPSBmdW5jdGlvbiAodG9rZW5zKSB7XG4gIHRva2Vucy5zaGlmdCgpXG5cbiAgdmFyIGx2bCA9IDFcbiAgdmFyIGJvZHkgPSBbXVxuICB2YXIgbXNnID0ge1xuICAgIG5hbWU6IHRva2Vucy5zaGlmdCgpLFxuICAgIGVudW1zOiBbXSxcbiAgICBleHRlbmRzOiBbXSxcbiAgICBtZXNzYWdlczogW10sXG4gICAgZmllbGRzOiBbXVxuICB9XG5cbiAgaWYgKHRva2Vuc1swXSAhPT0gJ3snKSB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHsgYnV0IGZvdW5kICcgKyB0b2tlbnNbMF0pXG4gIHRva2Vucy5zaGlmdCgpXG5cbiAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICBpZiAodG9rZW5zWzBdID09PSAneycpIGx2bCsrXG4gICAgZWxzZSBpZiAodG9rZW5zWzBdID09PSAnfScpIGx2bC0tXG5cbiAgICBpZiAoIWx2bCkge1xuICAgICAgdG9rZW5zLnNoaWZ0KClcbiAgICAgIGJvZHkgPSBvbm1lc3NhZ2Vib2R5KGJvZHkpXG4gICAgICBtc2cuZW51bXMgPSBib2R5LmVudW1zXG4gICAgICBtc2cubWVzc2FnZXMgPSBib2R5Lm1lc3NhZ2VzXG4gICAgICBtc2cuZmllbGRzID0gYm9keS5maWVsZHNcbiAgICAgIG1zZy5leHRlbmRzID0gYm9keS5leHRlbmRzXG4gICAgICBtc2cuZXh0ZW5zaW9ucyA9IGJvZHkuZXh0ZW5zaW9uc1xuICAgICAgcmV0dXJuIG1zZ1xuICAgIH1cblxuICAgIGJvZHkucHVzaCh0b2tlbnMuc2hpZnQoKSlcbiAgfVxuXG4gIGlmIChsdmwpIHRocm93IG5ldyBFcnJvcignTm8gY2xvc2luZyB0YWcgZm9yIG1lc3NhZ2UnKVxufVxuXG52YXIgb25wYWNrYWdlbmFtZSA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcbiAgdG9rZW5zLnNoaWZ0KClcbiAgdmFyIG5hbWUgPSB0b2tlbnMuc2hpZnQoKVxuICBpZiAodG9rZW5zWzBdICE9PSAnOycpIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgOyBidXQgZm91bmQgJyArIHRva2Vuc1swXSlcbiAgdG9rZW5zLnNoaWZ0KClcbiAgcmV0dXJuIG5hbWVcbn1cblxudmFyIG9uc3ludGF4dmVyc2lvbiA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcbiAgdG9rZW5zLnNoaWZ0KClcblxuICBpZiAodG9rZW5zWzBdICE9PSAnPScpIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgPSBidXQgZm91bmQgJyArIHRva2Vuc1swXSlcbiAgdG9rZW5zLnNoaWZ0KClcblxuICB2YXIgdmVyc2lvbiA9IHRva2Vucy5zaGlmdCgpXG4gIHN3aXRjaCAodmVyc2lvbikge1xuICAgIGNhc2UgJ1wicHJvdG8yXCInOlxuICAgICAgdmVyc2lvbiA9IDJcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdcInByb3RvM1wiJzpcbiAgICAgIHZlcnNpb24gPSAzXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcHJvdG9idWYgc3ludGF4IHZlcnNpb24gYnV0IGZvdW5kICcgKyB2ZXJzaW9uKVxuICB9XG5cbiAgaWYgKHRva2Vuc1swXSAhPT0gJzsnKSB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIDsgYnV0IGZvdW5kICcgKyB0b2tlbnNbMF0pXG4gIHRva2Vucy5zaGlmdCgpXG5cbiAgcmV0dXJuIHZlcnNpb25cbn1cblxudmFyIG9uZW51bXZhbHVlID0gZnVuY3Rpb24gKHRva2Vucykge1xuICBpZiAodG9rZW5zLmxlbmd0aCA8IDQpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbnVtIHZhbHVlOiAnICsgdG9rZW5zLnNsaWNlKDAsIDMpLmpvaW4oJyAnKSlcbiAgaWYgKHRva2Vuc1sxXSAhPT0gJz0nKSB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkID0gYnV0IGZvdW5kICcgKyB0b2tlbnNbMV0pXG4gIGlmICh0b2tlbnNbM10gIT09ICc7JyAmJiB0b2tlbnNbM10gIT09ICdbJykgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCA7IG9yIFsgYnV0IGZvdW5kICcgKyB0b2tlbnNbMV0pXG5cbiAgdmFyIG5hbWUgPSB0b2tlbnMuc2hpZnQoKVxuICB0b2tlbnMuc2hpZnQoKVxuICB2YXIgdmFsID0ge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIG9wdGlvbnM6IHt9XG4gIH1cbiAgdmFsLnZhbHVlID0gTnVtYmVyKHRva2Vucy5zaGlmdCgpKVxuICBpZiAodG9rZW5zWzBdID09PSAnWycpIHtcbiAgICB2YWwub3B0aW9ucyA9IG9uZmllbGRvcHRpb25zKHRva2VucylcbiAgfVxuICB0b2tlbnMuc2hpZnQoKSAvLyBleHBlY3RpbmcgdGhlIHNlbWljb2xvbiBoZXJlXG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHZhbDogdmFsXG4gIH1cbn1cblxudmFyIG9uZW51bSA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcbiAgdG9rZW5zLnNoaWZ0KClcbiAgdmFyIG9wdGlvbnMgPSB7fVxuICB2YXIgZSA9IHtcbiAgICBuYW1lOiB0b2tlbnMuc2hpZnQoKSxcbiAgICB2YWx1ZXM6IHt9LFxuICAgIG9wdGlvbnM6IHt9XG4gIH1cblxuICBpZiAodG9rZW5zWzBdICE9PSAneycpIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgeyBidXQgZm91bmQgJyArIHRva2Vuc1swXSlcbiAgdG9rZW5zLnNoaWZ0KClcblxuICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgIGlmICh0b2tlbnNbMF0gPT09ICd9Jykge1xuICAgICAgdG9rZW5zLnNoaWZ0KClcbiAgICAgIC8vIHRoZXJlIGdvZXMgb3B0aW9uYWwgc2VtaWNvbG9uIGFmdGVyIHRoZSBlbmNsb3NpbmcgXCJ9XCJcbiAgICAgIGlmICh0b2tlbnNbMF0gPT09ICc7JykgdG9rZW5zLnNoaWZ0KClcbiAgICAgIHJldHVybiBlXG4gICAgfVxuICAgIGlmICh0b2tlbnNbMF0gPT09ICdvcHRpb24nKSB7XG4gICAgICBvcHRpb25zID0gb25vcHRpb24odG9rZW5zKVxuICAgICAgZS5vcHRpb25zW29wdGlvbnMubmFtZV0gPSBvcHRpb25zLnZhbHVlXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICB2YXIgdmFsID0gb25lbnVtdmFsdWUodG9rZW5zKVxuICAgIGUudmFsdWVzW3ZhbC5uYW1lXSA9IHZhbC52YWxcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignTm8gY2xvc2luZyB0YWcgZm9yIGVudW0nKVxufVxuXG52YXIgb25vcHRpb24gPSBmdW5jdGlvbiAodG9rZW5zKSB7XG4gIHZhciBuYW1lID0gbnVsbFxuICB2YXIgdmFsdWUgPSBudWxsXG5cbiAgdmFyIHBhcnNlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHJldHVybiB0cnVlXG4gICAgaWYgKHZhbHVlID09PSAnZmFsc2UnKSByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvXlwiK3xcIiskL2dtLCAnJylcbiAgfVxuXG4gIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgaWYgKHRva2Vuc1swXSA9PT0gJzsnKSB7XG4gICAgICB0b2tlbnMuc2hpZnQoKVxuICAgICAgcmV0dXJuIHtuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWV9XG4gICAgfVxuICAgIHN3aXRjaCAodG9rZW5zWzBdKSB7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICB0b2tlbnMuc2hpZnQoKVxuXG4gICAgICAgIHZhciBoYXNCcmFja2V0ID0gdG9rZW5zWzBdID09PSAnKCdcbiAgICAgICAgaWYgKGhhc0JyYWNrZXQpIHRva2Vucy5zaGlmdCgpXG5cbiAgICAgICAgbmFtZSA9IHRva2Vucy5zaGlmdCgpXG5cbiAgICAgICAgaWYgKGhhc0JyYWNrZXQpIHtcbiAgICAgICAgICBpZiAodG9rZW5zWzBdICE9PSAnKScpIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgKSBidXQgZm91bmQgJyArIHRva2Vuc1swXSlcbiAgICAgICAgICB0b2tlbnMuc2hpZnQoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2Vuc1swXVswXSA9PT0gJy4nKSB7XG4gICAgICAgICAgbmFtZSArPSB0b2tlbnMuc2hpZnQoKVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnPSc6XG4gICAgICAgIHRva2Vucy5zaGlmdCgpXG4gICAgICAgIGlmIChuYW1lID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGtleSBmb3Igb3B0aW9uIHdpdGggdmFsdWU6ICcgKyB0b2tlbnNbMF0pXG4gICAgICAgIHZhbHVlID0gcGFyc2UodG9rZW5zLnNoaWZ0KCkpXG5cbiAgICAgICAgaWYgKG5hbWUgPT09ICdvcHRpbWl6ZV9mb3InICYmICEvXihTUEVFRHxDT0RFX1NJWkV8TElURV9SVU5USU1FKSQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHZhbHVlIGZvciBvcHRpb24gb3B0aW1pemVfZm9yOiAnICsgdmFsdWUpXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICd7Jykge1xuICAgICAgICAgIC8vIG9wdGlvbiBmb28gPSB7YmFyOiBiYXp9XG4gICAgICAgICAgdmFsdWUgPSBvbm9wdGlvbk1hcCh0b2tlbnMpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHRva2VuIGluIG9wdGlvbjogJyArIHRva2Vuc1swXSlcbiAgICB9XG4gIH1cbn1cblxudmFyIG9ub3B0aW9uTWFwID0gZnVuY3Rpb24gKHRva2Vucykge1xuICB2YXIgcGFyc2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09ICd0cnVlJykgcmV0dXJuIHRydWVcbiAgICBpZiAodmFsdWUgPT09ICdmYWxzZScpIHJldHVybiBmYWxzZVxuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9eXCIrfFwiKyQvZ20sICcnKVxuICB9XG5cbiAgdmFyIG1hcCA9IHt9XG5cbiAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICBpZiAodG9rZW5zWzBdID09PSAnfScpIHtcbiAgICAgIHRva2Vucy5zaGlmdCgpXG4gICAgICByZXR1cm4gbWFwXG4gICAgfVxuXG4gICAgdmFyIGhhc0JyYWNrZXQgPSB0b2tlbnNbMF0gPT09ICcoJ1xuICAgIGlmIChoYXNCcmFja2V0KSB0b2tlbnMuc2hpZnQoKVxuXG4gICAgdmFyIGtleSA9IHRva2Vucy5zaGlmdCgpXG4gICAgaWYgKGhhc0JyYWNrZXQpIHtcbiAgICAgIGlmICh0b2tlbnNbMF0gIT09ICcpJykgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCApIGJ1dCBmb3VuZCAnICsgdG9rZW5zWzBdKVxuICAgICAgdG9rZW5zLnNoaWZ0KClcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBudWxsXG5cbiAgICBzd2l0Y2ggKHRva2Vuc1swXSkge1xuICAgICAgY2FzZSAnOic6XG4gICAgICAgIGlmIChtYXBba2V5XSAhPT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoJ0R1cGxpY2F0ZSBvcHRpb24gbWFwIGtleSAnICsga2V5KVxuXG4gICAgICAgIHRva2Vucy5zaGlmdCgpXG5cbiAgICAgICAgdmFsdWUgPSBwYXJzZSh0b2tlbnMuc2hpZnQoKSlcblxuICAgICAgICBpZiAodmFsdWUgPT09ICd7Jykge1xuICAgICAgICAgIC8vIG9wdGlvbiBmb28gPSB7YmFyOiBiYXp9XG4gICAgICAgICAgdmFsdWUgPSBvbm9wdGlvbk1hcCh0b2tlbnMpXG4gICAgICAgIH1cblxuICAgICAgICBtYXBba2V5XSA9IHZhbHVlXG5cbiAgICAgICAgaWYgKHRva2Vuc1swXSA9PT0gJzsnKSB7XG4gICAgICAgICAgdG9rZW5zLnNoaWZ0KClcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICd7JzpcbiAgICAgICAgdG9rZW5zLnNoaWZ0KClcbiAgICAgICAgdmFsdWUgPSBvbm9wdGlvbk1hcCh0b2tlbnMpXG5cbiAgICAgICAgaWYgKG1hcFtrZXldID09PSB1bmRlZmluZWQpIG1hcFtrZXldID0gW11cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1hcFtrZXldKSkgdGhyb3cgbmV3IEVycm9yKCdEdXBsaWNhdGUgb3B0aW9uIG1hcCBrZXkgJyArIGtleSlcblxuICAgICAgICBtYXBba2V5XS5wdXNoKHZhbHVlKVxuICAgICAgICBicmVha1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdG9rZW4gaW4gb3B0aW9uIG1hcDogJyArIHRva2Vuc1swXSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNsb3NpbmcgdGFnIGZvciBvcHRpb24gbWFwJylcbn1cblxudmFyIG9uaW1wb3J0ID0gZnVuY3Rpb24gKHRva2Vucykge1xuICB0b2tlbnMuc2hpZnQoKVxuICB2YXIgZmlsZSA9IHRva2Vucy5zaGlmdCgpLnJlcGxhY2UoL15cIit8XCIrJC9nbSwgJycpXG5cbiAgaWYgKHRva2Vuc1swXSAhPT0gJzsnKSB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdG9rZW46ICcgKyB0b2tlbnNbMF0gKyAnLiBFeHBlY3RlZCBcIjtcIicpXG5cbiAgdG9rZW5zLnNoaWZ0KClcbiAgcmV0dXJuIGZpbGVcbn1cblxudmFyIG9uc2VydmljZSA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcbiAgdG9rZW5zLnNoaWZ0KClcblxuICB2YXIgc2VydmljZSA9IHtcbiAgICBuYW1lOiB0b2tlbnMuc2hpZnQoKSxcbiAgICBtZXRob2RzOiBbXSxcbiAgICBvcHRpb25zOiB7fVxuICB9XG5cbiAgaWYgKHRva2Vuc1swXSAhPT0gJ3snKSB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHsgYnV0IGZvdW5kICcgKyB0b2tlbnNbMF0pXG4gIHRva2Vucy5zaGlmdCgpXG5cbiAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICBpZiAodG9rZW5zWzBdID09PSAnfScpIHtcbiAgICAgIHRva2Vucy5zaGlmdCgpXG4gICAgICAvLyB0aGVyZSBnb2VzIG9wdGlvbmFsIHNlbWljb2xvbiBhZnRlciB0aGUgZW5jbG9zaW5nIFwifVwiXG4gICAgICBpZiAodG9rZW5zWzBdID09PSAnOycpIHRva2Vucy5zaGlmdCgpXG4gICAgICByZXR1cm4gc2VydmljZVxuICAgIH1cblxuICAgIHN3aXRjaCAodG9rZW5zWzBdKSB7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICB2YXIgb3B0ID0gb25vcHRpb24odG9rZW5zKVxuICAgICAgICBpZiAoc2VydmljZS5vcHRpb25zW29wdC5uYW1lXSAhPT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoJ0R1cGxpY2F0ZSBvcHRpb24gJyArIG9wdC5uYW1lKVxuICAgICAgICBzZXJ2aWNlLm9wdGlvbnNbb3B0Lm5hbWVdID0gb3B0LnZhbHVlXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdycGMnOlxuICAgICAgICBzZXJ2aWNlLm1ldGhvZHMucHVzaChvbnJwYyh0b2tlbnMpKVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHRva2VuIGluIHNlcnZpY2U6ICcgKyB0b2tlbnNbMF0pXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdObyBjbG9zaW5nIHRhZyBmb3Igc2VydmljZScpXG59XG5cbnZhciBvbnJwYyA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcbiAgdG9rZW5zLnNoaWZ0KClcblxuICB2YXIgcnBjID0ge1xuICAgIG5hbWU6IHRva2Vucy5zaGlmdCgpLFxuICAgIGlucHV0X3R5cGU6IG51bGwsXG4gICAgb3V0cHV0X3R5cGU6IG51bGwsXG4gICAgY2xpZW50X3N0cmVhbWluZzogZmFsc2UsXG4gICAgc2VydmVyX3N0cmVhbWluZzogZmFsc2UsXG4gICAgb3B0aW9uczoge31cbiAgfVxuXG4gIGlmICh0b2tlbnNbMF0gIT09ICcoJykgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCAoIGJ1dCBmb3VuZCAnICsgdG9rZW5zWzBdKVxuICB0b2tlbnMuc2hpZnQoKVxuXG4gIGlmICh0b2tlbnNbMF0gPT09ICdzdHJlYW0nKSB7XG4gICAgdG9rZW5zLnNoaWZ0KClcbiAgICBycGMuY2xpZW50X3N0cmVhbWluZyA9IHRydWVcbiAgfVxuXG4gIHJwYy5pbnB1dF90eXBlID0gdG9rZW5zLnNoaWZ0KClcblxuICBpZiAodG9rZW5zWzBdICE9PSAnKScpIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgKSBidXQgZm91bmQgJyArIHRva2Vuc1swXSlcbiAgdG9rZW5zLnNoaWZ0KClcblxuICBpZiAodG9rZW5zWzBdICE9PSAncmV0dXJucycpIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcmV0dXJucyBidXQgZm91bmQgJyArIHRva2Vuc1swXSlcbiAgdG9rZW5zLnNoaWZ0KClcblxuICBpZiAodG9rZW5zWzBdICE9PSAnKCcpIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgKCBidXQgZm91bmQgJyArIHRva2Vuc1swXSlcbiAgdG9rZW5zLnNoaWZ0KClcblxuICBpZiAodG9rZW5zWzBdID09PSAnc3RyZWFtJykge1xuICAgIHRva2Vucy5zaGlmdCgpXG4gICAgcnBjLnNlcnZlcl9zdHJlYW1pbmcgPSB0cnVlXG4gIH1cblxuICBycGMub3V0cHV0X3R5cGUgPSB0b2tlbnMuc2hpZnQoKVxuXG4gIGlmICh0b2tlbnNbMF0gIT09ICcpJykgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCApIGJ1dCBmb3VuZCAnICsgdG9rZW5zWzBdKVxuICB0b2tlbnMuc2hpZnQoKVxuXG4gIGlmICh0b2tlbnNbMF0gPT09ICc7Jykge1xuICAgIHRva2Vucy5zaGlmdCgpXG4gICAgcmV0dXJuIHJwY1xuICB9XG5cbiAgaWYgKHRva2Vuc1swXSAhPT0gJ3snKSB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHsgYnV0IGZvdW5kICcgKyB0b2tlbnNbMF0pXG4gIHRva2Vucy5zaGlmdCgpXG5cbiAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICBpZiAodG9rZW5zWzBdID09PSAnfScpIHtcbiAgICAgIHRva2Vucy5zaGlmdCgpXG4gICAgICAvLyB0aGVyZSBnb2VzIG9wdGlvbmFsIHNlbWljb2xvbiBhZnRlciB0aGUgZW5jbG9zaW5nIFwifVwiXG4gICAgICBpZiAodG9rZW5zWzBdID09PSAnOycpIHRva2Vucy5zaGlmdCgpXG4gICAgICByZXR1cm4gcnBjXG4gICAgfVxuXG4gICAgaWYgKHRva2Vuc1swXSA9PT0gJ29wdGlvbicpIHtcbiAgICAgIHZhciBvcHQgPSBvbm9wdGlvbih0b2tlbnMpXG4gICAgICBpZiAocnBjLm9wdGlvbnNbb3B0Lm5hbWVdICE9PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignRHVwbGljYXRlIG9wdGlvbiAnICsgb3B0Lm5hbWUpXG4gICAgICBycGMub3B0aW9uc1tvcHQubmFtZV0gPSBvcHQudmFsdWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHRva2VuIGluIHJwYyBvcHRpb25zOiAnICsgdG9rZW5zWzBdKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignTm8gY2xvc2luZyB0YWcgZm9yIHJwYycpXG59XG5cbnZhciBwYXJzZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgdmFyIHRva2VucyA9IHRva2VuaXplKGJ1Zi50b1N0cmluZygpKVxuICAvLyBjaGVjayBmb3IgaXNvbGF0ZWQgc3RyaW5ncyBpbiB0b2tlbnMgYnkgbG9va2luZyBmb3Igb3BlbmluZyBxdW90ZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICgvXihcInwnKShbXidcIl0qKSQvLnRlc3QodG9rZW5zW2ldKSkge1xuICAgICAgdmFyIGpcbiAgICAgIGlmICh0b2tlbnNbaV0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGogPSBpICsgMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaiA9IGlcbiAgICAgIH1cbiAgICAgIC8vIGxvb2sgYWhlYWQgZm9yIHRoZSBjbG9zaW5nIHF1b3RlIGFuZCBjb2xsYXBzZSBhbGxcbiAgICAgIC8vIGluLWJldHdlZW4gdG9rZW5zIGludG8gYSBzaW5nbGUgdG9rZW5cbiAgICAgIGZvciAoajsgaiA8IHRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoL14oW14nXCJdKikoXCJ8JykkLy50ZXN0KHRva2Vuc1tqXSkpIHtcbiAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuc2xpY2UoMCwgaSkuY29uY2F0KHRva2Vucy5zbGljZShpLCBqICsgMSkuam9pbignJykpLmNvbmNhdCh0b2tlbnMuc2xpY2UoaiArIDEpKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHNjaGVtYSA9IHtcbiAgICBzeW50YXg6IDMsXG4gICAgcGFja2FnZTogbnVsbCxcbiAgICBpbXBvcnRzOiBbXSxcbiAgICBlbnVtczogW10sXG4gICAgbWVzc2FnZXM6IFtdLFxuICAgIG9wdGlvbnM6IHt9LFxuICAgIGV4dGVuZHM6IFtdXG4gIH1cblxuICB2YXIgZmlyc3RsaW5lID0gdHJ1ZVxuXG4gIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgc3dpdGNoICh0b2tlbnNbMF0pIHtcbiAgICAgIGNhc2UgJ3BhY2thZ2UnOlxuICAgICAgICBzY2hlbWEucGFja2FnZSA9IG9ucGFja2FnZW5hbWUodG9rZW5zKVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdzeW50YXgnOlxuICAgICAgICBpZiAoIWZpcnN0bGluZSkgdGhyb3cgbmV3IEVycm9yKCdQcm90b2J1ZiBzeW50YXggdmVyc2lvbiBzaG91bGQgYmUgZmlyc3QgdGhpbmcgaW4gZmlsZScpXG4gICAgICAgIHNjaGVtYS5zeW50YXggPSBvbnN5bnRheHZlcnNpb24odG9rZW5zKVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdtZXNzYWdlJzpcbiAgICAgICAgc2NoZW1hLm1lc3NhZ2VzLnB1c2gob25tZXNzYWdlKHRva2VucykpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ2VudW0nOlxuICAgICAgICBzY2hlbWEuZW51bXMucHVzaChvbmVudW0odG9rZW5zKSlcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgdmFyIG9wdCA9IG9ub3B0aW9uKHRva2VucylcbiAgICAgICAgaWYgKHNjaGVtYS5vcHRpb25zW29wdC5uYW1lXSkgdGhyb3cgbmV3IEVycm9yKCdEdXBsaWNhdGUgb3B0aW9uICcgKyBvcHQubmFtZSlcbiAgICAgICAgc2NoZW1hLm9wdGlvbnNbb3B0Lm5hbWVdID0gb3B0LnZhbHVlXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ2ltcG9ydCc6XG4gICAgICAgIHNjaGVtYS5pbXBvcnRzLnB1c2gob25pbXBvcnQodG9rZW5zKSlcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnZXh0ZW5kJzpcbiAgICAgICAgc2NoZW1hLmV4dGVuZHMucHVzaChvbmV4dGVuZCh0b2tlbnMpKVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdzZXJ2aWNlJzpcbiAgICAgICAgaWYgKCFzY2hlbWEuc2VydmljZXMpIHNjaGVtYS5zZXJ2aWNlcyA9IFtdXG4gICAgICAgIHNjaGVtYS5zZXJ2aWNlcy5wdXNoKG9uc2VydmljZSh0b2tlbnMpKVxuICAgICAgICBicmVha1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdG9rZW46ICcgKyB0b2tlbnNbMF0pXG4gICAgfVxuICAgIGZpcnN0bGluZSA9IGZhbHNlXG4gIH1cblxuICAvLyBub3cgaXRlcmF0ZSBvdmVyIG1lc3NhZ2VzIGFuZCBwcm9wYWdhdGUgZXh0ZW5kc1xuICBzY2hlbWEuZXh0ZW5kcy5mb3JFYWNoKGZ1bmN0aW9uIChleHQpIHtcbiAgICBzY2hlbWEubWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7XG4gICAgICBpZiAobXNnLm5hbWUgPT09IGV4dC5uYW1lKSB7XG4gICAgICAgIGV4dC5tZXNzYWdlLmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgIGlmICghbXNnLmV4dGVuc2lvbnMgfHwgZmllbGQudGFnIDwgbXNnLmV4dGVuc2lvbnMuZnJvbSB8fCBmaWVsZC50YWcgPiBtc2cuZXh0ZW5zaW9ucy50bykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZy5uYW1lICsgJyBkb2VzIG5vdCBkZWNsYXJlICcgKyBmaWVsZC50YWcgKyAnIGFzIGFuIGV4dGVuc2lvbiBudW1iZXInKVxuICAgICAgICAgIH1cbiAgICAgICAgICBtc2cuZmllbGRzLnB1c2goZmllbGQpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfSlcblxuICBzY2hlbWEubWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7XG4gICAgbXNnLmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgdmFyIGZpZWxkU3BsaXRcbiAgICAgIHZhciBtZXNzYWdlTmFtZVxuICAgICAgdmFyIG5lc3RlZEVudW1OYW1lXG4gICAgICB2YXIgbWVzc2FnZVxuXG4gICAgICBmdW5jdGlvbiBlbnVtTmFtZUlzRmllbGRUeXBlIChlbikge1xuICAgICAgICByZXR1cm4gZW4ubmFtZSA9PT0gZmllbGQudHlwZVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlbnVtTmFtZUlzTmVzdGVkRW51bU5hbWUgKGVuKSB7XG4gICAgICAgIHJldHVybiBlbi5uYW1lID09PSBuZXN0ZWRFbnVtTmFtZVxuICAgICAgfVxuXG4gICAgICBpZiAoZmllbGQub3B0aW9ucyAmJiBmaWVsZC5vcHRpb25zLnBhY2tlZCA9PT0gJ3RydWUnKSB7XG4gICAgICAgIGlmIChQQUNLQUJMRV9UWVBFUy5pbmRleE9mKGZpZWxkLnR5cGUpID09PSAtMSkge1xuICAgICAgICAgIC8vIGxldCdzIHNlZSBpZiBpdCdzIGFuIGVudW1cbiAgICAgICAgICBpZiAoZmllbGQudHlwZS5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAobXNnLmVudW1zICYmIG1zZy5lbnVtcy5zb21lKGVudW1OYW1lSXNGaWVsZFR5cGUpKSB7XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWVsZFNwbGl0ID0gZmllbGQudHlwZS5zcGxpdCgnLicpXG4gICAgICAgICAgICBpZiAoZmllbGRTcGxpdC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignd2hhdCBpcyB0aGlzPycpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lc3NhZ2VOYW1lID0gZmllbGRTcGxpdFswXVxuICAgICAgICAgICAgbmVzdGVkRW51bU5hbWUgPSBmaWVsZFNwbGl0WzFdXG5cbiAgICAgICAgICAgIHNjaGVtYS5tZXNzYWdlcy5zb21lKGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgICAgaWYgKG1zZy5uYW1lID09PSBtZXNzYWdlTmFtZSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtc2dcbiAgICAgICAgICAgICAgICByZXR1cm4gbXNnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIGlmIChtZXNzYWdlICYmIG1lc3NhZ2UuZW51bXMgJiYgbWVzc2FnZS5lbnVtcy5zb21lKGVudW1OYW1lSXNOZXN0ZWRFbnVtTmFtZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0ZpZWxkcyBvZiB0eXBlICcgKyBmaWVsZC50eXBlICsgJyBjYW5ub3QgYmUgZGVjbGFyZWQgW3BhY2tlZD10cnVlXS4gJyArXG4gICAgICAgICAgICAnT25seSByZXBlYXRlZCBmaWVsZHMgb2YgcHJpbWl0aXZlIG51bWVyaWMgdHlwZXMgKHR5cGVzIHdoaWNoIHVzZSAnICtcbiAgICAgICAgICAgICd0aGUgdmFyaW50LCAzMi1iaXQsIG9yIDY0LWJpdCB3aXJlIHR5cGVzKSBjYW4gYmUgZGVjbGFyZWQgXCJwYWNrZWRcIi4gJyArXG4gICAgICAgICAgICAnU2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9lbmNvZGluZyNvcHRpb25hbCdcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9KVxuXG4gIHJldHVybiBzY2hlbWFcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVxuIiwiLyogZXNsaW50IG1heC1kZXB0aDogMSAqL1xuJ3VzZSBzdHJpY3QnXG5cbnZhciB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL3V0aWxzJykuZGVmaW5lZFxuXG5mdW5jdGlvbiBjb21waWxlRGVjb2RlIChtLCByZXNvbHZlLCBlbmMpIHtcbiAgdmFyIHJlcXVpcmVkRmllbGRzID0gW11cbiAgdmFyIGZpZWxkcyA9IHt9XG4gIHZhciBvbmVvZkZpZWxkcyA9IFtdXG4gIHZhciB2YWxzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVuYy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmaWVsZCA9IG0uZmllbGRzW2ldXG5cbiAgICBmaWVsZHNbZmllbGQudGFnXSA9IGlcblxuICAgIHZhciBkZWYgPSBmaWVsZC5vcHRpb25zICYmIGZpZWxkLm9wdGlvbnMuZGVmYXVsdFxuICAgIHZhciByZXNvbHZlZCA9IHJlc29sdmUoZmllbGQudHlwZSwgbS5pZCwgZmFsc2UpXG4gICAgdmFsc1tpXSA9IFtkZWYsIHJlc29sdmVkICYmIHJlc29sdmVkLnZhbHVlc11cblxuICAgIG0uZmllbGRzW2ldLnBhY2tlZCA9IGZpZWxkLnJlcGVhdGVkICYmIGZpZWxkLm9wdGlvbnMgJiYgZmllbGQub3B0aW9ucy5wYWNrZWQgJiYgZmllbGQub3B0aW9ucy5wYWNrZWQgIT09ICdmYWxzZSdcblxuICAgIGlmIChmaWVsZC5yZXF1aXJlZCkge1xuICAgICAgcmVxdWlyZWRGaWVsZHMucHVzaChmaWVsZC5uYW1lKVxuICAgIH1cblxuICAgIGlmIChmaWVsZC5vbmVvZikge1xuICAgICAgb25lb2ZGaWVsZHMucHVzaChmaWVsZC5uYW1lKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZUZpZWxkIChlLCBmaWVsZCwgb2JqLCBidWYsIG9mZnNldCwgaSkge1xuICAgIHZhciBuYW1lID0gZmllbGQubmFtZVxuXG4gICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAvLyBjbGVhciBhbHJlYWR5IGRlZmluZWQgb25lb2YgZmllbGRzXG4gICAgICB2YXIgcHJvcHMgPSBPYmplY3Qua2V5cyhvYmopXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChvbmVvZkZpZWxkcy5pbmRleE9mKHByb3BzW2pdKSA+IC0xKSB7XG4gICAgICAgICAgZGVsZXRlIG9ialtwcm9wc1tqXV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlLm1lc3NhZ2UpIHtcbiAgICAgIHZhciBsZW4gPSB2YXJpbnQuZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcblxuICAgICAgdmFyIGRlY29kZWQgPSBlLmRlY29kZShidWYsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKVxuXG4gICAgICBpZiAoZmllbGQubWFwKSB7XG4gICAgICAgIG9ialtuYW1lXSA9IG9ialtuYW1lXSB8fCB7fVxuICAgICAgICBvYmpbbmFtZV1bZGVjb2RlZC5rZXldID0gZGVjb2RlZC52YWx1ZVxuICAgICAgfSBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICBvYmpbbmFtZV0gPSBvYmpbbmFtZV0gfHwgW11cbiAgICAgICAgb2JqW25hbWVdLnB1c2goZGVjb2RlZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtuYW1lXSA9IGRlY29kZWRcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XG4gICAgICAgIG9ialtuYW1lXSA9IG9ialtuYW1lXSB8fCBbXVxuICAgICAgICBvYmpbbmFtZV0ucHVzaChlLmRlY29kZShidWYsIG9mZnNldCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpbbmFtZV0gPSBlLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvZmZzZXQgKz0gZS5kZWNvZGUuYnl0ZXNcbiAgICByZXR1cm4gb2Zmc2V0XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gZGVjb2RlIChidWYsIG9mZnNldCwgZW5kKSB7XG4gICAgaWYgKG9mZnNldCA9PSBudWxsKSB7XG4gICAgICBvZmZzZXQgPSAwXG4gICAgfVxuXG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICBlbmQgPSBidWYubGVuZ3RoXG4gICAgfVxuXG4gICAgaWYgKCEoZW5kIDw9IGJ1Zi5sZW5ndGggJiYgb2Zmc2V0IDw9IGJ1Zi5sZW5ndGgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWQnKVxuICAgIH1cblxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICB2YXIgb2JqID0ge31cbiAgICB2YXIgZmllbGRcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZW5kIDw9IG9mZnNldCkge1xuICAgICAgICAvLyBmaW5pc2hlZFxuXG4gICAgICAgIC8vIGNoZWNrIHJlcXVpcmVkIG1ldGhvZHNcbiAgICAgICAgdmFyIG5hbWUgPSAnJ1xuICAgICAgICB2YXIgaiA9IDBcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHJlcXVpcmVkRmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbmFtZSA9IHJlcXVpcmVkRmllbGRzW2pdXG4gICAgICAgICAgaWYgKCFkZWZpbmVkKG9ialtuYW1lXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZCwgbWlzc2luZyByZXF1aXJlZCBmaWVsZDogJyArIG5hbWUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlsbCBvdXQgbWlzc2luZyBkZWZhdWx0c1xuICAgICAgICB2YXIgdmFsXG4gICAgICAgIHZhciBkZWZcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGVuYy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGZpZWxkID0gbS5maWVsZHNbal1cbiAgICAgICAgICBkZWYgPSB2YWxzW2pdWzBdXG4gICAgICAgICAgdmFsID0gdmFsc1tqXVsxXVxuICAgICAgICAgIG5hbWUgPSBmaWVsZC5uYW1lXG5cbiAgICAgICAgICBpZiAoZGVmaW5lZChvYmpbbmFtZV0pKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkb25lID0gZmFsc2VcbiAgICAgICAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IE9iamVjdC5rZXlzKG9iailcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcHJvcHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgaWYgKG9uZW9mRmllbGRzLmluZGV4T2YocHJvcHNba10pID4gLTEpIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsKSB7IC8vIGlzIGVudW1cbiAgICAgICAgICAgIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICBvYmpbbmFtZV0gPSBbXVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVmID0gKGRlZiAmJiB2YWxbZGVmXSkgPyB2YWxbZGVmXS52YWx1ZSA6IHZhbFtPYmplY3Qua2V5cyh2YWwpWzBdXS52YWx1ZVxuICAgICAgICAgICAgICBvYmpbbmFtZV0gPSBwYXJzZUludChkZWYgfHwgMCwgMTApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtuYW1lXSA9IGRlZmF1bHRWYWx1ZShmaWVsZCwgZGVmKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgICAgICByZXR1cm4gb2JqXG4gICAgICB9XG5cbiAgICAgIHZhciBwcmVmaXggPSB2YXJpbnQuZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcbiAgICAgIHZhciB0YWcgPSBwcmVmaXggPj4gM1xuXG4gICAgICB2YXIgaSA9IGZpZWxkc1t0YWddXG5cbiAgICAgIGlmIChpID09IG51bGwpIHtcbiAgICAgICAgb2Zmc2V0ID0gc2tpcChwcmVmaXggJiA3LCBidWYsIG9mZnNldClcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgdmFyIGUgPSBlbmNbaV1cbiAgICAgIGZpZWxkID0gbS5maWVsZHNbaV1cblxuICAgICAgaWYgKGZpZWxkLnBhY2tlZCkge1xuICAgICAgICB2YXIgcGFja2VkRW5kID0gdmFyaW50LmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcbiAgICAgICAgcGFja2VkRW5kICs9IG9mZnNldFxuXG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBwYWNrZWRFbmQpIHtcbiAgICAgICAgICBvZmZzZXQgPSBkZWNvZGVGaWVsZChlLCBmaWVsZCwgb2JqLCBidWYsIG9mZnNldCwgaSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gZGVjb2RlRmllbGQoZSwgZmllbGQsIG9iaiwgYnVmLCBvZmZzZXQsIGkpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBza2lwID0gZnVuY3Rpb24gKHR5cGUsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgMDpcbiAgICAgIHZhcmludC5kZWNvZGUoYnVmZmVyLCBvZmZzZXQpXG4gICAgICByZXR1cm4gb2Zmc2V0ICsgdmFyaW50LmRlY29kZS5ieXRlc1xuXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIG9mZnNldCArIDhcblxuICAgIGNhc2UgMjpcbiAgICAgIHZhciBsZW4gPSB2YXJpbnQuZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0KVxuICAgICAgcmV0dXJuIG9mZnNldCArIHZhcmludC5kZWNvZGUuYnl0ZXMgKyBsZW5cblxuICAgIGNhc2UgMzpcbiAgICBjYXNlIDQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dyb3VwcyBhcmUgbm90IHN1cHBvcnRlZCcpXG5cbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgNFxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gd2lyZSB0eXBlOiAnICsgdHlwZSlcbiAgfVxufVxuXG52YXIgZGVmYXVsdFZhbHVlID0gZnVuY3Rpb24gKGYsIGRlZikge1xuICBpZiAoZi5tYXApIHJldHVybiB7fVxuICBpZiAoZi5yZXBlYXRlZCkgcmV0dXJuIFtdXG5cbiAgc3dpdGNoIChmLnR5cGUpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIGRlZiAhPSBudWxsID8gZGVmIDogJydcblxuICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgcmV0dXJuIGRlZiA9PT0gJ3RydWUnXG5cbiAgICBjYXNlICdmbG9hdCc6XG4gICAgY2FzZSAnZG91YmxlJzpcbiAgICBjYXNlICdzZml4ZWQzMic6XG4gICAgY2FzZSAnZml4ZWQzMic6XG4gICAgY2FzZSAndmFyaW50JzpcbiAgICBjYXNlICdlbnVtJzpcbiAgICBjYXNlICd1aW50NjQnOlxuICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgY2FzZSAnaW50NjQnOlxuICAgIGNhc2UgJ2ludDMyJzpcbiAgICBjYXNlICdzaW50NjQnOlxuICAgIGNhc2UgJ3NpbnQzMic6XG4gICAgICByZXR1cm4gcGFyc2VJbnQoZGVmIHx8IDAsIDEwKVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlRGVjb2RlXG4iLCIndXNlIHN0cmljdCdcblxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL3V0aWxzJykuZGVmaW5lZFxudmFyIHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG5cbmZ1bmN0aW9uIGNvbXBpbGVFbmNvZGUgKG0sIHJlc29sdmUsIGVuYywgb25lb2ZzLCBlbmNvZGluZ0xlbmd0aCkge1xuICB2YXIgb25lb2ZzS2V5cyA9IE9iamVjdC5rZXlzKG9uZW9mcylcbiAgdmFyIGVuY0xlbmd0aCA9IGVuYy5sZW5ndGhcbiAgdmFyIGludHMgPSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY0xlbmd0aDsgaSsrKSB7XG4gICAgaW50c1tpXSA9IHtcbiAgICAgIHA6IHZhcmludC5lbmNvZGUobS5maWVsZHNbaV0udGFnIDw8IDMgfCAyKSxcbiAgICAgIGg6IHZhcmludC5lbmNvZGUobS5maWVsZHNbaV0udGFnIDw8IDMgfCBlbmNbaV0udHlwZSlcbiAgICB9XG5cbiAgICB2YXIgZmllbGQgPSBtLmZpZWxkc1tpXVxuICAgIG0uZmllbGRzW2ldLnBhY2tlZCA9IGZpZWxkLnJlcGVhdGVkICYmIGZpZWxkLm9wdGlvbnMgJiYgZmllbGQub3B0aW9ucy5wYWNrZWQgJiYgZmllbGQub3B0aW9ucy5wYWNrZWQgIT09ICdmYWxzZSdcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZUZpZWxkIChidWYsIG9mZnNldCwgaCwgZSwgcGFja2VkLCBpbm5lclZhbCkge1xuICAgIHZhciBqID0gMFxuICAgIGlmICghcGFja2VkKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKykge1xuICAgICAgICBidWZbb2Zmc2V0KytdID0gaFtqXVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlLm1lc3NhZ2UpIHtcbiAgICAgIHZhcmludC5lbmNvZGUoZS5lbmNvZGluZ0xlbmd0aChpbm5lclZhbCksIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IHZhcmludC5lbmNvZGUuYnl0ZXNcbiAgICB9XG5cbiAgICBlLmVuY29kZShpbm5lclZhbCwgYnVmLCBvZmZzZXQpXG4gICAgcmV0dXJuIG9mZnNldCArIGUuZW5jb2RlLmJ5dGVzXG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gZW5jb2RlIChvYmosIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA9PSBudWxsKSB7XG4gICAgICBvZmZzZXQgPSAwXG4gICAgfVxuICAgIGlmIChidWYgPT0gbnVsbCkge1xuICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuY29kaW5nTGVuZ3RoKG9iaikpXG4gICAgfVxuXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIHZhciBvYmpLZXlzID0gT2JqZWN0LmtleXMob2JqKVxuICAgIHZhciBpID0gMFxuXG4gICAgLy8gb25lb2YgY2hlY2tzXG5cbiAgICB2YXIgbWF0Y2ggPSBmYWxzZVxuICAgIGZvciAoaSA9IDA7IGkgPCBvbmVvZnNLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IG9uZW9mc0tleXNbaV1cbiAgICAgIHZhciBwcm9wID0gb25lb2ZzW2ldXG4gICAgICBpZiAob2JqS2V5cy5pbmRleE9mKHByb3ApID4gLTEpIHtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmx5IG9uZSBvZiB0aGUgcHJvcGVydGllcyBkZWZpbmVkIGluIG9uZW9mICcgKyBuYW1lICsgJyBjYW4gYmUgc2V0JylcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdGNoID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmNMZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGUgPSBlbmNbaV1cbiAgICAgIHZhciBmaWVsZCA9IG0uZmllbGRzW2ldIC8vIHdhcyBmXG4gICAgICB2YXIgdmFsID0gb2JqW2ZpZWxkLm5hbWVdXG4gICAgICB2YXIgaiA9IDBcblxuICAgICAgaWYgKCFkZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgaWYgKGZpZWxkLnJlcXVpcmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZpZWxkLm5hbWUgKyAnIGlzIHJlcXVpcmVkJylcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgdmFyIHAgPSBpbnRzW2ldLnBcbiAgICAgIHZhciBoID0gaW50c1tpXS5oXG5cbiAgICAgIHZhciBwYWNrZWQgPSBmaWVsZC5wYWNrZWRcblxuICAgICAgaWYgKGZpZWxkLm1hcCkge1xuICAgICAgICB2YXIgdG1wID0gT2JqZWN0LmtleXModmFsKVxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgdG1wLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdG1wW2pdID0ge1xuICAgICAgICAgICAga2V5OiB0bXBbal0sXG4gICAgICAgICAgICB2YWx1ZTogdmFsW3RtcFtqXV1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFsID0gdG1wXG4gICAgICB9XG5cbiAgICAgIGlmIChwYWNrZWQpIHtcbiAgICAgICAgdmFyIHBhY2tlZExlbiA9IDBcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHZhbC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmICghZGVmaW5lZCh2YWxbal0pKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhY2tlZExlbiArPSBlLmVuY29kaW5nTGVuZ3RoKHZhbFtqXSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYWNrZWRMZW4pIHtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgYnVmW29mZnNldCsrXSA9IHBbal1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyaW50LmVuY29kZShwYWNrZWRMZW4sIGJ1Ziwgb2Zmc2V0KVxuICAgICAgICAgIG9mZnNldCArPSB2YXJpbnQuZW5jb2RlLmJ5dGVzXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XG4gICAgICAgIHZhciBpbm5lclZhbFxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgdmFsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaW5uZXJWYWwgPSB2YWxbal1cbiAgICAgICAgICBpZiAoIWRlZmluZWQoaW5uZXJWYWwpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBvZmZzZXQgPSBlbmNvZGVGaWVsZChidWYsIG9mZnNldCwgaCwgZSwgcGFja2VkLCBpbm5lclZhbClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gZW5jb2RlRmllbGQoYnVmLCBvZmZzZXQsIGgsIGUsIHBhY2tlZCwgdmFsKVxuICAgICAgfVxuICAgIH1cblxuICAgIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgIHJldHVybiBidWZcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBpbGVFbmNvZGVcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vdXRpbHMnKS5kZWZpbmVkXG52YXIgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcblxuZnVuY3Rpb24gY29tcGlsZUVuY29kaW5nTGVuZ3RoIChtLCBlbmMsIG9uZW9mcykge1xuICB2YXIgb25lb2ZzS2V5cyA9IE9iamVjdC5rZXlzKG9uZW9mcylcbiAgdmFyIGVuY0xlbmd0aCA9IGVuYy5sZW5ndGhcblxuICB2YXIgaGxzID0gbmV3IEFycmF5KGVuY0xlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG0uZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaGxzW2ldID0gdmFyaW50LmVuY29kaW5nTGVuZ3RoKG0uZmllbGRzW2ldLnRhZyA8PCAzIHwgZW5jW2ldLnR5cGUpXG5cbiAgICB2YXIgZmllbGQgPSBtLmZpZWxkc1tpXVxuICAgIG0uZmllbGRzW2ldLnBhY2tlZCA9IGZpZWxkLnJlcGVhdGVkICYmIGZpZWxkLm9wdGlvbnMgJiYgZmllbGQub3B0aW9ucy5wYWNrZWQgJiYgZmllbGQub3B0aW9ucy5wYWNrZWQgIT09ICdmYWxzZSdcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAob2JqKSB7XG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB2YXIgaSA9IDBcbiAgICB2YXIgaiA9IDBcblxuICAgIGZvciAoaSA9IDA7IGkgPCBvbmVvZnNLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IG9uZW9mc0tleXNbaV1cbiAgICAgIHZhciBwcm9wcyA9IG9uZW9mc1tuYW1lXVxuXG4gICAgICB2YXIgbWF0Y2ggPSBmYWxzZVxuICAgICAgZm9yIChqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChkZWZpbmVkKG9ialtwcm9wc1tqXV0pKSB7XG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkgb25lIG9mIHRoZSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gb25lb2YgJyArIG5hbWUgKyAnIGNhbiBiZSBzZXQnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBtYXRjaCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmNMZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGUgPSBlbmNbaV1cbiAgICAgIHZhciBmaWVsZCA9IG0uZmllbGRzW2ldXG4gICAgICB2YXIgdmFsID0gb2JqW2ZpZWxkLm5hbWVdXG4gICAgICB2YXIgaGwgPSBobHNbaV1cbiAgICAgIHZhciBsZW5cblxuICAgICAgaWYgKCFkZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgaWYgKGZpZWxkLnJlcXVpcmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZpZWxkLm5hbWUgKyAnIGlzIHJlcXVpcmVkJylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChmaWVsZC5tYXApIHtcbiAgICAgICAgdmFyIHRtcCA9IE9iamVjdC5rZXlzKHZhbClcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHRtcC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHRtcFtqXSA9IHtcbiAgICAgICAgICAgIGtleTogdG1wW2pdLFxuICAgICAgICAgICAgdmFsdWU6IHZhbFt0bXBbal1dXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFsID0gdG1wXG4gICAgICB9XG5cbiAgICAgIGlmIChmaWVsZC5wYWNrZWQpIHtcbiAgICAgICAgdmFyIHBhY2tlZExlbiA9IDBcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHZhbC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmICghZGVmaW5lZCh2YWxbal0pKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gPSBlLmVuY29kaW5nTGVuZ3RoKHZhbFtqXSlcbiAgICAgICAgICBwYWNrZWRMZW4gKz0gbGVuXG5cbiAgICAgICAgICBpZiAoZS5tZXNzYWdlKSB7XG4gICAgICAgICAgICBwYWNrZWRMZW4gKz0gdmFyaW50LmVuY29kaW5nTGVuZ3RoKGxlbilcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFja2VkTGVuKSB7XG4gICAgICAgICAgbGVuZ3RoICs9IGhsICsgcGFja2VkTGVuICsgdmFyaW50LmVuY29kaW5nTGVuZ3RoKHBhY2tlZExlbilcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgdmFsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKCFkZWZpbmVkKHZhbFtqXSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGVuID0gZS5lbmNvZGluZ0xlbmd0aCh2YWxbal0pXG4gICAgICAgICAgbGVuZ3RoICs9IGhsICsgbGVuICsgKGUubWVzc2FnZSA/IHZhcmludC5lbmNvZGluZ0xlbmd0aChsZW4pIDogMClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gZS5lbmNvZGluZ0xlbmd0aCh2YWwpXG4gICAgICAgIGxlbmd0aCArPSBobCArIGxlbiArIChlLm1lc3NhZ2UgPyB2YXJpbnQuZW5jb2RpbmdMZW5ndGgobGVuKSA6IDApXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlbmd0aFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZUVuY29kaW5nTGVuZ3RoXG4iLCIndXNlIHN0cmljdCdcblxudmFyIHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG52YXIgc3ZhcmludCA9IHJlcXVpcmUoJ3NpZ25lZC12YXJpbnQnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBlbmNvZGVyID0gZnVuY3Rpb24gKHR5cGUsIGVuY29kZSwgZGVjb2RlLCBlbmNvZGluZ0xlbmd0aCkge1xuICBlbmNvZGUuYnl0ZXMgPSBkZWNvZGUuYnl0ZXMgPSAwXG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGRlY29kZTogZGVjb2RlLFxuICAgIGVuY29kaW5nTGVuZ3RoOiBlbmNvZGluZ0xlbmd0aFxuICB9XG59XG5cbmV4cG9ydHMubWFrZSA9IGVuY29kZXJcblxuZXhwb3J0cy5ieXRlcyA9IChmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBidWZmZXJMZW5ndGggPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcih2YWwpID8gdmFsLmxlbmd0aCA6IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbClcbiAgfVxuXG4gIHZhciBlbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YXIgbGVuID0gYnVmZmVyTGVuZ3RoKHZhbClcbiAgICByZXR1cm4gdmFyaW50LmVuY29kaW5nTGVuZ3RoKGxlbikgKyBsZW5cbiAgfVxuXG4gIHZhciBlbmNvZGUgPSBmdW5jdGlvbiAodmFsLCBidWZmZXIsIG9mZnNldCkge1xuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICB2YXIgbGVuID0gYnVmZmVyTGVuZ3RoKHZhbClcblxuICAgIHZhcmludC5lbmNvZGUobGVuLCBidWZmZXIsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gdmFyaW50LmVuY29kZS5ieXRlc1xuXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB2YWwuY29weShidWZmZXIsIG9mZnNldClcbiAgICBlbHNlIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgbGVuKVxuICAgIG9mZnNldCArPSBsZW5cblxuICAgIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgIHJldHVybiBidWZmZXJcbiAgfVxuXG4gIHZhciBkZWNvZGUgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG5cbiAgICB2YXIgbGVuID0gdmFyaW50LmRlY29kZShidWZmZXIsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gdmFyaW50LmRlY29kZS5ieXRlc1xuXG4gICAgdmFyIHZhbCA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbilcbiAgICBvZmZzZXQgKz0gdmFsLmxlbmd0aFxuXG4gICAgZGVjb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgcmV0dXJuIHZhbFxuICB9XG5cbiAgcmV0dXJuIGVuY29kZXIoMiwgZW5jb2RlLCBkZWNvZGUsIGVuY29kaW5nTGVuZ3RoKVxufSkoKVxuXG5leHBvcnRzLnN0cmluZyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBlbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YXIgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsKVxuICAgIHJldHVybiB2YXJpbnQuZW5jb2RpbmdMZW5ndGgobGVuKSArIGxlblxuICB9XG5cbiAgdmFyIGVuY29kZSA9IGZ1bmN0aW9uICh2YWwsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIHZhciBsZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpXG5cbiAgICB2YXJpbnQuZW5jb2RlKGxlbiwgYnVmZmVyLCBvZmZzZXQsICd1dGYtOCcpXG4gICAgb2Zmc2V0ICs9IHZhcmludC5lbmNvZGUuYnl0ZXNcblxuICAgIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgbGVuKVxuICAgIG9mZnNldCArPSBsZW5cblxuICAgIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgIHJldHVybiBidWZmZXJcbiAgfVxuXG4gIHZhciBkZWNvZGUgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG5cbiAgICB2YXIgbGVuID0gdmFyaW50LmRlY29kZShidWZmZXIsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gdmFyaW50LmRlY29kZS5ieXRlc1xuXG4gICAgdmFyIHZhbCA9IGJ1ZmZlci50b1N0cmluZygndXRmLTgnLCBvZmZzZXQsIG9mZnNldCArIGxlbilcbiAgICBvZmZzZXQgKz0gbGVuXG5cbiAgICBkZWNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICByZXR1cm4gdmFsXG4gIH1cblxuICByZXR1cm4gZW5jb2RlcigyLCBlbmNvZGUsIGRlY29kZSwgZW5jb2RpbmdMZW5ndGgpXG59KSgpXG5cbmV4cG9ydHMuYm9vbCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBlbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgdmFyIGVuY29kZSA9IGZ1bmN0aW9uICh2YWwsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgYnVmZmVyW29mZnNldF0gPSB2YWwgPyAxIDogMFxuICAgIGVuY29kZS5ieXRlcyA9IDFcbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cblxuICB2YXIgZGVjb2RlID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgdmFyIGJvb2wgPSBidWZmZXJbb2Zmc2V0XSA+IDBcbiAgICBkZWNvZGUuYnl0ZXMgPSAxXG4gICAgcmV0dXJuIGJvb2xcbiAgfVxuXG4gIHJldHVybiBlbmNvZGVyKDAsIGVuY29kZSwgZGVjb2RlLCBlbmNvZGluZ0xlbmd0aClcbn0pKClcblxuZXhwb3J0cy5pbnQzMiA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBkZWNvZGUgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgdmFsID0gdmFyaW50LmRlY29kZShidWZmZXIsIG9mZnNldClcbiAgICBkZWNvZGUuYnl0ZXMgPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gICAgcmV0dXJuIHZhbCA+IDIxNDc0ODM2NDcgPyB2YWwgLSA0Mjk0OTY3Mjk2IDogdmFsXG4gIH1cblxuICB2YXIgZW5jb2RlID0gZnVuY3Rpb24gKHZhbCwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXJpbnQuZW5jb2RlKHZhbCA8IDAgPyB2YWwgKyA0Mjk0OTY3Mjk2IDogdmFsLCBidWZmZXIsIG9mZnNldClcbiAgICBlbmNvZGUuYnl0ZXMgPSB2YXJpbnQuZW5jb2RlLmJ5dGVzXG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG5cbiAgdmFyIGVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB2YXJpbnQuZW5jb2RpbmdMZW5ndGgodmFsIDwgMCA/IHZhbCArIDQyOTQ5NjcyOTYgOiB2YWwpXG4gIH1cblxuICByZXR1cm4gZW5jb2RlcigwLCB2YXJpbnQuZW5jb2RlLCBkZWNvZGUsIGVuY29kaW5nTGVuZ3RoKVxufSkoKVxuXG5leHBvcnRzLmludDY0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRlY29kZSA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCkge1xuICAgIHZhciB2YWwgPSB2YXJpbnQuZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0KVxuICAgIGlmICh2YWwgPj0gTWF0aC5wb3coMiwgNjMpKSB7XG4gICAgICB2YXIgbGltaXQgPSA5XG4gICAgICB3aGlsZSAoYnVmZmVyW29mZnNldCArIGxpbWl0IC0gMV0gPT09IDB4ZmYpIGxpbWl0LS1cbiAgICAgIGxpbWl0ID0gbGltaXQgfHwgOVxuICAgICAgdmFyIHN1YnNldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsaW1pdClcbiAgICAgIGJ1ZmZlci5jb3B5KHN1YnNldCwgMCwgb2Zmc2V0LCBvZmZzZXQgKyBsaW1pdClcbiAgICAgIHN1YnNldFtsaW1pdCAtIDFdID0gc3Vic2V0W2xpbWl0IC0gMV0gJiAweDdmXG4gICAgICB2YWwgPSAtMSAqIHZhcmludC5kZWNvZGUoc3Vic2V0LCAwKVxuICAgICAgZGVjb2RlLmJ5dGVzID0gMTBcbiAgICB9IGVsc2Uge1xuICAgICAgZGVjb2RlLmJ5dGVzID0gdmFyaW50LmRlY29kZS5ieXRlc1xuICAgIH1cbiAgICByZXR1cm4gdmFsXG4gIH1cblxuICB2YXIgZW5jb2RlID0gZnVuY3Rpb24gKHZhbCwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgICBpZiAodmFsIDwgMCkge1xuICAgICAgdmFyIGxhc3QgPSBvZmZzZXQgKyA5XG4gICAgICB2YXJpbnQuZW5jb2RlKHZhbCAqIC0xLCBidWZmZXIsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSB2YXJpbnQuZW5jb2RlLmJ5dGVzIC0gMVxuICAgICAgYnVmZmVyW29mZnNldF0gPSBidWZmZXJbb2Zmc2V0XSB8IDB4ODBcbiAgICAgIHdoaWxlIChvZmZzZXQgPCBsYXN0IC0gMSkge1xuICAgICAgICBvZmZzZXQrK1xuICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IDB4ZmZcbiAgICAgIH1cbiAgICAgIGJ1ZmZlcltsYXN0XSA9IDB4MDFcbiAgICAgIGVuY29kZS5ieXRlcyA9IDEwXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhcmludC5lbmNvZGUodmFsLCBidWZmZXIsIG9mZnNldClcbiAgICAgIGVuY29kZS5ieXRlcyA9IHZhcmludC5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG5cbiAgdmFyIGVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB2YWwgPCAwID8gMTAgOiB2YXJpbnQuZW5jb2RpbmdMZW5ndGgodmFsKVxuICB9XG5cbiAgcmV0dXJuIGVuY29kZXIoMCwgZW5jb2RlLCBkZWNvZGUsIGVuY29kaW5nTGVuZ3RoKVxufSkoKVxuXG5leHBvcnRzLnNpbnQzMiA9XG5leHBvcnRzLnNpbnQ2NCA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBlbmNvZGVyKDAsIHN2YXJpbnQuZW5jb2RlLCBzdmFyaW50LmRlY29kZSwgc3ZhcmludC5lbmNvZGluZ0xlbmd0aClcbn0pKClcblxuZXhwb3J0cy51aW50MzIgPVxuZXhwb3J0cy51aW50NjQgPVxuZXhwb3J0cy5lbnVtID1cbmV4cG9ydHMudmFyaW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGVuY29kZXIoMCwgdmFyaW50LmVuY29kZSwgdmFyaW50LmRlY29kZSwgdmFyaW50LmVuY29kaW5nTGVuZ3RoKVxufSkoKVxuXG4vLyB3ZSBjYW5ub3QgcmVwcmVzZW50IHRoZXNlIGluIGphdmFzY3JpcHQgc28gd2UganVzdCB1c2UgYnVmZmVyc1xuZXhwb3J0cy5maXhlZDY0ID1cbmV4cG9ydHMuc2ZpeGVkNjQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIDhcbiAgfVxuXG4gIHZhciBlbmNvZGUgPSBmdW5jdGlvbiAodmFsLCBidWZmZXIsIG9mZnNldCkge1xuICAgIHZhbC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KVxuICAgIGVuY29kZS5ieXRlcyA9IDhcbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cblxuICB2YXIgZGVjb2RlID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgdmFyIHZhbCA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIDgpXG4gICAgZGVjb2RlLmJ5dGVzID0gOFxuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIHJldHVybiBlbmNvZGVyKDEsIGVuY29kZSwgZGVjb2RlLCBlbmNvZGluZ0xlbmd0aClcbn0pKClcblxuZXhwb3J0cy5kb3VibGUgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIDhcbiAgfVxuXG4gIHZhciBlbmNvZGUgPSBmdW5jdGlvbiAodmFsLCBidWZmZXIsIG9mZnNldCkge1xuICAgIGJ1ZmZlci53cml0ZURvdWJsZUxFKHZhbCwgb2Zmc2V0KVxuICAgIGVuY29kZS5ieXRlcyA9IDhcbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cblxuICB2YXIgZGVjb2RlID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgdmFyIHZhbCA9IGJ1ZmZlci5yZWFkRG91YmxlTEUob2Zmc2V0KVxuICAgIGRlY29kZS5ieXRlcyA9IDhcbiAgICByZXR1cm4gdmFsXG4gIH1cblxuICByZXR1cm4gZW5jb2RlcigxLCBlbmNvZGUsIGRlY29kZSwgZW5jb2RpbmdMZW5ndGgpXG59KSgpXG5cbmV4cG9ydHMuZml4ZWQzMiA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBlbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gNFxuICB9XG5cbiAgdmFyIGVuY29kZSA9IGZ1bmN0aW9uICh2YWwsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUodmFsLCBvZmZzZXQpXG4gICAgZW5jb2RlLmJ5dGVzID0gNFxuICAgIHJldHVybiBidWZmZXJcbiAgfVxuXG4gIHZhciBkZWNvZGUgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgdmFsID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQpXG4gICAgZGVjb2RlLmJ5dGVzID0gNFxuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIHJldHVybiBlbmNvZGVyKDUsIGVuY29kZSwgZGVjb2RlLCBlbmNvZGluZ0xlbmd0aClcbn0pKClcblxuZXhwb3J0cy5zZml4ZWQzMiA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBlbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gNFxuICB9XG5cbiAgdmFyIGVuY29kZSA9IGZ1bmN0aW9uICh2YWwsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgYnVmZmVyLndyaXRlSW50MzJMRSh2YWwsIG9mZnNldClcbiAgICBlbmNvZGUuYnl0ZXMgPSA0XG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG5cbiAgdmFyIGRlY29kZSA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCkge1xuICAgIHZhciB2YWwgPSBidWZmZXIucmVhZEludDMyTEUob2Zmc2V0KVxuICAgIGRlY29kZS5ieXRlcyA9IDRcbiAgICByZXR1cm4gdmFsXG4gIH1cblxuICByZXR1cm4gZW5jb2Rlcig1LCBlbmNvZGUsIGRlY29kZSwgZW5jb2RpbmdMZW5ndGgpXG59KSgpXG5cbmV4cG9ydHMuZmxvYXQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIDRcbiAgfVxuXG4gIHZhciBlbmNvZGUgPSBmdW5jdGlvbiAodmFsLCBidWZmZXIsIG9mZnNldCkge1xuICAgIGJ1ZmZlci53cml0ZUZsb2F0TEUodmFsLCBvZmZzZXQpXG4gICAgZW5jb2RlLmJ5dGVzID0gNFxuICAgIHJldHVybiBidWZmZXJcbiAgfVxuXG4gIHZhciBkZWNvZGUgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgdmFsID0gYnVmZmVyLnJlYWRGbG9hdExFKG9mZnNldClcbiAgICBkZWNvZGUuYnl0ZXMgPSA0XG4gICAgcmV0dXJuIHZhbFxuICB9XG5cbiAgcmV0dXJuIGVuY29kZXIoNSwgZW5jb2RlLCBkZWNvZGUsIGVuY29kaW5nTGVuZ3RoKVxufSkoKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEJOID0gcmVxdWlyZSgnYXNuMS5qcycpLmJpZ251bVxuXG4vLyBDb252ZXJ0IGEgQk4uanMgaW5zdGFuY2UgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgd2l0aG91dCBwYWRkaW5nXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtam9zZS1qc29uLXdlYi1zaWduYXR1cmUtNDEjYXBwZW5kaXgtQ1xuZXhwb3J0cy50b0Jhc2U2NCA9IGZ1bmN0aW9uIHRvQmFzZTY0IChibiwgbGVuKSB7XG4gIC8vIGlmIGxlbiBpcyBkZWZpbmVkIHRoZW4gdGhlIGJ5dGVzIGFyZSBsZWFkaW5nLTAgcGFkZGVkIHRvIHRoZSBsZW5ndGhcbiAgbGV0IHMgPSBibi50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIGxlbikudG9TdHJpbmcoJ2Jhc2U2NCcpXG5cbiAgcmV0dXJuIHNcbiAgICAucmVwbGFjZSgvKD0qKSQvLCAnJykgLy8gUmVtb3ZlIGFueSB0cmFpbGluZyAnPSdzXG4gICAgLnJlcGxhY2UoL1xcKy9nLCAnLScpIC8vIDYybmQgY2hhciBvZiBlbmNvZGluZ1xuICAgIC5yZXBsYWNlKC9cXC8vZywgJ18nKSAvLyA2M3JkIGNoYXIgb2YgZW5jb2Rpbmdcbn1cblxuLy8gQ29udmVydCBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byBhIEJOLmpzIGluc3RhbmNlXG5leHBvcnRzLnRvQm4gPSBmdW5jdGlvbiB0b0JuIChzdHIpIHtcbiAgcmV0dXJuIG5ldyBCTihCdWZmZXIuZnJvbShzdHIsICdiYXNlNjQnKSlcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgYXNuMSA9IGV4cG9ydHM7XG5cbmFzbjEuYmlnbnVtID0gcmVxdWlyZSgnYm4uanMnKTtcblxuYXNuMS5kZWZpbmUgPSByZXF1aXJlKCcuL2FzbjEvYXBpJykuZGVmaW5lO1xuYXNuMS5iYXNlID0gcmVxdWlyZSgnLi9hc24xL2Jhc2UnKTtcbmFzbjEuY29uc3RhbnRzID0gcmVxdWlyZSgnLi9hc24xL2NvbnN0YW50cycpO1xuYXNuMS5kZWNvZGVycyA9IHJlcXVpcmUoJy4vYXNuMS9kZWNvZGVycycpO1xuYXNuMS5lbmNvZGVycyA9IHJlcXVpcmUoJy4vYXNuMS9lbmNvZGVycycpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHNoYTMgPSByZXF1aXJlKCdqcy1zaGEzJylcbmNvbnN0IG11cm11cjMgPSByZXF1aXJlKCdtdXJtdXJoYXNoM2pzJylcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IHNoYSA9IHJlcXVpcmUoJy4vY3J5cHRvLXNoYTEtMicpXG5cbmNvbnN0IHRvQ2FsbGJhY2sgPSB1dGlscy50b0NhbGxiYWNrXG5jb25zdCB0b0J1ZiA9IHV0aWxzLnRvQnVmXG5jb25zdCBmcm9tU3RyaW5nID0gdXRpbHMuZnJvbVN0cmluZ1xuY29uc3QgZnJvbU51bWJlclRvMzJCaXRCdWYgPSB1dGlscy5mcm9tTnVtYmVyVG8zMkJpdEJ1ZlxuXG5jb25zdCBkYmxTaGEyMjU2ID0gKGJ1ZiwgY2IpID0+IHtcbiAgc2hhLnNoYTIyNTYoYnVmLCAoZXJyLCBmaXJzdEhhc2gpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYihlcnIpXG4gICAgfVxuICAgIHNoYS5zaGEyMjU2KChCdWZmZXIuZnJvbShmaXJzdEhhc2gpKSwgY2IpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzaGExOiBzaGEuc2hhMSxcbiAgc2hhMjI1Njogc2hhLnNoYTIyNTYsXG4gIHNoYTI1MTI6IHNoYS5zaGEyNTEyLFxuICBzaGEzNTEyOiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMuc2hhM181MTIpKSxcbiAgc2hhMzM4NDogdG9DYWxsYmFjayh0b0J1ZihzaGEzLnNoYTNfMzg0KSksXG4gIHNoYTMyNTY6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5zaGEzXzI1NikpLFxuICBzaGEzMjI0OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMuc2hhM18yMjQpKSxcbiAgc2hha2UxMjg6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5zaGFrZV8xMjgsIDEyOCkpLFxuICBzaGFrZTI1NjogdG9DYWxsYmFjayh0b0J1ZihzaGEzLnNoYWtlXzI1NiwgMjU2KSksXG4gIGtlY2NhazIyNDogdG9DYWxsYmFjayh0b0J1ZihzaGEzLmtlY2Nha18yMjQpKSxcbiAga2VjY2FrMjU2OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMua2VjY2FrXzI1NikpLFxuICBrZWNjYWszODQ6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5rZWNjYWtfMzg0KSksXG4gIGtlY2NhazUxMjogdG9DYWxsYmFjayh0b0J1ZihzaGEzLmtlY2Nha181MTIpKSxcbiAgbXVybXVyMzEyODogdG9DYWxsYmFjayh0b0J1Zihmcm9tU3RyaW5nKG11cm11cjMueDY0Lmhhc2gxMjgpKSksXG4gIG11cm11cjMzMjogdG9DYWxsYmFjayhmcm9tTnVtYmVyVG8zMkJpdEJ1Zihmcm9tU3RyaW5nKG11cm11cjMueDg2Lmhhc2gzMikpKSxcbiAgYWRkQmxha2U6IHJlcXVpcmUoJy4vYmxha2UnKSxcbiAgZGJsU2hhMjI1NjogZGJsU2hhMjI1NlxufVxuIiwiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJykocmVxdWlyZSgnLi9saWIvanMnKSlcbiIsIm1vZHVsZS5leHBvcnRzID0gTm9kZVxuXG4vKipcbiAqIGEgbGlua2VkLWxpc3Qgbm9kZVxuICogQGNsYXNzXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgLSBub2RlJ3MgdmFsdWVcbiAqIEBwYXJhbSB7Tm9kZX0gbmV4dCAtIG5leHQgbm9kZVxuICovXG5mdW5jdGlvbiBOb2RlICh2YWx1ZSwgbmV4dCkge1xuICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgdGhpcy5uZXh0ID0gbmV4dFxufVxuXG4vKipcbiAqIGNoZWNrcyBpZiB0aGlzIG5vZGUgb3IgYW55IG9mIGl0cyBjaGlsZHJlbiBoYXMgdGhlIHZhbHVlXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgLSB2YWx1ZSB0byBjaGVjayBpZiBsaW5rZWQtbGlzdCBjb250YWluc1xuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgbGlzdCBjb250YWlucyB0aGUgdmFsdWU7IGZhbHNlIGlmIG5vdFxuICovXG5Ob2RlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgY3Vyc29yID0gdGhpc1xuXG4gIHdoaWxlIChjdXJzb3IpIHtcbiAgICBpZiAoY3Vyc29yLnZhbHVlID09PSB2YWx1ZSkgcmV0dXJuIHRydWVcbiAgICBjdXJzb3IgPSBjdXJzb3IubmV4dFxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgREFHTGluayA9IHJlcXVpcmUoJy4vLi4vZGFnLWxpbmsnKVxuY29uc3Qge1xuICBjaWQsXG4gIHNlcmlhbGl6ZVxufSA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHNcblxuZnVuY3Rpb24gY2xvbmVEYXRhIChkYWdOb2RlKSB7XG4gIGxldCBkYXRhXG5cbiAgaWYgKGRhZ05vZGUuRGF0YSAmJiBkYWdOb2RlLkRhdGEubGVuZ3RoID4gMCkge1xuICAgIGRhdGEgPSBCdWZmZXIuYWxsb2MoZGFnTm9kZS5EYXRhLmxlbmd0aClcbiAgICBkYWdOb2RlLkRhdGEuY29weShkYXRhKVxuICB9IGVsc2Uge1xuICAgIGRhdGEgPSBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGNsb25lTGlua3MgKGRhZ05vZGUpIHtcbiAgcmV0dXJuIGRhZ05vZGUuTGlua3Muc2xpY2UoKVxufVxuXG5mdW5jdGlvbiBsaW5rU29ydCAoYSwgYikge1xuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUoYS5uYW1lQXNCdWZmZXIsIGIubmFtZUFzQnVmZmVyKVxufVxuXG4vKlxuICogdG9EQUdMaW5rIGNvbnZlcnRzIGEgREFHTm9kZSB0byBhIERBR0xpbmtcbiAqL1xuY29uc3QgdG9EQUdMaW5rID0gYXN5bmMgKG5vZGUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBzZXJpYWxpemVkID0gc2VyaWFsaXplKG5vZGUpXG4gIGNvbnN0IG5vZGVDaWQgPSBhd2FpdCBjaWQoc2VyaWFsaXplZClcbiAgcmV0dXJuIG5ldyBEQUdMaW5rKG9wdGlvbnMubmFtZSB8fCAnJywgc2VyaWFsaXplZC5sZW5ndGgsIG5vZGVDaWQpXG59XG5cbmV4cG9ydHMuY2xvbmVEYXRhID0gY2xvbmVEYXRhXG5leHBvcnRzLmNsb25lTGlua3MgPSBjbG9uZUxpbmtzXG5leHBvcnRzLmxpbmtTb3J0ID0gbGlua1NvcnRcbmV4cG9ydHMudG9EQUdMaW5rID0gdG9EQUdMaW5rXG4iLCIvLyEgc3RhYmxlLmpzIDAuMS44LCBodHRwczovL2dpdGh1Yi5jb20vVHdvLVNjcmVlbi9zdGFibGVcbi8vISDCqSAyMDE4IEFuZ3J5IEJ5dGVzIGFuZCBjb250cmlidXRvcnMuIE1JVCBsaWNlbnNlZC5cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsLnN0YWJsZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBBIHN0YWJsZSBhcnJheSBzb3J0LCBiZWNhdXNlIGBBcnJheSNzb3J0KClgIGlzIG5vdCBndWFyYW50ZWVkIHN0YWJsZS5cbiAgLy8gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBtZXJnZSBzb3J0LCB3aXRob3V0IHJlY3Vyc2lvbi5cblxuICB2YXIgc3RhYmxlID0gZnVuY3Rpb24gKGFyciwgY29tcCkge1xuICAgIHJldHVybiBleGVjKGFyci5zbGljZSgpLCBjb21wKVxuICB9O1xuXG4gIHN0YWJsZS5pbnBsYWNlID0gZnVuY3Rpb24gKGFyciwgY29tcCkge1xuICAgIHZhciByZXN1bHQgPSBleGVjKGFyciwgY29tcCk7XG5cbiAgICAvLyBUaGlzIHNpbXBseSBjb3BpZXMgYmFjayBpZiB0aGUgcmVzdWx0IGlzbid0IGluIHRoZSBvcmlnaW5hbCBhcnJheSxcbiAgICAvLyB3aGljaCBoYXBwZW5zIG9uIGFuIG9kZCBudW1iZXIgb2YgcGFzc2VzLlxuICAgIGlmIChyZXN1bHQgIT09IGFycikge1xuICAgICAgcGFzcyhyZXN1bHQsIG51bGwsIGFyci5sZW5ndGgsIGFycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyclxuICB9O1xuXG4gIC8vIEV4ZWN1dGUgdGhlIHNvcnQgdXNpbmcgdGhlIGlucHV0IGFycmF5IGFuZCBhIHNlY29uZCBidWZmZXIgYXMgd29yayBzcGFjZS5cbiAgLy8gUmV0dXJucyBvbmUgb2YgdGhvc2UgdHdvLCBjb250YWluaW5nIHRoZSBmaW5hbCByZXN1bHQuXG4gIGZ1bmN0aW9uIGV4ZWMoYXJyLCBjb21wKSB7XG4gICAgaWYgKHR5cGVvZihjb21wKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoYSkubG9jYWxlQ29tcGFyZShiKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBTaG9ydC1jaXJjdWl0IHdoZW4gdGhlcmUncyBub3RoaW5nIHRvIHNvcnQuXG4gICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgaWYgKGxlbiA8PSAxKSB7XG4gICAgICByZXR1cm4gYXJyXG4gICAgfVxuXG4gICAgLy8gUmF0aGVyIHRoYW4gZGl2aWRpbmcgaW5wdXQsIHNpbXBseSBpdGVyYXRlIGNodW5rcyBvZiAxLCAyLCA0LCA4LCBldGMuXG4gICAgLy8gQ2h1bmtzIGFyZSB0aGUgc2l6ZSBvZiB0aGUgbGVmdCBvciByaWdodCBoYW5kIGluIG1lcmdlIHNvcnQuXG4gICAgLy8gU3RvcCB3aGVuIHRoZSBsZWZ0LWhhbmQgY292ZXJzIGFsbCBvZiB0aGUgYXJyYXkuXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGNoayA9IDE7IGNoayA8IGxlbjsgY2hrICo9IDIpIHtcbiAgICAgIHBhc3MoYXJyLCBjb21wLCBjaGssIGJ1ZmZlcik7XG5cbiAgICAgIHZhciB0bXAgPSBhcnI7XG4gICAgICBhcnIgPSBidWZmZXI7XG4gICAgICBidWZmZXIgPSB0bXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyclxuICB9XG5cbiAgLy8gUnVuIGEgc2luZ2xlIHBhc3Mgd2l0aCB0aGUgZ2l2ZW4gY2h1bmsgc2l6ZS5cbiAgdmFyIHBhc3MgPSBmdW5jdGlvbiAoYXJyLCBjb21wLCBjaGssIHJlc3VsdCkge1xuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICAvLyBTdGVwIHNpemUgLyBkb3VibGUgY2h1bmsgc2l6ZS5cbiAgICB2YXIgZGJsID0gY2hrICogMjtcbiAgICAvLyBCb3VuZHMgb2YgdGhlIGxlZnQgYW5kIHJpZ2h0IGNodW5rcy5cbiAgICB2YXIgbCwgciwgZTtcbiAgICAvLyBJdGVyYXRvcnMgb3ZlciB0aGUgbGVmdCBhbmQgcmlnaHQgY2h1bmsuXG4gICAgdmFyIGxpLCByaTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBwYWlycyBvZiBjaHVua3MuXG4gICAgZm9yIChsID0gMDsgbCA8IGxlbjsgbCArPSBkYmwpIHtcbiAgICAgIHIgPSBsICsgY2hrO1xuICAgICAgZSA9IHIgKyBjaGs7XG4gICAgICBpZiAociA+IGxlbikgciA9IGxlbjtcbiAgICAgIGlmIChlID4gbGVuKSBlID0gbGVuO1xuXG4gICAgICAvLyBJdGVyYXRlIGJvdGggY2h1bmtzIGluIHBhcmFsbGVsLlxuICAgICAgbGkgPSBsO1xuICAgICAgcmkgPSByO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgLy8gQ29tcGFyZSB0aGUgY2h1bmtzLlxuICAgICAgICBpZiAobGkgPCByICYmIHJpIDwgZSkge1xuICAgICAgICAgIC8vIFRoaXMgd29ya3MgZm9yIGEgcmVndWxhciBgc29ydCgpYCBjb21wYXRpYmxlIGNvbXBhcmF0b3IsXG4gICAgICAgICAgLy8gYnV0IGFsc28gZm9yIGEgc2ltcGxlIGNvbXBhcmF0b3IgbGlrZTogYGEgPiBiYFxuICAgICAgICAgIGlmIChjb21wKGFycltsaV0sIGFycltyaV0pIDw9IDApIHtcbiAgICAgICAgICAgIHJlc3VsdFtpKytdID0gYXJyW2xpKytdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtpKytdID0gYXJyW3JpKytdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RoaW5nIHRvIGNvbXBhcmUsIGp1c3QgZmx1c2ggd2hhdCdzIGxlZnQuXG4gICAgICAgIGVsc2UgaWYgKGxpIDwgcikge1xuICAgICAgICAgIHJlc3VsdFtpKytdID0gYXJyW2xpKytdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJpIDwgZSkge1xuICAgICAgICAgIHJlc3VsdFtpKytdID0gYXJyW3JpKytdO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJvdGggaXRlcmF0b3JzIGFyZSBhdCB0aGUgY2h1bmsgZW5kcy5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc3RhYmxlO1xuXG59KSkpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuXG5jb25zdCBjcnlwdG8gPSBzZWxmLmNyeXB0byB8fCBzZWxmLm1zQ3J5cHRvXG5cbm1vZHVsZS5leHBvcnRzID0gKGFsZ29yaXRobSkgPT4ge1xuICBpZiAodHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnIHx8ICghc2VsZi5jcnlwdG8gJiYgIXNlbGYubXNDcnlwdG8pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1BsZWFzZSB1c2UgYSBicm93c2VyIHdpdGggd2ViY3J5cHRvIHN1cHBvcnQgYW5kIGVuc3VyZSB0aGUgY29kZSBoYXMgYmVlbiBkZWxpdmVyZWQgc2VjdXJlbHkgdmlhIEhUVFBTL1RMUyBhbmQgcnVuIHdpdGhpbiBhIFNlY3VyZSBDb250ZXh0J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBhc3luYyAoZGF0YSkgPT4ge1xuICAgIHN3aXRjaCAoYWxnb3JpdGhtKSB7XG4gICAgICBjYXNlICdzaGExJzpcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KHsgbmFtZTogJ1NIQS0xJyB9LCBkYXRhKSlcbiAgICAgIGNhc2UgJ3NoYTItMjU2JzpcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KHsgbmFtZTogJ1NIQS0yNTYnIH0sIGRhdGEpKVxuICAgICAgY2FzZSAnc2hhMi01MTInOlxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoeyBuYW1lOiAnU0hBLTUxMicgfSwgZGF0YSkpXG4gICAgICBjYXNlICdkYmwtc2hhMi0yNTYnOiB7XG4gICAgICAgIGNvbnN0IGQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCh7IG5hbWU6ICdTSEEtMjU2JyB9LCBkYXRhKVxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoeyBuYW1lOiAnU0hBLTI1NicgfSwgZCkpXG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7YWxnb3JpdGhtfSBpcyBub3QgYSBzdXBwb3J0ZWQgYWxnb3JpdGhtYClcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcblxuY29uc3QgZnJvbU51bWJlclRvMzJCaXRCdWYgPSAobnVtYmVyKSA9PiB7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IEFycmF5KDQpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBieXRlc1tpXSA9IG51bWJlciAmIDB4ZmZcbiAgICBudW1iZXIgPSBudW1iZXIgPj4gOFxuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZnJvbU51bWJlclRvMzJCaXRCdWZcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IGJsYWtlID0gcmVxdWlyZSgnYmxha2VqcycpXG5cbmNvbnN0IG1pbkIgPSAweGIyMDFcbmNvbnN0IG1pblMgPSAweGIyNDFcblxuY29uc3QgYmxha2UyYiA9IHtcbiAgaW5pdDogYmxha2UuYmxha2UyYkluaXQsXG4gIHVwZGF0ZTogYmxha2UuYmxha2UyYlVwZGF0ZSxcbiAgZGlnZXN0OiBibGFrZS5ibGFrZTJiRmluYWxcbn1cblxuY29uc3QgYmxha2UycyA9IHtcbiAgaW5pdDogYmxha2UuYmxha2Uyc0luaXQsXG4gIHVwZGF0ZTogYmxha2UuYmxha2Uyc1VwZGF0ZSxcbiAgZGlnZXN0OiBibGFrZS5ibGFrZTJzRmluYWxcbn1cblxuLy8gTm90ZSB0aGF0IGFsdGhvdWdoIHRoaXMgZnVuY3Rpb24gZG9lc24ndCBkbyBhbnkgYXN5bmNocm9ub3VzIHdvcmssIHdlIG1hcmtcbi8vIHRoZSBmdW5jdGlvbiBhcyBhc3luYyBiZWNhdXNlIGl0IG11c3QgcmV0dXJuIGEgUHJvbWlzZSB0byBtYXRjaCB0aGUgQVBJXG4vLyBmb3Igb3RoZXIgZnVuY3Rpb25zIHRoYXQgZG8gcGVyZm9ybSBhc3luY2hyb25vdXMgd29yayAoc2VlIHNoYS5icm93c2VyLmpzKVxuY29uc3QgbWFrZUIySGFzaCA9IChzaXplLCBoZikgPT4gYXN5bmMgKGRhdGEpID0+IHtcbiAgY29uc3QgY3R4ID0gaGYuaW5pdChzaXplLCBudWxsKVxuICBoZi51cGRhdGUoY3R4LCBkYXRhKVxuICByZXR1cm4gQnVmZmVyLmZyb20oaGYuZGlnZXN0KGN0eCkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKHRhYmxlKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgIHRhYmxlW21pbkIgKyBpXSA9IG1ha2VCMkhhc2goaSArIDEsIGJsYWtlMmIpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgdGFibGVbbWluUyArIGldID0gbWFrZUIySGFzaChpICsgMSwgYmxha2UycylcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9tdXJtdXJIYXNoM2pzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHY0ID0gJyg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSkoPzpcXFxcLig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSkpezN9JztcblxuY29uc3QgdjZzZWcgPSAnWzAtOWEtZkEtRl17MSw0fSc7XG5jb25zdCB2NiA9IGBcbihcbig/OiR7djZzZWd9Oil7N30oPzoke3Y2c2VnfXw6KXwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDE6MjozOjQ6NTo2Ojc6OiAgMToyOjM6NDo1OjY6Nzo4XG4oPzoke3Y2c2VnfTopezZ9KD86JHt2NH18OiR7djZzZWd9fDopfCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxOjI6Mzo0OjU6Njo6ICAgIDE6MjozOjQ6NTo2Ojo4ICAgMToyOjM6NDo1OjY6OjggIDE6MjozOjQ6NTo2OjoxLjIuMy40XG4oPzoke3Y2c2VnfTopezV9KD86OiR7djR9fCg6JHt2NnNlZ30pezEsMn18Oil8ICAgICAgICAgICAgICAgICAvLyAxOjI6Mzo0OjU6OiAgICAgIDE6MjozOjQ6NTo6Nzo4ICAgMToyOjM6NDo1Ojo4ICAgIDE6MjozOjQ6NTo6NzoxLjIuMy40XG4oPzoke3Y2c2VnfTopezR9KD86KDoke3Y2c2VnfSl7MCwxfToke3Y0fXwoOiR7djZzZWd9KXsxLDN9fDopfCAvLyAxOjI6Mzo0OjogICAgICAgIDE6MjozOjQ6OjY6Nzo4ICAgMToyOjM6NDo6OCAgICAgIDE6MjozOjQ6OjY6NzoxLjIuMy40XG4oPzoke3Y2c2VnfTopezN9KD86KDoke3Y2c2VnfSl7MCwyfToke3Y0fXwoOiR7djZzZWd9KXsxLDR9fDopfCAvLyAxOjI6Mzo6ICAgICAgICAgIDE6MjozOjo1OjY6Nzo4ICAgMToyOjM6OjggICAgICAgIDE6MjozOjo1OjY6NzoxLjIuMy40XG4oPzoke3Y2c2VnfTopezJ9KD86KDoke3Y2c2VnfSl7MCwzfToke3Y0fXwoOiR7djZzZWd9KXsxLDV9fDopfCAvLyAxOjI6OiAgICAgICAgICAgIDE6Mjo6NDo1OjY6Nzo4ICAgMToyOjo4ICAgICAgICAgIDE6Mjo6NDo1OjY6NzoxLjIuMy40XG4oPzoke3Y2c2VnfTopezF9KD86KDoke3Y2c2VnfSl7MCw0fToke3Y0fXwoOiR7djZzZWd9KXsxLDZ9fDopfCAvLyAxOjogICAgICAgICAgICAgIDE6OjM6NDo1OjY6Nzo4ICAgMTo6OCAgICAgICAgICAgIDE6OjM6NDo1OjY6NzoxLjIuMy40XG4oPzo6KCg/Ojoke3Y2c2VnfSl7MCw1fToke3Y0fXwoPzo6JHt2NnNlZ30pezEsN318OikpICAgICAgICAgICAvLyA6OjI6Mzo0OjU6Njo3OjggIDo6MjozOjQ6NTo2Ojc6OCAgOjo4ICAgICAgICAgICAgIDo6MS4yLjMuNFxuKSglWzAtOWEtekEtWl17MSx9KT8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJWV0aDAgICAgICAgICAgICAlMVxuYC5yZXBsYWNlKC9cXHMqXFwvXFwvLiokL2dtLCAnJykucmVwbGFjZSgvXFxuL2csICcnKS50cmltKCk7XG5cbmNvbnN0IGlwID0gbW9kdWxlLmV4cG9ydHMgPSBvcHRzID0+IG9wdHMgJiYgb3B0cy5leGFjdCA/XG5cdG5ldyBSZWdFeHAoYCg/Ol4ke3Y0fSQpfCg/Ol4ke3Y2fSQpYCkgOlxuXHRuZXcgUmVnRXhwKGAoPzoke3Y0fSl8KD86JHt2Nn0pYCwgJ2cnKTtcblxuaXAudjQgPSBvcHRzID0+IG9wdHMgJiYgb3B0cy5leGFjdCA/IG5ldyBSZWdFeHAoYF4ke3Y0fSRgKSA6IG5ldyBSZWdFeHAodjQsICdnJyk7XG5pcC52NiA9IG9wdHMgPT4gb3B0cyAmJiBvcHRzLmV4YWN0ID8gbmV3IFJlZ0V4cChgXiR7djZ9JGApIDogbmV3IFJlZ0V4cCh2NiwgJ2cnKTtcbiIsIi8vIEJMQUtFMnMgaGFzaCBmdW5jdGlvbiBpbiBwdXJlIEphdmFzY3JpcHRcbi8vIEFkYXB0ZWQgZnJvbSB0aGUgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uIGluIFJGQzc2OTNcbi8vIFBvcnRlZCB0byBKYXZhc2NyaXB0IGJ5IERDIC0gaHR0cHM6Ly9naXRodWIuY29tL2RjcG9zY2hcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuXG4vLyBMaXR0bGUtZW5kaWFuIGJ5dGUgYWNjZXNzLlxuLy8gRXhwZWN0cyBhIFVpbnQ4QXJyYXkgYW5kIGFuIGluZGV4XG4vLyBSZXR1cm5zIHRoZSBsaXR0bGUtZW5kaWFuIHVpbnQzMiBhdCB2W2kuLmkrM11cbmZ1bmN0aW9uIEIyU19HRVQzMiAodiwgaSkge1xuICByZXR1cm4gdltpXSBeICh2W2kgKyAxXSA8PCA4KSBeICh2W2kgKyAyXSA8PCAxNikgXiAodltpICsgM10gPDwgMjQpXG59XG5cbi8vIE1peGluZyBmdW5jdGlvbiBHLlxuZnVuY3Rpb24gQjJTX0cgKGEsIGIsIGMsIGQsIHgsIHkpIHtcbiAgdlthXSA9IHZbYV0gKyB2W2JdICsgeFxuICB2W2RdID0gUk9UUjMyKHZbZF0gXiB2W2FdLCAxNilcbiAgdltjXSA9IHZbY10gKyB2W2RdXG4gIHZbYl0gPSBST1RSMzIodltiXSBeIHZbY10sIDEyKVxuICB2W2FdID0gdlthXSArIHZbYl0gKyB5XG4gIHZbZF0gPSBST1RSMzIodltkXSBeIHZbYV0sIDgpXG4gIHZbY10gPSB2W2NdICsgdltkXVxuICB2W2JdID0gUk9UUjMyKHZbYl0gXiB2W2NdLCA3KVxufVxuXG4vLyAzMi1iaXQgcmlnaHQgcm90YXRpb25cbi8vIHggc2hvdWxkIGJlIGEgdWludDMyXG4vLyB5IG11c3QgYmUgYmV0d2VlbiAxIGFuZCAzMSwgaW5jbHVzaXZlXG5mdW5jdGlvbiBST1RSMzIgKHgsIHkpIHtcbiAgcmV0dXJuICh4ID4+PiB5KSBeICh4IDw8ICgzMiAtIHkpKVxufVxuXG4vLyBJbml0aWFsaXphdGlvbiBWZWN0b3IuXG52YXIgQkxBS0UyU19JViA9IG5ldyBVaW50MzJBcnJheShbXG4gIDB4NkEwOUU2NjcsIDB4QkI2N0FFODUsIDB4M0M2RUYzNzIsIDB4QTU0RkY1M0EsXG4gIDB4NTEwRTUyN0YsIDB4OUIwNTY4OEMsIDB4MUY4M0Q5QUIsIDB4NUJFMENEMTldKVxuXG52YXIgU0lHTUEgPSBuZXcgVWludDhBcnJheShbXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gIDE0LCAxMCwgNCwgOCwgOSwgMTUsIDEzLCA2LCAxLCAxMiwgMCwgMiwgMTEsIDcsIDUsIDMsXG4gIDExLCA4LCAxMiwgMCwgNSwgMiwgMTUsIDEzLCAxMCwgMTQsIDMsIDYsIDcsIDEsIDksIDQsXG4gIDcsIDksIDMsIDEsIDEzLCAxMiwgMTEsIDE0LCAyLCA2LCA1LCAxMCwgNCwgMCwgMTUsIDgsXG4gIDksIDAsIDUsIDcsIDIsIDQsIDEwLCAxNSwgMTQsIDEsIDExLCAxMiwgNiwgOCwgMywgMTMsXG4gIDIsIDEyLCA2LCAxMCwgMCwgMTEsIDgsIDMsIDQsIDEzLCA3LCA1LCAxNSwgMTQsIDEsIDksXG4gIDEyLCA1LCAxLCAxNSwgMTQsIDEzLCA0LCAxMCwgMCwgNywgNiwgMywgOSwgMiwgOCwgMTEsXG4gIDEzLCAxMSwgNywgMTQsIDEyLCAxLCAzLCA5LCA1LCAwLCAxNSwgNCwgOCwgNiwgMiwgMTAsXG4gIDYsIDE1LCAxNCwgOSwgMTEsIDMsIDAsIDgsIDEyLCAyLCAxMywgNywgMSwgNCwgMTAsIDUsXG4gIDEwLCAyLCA4LCA0LCA3LCA2LCAxLCA1LCAxNSwgMTEsIDksIDE0LCAzLCAxMiwgMTMsIDBdKVxuXG4vLyBDb21wcmVzc2lvbiBmdW5jdGlvbi4gXCJsYXN0XCIgZmxhZyBpbmRpY2F0ZXMgbGFzdCBibG9ja1xudmFyIHYgPSBuZXcgVWludDMyQXJyYXkoMTYpXG52YXIgbSA9IG5ldyBVaW50MzJBcnJheSgxNilcbmZ1bmN0aW9uIGJsYWtlMnNDb21wcmVzcyAoY3R4LCBsYXN0KSB7XG4gIHZhciBpID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB7IC8vIGluaXQgd29yayB2YXJpYWJsZXNcbiAgICB2W2ldID0gY3R4LmhbaV1cbiAgICB2W2kgKyA4XSA9IEJMQUtFMlNfSVZbaV1cbiAgfVxuXG4gIHZbMTJdIF49IGN0eC50IC8vIGxvdyAzMiBiaXRzIG9mIG9mZnNldFxuICB2WzEzXSBePSAoY3R4LnQgLyAweDEwMDAwMDAwMCkgLy8gaGlnaCAzMiBiaXRzXG4gIGlmIChsYXN0KSB7IC8vIGxhc3QgYmxvY2sgZmxhZyBzZXQgP1xuICAgIHZbMTRdID0gfnZbMTRdXG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgeyAvLyBnZXQgbGl0dGxlLWVuZGlhbiB3b3Jkc1xuICAgIG1baV0gPSBCMlNfR0VUMzIoY3R4LmIsIDQgKiBpKVxuICB9XG5cbiAgLy8gdGVuIHJvdW5kcyBvZiBtaXhpbmdcbiAgLy8gdW5jb21tZW50IHRoZSBEZWJ1Z1ByaW50IGNhbGxzIHRvIGxvZyB0aGUgY29tcHV0YXRpb25cbiAgLy8gYW5kIG1hdGNoIHRoZSBSRkMgc2FtcGxlIGRvY3VtZW50YXRpb25cbiAgLy8gdXRpbC5kZWJ1Z1ByaW50KCcgICAgICAgICAgbVsxNl0nLCBtLCAzMilcbiAgZm9yIChpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAvLyB1dGlsLmRlYnVnUHJpbnQoJyAgIChpPScgKyBpICsgJykgIHZbMTZdJywgdiwgMzIpXG4gICAgQjJTX0coMCwgNCwgOCwgMTIsIG1bU0lHTUFbaSAqIDE2ICsgMF1dLCBtW1NJR01BW2kgKiAxNiArIDFdXSlcbiAgICBCMlNfRygxLCA1LCA5LCAxMywgbVtTSUdNQVtpICogMTYgKyAyXV0sIG1bU0lHTUFbaSAqIDE2ICsgM11dKVxuICAgIEIyU19HKDIsIDYsIDEwLCAxNCwgbVtTSUdNQVtpICogMTYgKyA0XV0sIG1bU0lHTUFbaSAqIDE2ICsgNV1dKVxuICAgIEIyU19HKDMsIDcsIDExLCAxNSwgbVtTSUdNQVtpICogMTYgKyA2XV0sIG1bU0lHTUFbaSAqIDE2ICsgN11dKVxuICAgIEIyU19HKDAsIDUsIDEwLCAxNSwgbVtTSUdNQVtpICogMTYgKyA4XV0sIG1bU0lHTUFbaSAqIDE2ICsgOV1dKVxuICAgIEIyU19HKDEsIDYsIDExLCAxMiwgbVtTSUdNQVtpICogMTYgKyAxMF1dLCBtW1NJR01BW2kgKiAxNiArIDExXV0pXG4gICAgQjJTX0coMiwgNywgOCwgMTMsIG1bU0lHTUFbaSAqIDE2ICsgMTJdXSwgbVtTSUdNQVtpICogMTYgKyAxM11dKVxuICAgIEIyU19HKDMsIDQsIDksIDE0LCBtW1NJR01BW2kgKiAxNiArIDE0XV0sIG1bU0lHTUFbaSAqIDE2ICsgMTVdXSlcbiAgfVxuICAvLyB1dGlsLmRlYnVnUHJpbnQoJyAgIChpPTEwKSB2WzE2XScsIHYsIDMyKVxuXG4gIGZvciAoaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICBjdHguaFtpXSBePSB2W2ldIF4gdltpICsgOF1cbiAgfVxuICAvLyB1dGlsLmRlYnVnUHJpbnQoJ2hbOF0nLCBjdHguaCwgMzIpXG59XG5cbi8vIENyZWF0ZXMgYSBCTEFLRTJzIGhhc2hpbmcgY29udGV4dFxuLy8gUmVxdWlyZXMgYW4gb3V0cHV0IGxlbmd0aCBiZXR3ZWVuIDEgYW5kIDMyIGJ5dGVzXG4vLyBUYWtlcyBhbiBvcHRpb25hbCBVaW50OEFycmF5IGtleVxuZnVuY3Rpb24gYmxha2Uyc0luaXQgKG91dGxlbiwga2V5KSB7XG4gIGlmICghKG91dGxlbiA+IDAgJiYgb3V0bGVuIDw9IDMyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IG91dHB1dCBsZW5ndGgsIHNob3VsZCBiZSBpbiBbMSwgMzJdJylcbiAgfVxuICB2YXIga2V5bGVuID0ga2V5ID8ga2V5Lmxlbmd0aCA6IDBcbiAgaWYgKGtleSAmJiAhKGtleWxlbiA+IDAgJiYga2V5bGVuIDw9IDMyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGtleSBsZW5ndGgsIHNob3VsZCBiZSBpbiBbMSwgMzJdJylcbiAgfVxuXG4gIHZhciBjdHggPSB7XG4gICAgaDogbmV3IFVpbnQzMkFycmF5KEJMQUtFMlNfSVYpLCAvLyBoYXNoIHN0YXRlXG4gICAgYjogbmV3IFVpbnQzMkFycmF5KDY0KSwgLy8gaW5wdXQgYmxvY2tcbiAgICBjOiAwLCAvLyBwb2ludGVyIHdpdGhpbiBibG9ja1xuICAgIHQ6IDAsIC8vIGlucHV0IGNvdW50XG4gICAgb3V0bGVuOiBvdXRsZW4gLy8gb3V0cHV0IGxlbmd0aCBpbiBieXRlc1xuICB9XG4gIGN0eC5oWzBdIF49IDB4MDEwMTAwMDAgXiAoa2V5bGVuIDw8IDgpIF4gb3V0bGVuXG5cbiAgaWYgKGtleWxlbiA+IDApIHtcbiAgICBibGFrZTJzVXBkYXRlKGN0eCwga2V5KVxuICAgIGN0eC5jID0gNjQgLy8gYXQgdGhlIGVuZFxuICB9XG5cbiAgcmV0dXJuIGN0eFxufVxuXG4vLyBVcGRhdGVzIGEgQkxBS0UycyBzdHJlYW1pbmcgaGFzaFxuLy8gUmVxdWlyZXMgaGFzaCBjb250ZXh0IGFuZCBVaW50OEFycmF5IChieXRlIGFycmF5KVxuZnVuY3Rpb24gYmxha2Uyc1VwZGF0ZSAoY3R4LCBpbnB1dCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGN0eC5jID09PSA2NCkgeyAvLyBidWZmZXIgZnVsbCA/XG4gICAgICBjdHgudCArPSBjdHguYyAvLyBhZGQgY291bnRlcnNcbiAgICAgIGJsYWtlMnNDb21wcmVzcyhjdHgsIGZhbHNlKSAvLyBjb21wcmVzcyAobm90IGxhc3QpXG4gICAgICBjdHguYyA9IDAgLy8gY291bnRlciB0byB6ZXJvXG4gICAgfVxuICAgIGN0eC5iW2N0eC5jKytdID0gaW5wdXRbaV1cbiAgfVxufVxuXG4vLyBDb21wbGV0ZXMgYSBCTEFLRTJzIHN0cmVhbWluZyBoYXNoXG4vLyBSZXR1cm5zIGEgVWludDhBcnJheSBjb250YWluaW5nIHRoZSBtZXNzYWdlIGRpZ2VzdFxuZnVuY3Rpb24gYmxha2Uyc0ZpbmFsIChjdHgpIHtcbiAgY3R4LnQgKz0gY3R4LmMgLy8gbWFyayBsYXN0IGJsb2NrIG9mZnNldFxuICB3aGlsZSAoY3R4LmMgPCA2NCkgeyAvLyBmaWxsIHVwIHdpdGggemVyb3NcbiAgICBjdHguYltjdHguYysrXSA9IDBcbiAgfVxuICBibGFrZTJzQ29tcHJlc3MoY3R4LCB0cnVlKSAvLyBmaW5hbCBibG9jayBmbGFnID0gMVxuXG4gIC8vIGxpdHRsZSBlbmRpYW4gY29udmVydCBhbmQgc3RvcmVcbiAgdmFyIG91dCA9IG5ldyBVaW50OEFycmF5KGN0eC5vdXRsZW4pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY3R4Lm91dGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gKGN0eC5oW2kgPj4gMl0gPj4gKDggKiAoaSAmIDMpKSkgJiAweEZGXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG4vLyBDb21wdXRlcyB0aGUgQkxBS0UyUyBoYXNoIG9mIGEgc3RyaW5nIG9yIGJ5dGUgYXJyYXksIGFuZCByZXR1cm5zIGEgVWludDhBcnJheVxuLy9cbi8vIFJldHVybnMgYSBuLWJ5dGUgVWludDhBcnJheVxuLy9cbi8vIFBhcmFtZXRlcnM6XG4vLyAtIGlucHV0IC0gdGhlIGlucHV0IGJ5dGVzLCBhcyBhIHN0cmluZywgQnVmZmVyLCBvciBVaW50OEFycmF5XG4vLyAtIGtleSAtIG9wdGlvbmFsIGtleSBVaW50OEFycmF5LCB1cCB0byAzMiBieXRlc1xuLy8gLSBvdXRsZW4gLSBvcHRpb25hbCBvdXRwdXQgbGVuZ3RoIGluIGJ5dGVzLCBkZWZhdWx0IDY0XG5mdW5jdGlvbiBibGFrZTJzIChpbnB1dCwga2V5LCBvdXRsZW4pIHtcbiAgLy8gcHJlcHJvY2VzcyBpbnB1dHNcbiAgb3V0bGVuID0gb3V0bGVuIHx8IDMyXG4gIGlucHV0ID0gdXRpbC5ub3JtYWxpemVJbnB1dChpbnB1dClcblxuICAvLyBkbyB0aGUgbWF0aFxuICB2YXIgY3R4ID0gYmxha2Uyc0luaXQob3V0bGVuLCBrZXkpXG4gIGJsYWtlMnNVcGRhdGUoY3R4LCBpbnB1dClcbiAgcmV0dXJuIGJsYWtlMnNGaW5hbChjdHgpXG59XG5cbi8vIENvbXB1dGVzIHRoZSBCTEFLRTJTIGhhc2ggb2YgYSBzdHJpbmcgb3IgYnl0ZSBhcnJheVxuLy9cbi8vIFJldHVybnMgYW4gbi1ieXRlIGhhc2ggaW4gaGV4LCBhbGwgbG93ZXJjYXNlXG4vL1xuLy8gUGFyYW1ldGVyczpcbi8vIC0gaW5wdXQgLSB0aGUgaW5wdXQgYnl0ZXMsIGFzIGEgc3RyaW5nLCBCdWZmZXIsIG9yIFVpbnQ4QXJyYXlcbi8vIC0ga2V5IC0gb3B0aW9uYWwga2V5IFVpbnQ4QXJyYXksIHVwIHRvIDMyIGJ5dGVzXG4vLyAtIG91dGxlbiAtIG9wdGlvbmFsIG91dHB1dCBsZW5ndGggaW4gYnl0ZXMsIGRlZmF1bHQgNjRcbmZ1bmN0aW9uIGJsYWtlMnNIZXggKGlucHV0LCBrZXksIG91dGxlbikge1xuICB2YXIgb3V0cHV0ID0gYmxha2UycyhpbnB1dCwga2V5LCBvdXRsZW4pXG4gIHJldHVybiB1dGlsLnRvSGV4KG91dHB1dClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGJsYWtlMnM6IGJsYWtlMnMsXG4gIGJsYWtlMnNIZXg6IGJsYWtlMnNIZXgsXG4gIGJsYWtlMnNJbml0OiBibGFrZTJzSW5pdCxcbiAgYmxha2Uyc1VwZGF0ZTogYmxha2Uyc1VwZGF0ZSxcbiAgYmxha2Uyc0ZpbmFsOiBibGFrZTJzRmluYWxcbn1cbiIsIi8vIEJsYWtlMkIgaW4gcHVyZSBKYXZhc2NyaXB0XG4vLyBBZGFwdGVkIGZyb20gdGhlIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbiBpbiBSRkM3NjkzXG4vLyBQb3J0ZWQgdG8gSmF2YXNjcmlwdCBieSBEQyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9kY3Bvc2NoXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcblxuLy8gNjQtYml0IHVuc2lnbmVkIGFkZGl0aW9uXG4vLyBTZXRzIHZbYSxhKzFdICs9IHZbYixiKzFdXG4vLyB2IHNob3VsZCBiZSBhIFVpbnQzMkFycmF5XG5mdW5jdGlvbiBBREQ2NEFBICh2LCBhLCBiKSB7XG4gIHZhciBvMCA9IHZbYV0gKyB2W2JdXG4gIHZhciBvMSA9IHZbYSArIDFdICsgdltiICsgMV1cbiAgaWYgKG8wID49IDB4MTAwMDAwMDAwKSB7XG4gICAgbzErK1xuICB9XG4gIHZbYV0gPSBvMFxuICB2W2EgKyAxXSA9IG8xXG59XG5cbi8vIDY0LWJpdCB1bnNpZ25lZCBhZGRpdGlvblxuLy8gU2V0cyB2W2EsYSsxXSArPSBiXG4vLyBiMCBpcyB0aGUgbG93IDMyIGJpdHMgb2YgYiwgYjEgcmVwcmVzZW50cyB0aGUgaGlnaCAzMiBiaXRzXG5mdW5jdGlvbiBBREQ2NEFDICh2LCBhLCBiMCwgYjEpIHtcbiAgdmFyIG8wID0gdlthXSArIGIwXG4gIGlmIChiMCA8IDApIHtcbiAgICBvMCArPSAweDEwMDAwMDAwMFxuICB9XG4gIHZhciBvMSA9IHZbYSArIDFdICsgYjFcbiAgaWYgKG8wID49IDB4MTAwMDAwMDAwKSB7XG4gICAgbzErK1xuICB9XG4gIHZbYV0gPSBvMFxuICB2W2EgKyAxXSA9IG8xXG59XG5cbi8vIExpdHRsZS1lbmRpYW4gYnl0ZSBhY2Nlc3NcbmZ1bmN0aW9uIEIyQl9HRVQzMiAoYXJyLCBpKSB7XG4gIHJldHVybiAoYXJyW2ldIF5cbiAgKGFycltpICsgMV0gPDwgOCkgXlxuICAoYXJyW2kgKyAyXSA8PCAxNikgXlxuICAoYXJyW2kgKyAzXSA8PCAyNCkpXG59XG5cbi8vIEcgTWl4aW5nIGZ1bmN0aW9uXG4vLyBUaGUgUk9UUnMgYXJlIGlubGluZWQgZm9yIHNwZWVkXG5mdW5jdGlvbiBCMkJfRyAoYSwgYiwgYywgZCwgaXgsIGl5KSB7XG4gIHZhciB4MCA9IG1baXhdXG4gIHZhciB4MSA9IG1baXggKyAxXVxuICB2YXIgeTAgPSBtW2l5XVxuICB2YXIgeTEgPSBtW2l5ICsgMV1cblxuICBBREQ2NEFBKHYsIGEsIGIpIC8vIHZbYSxhKzFdICs9IHZbYixiKzFdIC4uLiBpbiBKUyB3ZSBtdXN0IHN0b3JlIGEgdWludDY0IGFzIHR3byB1aW50MzJzXG4gIEFERDY0QUModiwgYSwgeDAsIHgxKSAvLyB2W2EsIGErMV0gKz0geCAuLi4geDAgaXMgdGhlIGxvdyAzMiBiaXRzIG9mIHgsIHgxIGlzIHRoZSBoaWdoIDMyIGJpdHNcblxuICAvLyB2W2QsZCsxXSA9ICh2W2QsZCsxXSB4b3IgdlthLGErMV0pIHJvdGF0ZWQgdG8gdGhlIHJpZ2h0IGJ5IDMyIGJpdHNcbiAgdmFyIHhvcjAgPSB2W2RdIF4gdlthXVxuICB2YXIgeG9yMSA9IHZbZCArIDFdIF4gdlthICsgMV1cbiAgdltkXSA9IHhvcjFcbiAgdltkICsgMV0gPSB4b3IwXG5cbiAgQURENjRBQSh2LCBjLCBkKVxuXG4gIC8vIHZbYixiKzFdID0gKHZbYixiKzFdIHhvciB2W2MsYysxXSkgcm90YXRlZCByaWdodCBieSAyNCBiaXRzXG4gIHhvcjAgPSB2W2JdIF4gdltjXVxuICB4b3IxID0gdltiICsgMV0gXiB2W2MgKyAxXVxuICB2W2JdID0gKHhvcjAgPj4+IDI0KSBeICh4b3IxIDw8IDgpXG4gIHZbYiArIDFdID0gKHhvcjEgPj4+IDI0KSBeICh4b3IwIDw8IDgpXG5cbiAgQURENjRBQSh2LCBhLCBiKVxuICBBREQ2NEFDKHYsIGEsIHkwLCB5MSlcblxuICAvLyB2W2QsZCsxXSA9ICh2W2QsZCsxXSB4b3IgdlthLGErMV0pIHJvdGF0ZWQgcmlnaHQgYnkgMTYgYml0c1xuICB4b3IwID0gdltkXSBeIHZbYV1cbiAgeG9yMSA9IHZbZCArIDFdIF4gdlthICsgMV1cbiAgdltkXSA9ICh4b3IwID4+PiAxNikgXiAoeG9yMSA8PCAxNilcbiAgdltkICsgMV0gPSAoeG9yMSA+Pj4gMTYpIF4gKHhvcjAgPDwgMTYpXG5cbiAgQURENjRBQSh2LCBjLCBkKVxuXG4gIC8vIHZbYixiKzFdID0gKHZbYixiKzFdIHhvciB2W2MsYysxXSkgcm90YXRlZCByaWdodCBieSA2MyBiaXRzXG4gIHhvcjAgPSB2W2JdIF4gdltjXVxuICB4b3IxID0gdltiICsgMV0gXiB2W2MgKyAxXVxuICB2W2JdID0gKHhvcjEgPj4+IDMxKSBeICh4b3IwIDw8IDEpXG4gIHZbYiArIDFdID0gKHhvcjAgPj4+IDMxKSBeICh4b3IxIDw8IDEpXG59XG5cbi8vIEluaXRpYWxpemF0aW9uIFZlY3RvclxudmFyIEJMQUtFMkJfSVYzMiA9IG5ldyBVaW50MzJBcnJheShbXG4gIDB4RjNCQ0M5MDgsIDB4NkEwOUU2NjcsIDB4ODRDQUE3M0IsIDB4QkI2N0FFODUsXG4gIDB4RkU5NEY4MkIsIDB4M0M2RUYzNzIsIDB4NUYxRDM2RjEsIDB4QTU0RkY1M0EsXG4gIDB4QURFNjgyRDEsIDB4NTEwRTUyN0YsIDB4MkIzRTZDMUYsIDB4OUIwNTY4OEMsXG4gIDB4RkI0MUJENkIsIDB4MUY4M0Q5QUIsIDB4MTM3RTIxNzksIDB4NUJFMENEMTlcbl0pXG5cbnZhciBTSUdNQTggPSBbXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gIDE0LCAxMCwgNCwgOCwgOSwgMTUsIDEzLCA2LCAxLCAxMiwgMCwgMiwgMTEsIDcsIDUsIDMsXG4gIDExLCA4LCAxMiwgMCwgNSwgMiwgMTUsIDEzLCAxMCwgMTQsIDMsIDYsIDcsIDEsIDksIDQsXG4gIDcsIDksIDMsIDEsIDEzLCAxMiwgMTEsIDE0LCAyLCA2LCA1LCAxMCwgNCwgMCwgMTUsIDgsXG4gIDksIDAsIDUsIDcsIDIsIDQsIDEwLCAxNSwgMTQsIDEsIDExLCAxMiwgNiwgOCwgMywgMTMsXG4gIDIsIDEyLCA2LCAxMCwgMCwgMTEsIDgsIDMsIDQsIDEzLCA3LCA1LCAxNSwgMTQsIDEsIDksXG4gIDEyLCA1LCAxLCAxNSwgMTQsIDEzLCA0LCAxMCwgMCwgNywgNiwgMywgOSwgMiwgOCwgMTEsXG4gIDEzLCAxMSwgNywgMTQsIDEyLCAxLCAzLCA5LCA1LCAwLCAxNSwgNCwgOCwgNiwgMiwgMTAsXG4gIDYsIDE1LCAxNCwgOSwgMTEsIDMsIDAsIDgsIDEyLCAyLCAxMywgNywgMSwgNCwgMTAsIDUsXG4gIDEwLCAyLCA4LCA0LCA3LCA2LCAxLCA1LCAxNSwgMTEsIDksIDE0LCAzLCAxMiwgMTMsIDAsXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gIDE0LCAxMCwgNCwgOCwgOSwgMTUsIDEzLCA2LCAxLCAxMiwgMCwgMiwgMTEsIDcsIDUsIDNcbl1cblxuLy8gVGhlc2UgYXJlIG9mZnNldHMgaW50byBhIHVpbnQ2NCBidWZmZXIuXG4vLyBNdWx0aXBseSB0aGVtIGFsbCBieSAyIHRvIG1ha2UgdGhlbSBvZmZzZXRzIGludG8gYSB1aW50MzIgYnVmZmVyLFxuLy8gYmVjYXVzZSB0aGlzIGlzIEphdmFzY3JpcHQgYW5kIHdlIGRvbid0IGhhdmUgdWludDY0c1xudmFyIFNJR01BODIgPSBuZXcgVWludDhBcnJheShTSUdNQTgubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICogMiB9KSlcblxuLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24uICdsYXN0JyBmbGFnIGluZGljYXRlcyBsYXN0IGJsb2NrLlxuLy8gTm90ZSB3ZSdyZSByZXByZXNlbnRpbmcgMTYgdWludDY0cyBhcyAzMiB1aW50MzJzXG52YXIgdiA9IG5ldyBVaW50MzJBcnJheSgzMilcbnZhciBtID0gbmV3IFVpbnQzMkFycmF5KDMyKVxuZnVuY3Rpb24gYmxha2UyYkNvbXByZXNzIChjdHgsIGxhc3QpIHtcbiAgdmFyIGkgPSAwXG5cbiAgLy8gaW5pdCB3b3JrIHZhcmlhYmxlc1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIHZbaV0gPSBjdHguaFtpXVxuICAgIHZbaSArIDE2XSA9IEJMQUtFMkJfSVYzMltpXVxuICB9XG5cbiAgLy8gbG93IDY0IGJpdHMgb2Ygb2Zmc2V0XG4gIHZbMjRdID0gdlsyNF0gXiBjdHgudFxuICB2WzI1XSA9IHZbMjVdIF4gKGN0eC50IC8gMHgxMDAwMDAwMDApXG4gIC8vIGhpZ2ggNjQgYml0cyBub3Qgc3VwcG9ydGVkLCBvZmZzZXQgbWF5IG5vdCBiZSBoaWdoZXIgdGhhbiAyKio1My0xXG5cbiAgLy8gbGFzdCBibG9jayBmbGFnIHNldCA/XG4gIGlmIChsYXN0KSB7XG4gICAgdlsyOF0gPSB+dlsyOF1cbiAgICB2WzI5XSA9IH52WzI5XVxuICB9XG5cbiAgLy8gZ2V0IGxpdHRsZS1lbmRpYW4gd29yZHNcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBtW2ldID0gQjJCX0dFVDMyKGN0eC5iLCA0ICogaSlcbiAgfVxuXG4gIC8vIHR3ZWx2ZSByb3VuZHMgb2YgbWl4aW5nXG4gIC8vIHVuY29tbWVudCB0aGUgRGVidWdQcmludCBjYWxscyB0byBsb2cgdGhlIGNvbXB1dGF0aW9uXG4gIC8vIGFuZCBtYXRjaCB0aGUgUkZDIHNhbXBsZSBkb2N1bWVudGF0aW9uXG4gIC8vIHV0aWwuZGVidWdQcmludCgnICAgICAgICAgIG1bMTZdJywgbSwgNjQpXG4gIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgLy8gdXRpbC5kZWJ1Z1ByaW50KCcgICAoaT0nICsgKGkgPCAxMCA/ICcgJyA6ICcnKSArIGkgKyAnKSB2WzE2XScsIHYsIDY0KVxuICAgIEIyQl9HKDAsIDgsIDE2LCAyNCwgU0lHTUE4MltpICogMTYgKyAwXSwgU0lHTUE4MltpICogMTYgKyAxXSlcbiAgICBCMkJfRygyLCAxMCwgMTgsIDI2LCBTSUdNQTgyW2kgKiAxNiArIDJdLCBTSUdNQTgyW2kgKiAxNiArIDNdKVxuICAgIEIyQl9HKDQsIDEyLCAyMCwgMjgsIFNJR01BODJbaSAqIDE2ICsgNF0sIFNJR01BODJbaSAqIDE2ICsgNV0pXG4gICAgQjJCX0coNiwgMTQsIDIyLCAzMCwgU0lHTUE4MltpICogMTYgKyA2XSwgU0lHTUE4MltpICogMTYgKyA3XSlcbiAgICBCMkJfRygwLCAxMCwgMjAsIDMwLCBTSUdNQTgyW2kgKiAxNiArIDhdLCBTSUdNQTgyW2kgKiAxNiArIDldKVxuICAgIEIyQl9HKDIsIDEyLCAyMiwgMjQsIFNJR01BODJbaSAqIDE2ICsgMTBdLCBTSUdNQTgyW2kgKiAxNiArIDExXSlcbiAgICBCMkJfRyg0LCAxNCwgMTYsIDI2LCBTSUdNQTgyW2kgKiAxNiArIDEyXSwgU0lHTUE4MltpICogMTYgKyAxM10pXG4gICAgQjJCX0coNiwgOCwgMTgsIDI4LCBTSUdNQTgyW2kgKiAxNiArIDE0XSwgU0lHTUE4MltpICogMTYgKyAxNV0pXG4gIH1cbiAgLy8gdXRpbC5kZWJ1Z1ByaW50KCcgICAoaT0xMikgdlsxNl0nLCB2LCA2NClcblxuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGN0eC5oW2ldID0gY3R4LmhbaV0gXiB2W2ldIF4gdltpICsgMTZdXG4gIH1cbiAgLy8gdXRpbC5kZWJ1Z1ByaW50KCdoWzhdJywgY3R4LmgsIDY0KVxufVxuXG4vLyBDcmVhdGVzIGEgQkxBS0UyYiBoYXNoaW5nIGNvbnRleHRcbi8vIFJlcXVpcmVzIGFuIG91dHB1dCBsZW5ndGggYmV0d2VlbiAxIGFuZCA2NCBieXRlc1xuLy8gVGFrZXMgYW4gb3B0aW9uYWwgVWludDhBcnJheSBrZXlcbmZ1bmN0aW9uIGJsYWtlMmJJbml0IChvdXRsZW4sIGtleSkge1xuICBpZiAob3V0bGVuID09PSAwIHx8IG91dGxlbiA+IDY0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIG91dHB1dCBsZW5ndGgsIGV4cGVjdGVkIDAgPCBsZW5ndGggPD0gNjQnKVxuICB9XG4gIGlmIChrZXkgJiYga2V5Lmxlbmd0aCA+IDY0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGtleSwgZXhwZWN0ZWQgVWludDhBcnJheSB3aXRoIDAgPCBsZW5ndGggPD0gNjQnKVxuICB9XG5cbiAgLy8gc3RhdGUsICdwYXJhbSBibG9jaydcbiAgdmFyIGN0eCA9IHtcbiAgICBiOiBuZXcgVWludDhBcnJheSgxMjgpLFxuICAgIGg6IG5ldyBVaW50MzJBcnJheSgxNiksXG4gICAgdDogMCwgLy8gaW5wdXQgY291bnRcbiAgICBjOiAwLCAvLyBwb2ludGVyIHdpdGhpbiBidWZmZXJcbiAgICBvdXRsZW46IG91dGxlbiAvLyBvdXRwdXQgbGVuZ3RoIGluIGJ5dGVzXG4gIH1cblxuICAvLyBpbml0aWFsaXplIGhhc2ggc3RhdGVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgY3R4LmhbaV0gPSBCTEFLRTJCX0lWMzJbaV1cbiAgfVxuICB2YXIga2V5bGVuID0ga2V5ID8ga2V5Lmxlbmd0aCA6IDBcbiAgY3R4LmhbMF0gXj0gMHgwMTAxMDAwMCBeIChrZXlsZW4gPDwgOCkgXiBvdXRsZW5cblxuICAvLyBrZXkgdGhlIGhhc2gsIGlmIGFwcGxpY2FibGVcbiAgaWYgKGtleSkge1xuICAgIGJsYWtlMmJVcGRhdGUoY3R4LCBrZXkpXG4gICAgLy8gYXQgdGhlIGVuZFxuICAgIGN0eC5jID0gMTI4XG4gIH1cblxuICByZXR1cm4gY3R4XG59XG5cbi8vIFVwZGF0ZXMgYSBCTEFLRTJiIHN0cmVhbWluZyBoYXNoXG4vLyBSZXF1aXJlcyBoYXNoIGNvbnRleHQgYW5kIFVpbnQ4QXJyYXkgKGJ5dGUgYXJyYXkpXG5mdW5jdGlvbiBibGFrZTJiVXBkYXRlIChjdHgsIGlucHV0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY3R4LmMgPT09IDEyOCkgeyAvLyBidWZmZXIgZnVsbCA/XG4gICAgICBjdHgudCArPSBjdHguYyAvLyBhZGQgY291bnRlcnNcbiAgICAgIGJsYWtlMmJDb21wcmVzcyhjdHgsIGZhbHNlKSAvLyBjb21wcmVzcyAobm90IGxhc3QpXG4gICAgICBjdHguYyA9IDAgLy8gY291bnRlciB0byB6ZXJvXG4gICAgfVxuICAgIGN0eC5iW2N0eC5jKytdID0gaW5wdXRbaV1cbiAgfVxufVxuXG4vLyBDb21wbGV0ZXMgYSBCTEFLRTJiIHN0cmVhbWluZyBoYXNoXG4vLyBSZXR1cm5zIGEgVWludDhBcnJheSBjb250YWluaW5nIHRoZSBtZXNzYWdlIGRpZ2VzdFxuZnVuY3Rpb24gYmxha2UyYkZpbmFsIChjdHgpIHtcbiAgY3R4LnQgKz0gY3R4LmMgLy8gbWFyayBsYXN0IGJsb2NrIG9mZnNldFxuXG4gIHdoaWxlIChjdHguYyA8IDEyOCkgeyAvLyBmaWxsIHVwIHdpdGggemVyb3NcbiAgICBjdHguYltjdHguYysrXSA9IDBcbiAgfVxuICBibGFrZTJiQ29tcHJlc3MoY3R4LCB0cnVlKSAvLyBmaW5hbCBibG9jayBmbGFnID0gMVxuXG4gIC8vIGxpdHRsZSBlbmRpYW4gY29udmVydCBhbmQgc3RvcmVcbiAgdmFyIG91dCA9IG5ldyBVaW50OEFycmF5KGN0eC5vdXRsZW4pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY3R4Lm91dGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gY3R4LmhbaSA+PiAyXSA+PiAoOCAqIChpICYgMykpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG4vLyBDb21wdXRlcyB0aGUgQkxBS0UyQiBoYXNoIG9mIGEgc3RyaW5nIG9yIGJ5dGUgYXJyYXksIGFuZCByZXR1cm5zIGEgVWludDhBcnJheVxuLy9cbi8vIFJldHVybnMgYSBuLWJ5dGUgVWludDhBcnJheVxuLy9cbi8vIFBhcmFtZXRlcnM6XG4vLyAtIGlucHV0IC0gdGhlIGlucHV0IGJ5dGVzLCBhcyBhIHN0cmluZywgQnVmZmVyIG9yIFVpbnQ4QXJyYXlcbi8vIC0ga2V5IC0gb3B0aW9uYWwga2V5IFVpbnQ4QXJyYXksIHVwIHRvIDY0IGJ5dGVzXG4vLyAtIG91dGxlbiAtIG9wdGlvbmFsIG91dHB1dCBsZW5ndGggaW4gYnl0ZXMsIGRlZmF1bHQgNjRcbmZ1bmN0aW9uIGJsYWtlMmIgKGlucHV0LCBrZXksIG91dGxlbikge1xuICAvLyBwcmVwcm9jZXNzIGlucHV0c1xuICBvdXRsZW4gPSBvdXRsZW4gfHwgNjRcbiAgaW5wdXQgPSB1dGlsLm5vcm1hbGl6ZUlucHV0KGlucHV0KVxuXG4gIC8vIGRvIHRoZSBtYXRoXG4gIHZhciBjdHggPSBibGFrZTJiSW5pdChvdXRsZW4sIGtleSlcbiAgYmxha2UyYlVwZGF0ZShjdHgsIGlucHV0KVxuICByZXR1cm4gYmxha2UyYkZpbmFsKGN0eClcbn1cblxuLy8gQ29tcHV0ZXMgdGhlIEJMQUtFMkIgaGFzaCBvZiBhIHN0cmluZyBvciBieXRlIGFycmF5XG4vL1xuLy8gUmV0dXJucyBhbiBuLWJ5dGUgaGFzaCBpbiBoZXgsIGFsbCBsb3dlcmNhc2Vcbi8vXG4vLyBQYXJhbWV0ZXJzOlxuLy8gLSBpbnB1dCAtIHRoZSBpbnB1dCBieXRlcywgYXMgYSBzdHJpbmcsIEJ1ZmZlciwgb3IgVWludDhBcnJheVxuLy8gLSBrZXkgLSBvcHRpb25hbCBrZXkgVWludDhBcnJheSwgdXAgdG8gNjQgYnl0ZXNcbi8vIC0gb3V0bGVuIC0gb3B0aW9uYWwgb3V0cHV0IGxlbmd0aCBpbiBieXRlcywgZGVmYXVsdCA2NFxuZnVuY3Rpb24gYmxha2UyYkhleCAoaW5wdXQsIGtleSwgb3V0bGVuKSB7XG4gIHZhciBvdXRwdXQgPSBibGFrZTJiKGlucHV0LCBrZXksIG91dGxlbilcbiAgcmV0dXJuIHV0aWwudG9IZXgob3V0cHV0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYmxha2UyYjogYmxha2UyYixcbiAgYmxha2UyYkhleDogYmxha2UyYkhleCxcbiAgYmxha2UyYkluaXQ6IGJsYWtlMmJJbml0LFxuICBibGFrZTJiVXBkYXRlOiBibGFrZTJiVXBkYXRlLFxuICBibGFrZTJiRmluYWw6IGJsYWtlMmJGaW5hbFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpc1Byb21pc2U7XHJcblxyXG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7XHJcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbic7XHJcbn0iLCJ2YXIgaXNQcm9taXNlID0gcmVxdWlyZSgnaXMtcHJvbWlzZScpXHJcblxyXG52YXIgbmV4dFRpY2s7XHJcbmlmICh0eXBlb2Ygc2V0SW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIG5leHRUaWNrID0gc2V0SW1lZGlhdGVcclxuZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MgJiYgcHJvY2Vzcy5uZXh0VGljaykgbmV4dFRpY2sgPSBwcm9jZXNzLm5leHRUaWNrXHJcbmVsc2UgbmV4dFRpY2sgPSBmdW5jdGlvbiAoY2IpIHsgc2V0VGltZW91dChjYiwgMCkgfVxyXG5cclxudmFyIGV4dGVuc2lvbnMgPSBbXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZVxyXG5mdW5jdGlvbiBQcm9taXNlKGZuKSB7XHJcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2UpKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nID8gbmV3IFByb21pc2UoZm4pIDogZGVmZXIoKVxyXG4gIH1cclxuICB2YXIgaXNSZXNvbHZlZCA9IGZhbHNlXHJcbiAgdmFyIGlzRnVsZmlsbGVkID0gZmFsc2VcclxuICB2YXIgdmFsdWVcclxuICB2YXIgd2FpdGluZyA9IFtdXHJcbiAgdmFyIHJ1bm5pbmcgPSBmYWxzZVxyXG5cclxuICBmdW5jdGlvbiBuZXh0KHNraXBUaW1lb3V0KSB7XHJcbiAgICBpZiAod2FpdGluZy5sZW5ndGgpIHtcclxuICAgICAgcnVubmluZyA9IHRydWVcclxuICAgICAgd2FpdGluZy5zaGlmdCgpKHNraXBUaW1lb3V0IHx8IGZhbHNlKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcnVubmluZyA9IGZhbHNlXHJcbiAgICB9XHJcbiAgfVxyXG4gIHRoaXMudGhlbiA9IHRoZW47XHJcbiAgZnVuY3Rpb24gdGhlbihjYiwgZWIpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZXIpIHtcclxuICAgICAgZnVuY3Rpb24gZG9uZShza2lwVGltZW91dCkge1xyXG4gICAgICAgIHZhciBjYWxsYmFjayA9IGlzRnVsZmlsbGVkID8gY2IgOiBlYlxyXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIGZ1bmN0aW9uIHRpbWVvdXREb25lKCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHZhbCA9IGNhbGxiYWNrKHZhbHVlKVxyXG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAgICAgICAgIHJlc29sdmVyLnJlamVjdChleClcclxuICAgICAgICAgICAgICByZXR1cm4gbmV4dCgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzb2x2ZXIuZnVsZmlsbCh2YWwpO1xyXG4gICAgICAgICAgICBuZXh0KHRydWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHNraXBUaW1lb3V0KSB0aW1lb3V0RG9uZSgpXHJcbiAgICAgICAgICBlbHNlIG5leHRUaWNrKHRpbWVvdXREb25lKVxyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNGdWxmaWxsZWQpIHtcclxuICAgICAgICAgIHJlc29sdmVyLmZ1bGZpbGwodmFsdWUpXHJcbiAgICAgICAgICBuZXh0KHNraXBUaW1lb3V0KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXNvbHZlci5yZWplY3QodmFsdWUpXHJcbiAgICAgICAgICBuZXh0KHNraXBUaW1lb3V0KVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB3YWl0aW5nLnB1c2goZG9uZSlcclxuICAgICAgaWYgKGlzUmVzb2x2ZWQgJiYgIXJ1bm5pbmcpIG5leHQoKVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIFxyXG4gIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbCkge1xyXG4gICAgICBpZiAoaXNSZXNvbHZlZCkgcmV0dXJuXHJcbiAgICAgIGlmIChpc1Byb21pc2UodmFsKSkgdmFsLnRoZW4oZnVsZmlsbCwgcmVqZWN0KVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBpc1Jlc29sdmVkID0gaXNGdWxmaWxsZWQgPSB0cnVlXHJcbiAgICAgICAgdmFsdWUgPSB2YWxcclxuICAgICAgICBuZXh0KClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KGVycikge1xyXG4gICAgICBpZiAoaXNSZXNvbHZlZCkgcmV0dXJuXHJcbiAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlXHJcbiAgICAgIGlzRnVsZmlsbGVkID0gZmFsc2VcclxuICAgICAgdmFsdWUgPSBlcnJcclxuICAgICAgbmV4dCgpXHJcbiAgICB9XHJcbiAgICB2YXIgcmVzb2x2ZXIgPSB7ZnVsZmlsbDogZnVsZmlsbCwgcmVqZWN0OiByZWplY3R9O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHRlbnNpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGV4dGVuc2lvbnNbaV0odGhpcywgcmVzb2x2ZXIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGZuKHJlc29sdmVyKVxyXG4gICAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAgIHJlc29sdmVyLnJlamVjdChleCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KCkpO1xyXG59XHJcbmZ1bmN0aW9uIGRlZmVyKCkge1xyXG4gIHZhciByZXNvbHZlclxyXG4gIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcykgeyByZXNvbHZlciA9IHJlcyB9KVxyXG4gIHJldHVybiB7cmVzb2x2ZXI6IHJlc29sdmVyLCBwcm9taXNlOiBwcm9taXNlfVxyXG59XHJcblByb21pc2UudXNlID0gZnVuY3Rpb24gKGV4dGVuc2lvbikge1xyXG4gIGV4dGVuc2lvbnMucHVzaChleHRlbnNpb24pO1xyXG59OyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgZHJhaW4gPSByZXF1aXJlKCcuL2RyYWluJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBvbkVuZCAoZG9uZSkge1xuICByZXR1cm4gZHJhaW4obnVsbCwgZG9uZSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgZHJhaW4gPSByZXF1aXJlKCcuL2RyYWluJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsb2cgKGRvbmUpIHtcbiAgcmV0dXJuIGRyYWluKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgY29uc29sZS5sb2coZGF0YSlcbiAgfSwgZG9uZSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBpZCAoZSkgeyByZXR1cm4gZSB9XG52YXIgcHJvcCA9IHJlcXVpcmUoJy4uL3V0aWwvcHJvcCcpXG52YXIgZHJhaW4gPSByZXF1aXJlKCcuL2RyYWluJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaW5kICh0ZXN0LCBjYikge1xuICB2YXIgZW5kZWQgPSBmYWxzZVxuICBpZighY2IpXG4gICAgY2IgPSB0ZXN0LCB0ZXN0ID0gaWRcbiAgZWxzZVxuICAgIHRlc3QgPSBwcm9wKHRlc3QpIHx8IGlkXG5cbiAgcmV0dXJuIGRyYWluKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYodGVzdChkYXRhKSkge1xuICAgICAgZW5kZWQgPSB0cnVlXG4gICAgICBjYihudWxsLCBkYXRhKVxuICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmKGVuZGVkKSByZXR1cm4gLy9hbHJlYWR5IGNhbGxlZCBiYWNrXG4gICAgY2IoZXJyID09PSB0cnVlID8gbnVsbCA6IGVyciwgbnVsbClcbiAgfSlcbn1cblxuXG5cblxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciByZWR1Y2UgPSByZXF1aXJlKCcuL3JlZHVjZScpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29uY2F0IChjYikge1xuICByZXR1cm4gcmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgKyBiXG4gIH0sICcnLCBjYilcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvdW50IChtYXgpIHtcbiAgdmFyIGkgPSAwOyBtYXggPSBtYXggfHwgSW5maW5pdHlcbiAgcmV0dXJuIGZ1bmN0aW9uIChlbmQsIGNiKSB7XG4gICAgaWYoZW5kKSByZXR1cm4gY2IgJiYgY2IoZW5kKVxuICAgIGlmKGkgPiBtYXgpXG4gICAgICByZXR1cm4gY2IodHJ1ZSlcbiAgICBjYihudWxsLCBpKyspXG4gIH1cbn1cblxuXG4iLCIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5maW5pdGUgKGdlbmVyYXRlKSB7XG4gIGdlbmVyYXRlID0gZ2VuZXJhdGUgfHwgTWF0aC5yYW5kb21cbiAgcmV0dXJuIGZ1bmN0aW9uIChlbmQsIGNiKSB7XG4gICAgaWYoZW5kKSByZXR1cm4gY2IgJiYgY2IoZW5kKVxuICAgIHJldHVybiBjYihudWxsLCBnZW5lcmF0ZSgpKVxuICB9XG59XG5cblxuIiwiJ3VzZSBzdHJpY3QnXG4vL2Egc3RyZWFtIHRoYXQgZW5kcyBpbW1lZGlhdGVseS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW1wdHkgKCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGFib3J0LCBjYikge1xuICAgIGNiKHRydWUpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuLy9hIHN0cmVhbSB0aGF0IGVycm9ycyBpbW1lZGlhdGVseS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXJyb3IgKGVycikge1xuICByZXR1cm4gZnVuY3Rpb24gKGFib3J0LCBjYikge1xuICAgIGNiKGVycilcbiAgfVxufVxuXG4iLCIndXNlIHN0cmljdCdcbnZhciB2YWx1ZXMgPSByZXF1aXJlKCcuL3ZhbHVlcycpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIHZhbHVlcyhPYmplY3Qua2V5cyhvYmplY3QpKVxufVxuXG5cbiIsIid1c2Ugc3RyaWN0J1xuXG4vL2EgcGFzcyB0aHJvdWdoIHN0cmVhbSB0aGF0IGRvZXNuJ3QgY2hhbmdlIHRoZSB2YWx1ZS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGhyb3VnaCAob3AsIG9uRW5kKSB7XG4gIHZhciBhID0gZmFsc2VcblxuICBmdW5jdGlvbiBvbmNlIChhYm9ydCkge1xuICAgIGlmKGEgfHwgIW9uRW5kKSByZXR1cm5cbiAgICBhID0gdHJ1ZVxuICAgIG9uRW5kKGFib3J0ID09PSB0cnVlID8gbnVsbCA6IGFib3J0KVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChyZWFkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbmQsIGNiKSB7XG4gICAgICBpZihlbmQpIG9uY2UoZW5kKVxuICAgICAgcmV0dXJuIHJlYWQoZW5kLCBmdW5jdGlvbiAoZW5kLCBkYXRhKSB7XG4gICAgICAgIGlmKCFlbmQpIG9wICYmIG9wKGRhdGEpXG4gICAgICAgIGVsc2Ugb25jZShlbmQpXG4gICAgICAgIGNiKGVuZCwgZGF0YSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuLy9yZWFkIGEgbnVtYmVyIG9mIGl0ZW1zIGFuZCB0aGVuIHN0b3AuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRha2UgKHRlc3QsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge31cbiAgdmFyIGxhc3QgPSBvcHRzLmxhc3QgfHwgZmFsc2UgLy8gd2hldGhlciB0aGUgZmlyc3QgaXRlbSBmb3Igd2hpY2ggIXRlc3QoaXRlbSkgc2hvdWxkIHN0aWxsIHBhc3NcbiAgdmFyIGVuZGVkID0gZmFsc2VcbiAgaWYoJ251bWJlcicgPT09IHR5cGVvZiB0ZXN0KSB7XG4gICAgbGFzdCA9IHRydWVcbiAgICB2YXIgbiA9IHRlc3Q7IHRlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gLS1uXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChyZWFkKSB7XG5cbiAgICBmdW5jdGlvbiB0ZXJtaW5hdGUgKGNiKSB7XG4gICAgICByZWFkKHRydWUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgbGFzdCA9IGZhbHNlOyBjYihlcnIgfHwgdHJ1ZSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbmQsIGNiKSB7XG4gICAgICBpZihlbmRlZCAmJiAhZW5kKSBsYXN0ID8gdGVybWluYXRlKGNiKSA6IGNiKGVuZGVkKVxuICAgICAgZWxzZSBpZihlbmRlZCA9IGVuZCkgcmVhZChlbmRlZCwgY2IpXG4gICAgICBlbHNlXG4gICAgICAgIHJlYWQobnVsbCwgZnVuY3Rpb24gKGVuZCwgZGF0YSkge1xuICAgICAgICAgIGlmKGVuZGVkID0gZW5kZWQgfHwgZW5kKSB7XG4gICAgICAgICAgICAvL2xhc3QgPyB0ZXJtaW5hdGUoY2IpIDpcbiAgICAgICAgICAgIGNiKGVuZGVkKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmKCF0ZXN0KGRhdGEpKSB7XG4gICAgICAgICAgICBlbmRlZCA9IHRydWVcbiAgICAgICAgICAgIGxhc3QgPyBjYihudWxsLCBkYXRhKSA6IHRlcm1pbmF0ZShjYilcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2IobnVsbCwgZGF0YSlcbiAgICAgICAgfSlcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgdGVzdGVyID0gcmVxdWlyZSgnLi4vdXRpbC90ZXN0ZXInKVxudmFyIGZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaWx0ZXJOb3QgKHRlc3QpIHtcbiAgdGVzdCA9IHRlc3Rlcih0ZXN0KVxuICByZXR1cm4gZmlsdGVyKGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiAhdGVzdChkYXRhKSB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmZ1bmN0aW9uIGlkIChlKSB7IHJldHVybiBlIH1cbnZhciBwcm9wID0gcmVxdWlyZSgnLi4vdXRpbC9wcm9wJylcbnZhciBmaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpXG5cbi8vZHJvcCBpdGVtcyB5b3UgaGF2ZSBhbHJlYWR5IHNlZW4uXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHVuaXF1ZSAoZmllbGQsIGludmVydCkge1xuICBmaWVsZCA9IHByb3AoZmllbGQpIHx8IGlkXG4gIHZhciBzZWVuID0ge31cbiAgcmV0dXJuIGZpbHRlcihmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBrZXkgPSBmaWVsZChkYXRhKVxuICAgIGlmKHNlZW5ba2V5XSkgcmV0dXJuICEhaW52ZXJ0IC8vZmFsc2UsIGJ5IGRlZmF1bHRcbiAgICBlbHNlIHNlZW5ba2V5XSA9IHRydWVcbiAgICByZXR1cm4gIWludmVydCAvL3RydWUgYnkgZGVmYXVsdFxuICB9KVxufVxuXG4iLCIndXNlIHN0cmljdCdcblxudmFyIHVuaXF1ZSA9IHJlcXVpcmUoJy4vdW5pcXVlJylcblxuLy9wYXNzZXMgYW4gaXRlbSB0aHJvdWdoIHdoZW4geW91IHNlZSBpdCBmb3IgdGhlIHNlY29uZCB0aW1lLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub25VbmlxdWUgKGZpZWxkKSB7XG4gIHJldHVybiB1bmlxdWUoZmllbGQsIHRydWUpXG59XG4iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgKytpaSkge1xuICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IGJ5dGVzVG9VdWlkKHJuZHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHY0O1xuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWFkLCBfY2IsIGFib3J0Q2IsIF9lbmRcblxuICB2YXIgcmVhZCA9IGZ1bmN0aW9uIChlbmQsIGNiKSB7XG4gICAgaWYoIV9yZWFkKSB7XG4gICAgICBpZihlbmQpIHtcbiAgICAgICAgX2VuZCA9IGVuZFxuICAgICAgICBhYm9ydENiID0gY2JcbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgX2NiID0gY2JcbiAgICB9XG4gICAgZWxzZSBfcmVhZChlbmQsIGNiKVxuICB9XG4gIHJlYWQucmVzb2x2ZSA9IGZ1bmN0aW9uIChyZWFkKSB7XG4gICAgaWYoX3JlYWQpIHRocm93IG5ldyBFcnJvcignYWxyZWFkeSByZXNvbHZlZCcpXG4gICAgX3JlYWQgPSByZWFkXG4gICAgaWYoIV9yZWFkKSB0aHJvdyBuZXcgRXJyb3IoJ25vIHJlYWQgY2Fubm90IHJlc29sdmUhJyArIF9yZWFkKVxuICAgIGlmKF9jYikgcmVhZChudWxsLCBfY2IpXG4gICAgaWYoYWJvcnRDYikgcmVhZChfZW5kLCBhYm9ydENiKVxuICB9XG4gIHJlYWQuYWJvcnQgPSBmdW5jdGlvbihlcnIpIHtcbiAgICByZWFkLnJlc29sdmUoZnVuY3Rpb24gKF8sIGNiKSB7XG4gICAgICBjYihlcnIgfHwgdHJ1ZSlcbiAgICB9KVxuICB9XG4gIHJldHVybiByZWFkXG59XG5cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVUZXN0ZXIgPSByZXF1aXJlKCcuL2ludGVybmFsL2NyZWF0ZVRlc3RlcicpO1xuXG52YXIgX2NyZWF0ZVRlc3RlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUZXN0ZXIpO1xuXG52YXIgX2RvUGFyYWxsZWxMaW1pdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvZG9QYXJhbGxlbExpbWl0Jyk7XG5cbnZhciBfZG9QYXJhbGxlbExpbWl0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RvUGFyYWxsZWxMaW1pdCk7XG5cbnZhciBfaWRlbnRpdHkgPSByZXF1aXJlKCdsb2Rhc2gvaWRlbnRpdHknKTtcblxudmFyIF9pZGVudGl0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pZGVudGl0eSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2Bzb21lYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnNvbWV9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIHNvbWVMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuc29tZV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnNvbWV9XG4gKiBAYWxpYXMgYW55TGltaXRcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW1cbiAqIGluIHRoZSBjb2xsZWN0aW9ucyBpbiBwYXJhbGxlbC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gYHJlc3VsdGAgdmFsdWUuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueVxuICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgaXRlcmF0ZWUgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuXG4gKiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWAgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jXG4gKiB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfZG9QYXJhbGxlbExpbWl0Mi5kZWZhdWx0KSgoMCwgX2NyZWF0ZVRlc3RlcjIuZGVmYXVsdCkoQm9vbGVhbiwgX2lkZW50aXR5Mi5kZWZhdWx0KSk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBLZXkgfSA9IHJlcXVpcmUoJ2ludGVyZmFjZS1kYXRhc3RvcmUnKVxuY29uc3QgeyBlbmNvZGVCYXNlMzIsIGtleVRvVG9waWMsIHRvcGljVG9LZXkgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuXG5jb25zdCBlcnJjb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgbG9nID0gZGVidWcoJ2RhdGFzdG9yZS1wdWJzdWI6cHVibGlzaGVyJylcbmxvZy5lcnJvciA9IGRlYnVnKCdkYXRhc3RvcmUtcHVic3ViOnB1Ymxpc2hlcjplcnJvcicpXG5cbi8vIERhdGFzdG9yZVB1YnN1YiBpcyByZXNwb25zaWJsZSBmb3IgcHJvdmlkaW5nIGFuIGFwaSBmb3IgcHVic3ViIHRvIGJlIHVzZWQgYXMgYSBkYXRhc3RvcmUgd2l0aFxuLy8gW1RpZXJlZERhdGFzdG9yZV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2lwZnMvanMtZGF0YXN0b3JlLWNvcmUvYmxvYi9tYXN0ZXIvc3JjL3RpZXJlZC5qc31cbmNsYXNzIERhdGFzdG9yZVB1YnN1YiB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIERhdGFzdG9yZVB1YnN1Yi5cbiAgICogQHBhcmFtIHsqfSBwdWJzdWIgLSBwdWJzdWIgaW1wbGVtZW50YXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gZGF0YXN0b3JlIC0gZGF0YXN0b3JlIGluc3RhbmNlLlxuICAgKiBAcGFyYW0geyp9IHBlZXJJZCAtIHBlZXItaWQgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWxpZGF0b3IgLSB2YWxpZGF0b3IgZnVuY3Rpb25zLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHJlY29yZCwgcGVlcklkLCBjYWxsYmFjayl9IHZhbGlkYXRvci52YWxpZGF0ZSAtIGZ1bmN0aW9uIHRvIHZhbGlkYXRlIGEgcmVjb3JkLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHJlY2VpdmVkLCBjdXJyZW50LCBjYWxsYmFjayl9IHZhbGlkYXRvci5zZWxlY3QgLSBmdW5jdGlvbiB0byBzZWxlY3QgdGhlIG5ld2VzdCBiZXR3ZWVuIHR3byByZWNvcmRzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGtleSwgY2FsbGJhY2spfSBzdWJzY3JpcHRpb25LZXlGbiAtIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIG1hbmlwdWxhdGUgdGhlIGtleSB0b3BpYyByZWNlaXZlZCBiZWZvcmUgcHJvY2Vzc2luZyBpdC5cbiAgICogQG1lbWJlcm9mIERhdGFzdG9yZVB1YnN1YlxuICAgKi9cbiAgY29uc3RydWN0b3IgKHB1YnN1YiwgZGF0YXN0b3JlLCBwZWVySWQsIHZhbGlkYXRvciwgc3Vic2NyaXB0aW9uS2V5Rm4pIHtcbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwodHlwZW9mIHZhbGlkYXRvciwgJ29iamVjdCcsICdtaXNzaW5nIHZhbGlkYXRvcicpXG4gICAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiB2YWxpZGF0b3IudmFsaWRhdGUsICdmdW5jdGlvbicsICdtaXNzaW5nIHZhbGlkYXRlIGZ1bmN0aW9uJylcbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwodHlwZW9mIHZhbGlkYXRvci5zZWxlY3QsICdmdW5jdGlvbicsICdtaXNzaW5nIHNlbGVjdCBmdW5jdGlvbicpXG4gICAgc3Vic2NyaXB0aW9uS2V5Rm4gJiYgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBzdWJzY3JpcHRpb25LZXlGbiwgJ2Z1bmN0aW9uJywgJ2ludmFsaWQgc3Vic2NyaXB0aW9uS2V5Rm4gcmVjZWl2ZWQnKVxuXG4gICAgdGhpcy5fcHVic3ViID0gcHVic3ViXG4gICAgdGhpcy5fZGF0YXN0b3JlID0gZGF0YXN0b3JlXG4gICAgdGhpcy5fcGVlcklkID0gcGVlcklkXG4gICAgdGhpcy5fdmFsaWRhdG9yID0gdmFsaWRhdG9yXG4gICAgdGhpcy5faGFuZGxlU3Vic2NyaXB0aW9uS2V5Rm4gPSBzdWJzY3JpcHRpb25LZXlGblxuXG4gICAgLy8gQmluZCBfb25NZXNzYWdlIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQgYnkgcHVic3ViLlxuICAgIHRoaXMuX29uTWVzc2FnZSA9IHRoaXMuX29uTWVzc2FnZS5iaW5kKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogUHVibGlzaGVzIGEgdmFsdWUgdGhyb3VnaCBwdWJzdWIuXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBrZXkgaWRlbnRpZmllciBvZiB0aGUgdmFsdWUgdG8gYmUgcHVibGlzaGVkLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gdmFsIHZhbHVlIHRvIGJlIHByb3BhZ2F0ZWQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHB1dCAoa2V5LCB2YWwsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoa2V5KSkge1xuICAgICAgY29uc3QgZXJyTXNnID0gYGRhdGFzdG9yZSBrZXkgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIGZvcm1hdGBcblxuICAgICAgbG9nLmVycm9yKGVyck1zZylcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnJjb2RlKG5ldyBFcnJvcihlcnJNc2cpLCAnRVJSX0lOVkFMSURfREFUQVNUT1JFX0tFWScpKVxuICAgIH1cblxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAgIGNvbnN0IGVyck1zZyA9IGByZWNlaXZlZCB2YWx1ZSBpcyBub3QgYSBidWZmZXJgXG5cbiAgICAgIGxvZy5lcnJvcihlcnJNc2cpXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9JTlZBTElEX1ZBTFVFX1JFQ0VJVkVEJykpXG4gICAgfVxuXG4gICAgY29uc3Qgc3RyaW5naWZpZWRUb3BpYyA9IGtleVRvVG9waWMoa2V5KVxuXG4gICAgbG9nKGBwdWJsaXNoIHZhbHVlIGZvciB0b3BpYyAke3N0cmluZ2lmaWVkVG9waWN9YClcblxuICAgIC8vIFB1Ymxpc2ggcmVjb3JkIHRvIHB1YnN1YlxuICAgIHRoaXMuX3B1YnN1Yi5wdWJsaXNoKHN0cmluZ2lmaWVkVG9waWMsIHZhbCwgY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogVHJ5IHRvIHN1YnNjcmliZSBhIHRvcGljIHdpdGggUHVic3ViIGFuZCByZXR1cm5zIHRoZSBsb2NhbCB2YWx1ZSBpZiBhdmFpbGFibGUuXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBrZXkgaWRlbnRpZmllciBvZiB0aGUgdmFsdWUgdG8gYmUgc3Vic2NyaWJlZC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQnVmZmVyKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBnZXQgKGtleSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihrZXkpKSB7XG4gICAgICBjb25zdCBlcnJNc2cgPSBgZGF0YXN0b3JlIGtleSBkb2VzIG5vdCBoYXZlIGEgdmFsaWQgZm9ybWF0YFxuXG4gICAgICBsb2cuZXJyb3IoZXJyTXNnKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKGVyck1zZyksICdFUlJfSU5WQUxJRF9EQVRBU1RPUkVfS0VZJykpXG4gICAgfVxuXG4gICAgY29uc3Qgc3RyaW5naWZpZWRUb3BpYyA9IGtleVRvVG9waWMoa2V5KVxuXG4gICAgdGhpcy5fcHVic3ViLmxzKChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBhbHJlYWR5IHN1YnNjcmliZWQsIGp1c3QgdHJ5IHRvIGdldCBpdFxuICAgICAgaWYgKHJlcyAmJiBBcnJheS5pc0FycmF5KHJlcykgJiYgcmVzLmluZGV4T2Yoc3RyaW5naWZpZWRUb3BpYykgPiAtMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TG9jYWwoa2V5LCBjYWxsYmFjaylcbiAgICAgIH1cblxuICAgICAgLy8gU3Vic2NyaWJlXG4gICAgICB0aGlzLl9wdWJzdWIuc3Vic2NyaWJlKHN0cmluZ2lmaWVkVG9waWMsIHRoaXMuX29uTWVzc2FnZSwgKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY29uc3QgZXJyTXNnID0gYGNhbm5vdCBzdWJzY3JpYmUgdG9waWMgJHtzdHJpbmdpZmllZFRvcGljfWBcblxuICAgICAgICAgIGxvZy5lcnJvcihlcnJNc2cpXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKGVyck1zZyksICdFUlJfU1VCU0NSSUJJTkdfVE9QSUMnKSlcbiAgICAgICAgfVxuICAgICAgICBsb2coYHN1YnNjcmliZWQgdmFsdWVzIGZvciBrZXkgJHtzdHJpbmdpZmllZFRvcGljfWApXG5cbiAgICAgICAgdGhpcy5fZ2V0TG9jYWwoa2V5LCBjYWxsYmFjaylcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSB0b3BpYy5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IGtleSBpZGVudGlmaWVyIG9mIHRoZSB2YWx1ZSB0byB1bnN1YnNjcmliZS5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICB1bnN1YnNjcmliZSAoa2V5KSB7XG4gICAgY29uc3Qgc3RyaW5naWZpZWRUb3BpYyA9IGtleVRvVG9waWMoa2V5KVxuXG4gICAgdGhpcy5fcHVic3ViLnVuc3Vic2NyaWJlKHN0cmluZ2lmaWVkVG9waWMsIHRoaXMuX29uTWVzc2FnZSlcbiAgfVxuXG4gIC8vIEdldCByZWNvcmQgZnJvbSBsb2NhbCBkYXRhc3RvcmVcbiAgX2dldExvY2FsIChrZXksIGNhbGxiYWNrKSB7XG4gICAgLy8gZW5jb2RlIGtleSAtIGJhc2UzMigvaXBucy97Y2lkfSlcbiAgICBjb25zdCByb3V0aW5nS2V5ID0gbmV3IEtleSgnLycgKyBlbmNvZGVCYXNlMzIoa2V5KSwgZmFsc2UpXG5cbiAgICB0aGlzLl9kYXRhc3RvcmUuZ2V0KHJvdXRpbmdLZXksIChlcnIsIGRzVmFsKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSAhPT0gJ0VSUl9OT1RfRk9VTkQnKSB7XG4gICAgICAgICAgY29uc3QgZXJyTXNnID0gYHVuZXhwZWN0ZWQgZXJyb3IgZ2V0dGluZyB0aGUgaXBucyByZWNvcmQgZm9yICR7cm91dGluZ0tleS50b1N0cmluZygpfWBcblxuICAgICAgICAgIGxvZy5lcnJvcihlcnJNc2cpXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKGVyck1zZyksICdFUlJfVU5FWFBFQ1RFRF9FUlJPUl9HRVRUSU5HX1JFQ09SRCcpKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVyck1zZyA9IGBsb2NhbCByZWNvcmQgcmVxdWVzdGVkIHdhcyBub3QgZm91bmQgZm9yICR7cm91dGluZ0tleS50b1N0cmluZygpfWBcblxuICAgICAgICBsb2cuZXJyb3IoZXJyTXNnKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9OT1RfRk9VTkQnKSlcbiAgICAgIH1cblxuICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZHNWYWwpKSB7XG4gICAgICAgIGNvbnN0IGVyck1zZyA9IGBmb3VuZCByZWNvcmQgdGhhdCB3ZSBjb3VsZG4ndCBjb252ZXJ0IHRvIGEgdmFsdWVgXG5cbiAgICAgICAgbG9nLmVycm9yKGVyck1zZylcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKGVyck1zZyksICdFUlJfSU5WQUxJRF9SRUNPUkRfUkVDRUlWRUQnKSlcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgZHNWYWwpXG4gICAgfSlcbiAgfVxuXG4gIC8vIGhhbmRsZXMgcHVic3ViIHN1YnNjcmlwdGlvbiBtZXNzYWdlc1xuICBfb25NZXNzYWdlIChtc2cpIHtcbiAgICBjb25zdCB7IGRhdGEsIGZyb20sIHRvcGljSURzIH0gPSBtc2dcbiAgICBsZXQga2V5XG4gICAgdHJ5IHtcbiAgICAgIGtleSA9IHRvcGljVG9LZXkodG9waWNJRHNbMF0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cuZXJyb3IoZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbG9nKGBtZXNzYWdlIHJlY2VpdmVkIGZvciAke2tleX0gdG9waWNgKVxuXG4gICAgLy8gU3RvcCBpZiB0aGUgbWVzc2FnZSBpcyBmcm9tIHRoZSBwZWVyIChpdCBhbHJlYWR5IHN0b3JlZCBpdCB3aGlsZSBwdWJsaXNoaW5nIHRvIHB1YnN1YilcbiAgICBpZiAoZnJvbSA9PT0gdGhpcy5fcGVlcklkLnRvQjU4U3RyaW5nKCkpIHtcbiAgICAgIGxvZyhgbWVzc2FnZSBkaXNjYXJkZWQgYXMgaXQgaXMgZnJvbSB0aGUgc2FtZSBwZWVyYClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLl9oYW5kbGVTdWJzY3JpcHRpb25LZXlGbikge1xuICAgICAgdGhpcy5faGFuZGxlU3Vic2NyaXB0aW9uS2V5Rm4oa2V5LCAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGxvZy5lcnJvcignbWVzc2FnZSBkaXNjYXJkZWQgYnkgdGhlIHN1YnNjcmlwdGlvbktleUZuJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0b3JlSWZTdWJzY3JpcHRpb25Jc0JldHRlcihyZXMsIGRhdGEpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdG9yZUlmU3Vic2NyaXB0aW9uSXNCZXR0ZXIoa2V5LCBkYXRhKVxuICAgIH1cbiAgfVxuXG4gIC8vIFN0b3JlIHRoZSByZWNlaXZlZCByZWNvcmQgaWYgaXQgaXMgYmV0dGVyIHRoYW4gdGhlIGN1cnJlbnQgc3RvcmVkXG4gIF9zdG9yZUlmU3Vic2NyaXB0aW9uSXNCZXR0ZXIgKGtleSwgZGF0YSkge1xuICAgIHRoaXMuX2lzQmV0dGVyKGtleSwgZGF0YSwgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoIWVyciAmJiByZXMpIHtcbiAgICAgICAgdGhpcy5fc3RvcmVSZWNvcmQoQnVmZmVyLmZyb20oa2V5KSwgZGF0YSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gVmFsaWRhdGUgcmVjb3JkIGFjY29yZGluZyB0byB0aGUgcmVjZWl2ZWQgdmFsaWRhdGlvbiBmdW5jdGlvblxuICBfdmFsaWRhdGVSZWNvcmQgKHZhbHVlLCBwZWVySWQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fdmFsaWRhdG9yLnZhbGlkYXRlKHZhbHVlLCBwZWVySWQsIGNhbGxiYWNrKVxuICB9XG5cbiAgLy8gU2VsZWN0IHRoZSBiZXN0IHJlY29yZCBhY2NvcmRpbmcgdG8gdGhlIHJlY2VpdmVkIHNlbGVjdCBmdW5jdGlvbi5cbiAgX3NlbGVjdFJlY29yZCAocmVjZWl2ZWRSZWNvcmQsIGN1cnJlbnRSZWNvcmQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fdmFsaWRhdG9yLnNlbGVjdChyZWNlaXZlZFJlY29yZCwgY3VycmVudFJlY29yZCwgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGxvZy5lcnJvcihlcnIpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBzZWxlY3RlZCB3YXMgdGhlIGZpcnN0ICgwKSwgaXQgc2hvdWxkIGJlIHN0b3JlZCAodHJ1ZSlcbiAgICAgIGNhbGxiYWNrKG51bGwsIHJlcyA9PT0gMClcbiAgICB9KVxuICB9XG5cbiAgLy8gVmVyaWZ5IGlmIHRoZSByZWNvcmQgcmVjZWl2ZWQgdGhyb3VnaCBwdWJzdWIgaXMgdmFsaWQgYW5kIGJldHRlciB0aGFuIHRoZSBvbmUgY3VycmVudGx5IHN0b3JlZFxuICBfaXNCZXR0ZXIgKGtleSwgdmFsLCBjYWxsYmFjaykge1xuICAgIC8vIHZhbGlkYXRlIHJlY2VpdmVkIHJlY29yZFxuICAgIHRoaXMuX3ZhbGlkYXRlUmVjb3JkKHZhbCwga2V5LCAoZXJyLCB2YWxpZCkgPT4ge1xuICAgICAgLy8gSWYgbm90IHZhbGlkLCBpdCBpcyBub3QgYmV0dGVyIHRoYW4gdGhlIG9uZSBjdXJyZW50bHkgYXZhaWxhYmxlXG4gICAgICBpZiAoZXJyIHx8ICF2YWxpZCkge1xuICAgICAgICBjb25zdCBlcnJNc2cgPSAncmVjb3JkIHJlY2VpdmVkIHRocm91Z2ggcHVic3ViIGlzIG5vdCB2YWxpZCdcblxuICAgICAgICBsb2cuZXJyb3IoZXJyTXNnKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9OT1RfVkFMSURfUkVDT1JEJykpXG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBMb2NhbCByZWNvcmRcbiAgICAgIGNvbnN0IGRzS2V5ID0gbmV3IEtleShrZXkpXG5cbiAgICAgIHRoaXMuX2dldExvY2FsKGRzS2V5LnRvQnVmZmVyKCksIChlcnIsIGN1cnJlbnRSZWNvcmQpID0+IHtcbiAgICAgICAgLy8gaWYgdGhlIG9sZCBvbmUgaXMgaW52YWxpZCwgdGhlIG5ldyBvbmUgaXMgKmFsd2F5cyogYmV0dGVyXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdHJ1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBzYW1lIHJlY29yZCwgZG8gbm90IG5lZWQgdG8gc3RvcmVcbiAgICAgICAgaWYgKGN1cnJlbnRSZWNvcmQuZXF1YWxzKHZhbCkpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZmFsc2UpXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2ZXJpZnkgaWYgdGhlIHJlY2VpdmVkIHJlY29yZCBzaG91bGQgcmVwbGFjZSB0aGUgY3VycmVudCBvbmVcbiAgICAgICAgdGhpcy5fc2VsZWN0UmVjb3JkKHZhbCwgY3VycmVudFJlY29yZCwgY2FsbGJhY2spXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyBhZGQgcmVjb3JkIHRvIGRhdGFzdG9yZVxuICBfc3RvcmVSZWNvcmQgKGtleSwgZGF0YSkge1xuICAgIC8vIGVuY29kZSBrZXkgLSBiYXNlMzIoL2lwbnMve2NpZH0pXG4gICAgY29uc3Qgcm91dGluZ0tleSA9IG5ldyBLZXkoJy8nICsgZW5jb2RlQmFzZTMyKGtleSksIGZhbHNlKVxuXG4gICAgdGhpcy5fZGF0YXN0b3JlLnB1dChyb3V0aW5nS2V5LCBkYXRhLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGxvZy5lcnJvcihgcmVjb3JkIGZvciAke2tleS50b1N0cmluZygpfSBjb3VsZCBub3QgYmUgc3RvcmVkIGluIHRoZSByb3V0aW5nYClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGxvZyhgcmVjb3JkIGZvciAke2tleS50b1N0cmluZygpfSB3YXMgc3RvcmVkIGluIHRoZSBkYXRhc3RvcmVgKVxuICAgIH0pXG4gIH1cblxuICBvcGVuIChjYWxsYmFjaykge1xuICAgIGNvbnN0IGVyck1zZyA9IGBvcGVuIGZ1bmN0aW9uIHdhcyBub3QgaW1wbGVtZW50ZWQgeWV0YFxuXG4gICAgbG9nLmVycm9yKGVyck1zZylcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9OT1RfSU1QTEVNRU5URURfWUVUJykpXG4gIH1cblxuICBoYXMgKGtleSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBlcnJNc2cgPSBgaGFzIGZ1bmN0aW9uIHdhcyBub3QgaW1wbGVtZW50ZWQgeWV0YFxuXG4gICAgbG9nLmVycm9yKGVyck1zZylcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9OT1RfSU1QTEVNRU5URURfWUVUJykpXG4gIH1cblxuICBkZWxldGUgKGtleSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBlcnJNc2cgPSBgZGVsZXRlIGZ1bmN0aW9uIHdhcyBub3QgaW1wbGVtZW50ZWQgeWV0YFxuXG4gICAgbG9nLmVycm9yKGVyck1zZylcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9OT1RfSU1QTEVNRU5URURfWUVUJykpXG4gIH1cblxuICBjbG9zZSAoY2FsbGJhY2spIHtcbiAgICBjb25zdCBlcnJNc2cgPSBgY2xvc2UgZnVuY3Rpb24gd2FzIG5vdCBpbXBsZW1lbnRlZCB5ZXRgXG5cbiAgICBsb2cuZXJyb3IoZXJyTXNnKVxuICAgIHJldHVybiBjYWxsYmFjayhlcnJjb2RlKG5ldyBFcnJvcihlcnJNc2cpLCAnRVJSX05PVF9JTVBMRU1FTlRFRF9ZRVQnKSlcbiAgfVxuXG4gIGJhdGNoICgpIHtcbiAgICBjb25zdCBlcnJNc2cgPSBgYmF0Y2ggZnVuY3Rpb24gd2FzIG5vdCBpbXBsZW1lbnRlZCB5ZXRgXG5cbiAgICBsb2cuZXJyb3IoZXJyTXNnKVxuICAgIHRocm93IGVycmNvZGUobmV3IEVycm9yKGVyck1zZyksICdFUlJfTk9UX0lNUExFTUVOVEVEX1lFVCcpXG4gIH1cblxuICBxdWVyeSAoKSB7XG4gICAgY29uc3QgZXJyTXNnID0gYHF1ZXJ5IGZ1bmN0aW9uIHdhcyBub3QgaW1wbGVtZW50ZWQgeWV0YFxuXG4gICAgbG9nLmVycm9yKGVyck1zZylcbiAgICB0aHJvdyBlcnJjb2RlKG5ldyBFcnJvcihlcnJNc2cpLCAnRVJSX05PVF9JTVBMRU1FTlRFRF9ZRVQnKVxuICB9XG59XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IERhdGFzdG9yZVB1YnN1YlxuIiwiLypqc2hpbnQgbm9kZTp0cnVlKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXBsYWNlcyBjaGFyYWN0ZXJzIGluIHN0cmluZ3MgdGhhdCBhcmUgaWxsZWdhbC91bnNhZmUgZm9yIGZpbGVuYW1lcy5cbiAqIFVuc2FmZSBjaGFyYWN0ZXJzIGFyZSBlaXRoZXIgcmVtb3ZlZCBvciByZXBsYWNlZCBieSBhIHN1YnN0aXR1dGUgc2V0XG4gKiBpbiB0aGUgb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdC5cbiAqXG4gKiBJbGxlZ2FsIENoYXJhY3RlcnMgb24gVmFyaW91cyBPcGVyYXRpbmcgU3lzdGVtc1xuICogLyA/IDwgPiBcXCA6ICogfCBcIlxuICogaHR0cHM6Ly9rYi5hY3JvbmlzLmNvbS9jb250ZW50LzM5NzkwXG4gKlxuICogVW5pY29kZSBDb250cm9sIGNvZGVzXG4gKiBDMCAweDAwLTB4MWYgJiBDMSAoMHg4MC0weDlmKVxuICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DMF9hbmRfQzFfY29udHJvbF9jb2Rlc1xuICpcbiAqIFJlc2VydmVkIGZpbGVuYW1lcyBvbiBVbml4LWJhc2VkIHN5c3RlbXMgKFwiLlwiLCBcIi4uXCIpXG4gKiBSZXNlcnZlZCBmaWxlbmFtZXMgaW4gV2luZG93cyAoXCJDT05cIiwgXCJQUk5cIiwgXCJBVVhcIiwgXCJOVUxcIiwgXCJDT00xXCIsXG4gKiBcIkNPTTJcIiwgXCJDT00zXCIsIFwiQ09NNFwiLCBcIkNPTTVcIiwgXCJDT002XCIsIFwiQ09NN1wiLCBcIkNPTThcIiwgXCJDT005XCIsXG4gKiBcIkxQVDFcIiwgXCJMUFQyXCIsIFwiTFBUM1wiLCBcIkxQVDRcIiwgXCJMUFQ1XCIsIFwiTFBUNlwiLCBcIkxQVDdcIiwgXCJMUFQ4XCIsIGFuZFxuICogXCJMUFQ5XCIpIGNhc2UtaW5zZXNpdGl2ZWx5IGFuZCB3aXRoIG9yIHdpdGhvdXQgZmlsZW5hbWUgZXh0ZW5zaW9ucy5cbiAqXG4gKiBDYXBwZWQgYXQgMjU1IGNoYXJhY3RlcnMgaW4gbGVuZ3RoLlxuICogaHR0cDovL3VuaXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzMyNzk1L3doYXQtaXMtdGhlLW1heGltdW0tYWxsb3dlZC1maWxlbmFtZS1hbmQtZm9sZGVyLXNpemUtd2l0aC1lY3J5cHRmc1xuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gaW5wdXQgICBPcmlnaW5hbCBmaWxlbmFtZVxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIHtyZXBsYWNlbWVudDogU3RyaW5nIHwgRnVuY3Rpb24gfVxuICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgIFNhbml0aXplZCBmaWxlbmFtZVxuICovXG5cbnZhciB0cnVuY2F0ZSA9IHJlcXVpcmUoXCJ0cnVuY2F0ZS11dGY4LWJ5dGVzXCIpO1xuXG52YXIgaWxsZWdhbFJlID0gL1tcXC9cXD88PlxcXFw6XFwqXFx8XCJdL2c7XG52YXIgY29udHJvbFJlID0gL1tcXHgwMC1cXHgxZlxceDgwLVxceDlmXS9nO1xudmFyIHJlc2VydmVkUmUgPSAvXlxcLiskLztcbnZhciB3aW5kb3dzUmVzZXJ2ZWRSZSA9IC9eKGNvbnxwcm58YXV4fG51bHxjb21bMC05XXxscHRbMC05XSkoXFwuLiopPyQvaTtcbnZhciB3aW5kb3dzVHJhaWxpbmdSZSA9IC9bXFwuIF0rJC87XG5cbmZ1bmN0aW9uIHNhbml0aXplKGlucHV0LCByZXBsYWNlbWVudCkge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgbXVzdCBiZSBzdHJpbmcnKTtcbiAgfVxuICB2YXIgc2FuaXRpemVkID0gaW5wdXRcbiAgICAucmVwbGFjZShpbGxlZ2FsUmUsIHJlcGxhY2VtZW50KVxuICAgIC5yZXBsYWNlKGNvbnRyb2xSZSwgcmVwbGFjZW1lbnQpXG4gICAgLnJlcGxhY2UocmVzZXJ2ZWRSZSwgcmVwbGFjZW1lbnQpXG4gICAgLnJlcGxhY2Uod2luZG93c1Jlc2VydmVkUmUsIHJlcGxhY2VtZW50KVxuICAgIC5yZXBsYWNlKHdpbmRvd3NUcmFpbGluZ1JlLCByZXBsYWNlbWVudCk7XG4gIHJldHVybiB0cnVuY2F0ZShzYW5pdGl6ZWQsIDI1NSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciByZXBsYWNlbWVudCA9IChvcHRpb25zICYmIG9wdGlvbnMucmVwbGFjZW1lbnQpIHx8ICcnO1xuICB2YXIgb3V0cHV0ID0gc2FuaXRpemUoaW5wdXQsIHJlcGxhY2VtZW50KTtcbiAgaWYgKHJlcGxhY2VtZW50ID09PSAnJykge1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgcmV0dXJuIHNhbml0aXplKG91dHB1dCwgJycpO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdhc3luYy9zZXRJbW1lZGlhdGUnKVxuY29uc3Qgc2VyaWVzID0gcmVxdWlyZSgnYXN5bmMvc2VyaWVzJylcbmNvbnN0IGRldGVjdCA9IHJlcXVpcmUoJ2FzeW5jL2RldGVjdCcpXG5jb25zdCB3YXRlcmZhbGwgPSByZXF1aXJlKCdhc3luYy93YXRlcmZhbGwnKVxucmVxdWlyZSgnbm9kZS1mb3JnZS9saWIvcGtjczcnKVxucmVxdWlyZSgnbm9kZS1mb3JnZS9saWIvcGJlJylcbmNvbnN0IGZvcmdlID0gcmVxdWlyZSgnbm9kZS1mb3JnZS9saWIvZm9yZ2UnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCBlcnJjb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuXG4vKipcbiAqIENyeXB0b2dyYXBoaWMgTWVzc2FnZSBTeW50YXggKGFrYSBQS0NTICM3KVxuICpcbiAqIENNUyBkZXNjcmliZXMgYW4gZW5jYXBzdWxhdGlvbiBzeW50YXggZm9yIGRhdGEgcHJvdGVjdGlvbi4gSXRcbiAqIGlzIHVzZWQgdG8gZGlnaXRhbGx5IHNpZ24sIGRpZ2VzdCwgYXV0aGVudGljYXRlLCBvciBlbmNyeXB0XG4gKiBhcmJpdHJhcnkgbWVzc2FnZSBjb250ZW50LlxuICpcbiAqIFNlZSBSRkMgNTY1MiBmb3IgYWxsIHRoZSBkZXRhaWxzLlxuICovXG5jbGFzcyBDTVMge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSB3aXRoIGEga2V5Y2hhaW5cbiAgICpcbiAgICogQHBhcmFtIHtLZXljaGFpbn0ga2V5Y2hhaW4gLSB0aGUgYXZhaWxhYmxlIGtleXNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChrZXljaGFpbikge1xuICAgIGlmICgha2V5Y2hhaW4pIHtcbiAgICAgIHRocm93IGVycmNvZGUobmV3IEVycm9yKCdrZXljaGFpbiBpcyByZXF1aXJlZCcpLCAnRVJSX0tFWUNIQUlOX1JFUVVJUkVEJylcbiAgICB9XG5cbiAgICB0aGlzLmtleWNoYWluID0ga2V5Y2hhaW5cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHNvbWUgcHJvdGVjdGVkIGRhdGEuXG4gICAqXG4gICAqIFRoZSBvdXRwdXQgQnVmZmVyIGNvbnRhaW5zIHRoZSBQS0NTICM3IG1lc3NhZ2UgaW4gREVSLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBsb2NhbCBrZXkgbmFtZS5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IHBsYWluIC0gVGhlIGRhdGEgdG8gZW5jcnlwdC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQnVmZmVyKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGVuY3J5cHQgKG5hbWUsIHBsYWluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgY29uc3QgZG9uZSA9IChlcnIsIHJlc3VsdCkgPT4gc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKGVyciwgcmVzdWx0KSlcblxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHBsYWluKSkge1xuICAgICAgcmV0dXJuIGRvbmUoZXJyY29kZShuZXcgRXJyb3IoJ1BsYWluIGRhdGEgbXVzdCBiZSBhIEJ1ZmZlcicpLCAnRVJSX0lOVkFMSURfUEFSQU1TJykpXG4gICAgfVxuXG4gICAgc2VyaWVzKFtcbiAgICAgIChjYikgPT4gc2VsZi5rZXljaGFpbi5maW5kS2V5QnlOYW1lKG5hbWUsIGNiKSxcbiAgICAgIChjYikgPT4gc2VsZi5rZXljaGFpbi5fZ2V0UHJpdmF0ZUtleShuYW1lLCBjYilcbiAgICBdLCAoZXJyLCByZXN1bHRzKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gZG9uZShlcnIpXG5cbiAgICAgIGxldCBrZXkgPSByZXN1bHRzWzBdXG4gICAgICBsZXQgcGVtID0gcmVzdWx0c1sxXVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IGZvcmdlLnBraS5kZWNyeXB0UnNhUHJpdmF0ZUtleShwZW0sIHNlbGYua2V5Y2hhaW4uXygpKVxuICAgICAgICB1dGlsLmNlcnRpZmljYXRlRm9yS2V5KGtleSwgcHJpdmF0ZUtleSwgKGVyciwgY2VydGlmaWNhdGUpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuXG4gICAgICAgICAgLy8gY3JlYXRlIGEgcDcgZW52ZWxvcGVkIG1lc3NhZ2VcbiAgICAgICAgICBjb25zdCBwNyA9IGZvcmdlLnBrY3M3LmNyZWF0ZUVudmVsb3BlZERhdGEoKVxuICAgICAgICAgIHA3LmFkZFJlY2lwaWVudChjZXJ0aWZpY2F0ZSlcbiAgICAgICAgICBwNy5jb250ZW50ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIocGxhaW4pXG4gICAgICAgICAgcDcuZW5jcnlwdCgpXG5cbiAgICAgICAgICAvLyBjb252ZXJ0IG1lc3NhZ2UgdG8gREVSXG4gICAgICAgICAgY29uc3QgZGVyID0gZm9yZ2UuYXNuMS50b0RlcihwNy50b0FzbjEoKSkuZ2V0Qnl0ZXMoKVxuICAgICAgICAgIGRvbmUobnVsbCwgQnVmZmVyLmZyb20oZGVyLCAnYmluYXJ5JykpXG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZG9uZShlcnIpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBzb21lIHByb3RlY3RlZCBkYXRhLlxuICAgKlxuICAgKiBUaGUga2V5Y2hhaW4gbXVzdCBjb250YWluIG9uZSBvZiB0aGUga2V5cyB1c2VkIHRvIGVuY3J5cHQgdGhlIGRhdGEuICBJZiBub25lIG9mIHRoZSBrZXlzXG4gICAqIGV4aXN0cywgYW4gRXJyb3IgaXMgcmV0dXJuZWQgd2l0aCB0aGUgcHJvcGVydHkgJ21pc3NpbmdLZXlzJy4gIEl0IGlzIGFycmF5IG9mIGtleSBpZHMuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjbXNEYXRhIC0gVGhlIENNUyBlbmNyeXB0ZWQgZGF0YSB0byBkZWNyeXB0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBCdWZmZXIpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgZGVjcnlwdCAoY21zRGF0YSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBkb25lID0gKGVyciwgcmVzdWx0KSA9PiBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2soZXJyLCByZXN1bHQpKVxuXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY21zRGF0YSkpIHtcbiAgICAgIHJldHVybiBkb25lKGVycmNvZGUobmV3IEVycm9yKCdDTVMgZGF0YSBpcyByZXF1aXJlZCcpLCAnRVJSX0lOVkFMSURfUEFSQU1TJykpXG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICBsZXQgY21zXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJ1ZiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNtc0RhdGEudG9TdHJpbmcoJ2JpbmFyeScpKVxuICAgICAgY29uc3Qgb2JqID0gZm9yZ2UuYXNuMS5mcm9tRGVyKGJ1ZilcbiAgICAgIGNtcyA9IGZvcmdlLnBrY3M3Lm1lc3NhZ2VGcm9tQXNuMShvYmopXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gZG9uZShlcnJjb2RlKG5ldyBFcnJvcignSW52YWxpZCBDTVM6ICcgKyBlcnIubWVzc2FnZSksICdFUlJfSU5WQUxJRF9DTVMnKSlcbiAgICB9XG5cbiAgICAvLyBGaW5kIGEgcmVjaXBpZW50IHdob3NlIGtleSB3ZSBob2xkLiBXZSBvbmx5IGRlYWwgd2l0aCByZWNpcGllbnQgY2VydHNcbiAgICAvLyBpc3N1ZWQgYnkgaXBmcyAoTz1pcGZzKS5cbiAgICBjb25zdCByZWNpcGllbnRzID0gY21zLnJlY2lwaWVudHNcbiAgICAgIC5maWx0ZXIociA9PiByLmlzc3Vlci5maW5kKGEgPT4gYS5zaG9ydE5hbWUgPT09ICdPJyAmJiBhLnZhbHVlID09PSAnaXBmcycpKVxuICAgICAgLmZpbHRlcihyID0+IHIuaXNzdWVyLmZpbmQoYSA9PiBhLnNob3J0TmFtZSA9PT0gJ0NOJykpXG4gICAgICAubWFwKHIgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlY2lwaWVudDogcixcbiAgICAgICAgICBrZXlJZDogci5pc3N1ZXIuZmluZChhID0+IGEuc2hvcnROYW1lID09PSAnQ04nKS52YWx1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIGRldGVjdChcbiAgICAgIHJlY2lwaWVudHMsXG4gICAgICAociwgY2IpID0+IHNlbGYua2V5Y2hhaW4uZmluZEtleUJ5SWQoci5rZXlJZCwgKGVyciwgaW5mbykgPT4gY2IobnVsbCwgIWVyciAmJiBpbmZvKSksXG4gICAgICAoZXJyLCByKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBkb25lKGVycilcbiAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgY29uc3QgbWlzc2luZ0tleXMgPSByZWNpcGllbnRzLm1hcChyID0+IHIua2V5SWQpXG4gICAgICAgICAgZXJyID0gZXJyY29kZShuZXcgRXJyb3IoJ0RlY3J5cHRpb24gbmVlZHMgb25lIG9mIHRoZSBrZXkocyk6ICcgKyBtaXNzaW5nS2V5cy5qb2luKCcsICcpKSwgJ0VSUl9NSVNTSU5HX0tFWVMnLCB7XG4gICAgICAgICAgICBtaXNzaW5nS2V5c1xuICAgICAgICAgIH0pXG4gICAgICAgICAgcmV0dXJuIGRvbmUoZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgd2F0ZXJmYWxsKFtcbiAgICAgICAgICAoY2IpID0+IHNlbGYua2V5Y2hhaW4uZmluZEtleUJ5SWQoci5rZXlJZCwgY2IpLFxuICAgICAgICAgIChrZXksIGNiKSA9PiBzZWxmLmtleWNoYWluLl9nZXRQcml2YXRlS2V5KGtleS5uYW1lLCBjYilcbiAgICAgICAgXSwgKGVyciwgcGVtKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGRvbmUoZXJyKVxuXG4gICAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IGZvcmdlLnBraS5kZWNyeXB0UnNhUHJpdmF0ZUtleShwZW0sIHNlbGYua2V5Y2hhaW4uXygpKVxuICAgICAgICAgIGNtcy5kZWNyeXB0KHIucmVjaXBpZW50LCBwcml2YXRlS2V5KVxuICAgICAgICAgIGRvbmUobnVsbCwgQnVmZmVyLmZyb20oY21zLmNvbnRlbnQuZ2V0Qnl0ZXMoKSwgJ2JpbmFyeScpKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENNU1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNFQ09ORCA9IDEwMDBcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1heFByb3ZpZGVyc1BlclJlcXVlc3Q6IDMsXG4gIHByb3ZpZGVyUmVxdWVzdFRpbWVvdXQ6IDEwICogU0VDT05ELFxuICBoYXNCbG9ja1RpbWVvdXQ6IDE1ICogU0VDT05ELFxuICBwcm92aWRlVGltZW91dDogMTUgKiBTRUNPTkQsXG4gIGtNYXhQcmlvcml0eTogTWF0aC5wb3coMiwgMzEpIC0gMSxcbiAgcmVicm9hZGNhc3REZWxheTogMTAgKiBTRUNPTkQsXG4gIG1heExpc3RlbmVyczogMTAwMFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHByb3RvbnMgPSByZXF1aXJlKCdwcm90b25zJylcbmNvbnN0IEJsb2NrID0gcmVxdWlyZSgnaXBmcy1ibG9jaycpXG5jb25zdCBpc0VxdWFsV2l0aCA9IHJlcXVpcmUoJ2xvZGFzaC5pc2VxdWFsd2l0aCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgZWFjaCA9IHJlcXVpcmUoJ2FzeW5jL2VhY2gnKVxuY29uc3QgbmV4dFRpY2sgPSByZXF1aXJlKCdhc3luYy9uZXh0VGljaycpXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcbmNvbnN0IGNvZGVjTmFtZSA9IHJlcXVpcmUoJ211bHRpY29kZWMvc3JjL25hbWUtdGFibGUnKVxuY29uc3QgdmQgPSByZXF1aXJlKCd2YXJpbnQtZGVjb2RlcicpXG5jb25zdCBtdWx0aWhhc2hpbmcgPSByZXF1aXJlKCdtdWx0aWhhc2hpbmctYXN5bmMnKVxuXG5jb25zdCBwYm0gPSBwcm90b25zKHJlcXVpcmUoJy4vbWVzc2FnZS5wcm90bycpKVxuY29uc3QgRW50cnkgPSByZXF1aXJlKCcuL2VudHJ5JylcblxuY2xhc3MgQml0c3dhcE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvciAoZnVsbCkge1xuICAgIHRoaXMuZnVsbCA9IGZ1bGxcbiAgICB0aGlzLndhbnRsaXN0ID0gbmV3IE1hcCgpXG4gICAgdGhpcy5ibG9ja3MgPSBuZXcgTWFwKClcbiAgfVxuXG4gIGdldCBlbXB0eSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tzLnNpemUgPT09IDAgJiZcbiAgICAgICAgICAgdGhpcy53YW50bGlzdC5zaXplID09PSAwXG4gIH1cblxuICBhZGRFbnRyeSAoY2lkLCBwcmlvcml0eSwgY2FuY2VsKSB7XG4gICAgYXNzZXJ0KGNpZCAmJiBDSUQuaXNDSUQoY2lkKSwgJ211c3QgYmUgYSB2YWxpZCBjaWQnKVxuICAgIGNvbnN0IGNpZFN0ciA9IGNpZC5idWZmZXIudG9TdHJpbmcoKVxuXG4gICAgY29uc3QgZW50cnkgPSB0aGlzLndhbnRsaXN0LmdldChjaWRTdHIpXG5cbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnByaW9yaXR5ID0gcHJpb3JpdHlcbiAgICAgIGVudHJ5LmNhbmNlbCA9IEJvb2xlYW4oY2FuY2VsKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndhbnRsaXN0LnNldChjaWRTdHIsIG5ldyBFbnRyeShjaWQsIHByaW9yaXR5LCBjYW5jZWwpKVxuICAgIH1cbiAgfVxuXG4gIGFkZEJsb2NrIChibG9jaykge1xuICAgIGFzc2VydChCbG9jay5pc0Jsb2NrKGJsb2NrKSwgJ211c3QgYmUgYSB2YWxpZCBjaWQnKVxuICAgIGNvbnN0IGNpZFN0ciA9IGJsb2NrLmNpZC5idWZmZXIudG9TdHJpbmcoKVxuICAgIHRoaXMuYmxvY2tzLnNldChjaWRTdHIsIGJsb2NrKVxuICB9XG5cbiAgY2FuY2VsIChjaWQpIHtcbiAgICBhc3NlcnQoQ0lELmlzQ0lEKGNpZCksICdtdXN0IGJlIGEgdmFsaWQgY2lkJylcbiAgICBjb25zdCBjaWRTdHIgPSBjaWQuYnVmZmVyLnRvU3RyaW5nKClcbiAgICB0aGlzLndhbnRsaXN0LmRlbGV0ZShjaWRTdHIpXG4gICAgdGhpcy5hZGRFbnRyeShjaWQsIDAsIHRydWUpXG4gIH1cblxuICAvKlxuICAgKiBTZXJpYWxpemVzIHRvIEJpdHN3YXAgTWVzc2FnZSBwcm90b2J1ZiBvZlxuICAgKiB2ZXJzaW9uIDEuMC4wXG4gICAqL1xuICBzZXJpYWxpemVUb0JpdHN3YXAxMDAgKCkge1xuICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgIHdhbnRsaXN0OiB7XG4gICAgICAgIGVudHJpZXM6IEFycmF5LmZyb20odGhpcy53YW50bGlzdC52YWx1ZXMoKSkubWFwKChlbnRyeSkgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBibG9jazogZW50cnkuY2lkLmJ1ZmZlciwgLy8gY2lkXG4gICAgICAgICAgICBwcmlvcml0eTogTnVtYmVyKGVudHJ5LnByaW9yaXR5KSxcbiAgICAgICAgICAgIGNhbmNlbDogQm9vbGVhbihlbnRyeS5jYW5jZWwpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIGJsb2NrczogQXJyYXkuZnJvbSh0aGlzLmJsb2Nrcy52YWx1ZXMoKSlcbiAgICAgICAgLm1hcCgoYmxvY2spID0+IGJsb2NrLmRhdGEpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZnVsbCkge1xuICAgICAgbXNnLndhbnRsaXN0LmZ1bGwgPSB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIHBibS5NZXNzYWdlLmVuY29kZShtc2cpXG4gIH1cblxuICAvKlxuICAgKiBTZXJpYWxpemVzIHRvIEJpdHN3YXAgTWVzc2FnZSBwcm90b2J1ZiBvZlxuICAgKiB2ZXJzaW9uIDEuMS4wXG4gICAqL1xuICBzZXJpYWxpemVUb0JpdHN3YXAxMTAgKCkge1xuICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgIHdhbnRsaXN0OiB7XG4gICAgICAgIGVudHJpZXM6IEFycmF5LmZyb20odGhpcy53YW50bGlzdC52YWx1ZXMoKSkubWFwKChlbnRyeSkgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBibG9jazogZW50cnkuY2lkLmJ1ZmZlciwgLy8gY2lkXG4gICAgICAgICAgICBwcmlvcml0eTogTnVtYmVyKGVudHJ5LnByaW9yaXR5KSxcbiAgICAgICAgICAgIGNhbmNlbDogQm9vbGVhbihlbnRyeS5jYW5jZWwpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIHBheWxvYWQ6IFtdXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZnVsbCkge1xuICAgICAgbXNnLndhbnRsaXN0LmZ1bGwgPSB0cnVlXG4gICAgfVxuXG4gICAgdGhpcy5ibG9ja3MuZm9yRWFjaCgoYmxvY2spID0+IHtcbiAgICAgIG1zZy5wYXlsb2FkLnB1c2goe1xuICAgICAgICBwcmVmaXg6IGJsb2NrLmNpZC5wcmVmaXgsXG4gICAgICAgIGRhdGE6IGJsb2NrLmRhdGFcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHJldHVybiBwYm0uTWVzc2FnZS5lbmNvZGUobXNnKVxuICB9XG5cbiAgZXF1YWxzIChvdGhlcikge1xuICAgIGNvbnN0IGNtcCA9IChhLCBiKSA9PiB7XG4gICAgICBpZiAoYS5lcXVhbHMgJiYgdHlwZW9mIGEuZXF1YWxzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBhLmVxdWFscyhiKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmZ1bGwgIT09IG90aGVyLmZ1bGwgfHxcbiAgICAgICAgIWlzRXF1YWxXaXRoKHRoaXMud2FudGxpc3QsIG90aGVyLndhbnRsaXN0LCBjbXApIHx8XG4gICAgICAgICFpc0VxdWFsV2l0aCh0aGlzLmJsb2Nrcywgb3RoZXIuYmxvY2tzLCBjbXApXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddICgpIHtcbiAgICBjb25zdCBsaXN0ID0gQXJyYXkuZnJvbSh0aGlzLndhbnRsaXN0LmtleXMoKSlcbiAgICBjb25zdCBibG9ja3MgPSBBcnJheS5mcm9tKHRoaXMuYmxvY2tzLmtleXMoKSlcbiAgICByZXR1cm4gYEJpdHN3YXBNZXNzYWdlIDxmdWxsOiAke3RoaXMuZnVsbH0sIGxpc3Q6ICR7bGlzdH0sIGJsb2NrczogJHtibG9ja3N9PmBcbiAgfVxufVxuXG5CaXRzd2FwTWVzc2FnZS5kZXNlcmlhbGl6ZSA9IChyYXcsIGNhbGxiYWNrKSA9PiB7XG4gIGxldCBkZWNvZGVkXG4gIHRyeSB7XG4gICAgZGVjb2RlZCA9IHBibS5NZXNzYWdlLmRlY29kZShyYXcpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBuZXh0VGljaygoKSA9PiBjYWxsYmFjayhlcnIpKVxuICB9XG5cbiAgY29uc3QgaXNGdWxsID0gKGRlY29kZWQud2FudGxpc3QgJiYgZGVjb2RlZC53YW50bGlzdC5mdWxsKSB8fCBmYWxzZVxuICBjb25zdCBtc2cgPSBuZXcgQml0c3dhcE1lc3NhZ2UoaXNGdWxsKVxuXG4gIGlmIChkZWNvZGVkLndhbnRsaXN0KSB7XG4gICAgZGVjb2RlZC53YW50bGlzdC5lbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAvLyBub3RlOiBlbnRyeS5ibG9jayBpcyB0aGUgQ0lEIGhlcmVcbiAgICAgIGxldCBjaWRcbiAgICAgIHRyeSB7XG4gICAgICAgIGNpZCA9IG5ldyBDSUQoZW50cnkuYmxvY2spXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cbiAgICAgIG1zZy5hZGRFbnRyeShjaWQsIGVudHJ5LnByaW9yaXR5LCBlbnRyeS5jYW5jZWwpXG4gICAgfSlcbiAgfVxuXG4gIC8vIEJpdHN3YXAgMS4wLjBcbiAgLy8gZGVjb2RlZC5ibG9ja3MgYXJlIGp1c3QgdGhlIGJ5dGUgYXJyYXlzXG4gIGlmIChkZWNvZGVkLmJsb2Nrcy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGVhY2goZGVjb2RlZC5ibG9ja3MsIChiLCBjYikgPT4ge1xuICAgICAgbXVsdGloYXNoaW5nKGIsICdzaGEyLTI1NicsIChlcnIsIGhhc2gpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNpZFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNpZCA9IG5ldyBDSUQoaGFzaClcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgfVxuICAgICAgICBtc2cuYWRkQmxvY2sobmV3IEJsb2NrKGIsIGNpZCkpXG4gICAgICAgIGNiKClcbiAgICAgIH0pXG4gICAgfSwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgbXNnKVxuICAgIH0pXG4gIH1cblxuICAvLyBCaXRzd2FwIDEuMS4wXG4gIGlmIChkZWNvZGVkLnBheWxvYWQubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBlYWNoKGRlY29kZWQucGF5bG9hZCwgKHAsIGNiKSA9PiB7XG4gICAgICBpZiAoIXAucHJlZml4IHx8ICFwLmRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5leHRUaWNrKGNiKVxuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWVzID0gdmQocC5wcmVmaXgpXG4gICAgICBjb25zdCBjaWRWZXJzaW9uID0gdmFsdWVzWzBdXG4gICAgICBjb25zdCBtdWx0aWNvZGVjID0gdmFsdWVzWzFdXG4gICAgICBjb25zdCBoYXNoQWxnID0gdmFsdWVzWzJdXG4gICAgICAvLyBjb25zdCBoYXNoTGVuID0gdmFsdWVzWzNdIC8vIFdlIGhhdmVuJ3QgbmVlZCB0byB1c2UgdGhpcyBzbyBmYXJcbiAgICAgIG11bHRpaGFzaGluZyhwLmRhdGEsIGhhc2hBbGcsIChlcnIsIGhhc2gpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2lkXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2lkID0gbmV3IENJRChjaWRWZXJzaW9uLCBjb2RlY05hbWVbbXVsdGljb2RlYy50b1N0cmluZygnMTYnKV0sIGhhc2gpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBtc2cuYWRkQmxvY2sobmV3IEJsb2NrKHAuZGF0YSwgY2lkKSlcbiAgICAgICAgY2IoKVxuICAgICAgfSlcbiAgICB9LCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBtc2cpXG4gICAgfSlcbiAgfVxuXG4gIGNhbGxiYWNrKG51bGwsIG1zZylcbn1cblxuQml0c3dhcE1lc3NhZ2UuRW50cnkgPSBFbnRyeVxubW9kdWxlLmV4cG9ydHMgPSBCaXRzd2FwTWVzc2FnZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgc29ydEJ5IH0gPSByZXF1aXJlKCcuLi8uLi91dGlscycpXG5jb25zdCBFbnRyeSA9IHJlcXVpcmUoJy4vZW50cnknKVxuXG5jbGFzcyBXYW50bGlzdCB7XG4gIGNvbnN0cnVjdG9yIChzdGF0cykge1xuICAgIHRoaXMuc2V0ID0gbmV3IE1hcCgpXG4gICAgdGhpcy5fc3RhdHMgPSBzdGF0c1xuICB9XG5cbiAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0LnNpemVcbiAgfVxuXG4gIGFkZCAoY2lkLCBwcmlvcml0eSkge1xuICAgIGNvbnN0IGNpZFN0ciA9IGNpZC5idWZmZXIudG9TdHJpbmcoKVxuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5zZXQuZ2V0KGNpZFN0cilcblxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkuaW5jKClcbiAgICAgIGVudHJ5LnByaW9yaXR5ID0gcHJpb3JpdHlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXQuc2V0KGNpZFN0ciwgbmV3IEVudHJ5KGNpZCwgcHJpb3JpdHkpKVxuICAgICAgaWYgKHRoaXMuX3N0YXRzKSB7XG4gICAgICAgIHRoaXMuX3N0YXRzLnB1c2gobnVsbCwgJ3dhbnRMaXN0U2l6ZScsIDEpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlIChjaWQpIHtcbiAgICBjb25zdCBjaWRTdHIgPSBjaWQuYnVmZmVyLnRvU3RyaW5nKClcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMuc2V0LmdldChjaWRTdHIpXG5cbiAgICBpZiAoIWVudHJ5KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBlbnRyeS5kZWMoKVxuXG4gICAgLy8gb25seSBkZWxldGUgd2hlbiBubyByZWZzIGFyZSBoZWxkXG4gICAgaWYgKGVudHJ5Lmhhc1JlZnMoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5zZXQuZGVsZXRlKGNpZFN0cilcbiAgICBpZiAodGhpcy5fc3RhdHMpIHtcbiAgICAgIHRoaXMuX3N0YXRzLnB1c2gobnVsbCwgJ3dhbnRMaXN0U2l6ZScsIC0xKVxuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUZvcmNlIChjaWRTdHIpIHtcbiAgICBpZiAodGhpcy5zZXQuaGFzKGNpZFN0cikpIHtcbiAgICAgIHRoaXMuc2V0LmRlbGV0ZShjaWRTdHIpXG4gICAgfVxuICB9XG5cbiAgZm9yRWFjaCAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5zZXQuZm9yRWFjaChmbilcbiAgfVxuXG4gIGVudHJpZXMgKCkge1xuICAgIHJldHVybiB0aGlzLnNldC5lbnRyaWVzKClcbiAgfVxuXG4gIHNvcnRlZEVudHJpZXMgKCkge1xuICAgIHJldHVybiBuZXcgTWFwKHNvcnRCeShvID0+IG9bMV0ua2V5LCBBcnJheS5mcm9tKHRoaXMuc2V0LmVudHJpZXMoKSkpKVxuICB9XG5cbiAgY29udGFpbnMgKGNpZCkge1xuICAgIGNvbnN0IGNpZFN0ciA9IGNpZC5idWZmZXIudG9TdHJpbmcoKVxuICAgIHJldHVybiB0aGlzLnNldC5nZXQoY2lkU3RyKVxuICB9XG59XG5cbldhbnRsaXN0LkVudHJ5ID0gRW50cnlcbm1vZHVsZS5leHBvcnRzID0gV2FudGxpc3RcbiIsIm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG5cbmZ1bmN0aW9uIGRlYm91bmNlKGZuLCB3YWl0LCBjYWxsRmlyc3QpIHtcbiAgdmFyIHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXdhaXQpIHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIGNhbGxOb3cgPSBjYWxsRmlyc3QgJiYgIXRpbWVvdXQ7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICBpZiAoIWNhbGxOb3cpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH0sIHdhaXQpO1xuXG4gICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBXYW50bGlzdCA9IHJlcXVpcmUoJy4uL3R5cGVzL3dhbnRsaXN0JylcblxuY2xhc3MgTGVkZ2VyIHtcbiAgY29uc3RydWN0b3IgKHBlZXJJZCkge1xuICAgIHRoaXMucGFydG5lciA9IHBlZXJJZFxuICAgIHRoaXMud2FudGxpc3QgPSBuZXcgV2FudGxpc3QoKVxuXG4gICAgdGhpcy5leGNoYW5nZUNvdW50ID0gMFxuICAgIHRoaXMuc2VudFRvUGVlciA9IG5ldyBNYXAoKVxuXG4gICAgdGhpcy5hY2NvdW50aW5nID0ge1xuICAgICAgYnl0ZXNTZW50OiAwLFxuICAgICAgYnl0ZXNSZWN2OiAwXG4gICAgfVxuICB9XG5cbiAgc2VudEJ5dGVzIChuKSB7XG4gICAgdGhpcy5leGNoYW5nZUNvdW50KytcbiAgICB0aGlzLmxhc3RFeGNoYW5nZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKClcbiAgICB0aGlzLmFjY291bnRpbmcuYnl0ZXNTZW50ICs9IG5cbiAgfVxuXG4gIHJlY2VpdmVkQnl0ZXMgKG4pIHtcbiAgICB0aGlzLmV4Y2hhbmdlQ291bnQrK1xuICAgIHRoaXMubGFzdEV4Y2hhbmdlID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKVxuICAgIHRoaXMuYWNjb3VudGluZy5ieXRlc1JlY3YgKz0gblxuICB9XG5cbiAgd2FudHMgKGNpZCwgcHJpb3JpdHkpIHtcbiAgICB0aGlzLndhbnRsaXN0LmFkZChjaWQsIHByaW9yaXR5KVxuICB9XG5cbiAgY2FuY2VsV2FudCAoY2lkKSB7XG4gICAgdGhpcy53YW50bGlzdC5yZW1vdmUoY2lkKVxuICB9XG5cbiAgd2FudGxpc3RDb250YWlucyAoY2lkKSB7XG4gICAgcmV0dXJuIHRoaXMud2FudGxpc3QuY29udGFpbnMoY2lkKVxuICB9XG5cbiAgZGVidFJhdGlvICgpIHtcbiAgICByZXR1cm4gKHRoaXMuYWNjb3VudGluZy5ieXRlc1NlbnQgLyAodGhpcy5hY2NvdW50aW5nLmJ5dGVzUmVjdiArIDEpKSAvLyArMSBpcyB0byBwcmV2ZW50IGRpdmlzaW9uIGJ5IHplcm9cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExlZGdlclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpXG5jb25zdCBCaWcgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKVxuY29uc3QgTW92aW5nQXZlcmFnZSA9IHJlcXVpcmUoJ21vdmluZy1hdmVyYWdlJylcblxuY2xhc3MgU3RhdHMgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoaW5pdGlhbENvdW50ZXJzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLl9xdWV1ZSA9IFtdXG4gICAgdGhpcy5fc3RhdHMgPSB7fVxuXG4gICAgdGhpcy5fZnJlcXVlbmN5TGFzdFRpbWUgPSBEYXRlLm5vdygpXG4gICAgdGhpcy5fZnJlcXVlbmN5QWNjdW11bGF0b3JzID0ge31cbiAgICB0aGlzLl9tb3ZpbmdBdmVyYWdlcyA9IHt9XG5cbiAgICB0aGlzLl91cGRhdGUgPSB0aGlzLl91cGRhdGUuYmluZCh0aGlzKVxuXG4gICAgaW5pdGlhbENvdW50ZXJzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgdGhpcy5fc3RhdHNba2V5XSA9IEJpZygwKVxuICAgICAgdGhpcy5fbW92aW5nQXZlcmFnZXNba2V5XSA9IHt9XG4gICAgICB0aGlzLl9vcHRpb25zLm1vdmluZ0F2ZXJhZ2VJbnRlcnZhbHMuZm9yRWFjaCgoaW50ZXJ2YWwpID0+IHtcbiAgICAgICAgY29uc3QgbWEgPSB0aGlzLl9tb3ZpbmdBdmVyYWdlc1trZXldW2ludGVydmFsXSA9IE1vdmluZ0F2ZXJhZ2UoaW50ZXJ2YWwpXG4gICAgICAgIG1hLnB1c2godGhpcy5fZnJlcXVlbmN5TGFzdFRpbWUsIDApXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLl9lbmFibGVkID0gdGhpcy5fb3B0aW9ucy5lbmFibGVkXG4gIH1cblxuICBlbmFibGUgKCkge1xuICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlXG4gIH1cblxuICBkaXNhYmxlICgpIHtcbiAgICB0aGlzLl9kaXNhYmxlZCA9IHRydWVcbiAgfVxuXG4gIHN0b3AgKCkge1xuICAgIGlmICh0aGlzLl90aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dClcbiAgICB9XG4gIH1cblxuICBnZXQgc25hcHNob3QgKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9zdGF0cylcbiAgfVxuXG4gIGdldCBtb3ZpbmdBdmVyYWdlcyAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX21vdmluZ0F2ZXJhZ2VzKVxuICB9XG5cbiAgcHVzaCAoY291bnRlciwgaW5jKSB7XG4gICAgaWYgKHRoaXMuX2VuYWJsZWQpIHtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2goW2NvdW50ZXIsIGluYywgRGF0ZS5ub3coKV0pXG4gICAgICB0aGlzLl9yZXNldENvbXB1dGVUaW1lb3V0KClcbiAgICB9XG4gIH1cblxuICBfcmVzZXRDb21wdXRlVGltZW91dCAoKSB7XG4gICAgaWYgKHRoaXMuX3RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KVxuICAgIH1cbiAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl91cGRhdGUsIHRoaXMuX25leHRUaW1lb3V0KCkpXG4gIH1cblxuICBfbmV4dFRpbWVvdXQgKCkge1xuICAgIC8vIGNhbGN1bGF0ZSB0aGUgbmVlZCBmb3IgYW4gdXBkYXRlLCBkZXBlbmRpbmcgb24gdGhlIHF1ZXVlIGxlbmd0aFxuICAgIGNvbnN0IHVyZ2VuY3kgPSB0aGlzLl9xdWV1ZS5sZW5ndGggLyB0aGlzLl9vcHRpb25zLmNvbXB1dGVUaHJvdHRsZU1heFF1ZXVlU2l6ZVxuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLl9vcHRpb25zLmNvbXB1dGVUaHJvdHRsZVRpbWVvdXQgKiAoMSAtIHVyZ2VuY3kpLCAwKVxuICB9XG5cbiAgX3VwZGF0ZSAoKSB7XG4gICAgdGhpcy5fdGltZW91dCA9IG51bGxcbiAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoKSB7XG4gICAgICBsZXQgbGFzdFxuICAgICAgd2hpbGUgKHRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBvcCA9IGxhc3QgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpXG4gICAgICAgIHRoaXMuX2FwcGx5T3Aob3ApXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3VwZGF0ZUZyZXF1ZW5jeShsYXN0WzJdKSAvLyBjb250YWlucyB0aW1lc3RhbXAgb2YgbGFzdCBvcFxuXG4gICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuX3N0YXRzKVxuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVGcmVxdWVuY3kgKGxhdGVzdFRpbWUpIHtcbiAgICBjb25zdCB0aW1lRGlmZiA9IGxhdGVzdFRpbWUgLSB0aGlzLl9mcmVxdWVuY3lMYXN0VGltZVxuXG4gICAgT2JqZWN0LmtleXModGhpcy5fc3RhdHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgdGhpcy5fdXBkYXRlRnJlcXVlbmN5Rm9yKGtleSwgdGltZURpZmYsIGxhdGVzdFRpbWUpXG4gICAgfSlcblxuICAgIHRoaXMuX2ZyZXF1ZW5jeUxhc3RUaW1lID0gbGF0ZXN0VGltZVxuICB9XG5cbiAgX3VwZGF0ZUZyZXF1ZW5jeUZvciAoa2V5LCB0aW1lRGlmZk1TLCBsYXRlc3RUaW1lKSB7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLl9mcmVxdWVuY3lBY2N1bXVsYXRvcnNba2V5XSB8fCAwXG4gICAgdGhpcy5fZnJlcXVlbmN5QWNjdW11bGF0b3JzW2tleV0gPSAwXG4gICAgY29uc3QgaHogPSAoY291bnQgLyB0aW1lRGlmZk1TKSAqIDEwMDBcblxuICAgIGxldCBtb3ZpbmdBdmVyYWdlcyA9IHRoaXMuX21vdmluZ0F2ZXJhZ2VzW2tleV1cbiAgICBpZiAoIW1vdmluZ0F2ZXJhZ2VzKSB7XG4gICAgICBtb3ZpbmdBdmVyYWdlcyA9IHRoaXMuX21vdmluZ0F2ZXJhZ2VzW2tleV0gPSB7fVxuICAgIH1cbiAgICB0aGlzLl9vcHRpb25zLm1vdmluZ0F2ZXJhZ2VJbnRlcnZhbHMuZm9yRWFjaCgobW92aW5nQXZlcmFnZUludGVydmFsKSA9PiB7XG4gICAgICBsZXQgbW92aW5nQXZlcmFnZSA9IG1vdmluZ0F2ZXJhZ2VzW21vdmluZ0F2ZXJhZ2VJbnRlcnZhbF1cbiAgICAgIGlmICghbW92aW5nQXZlcmFnZSkge1xuICAgICAgICBtb3ZpbmdBdmVyYWdlID0gbW92aW5nQXZlcmFnZXNbbW92aW5nQXZlcmFnZUludGVydmFsXSA9IE1vdmluZ0F2ZXJhZ2UobW92aW5nQXZlcmFnZUludGVydmFsKVxuICAgICAgfVxuICAgICAgbW92aW5nQXZlcmFnZS5wdXNoKGxhdGVzdFRpbWUsIGh6KVxuICAgIH0pXG4gIH1cblxuICBfYXBwbHlPcCAob3ApIHtcbiAgICBjb25zdCBrZXkgPSBvcFswXVxuICAgIGNvbnN0IGluYyA9IG9wWzFdXG5cbiAgICBpZiAodHlwZW9mIGluYyAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmNyZW1lbnQgbnVtYmVyOicsIGluYylcbiAgICB9XG5cbiAgICBsZXQgblxuXG4gICAgaWYgKCF0aGlzLl9zdGF0cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBuID0gdGhpcy5fc3RhdHNba2V5XSA9IEJpZygwKVxuICAgIH0gZWxzZSB7XG4gICAgICBuID0gdGhpcy5fc3RhdHNba2V5XVxuICAgIH1cbiAgICB0aGlzLl9zdGF0c1trZXldID0gbi5wbHVzKGluYylcblxuICAgIGlmICghdGhpcy5fZnJlcXVlbmN5QWNjdW11bGF0b3JzW2tleV0pIHtcbiAgICAgIHRoaXMuX2ZyZXF1ZW5jeUFjY3VtdWxhdG9yc1trZXldID0gMFxuICAgIH1cbiAgICB0aGlzLl9mcmVxdWVuY3lBY2N1bXVsYXRvcnNba2V5XSArPSBpbmNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRzXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZGVib3VuY2UgPSByZXF1aXJlKCdqdXN0LWRlYm91bmNlLWl0JylcblxuY29uc3QgTWVzc2FnZSA9IHJlcXVpcmUoJy4uL3R5cGVzL21lc3NhZ2UnKVxuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5sb2dnZXJcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBNc2dRdWV1ZSB7XG4gIGNvbnN0cnVjdG9yIChzZWxmUGVlcklkLCBvdGhlclBlZXJJZCwgbmV0d29yaykge1xuICAgIHRoaXMucGVlcklkID0gb3RoZXJQZWVySWRcbiAgICB0aGlzLm5ldHdvcmsgPSBuZXR3b3JrXG4gICAgdGhpcy5yZWZjbnQgPSAxXG5cbiAgICB0aGlzLl9lbnRyaWVzID0gW11cbiAgICB0aGlzLl9sb2cgPSBsb2dnZXIoc2VsZlBlZXJJZCwgJ21zZ3F1ZXVlJywgb3RoZXJQZWVySWQudG9CNThTdHJpbmcoKS5zbGljZSgwLCA4KSlcbiAgICB0aGlzLnNlbmRFbnRyaWVzID0gZGVib3VuY2UodGhpcy5fc2VuZEVudHJpZXMuYmluZCh0aGlzKSwgMjAwKVxuICB9XG5cbiAgYWRkTWVzc2FnZSAobXNnKSB7XG4gICAgaWYgKG1zZy5lbXB0eSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5zZW5kKG1zZylcbiAgfVxuXG4gIGFkZEVudHJpZXMgKGVudHJpZXMpIHtcbiAgICB0aGlzLl9lbnRyaWVzID0gdGhpcy5fZW50cmllcy5jb25jYXQoZW50cmllcylcbiAgICB0aGlzLnNlbmRFbnRyaWVzKClcbiAgfVxuXG4gIF9zZW5kRW50cmllcyAoKSB7XG4gICAgaWYgKCF0aGlzLl9lbnRyaWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgbXNnID0gbmV3IE1lc3NhZ2UoZmFsc2UpXG4gICAgdGhpcy5fZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgaWYgKGVudHJ5LmNhbmNlbCkge1xuICAgICAgICBtc2cuY2FuY2VsKGVudHJ5LmNpZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1zZy5hZGRFbnRyeShlbnRyeS5jaWQsIGVudHJ5LnByaW9yaXR5KVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5fZW50cmllcyA9IFtdXG4gICAgdGhpcy5hZGRNZXNzYWdlKG1zZylcbiAgfVxuXG4gIHNlbmQgKG1zZykge1xuICAgIHRoaXMubmV0d29yay5jb25uZWN0VG8odGhpcy5wZWVySWQsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5fbG9nLmVycm9yKCdjYW50IGNvbm5lY3QgdG8gcGVlciAlczogJXMnLCB0aGlzLnBlZXJJZC50b0I1OFN0cmluZygpLCBlcnIubWVzc2FnZSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xvZygnc2VuZGluZyBtZXNzYWdlJylcbiAgICAgIHRoaXMubmV0d29yay5zZW5kTWVzc2FnZSh0aGlzLnBlZXJJZCwgbXNnLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICB0aGlzLl9sb2cuZXJyb3IoJ3NlbmQgZXJyb3I6ICVzJywgZXJyLm1lc3NhZ2UpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGVuY29kZSA9IHJlcXVpcmUoJy4vZW5jb2RlJylcbmNvbnN0IGQgPSByZXF1aXJlKCcuL2RlY29kZScpXG5cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlXG5leHBvcnRzLmRlY29kZSA9IGQuZGVjb2RlXG5leHBvcnRzLmRlY29kZUZyb21SZWFkZXIgPSBkLmRlY29kZUZyb21SZWFkZXJcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwcm90b25zID0gcmVxdWlyZSgncHJvdG9ucycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuXG5jb25zdCBwYiA9IHByb3RvbnMocmVxdWlyZSgnLi9yZWNvcmQucHJvdG8nKSkuUmVjb3JkXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuXG5jbGFzcyBSZWNvcmQge1xuICAvKipcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtrZXldXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbdmFsdWVdXG4gICAqIEBwYXJhbSB7RGF0ZX0gW3JlY3Z0aW1lXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGtleSwgdmFsdWUsIHJlY3Z0aW1lKSB7XG4gICAgaWYgKGtleSkge1xuICAgICAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihrZXkpLCAna2V5IG11c3QgYmUgYSBCdWZmZXInKVxuICAgIH1cblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSksICd2YWx1ZSBtdXN0IGJlIGEgYnVmZmVyJylcbiAgICB9XG5cbiAgICB0aGlzLmtleSA9IGtleVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMudGltZVJlY2VpdmVkID0gcmVjdnRpbWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7QnVmZmVyfVxuICAgKi9cbiAgc2VyaWFsaXplICgpIHtcbiAgICByZXR1cm4gcGIuZW5jb2RlKHRoaXMucHJlcGFyZVNlcmlhbGl6ZSgpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgb2JqZWN0IGZvcm1hdCByZWFkeSB0byBiZSBnaXZlbiB0byB0aGUgcHJvdG9idWYgbGlicmFyeS5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIHByZXBhcmVTZXJpYWxpemUgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICB0aW1lUmVjZWl2ZWQ6IHRoaXMudGltZVJlY2VpdmVkICYmIHV0aWxzLnRvUkZDMzMzOSh0aGlzLnRpbWVSZWNlaXZlZClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgcHJvdG9idWYgZW5jb2RlZCByZWNvcmQuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSByYXdcbiAgICogQHJldHVybnMge1JlY29yZH1cbiAgICovXG4gIHN0YXRpYyBkZXNlcmlhbGl6ZSAocmF3KSB7XG4gICAgY29uc3QgZGVjID0gcGIuZGVjb2RlKHJhdylcbiAgICByZXR1cm4gUmVjb3JkLmZyb21EZXNlcmlhbGl6ZWQoZGVjKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJlY29yZCBmcm9tIHRoZSByYXcgb2JqZWN0IHJldHVybmVkIGZyb20gdGhlIHByb3RvYnVmIGxpYnJhcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogQHJldHVybnMge1JlY29yZH1cbiAgICovXG4gIHN0YXRpYyBmcm9tRGVzZXJpYWxpemVkIChvYmopIHtcbiAgICBsZXQgcmVjdnRpbWVcbiAgICBpZiAob2JqLnRpbWVSZWNlaXZlZCkge1xuICAgICAgcmVjdnRpbWUgPSB1dGlscy5wYXJzZVJGQzMzMzkob2JqLnRpbWVSZWNlaXZlZClcbiAgICB9XG5cbiAgICBjb25zdCByZWMgPSBuZXcgUmVjb3JkKFxuICAgICAgb2JqLmtleSwgb2JqLnZhbHVlLCByZWN2dGltZVxuICAgIClcblxuICAgIHJldHVybiByZWNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY29yZFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJzcGxpdCA9IHJlcXVpcmUoJ2J1ZmZlci1zcGxpdCcpXG5jb25zdCBlcnJjb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuXG4vKipcbiAqIFNlbGVjdCB0aGUgYmVzdCByZWNvcmQgb3V0IG9mIHRoZSBnaXZlbiByZWNvcmRzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxlY3RvcnNcbiAqIEBwYXJhbSB7QnVmZmVyfSBrXG4gKiBAcGFyYW0ge0FycmF5PEJ1ZmZlcj59IHJlY29yZHNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIGluZGV4IG9mIHRoZSBiZXN0IHJlY29yZC5cbiAqL1xuY29uc3QgYmVzdFJlY29yZCA9IChzZWxlY3RvcnMsIGssIHJlY29yZHMpID0+IHtcbiAgaWYgKHJlY29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc3QgZXJyTXNnID0gYE5vIHJlY29yZHMgZ2l2ZW5gXG5cbiAgICB0aHJvdyBlcnJjb2RlKG5ldyBFcnJvcihlcnJNc2cpLCAnRVJSX05PX1JFQ09SRFNfUkVDRUlWRUQnKVxuICB9XG5cbiAgY29uc3QgcGFydHMgPSBic3BsaXQoaywgQnVmZmVyLmZyb20oJy8nKSlcblxuICBpZiAocGFydHMubGVuZ3RoIDwgMykge1xuICAgIGNvbnN0IGVyck1zZyA9IGBSZWNvcmQga2V5IGRvZXMgbm90IGhhdmUgYSBzZWxlY3RvciBmdW5jdGlvbmBcblxuICAgIHRocm93IGVycmNvZGUobmV3IEVycm9yKGVyck1zZyksICdFUlJfTk9fU0VMRUNUT1JfRlVOQ1RJT05fRk9SX1JFQ09SRF9LRVknKVxuICB9XG5cbiAgY29uc3Qgc2VsZWN0b3IgPSBzZWxlY3RvcnNbcGFydHNbMV0udG9TdHJpbmcoKV1cblxuICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgY29uc3QgZXJyTXNnID0gYFVucmVjb2duaXplZCBrZXkgcHJlZml4OiAke3BhcnRzWzFdfWBcblxuICAgIHRocm93IGVycmNvZGUobmV3IEVycm9yKGVyck1zZyksICdFUlJfVU5SRUNPR05JWkVEX0tFWV9QUkVGSVgnKVxuICB9XG5cbiAgcmV0dXJuIHNlbGVjdG9yKGssIHJlY29yZHMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBiZXN0UmVjb3JkOiBiZXN0UmVjb3JkLFxuICBzZWxlY3RvcnM6IHJlcXVpcmUoJy4vc2VsZWN0b3JzJylcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBic3BsaXQgPSByZXF1aXJlKCdidWZmZXItc3BsaXQnKVxuY29uc3QgZXJyY29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxuLyoqXG4gKiBDaGVja3MgYSByZWNvcmQgYW5kIGVuc3VyZXMgaXQgaXMgc3RpbGwgdmFsaWQuXG4gKiBJdCBydW5zIHRoZSBuZWVkZWQgdmFsaWRhdG9ycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsaWRhdG9yc1xuICogQHBhcmFtIHtSZWNvcmR9IHJlY29yZFxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5jb25zdCB2ZXJpZnlSZWNvcmQgPSAodmFsaWRhdG9ycywgcmVjb3JkLCBjYWxsYmFjaykgPT4ge1xuICBjb25zdCBrZXkgPSByZWNvcmQua2V5XG4gIGNvbnN0IHBhcnRzID0gYnNwbGl0KGtleSwgQnVmZmVyLmZyb20oJy8nKSlcblxuICBpZiAocGFydHMubGVuZ3RoIDwgMykge1xuICAgIC8vIE5vIHZhbGlkYXRvciBhdmFpbGFibGVcbiAgICByZXR1cm4gY2FsbGJhY2soKVxuICB9XG5cbiAgY29uc3QgdmFsaWRhdG9yID0gdmFsaWRhdG9yc1twYXJ0c1sxXS50b1N0cmluZygpXVxuXG4gIGlmICghdmFsaWRhdG9yKSB7XG4gICAgY29uc3QgZXJyTXNnID0gYEludmFsaWQgcmVjb3JkIGtleXR5cGVgXG5cbiAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9JTlZBTElEX1JFQ09SRF9LRVlfVFlQRScpKVxuICB9XG5cbiAgdmFsaWRhdG9yLmZ1bmMoa2V5LCByZWNvcmQudmFsdWUsIGNhbGxiYWNrKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmVyaWZ5UmVjb3JkOiB2ZXJpZnlSZWNvcmQsXG4gIHZhbGlkYXRvcnM6IHJlcXVpcmUoJy4vdmFsaWRhdG9ycycpXG59XG4iLCIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBDb252ZXJ0IGEgSmF2YVNjcmlwdCBkYXRlIGludG8gYW4gYFJGQzMzMzlOYW5vYCBmb3JtYXR0ZWRcbiAqIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge0RhdGV9IHRpbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbm1vZHVsZS5leHBvcnRzLnRvUkZDMzMzOSA9ICh0aW1lKSA9PiB7XG4gIGNvbnN0IHllYXIgPSB0aW1lLmdldFVUQ0Z1bGxZZWFyKClcbiAgY29uc3QgbW9udGggPSBTdHJpbmcodGltZS5nZXRVVENNb250aCgpICsgMSkucGFkU3RhcnQoMiwgJzAnKVxuICBjb25zdCBkYXkgPSBTdHJpbmcodGltZS5nZXRVVENEYXRlKCkpLnBhZFN0YXJ0KDIsICcwJylcbiAgY29uc3QgaG91ciA9IFN0cmluZyh0aW1lLmdldFVUQ0hvdXJzKCkpLnBhZFN0YXJ0KDIsICcwJylcbiAgY29uc3QgbWludXRlID0gU3RyaW5nKHRpbWUuZ2V0VVRDTWludXRlcygpKS5wYWRTdGFydCgyLCAnMCcpXG4gIGNvbnN0IHNlY29uZHMgPSBTdHJpbmcodGltZS5nZXRVVENTZWNvbmRzKCkpLnBhZFN0YXJ0KDIsICcwJylcbiAgY29uc3QgbWlsbGlzZWNvbmRzID0gdGltZS5nZXRVVENNaWxsaXNlY29uZHMoKVxuICBjb25zdCBuYW5vc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAqIDEwMDAgKiAxMDAwXG5cbiAgcmV0dXJuIGAke3llYXJ9LSR7bW9udGh9LSR7ZGF5fVQke2hvdXJ9OiR7bWludXRlfToke3NlY29uZHN9LiR7bmFub3NlY29uZHN9WmBcbn1cblxuLyoqXG4gKiBQYXJzZXMgYSBkYXRlIHN0cmluZyBmb3JtYXR0ZWQgYXMgYFJGQzMzMzlOYW5vYCBpbnRvIGFcbiAqIEphdmFTY3JpcHQgRGF0ZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRpbWVcbiAqIEByZXR1cm5zIHtEYXRlfVxuICovXG5tb2R1bGUuZXhwb3J0cy5wYXJzZVJGQzMzMzkgPSAodGltZSkgPT4ge1xuICBjb25zdCByZmMzMzM5TWF0Y2hlciA9IG5ldyBSZWdFeHAoXG4gICAgLy8gMjAwNi0wMS0wMlRcbiAgICAnKFxcXFxkezR9KS0oXFxcXGR7Mn0pLShcXFxcZHsyfSlUJyArXG4gICAgLy8gMTU6MDQ6MDVcbiAgICAnKFxcXFxkezJ9KTooXFxcXGR7Mn0pOihcXFxcZHsyfSknICtcbiAgICAvLyAuOTk5OTk5OTk5WlxuICAgICdcXFxcLihcXFxcZCspWidcbiAgKVxuICBjb25zdCBtID0gU3RyaW5nKHRpbWUpLnRyaW0oKS5tYXRjaChyZmMzMzM5TWF0Y2hlcilcblxuICBpZiAoIW0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZm9ybWF0JylcbiAgfVxuXG4gIGNvbnN0IHllYXIgPSBwYXJzZUludChtWzFdLCAxMClcbiAgY29uc3QgbW9udGggPSBwYXJzZUludChtWzJdLCAxMCkgLSAxXG4gIGNvbnN0IGRhdGUgPSBwYXJzZUludChtWzNdLCAxMClcbiAgY29uc3QgaG91ciA9IHBhcnNlSW50KG1bNF0sIDEwKVxuICBjb25zdCBtaW51dGUgPSBwYXJzZUludChtWzVdLCAxMClcbiAgY29uc3Qgc2Vjb25kID0gcGFyc2VJbnQobVs2XSwgMTApXG4gIGNvbnN0IG1pbGxpc2Vjb25kID0gcGFyc2VJbnQobVs3XS5zbGljZSgwLCAtNiksIDEwKVxuXG4gIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF0ZSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kKSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLkVSUl9JUE5TX0VYUElSRURfUkVDT1JEID0gJ0VSUl9JUE5TX0VYUElSRURfUkVDT1JEJ1xuZXhwb3J0cy5FUlJfVU5SRUNPR05JWkVEX1ZBTElESVRZID0gJ0VSUl9VTlJFQ09HTklaRURfVkFMSURJVFknXG5leHBvcnRzLkVSUl9TSUdOQVRVUkVfQ1JFQVRJT04gPSAnRVJSX1NJR05BVFVSRV9DUkVBVElPTidcbmV4cG9ydHMuRVJSX1NJR05BVFVSRV9WRVJJRklDQVRJT04gPSAnRVJSX1NJR05BVFVSRV9WRVJJRklDQVRJT04nXG5leHBvcnRzLkVSUl9VTlJFQ09HTklaRURfRk9STUFUID0gJ0VSUl9VTlJFQ09HTklaRURfRk9STUFUJ1xuZXhwb3J0cy5FUlJfUEVFUl9JRF9GUk9NX1BVQkxJQ19LRVkgPSAnRVJSX1BFRVJfSURfRlJPTV9QVUJMSUNfS0VZJ1xuZXhwb3J0cy5FUlJfUFVCTElDX0tFWV9GUk9NX0lEID0gJ0VSUl9QVUJMSUNfS0VZX0ZST01fSUQnXG5leHBvcnRzLkVSUl9VTkRFRklORURfUEFSQU1FVEVSID0gJ0VSUl9VTkRFRklORURfUEFSQU1FVEVSJ1xuIiwiLyoqXG4gKiBUaW1lc3RhbXAgZm9yIDY0LWJpdCB0aW1lX3QsIG5hbm9zZWNvbmQgcHJlY2lzaW9uIGFuZCBzdHJmdGltZVxuICpcbiAqIEBhdXRob3IgWXVzdWtlIEthd2FzYWtpXG4gKiBAbGljZW5zZSBNSVRcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2thd2FuZXQvdGltZXN0YW1wLW5hbm9cbiAqL1xuXG52YXIgVGltZXN0YW1wID0gKGZ1bmN0aW9uKCkge1xuICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIG1vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBUaW1lc3RhbXA7XG5cbiAgdmFyIFNFQ19EQVkgPSAyNCAqIDM2MDA7IC8vIHNlY29uZHMgcGVyIGRheVxuICB2YXIgWUVBUl9TTE9UID0gMzIwMDsgLy8geWVhcnMgcGVyIHNsb3RcbiAgdmFyIERBWV9TTE9UID0gKDM2NSAqIDQwMCArIDk3KSAqIFlFQVJfU0xPVCAvIDQwMDsgLy8gZGF5cyBwZXIgc2xvdFxuICB2YXIgU0VDX1NMT1QgPSBTRUNfREFZICogREFZX1NMT1Q7IC8vIHNlY29uZHMgcGVyIHNsb3RcbiAgdmFyIE1TRUNfU0xPVCA9IFNFQ19TTE9UICogMTAwMDsgLy8gbXNlY29uZHMgcGVyIHNsb3RcblxuICAvLyAxNS45LjEuMSBUaW1lIFZhbHVlcyBhbmQgVGltZSBSYW5nZVxuICAvLyBUaGUgYWN0dWFsIHJhbmdlIG9mIHRpbWVzIHN1cHBvcnRlZCBieSBFQ01BU2NyaXB0IERhdGUgb2JqZWN0cyBpc1xuICAvLyBleGFjdGx5IOKAkzEwMCwwMDAsMDAwIGRheXMgdG8gMTAwLDAwMCwwMDAgZGF5cyBtZWFzdXJlZCByZWxhdGl2ZSB0b1xuICAvLyBtaWRuaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIDAxIEphbnVhcnksIDE5NzAgVVRDLlxuICB2YXIgTUFYX01TRUMgPSAxMDAwICogMTAwMDAgKiAxMDAwMCAqIFNFQ19EQVk7XG5cbiAgdmFyIEJJVDI0ID0gMHgxMDAwMDAwO1xuICB2YXIgQklUMzIgPSAweDEwMDAwICogMHgxMDAwMDtcbiAgdmFyIERFQzYgPSAxMDAwICogMTAwMDtcbiAgdmFyIERFQzkgPSAxMDAwICogMTAwMCAqIDEwMDA7XG4gIHZhciBaRVJPOSA9IFwiMDAwMDAwMDAwXCI7XG5cbiAgdmFyIHRydW5jID0gTWF0aC50cnVuYyB8fCBNYXRoX3RydW5jO1xuICB2YXIgUCA9IFRpbWVzdGFtcC5wcm90b3R5cGU7XG5cbiAgLy8gc3RhdGljIG1ldGhvZHNcbiAgVGltZXN0YW1wLmZyb21EYXRlID0gZnJvbURhdGU7XG4gIFRpbWVzdGFtcC5mcm9tSW50NjRCRSA9IGJ1aWxkRnJvbUludDY0KDAsIDEsIDIsIDMsIDAsIDQpO1xuICBUaW1lc3RhbXAuZnJvbUludDY0TEUgPSBidWlsZEZyb21JbnQ2NCgzLCAyLCAxLCAwLCA0LCAwKTtcbiAgVGltZXN0YW1wLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xuICBUaW1lc3RhbXAuZnJvbVRpbWVUID0gZnJvbVRpbWVUO1xuXG4gIC8vIHByaXZhdGUgcHJvcGVydGllc1xuICBQLnllYXIgPSAwOyAvLyBPZmZzZXQgbnVtYmVyIGZvciB5ZWFyIHByZWNpc2lvblxuICBQLnRpbWUgPSAwOyAvLyBNaWxsaXNlY29uZHMgZnJvbSBlcG9jaFxuICBQLm5hbm8gPSAwOyAvLyBPZmZzZXQgbnVtYmVyIGZvciBuYW5vc2Vjb25kIHByZWNpc2lvblxuXG4gIC8vIGluc3RhbmNlIG1ldGhvZHNcbiAgUC5hZGROYW5vID0gYWRkTmFubztcbiAgUC5nZXROYW5vID0gZ2V0TmFubztcbiAgUC5nZXRUaW1lVCA9IGdldFRpbWVUO1xuICBQLmdldFllYXIgPSBnZXRZZWFyO1xuICBQLnRvRGF0ZSA9IHRvRGF0ZTtcbiAgUC50b0pTT04gPSB0b0pTT047XG4gIFAudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgUC53cml0ZUludDY0QkUgPSBidWlsZFdyaXRlSW50NjQoMCwgMSwgMiwgMywgMCwgNCk7XG4gIFAud3JpdGVJbnQ2NExFID0gYnVpbGRXcml0ZUludDY0KDMsIDIsIDEsIDAsIDQsIDApO1xuXG4gIHZhciBGTVRfSlNPTiA9IFwiJVktJW0tJWRUJUg6JU06JVMuJU5aXCI7XG5cbiAgdmFyIEZNVF9NT05USCA9IFtcbiAgICBcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLFxuICAgIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJcbiAgXTtcblxuICB2YXIgRk1UX0RBWSA9IFtcbiAgICBcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXG4gIF07XG5cbiAgdmFyIEZNVF9TVFJJTkcgPSB7XG4gICAgXCIlXCI6IFwiJVwiLFxuICAgIEY6IFwiJVktJW0tJWRcIixcbiAgICBuOiBcIlxcblwiLFxuICAgIFI6IFwiJUg6JU1cIixcbiAgICBUOiBcIiVIOiVNOiVTXCIsXG4gICAgdDogXCJcXHRcIixcbiAgICBYOiBcIiVUXCIsXG4gICAgWjogXCJHTVRcIixcbiAgICB6OiBcIiswMDAwXCJcbiAgfTtcblxuICByZXR1cm4gVGltZXN0YW1wO1xuXG4gIGZ1bmN0aW9uIFRpbWVzdGFtcCh0aW1lLCBuYW5vLCB5ZWFyKSB7XG4gICAgdmFyIHRzID0gdGhpcztcbiAgICBpZiAoISh0cyBpbnN0YW5jZW9mIFRpbWVzdGFtcCkpIHJldHVybiBuZXcgVGltZXN0YW1wKHRpbWUsIG5hbm8sIHllYXIpO1xuICAgIHRzLnRpbWUgPSArdGltZSB8fCAwO1xuICAgIHRzLm5hbm8gPSArbmFubyB8fCAwO1xuICAgIHRzLnllYXIgPSAreWVhciB8fCAwO1xuICAgIG5vcm1hbGl6ZSh0cyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRZZWFyKCkge1xuICAgIHZhciB5ZWFyID0gdGhpcy50b0RhdGUoKS5nZXRVVENGdWxsWWVhcigpO1xuICAgIHJldHVybiB5ZWFyICsgdGhpcy55ZWFyO1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplKHRzKSB7XG4gICAgdmFyIHllYXIgPSB0cy55ZWFyO1xuICAgIHZhciB0aW1lID0gdHMudGltZTtcbiAgICB2YXIgbmFubyA9IHRzLm5hbm87XG4gICAgdmFyIGNoYW5nZWQ7XG4gICAgdmFyIHNsb3Q7XG5cbiAgICAvLyBub3JtYWxpemUgbmFub1xuICAgIGlmIChuYW5vIDwgMCB8fCBERUM2IDw9IG5hbm8pIHtcbiAgICAgIHZhciBuID0gTWF0aC5mbG9vcihuYW5vIC8gREVDNik7XG4gICAgICBuYW5vIC09IG4gKiBERUM2O1xuICAgICAgdGltZSArPSBuO1xuICAgICAgY2hhbmdlZCA9IDE7XG4gICAgfVxuXG4gICAgdmFyIHkgPSB5ZWFyICUgWUVBUl9TTE9UO1xuICAgIGlmICh0aW1lIDwgLU1BWF9NU0VDIHx8IE1BWF9NU0VDIDwgdGltZSB8fCB5KSB7XG4gICAgICAvLyBzaHJpbmsgdGltZSBpbnRvIHRoZSBtaW5pbWFsIHNsb3RcbiAgICAgIHNsb3QgPSB0cnVuYyh0aW1lIC8gTVNFQ19TTE9UKTtcbiAgICAgIGlmIChzbG90KSB7XG4gICAgICAgIHllYXIgKz0gc2xvdCAqIFlFQVJfU0xPVDtcbiAgICAgICAgdGltZSAtPSBzbG90ICogTVNFQ19TTE9UO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgeWVhciBvZmZzZXQgc21hbGxlciB0aGFuIGEgc2xvdFxuICAgICAgdmFyIGR0ID0gbmV3RGF0ZSh0aW1lKTtcbiAgICAgIGR0LnNldFVUQ0Z1bGxZZWFyKHkgKyBkdC5nZXRVVENGdWxsWWVhcigpKTtcbiAgICAgIHllYXIgLT0geTtcbiAgICAgIHRpbWUgPSArZHQ7XG5cbiAgICAgIC8vIHVzZSBmdWxsIHJhbmdlIG9mIDEwMCBtaWxsaW9uIGRheXMuXG4gICAgICBzbG90ID0gdHJ1bmMoeWVhciAvIFlFQVJfU0xPVCk7XG4gICAgICB2YXIgdG90YWwgPSB0aW1lICsgc2xvdCAqIE1TRUNfU0xPVDtcbiAgICAgIGlmIChzbG90ICYmIC1NQVhfTVNFQyA8PSB0b3RhbCAmJiB0b3RhbCA8PSBNQVhfTVNFQykge1xuICAgICAgICB5ZWFyIC09IHNsb3QgKiBZRUFSX1NMT1Q7XG4gICAgICAgIHRpbWUgPSB0b3RhbDtcbiAgICAgIH1cblxuICAgICAgY2hhbmdlZCA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRzLnllYXIgPSB5ZWFyO1xuICAgICAgdHMudGltZSA9IHRpbWU7XG4gICAgICB0cy5uYW5vID0gbmFubztcbiAgICB9XG5cbiAgICByZXR1cm4gdHM7XG4gIH1cblxuICBmdW5jdGlvbiB0b0RhdGUoKSB7XG4gICAgdmFyIHRzID0gbm9ybWFsaXplKHRoaXMpO1xuICAgIHJldHVybiBuZXdEYXRlKHRzLnRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV3RGF0ZSh0aW1lKSB7XG4gICAgdmFyIGR0ID0gbmV3IERhdGUoMCk7XG4gICAgZHQuc2V0VGltZSh0aW1lKTtcbiAgICByZXR1cm4gZHQ7XG4gIH1cblxuICBmdW5jdGlvbiBhZGROYW5vKG5hbm8pIHtcbiAgICB0aGlzLm5hbm8gKz0gK25hbm8gfHwgMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5hbm8oKSB7XG4gICAgdmFyIHRzID0gbm9ybWFsaXplKHRoaXMpO1xuICAgIHJldHVybiAoKHRzLnRpbWUgJSAxMDAwKSAqIERFQzYgKyAoK3RzLm5hbm8pICsgREVDOSkgJSBERUM5O1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgICB2YXIgdGltZTtcbiAgICB2YXIgdHMgPSBuZXcgVGltZXN0YW1wKCk7XG4gICAgc3RyaW5nICs9IFwiXCI7XG5cbiAgICB2YXIgYXJyYXkgPSBzdHJpbmcucmVwbGFjZSgvXlxccypbK1xcLV0/XFxkKy8sIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICB2YXIgeWVhciA9ICttYXRjaDtcbiAgICAgIC8vIFVzZSBvbmx5IHllYXJzIGFyb3VuZCAxOTcwIHRvIGF2b2lkIERhdGUncyB0ZXJyaWJsZSBiZWhhdmlvcjpcbiAgICAgIC8vIDE1LjkuNC4zIERhdGUuVVRDXG4gICAgICAvLyBJZiB5IGlzIG5vdCBOYU4gYW5kIDAgPD0geSA8PSA5OSwgdGhlbiBsZXQgeXIgYmUgMTkwMCt5XG4gICAgICB2YXIgeSA9IDE5NzAgKyAoKHllYXIgLSAxOTcwKSAlIDQwMCk7XG4gICAgICB0cy55ZWFyID0geWVhciAtIHk7XG4gICAgICByZXR1cm4geTtcbiAgICB9KS5yZXBsYWNlKC8oPzpafChbK1xcLV1cXGR7Mn0pOj8oXFxkezJ9KSkkLywgZnVuY3Rpb24obWF0Y2gsIGhvdXIsIG1pbikge1xuICAgICAgLy8gdGltZSB6b25lXG4gICAgICBpZiAoaG91ciA8IDApIG1pbiAqPSAtMTtcbiAgICAgIHRpbWUgPSAoKCtob3VyKSAqIDYwICsgKCttaW4pKSAqIDYwMDAwO1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfSkucmVwbGFjZSgvXFwuXFxkKyQvLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgLy8gbmFub3NlY29uZHNcbiAgICAgIHRzLm5hbm8gPSArKChtYXRjaCArIFpFUk85KS5zdWJzdHIoMSwgOSkpO1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfSkuc3BsaXQoL1xcRCsvKTtcblxuICAgIGlmIChhcnJheS5sZW5ndGggPiAxKSB7XG4gICAgICBhcnJheVsxXS0tOyAvLyBtb250aCBzdGFydHMgZnJvbSAwXG4gICAgfSBlbHNlIHtcbiAgICAgIGFycmF5WzFdID0gMDtcbiAgICB9XG5cbiAgICB0cy50aW1lID0gdGltZSA9IERhdGUuVVRDLmFwcGx5KERhdGUsIGFycmF5KSAtICh0aW1lIHx8IDApO1xuXG4gICAgaWYgKGlzTmFOKHRpbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBEYXRlXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub3JtYWxpemUodHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbURhdGUoZGF0ZSkge1xuICAgIHJldHVybiBuZXcgVGltZXN0YW1wKCtkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21UaW1lVCh0aW1lKSB7XG4gICAgcmV0dXJuIGZyb21UaW1lKHRpbWUsIDApO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbVRpbWUobG93LCBoaWdoKSB7XG4gICAgaGlnaCB8PSAwO1xuICAgIGhpZ2ggKj0gQklUMzI7XG4gICAgbG93ID0gK2xvdyB8fCAwO1xuXG4gICAgLy8gc2xvdCBjb3VudFxuICAgIHZhciBzbG90ID0gdHJ1bmMoaGlnaCAvIFNFQ19TTE9UKSArIHRydW5jKGxvdyAvIFNFQ19TTE9UKTtcblxuICAgIC8vIHNlY29uZHMgd2l0aGluIHNsb3RcbiAgICB2YXIgc2Vjb25kID0gKGhpZ2ggJSBTRUNfU0xPVCkgKyAobG93ICUgU0VDX1NMT1QpO1xuXG4gICAgLy8gc2xvdCBvZmZzZXRcbiAgICB2YXIgb2Zmc2V0ID0gdHJ1bmMoc2Vjb25kIC8gU0VDX1NMT1QpO1xuICAgIGlmIChvZmZzZXQpIHtcbiAgICAgIHNsb3QgKz0gb2Zmc2V0O1xuICAgICAgc2Vjb25kIC09IG9mZnNldCAqIFNFQ19TTE9UO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVGltZXN0YW1wKHNlY29uZCAqIDEwMDAsIDAsIHNsb3QgKiBZRUFSX1NMT1QpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGltZVQoKSB7XG4gICAgdmFyIHRzID0gbm9ybWFsaXplKHRoaXMpO1xuICAgIHZhciB0aW1lID0gTWF0aC5mbG9vcih0cy50aW1lIC8gMTAwMCk7XG5cbiAgICB2YXIgeWVhciA9IHRzLnllYXI7XG4gICAgaWYgKHllYXIpIHRpbWUgKz0geWVhciAqIERBWV9TTE9UICogU0VDX0RBWSAvIFlFQVJfU0xPVDtcblxuICAgIC8vIHRoaXMgbWF5IGxvb3NlIHNvbWUgYml0cyBvdmVyIHRoYW4gNTMgYml0IHByZWNpc2lvblxuICAgIHJldHVybiB0aW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCkucmVwbGFjZSgvMHsxLDZ9WiQvLCBcIlpcIik7XG4gIH1cblxuICBmdW5jdGlvbiB0b1N0cmluZyhmb3JtYXQpIHtcbiAgICB2YXIgdHMgPSB0aGlzO1xuICAgIHZhciBkdCA9IHRzLnRvRGF0ZSgpO1xuICAgIHZhciBtYXAgPSB7XG4gICAgICBIOiBILFxuICAgICAgTDogTCxcbiAgICAgIE06IE0sXG4gICAgICBOOiBOLFxuICAgICAgUzogUyxcbiAgICAgIFk6IFksXG4gICAgICBhOiBhLFxuICAgICAgYjogYixcbiAgICAgIGQ6IGQsXG4gICAgICBlOiBlLFxuICAgICAgbTogbVxuICAgIH07XG5cbiAgICByZXR1cm4gc3RyZnRpbWUoZm9ybWF0IHx8IEZNVF9KU09OKTtcblxuICAgIGZ1bmN0aW9uIHN0cmZ0aW1lKGZvcm1hdCkge1xuICAgICAgcmV0dXJuIGZvcm1hdC5yZXBsYWNlKC8lLi9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICB2YXIgbSA9IG1hdGNoWzFdO1xuICAgICAgICB2YXIgYyA9IEZNVF9TVFJJTkdbbV07XG4gICAgICAgIHZhciBmID0gbWFwW21dO1xuICAgICAgICByZXR1cm4gYyA/IHN0cmZ0aW1lKGMpIDogZiA/IGYoKSA6IG1hdGNoO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gWSgpIHtcbiAgICAgIHZhciB5ZWFyID0gdHMuZ2V0WWVhcigpO1xuICAgICAgaWYgKHllYXIgPiA5OTk5OTkpIHtcbiAgICAgICAgcmV0dXJuIFwiK1wiICsgeWVhcjtcbiAgICAgIH0gZWxzZSBpZiAoeWVhciA+IDk5OTkpIHtcbiAgICAgICAgcmV0dXJuIFwiK1wiICsgcGFkKHllYXIsIDYpO1xuICAgICAgfSBlbHNlIGlmICh5ZWFyID49IDApIHtcbiAgICAgICAgcmV0dXJuIHBhZCh5ZWFyLCA0KTtcbiAgICAgIH0gZWxzZSBpZiAoeWVhciA+PSAtOTk5OTk5KSB7XG4gICAgICAgIHJldHVybiBcIi1cIiArIHBhZCgteWVhciwgNik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geWVhcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtKCkge1xuICAgICAgcmV0dXJuIHBhZDIoZHQuZ2V0VVRDTW9udGgoKSArIDEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGQoKSB7XG4gICAgICByZXR1cm4gcGFkMihkdC5nZXRVVENEYXRlKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICByZXR1cm4gcGFkUyhkdC5nZXRVVENEYXRlKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEgoKSB7XG4gICAgICByZXR1cm4gcGFkMihkdC5nZXRVVENIb3VycygpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBNKCkge1xuICAgICAgcmV0dXJuIHBhZDIoZHQuZ2V0VVRDTWludXRlcygpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBTKCkge1xuICAgICAgcmV0dXJuIHBhZDIoZHQuZ2V0VVRDU2Vjb25kcygpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMKCkge1xuICAgICAgcmV0dXJuIHBhZChkdC5nZXRVVENNaWxsaXNlY29uZHMoKSwgMyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTigpIHtcbiAgICAgIHJldHVybiBwYWQodHMuZ2V0TmFubygpLCA5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhKCkge1xuICAgICAgcmV0dXJuIEZNVF9EQVlbZHQuZ2V0VVRDRGF5KCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGIoKSB7XG4gICAgICByZXR1cm4gRk1UX01PTlRIW2R0LmdldFVUQ01vbnRoKCldO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkV3JpdGVJbnQ2NChwb3MwLCBwb3MxLCBwb3MyLCBwb3MzLCBwb3NILCBwb3NMKSB7XG4gICAgcmV0dXJuIHdyaXRlSW50NjQ7XG5cbiAgICBmdW5jdGlvbiB3cml0ZUludDY0KGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgICB2YXIgdHMgPSBub3JtYWxpemUodGhpcyk7XG4gICAgICBpZiAoIWJ1ZmZlcikgYnVmZmVyID0gbmV3IEFycmF5KDgpO1xuICAgICAgY2hlY2tSYW5nZShidWZmZXIsIG9mZnNldCB8PSAwKTtcblxuICAgICAgdmFyIHNlY29uZCA9IE1hdGguZmxvb3IodHMudGltZSAvIDEwMDApO1xuICAgICAgdmFyIGRheSA9IHRzLnllYXIgKiAoREFZX1NMT1QgKiBTRUNfREFZIC8gWUVBUl9TTE9UKTtcbiAgICAgIHZhciBoaWdoID0gdHJ1bmMoZGF5IC8gQklUMzIpICsgdHJ1bmMoc2Vjb25kIC8gQklUMzIpO1xuICAgICAgdmFyIGxvdyA9IChkYXkgJSBCSVQzMikgKyAoc2Vjb25kICUgQklUMzIpO1xuXG4gICAgICAvLyBzbG90IG9mZnNldFxuICAgICAgdmFyIHNsb3QgPSBNYXRoLmZsb29yKGxvdyAvIEJJVDMyKTtcbiAgICAgIGlmIChzbG90KSB7XG4gICAgICAgIGhpZ2ggKz0gc2xvdDtcbiAgICAgICAgbG93IC09IHNsb3QgKiBCSVQzMjtcbiAgICAgIH1cblxuICAgICAgd3JpdGVVaW50MzIoYnVmZmVyLCBvZmZzZXQgKyBwb3NILCBoaWdoKTtcbiAgICAgIHdyaXRlVWludDMyKGJ1ZmZlciwgb2Zmc2V0ICsgcG9zTCwgbG93KTtcbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JpdGVVaW50MzIoYnVmZmVyLCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICBidWZmZXJbb2Zmc2V0ICsgcG9zMF0gPSAodmFsdWUgPj4gMjQpICYgMjU1O1xuICAgICAgYnVmZmVyW29mZnNldCArIHBvczFdID0gKHZhbHVlID4+IDE2KSAmIDI1NTtcbiAgICAgIGJ1ZmZlcltvZmZzZXQgKyBwb3MyXSA9ICh2YWx1ZSA+PiA4KSAmIDI1NTtcbiAgICAgIGJ1ZmZlcltvZmZzZXQgKyBwb3MzXSA9IHZhbHVlICYgMjU1O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkRnJvbUludDY0KHBvczAsIHBvczEsIHBvczIsIHBvczMsIHBvc0gsIHBvc0wpIHtcbiAgICByZXR1cm4gZnJvbUludDY0O1xuXG4gICAgZnVuY3Rpb24gZnJvbUludDY0KGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgICBjaGVja1JhbmdlKGJ1ZmZlciwgb2Zmc2V0IHw9IDApO1xuICAgICAgdmFyIGhpZ2ggPSByZWFkVWludDMyKGJ1ZmZlciwgb2Zmc2V0ICsgcG9zSCk7XG4gICAgICB2YXIgbG93ID0gcmVhZFVpbnQzMihidWZmZXIsIG9mZnNldCArIHBvc0wpO1xuICAgICAgcmV0dXJuIGZyb21UaW1lKGxvdywgaGlnaCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFVpbnQzMihidWZmZXIsIG9mZnNldCkge1xuICAgICAgcmV0dXJuIChidWZmZXJbb2Zmc2V0ICsgcG9zMF0gKiBCSVQyNCkgK1xuICAgICAgICAoKGJ1ZmZlcltvZmZzZXQgKyBwb3MxXSA8PCAxNikgfFxuICAgICAgICAgIChidWZmZXJbb2Zmc2V0ICsgcG9zMl0gPDwgOCkgfFxuICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBwb3MzXSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tSYW5nZShidWZmZXIsIG9mZnNldCkge1xuICAgIHZhciBsYXN0ID0gYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGg7XG4gICAgaWYgKGxhc3QgPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgQnVmZmVyXCIpO1xuICAgIGlmIChsYXN0IDwgb2Zmc2V0ICsgOCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJPdXQgb2YgcmFuZ2VcIik7XG4gIH1cblxuICBmdW5jdGlvbiBNYXRoX3RydW5jKHgpIHtcbiAgICB2YXIgbiA9IHggLSB4ICUgMTtcbiAgICByZXR1cm4gbiA9PT0gMCAmJiAoeCA8IDAgfHwgKHggPT09IDAgJiYgKDEgLyB4ICE9PSAxIC8gMCkpKSA/IC0wIDogbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhZFModikge1xuICAgIHJldHVybiAodiA+IDkgPyBcIlwiIDogXCIgXCIpICsgKHYgfCAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhZDIodikge1xuICAgIHJldHVybiAodiA+IDkgPyBcIlwiIDogXCIwXCIpICsgKHYgfCAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhZCh2LCBsZW4pIHtcbiAgICByZXR1cm4gKFpFUk85ICsgKHYgfCAwKSkuc3Vic3RyKC1sZW4pO1xuICB9XG59KSgpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHByb3RvbnMgPSByZXF1aXJlKCdwcm90b25zJylcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdGFicyAqL1xuY29uc3QgbWVzc2FnZSA9IGBcbm1lc3NhZ2UgSXBuc0VudHJ5IHtcbiAgZW51bSBWYWxpZGl0eVR5cGUge1xuXHRcdEVPTCA9IDA7IC8vIHNldHRpbmcgYW4gRU9MIHNheXMgXCJ0aGlzIHJlY29yZCBpcyB2YWxpZCB1bnRpbC4uLlwiXG5cdH1cblxuICByZXF1aXJlZCBieXRlcyB2YWx1ZSA9IDE7XG5cdHJlcXVpcmVkIGJ5dGVzIHNpZ25hdHVyZSA9IDI7XG5cblx0b3B0aW9uYWwgVmFsaWRpdHlUeXBlIHZhbGlkaXR5VHlwZSA9IDM7XG5cdG9wdGlvbmFsIGJ5dGVzIHZhbGlkaXR5ID0gNDtcblxuXHRvcHRpb25hbCB1aW50NjQgc2VxdWVuY2UgPSA1O1xuXG5cdG9wdGlvbmFsIHVpbnQ2NCB0dGwgPSA2O1xuXG5cdC8vIGluIG9yZGVyIGZvciBub2RlcyB0byBwcm9wZXJseSB2YWxpZGF0ZSBhIHJlY29yZCB1cG9uIHJlY2VpcHQsIHRoZXkgbmVlZCB0aGUgcHVibGljXG5cdC8vIGtleSBhc3NvY2lhdGVkIHdpdGggaXQuIEZvciBvbGQgUlNBIGtleXMsIGl0cyBlYXNpZXN0IGlmIHdlIGp1c3Qgc2VuZCB0aGlzIGFzIHBhcnQgb2Zcblx0Ly8gdGhlIHJlY29yZCBpdHNlbGYuIEZvciBuZXdlciBlZDI1NTE5IGtleXMsIHRoZSBwdWJsaWMga2V5IGNhbiBiZSBlbWJlZGRlZCBpbiB0aGVcblx0Ly8gcGVlcklELCBtYWtpbmcgdGhpcyBmaWVsZCB1bm5lY2Vzc2FyeS5cblx0b3B0aW9uYWwgYnl0ZXMgcHViS2V5ID0gNztcbn1cbmBcblxubW9kdWxlLmV4cG9ydHMgPSBwcm90b25zKG1lc3NhZ2UpLklwbnNFbnRyeVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gJy9tcGxleC82LjcuMCdcbiIsImZ1bmN0aW9uIGFib3J0YWJsZShvbkVuZCkge1xuICB2YXIgYWJvcnRlZCA9IGZhbHNlLCByZWFkaW5nID0gZmFsc2UsIGVuZGVkID0gZmFsc2UsIF9jYiwgX3JlYWRcblxuICBmdW5jdGlvbiBkb0VuZCAoKSB7XG4gICAgaWYoIW9uRW5kKSByZXR1cm5cbiAgICBpZihhYm9ydGVkICYmIGFib3J0ZWQgIT09IHRydWUpIHJldHVybiBvbkVuZChhYm9ydGVkKVxuICAgIGlmKGVuZGVkICYmIGVuZGVkICE9PSB0cnVlKSByZXR1cm4gb25FbmQoZW5kZWQpXG4gICAgcmV0dXJuIG9uRW5kKG51bGwpXG4gIH1cblxuICBmdW5jdGlvbiB0ZXJtaW5hdGUgKGVycikge1xuICAgIGRvRW5kKClcbiAgICB2YXIgY2IgPSBfY2I7IF9jYiA9IG51bGxcbiAgICBpZihjYikgY2IoYWJvcnRlZCB8fCBlbmRlZClcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCAoKSB7XG4gICAgZW5kZWQgPSBlbmRlZCB8fCB0cnVlXG4gICAgdGVybWluYXRlKGFib3J0ZWQgfHwgZW5kZWQpXG4gICAgaWYoX3JlYWQpXG4gICAgICBfcmVhZChhYm9ydGVkLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmKF9jYikgX2NiKGVycnx8YWJvcnRlZClcbiAgICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZWFkZXIgKHJlYWQpIHtcbiAgICBfcmVhZCA9IHJlYWRcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFib3J0LCBjYikge1xuICAgICAgX2NiID0gY2JcbiAgICAgIGlmKGFib3J0KSAgIGFib3J0ZWQgPSBhYm9ydFxuICAgICAgaWYoZW5kZWQpICAgcmV0dXJuIGNiKGVuZGVkKVxuICAgICAgaWYoYWJvcnRlZCkgcmV0dXJuXG4gICAgICByZWFkaW5nID0gdHJ1ZVxuICAgICAgcmVhZChhYm9ydCwgZnVuY3Rpb24gKGVuZCwgZGF0YSkge1xuICAgICAgICByZWFkaW5nID0gZmFsc2VcbiAgICAgICAgaWYoYWJvcnRlZCkgcmV0dXJuICFhYm9ydCAmJiByZWFkKGFib3J0ZWQsIGZ1bmN0aW9uICgpIHt9KVxuICAgICAgICBpZighX2NiKSByZXR1cm5cbiAgICAgICAgdmFyIGNiID0gX2NiXG4gICAgICAgIF9jYiA9IG51bGxcbiAgICAgICAgaWYoZW5kKSB7XG4gICAgICAgICAgZW5kZWQgPSBhYm9ydGVkIHx8IGVuZFxuICAgICAgICAgIGRvRW5kKClcbiAgICAgICAgICBjYihhYm9ydGVkIHx8IGVuZClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjYihhYm9ydGVkIHx8IGVuZCwgZGF0YSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZWFkZXIuYWJvcnQgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYoZW5kZWQpIHJldHVyblxuICAgIGFib3J0ZWQgPSBlcnIgfHwgdHJ1ZVxuICAgIGNhbmNlbCgpXG4gIH1cblxuICByZXR1cm4gcmVhZGVyXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWJvcnRhYmxlXG5cblxuXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5jb25zdCBDb25uZWN0aW9uID0gcmVxdWlyZSgnaW50ZXJmYWNlLWNvbm5lY3Rpb24nKS5Db25uZWN0aW9uXG5jb25zdCBuZXh0VGljayA9IHJlcXVpcmUoJ2FzeW5jL25leHRUaWNrJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuXG5jb25zdCBNVUxUSVBMRVhfQ09ERUMgPSByZXF1aXJlKCcuL2NvZGVjJylcblxuY29uc3QgbG9nID0gZGVidWcoJ2xpYnAycC1tcGxleDptdXhlcicpXG5sb2cuZXJyID0gZGVidWcoJ2xpYnAycC1tcGxleDptdXhlcjplcnJvcicpXG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuY2xhc3MgTXVsdGlwbGV4TXV4ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ublxuICAgKiBAcGFyYW0ge01wbGV4fSBtdWx0aXBsZXhcbiAgICovXG4gIGNvbnN0cnVjdG9yIChjb25uLCBtdWx0aXBsZXgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5jb25uID0gY29ublxuICAgIHRoaXMubXVsdGlwbGV4ID0gbXVsdGlwbGV4XG4gICAgdGhpcy5tdWx0aWNvZGVjID0gTVVMVElQTEVYX0NPREVDXG5cbiAgICBtdWx0aXBsZXgub24oJ2Nsb3NlJywgKCkgPT4gdGhpcy5lbWl0KCdjbG9zZScpKVxuICAgIG11bHRpcGxleC5vbignZXJyb3InLCAoZXJyKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKSlcblxuICAgIG11bHRpcGxleC5vbignc3RyZWFtJywgKHN0cmVhbSkgPT4ge1xuICAgICAgLy8gaW5zdGFsbCBkZWZhdWx0IGVycm9yIGhhbmRsZXIgc28gdGhhdCBpdCBkb2Vzbid0IHRocm93XG4gICAgICBzdHJlYW0ub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICBsb2cuZXJyKCdyZWNlaXZlciBzdHJlYW0gZXJyb3JlZCcsIGVycilcbiAgICAgIH0pXG4gICAgICB0aGlzLmVtaXQoJ3N0cmVhbScsIG5ldyBDb25uZWN0aW9uKHN0cmVhbSwgdGhpcy5jb25uKSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgc3RyZWFtIGZyb20gdGhlIGBDb25uZWN0aW9uYCB1c2VkIGluIGNyZWF0aW5nIHRoZSBtdXhlclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBDb25uZWN0aW9uKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge0Nvbm5lY3Rpb259XG4gICAqL1xuICBuZXdTdHJlYW0gKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wXG4gICAgbGV0IHN0cmVhbSA9IHRoaXMubXVsdGlwbGV4LmNyZWF0ZVN0cmVhbSgpXG4gICAgLy8gaW5zdGFsbCBkZWZhdWx0IGVycm9yIGhhbmRsZXIgc28gdGhhdCBpdCBkb2Vzbid0IHRocm93XG4gICAgc3RyZWFtLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgIGxvZy5lcnIoJ2luaXRpYXRvciBzdHJlYW0gZXJyb3JlZCcsIGVycilcbiAgICB9KVxuICAgIGNvbnN0IGNvbm4gPSBuZXcgQ29ubmVjdGlvbihzdHJlYW0sIHRoaXMuY29ubilcbiAgICBuZXh0VGljayhjYWxsYmFjaywgbnVsbCwgY29ubilcbiAgICByZXR1cm4gY29ublxuICB9XG5cbiAgLyoqXG4gICAqIEVuZHMgdGhlIGNvbm5lY3Rpb24gYW5kIGFsbCBvZiBpdHMgc3RyZWFtc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBlbmQgKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wXG4gICAgaWYgKHRoaXMubXVsdGlwbGV4LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIG5leHRUaWNrKGNhbGxiYWNrKVxuICAgIH1cbiAgICB0aGlzLm11bHRpcGxleC5vbmNlKCdjbG9zZScsIGNhbGxiYWNrKVxuICAgIHRoaXMubXVsdGlwbGV4LmNsb3NlKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE11bHRpcGxleE11eGVyXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtJylcbmNvbnN0IHB1c2hhYmxlID0gcmVxdWlyZSgncHVsbC1wdXNoYWJsZScpXG5jb25zdCB0aHJvdWdoID0gcmVxdWlyZSgncHVsbC10aHJvdWdoJylcbmNvbnN0IGxvb3BlciA9IHJlcXVpcmUoJ2xvb3BlcicpXG5jb25zdCBuZXh0VGljayA9IHJlcXVpcmUoJ2FzeW5jL25leHRUaWNrJylcbmNvbnN0IEVFID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuXG5jb25zdCB7IGVtaXRFcnJvciwgZW1pdFN0cmVhbSB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgVHlwZXMsIE1BWF9NU0dfU0laRSB9ID0gcmVxdWlyZSgnLi9jb25zdHMnKVxuY29uc3QgQ2hhbm5lbCA9IHJlcXVpcmUoJy4vY2hhbm5lbCcpXG5jb25zdCBjb2RlciA9IHJlcXVpcmUoJy4vY29kZXInKVxuXG5jb25zdCBsb2cgPSBkZWJ1ZygncHVsbC1wbGV4JylcbmxvZy5lcnIgPSBkZWJ1ZygncHVsbC1wbGV4OmVycicpXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWVzc2FnZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGlkXG4gKiBAcHJvcGVydHkge01lc3NhZ2VUeXBlfSB0eXBlXG4gKiBAcHJvcGVydHkge0J1ZmZlcn0gZGF0YVxuICovXG5cbi8qKlxuICogQGZpcmVzIE1wbGV4I2Nsb3NlIEVtaXR0ZWQgd2hlbiBNcGxleCBjbG9zZXNcbiAqIEBmaXJlcyBNcGxleCNlcnJvciBFbWl0dGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzXG4gKiBAZmlyZXMgTXBsZXgjc3RyZWFtIEVtaXR0ZWQgd2hlbiBhIG5ldyBzdHJlYW0gaXMgb3BlbmVkXG4gKi9cbmNsYXNzIE1wbGV4IGV4dGVuZHMgRUUge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0cy5pbml0aWF0b3IgSXMgdGhpcyBzdGFydGluZyB0aGUgc3RyZWFtLiBEZWZhdWx0OiBgdHJ1ZWBcbiAgICogQHBhcmFtIHtmdW5jdGlvbihDaGFubmVsLCBudW1iZXIpfSBvcHRzLm9uQ2hhbiBBIGhhbmRsZXIgZm9yIG5ldyBzdHJlYW1zLiBDYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIGAub24oJ3N0cmVhbScpYFxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5tYXhDaGFubmVscyBNYXhpbXVtIG51bWJlciBvZiBjaGFubmVscyB0byBoYXZlIG9wZW4uIERlZmF1bHQ6IGAxMDAwMGBcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMubWF4TXNnU2l6ZSBNYXhpbXVtIHNpemUgbWVzc2FnZXMgYXJlIGFsbG93ZWQgdG8gYmUuIERlZmF1bHQ6IGAxIDw8IDIwYCAoMU1CKVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdHMubGF6eSBTaG91bGQgY2hhbm5lbHMgYmUgb3BlbmVkIGxhemlseT8gSWYgZmFsc2UsIGNoYW5uZWxzIHdpbGwgYmUgb3BlbmVkIHdoZW4gdGhleSBhcmUgY3JlYXRlZC4gRGVmYXVsdDogYGZhbHNlYFxuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcigpXG5cbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdib29sZWFuJykge1xuICAgICAgb3B0cyA9IHsgaW5pdGlhdG9yOiBvcHRzIH1cbiAgICB9XG5cbiAgICBvcHRzID0ge1xuICAgICAgaW5pdGlhdG9yOiB0cnVlLFxuICAgICAgb25DaGFuOiBudWxsLFxuICAgICAgbWF4Q2hhbm5lbHM6IDEwMDAwLFxuICAgICAgbWF4TXNnU2l6ZTogTUFYX01TR19TSVpFLFxuICAgICAgbGF6eTogZmFsc2UsXG4gICAgICAuLi5vcHRzXG4gICAgfVxuXG4gICAgdGhpcy5fbWF4Q2hhbm5lbHMgPSBvcHRzLm1heENoYW5uZWxzXG4gICAgdGhpcy5fbWF4TXNnU2l6ZSA9IG9wdHMubWF4TXNnU2l6ZVxuICAgIHRoaXMuX2xhenkgPSBvcHRzLmxhenlcblxuICAgIHRoaXMuX2luaXRpYXRvciA9IEJvb2xlYW4ob3B0cy5pbml0aWF0b3IpXG4gICAgdGhpcy5fY2hhbklkID0gMFxuICAgIHRoaXMuX2luQ2hhbm5lbHMgPSBuZXcgQXJyYXkodGhpcy5fbWF4Q2hhbm5lbHMgLyAyKVxuICAgIHRoaXMuX291dENoYW5uZWxzID0gbmV3IEFycmF5KHRoaXMuX21heENoYW5uZWxzIC8gMilcbiAgICB0aGlzLl9lbmRlZFJlbW90ZSA9IGZhbHNlIC8vIHJlbW90ZSBzdHJlYW0gZW5kZWRcbiAgICB0aGlzLl9lbmRlZExvY2FsID0gZmFsc2UgLy8gbG9jYWwgc3RyZWFtIGVuZGVkXG5cbiAgICB0aGlzLl9jaGFuZGF0YSA9IHB1c2hhYmxlKChlcnIpID0+IHtcbiAgICAgIHRoaXMuX2xvZygnbXBsZXggZW5kZWQnKVxuICAgICAgdGhpcy5fZW5kZWRSZW1vdGUgPSB0cnVlXG4gICAgICB0aGlzLmNsb3NlKGVycilcbiAgICB9KVxuXG4gICAgaWYgKG9wdHMub25DaGFuKSB7XG4gICAgICB0aGlzLm9uKCdzdHJlYW0nLCAoY2hhbikgPT4gb3B0cy5vbkNoYW4oY2hhbiwgY2hhbi5pZCkpXG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2UgPSBwdWxsKFxuICAgICAgdGhpcy5fY2hhbmRhdGEsXG4gICAgICBjb2Rlci5lbmNvZGUoKVxuICAgIClcblxuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgdGhpcy5zaW5rID0gcHVsbChcbiAgICAgIHRocm91Z2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gZW5zdXJlIGRhdGEgaXMgd2l0aGluIG91ciBtYXggc2l6ZSByZXF1aXJlbWVudFxuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCA+PSBzZWxmLl9tYXhNc2dTaXplKSB7XG4gICAgICAgICAgbmV4dFRpY2soZW1pdEVycm9yLCBzZWxmLCBuZXcgRXJyb3IoJ21lc3NhZ2UgdG9vIGxhcmdlIScpKVxuICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlKG51bGwpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWV1ZShkYXRhKVxuICAgICAgfSksXG4gICAgICBjb2Rlci5kZWNvZGUoKSxcbiAgICAgIChyZWFkKSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHQgPSBsb29wZXIoKCkgPT4ge1xuICAgICAgICAgIHJlYWQobnVsbCwgKGVuZCwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNlbGYuX2VuZGVkTG9jYWwpIHsgcmV0dXJuIH1cbiAgICAgICAgICAgIGlmIChlbmQgPT09IHRydWUpIHsgcmV0dXJuIHNlbGYuY2xvc2UoKSB9XG4gICAgICAgICAgICBpZiAoZW5kKSB7IHJldHVybiBzZWxmLmRlc3Ryb3koZW5kKSB9XG4gICAgICAgICAgICBzZWxmLl9oYW5kbGUoZGF0YSlcbiAgICAgICAgICAgIG5leHQoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIG5leHQoKVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGNvbnZlbmllbmNlIHdyYXBwZXIgZm9yIHRoZSBsb2cgdGhhdCBhZGRzIHVzZWZ1bCBtZXRhZGF0YSB0byBsb2dzXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBvcGVyYXRpb24gYmVpbmcgbG9nZ2VkXG4gICAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ30gZGF0YSBMb2dnZWQgd2l0aCB0aGUgbWV0YWRhdGEuIE11c3QgYmUgYC50b1N0cmluZ2AgY2FwYWJsZS4gRGVmYXVsdDogYCcnYFxuICAgKi9cbiAgX2xvZyAobmFtZSwgZGF0YSkge1xuICAgIGxvZyh7XG4gICAgICBvcDogbmFtZSxcbiAgICAgIGluaXRpYXRvcjogdGhpcy5faW5pdGlhdG9yLFxuICAgICAgZW5kZWRMb2NhbDogdGhpcy5fZW5kZWRMb2NhbCxcbiAgICAgIGVuZGVkUmVtb3RlOiB0aGlzLl9lbmRlZFJlbW90ZSxcbiAgICAgIGRhdGE6IChkYXRhICYmIGRhdGEudG9TdHJpbmcoKSkgfHwgJydcbiAgICB9KVxuICB9XG5cbiAgZ2V0IGluaXRpYXRvciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luaXRpYXRvclxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyBhbGwgb3BlbiBjaGFubmVsc1xuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgT3B0aW9uYWwgZXJyb3JcbiAgICovXG4gIGNsb3NlIChlcnIpIHtcbiAgICB0aGlzLl9sb2coJ2Nsb3NlJywgZXJyKVxuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7IHJldHVybiB9XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBuZXh0VGljayhlbWl0RXJyb3IsIHRoaXMsIGVycilcbiAgICB9XG5cbiAgICBlcnIgPSBlcnIgfHwgJ1VuZGVybHlpbmcgc3RyZWFtIGhhcyBiZWVuIGNsb3NlZCdcbiAgICB0aGlzLl9lbmRlZExvY2FsID0gdHJ1ZVxuXG4gICAgLy8gcHJvcGFnYXRlIGNsb3NlIHRvIGNoYW5uZWxzXG4gICAgY29uc3QgY2hhbnMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0KHRoaXMuX291dENoYW5uZWxzLCB0aGlzLl9pbkNoYW5uZWxzKVxuICAgIGZvciAobGV0IGNoYW4gb2YgY2hhbnMpIHtcbiAgICAgIGlmIChjaGFuKSB7XG4gICAgICAgIGNoYW4uY2xvc2UoZXJyKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnY2xvc2UnKVxuICB9XG5cbiAgZ2V0IGRlc3Ryb3llZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuZGVkUmVtb3RlICYmIHRoaXMuX2VuZGVkTG9jYWxcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgcGFyZW50IHN0cmVhbSBhbmQgY2xvc2VzIE1wbGV4XG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICAgKi9cbiAgZGVzdHJveSAoZXJyKSB7XG4gICAgZXJyID0gZXJyIHx8IG5ldyBFcnJvcignVW5kZXJseWluZyBzdHJlYW0gaGFzIGJlZW4gY2xvc2VkJylcbiAgICB0aGlzLl9jaGFuZGF0YS5lbmQoZXJyKVxuICAgIHRoaXMuY2xvc2UoZXJyKVxuICB9XG5cbiAgLyoqXG4gICAqIFB1c2hlcyBkYXRhIHRvIHRoZSBzdHJlYW1cbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGFcbiAgICovXG4gIHB1c2ggKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5kYXRhICYmXG4gICAgICBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhLmRhdGEpID4gdGhpcy5fbWF4TXNnU2l6ZSkge1xuICAgICAgdGhpcy5fY2hhbmRhdGEuZW5kKG5ldyBFcnJvcignbWVzc2FnZSB0b28gbGFyZ2UhJykpXG4gICAgfVxuXG4gICAgdGhpcy5fY2hhbmRhdGEucHVzaChkYXRhKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgQ2hhbm5lbCAoc3RyZWFtKS4gSWYgTXBsZXggd2FzIGNyZWF0ZWQgd2l0aCBgb3B0cy5sYXp5YCBzZXQgdG8gdHJ1ZSxcbiAgICogdGhlIGNoYW5uZWwgd2lsbCBub3QgYXV0b21hdGljYWxseSBiZSBvcGVuZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjaGFubmVsL3N0cmVhbSB0byBjcmVhdGVcbiAgICogQHJldHVybnMge0NoYW5uZWx9XG4gICAqL1xuICBjcmVhdGVTdHJlYW0gKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdudW1iZXInKSB7IG5hbWUgPSBuYW1lLnRvU3RyaW5nKCkgfVxuICAgIGNvbnN0IGNoYW4gPSB0aGlzLl9uZXdTdHJlYW0obnVsbCwgdHJ1ZSwgZmFsc2UsIG5hbWUsIHRoaXMuX291dENoYW5uZWxzKVxuICAgIGlmICghdGhpcy5fbGF6eSkgeyBjaGFuLm9wZW5DaGFuKG5hbWUpIH1cbiAgICByZXR1cm4gY2hhblxuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGNyZWF0ZSBhIGNoYW5uZWwgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0LlxuICAgKiBJZiBhIGNoYW5uZWwgYWxyZWFkeSBleGlzdHMgZm9yIGBpZGAsIGBNcGxleCNlcnJvcmAgd2lsbCBiZSBlbWl0dGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaWQgVGhlIGlkIG9mIHRoZSBjaGFubmVsLiBJZiBgbnVsbGAgaXQgd2lsbCBiZSBhdXRvIGluY3JlbWVudGVkIGZyb20gYE1wbGV4Ll9jaGFuSWRgXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdGlhdG9yIElzIHRoZSBjaGFubmVsIGNyZWF0aW5nIHRoZSBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3BlbiBTaG91bGQgdGhlIGNoYW5uZWwgYmUgb3BlbmVkIHdoZW4gY3JlYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY2hhbm5lbFxuICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBjaGFubmVsIGxpc3QgdG8gYWRkIHRoZSBjaGFubmVsIHRvXG4gICAqIEByZXR1cm5zIHtDaGFubmVsfVxuICAgKi9cbiAgX25ld1N0cmVhbSAoaWQsIGluaXRpYXRvciwgb3BlbiwgbmFtZSwgbGlzdCkge1xuICAgIGlmICh0aGlzLmNoYW5TaXplID49IHRoaXMuX21heENoYW5uZWxzKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdtYXggY2hhbm5lbHMgZXhjZWVkZWQnKSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5pdGlhdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZSA9IGluaXRpYXRvclxuICAgICAgaW5pdGlhdG9yID0gZmFsc2VcbiAgICAgIG9wZW4gPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3BlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBvcGVuXG4gICAgICBvcGVuID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZCA9IHR5cGVvZiBpZCA9PT0gJ251bWJlcicgPyBpZCA6IHRoaXMuX2NoYW5JZCsrXG4gICAgaWYgKGxpc3RbaWRdKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKGBjaGFubmVsIHdpdGggaWQgJHtpZH0gYWxyZWFkeSBleGlzdCFgKSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBjaGFuID0gbmV3IENoYW5uZWwoe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgcGxleDogdGhpcyxcbiAgICAgIGluaXRpYXRvcixcbiAgICAgIG9wZW46IG9wZW4gfHwgZmFsc2VcbiAgICB9KVxuXG4gICAgcmV0dXJuIHRoaXMuX2FkZENoYW4oaWQsIGNoYW4sIGxpc3QpXG4gIH1cblxuICAvKipcbiAgICogQSBjb252ZW5pZW5jZSBtZXRob2QgZm9yIHNldHRpbmcgdGhlIGBjaGFuYCB1cCB0byBiZSB0cmFja2VkLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaWQgVGhlIGlkIG9mIHRoZSBjaGFubmVsXG4gICAqIEBwYXJhbSB7Q2hhbm5lbH0gY2hhbiBUaGUgY2hhbm5lbCB0byB0cmFja1xuICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBjaGFubmVsIGxpc3QgdG8gYWRkIHRoZSBjaGFubmVsIHRvXG4gICAqIEByZXR1cm5zIHtDaGFubmVsfSBgY2hhbmBcbiAgICovXG4gIF9hZGRDaGFuIChpZCwgY2hhbiwgbGlzdCkge1xuICAgIGNoYW4ub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICBsaXN0W2lkXSA9IG51bGxcbiAgICB9KVxuICAgIGNoYW4ub25jZSgnZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICBsb2cuZXJyKCdjaGFubmVsIGVycm9yJywgZXJyKVxuICAgIH0pXG5cbiAgICBsaXN0W2lkXSA9IGNoYW5cbiAgICByZXR1cm4gY2hhblxuICB9XG5cbiAgZ2V0IGNoYW5TaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5DaGFubmVscy5zaXplICsgdGhpcy5fb3V0Q2hhbm5lbHMuc2l6ZVxuICB9XG5cbiAgLyoqXG4gICAqIFRha2VzIHRoZSBhcHByb3ByaWF0ZSBjb3Vyc2Ugb2YgYWN0aW9uIGJhc2VkIG9uIGBtc2cudHlwZWAuXG4gICAqIElmIGBtc2cudHlwZWAgaXMgbm90IHJlY29nbml6ZWQgYE1wbGV4I2Vycm9yYCB3aWxsIGJlIGVtaXR0ZWQuXG4gICAqIEBwYXJhbSB7TWVzc2FnZX0gbXNnXG4gICAqL1xuICBfaGFuZGxlIChtc2cpIHtcbiAgICB0aGlzLl9sb2coJ19oYW5kbGUnLCBtc2cpXG4gICAgY29uc3QgeyBpZCwgdHlwZSwgZGF0YSB9ID0gbXNnXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAvLyBDcmVhdGUgYSBuZXcgc3RyZWFtXG4gICAgICBjYXNlIFR5cGVzLk5FVzoge1xuICAgICAgICBjb25zdCBjaGFuID0gdGhpcy5fbmV3U3RyZWFtKGlkLCBmYWxzZSwgdHJ1ZSwgZGF0YS50b1N0cmluZygpLCB0aGlzLl9pbkNoYW5uZWxzKVxuICAgICAgICBuZXh0VGljayhlbWl0U3RyZWFtLCB0aGlzLCBjaGFuLCBpZClcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgLy8gUHVzaCB0aGUgZGF0YSBpbnRvIHRoZSBjaGFubmVsIHdpdGggdGhlIG1hdGNoaW5nIGlkIGlmIGl0IGV4aXN0c1xuICAgICAgY2FzZSBUeXBlcy5PVVRfTUVTU0FHRTpcbiAgICAgIGNhc2UgVHlwZXMuSU5fTUVTU0FHRToge1xuICAgICAgICBjb25zdCBsaXN0ID0gdHlwZSAmIDEgPyB0aGlzLl9vdXRDaGFubmVscyA6IHRoaXMuX2luQ2hhbm5lbHNcbiAgICAgICAgY29uc3QgY2hhbiA9IGxpc3RbaWRdXG4gICAgICAgIGlmIChjaGFuKSB7XG4gICAgICAgICAgY2hhbi5wdXNoKGRhdGEpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xvc2UgdGhlIGNoYW5uZWwgd2l0aCB0aGUgbWF0Y2hpbmcgaWRcbiAgICAgIGNhc2UgVHlwZXMuT1VUX0NMT1NFOlxuICAgICAgY2FzZSBUeXBlcy5JTl9DTE9TRToge1xuICAgICAgICBjb25zdCBsaXN0ID0gdHlwZSAmIDEgPyB0aGlzLl9vdXRDaGFubmVscyA6IHRoaXMuX2luQ2hhbm5lbHNcbiAgICAgICAgY29uc3QgY2hhbiA9IGxpc3RbaWRdXG4gICAgICAgIGlmIChjaGFuKSB7XG4gICAgICAgICAgY2hhbi5jbG9zZSgpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgLy8gRGVzdHJveXMgdGhlIGNoYW5uZWwgd2l0aCB0aGUgbWF0Y2hpbmcgaWRcbiAgICAgIGNhc2UgVHlwZXMuT1VUX1JFU0VUOlxuICAgICAgY2FzZSBUeXBlcy5JTl9SRVNFVDoge1xuICAgICAgICBjb25zdCBsaXN0ID0gdHlwZSAmIDEgPyB0aGlzLl9vdXRDaGFubmVscyA6IHRoaXMuX2luQ2hhbm5lbHNcbiAgICAgICAgY29uc3QgY2hhbiA9IGxpc3RbaWRdXG4gICAgICAgIGlmIChjaGFuKSB7XG4gICAgICAgICAgY2hhbi5kZXN0cm95KClcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBuZXh0VGljayhlbWl0RXJyb3IsIHRoaXMsIG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlIHR5cGUnKSlcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNcGxleFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IENvbm5lY3Rpb24gPSByZXF1aXJlKCdpbnRlcmZhY2UtY29ubmVjdGlvbicpLkNvbm5lY3Rpb25cbmNvbnN0IG11bHRpYWRkciA9IHJlcXVpcmUoJ211bHRpYWRkcicpXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJylcblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5jb25zdCBjcmVhdGVTZXJ2ZXIgPSByZXF1aXJlKCdwdWxsLXdzL3NlcnZlcicpIHx8IG5vb3BcblxubW9kdWxlLmV4cG9ydHMgPSAob3B0aW9ucywgaGFuZGxlcikgPT4ge1xuICBjb25zdCBsaXN0ZW5lciA9IGNyZWF0ZVNlcnZlcihvcHRpb25zLCAoc29ja2V0KSA9PiB7XG4gICAgc29ja2V0LmdldE9ic2VydmVkQWRkcnMgPSAoY2FsbGJhY2spID0+IHtcbiAgICAgIC8vIFRPRE8gcmVzZWFyY2ggaWYgd2UgY2FuIHJldXNlIHRoZSBhZGRyZXNzIGluIGFueXdheVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIFtdKVxuICAgIH1cblxuICAgIGhhbmRsZXIobmV3IENvbm5lY3Rpb24oc29ja2V0KSlcbiAgfSlcblxuICBsZXQgbGlzdGVuaW5nTXVsdGlhZGRyXG5cbiAgbGlzdGVuZXIuX2xpc3RlbiA9IGxpc3RlbmVyLmxpc3RlblxuICBsaXN0ZW5lci5saXN0ZW4gPSAobWEsIGNhbGxiYWNrKSA9PiB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wXG4gICAgbGlzdGVuaW5nTXVsdGlhZGRyID0gbWFcblxuICAgIGlmIChtYS5wcm90b05hbWVzKCkuaW5jbHVkZXMoJ2lwZnMnKSkge1xuICAgICAgbWEgPSBtYS5kZWNhcHN1bGF0ZSgnaXBmcycpXG4gICAgfVxuXG4gICAgbGlzdGVuZXIuX2xpc3RlbihtYS50b09wdGlvbnMoKSwgY2FsbGJhY2spXG4gIH1cblxuICBsaXN0ZW5lci5nZXRBZGRycyA9IChjYWxsYmFjaykgPT4ge1xuICAgIGNvbnN0IG11bHRpYWRkcnMgPSBbXVxuICAgIGNvbnN0IGFkZHJlc3MgPSBsaXN0ZW5lci5hZGRyZXNzKClcblxuICAgIGlmICghYWRkcmVzcykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignTGlzdGVuZXIgaXMgbm90IHJlYWR5IHlldCcpKVxuICAgIH1cblxuICAgIGxldCBpcGZzSWQgPSBsaXN0ZW5pbmdNdWx0aWFkZHIuZ2V0UGVlcklkKClcblxuICAgIC8vIEJlY2F1c2UgVENQIHdpbGwgb25seSByZXR1cm4gdGhlIElQdjYgdmVyc2lvblxuICAgIC8vIHdlIG5lZWQgdG8gY2FwdHVyZSBmcm9tIHRoZSBwYXNzZWQgbXVsdGlhZGRyXG4gICAgaWYgKGxpc3RlbmluZ011bHRpYWRkci50b1N0cmluZygpLmluZGV4T2YoJ2lwNCcpICE9PSAtMSkge1xuICAgICAgbGV0IG0gPSBsaXN0ZW5pbmdNdWx0aWFkZHIuZGVjYXBzdWxhdGUoJ3RjcCcpXG4gICAgICBtID0gbS5lbmNhcHN1bGF0ZSgnL3RjcC8nICsgYWRkcmVzcy5wb3J0ICsgJy93cycpXG4gICAgICBpZiAobGlzdGVuaW5nTXVsdGlhZGRyLmdldFBlZXJJZCgpKSB7XG4gICAgICAgIG0gPSBtLmVuY2Fwc3VsYXRlKCcvaXBmcy8nICsgaXBmc0lkKVxuICAgICAgfVxuXG4gICAgICBpZiAobS50b1N0cmluZygpLmluZGV4T2YoJzAuMC4wLjAnKSAhPT0gLTEpIHtcbiAgICAgICAgY29uc3QgbmV0SW50ZXJmYWNlcyA9IG9zLm5ldHdvcmtJbnRlcmZhY2VzKClcbiAgICAgICAgT2JqZWN0LmtleXMobmV0SW50ZXJmYWNlcykuZm9yRWFjaCgobmlLZXkpID0+IHtcbiAgICAgICAgICBuZXRJbnRlcmZhY2VzW25pS2V5XS5mb3JFYWNoKChuaSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5pLmZhbWlseSA9PT0gJ0lQdjQnKSB7XG4gICAgICAgICAgICAgIG11bHRpYWRkcnMucHVzaChtdWx0aWFkZHIobS50b1N0cmluZygpLnJlcGxhY2UoJzAuMC4wLjAnLCBuaS5hZGRyZXNzKSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11bHRpYWRkcnMucHVzaChtKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIG11bHRpYWRkcnMpXG4gIH1cblxuICByZXR1cm4gbGlzdGVuZXJcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLkNvbm5lY3Rpb24gPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24nKVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vL2xvYWQgd2Vic29ja2V0IGxpYnJhcnkgaWYgd2UgYXJlIG5vdCBpbiB0aGUgYnJvd3NlclxudmFyIFdlYlNvY2tldCA9IHJlcXVpcmUoJy4vd2ViLXNvY2tldCcpXG52YXIgZHVwbGV4ID0gcmVxdWlyZSgnLi9kdXBsZXgnKVxudmFyIHdzdXJsID0gcmVxdWlyZSgnLi93cy11cmwnKVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uIChmKSB7XG4gIHJldHVybiAnZnVuY3Rpb24nID09PSB0eXBlb2YgZlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhZGRyLCBvcHRzKSB7XG4gIGlmIChpc0Z1bmN0aW9uKG9wdHMpKSBvcHRzID0ge29uQ29ubmVjdDogb3B0c31cblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHt9IDogd2luZG93LmxvY2F0aW9uXG5cbiAgdmFyIHVybCA9IHdzdXJsKGFkZHIsIGxvY2F0aW9uKVxuICB2YXIgc29ja2V0ID0gbmV3IFdlYlNvY2tldCh1cmwpXG5cbiAgdmFyIHN0cmVhbSA9IGR1cGxleChzb2NrZXQsIG9wdHMpXG4gIHN0cmVhbS5yZW1vdGVBZGRyZXNzID0gdXJsXG4gIHN0cmVhbS5jbG9zZSA9IGZ1bmN0aW9uIChjYikge1xuICAgIGlmIChpc0Z1bmN0aW9uKGNiKSkge1xuICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgY2IpXG4gICAgfVxuICAgIHNvY2tldC5jbG9zZSgpXG4gIH1cblxuICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKG9wdHMgJiYgaXNGdW5jdGlvbihvcHRzLm9uQ29ubmVjdCkpIHtcbiAgICAgIG9wdHMub25Db25uZWN0KG51bGwsIHN0cmVhbSlcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHN0cmVhbVxufVxuXG5tb2R1bGUuZXhwb3J0cy5jb25uZWN0ID0gbW9kdWxlLmV4cG9ydHNcbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBNYXhSZWNvcmRBZ2Ugc3BlY2lmaWVzIHRoZSBtYXhpbXVtIHRpbWUgdGhhdCBhbnkgbm9kZSB3aWxsIGhvbGQgb250byBhIHJlY29yZFxuLy8gZnJvbSB0aGUgdGltZSBpdHMgcmVjZWl2ZWQuIFRoaXMgZG9lcyBub3QgYXBwbHkgdG8gYW55IG90aGVyIGZvcm1zIG9mIHZhbGlkaXR5IHRoYXRcbi8vIHRoZSByZWNvcmQgbWF5IGNvbnRhaW4uXG4vLyBGb3IgZXhhbXBsZSwgYSByZWNvcmQgbWF5IGNvbnRhaW4gYW4gaXBucyBlbnRyeSB3aXRoIGFuIEVPTCBzYXlpbmcgaXRzIHZhbGlkXG4vLyB1bnRpbCB0aGUgeWVhciAyMDIwIChhIGdyZWF0IHRpbWUgaW4gdGhlIGZ1dHVyZSkuIEZvciB0aGF0IHJlY29yZCB0byBzdGljayBhcm91bmRcbi8vIGl0IG11c3QgYmUgcmVicm9hZGNhc3RlZCBtb3JlIGZyZXF1ZW50bHkgdGhhbiBvbmNlIGV2ZXJ5ICdNYXhSZWNvcmRBZ2UnXG5cbmNvbnN0IHNlY29uZCA9IGV4cG9ydHMuc2Vjb25kID0gMTAwMFxuY29uc3QgbWludXRlID0gZXhwb3J0cy5taW51dGUgPSA2MCAqIHNlY29uZFxuY29uc3QgaG91ciA9IGV4cG9ydHMuaG91ciA9IDYwICogbWludXRlXG5cbmV4cG9ydHMuTUFYX1JFQ09SRF9BR0UgPSAzNiAqIGhvdXJcblxuZXhwb3J0cy5QUk9UT0NPTF9ESFQgPSAnL2lwZnMva2FkLzEuMC4wJ1xuXG5leHBvcnRzLlBST1ZJREVSU19LRVlfUFJFRklYID0gJy9wcm92aWRlcnMvJ1xuXG5leHBvcnRzLlBST1ZJREVSU19MUlVfQ0FDSEVfU0laRSA9IDI1NlxuXG5leHBvcnRzLlBST1ZJREVSU19WQUxJRElUWSA9IDI0ICogaG91clxuXG5leHBvcnRzLlBST1ZJREVSU19DTEVBTlVQX0lOVEVSVkFMID0gaG91clxuXG5leHBvcnRzLlJFQURfTUVTU0FHRV9USU1FT1VUID0gMTAgKiBzZWNvbmRcblxuLy8gVGhlIG51bWJlciBvZiByZWNvcmRzIHRoYXQgd2lsbCBiZSByZXRyaWV2ZWQgb24gYSBjYWxsIHRvIGdldE1hbnkoKVxuZXhwb3J0cy5HRVRfTUFOWV9SRUNPUkRfQ09VTlQgPSAxNlxuXG4vLyBLIGlzIHRoZSBtYXhpbXVtIG51bWJlciBvZiByZXF1ZXN0cyB0byBwZXJmb3JtIGJlZm9yZSByZXR1cm5pbmcgZmFpbHVyZVxuZXhwb3J0cy5LID0gMjBcblxuLy8gQWxwaGEgaXMgdGhlIGNvbmN1cnJlbmN5IGZvciBhc3luY2hyb25vdXMgcmVxdWVzdHNcbmV4cG9ydHMuQUxQSEEgPSAzXG5cbmV4cG9ydHMubWF4TWVzc2FnZVNpemUgPSAyIDw8IDIyIC8vIDRNQlxuXG5leHBvcnRzLmRlZmF1bHRSYW5kb21XYWxrID0ge1xuICBlbmFibGVkOiB0cnVlLFxuICBxdWVyaWVzUGVyUGVyaW9kOiAxLFxuICBpbnRlcnZhbDogNSAqIG1pbnV0ZSxcbiAgdGltZW91dDogMTAgKiBzZWNvbmQsXG4gIGRlbGF5OiAxMCAqIHNlY29uZFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgYWxsIHJ1bm5pbmcgcXVlcmllcy5cbiAqL1xuY2xhc3MgUXVlcnlNYW5hZ2VyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUXVlcnlNYW5hZ2VyLlxuICAgKi9cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMucXVlcmllcyA9IG5ldyBTZXQoKVxuICAgIHRoaXMucnVubmluZyA9IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBxdWVyeSBpcyBzdGFydGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1F1ZXJ5fSBxdWVyeVxuICAgKi9cbiAgcXVlcnlTdGFydGVkIChxdWVyeSkge1xuICAgIHRoaXMucXVlcmllcy5hZGQocXVlcnkpXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBxdWVyeSBjb21wbGV0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UXVlcnl9IHF1ZXJ5XG4gICAqL1xuICBxdWVyeUNvbXBsZXRlZCAocXVlcnkpIHtcbiAgICB0aGlzLnF1ZXJpZXMuZGVsZXRlKHF1ZXJ5KVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgcXVlcnkgbWFuYWdlci5cbiAgICovXG4gIHN0YXJ0ICgpIHtcbiAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgYWxsIHF1ZXJpZXMuXG4gICAqL1xuICBzdG9wICgpIHtcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZVxuICAgIGZvciAoY29uc3QgcXVlcnkgb2YgdGhpcy5xdWVyaWVzKSB7XG4gICAgICBxdWVyeS5zdG9wKClcbiAgICB9XG4gICAgdGhpcy5xdWVyaWVzLmNsZWFyKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5TWFuYWdlclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2ZpbHRlciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvZmlsdGVyJyk7XG5cbnZhciBfZmlsdGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZpbHRlcik7XG5cbnZhciBfZG9QYXJhbGxlbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvZG9QYXJhbGxlbCcpO1xuXG52YXIgX2RvUGFyYWxsZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZG9QYXJhbGxlbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBhcnJheSBvZiBhbGwgdGhlIHZhbHVlcyBpbiBgY29sbGAgd2hpY2ggcGFzcyBhbiBhc3luYyB0cnV0aFxuICogdGVzdC4gVGhpcyBvcGVyYXRpb24gaXMgcGVyZm9ybWVkIGluIHBhcmFsbGVsLCBidXQgdGhlIHJlc3VsdHMgYXJyYXkgd2lsbCBiZVxuICogaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIG9yaWdpbmFsLlxuICpcbiAqIEBuYW1lIGZpbHRlclxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGFsaWFzIHNlbGVjdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgYGl0ZXJhdGVlYCBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCB0cnV0aFZhbHVlKWAsIHdoaWNoIG11c3QgYmUgY2FsbGVkXG4gKiB3aXRoIGEgYm9vbGVhbiBhcmd1bWVudCBvbmNlIGl0IGhhcyBjb21wbGV0ZWQuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuZmlsdGVyKFsnZmlsZTEnLCdmaWxlMicsJ2ZpbGUzJ10sIGZ1bmN0aW9uKGZpbGVQYXRoLCBjYWxsYmFjaykge1xuICogICAgIGZzLmFjY2VzcyhmaWxlUGF0aCwgZnVuY3Rpb24oZXJyKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICFlcnIpXG4gKiAgICAgfSk7XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAvLyByZXN1bHRzIG5vdyBlcXVhbHMgYW4gYXJyYXkgb2YgdGhlIGV4aXN0aW5nIGZpbGVzXG4gKiB9KTtcbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIF9kb1BhcmFsbGVsMi5kZWZhdWx0KShfZmlsdGVyMi5kZWZhdWx0KTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdGltZW91dDtcblxudmFyIF9pbml0aWFsUGFyYW1zID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9pbml0aWFsUGFyYW1zJyk7XG5cbnZhciBfaW5pdGlhbFBhcmFtczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbml0aWFsUGFyYW1zKTtcblxudmFyIF93cmFwQXN5bmMgPSByZXF1aXJlKCcuL2ludGVybmFsL3dyYXBBc3luYycpO1xuXG52YXIgX3dyYXBBc3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93cmFwQXN5bmMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIFNldHMgYSB0aW1lIGxpbWl0IG9uIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIGRvZXMgbm90IGNhbGxcbiAqIGl0cyBjYWxsYmFjayB3aXRoaW4gdGhlIHNwZWNpZmllZCBtaWxsaXNlY29uZHMsIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggYVxuICogdGltZW91dCBlcnJvci4gVGhlIGNvZGUgcHJvcGVydHkgZm9yIHRoZSBlcnJvciBvYmplY3Qgd2lsbCBiZSBgJ0VUSU1FRE9VVCdgLlxuICpcbiAqIEBuYW1lIHRpbWVvdXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGFzeW5jRm4gLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gbGltaXQgaW4gdGltZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaWxsaXNlY29uZHMgLSBUaGUgc3BlY2lmaWVkIHRpbWUgbGltaXQuXG4gKiBAcGFyYW0geyp9IFtpbmZvXSAtIEFueSB2YXJpYWJsZSB5b3Ugd2FudCBhdHRhY2hlZCAoYHN0cmluZ2AsIGBvYmplY3RgLCBldGMpXG4gKiB0byB0aW1lb3V0IEVycm9yIGZvciBtb3JlIGluZm9ybWF0aW9uLi5cbiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBSZXR1cm5zIGEgd3JhcHBlZCBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHdpdGggYW55XG4gKiBvZiB0aGUgY29udHJvbCBmbG93IGZ1bmN0aW9ucy5cbiAqIEludm9rZSB0aGlzIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgcGFyYW1ldGVycyBhcyB5b3Ugd291bGQgYGFzeW5jRnVuY2AuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIG15RnVuY3Rpb24oZm9vLCBjYWxsYmFjaykge1xuICogICAgIGRvQXN5bmNUYXNrKGZvbywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gKiAgICAgICAgIC8vIGhhbmRsZSBlcnJvcnNcbiAqICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gKlxuICogICAgICAgICAvLyBkbyBzb21lIHN0dWZmIC4uLlxuICpcbiAqICAgICAgICAgLy8gcmV0dXJuIHByb2Nlc3NlZCBkYXRhXG4gKiAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAqICAgICB9KTtcbiAqIH1cbiAqXG4gKiB2YXIgd3JhcHBlZCA9IGFzeW5jLnRpbWVvdXQobXlGdW5jdGlvbiwgMTAwMCk7XG4gKlxuICogLy8gY2FsbCBgd3JhcHBlZGAgYXMgeW91IHdvdWxkIGBteUZ1bmN0aW9uYFxuICogd3JhcHBlZCh7IGJhcjogJ2JhcicgfSwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gKiAgICAgLy8gaWYgYG15RnVuY3Rpb25gIHRha2VzIDwgMTAwMCBtcyB0byBleGVjdXRlLCBgZXJyYFxuICogICAgIC8vIGFuZCBgZGF0YWAgd2lsbCBoYXZlIHRoZWlyIGV4cGVjdGVkIHZhbHVlc1xuICpcbiAqICAgICAvLyBlbHNlIGBlcnJgIHdpbGwgYmUgYW4gRXJyb3Igd2l0aCB0aGUgY29kZSAnRVRJTUVET1VUJ1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXQoYXN5bmNGbiwgbWlsbGlzZWNvbmRzLCBpbmZvKSB7XG4gICAgdmFyIGZuID0gKDAsIF93cmFwQXN5bmMyLmRlZmF1bHQpKGFzeW5jRm4pO1xuXG4gICAgcmV0dXJuICgwLCBfaW5pdGlhbFBhcmFtczIuZGVmYXVsdCkoZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB0aW1lZE91dCA9IGZhbHNlO1xuICAgICAgICB2YXIgdGltZXI7XG5cbiAgICAgICAgZnVuY3Rpb24gdGltZW91dENhbGxiYWNrKCkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBhc3luY0ZuLm5hbWUgfHwgJ2Fub255bW91cyc7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NhbGxiYWNrIGZ1bmN0aW9uIFwiJyArIG5hbWUgKyAnXCIgdGltZWQgb3V0LicpO1xuICAgICAgICAgICAgZXJyb3IuY29kZSA9ICdFVElNRURPVVQnO1xuICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICBlcnJvci5pbmZvID0gaW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRpbWVkT3V0KSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzZXR1cCB0aW1lciBhbmQgY2FsbCBvcmlnaW5hbCBmdW5jdGlvblxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQodGltZW91dENhbGxiYWNrLCBtaWxsaXNlY29uZHMpO1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBQZWVySWQgPSByZXF1aXJlKCdwZWVyLWlkJylcbmNvbnN0IGxpYnAycFJlY29yZCA9IHJlcXVpcmUoJ2xpYnAycC1yZWNvcmQnKVxuY29uc3QgdGltZW91dCA9IHJlcXVpcmUoJ2FzeW5jL3RpbWVvdXQnKVxuY29uc3QgUGVlckluZm8gPSByZXF1aXJlKCdwZWVyLWluZm8nKVxuY29uc3QgcHJvbWlzaWZ5ID0gcmVxdWlyZSgncHJvbWlzaWZ5LWVzNicpXG5jb25zdCBwcm9taXNlVG9DYWxsYmFjayA9IHJlcXVpcmUoJ3Byb21pc2UtdG8tY2FsbGJhY2snKVxuY29uc3QgZXJyY29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IE1lc3NhZ2UgPSByZXF1aXJlKCcuL21lc3NhZ2UnKVxuY29uc3QgYyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZSgnLi9xdWVyeScpXG5jb25zdCBMaW1pdGVkUGVlckxpc3QgPSByZXF1aXJlKCcuL2xpbWl0ZWQtcGVlci1saXN0JylcblxuY29uc3QgUmVjb3JkID0gbGlicDJwUmVjb3JkLlJlY29yZFxuXG5tb2R1bGUuZXhwb3J0cyA9IChkaHQpID0+ICh7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb3V0aW5nIHRhYmxlcyBjbG9zZXN0IHBlZXJzLCBmb3IgdGhlIGtleSBvZlxuICAgKiB0aGUgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtc2dcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQXJyYXk8UGVlckluZm8+KX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9uZWFyZXN0UGVlcnNUb1F1ZXJ5IChtc2csIGNhbGxiYWNrKSB7XG4gICAgcHJvbWlzZVRvQ2FsbGJhY2sodGhpcy5fbmVhcmVzdFBlZXJzVG9RdWVyeUFzeW5jKG1zZykpKGNhbGxiYWNrKVxuICB9LFxuXG4gIGFzeW5jIF9uZWFyZXN0UGVlcnNUb1F1ZXJ5QXN5bmMgKG1zZykge1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IHByb21pc2lmeSh1dGlscy5jb252ZXJ0QnVmZmVyKShtc2cua2V5KVxuXG4gICAgY29uc3QgaWRzID0gZGh0LnJvdXRpbmdUYWJsZS5jbG9zZXN0UGVlcnMoa2V5LCBkaHQua0J1Y2tldFNpemUpXG4gICAgcmV0dXJuIGlkcy5tYXAoKHApID0+IHtcbiAgICAgIGlmIChkaHQucGVlckJvb2suaGFzKHApKSB7XG4gICAgICAgIHJldHVybiBkaHQucGVlckJvb2suZ2V0KHApXG4gICAgICB9XG4gICAgICByZXR1cm4gZGh0LnBlZXJCb29rLnB1dChuZXcgUGVlckluZm8ocCkpXG4gICAgfSlcbiAgfSxcbiAgLyoqXG4gICAqIEdldCB0aGUgbmVhcmVzdCBwZWVycyB0byB0aGUgZ2l2ZW4gcXVlcnksIGJ1dCBpZmYgY2xvc2VyXG4gICAqIHRoYW4gc2VsZi5cbiAgICpcbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtc2dcbiAgICogQHBhcmFtIHtQZWVySW5mb30gcGVlclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBBcnJheTxQZWVySW5mbz4pfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBfYmV0dGVyUGVlcnNUb1F1ZXJ5IChtc2csIHBlZXIsIGNhbGxiYWNrKSB7XG4gICAgcHJvbWlzZVRvQ2FsbGJhY2sodGhpcy5fYmV0dGVyUGVlcnNUb1F1ZXJ5QXN5bmMobXNnLCBwZWVyKSkoY2FsbGJhY2spXG4gIH0sXG5cbiAgYXN5bmMgX2JldHRlclBlZXJzVG9RdWVyeUFzeW5jIChtc2csIHBlZXIpIHtcbiAgICBkaHQuX2xvZygnYmV0dGVyUGVlcnNUb1F1ZXJ5JylcbiAgICBjb25zdCBjbG9zZXIgPSBhd2FpdCBkaHQuX25lYXJlc3RQZWVyc1RvUXVlcnlBc3luYyhtc2cpXG5cbiAgICByZXR1cm4gY2xvc2VyLmZpbHRlcigoY2xvc2VyKSA9PiB7XG4gICAgICBpZiAoZGh0Ll9pc1NlbGYoY2xvc2VyLmlkKSkge1xuICAgICAgICAvLyBTaG91bGQgYmFpbCwgbm90IHN1cmVcbiAgICAgICAgZGh0Ll9sb2cuZXJyb3IoJ3RyeWluZyB0byByZXR1cm4gc2VsZiBhcyBjbG9zZXInKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICFjbG9zZXIuaWQuaXNFcXVhbChwZWVyLmlkKVxuICAgIH0pXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyeSB0byBmZXRjaCBhIGdpdmVuIHJlY29yZCBieSBmcm9tIHRoZSBsb2NhbCBkYXRhc3RvcmUuXG4gICAqIFJldHVybnMgdGhlIHJlY29yZCBpZmYgaXQgaXMgc3RpbGwgdmFsaWQsIG1lYW5pbmdcbiAgICogLSBpdCB3YXMgZWl0aGVyIGF1dGhvcmVkIGJ5IHRoaXMgbm9kZSwgb3JcbiAgICogLSBpdCB3YXMgcmVjZWl2ZWQgbGVzcyB0aGFuIGBNQVhfUkVDT1JEX0FHRWAgYWdvLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0ga2V5XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIFJlY29yZCl9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqXG4gICAqQHByaXZhdGVcbiAgICovXG5cbiAgX2NoZWNrTG9jYWxEYXRhc3RvcmUgKGtleSwgY2FsbGJhY2spIHtcbiAgICBwcm9taXNlVG9DYWxsYmFjayh0aGlzLl9jaGVja0xvY2FsRGF0YXN0b3JlQXN5bmMoa2V5KSkoY2FsbGJhY2spXG4gIH0sXG5cbiAgYXN5bmMgX2NoZWNrTG9jYWxEYXRhc3RvcmVBc3luYyAoa2V5KSB7XG4gICAgZGh0Ll9sb2coJ2NoZWNrTG9jYWxEYXRhc3RvcmU6ICViJywga2V5KVxuICAgIGNvbnN0IGRzS2V5ID0gdXRpbHMuYnVmZmVyVG9LZXkoa2V5KVxuXG4gICAgLy8gRmV0Y2ggdmFsdWUgZnJvbSBkc1xuICAgIGxldCByYXdSZWNvcmRcbiAgICB0cnkge1xuICAgICAgcmF3UmVjb3JkID0gYXdhaXQgcHJvbWlzaWZ5KGNiID0+IGRodC5kYXRhc3RvcmUuZ2V0KGRzS2V5LCBjYikpKClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VSUl9OT1RfRk9VTkQnKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIC8vIENyZWF0ZSByZWNvcmQgZnJvbSB0aGUgcmV0dXJuZWQgYnl0ZXNcbiAgICBjb25zdCByZWNvcmQgPSBSZWNvcmQuZGVzZXJpYWxpemUocmF3UmVjb3JkKVxuXG4gICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgIHRocm93IGVycmNvZGUoJ0ludmFsaWQgcmVjb3JkJywgJ0VSUl9JTlZBTElEX1JFQ09SRCcpXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdmFsaWRpdHk6IGNvbXBhcmUgdGltZSByZWNlaXZlZCB3aXRoIG1heCByZWNvcmQgYWdlXG4gICAgaWYgKHJlY29yZC50aW1lUmVjZWl2ZWQgPT0gbnVsbCB8fFxuICAgICAgICB1dGlscy5ub3coKSAtIHJlY29yZC50aW1lUmVjZWl2ZWQgPiBjLk1BWF9SRUNPUkRfQUdFKSB7XG4gICAgICAvLyBJZiByZWNvcmQgaXMgYmFkIGRlbGV0ZSBpdCBhbmQgcmV0dXJuXG4gICAgICBhd2FpdCBwcm9taXNpZnkoY2IgPT4gZGh0LmRhdGFzdG9yZS5kZWxldGUoZHNLZXksIGNiKSkoKVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIC8vIFJlY29yZCBpcyB2YWxpZFxuICAgIHJldHVybiByZWNvcmRcbiAgfSxcbiAgLyoqXG4gICAqIEFkZCB0aGUgcGVlciB0byB0aGUgcm91dGluZyB0YWJsZSBhbmQgdXBkYXRlIGl0IGluIHRoZSBwZWVyYm9vay5cbiAgICpcbiAgICogQHBhcmFtIHtQZWVySW5mb30gcGVlclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgX2FkZCAocGVlciwgY2FsbGJhY2spIHtcbiAgICBwcm9taXNlVG9DYWxsYmFjayh0aGlzLl9hZGRBc3luYyhwZWVyKSkoZXJyID0+IGNhbGxiYWNrKGVycikpXG4gIH0sXG5cbiAgYXN5bmMgX2FkZEFzeW5jIChwZWVyKSB7XG4gICAgcGVlciA9IGRodC5wZWVyQm9vay5wdXQocGVlcilcbiAgICBhd2FpdCBwcm9taXNpZnkoY2IgPT4gZGh0LnJvdXRpbmdUYWJsZS5hZGQocGVlci5pZCwgY2IpKSgpXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9LFxuICAvKipcbiAgICogVmVyaWZ5IGEgcmVjb3JkIHdpdGhvdXQgc2VhcmNoaW5nIHRoZSBESFQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVjb3JkfSByZWNvcmRcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIF92ZXJpZnlSZWNvcmRMb2NhbGx5IChyZWNvcmQsIGNhbGxiYWNrKSB7XG4gICAgcHJvbWlzZVRvQ2FsbGJhY2sodGhpcy5fdmVyaWZ5UmVjb3JkTG9jYWxseUFzeW5jKHJlY29yZCkpKGVyciA9PiBjYWxsYmFjayhlcnIpKVxuICB9LFxuXG4gIGFzeW5jIF92ZXJpZnlSZWNvcmRMb2NhbGx5QXN5bmMgKHJlY29yZCkge1xuICAgIGRodC5fbG9nKCd2ZXJpZnlSZWNvcmRMb2NhbGx5JylcbiAgICBhd2FpdCBwcm9taXNpZnkoY2IgPT4gbGlicDJwUmVjb3JkLnZhbGlkYXRvci52ZXJpZnlSZWNvcmQoXG4gICAgICBkaHQudmFsaWRhdG9ycyxcbiAgICAgIHJlY29yZCxcbiAgICAgIGNiXG4gICAgKSkoKVxuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kIGNsb3NlIHBlZXJzIGZvciBhIGdpdmVuIHBlZXJcbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGtleVxuICAgKiBAcGFyYW0ge1BlZXJJZH0gcGVlclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBBcnJheTxQZWVySW5mbz4pfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgX2Nsb3NlclBlZXJzU2luZ2xlIChrZXksIHBlZXIsIGNhbGxiYWNrKSB7XG4gICAgcHJvbWlzZVRvQ2FsbGJhY2sodGhpcy5fY2xvc2VyUGVlcnNTaW5nbGVBc3luYyhrZXksIHBlZXIpKShjYWxsYmFjaylcbiAgfSxcblxuICBhc3luYyBfY2xvc2VyUGVlcnNTaW5nbGVBc3luYyAoa2V5LCBwZWVyKSB7XG4gICAgZGh0Ll9sb2coJ19jbG9zZXJQZWVyc1NpbmdsZSAlYiBmcm9tICVzJywga2V5LCBwZWVyLnRvQjU4U3RyaW5nKCkpXG4gICAgY29uc3QgbXNnID0gYXdhaXQgZGh0Ll9maW5kUGVlclNpbmdsZUFzeW5jKHBlZXIsIG5ldyBQZWVySWQoa2V5KSlcbiAgICByZXR1cm4gbXNnLmNsb3NlclBlZXJzXG4gICAgICAuZmlsdGVyKChwSW5mbykgPT4gIWRodC5faXNTZWxmKHBJbmZvLmlkKSlcbiAgICAgIC5tYXAoKHBJbmZvKSA9PiBkaHQucGVlckJvb2sucHV0KHBJbmZvKSlcbiAgfSxcblxuICAvKipcbiAgICogSXMgdGhlIGdpdmVuIHBlZXIgaWQgb3VyIFBlZXJJZD9cbiAgICpcbiAgICogQHBhcmFtIHtQZWVySWR9IG90aGVyXG4gICAqIEByZXR1cm5zIHtib29sfVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBfaXNTZWxmIChvdGhlcikge1xuICAgIHJldHVybiBvdGhlciAmJiBkaHQucGVlckluZm8uaWQuaWQuZXF1YWxzKG90aGVyLmlkKVxuICB9LFxuXG4gIC8qKlxuICAgKiBBc2sgcGVlciBgcGVlcmAgaWYgdGhleSBrbm93IHdoZXJlIHRoZSBwZWVyIHdpdGggaWQgYHRhcmdldGAgaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlcklkfSBwZWVyXG4gICAqIEBwYXJhbSB7UGVlcklkfSB0YXJnZXRcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgTWVzc2FnZSl9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBfZmluZFBlZXJTaW5nbGUgKHBlZXIsIHRhcmdldCwgY2FsbGJhY2spIHtcbiAgICBwcm9taXNlVG9DYWxsYmFjayh0aGlzLl9maW5kUGVlclNpbmdsZUFzeW5jKHBlZXIsIHRhcmdldCkpKGNhbGxiYWNrKVxuICB9LFxuXG4gIGFzeW5jIF9maW5kUGVlclNpbmdsZUFzeW5jIChwZWVyLCB0YXJnZXQpIHtcbiAgICBkaHQuX2xvZygnX2ZpbmRQZWVyU2luZ2xlICVzJywgcGVlci50b0I1OFN0cmluZygpKVxuICAgIGNvbnN0IG1zZyA9IG5ldyBNZXNzYWdlKE1lc3NhZ2UuVFlQRVMuRklORF9OT0RFLCB0YXJnZXQuaWQsIDApXG4gICAgcmV0dXJuIHByb21pc2lmeShjYWxsYmFjayA9PiBkaHQubmV0d29yay5zZW5kUmVxdWVzdChwZWVyLCBtc2csIGNhbGxiYWNrKSkoKVxuICB9LFxuXG4gIC8qKlxuICAgKiBTdG9yZSB0aGUgZ2l2ZW4ga2V5L3ZhbHVlIHBhaXIgYXQgdGhlIHBlZXIgYHRhcmdldGAuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBrZXlcbiAgICogQHBhcmFtIHtCdWZmZXJ9IHJlYyAtIGVuY29kZWQgcmVjb3JkXG4gICAqIEBwYXJhbSB7UGVlcklkfSB0YXJnZXRcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBfcHV0VmFsdWVUb1BlZXIgKGtleSwgcmVjLCB0YXJnZXQsIGNhbGxiYWNrKSB7XG4gICAgcHJvbWlzZVRvQ2FsbGJhY2sodGhpcy5fcHV0VmFsdWVUb1BlZXJBc3luYyhrZXksIHJlYywgdGFyZ2V0KSkoY2FsbGJhY2spXG4gIH0sXG5cbiAgYXN5bmMgX3B1dFZhbHVlVG9QZWVyQXN5bmMgKGtleSwgcmVjLCB0YXJnZXQpIHtcbiAgICBjb25zdCBtc2cgPSBuZXcgTWVzc2FnZShNZXNzYWdlLlRZUEVTLlBVVF9WQUxVRSwga2V5LCAwKVxuICAgIG1zZy5yZWNvcmQgPSByZWNcblxuICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBwcm9taXNpZnkoY2IgPT4gZGh0Lm5ldHdvcmsuc2VuZFJlcXVlc3QodGFyZ2V0LCBtc2csIGNiKSkoKVxuXG4gICAgaWYgKCFyZXNwLnJlY29yZC52YWx1ZS5lcXVhbHMoUmVjb3JkLmRlc2VyaWFsaXplKHJlYykudmFsdWUpKSB7XG4gICAgICB0aHJvdyBlcnJjb2RlKG5ldyBFcnJvcigndmFsdWUgbm90IHB1dCBjb3JyZWN0bHknKSwgJ0VSUl9QVVRfVkFMVUVfSU5WQUxJRCcpXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTdG9yZSB0aGUgZ2l2ZW4ga2V5L3ZhbHVlIHBhaXIgbG9jYWxseSwgaW4gdGhlIGRhdGFzdG9yZS5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IGtleVxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gcmVjIC0gZW5jb2RlZCByZWNvcmRcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBfcHV0TG9jYWwgKGtleSwgcmVjLCBjYWxsYmFjaykge1xuICAgIHByb21pc2VUb0NhbGxiYWNrKHRoaXMuX3B1dExvY2FsQXN5bmMoa2V5LCByZWMpKShlcnIgPT4gY2FsbGJhY2soZXJyKSlcbiAgfSxcblxuICBhc3luYyBfcHV0TG9jYWxBc3luYyAoa2V5LCByZWMpIHtcbiAgICBhd2FpdCBwcm9taXNpZnkoY2IgPT4gZGh0LmRhdGFzdG9yZS5wdXQodXRpbHMuYnVmZmVyVG9LZXkoa2V5KSwgcmVjLCBjYikpKClcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgZm9yIGdpdmVuIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGtleVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGdldCBvcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRpbWVvdXQgLSBvcHRpb25hbCB0aW1lb3V0IChkZWZhdWx0OiA2MDAwMClcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgUmVjb3JkKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIF9nZXQgKGtleSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBwcm9taXNlVG9DYWxsYmFjayh0aGlzLl9nZXRBc3luYyhrZXksIG9wdGlvbnMpKShjYWxsYmFjaylcbiAgfSxcblxuICBhc3luYyBfZ2V0QXN5bmMgKGtleSwgb3B0aW9ucykge1xuICAgIGRodC5fbG9nKCdfZ2V0ICViJywga2V5KVxuXG4gICAgY29uc3QgdmFscyA9IGF3YWl0IHByb21pc2lmeShjYiA9PiBkaHQuZ2V0TWFueShrZXksIGMuR0VUX01BTllfUkVDT1JEX0NPVU5ULCBvcHRpb25zLCBjYikpKClcblxuICAgIGNvbnN0IHJlY3MgPSB2YWxzLm1hcCgodikgPT4gdi52YWwpXG4gICAgbGV0IGkgPSAwXG5cbiAgICB0cnkge1xuICAgICAgaSA9IGxpYnAycFJlY29yZC5zZWxlY3Rpb24uYmVzdFJlY29yZChkaHQuc2VsZWN0b3JzLCBrZXksIHJlY3MpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBBc3N1bWUgdGhlIGZpcnN0IHJlY29yZCBpZiBubyBzZWxlY3RvciBhdmFpbGFibGVcbiAgICAgIGlmIChlcnIuY29kZSAhPT0gJ0VSUl9OT19TRUxFQ1RPUl9GVU5DVElPTl9GT1JfUkVDT1JEX0tFWScpIHtcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYmVzdCA9IHJlY3NbaV1cbiAgICBkaHQuX2xvZygnR2V0VmFsdWUgJWIgJXMnLCBrZXksIGJlc3QpXG5cbiAgICBpZiAoIWJlc3QpIHtcbiAgICAgIHRocm93IGVycmNvZGUobmV3IEVycm9yKCdiZXN0IHZhbHVlIHdhcyBub3QgZm91bmQnKSwgJ0VSUl9OT1RfRk9VTkQnKVxuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuX3NlbmRDb3JyZWN0aW9uUmVjb3JkKGtleSwgdmFscywgYmVzdClcblxuICAgIHJldHVybiBiZXN0XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlbmQgdGhlIGJlc3QgcmVjb3JkIGZvdW5kIHRvIGFueSBwZWVycyB0aGF0IGhhdmUgYW4gb3V0IG9mIGRhdGUgcmVjb3JkLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0ga2V5XG4gICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gdmFscyAtIHZhbHVlcyByZXRyaWV2ZWQgZnJvbSB0aGUgREhUXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBiZXN0IC0gdGhlIGJlc3QgcmVjb3JkIHRoYXQgd2FzIGZvdW5kXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX3NlbmRDb3JyZWN0aW9uUmVjb3JkIChrZXksIHZhbHMsIGJlc3QpIHtcbiAgICBjb25zdCBmaXh1cFJlYyA9IGF3YWl0IHByb21pc2lmeShjYiA9PiB1dGlscy5jcmVhdGVQdXRSZWNvcmQoa2V5LCBiZXN0LCBjYikpKClcblxuICAgIHJldHVybiBQcm9taXNlLmFsbCh2YWxzLm1hcChhc3luYyAodikgPT4ge1xuICAgICAgLy8gbm8gbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgaWYgKHYudmFsLmVxdWFscyhiZXN0KSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gY29ycmVjdCBvdXJzZWxmXG4gICAgICBpZiAoZGh0Ll9pc1NlbGYodi5mcm9tKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IGRodC5fcHV0TG9jYWxBc3luYyhrZXksIGZpeHVwUmVjKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBkaHQuX2xvZy5lcnJvcignRmFpbGVkIGVycm9yIGNvcnJlY3Rpbmcgc2VsZicsIGVycilcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gc2VuZCBjb3JyZWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBkaHQuX3B1dFZhbHVlVG9QZWVyQXN5bmMoa2V5LCBmaXh1cFJlYywgdi5mcm9tKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGRodC5fbG9nLmVycm9yKCdGYWlsZWQgZXJyb3IgY29ycmVjdGluZyBlbnRyeScsIGVycilcbiAgICAgIH1cbiAgICB9KSlcbiAgfSxcblxuICAvKipcbiAgICogQXR0ZW1wdCB0byByZXRyaWV2ZSB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXkgZnJvbVxuICAgKiB0aGUgbG9jYWwgZGF0YXN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0ga2V5XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIFJlY29yZCl9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldExvY2FsIChrZXksIGNhbGxiYWNrKSB7XG4gICAgcHJvbWlzZVRvQ2FsbGJhY2sodGhpcy5fZ2V0TG9jYWxBc3luYyhrZXkpKShjYWxsYmFjaylcbiAgfSxcblxuICBhc3luYyBfZ2V0TG9jYWxBc3luYyAoa2V5KSB7XG4gICAgZGh0Ll9sb2coJ2dldExvY2FsICViJywga2V5KVxuXG4gICAgY29uc3QgcmF3ID0gYXdhaXQgcHJvbWlzaWZ5KGNiID0+IGRodC5kYXRhc3RvcmUuZ2V0KHV0aWxzLmJ1ZmZlclRvS2V5KGtleSksIGNiKSkoKVxuICAgIGRodC5fbG9nKCdmb3VuZCAlYiBpbiBsb2NhbCBkYXRhc3RvcmUnLCBrZXkpXG4gICAgY29uc3QgcmVjID0gUmVjb3JkLmRlc2VyaWFsaXplKHJhdylcblxuICAgIGF3YWl0IGRodC5fdmVyaWZ5UmVjb3JkTG9jYWxseUFzeW5jKHJlYylcbiAgICByZXR1cm4gcmVjXG4gIH0sXG5cbiAgLyoqXG4gICAqIFF1ZXJ5IGEgcGFydGljdWxhciBwZWVyIGZvciB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXkuXG4gICAqIEl0IHdpbGwgZWl0aGVyIHJldHVybiB0aGUgdmFsdWUgb3IgYSBsaXN0IG9mIGNsb3NlciBwZWVycy5cbiAgICpcbiAgICogTm90ZTogVGhlIHBlZXJib29rIGlzIHVwZGF0ZWQgd2l0aCBuZXcgYWRkcmVzc2VzIGZvdW5kIGZvciB0aGUgZ2l2ZW4gcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtQZWVySWR9IHBlZXJcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGtleVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBSZWRjb3JkLCBBcnJheTxQZWVySW5mbz4pfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgX2dldFZhbHVlT3JQZWVycyAocGVlciwga2V5LCBjYWxsYmFjaykge1xuICAgIHByb21pc2VUb0NhbGxiYWNrKHRoaXMuX2dldFZhbHVlT3JQZWVyc0FzeW5jKHBlZXIsIGtleSkpKChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdC5yZWNvcmQsIHJlc3VsdC5wZWVycylcbiAgICB9KVxuICB9LFxuXG4gIGFzeW5jIF9nZXRWYWx1ZU9yUGVlcnNBc3luYyAocGVlciwga2V5KSB7XG4gICAgY29uc3QgbXNnID0gYXdhaXQgcHJvbWlzaWZ5KGNiID0+IGRodC5fZ2V0VmFsdWVTaW5nbGUocGVlciwga2V5LCBjYikpKClcblxuICAgIGNvbnN0IHBlZXJzID0gbXNnLmNsb3NlclBlZXJzXG4gICAgY29uc3QgcmVjb3JkID0gbXNnLnJlY29yZFxuXG4gICAgaWYgKHJlY29yZCkge1xuICAgICAgLy8gV2UgaGF2ZSBhIHJlY29yZFxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZGh0Ll92ZXJpZnlSZWNvcmRPbmxpbmVBc3luYyhyZWNvcmQpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyTXNnID0gJ2ludmFsaWQgcmVjb3JkIHJlY2VpdmVkLCBkaXNjYXJkZWQnXG4gICAgICAgIGRodC5fbG9nKGVyck1zZylcbiAgICAgICAgdGhyb3cgZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9JTlZBTElEX1JFQ09SRCcpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHJlY29yZCwgcGVlcnMgfVxuICAgIH1cblxuICAgIGlmIChwZWVycy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4geyBwZWVycyB9XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyY29kZShuZXcgRXJyb3IoJ05vdCBmb3VuZCcpLCAnRVJSX05PVF9GT1VORCcpXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIHZhbHVlIHZpYSBycGMgY2FsbCBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlcklkfSBwZWVyXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBrZXlcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgTWVzc2FnZSl9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBfZ2V0VmFsdWVTaW5nbGUgKHBlZXIsIGtleSwgY2FsbGJhY2spIHtcbiAgICBwcm9taXNlVG9DYWxsYmFjayh0aGlzLl9nZXRWYWx1ZVNpbmdsZUFzeW5jKHBlZXIsIGtleSkpKGNhbGxiYWNrKVxuICB9LFxuXG4gIGFzeW5jIF9nZXRWYWx1ZVNpbmdsZUFzeW5jIChwZWVyLCBrZXkpIHtcbiAgICBjb25zdCBtc2cgPSBuZXcgTWVzc2FnZShNZXNzYWdlLlRZUEVTLkdFVF9WQUxVRSwga2V5LCAwKVxuICAgIHJldHVybiBwcm9taXNpZnkoY2IgPT4gZGh0Lm5ldHdvcmsuc2VuZFJlcXVlc3QocGVlciwgbXNnLCBjYikpKClcbiAgfSxcblxuICAvKipcbiAgICogVmVyaWZ5IGEgcmVjb3JkLCBmZXRjaGluZyBtaXNzaW5nIHB1YmxpYyBrZXlzIGZyb20gdGhlIG5ldHdvcmsuXG4gICAqIENhbGxzIGJhY2sgd2l0aCBhbiBlcnJvciBpZiB0aGUgcmVjb3JkIGlzIGludmFsaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVjb3JkfSByZWNvcmRcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBfdmVyaWZ5UmVjb3JkT25saW5lIChyZWNvcmQsIGNhbGxiYWNrKSB7XG4gICAgcHJvbWlzZVRvQ2FsbGJhY2sodGhpcy5fdmVyaWZ5UmVjb3JkT25saW5lQXN5bmMocmVjb3JkKSkoZXJyID0+IGNhbGxiYWNrKGVycikpXG4gIH0sXG5cbiAgYXN5bmMgX3ZlcmlmeVJlY29yZE9ubGluZUFzeW5jIChyZWNvcmQpIHtcbiAgICBhd2FpdCBwcm9taXNpZnkoY2IgPT4gbGlicDJwUmVjb3JkLnZhbGlkYXRvci52ZXJpZnlSZWNvcmQoZGh0LnZhbGlkYXRvcnMsIHJlY29yZCwgY2IpKSgpXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHVibGljIGtleSBkaXJlY3RseSBmcm9tIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtQZWVySWR9IHBlZXJcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgUHVibGljS2V5KX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIF9nZXRQdWJsaWNLZXlGcm9tTm9kZSAocGVlciwgY2FsbGJhY2spIHtcbiAgICBwcm9taXNlVG9DYWxsYmFjayh0aGlzLl9nZXRQdWJsaWNLZXlGcm9tTm9kZUFzeW5jKHBlZXIpKShjYWxsYmFjaylcbiAgfSxcblxuICBhc3luYyBfZ2V0UHVibGljS2V5RnJvbU5vZGVBc3luYyAocGVlcikge1xuICAgIGNvbnN0IHBrS2V5ID0gdXRpbHMua2V5Rm9yUHVibGljS2V5KHBlZXIpXG4gICAgLy8gY29uc3QgbXNnID0gYXdhaXQgZGh0Ll9nZXRWYWx1ZVNpbmdsZUFzeW5jKHBlZXIsIHBrS2V5KVxuICAgIGNvbnN0IG1zZyA9IGF3YWl0IHByb21pc2lmeShjYiA9PiBkaHQuX2dldFZhbHVlU2luZ2xlKHBlZXIsIHBrS2V5LCBjYikpKClcblxuICAgIGlmICghbXNnLnJlY29yZCB8fCAhbXNnLnJlY29yZC52YWx1ZSkge1xuICAgICAgdGhyb3cgZXJyY29kZShgTm9kZSBub3QgcmVzcG9uZGluZyB3aXRoIGl0cyBwdWJsaWMga2V5OiAke3BlZXIudG9CNThTdHJpbmcoKX1gLCAnRVJSX0lOVkFMSURfUkVDT1JEJylcbiAgICB9XG5cbiAgICBjb25zdCByZWNQZWVyID0gYXdhaXQgcHJvbWlzaWZ5KGNiID0+IFBlZXJJZC5jcmVhdGVGcm9tUHViS2V5KG1zZy5yZWNvcmQudmFsdWUsIGNiKSkoKVxuXG4gICAgLy8gY29tcGFyZSBoYXNoZXMgb2YgdGhlIHB1YiBrZXlcbiAgICBpZiAoIXJlY1BlZXIuaXNFcXVhbChwZWVyKSkge1xuICAgICAgdGhyb3cgZXJyY29kZSgncHVibGljIGtleSBkb2VzIG5vdCBtYXRjaCBpZCcsICdFUlJfUFVCTElDX0tFWV9ET0VTX05PVF9NQVRDSF9JRCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY1BlZXIucHViS2V5XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlYXJjaCB0aGUgZGh0IGZvciB1cCB0byBgbmAgcHJvdmlkZXJzIG9mIHRoZSBnaXZlbiBDSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q0lEfSBrZXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHByb3ZpZGVyVGltZW91dCAtIEhvdyBsb25nIHRoZSBxdWVyeSBzaG91bGQgbWF4aW1hbGx5IHJ1biBpbiBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEFycmF5PFBlZXJJbmZvPil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2ZpbmROUHJvdmlkZXJzIChrZXksIHByb3ZpZGVyVGltZW91dCwgbiwgY2FsbGJhY2spIHtcbiAgICBwcm9taXNlVG9DYWxsYmFjayh0aGlzLl9maW5kTlByb3ZpZGVyc0FzeW5jKGtleSwgcHJvdmlkZXJUaW1lb3V0LCBuKSkoY2FsbGJhY2spXG4gIH0sXG5cbiAgYXN5bmMgX2ZpbmROUHJvdmlkZXJzQXN5bmMgKGtleSwgcHJvdmlkZXJUaW1lb3V0LCBuKSB7XG4gICAgY29uc3Qgb3V0ID0gbmV3IExpbWl0ZWRQZWVyTGlzdChuKVxuXG4gICAgY29uc3QgcHJvdnMgPSBhd2FpdCBkaHQucHJvdmlkZXJzLmdldFByb3ZpZGVycyhrZXkpXG5cbiAgICBwcm92cy5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgbGV0IGluZm9cbiAgICAgIGlmIChkaHQucGVlckJvb2suaGFzKGlkKSkge1xuICAgICAgICBpbmZvID0gZGh0LnBlZXJCb29rLmdldChpZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gPSBkaHQucGVlckJvb2sucHV0KG5ldyBQZWVySW5mbyhpZCkpXG4gICAgICB9XG4gICAgICBvdXQucHVzaChpbmZvKVxuICAgIH0pXG5cbiAgICAvLyBBbGwgZG9uZVxuICAgIGlmIChvdXQubGVuZ3RoID49IG4pIHtcbiAgICAgIHJldHVybiBvdXQudG9BcnJheSgpXG4gICAgfVxuXG4gICAgLy8gbmVlZCBtb3JlLCBxdWVyeSB0aGUgbmV0d29ya1xuICAgIGNvbnN0IHBhdGhzID0gW11cbiAgICBjb25zdCBxdWVyeSA9IG5ldyBRdWVyeShkaHQsIGtleS5idWZmZXIsIChwYXRoSW5kZXgsIG51bVBhdGhzKSA9PiB7XG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIGJvZHkgcnVucyBvbmNlIHBlciBkaXNqb2ludCBwYXRoXG4gICAgICBjb25zdCBwYXRoU2l6ZSA9IHV0aWxzLnBhdGhTaXplKG4gLSBvdXQubGVuZ3RoLCBudW1QYXRocylcbiAgICAgIGNvbnN0IHBhdGhQcm92aWRlcnMgPSBuZXcgTGltaXRlZFBlZXJMaXN0KHBhdGhTaXplKVxuICAgICAgcGF0aHMucHVzaChwYXRoUHJvdmlkZXJzKVxuXG4gICAgICAvLyBIZXJlIHdlIHJldHVybiB0aGUgcXVlcnkgZnVuY3Rpb24gdG8gdXNlIG9uIHRoaXMgcGFydGljdWxhciBkaXNqb2ludCBwYXRoXG4gICAgICByZXR1cm4gYXN5bmMgKHBlZXIpID0+IHtcbiAgICAgICAgY29uc3QgbXNnID0gYXdhaXQgZGh0Ll9maW5kUHJvdmlkZXJzU2luZ2xlQXN5bmMocGVlciwga2V5KVxuICAgICAgICBjb25zdCBwcm92cyA9IG1zZy5wcm92aWRlclBlZXJzXG4gICAgICAgIGRodC5fbG9nKCcoJXMpIGZvdW5kICVzIHByb3ZpZGVyIGVudHJpZXMnLCBkaHQucGVlckluZm8uaWQudG9CNThTdHJpbmcoKSwgcHJvdnMubGVuZ3RoKVxuXG4gICAgICAgIHByb3ZzLmZvckVhY2goKHByb3YpID0+IHtcbiAgICAgICAgICBwYXRoUHJvdmlkZXJzLnB1c2goZGh0LnBlZXJCb29rLnB1dChwcm92KSlcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBob29yYXkgd2UgaGF2ZSBhbGwgdGhhdCB3ZSB3YW50XG4gICAgICAgIGlmIChwYXRoUHJvdmlkZXJzLmxlbmd0aCA+PSBwYXRoU2l6ZSkge1xuICAgICAgICAgIHJldHVybiB7IHBhdGhDb21wbGV0ZTogdHJ1ZSB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpdCBsb29rcyBsaWtlIHdlIHdhbnQgc29tZSBtb3JlXG4gICAgICAgIHJldHVybiB7IGNsb3NlclBlZXJzOiBtc2cuY2xvc2VyUGVlcnMgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBwZWVycyA9IGRodC5yb3V0aW5nVGFibGUuY2xvc2VzdFBlZXJzKGtleS5idWZmZXIsIGRodC5rQnVja2V0U2l6ZSlcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwcm9taXNpZnkoY2FsbGJhY2sgPT4gdGltZW91dCgoY2IpID0+IHtcbiAgICAgICAgcHJvbWlzZVRvQ2FsbGJhY2socXVlcnkucnVuKHBlZXJzKSkoY2IpXG4gICAgICB9LCBwcm92aWRlclRpbWVvdXQpKGNhbGxiYWNrKSkoKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5jb2RlICE9PSAnRVRJTUVET1VUJykge1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgcXVlcnkuc3RvcCgpXG4gICAgfVxuXG4gICAgLy8gY29tYmluZSBwZWVycyBmcm9tIGVhY2ggcGF0aFxuICAgIHBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgIHBhdGgudG9BcnJheSgpLmZvckVhY2goKHBlZXIpID0+IHtcbiAgICAgICAgb3V0LnB1c2gocGVlcilcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGlmIChvdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBlcnJjb2RlKG5ldyBFcnJvcignbm8gcHJvdmlkZXJzIGZvdW5kJyksICdFUlJfTk9UX0ZPVU5EJylcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0LnRvQXJyYXkoKVxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBmb3IgcHJvdmlkZXJzIGZyb20gYSBzaW5nbGUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtQZWVySWR9IHBlZXJcbiAgICogQHBhcmFtIHtDSUR9IGtleVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBNZXNzYWdlKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZmluZFByb3ZpZGVyc1NpbmdsZSAocGVlciwga2V5LCBjYWxsYmFjaykge1xuICAgIHByb21pc2VUb0NhbGxiYWNrKHRoaXMuX2ZpbmRQcm92aWRlcnNTaW5nbGVBc3luYyhwZWVyLCBrZXkpKShjYWxsYmFjaylcbiAgfSxcblxuICBhc3luYyBfZmluZFByb3ZpZGVyc1NpbmdsZUFzeW5jIChwZWVyLCBrZXkpIHtcbiAgICBjb25zdCBtc2cgPSBuZXcgTWVzc2FnZShNZXNzYWdlLlRZUEVTLkdFVF9QUk9WSURFUlMsIGtleS5idWZmZXIsIDApXG4gICAgcmV0dXJuIHByb21pc2lmeShjYiA9PiBkaHQubmV0d29yay5zZW5kUmVxdWVzdChwZWVyLCBtc2csIGNiKSkoKVxuICB9XG59KVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCBQZWVySW5mbyA9IHJlcXVpcmUoJ3BlZXItaW5mbycpXG5jb25zdCBQZWVySWQgPSByZXF1aXJlKCdwZWVyLWlkJylcbmNvbnN0IHByb3RvbnMgPSByZXF1aXJlKCdwcm90b25zJylcbmNvbnN0IFJlY29yZCA9IHJlcXVpcmUoJ2xpYnAycC1yZWNvcmQnKS5SZWNvcmRcblxuY29uc3QgcGJtID0gcHJvdG9ucyhyZXF1aXJlKCcuL2RodC5wcm90bycpKVxuXG5jb25zdCBNRVNTQUdFX1RZUEUgPSBwYm0uTWVzc2FnZS5NZXNzYWdlVHlwZVxuY29uc3QgQ09OTkVDVElPTl9UWVBFID0gcGJtLk1lc3NhZ2UuQ29ubmVjdGlvblR5cGVcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc2luZ2xlIERIVCBjb250cm9sIG1lc3NhZ2UuXG4gKi9cbmNsYXNzIE1lc3NhZ2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtNZXNzYWdlVHlwZX0gdHlwZVxuICAgKiBAcGFyYW0ge0J1ZmZlcn0ga2V5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFxuICAgKi9cbiAgY29uc3RydWN0b3IgKHR5cGUsIGtleSwgbGV2ZWwpIHtcbiAgICBpZiAoa2V5KSB7XG4gICAgICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKGtleSkpXG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gdHlwZVxuICAgIHRoaXMua2V5ID0ga2V5XG4gICAgdGhpcy5fY2x1c3RlckxldmVsUmF3ID0gbGV2ZWxcbiAgICB0aGlzLmNsb3NlclBlZXJzID0gW11cbiAgICB0aGlzLnByb3ZpZGVyUGVlcnMgPSBbXVxuICAgIHRoaXMucmVjb3JkID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgY2x1c3RlckxldmVsICgpIHtcbiAgICBjb25zdCBsZXZlbCA9IHRoaXMuX2NsdXN0ZXJMZXZlbFJhdyAtIDFcbiAgICBpZiAobGV2ZWwgPCAwKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiBsZXZlbFxuICB9XG5cbiAgc2V0IGNsdXN0ZXJMZXZlbCAobGV2ZWwpIHtcbiAgICB0aGlzLl9jbHVzdGVyTGV2ZWxSYXcgPSBsZXZlbFxuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSBpbnRvIHByb3RvYnVmXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gICAqL1xuICBzZXJpYWxpemUgKCkge1xuICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICBjbHVzdGVyTGV2ZWxSYXc6IHRoaXMuX2NsdXN0ZXJMZXZlbFJhdyxcbiAgICAgIGNsb3NlclBlZXJzOiB0aGlzLmNsb3NlclBlZXJzLm1hcCh0b1BiUGVlciksXG4gICAgICBwcm92aWRlclBlZXJzOiB0aGlzLnByb3ZpZGVyUGVlcnMubWFwKHRvUGJQZWVyKVxuICAgIH1cblxuICAgIGlmICh0aGlzLnJlY29yZCkge1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0aGlzLnJlY29yZCkpIHtcbiAgICAgICAgb2JqLnJlY29yZCA9IHRoaXMucmVjb3JkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmoucmVjb3JkID0gdGhpcy5yZWNvcmQuc2VyaWFsaXplKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGJtLk1lc3NhZ2UuZW5jb2RlKG9iailcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgZnJvbSBwcm90b2J1ZlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gcmF3XG4gICAqIEByZXR1cm5zIHtNZXNzYWdlfVxuICAgKi9cbiAgc3RhdGljIGRlc2VyaWFsaXplIChyYXcpIHtcbiAgICBjb25zdCBkZWMgPSBwYm0uTWVzc2FnZS5kZWNvZGUocmF3KVxuXG4gICAgY29uc3QgbXNnID0gbmV3IE1lc3NhZ2UoZGVjLnR5cGUsIGRlYy5rZXksIGRlYy5jbHVzdGVyTGV2ZWxSYXcpXG5cbiAgICBtc2cuY2xvc2VyUGVlcnMgPSBkZWMuY2xvc2VyUGVlcnMubWFwKGZyb21QYlBlZXIpXG4gICAgbXNnLnByb3ZpZGVyUGVlcnMgPSBkZWMucHJvdmlkZXJQZWVycy5tYXAoZnJvbVBiUGVlcilcbiAgICBpZiAoZGVjLnJlY29yZCkge1xuICAgICAgbXNnLnJlY29yZCA9IFJlY29yZC5kZXNlcmlhbGl6ZShkZWMucmVjb3JkKVxuICAgIH1cblxuICAgIHJldHVybiBtc2dcbiAgfVxufVxuXG5NZXNzYWdlLlRZUEVTID0gTUVTU0FHRV9UWVBFXG5NZXNzYWdlLkNPTk5FQ1RJT05fVFlQRVMgPSBDT05ORUNUSU9OX1RZUEVcblxuZnVuY3Rpb24gdG9QYlBlZXIgKHBlZXIpIHtcbiAgY29uc3QgcmVzID0ge1xuICAgIGlkOiBwZWVyLmlkLmlkLFxuICAgIGFkZHJzOiBwZWVyLm11bHRpYWRkcnMudG9BcnJheSgpLm1hcCgobSkgPT4gbS5idWZmZXIpXG4gIH1cblxuICBpZiAocGVlci5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgcmVzLmNvbm5lY3Rpb24gPSBDT05ORUNUSU9OX1RZUEUuQ09OTkVDVEVEXG4gIH0gZWxzZSB7XG4gICAgcmVzLmNvbm5lY3Rpb24gPSBDT05ORUNUSU9OX1RZUEUuTk9UX0NPTk5FQ1RFRFxuICB9XG5cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBmcm9tUGJQZWVyIChwZWVyKSB7XG4gIGNvbnN0IGluZm8gPSBuZXcgUGVlckluZm8obmV3IFBlZXJJZChwZWVyLmlkKSlcbiAgcGVlci5hZGRycy5mb3JFYWNoKChhKSA9PiBpbmZvLm11bHRpYWRkcnMuYWRkKGEpKVxuXG4gIHJldHVybiBpbmZvXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNhY2hlID0gcmVxdWlyZSgnaGFzaGxydScpXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuY29uc3QgUGVlcklkID0gcmVxdWlyZSgncGVlci1pZCcpXG5jb25zdCBLZXkgPSByZXF1aXJlKCdpbnRlcmZhY2UtZGF0YXN0b3JlJykuS2V5XG5jb25zdCBRdWV1ZSA9IHJlcXVpcmUoJ3AtcXVldWUnKVxuY29uc3QgcHJvbWlzaWZ5ID0gcmVxdWlyZSgncHJvbWlzaWZ5LWVzNicpXG5jb25zdCB0b0l0ZXJhdG9yID0gcmVxdWlyZSgncHVsbC1zdHJlYW0tdG8tYXN5bmMtaXRlcmF0b3InKVxuXG5jb25zdCBjID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcblxuLyoqXG4gKiBUaGlzIGNsYXNzIG1hbmFnZXMga25vd24gcHJvdmlkZXJzLlxuICogQSBwcm92aWRlciBpcyBhIHBlZXIgdGhhdCB3ZSBrbm93IHRvIGhhdmUgdGhlIGNvbnRlbnQgZm9yIGEgZ2l2ZW4gQ0lELlxuICpcbiAqIEV2ZXJ5IGBjbGVhbnVwSW50ZXJ2YWxgIHByb3ZpZGVycyBhcmUgY2hlY2tlZCBpZiB0aGV5XG4gKiBhcmUgc3RpbGwgdmFsaWQsIGkuZS4geW91bmdlciB0aGFuIHRoZSBgcHJvdmlkZVZhbGlkaXR5YC5cbiAqIElmIHRoZXkgYXJlIG5vdCwgdGhleSBhcmUgZGVsZXRlZC5cbiAqXG4gKiBUbyBlbnN1cmUgdGhlIGxpc3Qgc3Vydml2ZXMgcmVzdGFydHMgb2YgdGhlIGRhZW1vbixcbiAqIHByb3ZpZGVycyBhcmUgc3RvcmVkIGluIHRoZSBkYXRhc3RvcmUsIGJ1dCB0byBlbnN1cmVcbiAqIGFjY2VzcyBpcyBmYXN0IHRoZXJlIGlzIGFuIExSVSBjYWNoZSBpbiBmcm9udCBvZiB0aGF0LlxuICovXG5jbGFzcyBQcm92aWRlcnMge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFzdG9yZVxuICAgKiBAcGFyYW0ge1BlZXJJZH0gW3NlbGZdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY2FjaGVTaXplPTI1Nl1cbiAgICovXG4gIGNvbnN0cnVjdG9yIChkYXRhc3RvcmUsIHNlbGYsIGNhY2hlU2l6ZSkge1xuICAgIHRoaXMuZGF0YXN0b3JlID0gZGF0YXN0b3JlXG5cbiAgICB0aGlzLl9sb2cgPSB1dGlscy5sb2dnZXIoc2VsZiwgJ3Byb3ZpZGVycycpXG5cbiAgICAvKipcbiAgICAgKiBIb3cgb2Z0ZW4gaW52YWxpZCByZWNvcmRzIGFyZSBjbGVhbmVkLiAoaW4gc2Vjb25kcylcbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jbGVhbnVwSW50ZXJ2YWwgPSBjLlBST1ZJREVSU19DTEVBTlVQX0lOVEVSVkFMXG5cbiAgICAvKipcbiAgICAgKiBIb3cgbG9uZyBpcyBhIHByb3ZpZGVyIHZhbGlkIGZvci4gKGluIHNlY29uZHMpXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucHJvdmlkZVZhbGlkaXR5ID0gYy5QUk9WSURFUlNfVkFMSURJVFlcblxuICAgIC8qKlxuICAgICAqIExSVSBjYWNoZSBzaXplXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubHJ1Q2FjaGVTaXplID0gY2FjaGVTaXplIHx8IGMuUFJPVklERVJTX0xSVV9DQUNIRV9TSVpFXG5cbiAgICB0aGlzLnByb3ZpZGVycyA9IGNhY2hlKHRoaXMubHJ1Q2FjaGVTaXplKVxuXG4gICAgdGhpcy5zeW5jUXVldWUgPSBuZXcgUXVldWUoeyBjb25jdXJyZW5jeTogMSB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2UgYW55IHJlc291cmNlcy5cbiAgICpcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIHN0b3AgKCkge1xuICAgIGlmICh0aGlzLl9jbGVhbmVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX2NsZWFuZXIpXG4gICAgICB0aGlzLl9jbGVhbmVyID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBhbGwgcHJvdmlkZXJzIGlmIHRoZXkgYXJlIHN0aWxsIHZhbGlkLCBhbmQgaWYgbm90IGRlbGV0ZSB0aGVtLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jbGVhbnVwICgpIHtcbiAgICByZXR1cm4gdGhpcy5zeW5jUXVldWUuYWRkKGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuX2xvZygnc3RhcnQgY2xlYW51cCcpXG4gICAgICBjb25zdCBzdGFydCA9IERhdGUubm93KClcblxuICAgICAgbGV0IGNvdW50ID0gMFxuICAgICAgbGV0IGRlbGV0ZUNvdW50ID0gMFxuICAgICAgY29uc3QgZGVsZXRlZCA9IG5ldyBNYXAoKVxuICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLmRhdGFzdG9yZS5iYXRjaCgpXG5cbiAgICAgIC8vIEdldCBhbGwgcHJvdmlkZXIgZW50cmllcyBmcm9tIHRoZSBkYXRhc3RvcmVcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5kYXRhc3RvcmUucXVlcnkoeyBwcmVmaXg6IGMuUFJPVklERVJTX0tFWV9QUkVGSVggfSlcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZW50cnkgb2YgdG9JdGVyYXRvcihxdWVyeSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBBZGQgYSBkZWxldGUgdG8gdGhlIGJhdGNoIGZvciBlYWNoIGV4cGlyZWQgZW50cnlcbiAgICAgICAgICBjb25zdCB7IGNpZCwgcGVlcklkIH0gPSBwYXJzZVByb3ZpZGVyS2V5KGVudHJ5LmtleSlcbiAgICAgICAgICBjb25zdCB0aW1lID0gcmVhZFRpbWUoZW50cnkudmFsdWUpXG4gICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgICAgICAgIGNvbnN0IGRlbHRhID0gbm93IC0gdGltZVxuICAgICAgICAgIGNvbnN0IGV4cGlyZWQgPSBkZWx0YSA+IHRoaXMucHJvdmlkZVZhbGlkaXR5XG4gICAgICAgICAgdGhpcy5fbG9nKCdjb21wYXJpbmc6ICVkIC0gJWQgPSAlZCA+ICVkICVzJyxcbiAgICAgICAgICAgIG5vdywgdGltZSwgZGVsdGEsIHRoaXMucHJvdmlkZVZhbGlkaXR5LCBleHBpcmVkID8gJyhleHBpcmVkKScgOiAnJylcbiAgICAgICAgICBpZiAoZXhwaXJlZCkge1xuICAgICAgICAgICAgZGVsZXRlQ291bnQrK1xuICAgICAgICAgICAgYmF0Y2guZGVsZXRlKGVudHJ5LmtleSlcbiAgICAgICAgICAgIGNvbnN0IHBlZXJzID0gZGVsZXRlZC5nZXQoY2lkKSB8fCBuZXcgU2V0KClcbiAgICAgICAgICAgIHBlZXJzLmFkZChwZWVySWQpXG4gICAgICAgICAgICBkZWxldGVkLnNldChjaWQsIHBlZXJzKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCsrXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcihlcnIubWVzc2FnZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fbG9nKCdkZWxldGluZyAlZCAvICVkIGVudHJpZXMnLCBkZWxldGVDb3VudCwgY291bnQpXG5cbiAgICAgIC8vIENvbW1pdCB0aGUgZGVsZXRlcyB0byB0aGUgZGF0YXN0b3JlXG4gICAgICBpZiAoZGVsZXRlZC5zaXplKSB7XG4gICAgICAgIGF3YWl0IHByb21pc2lmeShjYiA9PiBiYXRjaC5jb21taXQoY2IpKSgpXG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFyIGV4cGlyZWQgZW50cmllcyBmcm9tIHRoZSBjYWNoZVxuICAgICAgZm9yIChjb25zdCBbY2lkLCBwZWVyc10gb2YgZGVsZXRlZCkge1xuICAgICAgICBjb25zdCBrZXkgPSBtYWtlUHJvdmlkZXJLZXkoY2lkKVxuICAgICAgICBjb25zdCBwcm92cyA9IHRoaXMucHJvdmlkZXJzLmdldChrZXkpXG4gICAgICAgIGlmIChwcm92cykge1xuICAgICAgICAgIGZvciAoY29uc3QgcGVlcklkIG9mIHBlZXJzKSB7XG4gICAgICAgICAgICBwcm92cy5kZWxldGUocGVlcklkKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJvdnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMucmVtb3ZlKGtleSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KGtleSwgcHJvdnMpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xvZygnQ2xlYW51cCBzdWNjZXNzZnVsICglZG1zKScsIERhdGUubm93KCkgLSBzdGFydClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudGx5IGtub3duIHByb3ZpZGVyIHBlZXIgaWRzIGZvciBhIGdpdmVuIENJRC5cbiAgICpcbiAgICogQHBhcmFtIHtDSUR9IGNpZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNYXA8U3RyaW5nLCBEYXRlPj59XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBfZ2V0UHJvdmlkZXJzTWFwIChjaWQpIHtcbiAgICBjb25zdCBjYWNoZUtleSA9IG1ha2VQcm92aWRlcktleShjaWQpXG4gICAgbGV0IHByb3ZzID0gdGhpcy5wcm92aWRlcnMuZ2V0KGNhY2hlS2V5KVxuICAgIGlmICghcHJvdnMpIHtcbiAgICAgIHByb3ZzID0gYXdhaXQgbG9hZFByb3ZpZGVycyh0aGlzLmRhdGFzdG9yZSwgY2lkKVxuICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KGNhY2hlS2V5LCBwcm92cylcbiAgICB9XG4gICAgcmV0dXJuIHByb3ZzXG4gIH1cblxuICBnZXQgY2xlYW51cEludGVydmFsICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xlYW51cEludGVydmFsXG4gIH1cblxuICBzZXQgY2xlYW51cEludGVydmFsICh2YWwpIHtcbiAgICB0aGlzLl9jbGVhbnVwSW50ZXJ2YWwgPSB2YWxcblxuICAgIGlmICh0aGlzLl9jbGVhbmVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX2NsZWFuZXIpXG4gICAgfVxuXG4gICAgdGhpcy5fY2xlYW5lciA9IHNldEludGVydmFsKFxuICAgICAgKCkgPT4gdGhpcy5fY2xlYW51cCgpLFxuICAgICAgdGhpcy5jbGVhbnVwSW50ZXJ2YWxcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IHByb3ZpZGVyIGZvciB0aGUgZ2l2ZW4gQ0lELlxuICAgKlxuICAgKiBAcGFyYW0ge0NJRH0gY2lkXG4gICAqIEBwYXJhbSB7UGVlcklkfSBwcm92aWRlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIGFkZFByb3ZpZGVyIChjaWQsIHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuc3luY1F1ZXVlLmFkZChhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLl9sb2coJ2FkZFByb3ZpZGVyICVzJywgY2lkLnRvQmFzZUVuY29kZWRTdHJpbmcoKSlcbiAgICAgIGNvbnN0IHByb3ZzID0gYXdhaXQgdGhpcy5fZ2V0UHJvdmlkZXJzTWFwKGNpZClcblxuICAgICAgdGhpcy5fbG9nKCdsb2FkZWQgJXMgcHJvdnMnLCBwcm92cy5zaXplKVxuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgICAgcHJvdnMuc2V0KHV0aWxzLmVuY29kZUJhc2UzMihwcm92aWRlci5pZCksIG5vdylcblxuICAgICAgY29uc3QgZHNLZXkgPSBtYWtlUHJvdmlkZXJLZXkoY2lkKVxuICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KGRzS2V5LCBwcm92cylcbiAgICAgIHJldHVybiB3cml0ZVByb3ZpZGVyRW50cnkodGhpcy5kYXRhc3RvcmUsIGNpZCwgcHJvdmlkZXIsIG5vdylcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgcHJvdmlkZXJzIGZvciB0aGUgZ2l2ZW4gQ0lELlxuICAgKlxuICAgKiBAcGFyYW0ge0NJRH0gY2lkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PFBlZXJJZD4+fVxuICAgKi9cbiAgYXN5bmMgZ2V0UHJvdmlkZXJzIChjaWQpIHtcbiAgICByZXR1cm4gdGhpcy5zeW5jUXVldWUuYWRkKGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuX2xvZygnZ2V0UHJvdmlkZXJzICVzJywgY2lkLnRvQmFzZUVuY29kZWRTdHJpbmcoKSlcbiAgICAgIGNvbnN0IHByb3ZzID0gYXdhaXQgdGhpcy5fZ2V0UHJvdmlkZXJzTWFwKGNpZClcbiAgICAgIHJldHVybiBbLi4ucHJvdnMua2V5cygpXS5tYXAoKGJhc2UzMlBlZXJJZCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFBlZXJJZCh1dGlscy5kZWNvZGVCYXNlMzIoYmFzZTMyUGVlcklkKSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIEVuY29kZSB0aGUgZ2l2ZW4ga2V5IGl0cyBtYXRjaGluZyBkYXRhc3RvcmUga2V5LlxuICpcbiAqIEBwYXJhbSB7Q0lEfHN0cmluZ30gY2lkIC0gY2lkIG9yIGJhc2UzMiBlbmNvZGVkIHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ31cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlUHJvdmlkZXJLZXkgKGNpZCkge1xuICBjaWQgPSB0eXBlb2YgY2lkID09PSAnc3RyaW5nJyA/IGNpZCA6IHV0aWxzLmVuY29kZUJhc2UzMihjaWQuYnVmZmVyKVxuICByZXR1cm4gYy5QUk9WSURFUlNfS0VZX1BSRUZJWCArIGNpZFxufVxuXG4vKipcbiAqIFdyaXRlIGEgcHJvdmlkZXIgaW50byB0aGUgZ2l2ZW4gc3RvcmUuXG4gKlxuICogQHBhcmFtIHtEYXRhc3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0NJRH0gY2lkXG4gKiBAcGFyYW0ge1BlZXJJZH0gcGVlclxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlUHJvdmlkZXJFbnRyeSAoc3RvcmUsIGNpZCwgcGVlciwgdGltZSkge1xuICBjb25zdCBkc0tleSA9IFtcbiAgICBtYWtlUHJvdmlkZXJLZXkoY2lkKSxcbiAgICAnLycsXG4gICAgdXRpbHMuZW5jb2RlQmFzZTMyKHBlZXIuaWQpXG4gIF0uam9pbignJylcblxuICBjb25zdCBrZXkgPSBuZXcgS2V5KGRzS2V5KVxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbSh2YXJpbnQuZW5jb2RlKHRpbWUpKVxuICByZXR1cm4gcHJvbWlzaWZ5KGNiID0+IHN0b3JlLnB1dChrZXksIGJ1ZmZlciwgY2IpKSgpXG59XG5cbi8qKlxuICogUGFyc2UgdGhlIENJRCBhbmQgcHJvdmlkZXIgcGVlciBpZCBmcm9tIHRoZSBrZXlcbiAqXG4gKiBAcGFyYW0ge0RLZXl9IGtleVxuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IHdpdGggcGVlciBpZCBhbmQgY2lkXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VQcm92aWRlcktleSAoa2V5KSB7XG4gIGNvbnN0IHBhcnRzID0ga2V5LnRvU3RyaW5nKCkuc3BsaXQoJy8nKVxuICBpZiAocGFydHMubGVuZ3RoICE9PSA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbmNvcnJlY3RseSBmb3JtYXR0ZWQgcHJvdmlkZXIgZW50cnkga2V5IGluIGRhdGFzdG9yZTogJyArIGtleSlcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2lkOiBwYXJ0c1syXSxcbiAgICBwZWVySWQ6IHBhcnRzWzNdXG4gIH1cbn1cblxuLyoqXG4gKiBMb2FkIHByb3ZpZGVycyBmb3IgdGhlIGdpdmVuIENJRCBmcm9tIHRoZSBzdG9yZS5cbiAqXG4gKiBAcGFyYW0ge0RhdGFzdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7Q0lEfSBjaWRcbiAqIEByZXR1cm5zIHtQcm9taXNlPE1hcDxQZWVySWQsIERhdGU+Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkUHJvdmlkZXJzIChzdG9yZSwgY2lkKSB7XG4gIGNvbnN0IHByb3ZpZGVycyA9IG5ldyBNYXAoKVxuICBjb25zdCBxdWVyeSA9IHN0b3JlLnF1ZXJ5KHsgcHJlZml4OiBtYWtlUHJvdmlkZXJLZXkoY2lkKSB9KVxuICBmb3IgYXdhaXQgKGNvbnN0IGVudHJ5IG9mIHRvSXRlcmF0b3IocXVlcnkpKSB7XG4gICAgY29uc3QgeyBwZWVySWQgfSA9IHBhcnNlUHJvdmlkZXJLZXkoZW50cnkua2V5KVxuICAgIHByb3ZpZGVycy5zZXQocGVlcklkLCByZWFkVGltZShlbnRyeS52YWx1ZSkpXG4gIH1cbiAgcmV0dXJuIHByb3ZpZGVyc1xufVxuXG5mdW5jdGlvbiByZWFkVGltZSAoYnVmKSB7XG4gIHJldHVybiB2YXJpbnQuZGVjb2RlKGJ1Zilcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcm92aWRlcnNcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBLQnVja2V0ID0gcmVxdWlyZSgnay1idWNrZXQnKVxuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuXG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgYGstYnVja2V0YCwgdG8gcHJvdmlkZSBlYXN5IHN0b3JlIGFuZFxuICogcmV0cml2YWwgZm9yIHBlZXJzLlxuICovXG5jbGFzcyBSb3V0aW5nVGFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtQZWVySWR9IHNlbGZcbiAgICogQHBhcmFtIHtudW1iZXJ9IGtCdWNrZXRTaXplXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoc2VsZiwga0J1Y2tldFNpemUpIHtcbiAgICB0aGlzLnNlbGYgPSBzZWxmXG4gICAgdGhpcy5fb25QaW5nID0gdGhpcy5fb25QaW5nLmJpbmQodGhpcylcblxuICAgIHV0aWxzLmNvbnZlcnRQZWVySWQoc2VsZiwgKGVyciwgc2VsZktleSkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cblxuICAgICAgdGhpcy5rYiA9IG5ldyBLQnVja2V0KHtcbiAgICAgICAgbG9jYWxOb2RlSWQ6IHNlbGZLZXksXG4gICAgICAgIG51bWJlck9mTm9kZXNQZXJLQnVja2V0OiBrQnVja2V0U2l6ZSxcbiAgICAgICAgbnVtYmVyT2ZOb2Rlc1RvUGluZzogMVxuICAgICAgfSlcblxuICAgICAgdGhpcy5rYi5vbigncGluZycsIHRoaXMuX29uUGluZylcbiAgICB9KVxuICB9XG5cbiAgLy8gLS0gUHJpdmF0ZSBNZXRob2RzXG5cbiAgLyoqXG4gICAqIENhbGxlZCBvbiB0aGUgYHBpbmdgIGV2ZW50IGZyb20gYGstYnVja2V0YC5cbiAgICogQ3VycmVudGx5IHRoaXMganVzdCByZW1vdmVzIHRoZSBvbGRlc3QgY29udGFjdCBmcm9tXG4gICAqIHRoZSBsaXN0LCB3aXRob3V0IGFjdXRhbGx5IHBpbmdpbmcgdGhlIGluZGl2aWR1YWwgcGVlcnMuXG4gICAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgZ28gZG9lcywgYnV0IHNob3VsZCBwcm9iYWJseVxuICAgKiBiZSB1cGdyYWRlZCB0byBhY3R1YWxseSBwaW5nIHRoZSBpbmRpdmlkdWFsIHBlZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IG9sZENvbnRhY3RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdDb250YWN0XG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25QaW5nIChvbGRDb250YWN0cywgbmV3Q29udGFjdCkge1xuICAgIC8vIGp1c3QgdXNlIHRoZSBmaXJzdCBvbmUgKGstYnVja2V0IHNvcnRzIGZyb20gb2xkZXN0IHRvIG5ld2VzdClcbiAgICBjb25zdCBvbGRlc3QgPSBvbGRDb250YWN0c1swXVxuXG4gICAgLy8gcmVtb3ZlIHRoZSBvbGRlc3Qgb25lXG4gICAgdGhpcy5rYi5yZW1vdmUob2xkZXN0LmlkKVxuXG4gICAgLy8gYWRkIHRoZSBuZXcgb25lXG4gICAgdGhpcy5rYi5hZGQobmV3Q29udGFjdClcbiAgfVxuXG4gIC8vIC0tIFB1YmxpYyBJbnRlcmZhY2VcblxuICAvKipcbiAgICogQW1vdW50IG9mIGN1cnJlbnRseSBzdG9yZWQgcGVlcnMuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMua2IuY291bnQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYSBzcGVjaWZpYyBwZWVyIGJ5IGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge1BlZXJJZH0gcGVlclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBQZWVySWQpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZpbmQgKHBlZXIsIGNhbGxiYWNrKSB7XG4gICAgdXRpbHMuY29udmVydFBlZXJJZChwZWVyLCAoZXJyLCBrZXkpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNsb3Nlc3QgPSB0aGlzLmNsb3Nlc3RQZWVyKGtleSlcblxuICAgICAgaWYgKGNsb3Nlc3QgJiYgY2xvc2VzdC5pc0VxdWFsKHBlZXIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBjbG9zZXN0KVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjaygpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgY2xvc2VzdCBwZWVycyB0byB0aGUgZ2l2ZW4ga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0ga2V5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICAgKiBAcmV0dXJucyB7UGVlcklkfHVuZGVmaW5lZH1cbiAgICovXG4gIGNsb3Nlc3RQZWVyIChrZXksIGNvdW50KSB7XG4gICAgY29uc3QgcmVzID0gdGhpcy5jbG9zZXN0UGVlcnMoa2V5LCAxKVxuICAgIGlmIChyZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHJlc1swXVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgYGNvdW50YC1jbG9zZXN0IHBlZXJzIHRvIHRoZSBnaXZlbiBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBrZXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gICAqIEByZXR1cm5zIHtBcnJheTxQZWVySWQ+fVxuICAgKi9cbiAgY2xvc2VzdFBlZXJzIChrZXksIGNvdW50KSB7XG4gICAgcmV0dXJuIHRoaXMua2IuY2xvc2VzdChrZXksIGNvdW50KS5tYXAoKHApID0+IHAucGVlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgb3IgdXBkYXRlIHRoZSByb3V0aW5nIHRhYmxlIHdpdGggdGhlIGdpdmVuIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlcklkfSBwZWVyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgYWRkIChwZWVyLCBjYWxsYmFjaykge1xuICAgIHV0aWxzLmNvbnZlcnRQZWVySWQocGVlciwgKGVyciwgaWQpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cbiAgICAgIHRoaXMua2IuYWRkKHsgaWQ6IGlkLCBwZWVyOiBwZWVyIH0pXG4gICAgICBjYWxsYmFjaygpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBnaXZlbiBwZWVyIGZyb20gdGhlIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0ge1BlZXJJZH0gcGVlclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIHJlbW92ZSAocGVlciwgY2FsbGJhY2spIHtcbiAgICB1dGlscy5jb252ZXJ0UGVlcklkKHBlZXIsIChlcnIsIGlkKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgICB0aGlzLmtiLnJlbW92ZShpZClcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUm91dGluZ1RhYmxlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHJvbWlzaWZ5ID0gcmVxdWlyZSgncHJvbWlzaWZ5LWVzNicpXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdsaWJwMnAtY3J5cHRvJylcbmNvbnN0IG11bHRpaGFzaGluZyA9IHByb21pc2lmeShyZXF1aXJlKCdtdWx0aWhhc2hpbmctYXN5bmMnKSlcbmNvbnN0IFBlZXJJZCA9IHJlcXVpcmUoJ3BlZXItaWQnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IEFib3J0Q29udHJvbGxlciA9IHJlcXVpcmUoJ2Fib3J0LWNvbnRyb2xsZXInKVxuY29uc3QgZXJyY29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcbmNvbnN0IHRpbWVzID0gcmVxdWlyZSgncC10aW1lcycpXG5jb25zdCBjID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuXG5jbGFzcyBSYW5kb21XYWxrIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0RIVH0gZGh0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7cmFuZG9tV2Fsa09wdGlvbnMuZW5hYmxlZH0gb3B0aW9ucy5lbmFibGVkXG4gICAqIEBwYXJhbSB7cmFuZG9tV2Fsa09wdGlvbnMucXVlcmllc1BlclBlcmlvZH0gb3B0aW9ucy5xdWVyaWVzUGVyUGVyaW9kXG4gICAqIEBwYXJhbSB7cmFuZG9tV2Fsa09wdGlvbnMuaW50ZXJ2YWx9IG9wdGlvbnMuaW50ZXJ2YWxcbiAgICogQHBhcmFtIHtyYW5kb21XYWxrT3B0aW9ucy50aW1lb3V0fSBvcHRpb25zLnRpbWVvdXRcbiAgICogQHBhcmFtIHtyYW5kb21XYWxrT3B0aW9ucy5kZWxheX0gb3B0aW9ucy5kZWxheVxuICAgKiBAcGFyYW0ge0RIVH0gb3B0aW9ucy5kaHRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkaHQsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnQoZGh0LCAnUmFuZG9tIFdhbGsgbmVlZHMgYW4gaW5zdGFuY2Ugb2YgdGhlIEthZGVtbGlhIERIVCcpXG4gICAgdGhpcy5fb3B0aW9ucyA9IHsgLi4uYy5kZWZhdWx0UmFuZG9tV2FsaywgLi4ub3B0aW9ucyB9XG4gICAgdGhpcy5fa2FkREhUID0gZGh0XG4gICAgdGhpcy5sb2cgPSBsb2dnZXIoZGh0LnBlZXJJbmZvLmlkLCAncmFuZG9tLXdhbGsnKVxuICAgIHRoaXMuX3RpbWVvdXRJZCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSBSYW5kb20gV2FsayBwcm9jZXNzLiBUaGlzIG1lYW5zIHJ1bm5pbmcgYSBudW1iZXIgb2YgcXVlcmllc1xuICAgKiBldmVyeSBpbnRlcnZhbCByZXF1ZXN0aW5nIHJhbmRvbSBkYXRhLiBUaGlzIGlzIGRvbmUgdG8ga2VlcCB0aGUgZGh0XG4gICAqIGhlYWx0aHkgb3ZlciB0aW1lLlxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHN0YXJ0ICgpIHtcbiAgICAvLyBEb24ndCBydW4gdHdpY2VcbiAgICBpZiAodGhpcy5fdGltZW91dElkIHx8ICF0aGlzLl9vcHRpb25zLmVuYWJsZWQpIHsgcmV0dXJuIH1cblxuICAgIC8vIFN0YXJ0IGRvaW5nIHJhbmRvbSB3YWxrcyBhZnRlciBgdGhpcy5fb3B0aW9ucy5kZWxheWBcbiAgICB0aGlzLl90aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIFN0YXJ0IHJ1bm5lciBpbW1lZGlhdGVseVxuICAgICAgdGhpcy5fcnVuUGVyaW9kaWNhbGx5KClcbiAgICB9LCB0aGlzLl9vcHRpb25zLmRlbGF5KVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIHJhbmRvbS13YWxrIHByb2Nlc3MuIEFueSBhY3RpdmVcbiAgICogcXVlcmllcyB3aWxsIGJlIGFib3J0ZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgc3RvcCAoKSB7XG4gICAgaWYgKHRoaXMuX3RpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRJZClcbiAgICAgIHRoaXMuX3RpbWVvdXRJZCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgICB0aGlzLl9jb250cm9sbGVyICYmIHRoaXMuX2NvbnRyb2xsZXIuYWJvcnQoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBmdW5jdGlvbiBgcmFuZG9tV2Fsay5fd2Fsa2Agb24gZXZlcnkgYG9wdGlvbnMuaW50ZXJ2YWxgIG1zXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBfcnVuUGVyaW9kaWNhbGx5ICgpIHtcbiAgICAvLyBydW4gdW50aWwgdGhlIHdhbGsgaGFzIGJlZW4gc3RvcHBlZFxuICAgIHdoaWxlICh0aGlzLl90aW1lb3V0SWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3dhbGsodGhpcy5fb3B0aW9ucy5xdWVyaWVzUGVyUGVyaW9kLCB0aGlzLl9vcHRpb25zLnRpbWVvdXQpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5fa2FkREhULl9sb2cuZXJyb3IoJ3JhbmRvbS13YWxrOmVycm9yJywgZXJyKVxuICAgICAgfVxuICAgICAgLy8gRWFjaCBzdWJzZXF1ZW50IHdhbGsgc2hvdWxkIHJ1biBvbiBhIGB0aGlzLl9vcHRpb25zLmludGVydmFsYCBpbnRlcnZhbFxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRoaXMuX3RpbWVvdXRJZCA9IHNldFRpbWVvdXQocmVzb2x2ZSwgdGhpcy5fb3B0aW9ucy5pbnRlcnZhbClcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERvIHRoZSByYW5kb20gd2FsayB3b3JrLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcXVlcmllc1xuICAgKiBAcGFyYW0ge251bWJlcn0gd2Fsa1RpbWVvdXRcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBfd2FsayAocXVlcmllcywgd2Fsa1RpbWVvdXQpIHtcbiAgICB0aGlzLmxvZygnc3RhcnQnKVxuICAgIHRoaXMuX2NvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aW1lcyhxdWVyaWVzLCBhc3luYyAoaW5kZXgpID0+IHtcbiAgICAgICAgdGhpcy5sb2coJ3J1bm5pbmcgcXVlcnkgJWQnLCBpbmRleClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBpZCA9IGF3YWl0IHRoaXMuX3JhbmRvbVBlZXJJZCgpXG5cbiAgICAgICAgICAvLyBDaGVjayBpZiB3ZSd2ZSBoYXBwZW5lZCB0byBhbHJlYWR5IGFib3J0XG4gICAgICAgICAgaWYgKCF0aGlzLl9jb250cm9sbGVyKSByZXR1cm5cblxuICAgICAgICAgIGF3YWl0IHRoaXMuX3F1ZXJ5KGlkLCB7XG4gICAgICAgICAgICB0aW1lb3V0OiB3YWxrVGltZW91dCxcbiAgICAgICAgICAgIHNpZ25hbDogdGhpcy5fY29udHJvbGxlci5zaWduYWxcbiAgICAgICAgICB9KVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlICE9PSAnRVRJTUVET1VUJykge1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ3F1ZXJ5ICVkIGZpbmlzaGVkIHdpdGggZXJyb3InLCBpbmRleCwgZXJyKVxuICAgICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb2coJ2ZpbmlzaGVkIHF1ZXJ5ICVkJywgaW5kZXgpXG4gICAgICB9KVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9jb250cm9sbGVyID0gbnVsbFxuICAgICAgdGhpcy5sb2coJ2ZpbmlzaGVkIHF1ZXJpZXMnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcXVlcnkgcnVuIGR1cmluZyBhIHJhbmRvbSB3YWxrIHJlcXVlc3QuXG4gICAqXG4gICAqIFRPRE86IFdoaWxlIHF1ZXJ5IGN1cnJlbnRseSBzdXBwb3J0cyBhbiBhYm9ydCBjb250cm9sbGVyLCBpdCBpcyBub3RcbiAgICogeWV0IHN1cHBvcnRlZCBieSBgREhULmZpbmRQZWVyYC4gT25jZSBodHRwczovL2dpdGh1Yi5jb20vbGlicDJwL2pzLWxpYnAycC1rYWQtZGh0L3B1bGwvODJcbiAgICogaXMgY29tcGxldGUsIGFuZCBBYm9ydENvbnRyb2xsZXIgc3VwcG9ydCBoYXMgYmVlbiBhZGRlZCB0byB0aGVcbiAgICogREhUIHF1ZXJ5IGZ1bmN0aW9ucywgdGhlIGFib3J0IGhlcmUgd2lsbCBqdXN0IHdvcmssIHByb3ZpZGVkIHRoZVxuICAgKiBmdW5jdGlvbnMgc3VwcG9ydCBgb3B0aW9ucy5zaWduYWxgLiBPbmNlIGRvbmUsIHRoaXMgdG9kbyBzaG91bGQgYmVcbiAgICogcmVtb3ZlZC5cbiAgICpcbiAgICogQHBhcmFtIHtQZWVySWR9IGlkXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRpbWVvdXRcbiAgICogQHBhcmFtIHtBYm9ydENvbnRyb2xsZXJTaWduYWx9IG9wdGlvbnMuc2lnbmFsXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX3F1ZXJ5IChpZCwgb3B0aW9ucykge1xuICAgIHRoaXMubG9nKCdxdWVyeTolcycsIGlkLnRvQjU4U3RyaW5nKCkpXG5cbiAgICBsZXQgcGVlclxuICAgIHRyeSB7XG4gICAgICBwZWVyID0gYXdhaXQgcHJvbWlzaWZ5KGNiID0+IHRoaXMuX2thZERIVC5maW5kUGVlcihpZCwgb3B0aW9ucywgY2IpKSgpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSAnRVJSX05PVF9GT1VORCcpIHtcbiAgICAgICAgLy8gZXhwZWN0ZWQgY2FzZSwgd2UgYXNrZWQgZm9yIHJhbmRvbSBzdHVmZiBhZnRlciBhbGxcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIHRoaXMubG9nKCdxdWVyeTpmb3VuZCcsIHBlZXIpXG5cbiAgICAvLyB3YWl0IHdoYXQsIHRoZXJlIHdhcyBzb21ldGhpbmcgZm91bmQ/IEx1Y2t5IGRheSFcbiAgICB0aHJvdyBlcnJjb2RlKGByYW5kb20td2FsazogQUNUVUFMTFkgRk9VTkQgUEVFUjogJHtwZWVyfSwgJHtpZC50b0I1OFN0cmluZygpfWAsICdFUlJfRk9VTkRfUkFORE9NX1BFRVInKVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgcmFuZG9tIHBlZXIgaWQgZm9yIHJhbmRvbS13YWxrIHB1cnBvc2VzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQZWVySWQ+fVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX3JhbmRvbVBlZXJJZCAoKSB7XG4gICAgY29uc3QgZGlnZXN0ID0gYXdhaXQgbXVsdGloYXNoaW5nKGNyeXB0by5yYW5kb21CeXRlcygxNiksICdzaGEyLTI1NicpXG4gICAgcmV0dXJuIG5ldyBQZWVySWQoZGlnZXN0KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tV2Fsa1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgbXVsdGloYXNoaW5nID0gcmVxdWlyZSgnbXVsdGloYXNoaW5nLWFzeW5jJylcbmNvbnN0IG1oID0gcmVxdWlyZSgnbXVsdGloYXNoZXMnKVxuY29uc3QgS2V5ID0gcmVxdWlyZSgnaW50ZXJmYWNlLWRhdGFzdG9yZScpLktleVxuY29uc3QgYmFzZTMyID0gcmVxdWlyZSgnYmFzZTMyLmpzJylcbmNvbnN0IGRpc3RhbmNlID0gcmVxdWlyZSgneG9yLWRpc3RhbmNlJylcbmNvbnN0IG1hcCA9IHJlcXVpcmUoJ2FzeW5jL21hcCcpXG5jb25zdCBSZWNvcmQgPSByZXF1aXJlKCdsaWJwMnAtcmVjb3JkJykuUmVjb3JkXG5jb25zdCBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdhc3luYy9zZXRJbW1lZGlhdGUnKVxuY29uc3QgUGVlcklkID0gcmVxdWlyZSgncGVlci1pZCcpXG5jb25zdCBlcnJjb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuXG4vKipcbiAqIENyZWF0ZXMgYSBESFQgSUQgYnkgaGFzaGluZyBhIGdpdmVuIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBCdWZmZXIpfSBjYWxsYmFja1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydHMuY29udmVydEJ1ZmZlciA9IChidWYsIGNhbGxiYWNrKSA9PiB7XG4gIG11bHRpaGFzaGluZy5kaWdlc3QoYnVmLCAnc2hhMi0yNTYnLCBjYWxsYmFjaylcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgREhUIElEIGJ5IGhhc2hpbmcgYSBQZWVyIElEXG4gKlxuICogQHBhcmFtIHtQZWVySWR9IHBlZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEJ1ZmZlcil9IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0cy5jb252ZXJ0UGVlcklkID0gKHBlZXIsIGNhbGxiYWNrKSA9PiB7XG4gIG11bHRpaGFzaGluZy5kaWdlc3QocGVlci5pZCwgJ3NoYTItMjU2JywgY2FsbGJhY2spXG59XG5cbi8qKlxuICogQ29udmVydCBhIGJ1ZmZlciB0byB0aGVpciBTSEEyLTI1NiBoYXNoLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZcbiAqIEByZXR1cm5zIHtLZXl9XG4gKi9cbmV4cG9ydHMuYnVmZmVyVG9LZXkgPSAoYnVmKSA9PiB7XG4gIHJldHVybiBuZXcgS2V5KCcvJyArIGV4cG9ydHMuZW5jb2RlQmFzZTMyKGJ1ZiksIGZhbHNlKVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBrZXkgZm9yIGEgcHVibGljIGtleS5cbiAqXG4gKiBAcGFyYW0ge1BlZXJJZH0gcGVlclxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5rZXlGb3JQdWJsaWNLZXkgPSAocGVlcikgPT4ge1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbXG4gICAgQnVmZmVyLmZyb20oJy9way8nKSxcbiAgICBwZWVyLmlkXG4gIF0pXG59XG5cbmV4cG9ydHMuaXNQdWJsaWNLZXlLZXkgPSAoa2V5KSA9PiB7XG4gIHJldHVybiBrZXkuc2xpY2UoMCwgNCkudG9TdHJpbmcoKSA9PT0gJy9way8nXG59XG5cbmV4cG9ydHMuZnJvbVB1YmxpY0tleUtleSA9IChrZXkpID0+IHtcbiAgcmV0dXJuIG5ldyBQZWVySWQoa2V5LnNsaWNlKDQpKVxufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCB0aW1lIGFzIHRpbWVzdGFtcC5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLm5vdyA9ICgpID0+IHtcbiAgcmV0dXJuIERhdGUubm93KClcbn1cblxuLyoqXG4gKiBFbmNvZGUgYSBnaXZlbiBidWZmZXIgaW50byBhIGJhc2UzMiBzdHJpbmcuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLmVuY29kZUJhc2UzMiA9IChidWYpID0+IHtcbiAgY29uc3QgZW5jID0gbmV3IGJhc2UzMi5FbmNvZGVyKClcbiAgcmV0dXJuIGVuYy53cml0ZShidWYpLmZpbmFsaXplKClcbn1cblxuLyoqXG4gKiBEZWNvZGUgYSBnaXZlbiBiYXNlMzIgc3RyaW5nIGludG8gYSBidWZmZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmF3XG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5leHBvcnRzLmRlY29kZUJhc2UzMiA9IChyYXcpID0+IHtcbiAgY29uc3QgZGVjID0gbmV3IGJhc2UzMi5EZWNvZGVyKClcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRlYy53cml0ZShyYXcpLmZpbmFsaXplKCkpXG59XG5cbi8qKlxuICogU29ydCBwZWVycyBieSBkaXN0YW5jZSB0byB0aGUgZ2l2ZW4gYHRhcmdldGAuXG4gKlxuICogQHBhcmFtIHtBcnJheTxQZWVySWQ+fSBwZWVyc1xuICogQHBhcmFtIHtCdWZmZXJ9IHRhcmdldFxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQXJyYXk8UGVlcklkPil9IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0cy5zb3J0Q2xvc2VzdFBlZXJzID0gKHBlZXJzLCB0YXJnZXQsIGNhbGxiYWNrKSA9PiB7XG4gIG1hcChwZWVycywgKHBlZXIsIGNiKSA9PiB7XG4gICAgZXhwb3J0cy5jb252ZXJ0UGVlcklkKHBlZXIsIChlcnIsIGlkKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICB9XG5cbiAgICAgIGNiKG51bGwsIHtcbiAgICAgICAgcGVlcjogcGVlcixcbiAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlKGlkLCB0YXJnZXQpXG4gICAgICB9KVxuICAgIH0pXG4gIH0sIChlcnIsIGRpc3RhbmNlcykgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgZGlzdGFuY2VzLnNvcnQoZXhwb3J0cy54b3JDb21wYXJlKS5tYXAoKGQpID0+IGQucGVlcikpXG4gIH0pXG59XG5cbi8qKlxuICogQ29tcGFyZSBmdW5jdGlvbiB0byBzb3J0IGFuIGFycmF5IG9mIGVsZW1lbnRzIHdoaWNoIGhhdmUgYSBkaXN0YW5jZSBwcm9wZXJ0eSB3aGljaCBpcyB0aGUgeG9yIGRpc3RhbmNlIHRvIGEgZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydHMueG9yQ29tcGFyZSA9IChhLCBiKSA9PiB7XG4gIHJldHVybiBkaXN0YW5jZS5jb21wYXJlKGEuZGlzdGFuY2UsIGIuZGlzdGFuY2UpXG59XG5cbi8qKlxuICogQ29tcHV0ZXMgaG93IG1hbnkgcmVzdWx0cyB0byBjb2xsZWN0IG9uIGVhY2ggZGlzam9pbnQgcGF0aCwgcm91bmRpbmcgdXAuXG4gKiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBsb29rIGZvciBhdCBsZWFzdCBvbmUgcmVzdWx0IHBlciBwYXRoLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSByZXN1bHRzV2FudGVkXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtUGF0aHMgLSB0b3RhbCBudW1iZXIgb2YgcGF0aHNcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydHMucGF0aFNpemUgPSAocmVzdWx0c1dhbnRlZCwgbnVtUGF0aHMpID0+IHtcbiAgcmV0dXJuIE1hdGguY2VpbChyZXN1bHRzV2FudGVkIC8gbnVtUGF0aHMpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHB1dCByZWNvcmQsIGVuY29kZXMgYW5kIHNpZ25zIGl0IGlmIGVuYWJsZWQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGtleVxuICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBCdWZmZXIpfSBjYWxsYmFja1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydHMuY3JlYXRlUHV0UmVjb3JkID0gKGtleSwgdmFsdWUsIGNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IHRpbWVSZWNlaXZlZCA9IG5ldyBEYXRlKClcbiAgY29uc3QgcmVjID0gbmV3IFJlY29yZChrZXksIHZhbHVlLCB0aW1lUmVjZWl2ZWQpXG5cbiAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICBjYWxsYmFjayhudWxsLCByZWMuc2VyaWFsaXplKCkpXG4gIH0pXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGxvZ2dlciBmb3IgdGhlIGdpdmVuIHN1YnN5c3RlbVxuICpcbiAqIEBwYXJhbSB7UGVlcklkfSBbaWRdXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N1YnN5c3RlbV1cbiAqIEByZXR1cm5zIHtkZWJ1Z31cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmxvZ2dlciA9IChpZCwgc3Vic3lzdGVtKSA9PiB7XG4gIGNvbnN0IG5hbWUgPSBbJ2xpYnAycCcsICdkaHQnXVxuICBpZiAoc3Vic3lzdGVtKSB7XG4gICAgbmFtZS5wdXNoKHN1YnN5c3RlbSlcbiAgfVxuICBpZiAoaWQpIHtcbiAgICBuYW1lLnB1c2goYCR7aWQudG9CNThTdHJpbmcoKS5zbGljZSgwLCA4KX1gKVxuICB9XG5cbiAgLy8gQWRkIGEgZm9ybWF0dGVyIGZvciBjb252ZXJ0aW5nIHRvIGEgYmFzZTU4IHN0cmluZ1xuICBkZWJ1Zy5mb3JtYXR0ZXJzLmIgPSAodikgPT4ge1xuICAgIHJldHVybiBtaC50b0I1OFN0cmluZyh2KVxuICB9XG5cbiAgY29uc3QgbG9nZ2VyID0gZGVidWcobmFtZS5qb2luKCc6JykpXG4gIGxvZ2dlci5lcnJvciA9IGRlYnVnKG5hbWUuY29uY2F0KFsnZXJyb3InXSkuam9pbignOicpKVxuXG4gIHJldHVybiBsb2dnZXJcbn1cblxuZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSBjbGFzcyBUaW1lb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGdldCBjb2RlICgpIHtcbiAgICByZXR1cm4gJ0VUSU1FRE9VVCdcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXN5bmMgZnVuY3Rpb24gdGhhdCBjYWxscyB0aGUgZ2l2ZW4gYGFzeW5jRm5gIGFuZCBFcnJvcnNcbiAqIGlmIGl0IGRvZXMgbm90IHJlc29sdmUgd2l0aGluIGB0aW1lYCBtc1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFthc3luY0ZuXVxuICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lXVxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMud2l0aFRpbWVvdXQgPSAoYXN5bmNGbiwgdGltZSkgPT4ge1xuICByZXR1cm4gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgIGFzeW5jRm4oLi4uYXJncyksXG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHJlamVjdChlcnJjb2RlKG5ldyBFcnJvcignQXN5bmMgZnVuY3Rpb24gZGlkIG5vdCBjb21wbGV0ZSBiZWZvcmUgdGltZW91dCcpLCAnRVRJTUVET1VUJykpXG4gICAgICAgIH0sIHRpbWUpXG4gICAgICB9KVxuICAgIF0pXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBtaCA9IHJlcXVpcmUoJ211bHRpaGFzaGVzJylcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpXG5jb25zdCBSdW4gPSByZXF1aXJlKCcuL3J1bicpXG5cbi8qKlxuICogRGl2aWRlIHBlZXJzIHVwIGludG8gZGlzam9pbnQgcGF0aHMgKHN1YnF1ZXJpZXMpLiBBbnkgcGVlciBjYW4gb25seSBiZSB1c2VkIG9uY2Ugb3ZlciBhbGwgcGF0aHMuXG4gKiBXaXRoaW4gZWFjaCBwYXRoLCBxdWVyeSBwZWVycyBmcm9tIGNsb3Nlc3QgdG8gZmFydGhlc3QgYXdheS5cbiAqL1xuY2xhc3MgUXVlcnkge1xuICAvKipcbiAgICogVXNlci1zdXBwbGllZCBmdW5jdGlvbiB0byBzZXQgdXAgYW4gaW5kaXZpZHVhbCBkaXNqb2ludCBwYXRoLiBQZXItcGF0aFxuICAgKiBxdWVyeSBzdGF0ZSBzaG91bGQgYmUgaGVsZCBpbiB0aGlzIGZ1bmN0aW9uJ3MgY2xvc3VyZS5cbiAgICogQHR5cGVkZWYge21ha2VQYXRofSBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gcGF0aE51bSAtIE51bWVyaWMgaW5kZXggZnJvbSB6ZXJvIHRvIG51bVBhdGhzIC0gMVxuICAgKiBAcmV0dXJucyB7cXVlcnlGdW5jfSAtIEZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBwZWVyIGluIHRoZSBxdWVyeVxuICAgKi9cblxuICAvKipcbiAgICogUXVlcnkgZnVuY3Rpb24uXG4gICAqIEB0eXBlZGVmIHtxdWVyeUZ1bmN9IGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7UGVlcklkfSBuZXh0IC0gUGVlciB0byBxdWVyeVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBPYmplY3QpfSBjYWxsYmFjayAtIFF1ZXJ5IHJlc3VsdCBjYWxsYmFja1xuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHF1ZXJ5LiBUaGUgbWFrZVBhdGggZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgcGVyIGRpc2pvaW50IHBhdGgsIHNvIHRoYXQgcGVyLXBhdGhcbiAgICogdmFyaWFibGVzIGNhbiBiZSBjcmVhdGVkIGluIHRoYXQgc2NvcGUuIG1ha2VQYXRoIHRoZW4gcmV0dXJucyB0aGUgYWN0dWFsIHF1ZXJ5IGZ1bmN0aW9uIChxdWVyeUZ1bmMpIHRvXG4gICAqIHVzZSB3aGVuIG9uIHRoYXQgcGF0aC5cbiAgICpcbiAgICogQHBhcmFtIHtESFR9IGRodCAtIERIVCBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0J1ZmZlcn0ga2V5XG4gICAqIEBwYXJhbSB7bWFrZVBhdGh9IG1ha2VQYXRoIC0gQ2FsbGVkIHRvIHNldCB1cCBlYWNoIGRpc2pvaW50IHBhdGguIE11c3QgcmV0dXJuIHRoZSBxdWVyeSBmdW5jdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChkaHQsIGtleSwgbWFrZVBhdGgpIHtcbiAgICB0aGlzLmRodCA9IGRodFxuICAgIHRoaXMua2V5ID0ga2V5XG4gICAgdGhpcy5tYWtlUGF0aCA9IG1ha2VQYXRoXG4gICAgdGhpcy5fbG9nID0gdXRpbHMubG9nZ2VyKHRoaXMuZGh0LnBlZXJJbmZvLmlkLCAncXVlcnk6JyArIG1oLnRvQjU4U3RyaW5nKGtleSkpXG5cbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZVxuXG4gICAgdGhpcy5fb25TdGFydCA9IHRoaXMuX29uU3RhcnQuYmluZCh0aGlzKVxuICAgIHRoaXMuX29uQ29tcGxldGUgPSB0aGlzLl9vbkNvbXBsZXRlLmJpbmQodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gdGhpcyBxdWVyeSwgc3RhcnQgd2l0aCB0aGUgZ2l2ZW4gbGlzdCBvZiBwZWVycyBmaXJzdC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxQZWVySWQ+fSBwZWVyc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHJ1biAocGVlcnMpIHtcbiAgICBpZiAoIXRoaXMuZGh0Ll9xdWVyeU1hbmFnZXIucnVubmluZykge1xuICAgICAgdGhpcy5fbG9nLmVycm9yKCdBdHRlbXB0IHRvIHJ1biBxdWVyeSBhZnRlciBzaHV0ZG93bicpXG4gICAgICByZXR1cm4geyBmaW5hbFNldDogbmV3IFNldCgpLCBwYXRoczogW10gfVxuICAgIH1cblxuICAgIGlmIChwZWVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX2xvZy5lcnJvcignUnVubmluZyBxdWVyeSB3aXRoIG5vIHBlZXJzJylcbiAgICAgIHJldHVybiB7IGZpbmFsU2V0OiBuZXcgU2V0KCksIHBhdGhzOiBbXSB9XG4gICAgfVxuXG4gICAgdGhpcy5fcnVuID0gbmV3IFJ1bih0aGlzKVxuXG4gICAgdGhpcy5fbG9nKGBxdWVyeSBydW5uaW5nIHdpdGggSz0ke3RoaXMuZGh0LmtCdWNrZXRTaXplfSwgQT0ke3RoaXMuZGh0LmNvbmN1cnJlbmN5fSwgRD0ke01hdGgubWluKHRoaXMuZGh0LmRpc2pvaW50UGF0aHMsIHBlZXJzLmxlbmd0aCl9YClcbiAgICB0aGlzLl9ydW4ub25jZSgnc3RhcnQnLCB0aGlzLl9vblN0YXJ0KVxuICAgIHRoaXMuX3J1bi5vbmNlKCdjb21wbGV0ZScsIHRoaXMuX29uQ29tcGxldGUpXG4gICAgcmV0dXJuIHRoaXMuX3J1bi5leGVjdXRlKHBlZXJzKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBydW4gc3RhcnRzLlxuICAgKi9cbiAgX29uU3RhcnQgKCkge1xuICAgIHRoaXMucnVubmluZyA9IHRydWVcbiAgICB0aGlzLl9zdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgdGhpcy5fbG9nKCdxdWVyeTpzdGFydCcpXG5cbiAgICAvLyBSZWdpc3RlciB0aGlzIHF1ZXJ5IHNvIHdlIGNhbiBzdG9wIGl0IGlmIHRoZSBESFQgc3RvcHNcbiAgICB0aGlzLmRodC5fcXVlcnlNYW5hZ2VyLnF1ZXJ5U3RhcnRlZCh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBydW4gY29tcGxldGVzIChldmVuIGlmIHRoZXJlJ3MgYW4gZXJyb3IpLlxuICAgKi9cbiAgX29uQ29tcGxldGUgKCkge1xuICAgIC8vIEVuc3VyZSB3b3JrZXIgcXVldWVzIGZvciBhbGwgcGF0aHMgYXJlIHN0b3BwZWQgYXQgdGhlIGVuZCBvZiB0aGUgcXVlcnlcbiAgICB0aGlzLnN0b3AoKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIHF1ZXJ5LlxuICAgKi9cbiAgc3RvcCAoKSB7XG4gICAgdGhpcy5fbG9nKGBxdWVyeTpkb25lIGluICR7RGF0ZS5ub3coKSAtIHRoaXMuX3N0YXJ0VGltZX1tc2ApXG5cbiAgICBpZiAodGhpcy5fcnVuKSB7XG4gICAgICB0aGlzLl9sb2coYCR7dGhpcy5fcnVuLmVycm9ycy5sZW5ndGh9IG9mICR7dGhpcy5fcnVuLnBlZXJzU2Vlbi5zaXplfSBwZWVycyBlcnJvcmVkICgke3RoaXMuX3J1bi5lcnJvcnMubGVuZ3RoIC8gdGhpcy5fcnVuLnBlZXJzU2Vlbi5zaXplICogMTAwfSUgZmFpbCByYXRlKWApXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnJ1bm5pbmcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3J1bi5yZW1vdmVMaXN0ZW5lcignc3RhcnQnLCB0aGlzLl9vblN0YXJ0KVxuICAgIHRoaXMuX3J1bi5yZW1vdmVMaXN0ZW5lcignY29tcGxldGUnLCB0aGlzLl9vbkNvbXBsZXRlKVxuXG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2VcbiAgICB0aGlzLl9ydW4gJiYgdGhpcy5fcnVuLnN0b3AoKVxuICAgIHRoaXMuZGh0Ll9xdWVyeU1hbmFnZXIucXVlcnlDb21wbGV0ZWQodGhpcylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtJylcbmNvbnN0IHRpbWVvdXQgPSByZXF1aXJlKCdhc3luYy90aW1lb3V0JylcbmNvbnN0IGxwID0gcmVxdWlyZSgncHVsbC1sZW5ndGgtcHJlZml4ZWQnKVxuY29uc3Qgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgnYXN5bmMvc2V0SW1tZWRpYXRlJylcblxuY29uc3QgZXJyY29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxuY29uc3QgcnBjID0gcmVxdWlyZSgnLi9ycGMnKVxuY29uc3QgYyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IE1lc3NhZ2UgPSByZXF1aXJlKCcuL21lc3NhZ2UnKVxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcblxuLyoqXG4gKiBIYW5kbGUgbmV0d29yayBvcGVyYXRpb25zIGZvciB0aGUgZGh0XG4gKi9cbmNsYXNzIE5ldHdvcmsge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IG5ldHdvcmsuXG4gICAqXG4gICAqIEBwYXJhbSB7S2FkREhUfSBzZWxmXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoc2VsZikge1xuICAgIHRoaXMuZGh0ID0gc2VsZlxuICAgIHRoaXMucmVhZE1lc3NhZ2VUaW1lb3V0ID0gYy5SRUFEX01FU1NBR0VfVElNRU9VVFxuICAgIHRoaXMuX2xvZyA9IHV0aWxzLmxvZ2dlcih0aGlzLmRodC5wZWVySW5mby5pZCwgJ25ldCcpXG4gICAgdGhpcy5fcnBjID0gcnBjKHRoaXMuZGh0KVxuICAgIHRoaXMuX29uUGVlckNvbm5lY3RlZCA9IHRoaXMuX29uUGVlckNvbm5lY3RlZC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdGhlIG5ldHdvcmsuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHN0YXJ0IChjYWxsYmFjaykge1xuICAgIGNvbnN0IGNiID0gKGVycikgPT4gc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKGVycikpXG5cbiAgICBpZiAodGhpcy5fcnVubmluZykge1xuICAgICAgcmV0dXJuIGNiKGVycmNvZGUobmV3IEVycm9yKCdOZXR3b3JrIGlzIGFscmVhZHkgcnVubmluZycpLCAnRVJSX05FVFdPUktfQUxSRUFEWV9SVU5OSU5HJykpXG4gICAgfVxuXG4gICAgLy8gVE9ETyBhZGQgYSB3YXkgdG8gY2hlY2sgaWYgc3dpdGNoIGhhcyBzdGFydGVkIG9yIG5vdFxuICAgIGlmICghdGhpcy5kaHQuaXNTdGFydGVkKSB7XG4gICAgICByZXR1cm4gY2IoZXJyY29kZShuZXcgRXJyb3IoJ0NhbiBub3Qgc3RhcnQgbmV0d29yaycpLCAnRVJSX0NBTk5PVF9TVEFSVF9ORVRXT1JLJykpXG4gICAgfVxuXG4gICAgdGhpcy5fcnVubmluZyA9IHRydWVcblxuICAgIC8vIGhhbmRsZSBpbmNvbWluZyBjb25uZWN0aW9uc1xuICAgIHRoaXMuZGh0LnN3aXRjaC5oYW5kbGUoYy5QUk9UT0NPTF9ESFQsIHRoaXMuX3JwYylcblxuICAgIC8vIGhhbmRsZSBuZXcgY29ubmVjdGlvbnNcbiAgICB0aGlzLmRodC5zd2l0Y2gub24oJ3BlZXItbXV4LWVzdGFibGlzaGVkJywgdGhpcy5fb25QZWVyQ29ubmVjdGVkKVxuXG4gICAgY2IoKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgYWxsIG5ldHdvcmsgYWN0aXZpdHkuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHN0b3AgKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY2IgPSAoZXJyKSA9PiBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2soZXJyKSlcblxuICAgIGlmICghdGhpcy5kaHQuaXNTdGFydGVkICYmICF0aGlzLmlzU3RhcnRlZCkge1xuICAgICAgcmV0dXJuIGNiKGVycmNvZGUobmV3IEVycm9yKCdOZXR3b3JrIGlzIGFscmVhZHkgc3RvcHBlZCcpLCAnRVJSX05FVFdPUktfQUxSRUFEWV9TVE9QUEVEJykpXG4gICAgfVxuICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZVxuICAgIHRoaXMuZGh0LnN3aXRjaC5yZW1vdmVMaXN0ZW5lcigncGVlci1tdXgtZXN0YWJsaXNoZWQnLCB0aGlzLl9vblBlZXJDb25uZWN0ZWQpXG5cbiAgICB0aGlzLmRodC5zd2l0Y2gudW5oYW5kbGUoYy5QUk9UT0NPTF9ESFQpXG4gICAgY2IoKVxuICB9XG5cbiAgLyoqXG4gICAqIElzIHRoZSBuZXR3b3JrIG9ubGluZT9cbiAgICpcbiAgICogQHR5cGUge2Jvb2x9XG4gICAqL1xuICBnZXQgaXNTdGFydGVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcnVubmluZ1xuICB9XG5cbiAgLyoqXG4gICAqIEFyZSBhbGwgbmV0d29yayBjb21wb25lbnRzIHRoZXJlP1xuICAgKlxuICAgKiBAdHlwZSB7Ym9vbH1cbiAgICovXG4gIGdldCBpc0Nvbm5lY3RlZCAoKSB7XG4gICAgLy8gVE9ETyBhZGQgYSB3YXkgdG8gY2hlY2sgaWYgc3dpdGNoIGhhcyBzdGFydGVkIG9yIG5vdFxuICAgIHJldHVybiB0aGlzLmRodC5pc1N0YXJ0ZWQgJiYgdGhpcy5pc1N0YXJ0ZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgbmV3IGNvbm5lY3Rpb25zIGluIHRoZSBzd2l0Y2guXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlckluZm99IHBlZXJcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25QZWVyQ29ubmVjdGVkIChwZWVyKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9nLmVycm9yKCdOZXR3b3JrIGlzIG9mZmxpbmUnKVxuICAgIH1cblxuICAgIHRoaXMuZGh0LnN3aXRjaC5kaWFsKHBlZXIsIGMuUFJPVE9DT0xfREhULCAoZXJyLCBjb25uKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2coJyVzIGRvZXMgbm90IHN1cHBvcnQgcHJvdG9jb2w6ICVzJywgcGVlci5pZC50b0I1OFN0cmluZygpLCBjLlBST1RPQ09MX0RIVClcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogY29ubi5jbG9zZSgpXG4gICAgICBwdWxsKHB1bGwuZW1wdHkoKSwgY29ubilcblxuICAgICAgdGhpcy5kaHQuX2FkZChwZWVyLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nLmVycm9yKCdGYWlsZWQgdG8gYWRkIHRvIHRoZSByb3V0aW5nIHRhYmxlJywgZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9nKCdhZGRlZCB0byB0aGUgcm91dGluZyB0YWJsZTogJXMnLCBwZWVyLmlkLnRvQjU4U3RyaW5nKCkpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHJlcXVlc3QgYW5kIHJlY29yZCBSVFQgZm9yIGxhdGVuY3kgbWVhc3VyZW1lbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BlZXJJZH0gdG8gLSBUaGUgcGVlciB0aGF0IHNob3VsZCByZWNlaXZlIGEgbWVzc2FnZVxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1zZyAtIFRoZSBtZXNzYWdlIHRvIHNlbmQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIE1lc3NhZ2UpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHNlbmRSZXF1ZXN0ICh0bywgbXNnLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IHJlY29yZCBsYXRlbmN5XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoJ05ldHdvcmsgaXMgb2ZmbGluZScpLCAnRVJSX05FVFdPUktfT0ZGTElORScpKVxuICAgIH1cblxuICAgIHRoaXMuX2xvZygnc2VuZGluZyB0bzogJXMnLCB0by50b0I1OFN0cmluZygpKVxuICAgIHRoaXMuZGh0LnN3aXRjaC5kaWFsKHRvLCBjLlBST1RPQ09MX0RIVCwgKGVyciwgY29ubikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl93cml0ZVJlYWRNZXNzYWdlKGNvbm4sIG1zZy5zZXJpYWxpemUoKSwgY2FsbGJhY2spXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIG1lc3NhZ2Ugd2l0aG91dCBleHBlY3RpbmcgYW4gYW5zd2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge1BlZXJJZH0gdG9cbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtc2dcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgc2VuZE1lc3NhZ2UgKHRvLCBtc2csIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKCdOZXR3b3JrIGlzIG9mZmxpbmUnKSwgJ0VSUl9ORVRXT1JLX09GRkxJTkUnKSkpXG4gICAgfVxuXG4gICAgdGhpcy5fbG9nKCdzZW5kaW5nIHRvOiAlcycsIHRvLnRvQjU4U3RyaW5nKCkpXG5cbiAgICB0aGlzLmRodC5zd2l0Y2guZGlhbCh0bywgYy5QUk9UT0NPTF9ESFQsIChlcnIsIGNvbm4pID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgdGhpcy5fd3JpdGVNZXNzYWdlKGNvbm4sIG1zZy5zZXJpYWxpemUoKSwgY2FsbGJhY2spXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIG1lc3NhZ2UgYW5kIHJlYWQgaXRzIHJlc3BvbnNlLlxuICAgKiBJZiBubyByZXNwb25zZSBpcyByZWNlaXZlZCBhZnRlciB0aGUgc3BlY2lmaWVkIHRpbWVvdXRcbiAgICogdGhpcyB3aWxsIGVycm9yIG91dC5cbiAgICpcbiAgICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uIC0gdGhlIGNvbm5lY3Rpb24gdG8gdXNlXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBtc2cgLSB0aGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIE1lc3NhZ2UpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF93cml0ZVJlYWRNZXNzYWdlIChjb25uLCBtc2csIGNhbGxiYWNrKSB7XG4gICAgdGltZW91dChcbiAgICAgIHdyaXRlUmVhZE1lc3NhZ2UsXG4gICAgICB0aGlzLnJlYWRNZXNzYWdlVGltZW91dFxuICAgICkoY29ubiwgbXNnLCBjYWxsYmFjaylcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIG1lc3NhZ2UgdG8gdGhlIGdpdmVuIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubiAtIHRoZSBjb25uZWN0aW9uIHRvIHVzZVxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gbXNnIC0gdGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd3JpdGVNZXNzYWdlIChjb25uLCBtc2csIGNhbGxiYWNrKSB7XG4gICAgcHVsbChcbiAgICAgIHB1bGwudmFsdWVzKFttc2ddKSxcbiAgICAgIGxwLmVuY29kZSgpLFxuICAgICAgY29ubixcbiAgICAgIHB1bGwub25FbmQoY2FsbGJhY2spXG4gICAgKVxuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlUmVhZE1lc3NhZ2UgKGNvbm4sIG1zZywgY2FsbGJhY2spIHtcbiAgcHVsbChcbiAgICBwdWxsLnZhbHVlcyhbbXNnXSksXG4gICAgbHAuZW5jb2RlKCksXG4gICAgY29ubixcbiAgICBwdWxsLmZpbHRlcigobXNnKSA9PiBtc2cubGVuZ3RoIDwgYy5tYXhNZXNzYWdlU2l6ZSksXG4gICAgbHAuZGVjb2RlKCksXG4gICAgcHVsbC5jb2xsZWN0KChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuICAgICAgaWYgKHJlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKCdObyBtZXNzYWdlIHJlY2VpdmVkJyksICdFUlJfTk9fTUVTU0FHRV9SRUNFSVZFRCcpKVxuICAgICAgfVxuXG4gICAgICBsZXQgcmVzcG9uc2VcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3BvbnNlID0gTWVzc2FnZS5kZXNlcmlhbGl6ZShyZXNbMF0pXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUoZXJyLCAnRVJSX0ZBSUxFRF9ERVNFUklBTElaRV9SRVNQT05TRScpKVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCByZXNwb25zZSlcbiAgICB9KVxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTmV0d29ya1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGhhbmRzaGFrZSA9IHJlcXVpcmUoJ3B1bGwtaGFuZHNoYWtlJylcbmNvbnN0IGRlZmVycmVkID0gcmVxdWlyZSgncHVsbC1kZWZlcicpXG5cbmNsYXNzIFN0YXRlIHtcbiAgY29uc3RydWN0b3IgKGxvY2FsSWQsIHJlbW90ZUlkLCB0aW1lb3V0LCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgdGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSB0aW1lb3V0XG4gICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgdGhpcy5zZXR1cCgpXG5cbiAgICB0aGlzLmlkLmxvY2FsID0gbG9jYWxJZFxuICAgIC8vIFRPRE8gdXNlIHJlbW90ZUlkIHRvIHZlcmlmeSBQZWVyc0lkZW50aXR5XG4gICAgdGhpcy5pZC5yZW1vdGUgPSByZW1vdGVJZFxuICAgIHRoaXMua2V5LmxvY2FsID0gbG9jYWxJZC5wcml2S2V5XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dCB8fCA2MCAqIDEwMDBcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8ICgoKSA9PiB7fSlcblxuICAgIHRoaXMuc2VjdXJlID0gZGVmZXJyZWQuZHVwbGV4KClcbiAgICB0aGlzLnN0cmVhbSA9IGhhbmRzaGFrZSh7IHRpbWVvdXQ6IHRoaXMudGltZW91dCB9LCBjYWxsYmFjaylcbiAgICB0aGlzLnNoYWtlID0gdGhpcy5zdHJlYW0uaGFuZHNoYWtlXG4gICAgZGVsZXRlIHRoaXMuc3RyZWFtLmhhbmRzaGFrZVxuICB9XG5cbiAgc2V0dXAgKCkge1xuICAgIHRoaXMuaWQgPSB7IGxvY2FsOiBudWxsLCByZW1vdGU6IG51bGwgfVxuICAgIHRoaXMua2V5ID0geyBsb2NhbDogbnVsbCwgcmVtb3RlOiBudWxsIH1cbiAgICB0aGlzLnNoYWtlID0gbnVsbFxuICAgIHRoaXMuY2xlYW5TZWNyZXRzKClcbiAgfVxuXG4gIC8vIHJlbW92ZSBhbGwgZGF0YSBmcm9tIHRoZSBoYW5kc2hha2UgdGhhdCBpcyBub3QgbmVlZGVkIGFueW1vcmVcbiAgY2xlYW5TZWNyZXRzICgpIHtcbiAgICB0aGlzLnNoYXJlZCA9IHt9XG5cbiAgICB0aGlzLmVwaGVtZXJhbEtleSA9IHsgbG9jYWw6IG51bGwsIHJlbW90ZTogbnVsbCB9XG4gICAgdGhpcy5wcm9wb3NhbCA9IHsgaW46IG51bGwsIG91dDogbnVsbCB9XG4gICAgdGhpcy5wcm9wb3NhbEVuY29kZWQgPSB7IGluOiBudWxsLCBvdXQ6IG51bGwgfVxuICAgIHRoaXMucHJvdG9jb2xzID0geyBsb2NhbDogbnVsbCwgcmVtb3RlOiBudWxsIH1cbiAgICB0aGlzLmV4Y2hhbmdlID0geyBpbjogbnVsbCwgb3V0OiBudWxsIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3Qgc2VyaWVzID0gcmVxdWlyZSgnYXN5bmMvc2VyaWVzJylcblxuY29uc3QgcHJvcG9zZSA9IHJlcXVpcmUoJy4vcHJvcG9zZScpXG5jb25zdCBleGNoYW5nZSA9IHJlcXVpcmUoJy4vZXhjaGFuZ2UnKVxuY29uc3QgZmluaXNoID0gcmVxdWlyZSgnLi9maW5pc2gnKVxuXG4vLyBQZXJmb3JtcyBpbml0aWFsIGNvbW11bmljYXRpb24gb3ZlciBpbnNlY3VyZSBjaGFubmVsIHRvIHNoYXJlIGtleXMsIElEcyxcbi8vIGFuZCBpbml0aWF0ZSBjb21tdW5pY2F0aW9uLCBhc3NpZ25pbmcgYWxsIG5lY2Vzc2FyeSBwYXJhbXMuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhbmRzaGFrZSAoc3RhdGUsIGNhbGxiYWNrKSB7XG4gIHNlcmllcyhbXG4gICAgKGNiKSA9PiBwcm9wb3NlKHN0YXRlLCBjYiksXG4gICAgKGNiKSA9PiBleGNoYW5nZShzdGF0ZSwgY2IpLFxuICAgIChjYikgPT4gZmluaXNoKHN0YXRlLCBjYilcbiAgXSwgKGVycikgPT4ge1xuICAgIHN0YXRlLmNsZWFuU2VjcmV0cygpXG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBpZiAoZXJyID09PSB0cnVlKSB7XG4gICAgICAgIGVyciA9IG5ldyBFcnJvcignU3RyZWFtIGVuZGVkIHByZW1hdHVyZWx5JylcbiAgICAgIH1cbiAgICAgIHN0YXRlLnNoYWtlLmFib3J0KGVycilcbiAgICB9XG5cbiAgICAvLyBzaWduYWwgd2hlbiB0aGUgaGFuZHNoYWtlIGlzIGZpbmlzaGVkIHNvIHRoYXQgcGx1bWJpbmcgY2FuIGhhcHBlblxuICAgIGNhbGxiYWNrKGVycilcbiAgfSlcblxuICByZXR1cm4gc3RhdGUuc3RyZWFtXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpXG5jb25zdCBsb2cgPSBkZWJ1ZygnbGlicDJwOndlYnNvY2tldC1zdGFyJylcbmNvbnN0IG11bHRpYWRkciA9IHJlcXVpcmUoJ211bHRpYWRkcicpXG5jb25zdCBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuY29uc3QgUGVlcklkID0gcmVxdWlyZSgncGVlci1pZCcpXG5jb25zdCBQZWVySW5mbyA9IHJlcXVpcmUoJ3BlZXItaW5mbycpXG5jb25zdCBDb25uZWN0aW9uID0gcmVxdWlyZSgnaW50ZXJmYWNlLWNvbm5lY3Rpb24nKS5Db25uZWN0aW9uXG5jb25zdCBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdhc3luYy9zZXRJbW1lZGlhdGUnKVxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IExpc3RlbmVyID0gcmVxdWlyZSgnLi9saXN0ZW5lcicpXG5jb25zdCBjbGVhblVybFNJTyA9IHV0aWxzLmNsZWFuVXJsU0lPXG5jb25zdCBtYWZtdCA9IHJlcXVpcmUoJ21hZm10JylcbmNvbnN0IHdpdGhJcyA9IHJlcXVpcmUoJ2NsYXNzLWlzJylcblxuY2xhc3MgV2Vic29ja2V0U3RhciB7XG4gIC8qKlxuICAgICogV2Vic29ja2V0U3RhciBUcmFuc3BvcnRcbiAgICAqIEBjbGFzc1xuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgbGlzdGVuZXJcbiAgICAqIEBwYXJhbSB7UGVlcklkfSBvcHRpb25zLmlkIC0gSWQgZm9yIHRoZSBjcnlwdG8gY2hhbGxlbmdlXG4gICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgdGhpcy5pZCA9IG9wdGlvbnMuaWRcbiAgICB0aGlzLmZsYWcgPSBvcHRpb25zLmFsbG93Sm9pbldpdGhEaXNhYmxlZENoYWxsZW5nZSAvLyBsZXQncyBqdXN0IHJlZmVyIHRvIGl0IGFzIFwiZmxhZ1wiXG5cbiAgICB0aGlzLmRpc2NvdmVyeSA9IG5ldyBFRSgpXG4gICAgdGhpcy5kaXNjb3ZlcnkudGFnID0gJ3dlYnNvY2tldFN0YXInXG4gICAgdGhpcy5kaXNjb3Zlcnkuc3RhcnQgPSAoY2FsbGJhY2spID0+IHtcbiAgICAgIHNldEltbWVkaWF0ZShjYWxsYmFjaylcbiAgICB9XG4gICAgdGhpcy5kaXNjb3Zlcnkuc3RvcCA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKVxuICAgIH1cblxuICAgIHRoaXMubGlzdGVuZXJzX2xpc3QgPSB7fVxuICAgIHRoaXMuX3BlZXJEaXNjb3ZlcmVkID0gdGhpcy5fcGVlckRpc2NvdmVyZWQuYmluZCh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAgKiBTZXRzIHRoZSBpZCBhZnRlciB0cmFuc3BvcnQgY3JlYXRpb24gKGFrYSB0aGUgbGF6eSB3YXkpXG4gICAgKiBAcGFyYW0ge1BlZXJJZH0gaWRcbiAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgKi9cbiAgbGF6eVNldElkIChpZCkge1xuICAgIGlmICghaWQpIHJldHVyblxuICAgIHRoaXMuaWQgPSBpZFxuICAgIHRoaXMuY2FuQ3J5cHRvID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAgKiBEaWFscyBhIHBlZXJcbiAgICAqIEBwYXJhbSB7TXVsdGlhZGRyfSBtYSAtIE11bHRpYWRkciB0byBkaWFsIHRvXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAqIEByZXR1cm5zIHtDb25uZWN0aW9ufVxuICAgICovXG4gIGRpYWwgKG1hLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICBsZXQgdXJsXG4gICAgdHJ5IHtcbiAgICAgIHVybCA9IGNsZWFuVXJsU0lPKG1hKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycikgLy8gZWFybHlcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXIgPSB0aGlzLmxpc3RlbmVyc19saXN0W3VybF1cbiAgICBpZiAoIWxpc3RlbmVyKSB7XG4gICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ05vIGxpc3RlbmVyIGZvciB0aGlzIHNlcnZlcicpKVxuICAgICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uKClcbiAgICB9XG4gICAgcmV0dXJuIGxpc3RlbmVyLmRpYWwobWEsIG9wdGlvbnMsIGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAgKiBDcmVhdGVzIGEgbGlzdGVuZXJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgKiBAcmV0dXJucyB7TGlzdGVuZXJ9XG4gICAgKi9cbiAgY3JlYXRlTGlzdGVuZXIgKG9wdGlvbnMsIGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGhhbmRsZXIgPSBvcHRpb25zXG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICBjb25zdCBsaXN0ZW5lciA9IG5ldyBMaXN0ZW5lcih7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGhhbmRsZXIsXG4gICAgICBsaXN0ZW5lcnM6IHRoaXMubGlzdGVuZXJzX2xpc3QsXG4gICAgICBmbGFnOiB0aGlzLmZsYWdcbiAgICB9KVxuXG4gICAgbGlzdGVuZXIub24oJ3BlZXInLCB0aGlzLl9wZWVyRGlzY292ZXJlZClcblxuICAgIHJldHVybiBsaXN0ZW5lclxuICB9XG5cbiAgLyoqXG4gICAgKiBGaWx0ZXJzIG11bHRpYWRkcnNcbiAgICAqIEBwYXJhbSB7TXVsdGlhZGRyW119IG11bHRpYWRkcnNcbiAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICovXG4gIGZpbHRlciAobXVsdGlhZGRycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShtdWx0aWFkZHJzKSkge1xuICAgICAgbXVsdGlhZGRycyA9IFttdWx0aWFkZHJzXVxuICAgIH1cblxuICAgIHJldHVybiBtdWx0aWFkZHJzLmZpbHRlcigobWEpID0+IG1hZm10LldlYlNvY2tldFN0YXIubWF0Y2hlcyhtYSkpXG4gIH1cblxuICAvKipcbiAgICAqIFVzZWQgdG8gZmlyZSBwZWVyIGV2ZW50cyBvbiB0aGUgZGlzY292ZXJ5IHBhcnRcbiAgICAqIEBwYXJhbSB7TXVsdGlhZGRyfSBtYVN0clxuICAgICogQGZpcmVzIERpc2NvdmVyeSNwZWVyXG4gICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICBfcGVlckRpc2NvdmVyZWQgKG1hU3RyKSB7XG4gICAgbG9nKCdQZWVyIERpc2NvdmVyZWQ6JywgbWFTdHIpXG4gICAgY29uc3QgcGVlcklkU3RyID0gbWFTdHIuc3BsaXQoJy9pcGZzLycpLnBvcCgpXG4gICAgY29uc3QgcGVlcklkID0gUGVlcklkLmNyZWF0ZUZyb21CNThTdHJpbmcocGVlcklkU3RyKVxuICAgIGNvbnN0IHBlZXJJbmZvID0gbmV3IFBlZXJJbmZvKHBlZXJJZClcblxuICAgIHBlZXJJbmZvLm11bHRpYWRkcnMuYWRkKG11bHRpYWRkcihtYVN0cikpXG4gICAgdGhpcy5kaXNjb3ZlcnkuZW1pdCgncGVlcicsIHBlZXJJbmZvKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2l0aElzKFdlYnNvY2tldFN0YXIsIHsgY2xhc3NOYW1lOiAnV2Vic29ja2V0U3RhcicsIHN5bWJvbE5hbWU6ICdAbGlicDJwL2pzLWxpYnAycC13ZWJzb2NrZXQtc3Rhci93ZWJzb2NrZXRzdGFyJyB9KVxuIiwiLyogZ2xvYmFsIHNlbGYgKi9cblxuLy8gY3JlYXRlZCBieSBASGVucmlrSm9yZXRlZ1xudmFyIHByZWZpeFxudmFyIHZlcnNpb25cblxuaWYgKHNlbGYubW96UlRDUGVlckNvbm5lY3Rpb24gfHwgbmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSkge1xuICBwcmVmaXggPSAnbW96J1xuICB2ZXJzaW9uID0gcGFyc2VJbnQobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLyhbMC05XSspXFwuLylbMV0sIDEwKVxufSBlbHNlIGlmIChzZWxmLndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uIHx8IG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEpIHtcbiAgcHJlZml4ID0gJ3dlYmtpdCdcbiAgdmVyc2lvbiA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0Nocm9tKGV8aXVtKS8pICYmIHBhcnNlSW50KG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0Nocm9tKGV8aXVtKVxcLyhbMC05XSspXFwuLylbMl0sIDEwKVxufVxuXG52YXIgUEMgPSBzZWxmLlJUQ1BlZXJDb25uZWN0aW9uIHx8IHNlbGYubW96UlRDUGVlckNvbm5lY3Rpb24gfHwgc2VsZi53ZWJraXRSVENQZWVyQ29ubmVjdGlvblxudmFyIEljZUNhbmRpZGF0ZSA9IHNlbGYubW96UlRDSWNlQ2FuZGlkYXRlIHx8IHNlbGYuUlRDSWNlQ2FuZGlkYXRlXG52YXIgU2Vzc2lvbkRlc2NyaXB0aW9uID0gc2VsZi5tb3pSVENTZXNzaW9uRGVzY3JpcHRpb24gfHwgc2VsZi5SVENTZXNzaW9uRGVzY3JpcHRpb25cbnZhciBNZWRpYVN0cmVhbSA9IHNlbGYud2Via2l0TWVkaWFTdHJlYW0gfHwgc2VsZi5NZWRpYVN0cmVhbVxudmFyIHNjcmVlblNoYXJpbmcgPSBzZWxmLmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyAmJlxuICAgICgocHJlZml4ID09PSAnd2Via2l0JyAmJiB2ZXJzaW9uID49IDI2KSB8fFxuICAgICAocHJlZml4ID09PSAnbW96JyAmJiB2ZXJzaW9uID49IDMzKSlcbnZhciBBdWRpb0NvbnRleHQgPSBzZWxmLkF1ZGlvQ29udGV4dCB8fCBzZWxmLndlYmtpdEF1ZGlvQ29udGV4dFxudmFyIHZpZGVvRWwgPSBzZWxmLmRvY3VtZW50ICYmIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJylcbnZhciBzdXBwb3J0VnA4ID0gdmlkZW9FbCAmJiB2aWRlb0VsLmNhblBsYXlUeXBlICYmIHZpZGVvRWwuY2FuUGxheVR5cGUoJ3ZpZGVvL3dlYm07IGNvZGVjcz1cInZwOFwiLCB2b3JiaXMnKSA9PT0gJ3Byb2JhYmx5J1xudmFyIGdldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3IubXNHZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYVxuXG4vLyBleHBvcnQgc3VwcG9ydCBmbGFncyBhbmQgY29uc3RydWN0b3JzLnByb3RvdHlwZSAmJiBQQ1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHByZWZpeDogcHJlZml4LFxuICBicm93c2VyVmVyc2lvbjogdmVyc2lvbixcbiAgc3VwcG9ydDogISFQQyAmJiAhIWdldFVzZXJNZWRpYSxcbiAgICAvLyBuZXcgc3VwcG9ydCBzdHlsZVxuICBzdXBwb3J0UlRDUGVlckNvbm5lY3Rpb246ICEhUEMsXG4gIHN1cHBvcnRWcDg6IHN1cHBvcnRWcDgsXG4gIHN1cHBvcnRHZXRVc2VyTWVkaWE6ICEhZ2V0VXNlck1lZGlhLFxuICBzdXBwb3J0RGF0YUNoYW5uZWw6ICEhKFBDICYmIFBDLnByb3RvdHlwZSAmJiBQQy5wcm90b3R5cGUuY3JlYXRlRGF0YUNoYW5uZWwpLFxuICBzdXBwb3J0V2ViQXVkaW86ICEhKEF1ZGlvQ29udGV4dCAmJiBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKSxcbiAgc3VwcG9ydE1lZGlhU3RyZWFtOiAhIShNZWRpYVN0cmVhbSAmJiBNZWRpYVN0cmVhbS5wcm90b3R5cGUucmVtb3ZlVHJhY2spLFxuICBzdXBwb3J0U2NyZWVuU2hhcmluZzogISFzY3JlZW5TaGFyaW5nLFxuICAgIC8vIGNvbnN0cnVjdG9yc1xuICBBdWRpb0NvbnRleHQ6IEF1ZGlvQ29udGV4dCxcbiAgUGVlckNvbm5lY3Rpb246IFBDLFxuICBTZXNzaW9uRGVzY3JpcHRpb246IFNlc3Npb25EZXNjcmlwdGlvbixcbiAgSWNlQ2FuZGlkYXRlOiBJY2VDYW5kaWRhdGUsXG4gIE1lZGlhU3RyZWFtOiBNZWRpYVN0cmVhbSxcbiAgZ2V0VXNlck1lZGlhOiBnZXRVc2VyTWVkaWFcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBtdWx0aWFkZHIgPSByZXF1aXJlKCdtdWx0aWFkZHInKVxuXG5mdW5jdGlvbiBjbGVhblVybFNJTyAobWEpIHtcbiAgY29uc3QgbWFTdHJTcGxpdCA9IG1hLnRvU3RyaW5nKCkuc3BsaXQoJy8nKVxuICBjb25zdCB0Y3BQcm90byA9IG1hLnByb3RvcygpWzFdLm5hbWVcbiAgY29uc3Qgd3NQcm90byA9IG1hLnByb3RvcygpWzJdLm5hbWVcbiAgY29uc3QgdGNwUG9ydCA9IG1hLnN0cmluZ1R1cGxlcygpWzFdWzFdXG5cbiAgaWYgKHRjcFByb3RvICE9PSAndGNwJyB8fCAod3NQcm90byAhPT0gJ3dzJyAmJiB3c1Byb3RvICE9PSAnd3NzJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbXVsdGlhZGRyOiAnICsgbWEudG9TdHJpbmcoKSlcbiAgfVxuXG4gIGlmICghbXVsdGlhZGRyLmlzTmFtZShtYSkpIHtcbiAgICByZXR1cm4gJ2h0dHA6Ly8nICsgbWFTdHJTcGxpdFsyXSArICc6JyArIG1hU3RyU3BsaXRbNF1cbiAgfVxuXG4gIGlmICh3c1Byb3RvID09PSAnd3MnKSB7XG4gICAgcmV0dXJuICdodHRwOi8vJyArIG1hU3RyU3BsaXRbMl0gKyAodGNwUG9ydCA9PT0gODAgPyAnJyA6ICc6JyArIHRjcFBvcnQpXG4gIH1cblxuICBpZiAod3NQcm90byA9PT0gJ3dzcycpIHtcbiAgICByZXR1cm4gJ2h0dHBzOi8vJyArIG1hU3RyU3BsaXRbMl0gKyAodGNwUG9ydCA9PT0gNDQzID8gJycgOiAnOicgKyB0Y3BQb3J0KVxuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuTXVsdGlhZGRyIChtYVN0cikge1xuICBjb25zdCBsZWdhY3kgPSAnL2xpYnAycC13ZWJydGMtc3RhcidcblxuICBpZiAobWFTdHIuaW5kZXhPZihsZWdhY3kpICE9PSAtMSkge1xuICAgIG1hU3RyID0gbWFTdHIuc3Vic3RyaW5nKGxlZ2FjeS5sZW5ndGgsIG1hU3RyLmxlbmd0aClcbiAgICBsZXQgbWEgPSBtdWx0aWFkZHIobWFTdHIpXG4gICAgY29uc3QgdHVwcGxlSVBGUyA9IG1hLnN0cmluZ1R1cGxlcygpLmZpbHRlcigodHVwcGxlKSA9PiB7XG4gICAgICByZXR1cm4gdHVwcGxlWzBdID09PSA0MjEgLy8gaXBmcyBjb2RlXG4gICAgfSlbMF1cblxuICAgIG1hID0gbWEuZGVjYXBzdWxhdGUoJ2lwZnMnKVxuICAgIG1hID0gbWEuZW5jYXBzdWxhdGUoJy9wMnAtd2VicnRjLXN0YXInKVxuICAgIG1hID0gbWEuZW5jYXBzdWxhdGUoYC9pcGZzLyR7dHVwcGxlSVBGU1sxXX1gKVxuICAgIG1hU3RyID0gbWEudG9TdHJpbmcoKVxuICB9XG5cbiAgcmV0dXJuIG1hU3RyXG59XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0c1xuZXhwb3J0cy5jbGVhblVybFNJTyA9IGNsZWFuVXJsU0lPXG5leHBvcnRzLmNsZWFuTXVsdGlhZGRyID0gY2xlYW5NdWx0aWFkZHJcbiIsIm1vZHVsZS5leHBvcnRzID0gUGVlclxuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzaW1wbGUtcGVlcicpXG52YXIgZ2V0QnJvd3NlclJUQyA9IHJlcXVpcmUoJ2dldC1icm93c2VyLXJ0YycpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgcmFuZG9tYnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcblxudmFyIE1BWF9CVUZGRVJFRF9BTU9VTlQgPSA2NCAqIDEwMjRcbnZhciBJQ0VDT01QTEVURV9USU1FT1VUID0gNSAqIDEwMDBcbnZhciBDSEFOTkVMX0NMT1NJTkdfVElNRU9VVCA9IDUgKiAxMDAwXG5cbmluaGVyaXRzKFBlZXIsIHN0cmVhbS5EdXBsZXgpXG5cbi8qKlxuICogV2ViUlRDIHBlZXIgY29ubmVjdGlvbi4gU2FtZSBBUEkgYXMgbm9kZSBjb3JlIGBuZXQuU29ja2V0YCwgcGx1cyBhIGZldyBleHRyYSBtZXRob2RzLlxuICogRHVwbGV4IHN0cmVhbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbmZ1bmN0aW9uIFBlZXIgKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBQZWVyKSkgcmV0dXJuIG5ldyBQZWVyKG9wdHMpXG5cbiAgc2VsZi5faWQgPSByYW5kb21ieXRlcyg0KS50b1N0cmluZygnaGV4Jykuc2xpY2UoMCwgNylcbiAgc2VsZi5fZGVidWcoJ25ldyBwZWVyICVvJywgb3B0cylcblxuICBvcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgYWxsb3dIYWxmT3BlbjogZmFsc2VcbiAgfSwgb3B0cylcblxuICBzdHJlYW0uRHVwbGV4LmNhbGwoc2VsZiwgb3B0cylcblxuICBzZWxmLmNoYW5uZWxOYW1lID0gb3B0cy5pbml0aWF0b3JcbiAgICA/IG9wdHMuY2hhbm5lbE5hbWUgfHwgcmFuZG9tYnl0ZXMoMjApLnRvU3RyaW5nKCdoZXgnKVxuICAgIDogbnVsbFxuXG4gIHNlbGYuaW5pdGlhdG9yID0gb3B0cy5pbml0aWF0b3IgfHwgZmFsc2VcbiAgc2VsZi5jaGFubmVsQ29uZmlnID0gb3B0cy5jaGFubmVsQ29uZmlnIHx8IFBlZXIuY2hhbm5lbENvbmZpZ1xuICBzZWxmLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIFBlZXIuY29uZmlnLCBvcHRzLmNvbmZpZylcbiAgc2VsZi5vZmZlck9wdGlvbnMgPSBvcHRzLm9mZmVyT3B0aW9ucyB8fCB7fVxuICBzZWxmLmFuc3dlck9wdGlvbnMgPSBvcHRzLmFuc3dlck9wdGlvbnMgfHwge31cbiAgc2VsZi5zZHBUcmFuc2Zvcm0gPSBvcHRzLnNkcFRyYW5zZm9ybSB8fCBmdW5jdGlvbiAoc2RwKSB7IHJldHVybiBzZHAgfVxuICBzZWxmLnN0cmVhbXMgPSBvcHRzLnN0cmVhbXMgfHwgKG9wdHMuc3RyZWFtID8gW29wdHMuc3RyZWFtXSA6IFtdKSAvLyBzdXBwb3J0IG9sZCBcInN0cmVhbVwiIG9wdGlvblxuICBzZWxmLnRyaWNrbGUgPSBvcHRzLnRyaWNrbGUgIT09IHVuZGVmaW5lZCA/IG9wdHMudHJpY2tsZSA6IHRydWVcbiAgc2VsZi5hbGxvd0hhbGZUcmlja2xlID0gb3B0cy5hbGxvd0hhbGZUcmlja2xlICE9PSB1bmRlZmluZWQgPyBvcHRzLmFsbG93SGFsZlRyaWNrbGUgOiBmYWxzZVxuICBzZWxmLmljZUNvbXBsZXRlVGltZW91dCA9IG9wdHMuaWNlQ29tcGxldGVUaW1lb3V0IHx8IElDRUNPTVBMRVRFX1RJTUVPVVRcblxuICBzZWxmLmRlc3Ryb3llZCA9IGZhbHNlXG4gIHNlbGYuX2Nvbm5lY3RlZCA9IGZhbHNlXG5cbiAgc2VsZi5yZW1vdGVBZGRyZXNzID0gdW5kZWZpbmVkXG4gIHNlbGYucmVtb3RlRmFtaWx5ID0gdW5kZWZpbmVkXG4gIHNlbGYucmVtb3RlUG9ydCA9IHVuZGVmaW5lZFxuICBzZWxmLmxvY2FsQWRkcmVzcyA9IHVuZGVmaW5lZFxuICBzZWxmLmxvY2FsRmFtaWx5ID0gdW5kZWZpbmVkXG4gIHNlbGYubG9jYWxQb3J0ID0gdW5kZWZpbmVkXG5cbiAgc2VsZi5fd3J0YyA9IChvcHRzLndydGMgJiYgdHlwZW9mIG9wdHMud3J0YyA9PT0gJ29iamVjdCcpXG4gICAgPyBvcHRzLndydGNcbiAgICA6IGdldEJyb3dzZXJSVEMoKVxuXG4gIGlmICghc2VsZi5fd3J0Yykge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbWFrZUVycm9yKCdObyBXZWJSVEMgc3VwcG9ydDogU3BlY2lmeSBgb3B0cy53cnRjYCBvcHRpb24gaW4gdGhpcyBlbnZpcm9ubWVudCcsICdFUlJfV0VCUlRDX1NVUFBPUlQnKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBtYWtlRXJyb3IoJ05vIFdlYlJUQyBzdXBwb3J0OiBOb3QgYSBzdXBwb3J0ZWQgYnJvd3NlcicsICdFUlJfV0VCUlRDX1NVUFBPUlQnKVxuICAgIH1cbiAgfVxuXG4gIHNlbGYuX3BjUmVhZHkgPSBmYWxzZVxuICBzZWxmLl9jaGFubmVsUmVhZHkgPSBmYWxzZVxuICBzZWxmLl9pY2VDb21wbGV0ZSA9IGZhbHNlIC8vIGljZSBjYW5kaWRhdGUgdHJpY2tsZSBkb25lIChnb3QgbnVsbCBjYW5kaWRhdGUpXG4gIHNlbGYuX2ljZUNvbXBsZXRlVGltZXIgPSBudWxsIC8vIHNlbmQgYW4gb2ZmZXIvYW5zd2VyIGFueXdheSBhZnRlciBzb21lIHRpbWVvdXRcbiAgc2VsZi5fY2hhbm5lbCA9IG51bGxcbiAgc2VsZi5fcGVuZGluZ0NhbmRpZGF0ZXMgPSBbXVxuXG4gIHNlbGYuX2lzTmVnb3RpYXRpbmcgPSAhc2VsZi5pbml0aWF0b3IgLy8gaXMgdGhpcyBwZWVyIHdhaXRpbmcgZm9yIG5lZ290aWF0aW9uIHRvIGNvbXBsZXRlP1xuICBzZWxmLl9iYXRjaGVkTmVnb3RpYXRpb24gPSBmYWxzZSAvLyBiYXRjaCBzeW5jaHJvbm91cyBuZWdvdGlhdGlvbnNcbiAgc2VsZi5fcXVldWVkTmVnb3RpYXRpb24gPSBmYWxzZSAvLyBpcyB0aGVyZSBhIHF1ZXVlZCBuZWdvdGlhdGlvbiByZXF1ZXN0P1xuICBzZWxmLl9zZW5kZXJzQXdhaXRpbmdTdGFibGUgPSBbXVxuICBzZWxmLl9zZW5kZXJNYXAgPSBuZXcgTWFwKClcbiAgc2VsZi5fZmlyc3RTdGFibGUgPSB0cnVlXG4gIHNlbGYuX2Nsb3NpbmdJbnRlcnZhbCA9IG51bGxcblxuICBzZWxmLl9yZW1vdGVUcmFja3MgPSBbXVxuICBzZWxmLl9yZW1vdGVTdHJlYW1zID0gW11cblxuICBzZWxmLl9jaHVuayA9IG51bGxcbiAgc2VsZi5fY2IgPSBudWxsXG4gIHNlbGYuX2ludGVydmFsID0gbnVsbFxuXG4gIHRyeSB7XG4gICAgc2VsZi5fcGMgPSBuZXcgKHNlbGYuX3dydGMuUlRDUGVlckNvbm5lY3Rpb24pKHNlbGYuY29uZmlnKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHNlbGYuZGVzdHJveShlcnIpLCAwKVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gV2UgcHJlZmVyIGZlYXR1cmUgZGV0ZWN0aW9uIHdoZW5ldmVyIHBvc3NpYmxlLCBidXQgc29tZXRpbWVzIHRoYXQncyBub3RcbiAgLy8gcG9zc2libGUgZm9yIGNlcnRhaW4gaW1wbGVtZW50YXRpb25zLlxuICBzZWxmLl9pc1JlYWN0TmF0aXZlV2VicnRjID0gdHlwZW9mIHNlbGYuX3BjLl9wZWVyQ29ubmVjdGlvbklkID09PSAnbnVtYmVyJ1xuXG4gIHNlbGYuX3BjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX29uSWNlU3RhdGVDaGFuZ2UoKVxuICB9XG4gIHNlbGYuX3BjLm9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fb25JY2VTdGF0ZUNoYW5nZSgpXG4gIH1cbiAgc2VsZi5fcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9vblNpZ25hbGluZ1N0YXRlQ2hhbmdlKClcbiAgfVxuICBzZWxmLl9wYy5vbmljZWNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHNlbGYuX29uSWNlQ2FuZGlkYXRlKGV2ZW50KVxuICB9XG5cbiAgLy8gT3RoZXIgc3BlYyBldmVudHMsIHVudXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uOlxuICAvLyAtIG9uY29ubmVjdGlvbnN0YXRlY2hhbmdlXG4gIC8vIC0gb25pY2VjYW5kaWRhdGVlcnJvclxuICAvLyAtIG9uZmluZ2VycHJpbnRmYWlsdXJlXG4gIC8vIC0gb25uZWdvdGlhdGlvbm5lZWRlZFxuXG4gIGlmIChzZWxmLmluaXRpYXRvcikge1xuICAgIHNlbGYuX3NldHVwRGF0YSh7XG4gICAgICBjaGFubmVsOiBzZWxmLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChzZWxmLmNoYW5uZWxOYW1lLCBzZWxmLmNoYW5uZWxDb25maWcpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBzZWxmLl9wYy5vbmRhdGFjaGFubmVsID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBzZWxmLl9zZXR1cERhdGEoZXZlbnQpXG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbGYuc3RyZWFtcykge1xuICAgIHNlbGYuc3RyZWFtcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgIHNlbGYuYWRkU3RyZWFtKHN0cmVhbSlcbiAgICB9KVxuICB9XG4gIHNlbGYuX3BjLm9udHJhY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBzZWxmLl9vblRyYWNrKGV2ZW50KVxuICB9XG5cbiAgaWYgKHNlbGYuaW5pdGlhdG9yKSB7XG4gICAgc2VsZi5fbmVlZHNOZWdvdGlhdGlvbigpXG4gIH1cblxuICBzZWxmLl9vbkZpbmlzaEJvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX29uRmluaXNoKClcbiAgfVxuICBzZWxmLm9uY2UoJ2ZpbmlzaCcsIHNlbGYuX29uRmluaXNoQm91bmQpXG59XG5cblBlZXIuV0VCUlRDX1NVUFBPUlQgPSAhIWdldEJyb3dzZXJSVEMoKVxuXG4vKipcbiAqIEV4cG9zZSBwZWVyIGFuZCBkYXRhIGNoYW5uZWwgY29uZmlnIGZvciBvdmVycmlkaW5nIGFsbCBQZWVyXG4gKiBpbnN0YW5jZXMuIE90aGVyd2lzZSwganVzdCBzZXQgb3B0cy5jb25maWcgb3Igb3B0cy5jaGFubmVsQ29uZmlnXG4gKiB3aGVuIGNvbnN0cnVjdGluZyBhIFBlZXIuXG4gKi9cblBlZXIuY29uZmlnID0ge1xuICBpY2VTZXJ2ZXJzOiBbXG4gICAge1xuICAgICAgdXJsczogJ3N0dW46c3R1bi5sLmdvb2dsZS5jb206MTkzMDInXG4gICAgfSxcbiAgICB7XG4gICAgICB1cmxzOiAnc3R1bjpnbG9iYWwuc3R1bi50d2lsaW8uY29tOjM0Nzg/dHJhbnNwb3J0PXVkcCdcbiAgICB9XG4gIF0sXG4gIHNkcFNlbWFudGljczogJ3VuaWZpZWQtcGxhbidcbn1cblBlZXIuY2hhbm5lbENvbmZpZyA9IHt9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQZWVyLnByb3RvdHlwZSwgJ2J1ZmZlclNpemUnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHJldHVybiAoc2VsZi5fY2hhbm5lbCAmJiBzZWxmLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50KSB8fCAwXG4gIH1cbn0pXG5cbi8vIEhBQ0s6IGl0J3MgcG9zc2libGUgY2hhbm5lbC5yZWFkeVN0YXRlIGlzIFwiY2xvc2luZ1wiIGJlZm9yZSBwZWVyLmRlc3Ryb3koKSBmaXJlc1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODgyNzQzXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGVlci5wcm90b3R5cGUsICdjb25uZWN0ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHJldHVybiAoc2VsZi5fY29ubmVjdGVkICYmIHNlbGYuX2NoYW5uZWwucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKVxuICB9XG59KVxuXG5QZWVyLnByb3RvdHlwZS5hZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIHsgcG9ydDogc2VsZi5sb2NhbFBvcnQsIGZhbWlseTogc2VsZi5sb2NhbEZhbWlseSwgYWRkcmVzczogc2VsZi5sb2NhbEFkZHJlc3MgfVxufVxuXG5QZWVyLnByb3RvdHlwZS5zaWduYWwgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSB0aHJvdyBtYWtlRXJyb3IoJ2Nhbm5vdCBzaWduYWwgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnLCAnRVJSX1NJR05BTElORycpXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGRhdGEgPSB7fVxuICAgIH1cbiAgfVxuICBzZWxmLl9kZWJ1Zygnc2lnbmFsKCknKVxuXG4gIGlmIChkYXRhLnJlbmVnb3RpYXRlICYmIHNlbGYuaW5pdGlhdG9yKSB7XG4gICAgc2VsZi5fZGVidWcoJ2dvdCByZXF1ZXN0IHRvIHJlbmVnb3RpYXRlJylcbiAgICBzZWxmLl9uZWVkc05lZ290aWF0aW9uKClcbiAgfVxuICBpZiAoZGF0YS50cmFuc2NlaXZlclJlcXVlc3QgJiYgc2VsZi5pbml0aWF0b3IpIHtcbiAgICBzZWxmLl9kZWJ1ZygnZ290IHJlcXVlc3QgZm9yIHRyYW5zY2VpdmVyJylcbiAgICBzZWxmLmFkZFRyYW5zY2VpdmVyKGRhdGEudHJhbnNjZWl2ZXJSZXF1ZXN0LmtpbmQsIGRhdGEudHJhbnNjZWl2ZXJSZXF1ZXN0LmluaXQpXG4gIH1cbiAgaWYgKGRhdGEuY2FuZGlkYXRlKSB7XG4gICAgaWYgKHNlbGYuX3BjLmxvY2FsRGVzY3JpcHRpb24gJiYgc2VsZi5fcGMubG9jYWxEZXNjcmlwdGlvbi50eXBlICYmIHNlbGYuX3BjLnJlbW90ZURlc2NyaXB0aW9uICYmIHNlbGYuX3BjLnJlbW90ZURlc2NyaXB0aW9uLnR5cGUpIHtcbiAgICAgIHNlbGYuX2FkZEljZUNhbmRpZGF0ZShkYXRhLmNhbmRpZGF0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fcGVuZGluZ0NhbmRpZGF0ZXMucHVzaChkYXRhLmNhbmRpZGF0ZSlcbiAgICB9XG4gIH1cbiAgaWYgKGRhdGEuc2RwKSB7XG4gICAgc2VsZi5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24obmV3IChzZWxmLl93cnRjLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbikoZGF0YSkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblxuICAgICAgc2VsZi5fcGVuZGluZ0NhbmRpZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoY2FuZGlkYXRlKSB7XG4gICAgICAgIHNlbGYuX2FkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpXG4gICAgICB9KVxuICAgICAgc2VsZi5fcGVuZGluZ0NhbmRpZGF0ZXMgPSBbXVxuXG4gICAgICBpZiAoc2VsZi5fcGMucmVtb3RlRGVzY3JpcHRpb24udHlwZSA9PT0gJ29mZmVyJykgc2VsZi5fY3JlYXRlQW5zd2VyKClcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7IHNlbGYuZGVzdHJveShtYWtlRXJyb3IoZXJyLCAnRVJSX1NFVF9SRU1PVEVfREVTQ1JJUFRJT04nKSkgfSlcbiAgfVxuICBpZiAoIWRhdGEuc2RwICYmICFkYXRhLmNhbmRpZGF0ZSAmJiAhZGF0YS5yZW5lZ290aWF0ZSAmJiAhZGF0YS50cmFuc2NlaXZlclJlcXVlc3QpIHtcbiAgICBzZWxmLmRlc3Ryb3kobWFrZUVycm9yKCdzaWduYWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIHNpZ25hbCBkYXRhJywgJ0VSUl9TSUdOQUxJTkcnKSlcbiAgfVxufVxuXG5QZWVyLnByb3RvdHlwZS5fYWRkSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24gKGNhbmRpZGF0ZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGljZUNhbmRpZGF0ZU9iaiA9IG5ldyBzZWxmLl93cnRjLlJUQ0ljZUNhbmRpZGF0ZShjYW5kaWRhdGUpXG4gIHNlbGYuX3BjLmFkZEljZUNhbmRpZGF0ZShpY2VDYW5kaWRhdGVPYmopLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWljZUNhbmRpZGF0ZU9iai5hZGRyZXNzIHx8IGljZUNhbmRpZGF0ZU9iai5hZGRyZXNzLmVuZHNXaXRoKCcubG9jYWwnKSkge1xuICAgICAgd2FybignSWdub3JpbmcgdW5zdXBwb3J0ZWQgSUNFIGNhbmRpZGF0ZS4nKVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmRlc3Ryb3kobWFrZUVycm9yKGVyciwgJ0VSUl9BRERfSUNFX0NBTkRJREFURScpKVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBTZW5kIHRleHQvYmluYXJ5IGRhdGEgdG8gdGhlIHJlbW90ZSBwZWVyLlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd8QXJyYXlCdWZmZXJ8QnVmZmVyfHN0cmluZ3xCbG9ifSBjaHVua1xuICovXG5QZWVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9jaGFubmVsLnNlbmQoY2h1bmspXG59XG5cbi8qKlxuICogQWRkIGEgVHJhbnNjZWl2ZXIgdG8gdGhlIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30ga2luZFxuICogQHBhcmFtIHtPYmplY3R9IGluaXRcbiAqL1xuUGVlci5wcm90b3R5cGUuYWRkVHJhbnNjZWl2ZXIgPSBmdW5jdGlvbiAoa2luZCwgaW5pdCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBzZWxmLl9kZWJ1ZygnYWRkVHJhbnNjZWl2ZXIoKScpXG5cbiAgaWYgKHNlbGYuaW5pdGlhdG9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuX3BjLmFkZFRyYW5zY2VpdmVyKGtpbmQsIGluaXQpXG4gICAgICBzZWxmLl9uZWVkc05lZ290aWF0aW9uKClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNlbGYuZGVzdHJveShlcnIpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNlbGYuZW1pdCgnc2lnbmFsJywgeyAvLyByZXF1ZXN0IGluaXRpYXRvciB0byByZW5lZ290aWF0ZVxuICAgICAgdHJhbnNjZWl2ZXJSZXF1ZXN0OiB7IGtpbmQsIGluaXQgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgYSBNZWRpYVN0cmVhbSB0byB0aGUgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IHN0cmVhbVxuICovXG5QZWVyLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHNlbGYuX2RlYnVnKCdhZGRTdHJlYW0oKScpXG5cbiAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgc2VsZi5hZGRUcmFjayh0cmFjaywgc3RyZWFtKVxuICB9KVxufVxuXG4vKipcbiAqIEFkZCBhIE1lZGlhU3RyZWFtVHJhY2sgdG8gdGhlIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IHRyYWNrXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAqL1xuUGVlci5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiAodHJhY2ssIHN0cmVhbSkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBzZWxmLl9kZWJ1ZygnYWRkVHJhY2soKScpXG5cbiAgdmFyIHN1Ym1hcCA9IHNlbGYuX3NlbmRlck1hcC5nZXQodHJhY2spIHx8IG5ldyBNYXAoKSAvLyBuZXN0ZWQgTWFwcyBtYXAgW3RyYWNrLCBzdHJlYW1dIHRvIHNlbmRlclxuICB2YXIgc2VuZGVyID0gc3VibWFwLmdldChzdHJlYW0pXG4gIGlmICghc2VuZGVyKSB7XG4gICAgc2VuZGVyID0gc2VsZi5fcGMuYWRkVHJhY2sodHJhY2ssIHN0cmVhbSlcbiAgICBzdWJtYXAuc2V0KHN0cmVhbSwgc2VuZGVyKVxuICAgIHNlbGYuX3NlbmRlck1hcC5zZXQodHJhY2ssIHN1Ym1hcClcbiAgICBzZWxmLl9uZWVkc05lZ290aWF0aW9uKClcbiAgfSBlbHNlIGlmIChzZW5kZXIucmVtb3ZlZCkge1xuICAgIHNlbGYuZGVzdHJveShtYWtlRXJyb3IoJ1RyYWNrIGhhcyBiZWVuIHJlbW92ZWQuIFlvdSBzaG91bGQgZW5hYmxlL2Rpc2FibGUgdHJhY2tzIHRoYXQgeW91IHdhbnQgdG8gcmUtYWRkLicsICdFUlJfU0VOREVSX1JFTU9WRUQnKSlcbiAgfSBlbHNlIHtcbiAgICBzZWxmLmRlc3Ryb3kobWFrZUVycm9yKCdUcmFjayBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIHRoYXQgc3RyZWFtLicsICdFUlJfU0VOREVSX0FMUkVBRFlfQURERUQnKSlcbiAgfVxufVxuXG4vKipcbiAqIFJlcGxhY2UgYSBNZWRpYVN0cmVhbVRyYWNrIGJ5IGFub3RoZXIgaW4gdGhlIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IG9sZFRyYWNrXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IG5ld1RyYWNrXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAqL1xuUGVlci5wcm90b3R5cGUucmVwbGFjZVRyYWNrID0gZnVuY3Rpb24gKG9sZFRyYWNrLCBuZXdUcmFjaywgc3RyZWFtKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHNlbGYuX2RlYnVnKCdyZXBsYWNlVHJhY2soKScpXG5cbiAgdmFyIHN1Ym1hcCA9IHNlbGYuX3NlbmRlck1hcC5nZXQob2xkVHJhY2spXG4gIHZhciBzZW5kZXIgPSBzdWJtYXAgPyBzdWJtYXAuZ2V0KHN0cmVhbSkgOiBudWxsXG4gIGlmICghc2VuZGVyKSB7XG4gICAgc2VsZi5kZXN0cm95KG1ha2VFcnJvcignQ2Fubm90IHJlcGxhY2UgdHJhY2sgdGhhdCB3YXMgbmV2ZXIgYWRkZWQuJywgJ0VSUl9UUkFDS19OT1RfQURERUQnKSlcbiAgfVxuICBpZiAobmV3VHJhY2spIHNlbGYuX3NlbmRlck1hcC5zZXQobmV3VHJhY2ssIHN1Ym1hcClcblxuICBpZiAoc2VuZGVyLnJlcGxhY2VUcmFjayAhPSBudWxsKSB7XG4gICAgc2VuZGVyLnJlcGxhY2VUcmFjayhuZXdUcmFjaylcbiAgfSBlbHNlIHtcbiAgICBzZWxmLmRlc3Ryb3kobWFrZUVycm9yKCdyZXBsYWNlVHJhY2sgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInLCAnRVJSX1VOU1VQUE9SVEVEX1JFUExBQ0VUUkFDSycpKVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgTWVkaWFTdHJlYW1UcmFjayBmcm9tIHRoZSBjb25uZWN0aW9uLlxuICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfSB0cmFja1xuICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gc3RyZWFtXG4gKi9cblBlZXIucHJvdG90eXBlLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24gKHRyYWNrLCBzdHJlYW0pIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgc2VsZi5fZGVidWcoJ3JlbW92ZVNlbmRlcigpJylcblxuICB2YXIgc3VibWFwID0gc2VsZi5fc2VuZGVyTWFwLmdldCh0cmFjaylcbiAgdmFyIHNlbmRlciA9IHN1Ym1hcCA/IHN1Ym1hcC5nZXQoc3RyZWFtKSA6IG51bGxcbiAgaWYgKCFzZW5kZXIpIHtcbiAgICBzZWxmLmRlc3Ryb3kobWFrZUVycm9yKCdDYW5ub3QgcmVtb3ZlIHRyYWNrIHRoYXQgd2FzIG5ldmVyIGFkZGVkLicsICdFUlJfVFJBQ0tfTk9UX0FEREVEJykpXG4gIH1cbiAgdHJ5IHtcbiAgICBzZW5kZXIucmVtb3ZlZCA9IHRydWVcbiAgICBzZWxmLl9wYy5yZW1vdmVUcmFjayhzZW5kZXIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubmFtZSA9PT0gJ05TX0VSUk9SX1VORVhQRUNURUQnKSB7XG4gICAgICBzZWxmLl9zZW5kZXJzQXdhaXRpbmdTdGFibGUucHVzaChzZW5kZXIpIC8vIEhBQ0s6IEZpcmVmb3ggbXVzdCB3YWl0IHVudGlsIChzaWduYWxpbmdTdGF0ZSA9PT0gc3RhYmxlKSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTMzODc0XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuZGVzdHJveShlcnIpXG4gICAgfVxuICB9XG4gIHNlbGYuX25lZWRzTmVnb3RpYXRpb24oKVxufVxuXG4vKipcbiAqIFJlbW92ZSBhIE1lZGlhU3RyZWFtIGZyb20gdGhlIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAqL1xuUGVlci5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBzZWxmLl9kZWJ1ZygncmVtb3ZlU2VuZGVycygpJylcblxuICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICBzZWxmLnJlbW92ZVRyYWNrKHRyYWNrLCBzdHJlYW0pXG4gIH0pXG59XG5cblBlZXIucHJvdG90eXBlLl9uZWVkc05lZ290aWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBzZWxmLl9kZWJ1ZygnX25lZWRzTmVnb3RpYXRpb24nKVxuICBpZiAoc2VsZi5fYmF0Y2hlZE5lZ290aWF0aW9uKSByZXR1cm4gLy8gYmF0Y2ggc3luY2hyb25vdXMgcmVuZWdvdGlhdGlvbnNcbiAgc2VsZi5fYmF0Y2hlZE5lZ290aWF0aW9uID0gdHJ1ZVxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9iYXRjaGVkTmVnb3RpYXRpb24gPSBmYWxzZVxuICAgIHNlbGYuX2RlYnVnKCdzdGFydGluZyBiYXRjaGVkIG5lZ290aWF0aW9uJylcbiAgICBzZWxmLm5lZ290aWF0ZSgpXG4gIH0sIDApXG59XG5cblBlZXIucHJvdG90eXBlLm5lZ290aWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKHNlbGYuaW5pdGlhdG9yKSB7XG4gICAgaWYgKHNlbGYuX2lzTmVnb3RpYXRpbmcpIHtcbiAgICAgIHNlbGYuX3F1ZXVlZE5lZ290aWF0aW9uID0gdHJ1ZVxuICAgICAgc2VsZi5fZGVidWcoJ2FscmVhZHkgbmVnb3RpYXRpbmcsIHF1ZXVlaW5nJylcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fZGVidWcoJ3N0YXJ0IG5lZ290aWF0aW9uJylcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4geyAvLyBIQUNLOiBDaHJvbWUgY3Jhc2hlcyBpZiB3ZSBpbW1lZGlhdGVseSBjYWxsIGNyZWF0ZU9mZmVyXG4gICAgICAgIHNlbGYuX2NyZWF0ZU9mZmVyKClcbiAgICAgIH0sIDApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghc2VsZi5faXNOZWdvdGlhdGluZykge1xuICAgICAgc2VsZi5fZGVidWcoJ3JlcXVlc3RpbmcgbmVnb3RpYXRpb24gZnJvbSBpbml0aWF0b3InKVxuICAgICAgc2VsZi5lbWl0KCdzaWduYWwnLCB7IC8vIHJlcXVlc3QgaW5pdGlhdG9yIHRvIHJlbmVnb3RpYXRlXG4gICAgICAgIHJlbmVnb3RpYXRlOiB0cnVlXG4gICAgICB9KVxuICAgIH1cbiAgfVxuICBzZWxmLl9pc05lZ290aWF0aW5nID0gdHJ1ZVxufVxuXG4vLyBUT0RPOiBEZWxldGUgdGhpcyBtZXRob2Qgb25jZSByZWFkYWJsZS1zdHJlYW0gaXMgdXBkYXRlZCB0byBjb250YWluIGEgZGVmYXVsdFxuLy8gaW1wbGVtZW50YXRpb24gb2YgZGVzdHJveSgpIHRoYXQgYXV0b21hdGljYWxseSBjYWxscyBfZGVzdHJveSgpXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvcmVhZGFibGUtc3RyZWFtL2lzc3Vlcy8yODNcblBlZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9kZXN0cm95KGVyciwgZnVuY3Rpb24gKCkge30pXG59XG5cblBlZXIucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgc2VsZi5fZGVidWcoJ2Rlc3Ryb3kgKGVycm9yOiAlcyknLCBlcnIgJiYgKGVyci5tZXNzYWdlIHx8IGVycikpXG5cbiAgc2VsZi5yZWFkYWJsZSA9IHNlbGYud3JpdGFibGUgPSBmYWxzZVxuXG4gIGlmICghc2VsZi5fcmVhZGFibGVTdGF0ZS5lbmRlZCkgc2VsZi5wdXNoKG51bGwpXG4gIGlmICghc2VsZi5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkgc2VsZi5lbmQoKVxuXG4gIHNlbGYuZGVzdHJveWVkID0gdHJ1ZVxuICBzZWxmLl9jb25uZWN0ZWQgPSBmYWxzZVxuICBzZWxmLl9wY1JlYWR5ID0gZmFsc2VcbiAgc2VsZi5fY2hhbm5lbFJlYWR5ID0gZmFsc2VcbiAgc2VsZi5fcmVtb3RlVHJhY2tzID0gbnVsbFxuICBzZWxmLl9yZW1vdGVTdHJlYW1zID0gbnVsbFxuICBzZWxmLl9zZW5kZXJNYXAgPSBudWxsXG5cbiAgY2xlYXJJbnRlcnZhbChzZWxmLl9jbG9zaW5nSW50ZXJ2YWwpXG4gIHNlbGYuX2Nsb3NpbmdJbnRlcnZhbCA9IG51bGxcblxuICBjbGVhckludGVydmFsKHNlbGYuX2ludGVydmFsKVxuICBzZWxmLl9pbnRlcnZhbCA9IG51bGxcbiAgc2VsZi5fY2h1bmsgPSBudWxsXG4gIHNlbGYuX2NiID0gbnVsbFxuXG4gIGlmIChzZWxmLl9vbkZpbmlzaEJvdW5kKSBzZWxmLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBzZWxmLl9vbkZpbmlzaEJvdW5kKVxuICBzZWxmLl9vbkZpbmlzaEJvdW5kID0gbnVsbFxuXG4gIGlmIChzZWxmLl9jaGFubmVsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuX2NoYW5uZWwuY2xvc2UoKVxuICAgIH0gY2F0Y2ggKGVycikge31cblxuICAgIHNlbGYuX2NoYW5uZWwub25tZXNzYWdlID0gbnVsbFxuICAgIHNlbGYuX2NoYW5uZWwub25vcGVuID0gbnVsbFxuICAgIHNlbGYuX2NoYW5uZWwub25jbG9zZSA9IG51bGxcbiAgICBzZWxmLl9jaGFubmVsLm9uZXJyb3IgPSBudWxsXG4gIH1cbiAgaWYgKHNlbGYuX3BjKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuX3BjLmNsb3NlKClcbiAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICBzZWxmLl9wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGxcbiAgICBzZWxmLl9wYy5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlID0gbnVsbFxuICAgIHNlbGYuX3BjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgc2VsZi5fcGMub25pY2VjYW5kaWRhdGUgPSBudWxsXG4gICAgc2VsZi5fcGMub250cmFjayA9IG51bGxcbiAgICBzZWxmLl9wYy5vbmRhdGFjaGFubmVsID0gbnVsbFxuICB9XG4gIHNlbGYuX3BjID0gbnVsbFxuICBzZWxmLl9jaGFubmVsID0gbnVsbFxuXG4gIGlmIChlcnIpIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG4gIHNlbGYuZW1pdCgnY2xvc2UnKVxuICBjYigpXG59XG5cblBlZXIucHJvdG90eXBlLl9zZXR1cERhdGEgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghZXZlbnQuY2hhbm5lbCkge1xuICAgIC8vIEluIHNvbWUgc2l0dWF0aW9ucyBgcGMuY3JlYXRlRGF0YUNoYW5uZWwoKWAgcmV0dXJucyBgdW5kZWZpbmVkYCAoaW4gd3J0YyksXG4gICAgLy8gd2hpY2ggaXMgaW52YWxpZCBiZWhhdmlvci4gSGFuZGxlIGl0IGdyYWNlZnVsbHkuXG4gICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL3NpbXBsZS1wZWVyL2lzc3Vlcy8xNjNcbiAgICByZXR1cm4gc2VsZi5kZXN0cm95KG1ha2VFcnJvcignRGF0YSBjaGFubmVsIGV2ZW50IGlzIG1pc3NpbmcgYGNoYW5uZWxgIHByb3BlcnR5JywgJ0VSUl9EQVRBX0NIQU5ORUwnKSlcbiAgfVxuXG4gIHNlbGYuX2NoYW5uZWwgPSBldmVudC5jaGFubmVsXG4gIHNlbGYuX2NoYW5uZWwuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcidcblxuICBpZiAodHlwZW9mIHNlbGYuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQgPT09ICdudW1iZXInKSB7XG4gICAgc2VsZi5fY2hhbm5lbC5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCA9IE1BWF9CVUZGRVJFRF9BTU9VTlRcbiAgfVxuXG4gIHNlbGYuY2hhbm5lbE5hbWUgPSBzZWxmLl9jaGFubmVsLmxhYmVsXG5cbiAgc2VsZi5fY2hhbm5lbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBzZWxmLl9vbkNoYW5uZWxNZXNzYWdlKGV2ZW50KVxuICB9XG4gIHNlbGYuX2NoYW5uZWwub25idWZmZXJlZGFtb3VudGxvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9vbkNoYW5uZWxCdWZmZXJlZEFtb3VudExvdygpXG4gIH1cbiAgc2VsZi5fY2hhbm5lbC5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fb25DaGFubmVsT3BlbigpXG4gIH1cbiAgc2VsZi5fY2hhbm5lbC5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX29uQ2hhbm5lbENsb3NlKClcbiAgfVxuICBzZWxmLl9jaGFubmVsLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5kZXN0cm95KG1ha2VFcnJvcihlcnIsICdFUlJfREFUQV9DSEFOTkVMJykpXG4gIH1cblxuICAvLyBIQUNLOiBDaHJvbWUgd2lsbCBzb21ldGltZXMgZ2V0IHN0dWNrIGluIHJlYWR5U3RhdGUgXCJjbG9zaW5nXCIsIGxldCdzIGNoZWNrIGZvciB0aGlzIGNvbmRpdGlvblxuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04ODI3NDNcbiAgdmFyIGlzQ2xvc2luZyA9IGZhbHNlXG4gIHNlbGYuX2Nsb3NpbmdJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHsgLy8gTm8gXCJvbmNsb3NpbmdcIiBldmVudFxuICAgIGlmIChzZWxmLl9jaGFubmVsICYmIHNlbGYuX2NoYW5uZWwucmVhZHlTdGF0ZSA9PT0gJ2Nsb3NpbmcnKSB7XG4gICAgICBpZiAoaXNDbG9zaW5nKSBzZWxmLl9vbkNoYW5uZWxDbG9zZSgpIC8vIGNsb3NpbmcgdGltZWQgb3V0OiBlcXVpdmFsZW50IHRvIG9uY2xvc2UgZmlyaW5nXG4gICAgICBpc0Nsb3NpbmcgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGlzQ2xvc2luZyA9IGZhbHNlXG4gICAgfVxuICB9LCBDSEFOTkVMX0NMT1NJTkdfVElNRU9VVClcbn1cblxuUGVlci5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAoKSB7fVxuXG5QZWVyLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm4gY2IobWFrZUVycm9yKCdjYW5ub3Qgd3JpdGUgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnLCAnRVJSX0RBVEFfQ0hBTk5FTCcpKVxuXG4gIGlmIChzZWxmLl9jb25uZWN0ZWQpIHtcbiAgICB0cnkge1xuICAgICAgc2VsZi5zZW5kKGNodW5rKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHNlbGYuZGVzdHJveShtYWtlRXJyb3IoZXJyLCAnRVJSX0RBVEFfQ0hBTk5FTCcpKVxuICAgIH1cbiAgICBpZiAoc2VsZi5fY2hhbm5lbC5idWZmZXJlZEFtb3VudCA+IE1BWF9CVUZGRVJFRF9BTU9VTlQpIHtcbiAgICAgIHNlbGYuX2RlYnVnKCdzdGFydCBiYWNrcHJlc3N1cmU6IGJ1ZmZlcmVkQW1vdW50ICVkJywgc2VsZi5fY2hhbm5lbC5idWZmZXJlZEFtb3VudClcbiAgICAgIHNlbGYuX2NiID0gY2JcbiAgICB9IGVsc2Uge1xuICAgICAgY2IobnVsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5fZGVidWcoJ3dyaXRlIGJlZm9yZSBjb25uZWN0JylcbiAgICBzZWxmLl9jaHVuayA9IGNodW5rXG4gICAgc2VsZi5fY2IgPSBjYlxuICB9XG59XG5cbi8vIFdoZW4gc3RyZWFtIGZpbmlzaGVzIHdyaXRpbmcsIGNsb3NlIHNvY2tldC4gSGFsZiBvcGVuIGNvbm5lY3Rpb25zIGFyZSBub3Rcbi8vIHN1cHBvcnRlZC5cblBlZXIucHJvdG90eXBlLl9vbkZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgaWYgKHNlbGYuX2Nvbm5lY3RlZCkge1xuICAgIGRlc3Ryb3lTb29uKClcbiAgfSBlbHNlIHtcbiAgICBzZWxmLm9uY2UoJ2Nvbm5lY3QnLCBkZXN0cm95U29vbilcbiAgfVxuXG4gIC8vIFdhaXQgYSBiaXQgYmVmb3JlIGRlc3Ryb3lpbmcgc28gdGhlIHNvY2tldCBmbHVzaGVzLlxuICAvLyBUT0RPOiBpcyB0aGVyZSBhIG1vcmUgcmVsaWFibGUgd2F5IHRvIGFjY29tcGxpc2ggdGhpcz9cbiAgZnVuY3Rpb24gZGVzdHJveVNvb24gKCkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5kZXN0cm95KClcbiAgICB9LCAxMDAwKVxuICB9XG59XG5cblBlZXIucHJvdG90eXBlLl9zdGFydEljZUNvbXBsZXRlVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIGlmIChzZWxmLl9pY2VDb21wbGV0ZVRpbWVyKSByZXR1cm5cbiAgc2VsZi5fZGVidWcoJ3N0YXJ0ZWQgaWNlQ29tcGxldGUgdGltZW91dCcpXG4gIHNlbGYuX2ljZUNvbXBsZXRlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNlbGYuX2ljZUNvbXBsZXRlKSB7XG4gICAgICBzZWxmLl9pY2VDb21wbGV0ZSA9IHRydWVcbiAgICAgIHNlbGYuX2RlYnVnKCdpY2VDb21wbGV0ZSB0aW1lb3V0IGNvbXBsZXRlZCcpXG4gICAgICBzZWxmLmVtaXQoJ2ljZVRpbWVvdXQnKVxuICAgICAgc2VsZi5lbWl0KCdfaWNlQ29tcGxldGUnKVxuICAgIH1cbiAgfSwgc2VsZi5pY2VDb21wbGV0ZVRpbWVvdXQpXG59XG5cblBlZXIucHJvdG90eXBlLl9jcmVhdGVPZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgc2VsZi5fcGMuY3JlYXRlT2ZmZXIoc2VsZi5vZmZlck9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKG9mZmVyKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBpZiAoIXNlbGYudHJpY2tsZSAmJiAhc2VsZi5hbGxvd0hhbGZUcmlja2xlKSBvZmZlci5zZHAgPSBmaWx0ZXJUcmlja2xlKG9mZmVyLnNkcClcbiAgICBvZmZlci5zZHAgPSBzZWxmLnNkcFRyYW5zZm9ybShvZmZlci5zZHApXG4gICAgc2VsZi5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcikudGhlbihvblN1Y2Nlc3MpLmNhdGNoKG9uRXJyb3IpXG5cbiAgICBmdW5jdGlvbiBvblN1Y2Nlc3MgKCkge1xuICAgICAgc2VsZi5fZGVidWcoJ2NyZWF0ZU9mZmVyIHN1Y2Nlc3MnKVxuICAgICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgIGlmIChzZWxmLnRyaWNrbGUgfHwgc2VsZi5faWNlQ29tcGxldGUpIHNlbmRPZmZlcigpXG4gICAgICBlbHNlIHNlbGYub25jZSgnX2ljZUNvbXBsZXRlJywgc2VuZE9mZmVyKSAvLyB3YWl0IGZvciBjYW5kaWRhdGVzXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25FcnJvciAoZXJyKSB7XG4gICAgICBzZWxmLmRlc3Ryb3kobWFrZUVycm9yKGVyciwgJ0VSUl9TRVRfTE9DQUxfREVTQ1JJUFRJT04nKSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZW5kT2ZmZXIgKCkge1xuICAgICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgIHZhciBzaWduYWwgPSBzZWxmLl9wYy5sb2NhbERlc2NyaXB0aW9uIHx8IG9mZmVyXG4gICAgICBzZWxmLl9kZWJ1Zygnc2lnbmFsJylcbiAgICAgIHNlbGYuZW1pdCgnc2lnbmFsJywge1xuICAgICAgICB0eXBlOiBzaWduYWwudHlwZSxcbiAgICAgICAgc2RwOiBzaWduYWwuc2RwXG4gICAgICB9KVxuICAgIH1cbiAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikgeyBzZWxmLmRlc3Ryb3kobWFrZUVycm9yKGVyciwgJ0VSUl9DUkVBVEVfT0ZGRVInKSkgfSlcbn1cblxuUGVlci5wcm90b3R5cGUuX3JlcXVlc3RNaXNzaW5nVHJhbnNjZWl2ZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBpZiAoc2VsZi5fcGMuZ2V0VHJhbnNjZWl2ZXJzKSB7XG4gICAgc2VsZi5fcGMuZ2V0VHJhbnNjZWl2ZXJzKCkuZm9yRWFjaCh0cmFuc2NlaXZlciA9PiB7XG4gICAgICBpZiAoIXRyYW5zY2VpdmVyLm1pZCAmJiB0cmFuc2NlaXZlci5zZW5kZXIudHJhY2sgJiYgIXRyYW5zY2VpdmVyLnJlcXVlc3RlZCkge1xuICAgICAgICB0cmFuc2NlaXZlci5yZXF1ZXN0ZWQgPSB0cnVlIC8vIEhBQ0s6IFNhZmFyaSByZXR1cm5zIG5lZ290aWF0ZWQgdHJhbnNjZWl2ZXJzIHdpdGggYSBudWxsIG1pZFxuICAgICAgICBzZWxmLmFkZFRyYW5zY2VpdmVyKHRyYW5zY2VpdmVyLnNlbmRlci50cmFjay5raW5kKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuUGVlci5wcm90b3R5cGUuX2NyZWF0ZUFuc3dlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgc2VsZi5fcGMuY3JlYXRlQW5zd2VyKHNlbGYuYW5zd2VyT3B0aW9ucykudGhlbihmdW5jdGlvbiAoYW5zd2VyKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBpZiAoIXNlbGYudHJpY2tsZSAmJiAhc2VsZi5hbGxvd0hhbGZUcmlja2xlKSBhbnN3ZXIuc2RwID0gZmlsdGVyVHJpY2tsZShhbnN3ZXIuc2RwKVxuICAgIGFuc3dlci5zZHAgPSBzZWxmLnNkcFRyYW5zZm9ybShhbnN3ZXIuc2RwKVxuICAgIHNlbGYuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKS50aGVuKG9uU3VjY2VzcykuY2F0Y2gob25FcnJvcilcblxuICAgIGZ1bmN0aW9uIG9uU3VjY2VzcyAoKSB7XG4gICAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgICAgaWYgKHNlbGYudHJpY2tsZSB8fCBzZWxmLl9pY2VDb21wbGV0ZSkgc2VuZEFuc3dlcigpXG4gICAgICBlbHNlIHNlbGYub25jZSgnX2ljZUNvbXBsZXRlJywgc2VuZEFuc3dlcilcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkVycm9yIChlcnIpIHtcbiAgICAgIHNlbGYuZGVzdHJveShtYWtlRXJyb3IoZXJyLCAnRVJSX1NFVF9MT0NBTF9ERVNDUklQVElPTicpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbmRBbnN3ZXIgKCkge1xuICAgICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgIHZhciBzaWduYWwgPSBzZWxmLl9wYy5sb2NhbERlc2NyaXB0aW9uIHx8IGFuc3dlclxuICAgICAgc2VsZi5fZGVidWcoJ3NpZ25hbCcpXG4gICAgICBzZWxmLmVtaXQoJ3NpZ25hbCcsIHtcbiAgICAgICAgdHlwZTogc2lnbmFsLnR5cGUsXG4gICAgICAgIHNkcDogc2lnbmFsLnNkcFxuICAgICAgfSlcbiAgICAgIGlmICghc2VsZi5pbml0aWF0b3IpIHNlbGYuX3JlcXVlc3RNaXNzaW5nVHJhbnNjZWl2ZXJzKClcbiAgICB9XG4gIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHsgc2VsZi5kZXN0cm95KG1ha2VFcnJvcihlcnIsICdFUlJfQ1JFQVRFX0FOU1dFUicpKSB9KVxufVxuXG5QZWVyLnByb3RvdHlwZS5fb25JY2VTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHZhciBpY2VDb25uZWN0aW9uU3RhdGUgPSBzZWxmLl9wYy5pY2VDb25uZWN0aW9uU3RhdGVcbiAgdmFyIGljZUdhdGhlcmluZ1N0YXRlID0gc2VsZi5fcGMuaWNlR2F0aGVyaW5nU3RhdGVcblxuICBzZWxmLl9kZWJ1ZyhcbiAgICAnaWNlU3RhdGVDaGFuZ2UgKGNvbm5lY3Rpb246ICVzKSAoZ2F0aGVyaW5nOiAlcyknLFxuICAgIGljZUNvbm5lY3Rpb25TdGF0ZSxcbiAgICBpY2VHYXRoZXJpbmdTdGF0ZVxuICApXG4gIHNlbGYuZW1pdCgnaWNlU3RhdGVDaGFuZ2UnLCBpY2VDb25uZWN0aW9uU3RhdGUsIGljZUdhdGhlcmluZ1N0YXRlKVxuXG4gIGlmIChpY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnIHx8IGljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcbiAgICBzZWxmLl9wY1JlYWR5ID0gdHJ1ZVxuICAgIHNlbGYuX21heWJlUmVhZHkoKVxuICB9XG4gIGlmIChpY2VDb25uZWN0aW9uU3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgc2VsZi5kZXN0cm95KG1ha2VFcnJvcignSWNlIGNvbm5lY3Rpb24gZmFpbGVkLicsICdFUlJfSUNFX0NPTk5FQ1RJT05fRkFJTFVSRScpKVxuICB9XG4gIGlmIChpY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgc2VsZi5kZXN0cm95KG1ha2VFcnJvcignSWNlIGNvbm5lY3Rpb24gY2xvc2VkLicsICdFUlJfSUNFX0NPTk5FQ1RJT05fQ0xPU0VEJykpXG4gIH1cbn1cblxuUGVlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgLy8gUHJvbWlzZS1iYXNlZCBnZXRTdGF0cygpIChzdGFuZGFyZClcbiAgaWYgKHNlbGYuX3BjLmdldFN0YXRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHNlbGYuX3BjLmdldFN0YXRzKCkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICB2YXIgcmVwb3J0cyA9IFtdXG4gICAgICByZXMuZm9yRWFjaChmdW5jdGlvbiAocmVwb3J0KSB7XG4gICAgICAgIHJlcG9ydHMucHVzaChmbGF0dGVuVmFsdWVzKHJlcG9ydCkpXG4gICAgICB9KVxuICAgICAgY2IobnVsbCwgcmVwb3J0cylcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7IGNiKGVycikgfSlcblxuICAvLyBUd28tcGFyYW1ldGVyIGNhbGxiYWNrLWJhc2VkIGdldFN0YXRzKCkgKGRlcHJlY2F0ZWQsIGZvcm1lciBzdGFuZGFyZClcbiAgfSBlbHNlIGlmIChzZWxmLl9pc1JlYWN0TmF0aXZlV2VicnRjKSB7XG4gICAgc2VsZi5fcGMuZ2V0U3RhdHMobnVsbCwgZnVuY3Rpb24gKHJlcykge1xuICAgICAgdmFyIHJlcG9ydHMgPSBbXVxuICAgICAgcmVzLmZvckVhY2goZnVuY3Rpb24gKHJlcG9ydCkge1xuICAgICAgICByZXBvcnRzLnB1c2goZmxhdHRlblZhbHVlcyhyZXBvcnQpKVxuICAgICAgfSlcbiAgICAgIGNiKG51bGwsIHJlcG9ydHMpXG4gICAgfSwgZnVuY3Rpb24gKGVycikgeyBjYihlcnIpIH0pXG5cbiAgLy8gU2luZ2xlLXBhcmFtZXRlciBjYWxsYmFjay1iYXNlZCBnZXRTdGF0cygpIChub24tc3RhbmRhcmQpXG4gIH0gZWxzZSBpZiAoc2VsZi5fcGMuZ2V0U3RhdHMubGVuZ3RoID4gMCkge1xuICAgIHNlbGYuX3BjLmdldFN0YXRzKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIElmIHdlIGRlc3Ryb3kgY29ubmVjdGlvbiBpbiBgY29ubmVjdGAgY2FsbGJhY2sgdGhpcyBjb2RlIG1pZ2h0IGhhcHBlbiB0byBydW4gd2hlbiBhY3R1YWwgY29ubmVjdGlvbiBpcyBhbHJlYWR5IGNsb3NlZFxuICAgICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblxuICAgICAgdmFyIHJlcG9ydHMgPSBbXVxuICAgICAgcmVzLnJlc3VsdCgpLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICB2YXIgcmVwb3J0ID0ge31cbiAgICAgICAgcmVzdWx0Lm5hbWVzKCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHJlcG9ydFtuYW1lXSA9IHJlc3VsdC5zdGF0KG5hbWUpXG4gICAgICAgIH0pXG4gICAgICAgIHJlcG9ydC5pZCA9IHJlc3VsdC5pZFxuICAgICAgICByZXBvcnQudHlwZSA9IHJlc3VsdC50eXBlXG4gICAgICAgIHJlcG9ydC50aW1lc3RhbXAgPSByZXN1bHQudGltZXN0YW1wXG4gICAgICAgIHJlcG9ydHMucHVzaChmbGF0dGVuVmFsdWVzKHJlcG9ydCkpXG4gICAgICB9KVxuICAgICAgY2IobnVsbCwgcmVwb3J0cylcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7IGNiKGVycikgfSlcblxuICAvLyBVbmtub3duIGJyb3dzZXIsIHNraXAgZ2V0U3RhdHMoKSBzaW5jZSBpdCdzIGFueW9uZSdzIGd1ZXNzIHdoaWNoIHN0eWxlIG9mXG4gIC8vIGdldFN0YXRzKCkgdGhleSBpbXBsZW1lbnQuXG4gIH0gZWxzZSB7XG4gICAgY2IobnVsbCwgW10pXG4gIH1cblxuICAvLyBzdGF0cmVwb3J0cyBjYW4gY29tZSB3aXRoIGEgdmFsdWUgYXJyYXkgaW5zdGVhZCBvZiBwcm9wZXJ0aWVzXG4gIGZ1bmN0aW9uIGZsYXR0ZW5WYWx1ZXMgKHJlcG9ydCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmVwb3J0LnZhbHVlcykgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJlcG9ydC52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihyZXBvcnQsIHZhbHVlKVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHJlcG9ydFxuICB9XG59XG5cblBlZXIucHJvdG90eXBlLl9tYXliZVJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fZGVidWcoJ21heWJlUmVhZHkgcGMgJXMgY2hhbm5lbCAlcycsIHNlbGYuX3BjUmVhZHksIHNlbGYuX2NoYW5uZWxSZWFkeSlcbiAgaWYgKHNlbGYuX2Nvbm5lY3RlZCB8fCBzZWxmLl9jb25uZWN0aW5nIHx8ICFzZWxmLl9wY1JlYWR5IHx8ICFzZWxmLl9jaGFubmVsUmVhZHkpIHJldHVyblxuXG4gIHNlbGYuX2Nvbm5lY3RpbmcgPSB0cnVlXG5cbiAgLy8gSEFDSzogV2UgY2FuJ3QgcmVseSBvbiBvcmRlciBoZXJlLCBmb3IgZGV0YWlscyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pzLXBsYXRmb3JtL25vZGUtd2VicnRjL2lzc3Vlcy8zMzlcbiAgZnVuY3Rpb24gZmluZENhbmRpZGF0ZVBhaXIgKCkge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICBzZWxmLmdldFN0YXRzKGZ1bmN0aW9uIChlcnIsIGl0ZW1zKSB7XG4gICAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgICAvLyBUcmVhdCBnZXRTdGF0cyBlcnJvciBhcyBub24tZmF0YWwuIEl0J3Mgbm90IGVzc2VudGlhbC5cbiAgICAgIGlmIChlcnIpIGl0ZW1zID0gW11cblxuICAgICAgdmFyIHJlbW90ZUNhbmRpZGF0ZXMgPSB7fVxuICAgICAgdmFyIGxvY2FsQ2FuZGlkYXRlcyA9IHt9XG4gICAgICB2YXIgY2FuZGlkYXRlUGFpcnMgPSB7fVxuICAgICAgdmFyIGZvdW5kU2VsZWN0ZWRDYW5kaWRhdGVQYWlyID0gZmFsc2VcblxuICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAvLyBUT0RPOiBPbmNlIGFsbCBicm93c2VycyBzdXBwb3J0IHRoZSBoeXBoZW5hdGVkIHN0YXRzIHJlcG9ydCB0eXBlcywgcmVtb3ZlXG4gICAgICAgIC8vIHRoZSBub24taHlwZW5hdGVkIG9uZXNcbiAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ3JlbW90ZWNhbmRpZGF0ZScgfHwgaXRlbS50eXBlID09PSAncmVtb3RlLWNhbmRpZGF0ZScpIHtcbiAgICAgICAgICByZW1vdGVDYW5kaWRhdGVzW2l0ZW0uaWRdID0gaXRlbVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdsb2NhbGNhbmRpZGF0ZScgfHwgaXRlbS50eXBlID09PSAnbG9jYWwtY2FuZGlkYXRlJykge1xuICAgICAgICAgIGxvY2FsQ2FuZGlkYXRlc1tpdGVtLmlkXSA9IGl0ZW1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnY2FuZGlkYXRlcGFpcicgfHwgaXRlbS50eXBlID09PSAnY2FuZGlkYXRlLXBhaXInKSB7XG4gICAgICAgICAgY2FuZGlkYXRlUGFpcnNbaXRlbS5pZF0gPSBpdGVtXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgLy8gU3BlYy1jb21wbGlhbnRcbiAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ3RyYW5zcG9ydCcgJiYgaXRlbS5zZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCkge1xuICAgICAgICAgIHNldFNlbGVjdGVkQ2FuZGlkYXRlUGFpcihjYW5kaWRhdGVQYWlyc1tpdGVtLnNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkXSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9sZCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChpdGVtLnR5cGUgPT09ICdnb29nQ2FuZGlkYXRlUGFpcicgJiYgaXRlbS5nb29nQWN0aXZlQ29ubmVjdGlvbiA9PT0gJ3RydWUnKSB8fFxuICAgICAgICAgICgoaXRlbS50eXBlID09PSAnY2FuZGlkYXRlcGFpcicgfHwgaXRlbS50eXBlID09PSAnY2FuZGlkYXRlLXBhaXInKSAmJiBpdGVtLnNlbGVjdGVkKVxuICAgICAgICApIHtcbiAgICAgICAgICBzZXRTZWxlY3RlZENhbmRpZGF0ZVBhaXIoaXRlbSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgZnVuY3Rpb24gc2V0U2VsZWN0ZWRDYW5kaWRhdGVQYWlyIChzZWxlY3RlZENhbmRpZGF0ZVBhaXIpIHtcbiAgICAgICAgZm91bmRTZWxlY3RlZENhbmRpZGF0ZVBhaXIgPSB0cnVlXG5cbiAgICAgICAgdmFyIGxvY2FsID0gbG9jYWxDYW5kaWRhdGVzW3NlbGVjdGVkQ2FuZGlkYXRlUGFpci5sb2NhbENhbmRpZGF0ZUlkXVxuXG4gICAgICAgIGlmIChsb2NhbCAmJiAobG9jYWwuaXAgfHwgbG9jYWwuYWRkcmVzcykpIHtcbiAgICAgICAgICAvLyBTcGVjXG4gICAgICAgICAgc2VsZi5sb2NhbEFkZHJlc3MgPSBsb2NhbC5pcCB8fCBsb2NhbC5hZGRyZXNzXG4gICAgICAgICAgc2VsZi5sb2NhbFBvcnQgPSBOdW1iZXIobG9jYWwucG9ydClcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbCAmJiBsb2NhbC5pcEFkZHJlc3MpIHtcbiAgICAgICAgICAvLyBGaXJlZm94XG4gICAgICAgICAgc2VsZi5sb2NhbEFkZHJlc3MgPSBsb2NhbC5pcEFkZHJlc3NcbiAgICAgICAgICBzZWxmLmxvY2FsUG9ydCA9IE51bWJlcihsb2NhbC5wb3J0TnVtYmVyKVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxlY3RlZENhbmRpZGF0ZVBhaXIuZ29vZ0xvY2FsQWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBvbmNlIENocm9tZSA1OCBpcyByZWxlYXNlZFxuICAgICAgICAgIGxvY2FsID0gc2VsZWN0ZWRDYW5kaWRhdGVQYWlyLmdvb2dMb2NhbEFkZHJlc3Muc3BsaXQoJzonKVxuICAgICAgICAgIHNlbGYubG9jYWxBZGRyZXNzID0gbG9jYWxbMF1cbiAgICAgICAgICBzZWxmLmxvY2FsUG9ydCA9IE51bWJlcihsb2NhbFsxXSlcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5sb2NhbEFkZHJlc3MpIHtcbiAgICAgICAgICBzZWxmLmxvY2FsRmFtaWx5ID0gc2VsZi5sb2NhbEFkZHJlc3MuaW5jbHVkZXMoJzonKSA/ICdJUHY2JyA6ICdJUHY0J1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbW90ZSA9IHJlbW90ZUNhbmRpZGF0ZXNbc2VsZWN0ZWRDYW5kaWRhdGVQYWlyLnJlbW90ZUNhbmRpZGF0ZUlkXVxuXG4gICAgICAgIGlmIChyZW1vdGUgJiYgKHJlbW90ZS5pcCB8fCByZW1vdGUuYWRkcmVzcykpIHtcbiAgICAgICAgICAvLyBTcGVjXG4gICAgICAgICAgc2VsZi5yZW1vdGVBZGRyZXNzID0gcmVtb3RlLmlwIHx8IHJlbW90ZS5hZGRyZXNzXG4gICAgICAgICAgc2VsZi5yZW1vdGVQb3J0ID0gTnVtYmVyKHJlbW90ZS5wb3J0KVxuICAgICAgICB9IGVsc2UgaWYgKHJlbW90ZSAmJiByZW1vdGUuaXBBZGRyZXNzKSB7XG4gICAgICAgICAgLy8gRmlyZWZveFxuICAgICAgICAgIHNlbGYucmVtb3RlQWRkcmVzcyA9IHJlbW90ZS5pcEFkZHJlc3NcbiAgICAgICAgICBzZWxmLnJlbW90ZVBvcnQgPSBOdW1iZXIocmVtb3RlLnBvcnROdW1iZXIpXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGVjdGVkQ2FuZGlkYXRlUGFpci5nb29nUmVtb3RlQWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBvbmNlIENocm9tZSA1OCBpcyByZWxlYXNlZFxuICAgICAgICAgIHJlbW90ZSA9IHNlbGVjdGVkQ2FuZGlkYXRlUGFpci5nb29nUmVtb3RlQWRkcmVzcy5zcGxpdCgnOicpXG4gICAgICAgICAgc2VsZi5yZW1vdGVBZGRyZXNzID0gcmVtb3RlWzBdXG4gICAgICAgICAgc2VsZi5yZW1vdGVQb3J0ID0gTnVtYmVyKHJlbW90ZVsxXSlcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5yZW1vdGVBZGRyZXNzKSB7XG4gICAgICAgICAgc2VsZi5yZW1vdGVGYW1pbHkgPSBzZWxmLnJlbW90ZUFkZHJlc3MuaW5jbHVkZXMoJzonKSA/ICdJUHY2JyA6ICdJUHY0J1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5fZGVidWcoXG4gICAgICAgICAgJ2Nvbm5lY3QgbG9jYWw6ICVzOiVzIHJlbW90ZTogJXM6JXMnLFxuICAgICAgICAgIHNlbGYubG9jYWxBZGRyZXNzLCBzZWxmLmxvY2FsUG9ydCwgc2VsZi5yZW1vdGVBZGRyZXNzLCBzZWxmLnJlbW90ZVBvcnRcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBJZ25vcmUgY2FuZGlkYXRlIHBhaXIgc2VsZWN0aW9uIGluIGJyb3dzZXJzIGxpa2UgU2FmYXJpIDExIHRoYXQgZG8gbm90IGhhdmUgYW55IGxvY2FsIG9yIHJlbW90ZSBjYW5kaWRhdGVzXG4gICAgICAvLyBCdXQgd2FpdCB1bnRpbCBhdCBsZWFzdCAxIGNhbmRpZGF0ZSBwYWlyIGlzIGF2YWlsYWJsZVxuICAgICAgaWYgKCFmb3VuZFNlbGVjdGVkQ2FuZGlkYXRlUGFpciAmJiAoIU9iamVjdC5rZXlzKGNhbmRpZGF0ZVBhaXJzKS5sZW5ndGggfHwgT2JqZWN0LmtleXMobG9jYWxDYW5kaWRhdGVzKS5sZW5ndGgpKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZmluZENhbmRpZGF0ZVBhaXIsIDEwMClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLl9jb25uZWN0aW5nID0gZmFsc2VcbiAgICAgICAgc2VsZi5fY29ubmVjdGVkID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5fY2h1bmspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzZWxmLnNlbmQoc2VsZi5fY2h1bmspXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiBzZWxmLmRlc3Ryb3kobWFrZUVycm9yKGVyciwgJ0VSUl9EQVRBX0NIQU5ORUwnKSlcbiAgICAgICAgfVxuICAgICAgICBzZWxmLl9jaHVuayA9IG51bGxcbiAgICAgICAgc2VsZi5fZGVidWcoJ3NlbnQgY2h1bmsgZnJvbSBcIndyaXRlIGJlZm9yZSBjb25uZWN0XCInKVxuXG4gICAgICAgIHZhciBjYiA9IHNlbGYuX2NiXG4gICAgICAgIHNlbGYuX2NiID0gbnVsbFxuICAgICAgICBjYihudWxsKVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBgYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGRgIGFuZCAnb25idWZmZXJlZGFtb3VudGxvdycgYXJlIHVuc3VwcG9ydGVkLFxuICAgICAgLy8gZmFsbGJhY2sgdG8gdXNpbmcgc2V0SW50ZXJ2YWwgdG8gaW1wbGVtZW50IGJhY2twcmVzc3VyZS5cbiAgICAgIGlmICh0eXBlb2Ygc2VsZi5fY2hhbm5lbC5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgc2VsZi5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7IHNlbGYuX29uSW50ZXJ2YWwoKSB9LCAxNTApXG4gICAgICAgIGlmIChzZWxmLl9pbnRlcnZhbC51bnJlZikgc2VsZi5faW50ZXJ2YWwudW5yZWYoKVxuICAgICAgfVxuXG4gICAgICBzZWxmLl9kZWJ1ZygnY29ubmVjdCcpXG4gICAgICBzZWxmLmVtaXQoJ2Nvbm5lY3QnKVxuICAgIH0pXG4gIH1cbiAgZmluZENhbmRpZGF0ZVBhaXIoKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fb25JbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghc2VsZi5fY2IgfHwgIXNlbGYuX2NoYW5uZWwgfHwgc2VsZi5fY2hhbm5lbC5idWZmZXJlZEFtb3VudCA+IE1BWF9CVUZGRVJFRF9BTU9VTlQpIHtcbiAgICByZXR1cm5cbiAgfVxuICBzZWxmLl9vbkNoYW5uZWxCdWZmZXJlZEFtb3VudExvdygpXG59XG5cblBlZXIucHJvdG90eXBlLl9vblNpZ25hbGluZ1N0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblxuICBpZiAoc2VsZi5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdzdGFibGUnICYmICFzZWxmLl9maXJzdFN0YWJsZSkge1xuICAgIHNlbGYuX2lzTmVnb3RpYXRpbmcgPSBmYWxzZVxuXG4gICAgLy8gSEFDSzogRmlyZWZveCBkb2Vzbid0IHlldCBzdXBwb3J0IHJlbW92aW5nIHRyYWNrcyB3aGVuIHNpZ25hbGluZ1N0YXRlICE9PSAnc3RhYmxlJ1xuICAgIHNlbGYuX2RlYnVnKCdmbHVzaGluZyBzZW5kZXIgcXVldWUnLCBzZWxmLl9zZW5kZXJzQXdhaXRpbmdTdGFibGUpXG4gICAgc2VsZi5fc2VuZGVyc0F3YWl0aW5nU3RhYmxlLmZvckVhY2goZnVuY3Rpb24gKHNlbmRlcikge1xuICAgICAgc2VsZi5fcGMucmVtb3ZlVHJhY2soc2VuZGVyKVxuICAgICAgc2VsZi5fcXVldWVkTmVnb3RpYXRpb24gPSB0cnVlXG4gICAgfSlcbiAgICBzZWxmLl9zZW5kZXJzQXdhaXRpbmdTdGFibGUgPSBbXVxuXG4gICAgaWYgKHNlbGYuX3F1ZXVlZE5lZ290aWF0aW9uKSB7XG4gICAgICBzZWxmLl9kZWJ1ZygnZmx1c2hpbmcgbmVnb3RpYXRpb24gcXVldWUnKVxuICAgICAgc2VsZi5fcXVldWVkTmVnb3RpYXRpb24gPSBmYWxzZVxuICAgICAgc2VsZi5fbmVlZHNOZWdvdGlhdGlvbigpIC8vIG5lZ290aWF0ZSBhZ2FpblxuICAgIH1cblxuICAgIHNlbGYuX2RlYnVnKCduZWdvdGlhdGUnKVxuICAgIHNlbGYuZW1pdCgnbmVnb3RpYXRlJylcbiAgfVxuICBzZWxmLl9maXJzdFN0YWJsZSA9IGZhbHNlXG5cbiAgc2VsZi5fZGVidWcoJ3NpZ25hbGluZ1N0YXRlQ2hhbmdlICVzJywgc2VsZi5fcGMuc2lnbmFsaW5nU3RhdGUpXG4gIHNlbGYuZW1pdCgnc2lnbmFsaW5nU3RhdGVDaGFuZ2UnLCBzZWxmLl9wYy5zaWduYWxpbmdTdGF0ZSlcbn1cblxuUGVlci5wcm90b3R5cGUuX29uSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBpZiAoZXZlbnQuY2FuZGlkYXRlICYmIHNlbGYudHJpY2tsZSkge1xuICAgIHNlbGYuZW1pdCgnc2lnbmFsJywge1xuICAgICAgY2FuZGlkYXRlOiB7XG4gICAgICAgIGNhbmRpZGF0ZTogZXZlbnQuY2FuZGlkYXRlLmNhbmRpZGF0ZSxcbiAgICAgICAgc2RwTUxpbmVJbmRleDogZXZlbnQuY2FuZGlkYXRlLnNkcE1MaW5lSW5kZXgsXG4gICAgICAgIHNkcE1pZDogZXZlbnQuY2FuZGlkYXRlLnNkcE1pZFxuICAgICAgfVxuICAgIH0pXG4gIH0gZWxzZSBpZiAoIWV2ZW50LmNhbmRpZGF0ZSAmJiAhc2VsZi5faWNlQ29tcGxldGUpIHtcbiAgICBzZWxmLl9pY2VDb21wbGV0ZSA9IHRydWVcbiAgICBzZWxmLmVtaXQoJ19pY2VDb21wbGV0ZScpXG4gIH1cbiAgLy8gYXMgc29vbiBhcyB3ZSd2ZSByZWNlaXZlZCBvbmUgdmFsaWQgY2FuZGlkYXRlIHN0YXJ0IHRpbWVvdXRcbiAgaWYgKGV2ZW50LmNhbmRpZGF0ZSkge1xuICAgIHNlbGYuX3N0YXJ0SWNlQ29tcGxldGVUaW1lb3V0KClcbiAgfVxufVxuXG5QZWVyLnByb3RvdHlwZS5fb25DaGFubmVsTWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgdmFyIGRhdGEgPSBldmVudC5kYXRhXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKVxuICBzZWxmLnB1c2goZGF0YSlcbn1cblxuUGVlci5wcm90b3R5cGUuX29uQ2hhbm5lbEJ1ZmZlcmVkQW1vdW50TG93ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkIHx8ICFzZWxmLl9jYikgcmV0dXJuXG4gIHNlbGYuX2RlYnVnKCdlbmRpbmcgYmFja3ByZXNzdXJlOiBidWZmZXJlZEFtb3VudCAlZCcsIHNlbGYuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQpXG4gIHZhciBjYiA9IHNlbGYuX2NiXG4gIHNlbGYuX2NiID0gbnVsbFxuICBjYihudWxsKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fb25DaGFubmVsT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLl9jb25uZWN0ZWQgfHwgc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLl9kZWJ1Zygnb24gY2hhbm5lbCBvcGVuJylcbiAgc2VsZi5fY2hhbm5lbFJlYWR5ID0gdHJ1ZVxuICBzZWxmLl9tYXliZVJlYWR5KClcbn1cblxuUGVlci5wcm90b3R5cGUuX29uQ2hhbm5lbENsb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgc2VsZi5fZGVidWcoJ29uIGNoYW5uZWwgY2xvc2UnKVxuICBzZWxmLmRlc3Ryb3koKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fb25UcmFjayA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblxuICBldmVudC5zdHJlYW1zLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50U3RyZWFtKSB7XG4gICAgc2VsZi5fZGVidWcoJ29uIHRyYWNrJylcbiAgICBzZWxmLmVtaXQoJ3RyYWNrJywgZXZlbnQudHJhY2ssIGV2ZW50U3RyZWFtKVxuXG4gICAgc2VsZi5fcmVtb3RlVHJhY2tzLnB1c2goe1xuICAgICAgdHJhY2s6IGV2ZW50LnRyYWNrLFxuICAgICAgc3RyZWFtOiBldmVudFN0cmVhbVxuICAgIH0pXG5cbiAgICBpZiAoc2VsZi5fcmVtb3RlU3RyZWFtcy5zb21lKGZ1bmN0aW9uIChyZW1vdGVTdHJlYW0pIHtcbiAgICAgIHJldHVybiByZW1vdGVTdHJlYW0uaWQgPT09IGV2ZW50U3RyZWFtLmlkXG4gICAgfSkpIHJldHVybiAvLyBPbmx5IGZpcmUgb25lICdzdHJlYW0nIGV2ZW50LCBldmVuIHRob3VnaCB0aGVyZSBtYXkgYmUgbXVsdGlwbGUgdHJhY2tzIHBlciBzdHJlYW1cblxuICAgIHNlbGYuX3JlbW90ZVN0cmVhbXMucHVzaChldmVudFN0cmVhbSlcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZW1pdCgnc3RyZWFtJywgZXZlbnRTdHJlYW0pIC8vIGVuc3VyZSBhbGwgdHJhY2tzIGhhdmUgYmVlbiBhZGRlZFxuICAgIH0sIDApXG4gIH0pXG59XG5cblBlZXIucHJvdG90eXBlLl9kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gIGFyZ3NbMF0gPSAnWycgKyBzZWxmLl9pZCArICddICcgKyBhcmdzWzBdXG4gIGRlYnVnLmFwcGx5KG51bGwsIGFyZ3MpXG59XG5cbi8vIEhBQ0s6IEZpbHRlciB0cmlja2xlIGxpbmVzIHdoZW4gdHJpY2tsZSBpcyBkaXNhYmxlZCAjMzU0XG5mdW5jdGlvbiBmaWx0ZXJUcmlja2xlIChzZHApIHtcbiAgcmV0dXJuIHNkcC5yZXBsYWNlKC9hPWljZS1vcHRpb25zOnRyaWNrbGVcXHNcXG4vZywgJycpXG59XG5cbmZ1bmN0aW9uIG1ha2VFcnJvciAobWVzc2FnZSwgY29kZSkge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpXG4gIGVyci5jb2RlID0gY29kZVxuICByZXR1cm4gZXJyXG59XG5cbmZ1bmN0aW9uIHdhcm4gKG1lc3NhZ2UpIHtcbiAgY29uc29sZS53YXJuKG1lc3NhZ2UpXG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXJsID0gcmVxdWlyZSgnLi91cmwnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGxvb2t1cDtcblxuLyoqXG4gKiBNYW5hZ2VycyBjYWNoZS5cbiAqL1xuXG52YXIgY2FjaGUgPSBleHBvcnRzLm1hbmFnZXJzID0ge307XG5cbi8qKlxuICogTG9va3MgdXAgYW4gZXhpc3RpbmcgYE1hbmFnZXJgIGZvciBtdWx0aXBsZXhpbmcuXG4gKiBJZiB0aGUgdXNlciBzdW1tb25zOlxuICpcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2EnKTtgXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9iJyk7YFxuICpcbiAqIFdlIHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZSBiYXNlZCBvbiBzYW1lIHNjaGVtZS9wb3J0L2hvc3QsXG4gKiBhbmQgd2UgaW5pdGlhbGl6ZSBzb2NrZXRzIGZvciBlYWNoIG5hbWVzcGFjZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvb2t1cCAodXJpLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgdXJpID09PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHBhcnNlZCA9IHVybCh1cmkpO1xuICB2YXIgc291cmNlID0gcGFyc2VkLnNvdXJjZTtcbiAgdmFyIGlkID0gcGFyc2VkLmlkO1xuICB2YXIgcGF0aCA9IHBhcnNlZC5wYXRoO1xuICB2YXIgc2FtZU5hbWVzcGFjZSA9IGNhY2hlW2lkXSAmJiBwYXRoIGluIGNhY2hlW2lkXS5uc3BzO1xuICB2YXIgbmV3Q29ubmVjdGlvbiA9IG9wdHMuZm9yY2VOZXcgfHwgb3B0c1snZm9yY2UgbmV3IGNvbm5lY3Rpb24nXSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGZhbHNlID09PSBvcHRzLm11bHRpcGxleCB8fCBzYW1lTmFtZXNwYWNlO1xuXG4gIHZhciBpbztcblxuICBpZiAobmV3Q29ubmVjdGlvbikge1xuICAgIGRlYnVnKCdpZ25vcmluZyBzb2NrZXQgY2FjaGUgZm9yICVzJywgc291cmNlKTtcbiAgICBpbyA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWNhY2hlW2lkXSkge1xuICAgICAgZGVidWcoJ25ldyBpbyBpbnN0YW5jZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgICAgY2FjaGVbaWRdID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICAgIH1cbiAgICBpbyA9IGNhY2hlW2lkXTtcbiAgfVxuICBpZiAocGFyc2VkLnF1ZXJ5ICYmICFvcHRzLnF1ZXJ5KSB7XG4gICAgb3B0cy5xdWVyeSA9IHBhcnNlZC5xdWVyeTtcbiAgfVxuICByZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDtcblxuLyoqXG4gKiBgY29ubmVjdGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmNvbm5lY3QgPSBsb29rdXA7XG5cbi8qKlxuICogRXhwb3NlIGNvbnN0cnVjdG9ycyBmb3Igc3RhbmRhbG9uZSBidWlsZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xuZXhwb3J0cy5Tb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMubWVzc2FnZXMgPSB7XG4gIE5PVF9TVEFSVEVEX1lFVDogJ1RoZSBsaWJwMnAgbm9kZSBpcyBub3Qgc3RhcnRlZCB5ZXQnLFxuICBESFRfRElTQUJMRUQ6ICdESFQgaXMgbm90IGF2YWlsYWJsZSdcbn1cblxuZXhwb3J0cy5jb2RlcyA9IHtcbiAgREhUX0RJU0FCTEVEOiAnRVJSX0RIVF9ESVNBQkxFRCcsXG4gIFBVQlNVQl9OT1RfU1RBUlRFRDogJ0VSUl9QVUJTVUJfTk9UX1NUQVJURUQnLFxuICBFUlJfTk9ERV9OT1RfU1RBUlRFRDogJ0VSUl9OT0RFX05PVF9TVEFSVEVEJyxcbiAgRVJSX0RJU0NPVkVSRURfU0VMRjogJ0VSUl9ESVNDT1ZFUkVEX1NFTEYnXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgUGVlcklkID0gcmVxdWlyZSgncGVlci1pZCcpXG5jb25zdCBQZWVySW5mbyA9IHJlcXVpcmUoJ3BlZXItaW5mbycpXG5jb25zdCBtdWx0aWFkZHIgPSByZXF1aXJlKCdtdWx0aWFkZHInKVxuY29uc3QgZXJyQ29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxubW9kdWxlLmV4cG9ydHMgPSAobm9kZSkgPT4ge1xuICAvKlxuICAgKiBIZWxwZXIgbWV0aG9kIHRvIGNoZWNrIHRoZSBkYXRhIHR5cGUgb2YgcGVlciBhbmQgY29udmVydCBpdCB0byBQZWVySW5mb1xuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIChwZWVyLCBjYWxsYmFjaykge1xuICAgIGxldCBwXG4gICAgLy8gUGVlckluZm9cbiAgICBpZiAoUGVlckluZm8uaXNQZWVySW5mbyhwZWVyKSkge1xuICAgICAgcCA9IHBlZXJcbiAgICAvLyBNdWx0aWFkZHIgaW5zdGFuY2Ugb3IgTXVsdGlhZGRyIFN0cmluZ1xuICAgIH0gZWxzZSBpZiAobXVsdGlhZGRyLmlzTXVsdGlhZGRyKHBlZXIpIHx8IHR5cGVvZiBwZWVyID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGVvZiBwZWVyID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHBlZXIgPSBtdWx0aWFkZHIocGVlcilcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKFxuICAgICAgICAgICAgZXJyQ29kZShlcnIsICdFUlJfSU5WQUxJRF9NVUxUSUFERFInKVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwZWVySWRCNThTdHIgPSBwZWVyLmdldFBlZXJJZCgpXG5cbiAgICAgIGlmICghcGVlcklkQjU4U3RyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhcbiAgICAgICAgICBlcnJDb2RlKFxuICAgICAgICAgICAgbmV3IEVycm9yKCdwZWVyIG11bHRpYWRkciBpbnN0YW5jZSBvciBzdHJpbmcgbXVzdCBpbmNsdWRlIHBlZXJJZCcpLFxuICAgICAgICAgICAgJ0VSUl9JTlZBTElEX01VTFRJQUREUidcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgcCA9IG5vZGUucGVlckJvb2suZ2V0KHBlZXJJZEI1OFN0cilcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBwID0gbmV3IFBlZXJJbmZvKFBlZXJJZC5jcmVhdGVGcm9tQjU4U3RyaW5nKHBlZXJJZEI1OFN0cikpXG4gICAgICB9XG4gICAgICBwLm11bHRpYWRkcnMuYWRkKHBlZXIpXG5cbiAgICAgIC8vIFBlZXJJZFxuICAgIH0gZWxzZSBpZiAoUGVlcklkLmlzUGVlcklkKHBlZXIpKSB7XG4gICAgICBjb25zdCBwZWVySWRCNThTdHIgPSBwZWVyLnRvQjU4U3RyaW5nKClcbiAgICAgIHRyeSB7XG4gICAgICAgIHAgPSBub2RlLnBlZXJCb29rLmdldChwZWVySWRCNThTdHIpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUucGVlclJvdXRpbmcuZmluZFBlZXIocGVlciwgY2FsbGJhY2spXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhcbiAgICAgICAgZXJyQ29kZShcbiAgICAgICAgICBuZXcgRXJyb3IoYCR7cH0gaXMgbm90IGEgdmFsaWQgcGVlciB0eXBlYCksXG4gICAgICAgICAgJ0VSUl9JTlZBTElEX1BFRVJfVFlQRSdcbiAgICAgICAgKVxuICAgICAgKVxuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIHApXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHN0cnVjdCwgc3VwZXJzdHJ1Y3QgfSA9IHJlcXVpcmUoJ3N1cGVyc3RydWN0JylcbmNvbnN0IHsgb3B0aW9uYWwsIGxpc3QgfSA9IHN0cnVjdFxuXG4vLyBEZWZpbmUgY3VzdG9tIHR5cGVzXG5jb25zdCBzID0gc3VwZXJzdHJ1Y3QoKVxuY29uc3QgdHJhbnNwb3J0ID0gcy51bmlvbihbXG4gIHMuaW50ZXJmYWNlKHtcbiAgICBjcmVhdGVMaXN0ZW5lcjogJ2Z1bmN0aW9uJyxcbiAgICBkaWFsOiAnZnVuY3Rpb24nXG4gIH0pLFxuICAnZnVuY3Rpb24nXG5dKVxuY29uc3QgbW9kdWxlc1NjaGVtYSA9IHMoe1xuICBjb25uRW5jcnlwdGlvbjogb3B0aW9uYWwobGlzdChbcygnb2JqZWN0fGZ1bmN0aW9uJyldKSksXG4gIC8vIHRoaXMgaXMgaGFja3kgdG8gc2ltdWxhdGUgb3B0aW9uYWwgYmVjYXVzZSBpbnRlcmZhY2UgZG9lc250IHdvcmsgY29ycmVjdGx5IHdpdGggaXRcbiAgLy8gY2hhbmdlIHRvIG9wdGlvbmFsIHdoZW4gZml4ZWQgdXBzdHJlYW1cbiAgY29ublByb3RlY3Rvcjogcy51bmlvbihbJ3VuZGVmaW5lZCcsIHMuaW50ZXJmYWNlKHsgcHJvdGVjdDogJ2Z1bmN0aW9uJyB9KV0pLFxuICBjb250ZW50Um91dGluZzogb3B0aW9uYWwobGlzdChbJ29iamVjdCddKSksXG4gIGRodDogb3B0aW9uYWwocygnbnVsbHxmdW5jdGlvbnxvYmplY3QnKSksXG4gIHBlZXJEaXNjb3Zlcnk6IG9wdGlvbmFsKGxpc3QoW3MoJ29iamVjdHxmdW5jdGlvbicpXSkpLFxuICBwZWVyUm91dGluZzogb3B0aW9uYWwobGlzdChbJ29iamVjdCddKSksXG4gIHN0cmVhbU11eGVyOiBvcHRpb25hbChsaXN0KFtzKCdvYmplY3R8ZnVuY3Rpb24nKV0pKSxcbiAgdHJhbnNwb3J0OiBzLmludGVyc2VjdGlvbihbW3RyYW5zcG9ydF0sIHMuaW50ZXJmYWNlKHtcbiAgICBsZW5ndGggKHYpIHtcbiAgICAgIHJldHVybiB2ID4gMCA/IHRydWUgOiAnRVJST1JfRU1QVFknXG4gICAgfVxuICB9KV0pXG59KVxuXG5jb25zdCBjb25maWdTY2hlbWEgPSBzKHtcbiAgcGVlckRpc2NvdmVyeTogcygnb2JqZWN0Jywge1xuICAgIGF1dG9EaWFsOiB0cnVlXG4gIH0pLFxuICByZWxheTogcyh7XG4gICAgZW5hYmxlZDogJ2Jvb2xlYW4nLFxuICAgIGhvcDogb3B0aW9uYWwocyh7XG4gICAgICBlbmFibGVkOiAnYm9vbGVhbicsXG4gICAgICBhY3RpdmU6ICdib29sZWFuJ1xuICAgIH0sIHtcbiAgICAgIC8vIEhPUCBkZWZhdWx0c1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBhY3RpdmU6IGZhbHNlXG4gICAgfSkpXG4gIH0sIHtcbiAgICAvLyBSZWxheSBkZWZhdWx0c1xuICAgIGVuYWJsZWQ6IHRydWVcbiAgfSksXG4gIC8vIERIVCBjb25maWdcbiAgZGh0OiBzKCdvYmplY3Q/Jywge1xuICAgIC8vIERIVCBkZWZhdWx0c1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIGtCdWNrZXRTaXplOiAyMCxcbiAgICByYW5kb21XYWxrOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSwgLy8gZGlzYWJsZWQgd2FpdGluZyBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2xpYnAycC9qcy1saWJwMnAta2FkLWRodC9pc3N1ZXMvODZcbiAgICAgIHF1ZXJpZXNQZXJQZXJpb2Q6IDEsXG4gICAgICBpbnRlcnZhbDogMzAwZTMsXG4gICAgICB0aW1lb3V0OiAxMGUzXG4gICAgfVxuICB9KSxcbiAgLy8gRXhwZXJpbWVudGFsIGNvbmZpZ1xuICBFWFBFUklNRU5UQUw6IHMoe1xuICAgIHB1YnN1YjogJ2Jvb2xlYW4nXG4gIH0sIHtcbiAgICAvLyBFeHBlcmltZW50YWwgZGVmYXVsdHNcbiAgICBwdWJzdWI6IGZhbHNlXG4gIH0pXG59LCB7fSlcblxuY29uc3Qgb3B0aW9uc1NjaGVtYSA9IHMoe1xuICBzd2l0Y2g6ICdvYmplY3Q/JyxcbiAgY29ubmVjdGlvbk1hbmFnZXI6IHMoJ29iamVjdCcsIHtcbiAgICBtaW5QZWVyczogMjVcbiAgfSksXG4gIGRhdGFzdG9yZTogJ29iamVjdD8nLFxuICBwZWVySW5mbzogJ29iamVjdCcsXG4gIHBlZXJCb29rOiAnb2JqZWN0PycsXG4gIG1vZHVsZXM6IG1vZHVsZXNTY2hlbWEsXG4gIGNvbmZpZzogY29uZmlnU2NoZW1hXG59KVxuXG5tb2R1bGUuZXhwb3J0cy52YWxpZGF0ZSA9IChvcHRzKSA9PiB7XG4gIGNvbnN0IFtlcnJvciwgb3B0aW9uc10gPSBvcHRpb25zU2NoZW1hLnZhbGlkYXRlKG9wdHMpXG5cbiAgLy8gSW1wcm92ZSBlcnJvcnMgdGhyb3dlZCwgcmVkdWNlIHN0YWNrIGJ5IHRocm93aW5nIGhlcmUgYW5kIGFkZCByZWFzb24gdG8gdGhlIG1lc3NhZ2VcbiAgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke2Vycm9yLm1lc3NhZ2V9JHtlcnJvci5yZWFzb24gPyAnIC0gJyArIGVycm9yLnJlYXNvbiA6ICcnfWApXG4gIH0gZWxzZSB7XG4gICAgLy8gVGhyb3cgd2hlbiBkaHQgaXMgZW5hYmxlZCBidXQgbm8gZGh0IG1vZHVsZSBwcm92aWRlZFxuICAgIGlmIChvcHRpb25zLmNvbmZpZy5kaHQuZW5hYmxlZCkge1xuICAgICAgcygnZnVuY3Rpb258b2JqZWN0Jykob3B0aW9ucy5tb2R1bGVzLmRodClcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5jb25maWcucGVlckRpc2NvdmVyeS5hdXRvRGlhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5jb25maWcucGVlckRpc2NvdmVyeS5hdXRvRGlhbCA9IHRydWVcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdHJ5RWFjaCA9IHJlcXVpcmUoJ2FzeW5jL3RyeUVhY2gnKVxuY29uc3QgZXJyQ29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxubW9kdWxlLmV4cG9ydHMgPSAobm9kZSkgPT4ge1xuICBjb25zdCByb3V0ZXJzID0gbm9kZS5fbW9kdWxlcy5wZWVyUm91dGluZyB8fCBbXVxuXG4gIC8vIElmIHdlIGhhdmUgdGhlIGRodCwgbWFrZSBpdCBmaXJzdFxuICBpZiAobm9kZS5fZGh0KSB7XG4gICAgcm91dGVycy51bnNoaWZ0KG5vZGUuX2RodClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhbGwgcGVlciByb3V0ZXJzIGluIHNlcmllcyB0byBmaW5kIHRoZSBnaXZlbiBwZWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBpZCBvZiB0aGUgcGVlciB0byBmaW5kXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5tYXhUaW1lb3V0IEhvdyBsb25nIHRoZSBxdWVyeSBzaG91bGQgcnVuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgUmVzdWx0PEFycmF5Pil9IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZmluZFBlZXI6IChpZCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IHt9XG4gICAgICB9XG5cbiAgICAgIGlmICghcm91dGVycy5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyQ29kZShuZXcgRXJyb3IoJ05vIHBlZXIgcm91dGVycyBhdmFpbGFibGUnKSwgJ05PX1JPVVRFUlNfQVZBSUxBQkxFJykpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhc2tzID0gcm91dGVycy5tYXAoKHJvdXRlcikgPT4ge1xuICAgICAgICByZXR1cm4gKGNiKSA9PiByb3V0ZXIuZmluZFBlZXIoaWQsIG9wdGlvbnMsIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHJlc3VsdCwgd2UgbmVlZCB0byBwcm92aWRlIGFuIGVycm9yIHRvIGtlZXAgdHJ5aW5nXG4gICAgICAgICAgaWYgKCFyZXN1bHQgfHwgT2JqZWN0LmtleXMocmVzdWx0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjYihlcnJDb2RlKG5ldyBFcnJvcignbm90IGZvdW5kJyksICdOT1RfRk9VTkQnKSwgbnVsbClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYihudWxsLCByZXN1bHQpXG4gICAgICAgIH0pXG4gICAgICB9KVxuXG4gICAgICB0cnlFYWNoKHRhc2tzLCAoZXJyLCByZXN1bHRzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG5leHRUaWNrID0gcmVxdWlyZSgnYXN5bmMvbmV4dFRpY2snKVxuY29uc3QgZXJyQ29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxuY29uc3QgeyBtZXNzYWdlcywgY29kZXMgfSA9IHJlcXVpcmUoJy4vZXJyb3JzJylcblxubW9kdWxlLmV4cG9ydHMgPSAobm9kZSkgPT4ge1xuICByZXR1cm4ge1xuICAgIHB1dDogKGtleSwgdmFsdWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAoIW5vZGUuX2RodCkge1xuICAgICAgICByZXR1cm4gbmV4dFRpY2soY2FsbGJhY2ssIGVyckNvZGUobmV3IEVycm9yKG1lc3NhZ2VzLkRIVF9ESVNBQkxFRCksIGNvZGVzLkRIVF9ESVNBQkxFRCkpXG4gICAgICB9XG5cbiAgICAgIG5vZGUuX2RodC5wdXQoa2V5LCB2YWx1ZSwgY2FsbGJhY2spXG4gICAgfSxcbiAgICBnZXQ6IChrZXksIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICAgIG9wdGlvbnMgPSB7fVxuICAgICAgfVxuXG4gICAgICBpZiAoIW5vZGUuX2RodCkge1xuICAgICAgICByZXR1cm4gbmV4dFRpY2soY2FsbGJhY2ssIGVyckNvZGUobmV3IEVycm9yKG1lc3NhZ2VzLkRIVF9ESVNBQkxFRCksIGNvZGVzLkRIVF9ESVNBQkxFRCkpXG4gICAgICB9XG5cbiAgICAgIG5vZGUuX2RodC5nZXQoa2V5LCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICB9LFxuICAgIGdldE1hbnk6IChrZXksIG5WYWxzLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgICAgICBvcHRpb25zID0ge31cbiAgICAgIH1cblxuICAgICAgaWYgKCFub2RlLl9kaHQpIHtcbiAgICAgICAgcmV0dXJuIG5leHRUaWNrKGNhbGxiYWNrLCBlcnJDb2RlKG5ldyBFcnJvcihtZXNzYWdlcy5ESFRfRElTQUJMRUQpLCBjb2Rlcy5ESFRfRElTQUJMRUQpKVxuICAgICAgfVxuXG4gICAgICBub2RlLl9kaHQuZ2V0TWFueShrZXksIG5WYWxzLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuY29uc3Qgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxuXG4vKipcbiAqIFJlZ2lzdGVycyBgaGFuZGxlcmAgdG8gZWFjaCBldmVudCBpbiBgZXZlbnRzYC4gVGhlIGBoYW5kbGVyYFxuICogd2lsbCBvbmx5IGJlIGNhbGxlZCBmb3IgdGhlIGZpcnN0IGV2ZW50IGZpcmVkLCBhdCB3aGljaCBwb2ludFxuICogdGhlIGBoYW5kbGVyYCB3aWxsIGJlIHJlbW92ZWQgYXMgYSBsaXN0ZW5lci5cbiAqXG4gKiBFbnN1cmVzIGBoYW5kbGVyYCBpcyBvbmx5IGNhbGxlZCBvbmNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyB3aWxsIGNhbGwgYGNhbGxiYWNrYCB3aGVuIGBzdGFydGAgb3IgYGVycm9yYCBpcyBlbWl0dGVkIGJ5IGB0aGlzYFxuICogZW1pdEZpcnN0KHRoaXMsIFsnZXJyb3InLCAnc3RhcnQnXSwgY2FsbGJhY2spXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFRoZSBlbWl0dGVyIHRvIGxpc3RlbiBvblxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBldmVudHMgVGhlIGV2ZW50cyB0byBsaXN0ZW4gZm9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCopfSBoYW5kbGVyIFRoZSBoYW5kbGVyIHRvIGNhbGwgd2hlbiBhbiBldmVudCBpcyB0cmlnZ2VyZWRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBlbWl0Rmlyc3QgKGVtaXR0ZXIsIGV2ZW50cywgaGFuZGxlcikge1xuICBoYW5kbGVyID0gb25jZShoYW5kbGVyKVxuICBldmVudHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgIGVtaXR0ZXIub25jZShlLCAoLi4uYXJncykgPT4ge1xuICAgICAgZXZlbnRzLmZvckVhY2goKGV2KSA9PiB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoZXYsIGhhbmRsZXIpXG4gICAgICB9KVxuICAgICAgaGFuZGxlci5hcHBseShlbWl0dGVyLCBhcmdzKVxuICAgIH0pXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzLmVtaXRGaXJzdCA9IGVtaXRGaXJzdFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHRyeUVhY2ggPSByZXF1aXJlKCdhc3luYy90cnlFYWNoJylcbmNvbnN0IHBhcmFsbGVsID0gcmVxdWlyZSgnYXN5bmMvcGFyYWxsZWwnKVxuY29uc3QgZXJyQ29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxubW9kdWxlLmV4cG9ydHMgPSAobm9kZSkgPT4ge1xuICBjb25zdCByb3V0ZXJzID0gbm9kZS5fbW9kdWxlcy5jb250ZW50Um91dGluZyB8fCBbXVxuXG4gIC8vIElmIHdlIGhhdmUgdGhlIGRodCwgbWFrZSBpdCBmaXJzdFxuICBpZiAobm9kZS5fZGh0KSB7XG4gICAgcm91dGVycy51bnNoaWZ0KG5vZGUuX2RodClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhbGwgY29udGVudCByb3V0ZXJzIGluIHNlcmllcyB0byBmaW5kIHByb3ZpZGVycyBvZiB0aGUgZ2l2ZW4ga2V5LlxuICAgICAqIE9uY2UgYSBjb250ZW50IHJvdXRlciBzdWNjZWVkcywgaXRlcmF0aW9uIHdpbGwgc3RvcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q0lEfSBrZXkgVGhlIENJRCBrZXkgb2YgdGhlIGNvbnRlbnQgdG8gZmluZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubWF4VGltZW91dCBIb3cgbG9uZyB0aGUgcXVlcnkgc2hvdWxkIHJ1blxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1heE51bVByb3ZpZGVycyAtIG1heGltdW0gbnVtYmVyIG9mIHByb3ZpZGVycyB0byBmaW5kXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgUmVzdWx0PEFycmF5Pil9IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZmluZFByb3ZpZGVyczogKGtleSwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IHt9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykgeyAvLyBUaGlzIGNhbiBiZSBkZXByZWNhdGVkIGluIGEgZnV0dXJlIHJlbGVhc2VcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICBtYXhUaW1lb3V0OiBvcHRpb25zXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFyb3V0ZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyQ29kZShuZXcgRXJyb3IoJ05vIGNvbnRlbnQgcm91dGVycyBhdmFpbGFibGUnKSwgJ05PX1JPVVRFUlNfQVZBSUxBQkxFJykpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhc2tzID0gcm91dGVycy5tYXAoKHJvdXRlcikgPT4ge1xuICAgICAgICByZXR1cm4gKGNiKSA9PiByb3V0ZXIuZmluZFByb3ZpZGVycyhrZXksIG9wdGlvbnMsIChlcnIsIHJlc3VsdHMpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IHJlc3VsdHMsIHdlIG5lZWQgdG8gcHJvdmlkZSBhbiBlcnJvciB0byBrZWVwIHRyeWluZ1xuICAgICAgICAgIGlmICghcmVzdWx0cyB8fCBPYmplY3Qua2V5cyhyZXN1bHRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjYihlcnJDb2RlKG5ldyBFcnJvcignbm90IGZvdW5kJyksICdOT1RfRk9VTkQnKSwgbnVsbClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYihudWxsLCByZXN1bHRzKVxuICAgICAgICB9KVxuICAgICAgfSlcblxuICAgICAgdHJ5RWFjaCh0YXNrcywgKGVyciwgcmVzdWx0cykgPT4ge1xuICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlICE9PSAnTk9UX0ZPVU5EJykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW11cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0cylcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgYWxsIGNvbnRlbnQgcm91dGVycyBpbiBwYXJhbGxlbCB0byBub3RpZnkgaXQgaXNcbiAgICAgKiBhIHByb3ZpZGVyIG9mIHRoZSBnaXZlbiBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NJRH0ga2V5IFRoZSBDSUQga2V5IG9mIHRoZSBjb250ZW50IHRvIGZpbmRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBwcm92aWRlOiAoa2V5LCBjYWxsYmFjaykgPT4ge1xuICAgICAgaWYgKCFyb3V0ZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyQ29kZShuZXcgRXJyb3IoJ05vIGNvbnRlbnQgcm91dGVycyBhdmFpbGFibGUnKSwgJ05PX1JPVVRFUlNfQVZBSUxBQkxFJykpXG4gICAgICB9XG5cbiAgICAgIHBhcmFsbGVsKHJvdXRlcnMubWFwKChyb3V0ZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIChjYikgPT4gcm91dGVyLnByb3ZpZGUoa2V5LCBjYilcbiAgICAgIH0pLCBjYWxsYmFjaylcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBoYW5kbGVyID0gcmVxdWlyZSgnLi9oYW5kbGVyJylcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9waW5nJylcbmV4cG9ydHMubW91bnQgPSBoYW5kbGVyLm1vdW50XG5leHBvcnRzLnVubW91bnQgPSBoYW5kbGVyLnVubW91bnRcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBuZXh0VGljayA9IHJlcXVpcmUoJ2FzeW5jL25leHRUaWNrJylcbmNvbnN0IHsgbWVzc2FnZXMsIGNvZGVzIH0gPSByZXF1aXJlKCcuL2Vycm9ycycpXG5jb25zdCBGbG9vZFN1YiA9IHJlcXVpcmUoJ2xpYnAycC1mbG9vZHN1YicpXG5cbmNvbnN0IGVyckNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5cbm1vZHVsZS5leHBvcnRzID0gKG5vZGUpID0+IHtcbiAgY29uc3QgZmxvb2RTdWIgPSBuZXcgRmxvb2RTdWIobm9kZSlcblxuICBub2RlLl9mbG9vZFN1YiA9IGZsb29kU3ViXG5cbiAgcmV0dXJuIHtcbiAgICBzdWJzY3JpYmU6ICh0b3BpYywgb3B0aW9ucywgaGFuZGxlciwgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IGhhbmRsZXJcbiAgICAgICAgaGFuZGxlciA9IG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IHt9XG4gICAgICB9XG5cbiAgICAgIGlmICghbm9kZS5pc1N0YXJ0ZWQoKSAmJiAhZmxvb2RTdWIuc3RhcnRlZCkge1xuICAgICAgICByZXR1cm4gbmV4dFRpY2soY2FsbGJhY2ssIGVyckNvZGUobmV3IEVycm9yKG1lc3NhZ2VzLk5PVF9TVEFSVEVEX1lFVCksIGNvZGVzLlBVQlNVQl9OT1RfU1RBUlRFRCkpXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHN1YnNjcmliZSAoY2IpIHtcbiAgICAgICAgaWYgKGZsb29kU3ViLmxpc3RlbmVyQ291bnQodG9waWMpID09PSAwKSB7XG4gICAgICAgICAgZmxvb2RTdWIuc3Vic2NyaWJlKHRvcGljKVxuICAgICAgICB9XG5cbiAgICAgICAgZmxvb2RTdWIub24odG9waWMsIGhhbmRsZXIpXG4gICAgICAgIG5leHRUaWNrKGNiKVxuICAgICAgfVxuXG4gICAgICBzdWJzY3JpYmUoY2FsbGJhY2spXG4gICAgfSxcblxuICAgIHVuc3Vic2NyaWJlOiAodG9waWMsIGhhbmRsZXIsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAoIW5vZGUuaXNTdGFydGVkKCkgJiYgIWZsb29kU3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgcmV0dXJuIG5leHRUaWNrKGNhbGxiYWNrLCBlcnJDb2RlKG5ldyBFcnJvcihtZXNzYWdlcy5OT1RfU1RBUlRFRF9ZRVQpLCBjb2Rlcy5QVUJTVUJfTk9UX1NUQVJURUQpKVxuICAgICAgfVxuICAgICAgaWYgKCFoYW5kbGVyICYmICFjYWxsYmFjaykge1xuICAgICAgICBmbG9vZFN1Yi5yZW1vdmVBbGxMaXN0ZW5lcnModG9waWMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbG9vZFN1Yi5yZW1vdmVMaXN0ZW5lcih0b3BpYywgaGFuZGxlcilcbiAgICAgIH1cblxuICAgICAgaWYgKGZsb29kU3ViLmxpc3RlbmVyQ291bnQodG9waWMpID09PSAwKSB7XG4gICAgICAgIGZsb29kU3ViLnVuc3Vic2NyaWJlKHRvcGljKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG5leHRUaWNrKCgpID0+IGNhbGxiYWNrKCkpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHB1Ymxpc2g6ICh0b3BpYywgZGF0YSwgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICghbm9kZS5pc1N0YXJ0ZWQoKSAmJiAhZmxvb2RTdWIuc3RhcnRlZCkge1xuICAgICAgICByZXR1cm4gbmV4dFRpY2soY2FsbGJhY2ssIGVyckNvZGUobmV3IEVycm9yKG1lc3NhZ2VzLk5PVF9TVEFSVEVEX1lFVCksIGNvZGVzLlBVQlNVQl9OT1RfU1RBUlRFRCkpXG4gICAgICB9XG5cbiAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBuZXh0VGljayhjYWxsYmFjaywgZXJyQ29kZShuZXcgRXJyb3IoJ2RhdGEgbXVzdCBiZSBhIEJ1ZmZlcicpLCAnRVJSX0RBVEFfSVNfTk9UX0FfQlVGRkVSJykpXG4gICAgICB9XG5cbiAgICAgIGZsb29kU3ViLnB1Ymxpc2godG9waWMsIGRhdGEsIGNhbGxiYWNrKVxuICAgIH0sXG5cbiAgICBsczogKGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAoIW5vZGUuaXNTdGFydGVkKCkgJiYgIWZsb29kU3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgcmV0dXJuIG5leHRUaWNrKGNhbGxiYWNrLCBlcnJDb2RlKG5ldyBFcnJvcihtZXNzYWdlcy5OT1RfU1RBUlRFRF9ZRVQpLCBjb2Rlcy5QVUJTVUJfTk9UX1NUQVJURUQpKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gQXJyYXkuZnJvbShmbG9vZFN1Yi5zdWJzY3JpcHRpb25zKVxuXG4gICAgICBuZXh0VGljaygoKSA9PiBjYWxsYmFjayhudWxsLCBzdWJzY3JpcHRpb25zKSlcbiAgICB9LFxuXG4gICAgcGVlcnM6ICh0b3BpYywgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICghbm9kZS5pc1N0YXJ0ZWQoKSAmJiAhZmxvb2RTdWIuc3RhcnRlZCkge1xuICAgICAgICByZXR1cm4gbmV4dFRpY2soY2FsbGJhY2ssIGVyckNvZGUobmV3IEVycm9yKG1lc3NhZ2VzLk5PVF9TVEFSVEVEX1lFVCksIGNvZGVzLlBVQlNVQl9OT1RfU1RBUlRFRCkpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdG9waWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB0b3BpY1xuICAgICAgICB0b3BpYyA9IG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGVlcnMgPSBBcnJheS5mcm9tKGZsb29kU3ViLnBlZXJzLnZhbHVlcygpKVxuICAgICAgICAuZmlsdGVyKChwZWVyKSA9PiB0b3BpYyA/IHBlZXIudG9waWNzLmhhcyh0b3BpYykgOiB0cnVlKVxuICAgICAgICAubWFwKChwZWVyKSA9PiBwZWVyLmluZm8uaWQudG9CNThTdHJpbmcoKSlcblxuICAgICAgbmV4dFRpY2soKCkgPT4gY2FsbGJhY2sobnVsbCwgcGVlcnMpKVxuICAgIH0sXG5cbiAgICBzZXRNYXhMaXN0ZW5lcnMgKG4pIHtcbiAgICAgIHJldHVybiBmbG9vZFN1Yi5zZXRNYXhMaXN0ZW5lcnMobilcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKVxuY29uc3QgTGF0ZW5jeU1vbml0b3IgPSByZXF1aXJlKCdsYXRlbmN5LW1vbml0b3InKS5kZWZhdWx0XG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2xpYnAycDpjb25uZWN0aW9uLW1hbmFnZXInKVxuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgbWF4UGVlcnM6IEluZmluaXR5LFxuICBtaW5QZWVyczogMCxcbiAgbWF4RGF0YTogSW5maW5pdHksXG4gIG1heFNlbnREYXRhOiBJbmZpbml0eSxcbiAgbWF4UmVjZWl2ZWREYXRhOiBJbmZpbml0eSxcbiAgbWF4RXZlbnRMb29wRGVsYXk6IEluZmluaXR5LFxuICBwb2xsSW50ZXJ2YWw6IDIwMDAsXG4gIG1vdmluZ0F2ZXJhZ2VJbnRlcnZhbDogNjAwMDAsXG4gIGRlZmF1bHRQZWVyVmFsdWU6IDFcbn1cblxuY2xhc3MgQ29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAobGlicDJwLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2xpYnAycCA9IGxpYnAycFxuICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucylcbiAgICB0aGlzLl9vcHRpb25zLm1heFBlZXJzUGVyUHJvdG9jb2wgPSBmaXhNYXhQZWVyc1BlclByb3RvY29sKHRoaXMuX29wdGlvbnMubWF4UGVlcnNQZXJQcm90b2NvbClcblxuICAgIGRlYnVnKCdvcHRpb25zOiAlaicsIHRoaXMuX29wdGlvbnMpXG5cbiAgICB0aGlzLl9zdGF0cyA9IGxpYnAycC5zdGF0c1xuICAgIGlmIChvcHRpb25zICYmICF0aGlzLl9zdGF0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBsaWJwMnAuc3RhdHMnKVxuICAgIH1cblxuICAgIHRoaXMuX3BlZXJWYWx1ZXMgPSBuZXcgTWFwKClcbiAgICB0aGlzLl9wZWVycyA9IG5ldyBNYXAoKVxuICAgIHRoaXMuX3BlZXJQcm90b2NvbHMgPSBuZXcgTWFwKClcbiAgICB0aGlzLl9wZWVyQ291bnRQZXJQcm90b2NvbCA9IG5ldyBNYXAoKVxuICAgIHRoaXMuX29uU3RhdHNVcGRhdGUgPSB0aGlzLl9vblN0YXRzVXBkYXRlLmJpbmQodGhpcylcbiAgICB0aGlzLl9vblBlZXJDb25uZWN0ID0gdGhpcy5fb25QZWVyQ29ubmVjdC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fb25QZWVyRGlzY29ubmVjdCA9IHRoaXMuX29uUGVlckRpc2Nvbm5lY3QuYmluZCh0aGlzKVxuXG4gICAgaWYgKHRoaXMuX2xpYnAycC5pc1N0YXJ0ZWQoKSkge1xuICAgICAgdGhpcy5fb25jZVN0YXJ0ZWQoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9saWJwMnAub25jZSgnc3RhcnQnLCB0aGlzLl9vbmNlU3RhcnRlZC5iaW5kKHRoaXMpKVxuICAgIH1cbiAgfVxuXG4gIHN0YXJ0ICgpIHtcbiAgICB0aGlzLl9zdGF0cy5vbigndXBkYXRlJywgdGhpcy5fb25TdGF0c1VwZGF0ZSlcbiAgICB0aGlzLl9saWJwMnAub24oJ2Nvbm5lY3Rpb246c3RhcnQnLCB0aGlzLl9vblBlZXJDb25uZWN0KVxuICAgIHRoaXMuX2xpYnAycC5vbignY29ubmVjdGlvbjplbmQnLCB0aGlzLl9vblBlZXJEaXNjb25uZWN0KVxuICAgIC8vIGxhdGVuY3kgbW9uaXRvclxuICAgIHRoaXMuX2xhdGVuY3lNb25pdG9yID0gbmV3IExhdGVuY3lNb25pdG9yKHtcbiAgICAgIGRhdGFFbWl0SW50ZXJ2YWxNczogdGhpcy5fb3B0aW9ucy5wb2xsSW50ZXJ2YWxcbiAgICB9KVxuICAgIHRoaXMuX29uTGF0ZW5jeU1lYXN1cmUgPSB0aGlzLl9vbkxhdGVuY3lNZWFzdXJlLmJpbmQodGhpcylcbiAgICB0aGlzLl9sYXRlbmN5TW9uaXRvci5vbignZGF0YScsIHRoaXMuX29uTGF0ZW5jeU1lYXN1cmUpXG4gIH1cblxuICBzdG9wICgpIHtcbiAgICB0aGlzLl9zdGF0cy5yZW1vdmVMaXN0ZW5lcigndXBkYXRlJywgdGhpcy5fb25TdGF0c1VwZGF0ZSlcbiAgICB0aGlzLl9saWJwMnAucmVtb3ZlTGlzdGVuZXIoJ2Nvbm5lY3Rpb246c3RhcnQnLCB0aGlzLl9vblBlZXJDb25uZWN0KVxuICAgIHRoaXMuX2xpYnAycC5yZW1vdmVMaXN0ZW5lcignY29ubmVjdGlvbjplbmQnLCB0aGlzLl9vblBlZXJEaXNjb25uZWN0KVxuICAgIHRoaXMuX2xhdGVuY3lNb25pdG9yLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgdGhpcy5fb25MYXRlbmN5TWVhc3VyZSlcbiAgfVxuXG4gIHNldFBlZXJWYWx1ZSAocGVlcklkLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIHNob3VsZCBiZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEnKVxuICAgIH1cbiAgICBpZiAocGVlcklkLnRvQjU4U3RyaW5nKSB7XG4gICAgICBwZWVySWQgPSBwZWVySWQudG9CNThTdHJpbmcoKVxuICAgIH1cbiAgICB0aGlzLl9wZWVyVmFsdWVzLnNldChwZWVySWQsIHZhbHVlKVxuICB9XG5cbiAgX29uY2VTdGFydGVkICgpIHtcbiAgICB0aGlzLl9wZWVySWQgPSB0aGlzLl9saWJwMnAucGVlckluZm8uaWQudG9CNThTdHJpbmcoKVxuICB9XG5cbiAgX29uU3RhdHNVcGRhdGUgKCkge1xuICAgIGNvbnN0IG1vdmluZ0F2Z3MgPSB0aGlzLl9zdGF0cy5nbG9iYWwubW92aW5nQXZlcmFnZXNcbiAgICBjb25zdCByZWNlaXZlZCA9IG1vdmluZ0F2Z3MuZGF0YVJlY2VpdmVkW3RoaXMuX29wdGlvbnMubW92aW5nQXZlcmFnZUludGVydmFsXS5tb3ZpbmdBdmVyYWdlKClcbiAgICB0aGlzLl9jaGVja0xpbWl0KCdtYXhSZWNlaXZlZERhdGEnLCByZWNlaXZlZClcbiAgICBjb25zdCBzZW50ID0gbW92aW5nQXZncy5kYXRhU2VudFt0aGlzLl9vcHRpb25zLm1vdmluZ0F2ZXJhZ2VJbnRlcnZhbF0ubW92aW5nQXZlcmFnZSgpXG4gICAgdGhpcy5fY2hlY2tMaW1pdCgnbWF4U2VudERhdGEnLCBzZW50KVxuICAgIGNvbnN0IHRvdGFsID0gcmVjZWl2ZWQgKyBzZW50XG4gICAgdGhpcy5fY2hlY2tMaW1pdCgnbWF4RGF0YScsIHRvdGFsKVxuICAgIGRlYnVnKCdzdGF0cyB1cGRhdGUnLCB0b3RhbClcbiAgfVxuXG4gIF9vblBlZXJDb25uZWN0IChwZWVySW5mbykge1xuICAgIGNvbnN0IHBlZXJJZCA9IHBlZXJJbmZvLmlkLnRvQjU4U3RyaW5nKClcbiAgICBkZWJ1ZygnJXM6IGNvbm5lY3RlZCB0byAlcycsIHRoaXMuX3BlZXJJZCwgcGVlcklkKVxuICAgIHRoaXMuX3BlZXJWYWx1ZXMuc2V0KHBlZXJJZCwgdGhpcy5fb3B0aW9ucy5kZWZhdWx0UGVlclZhbHVlKVxuICAgIHRoaXMuX3BlZXJzLnNldChwZWVySWQsIHBlZXJJbmZvKVxuICAgIHRoaXMuZW1pdCgnY29ubmVjdGVkJywgcGVlcklkKVxuICAgIHRoaXMuX2NoZWNrTGltaXQoJ21heFBlZXJzJywgdGhpcy5fcGVlcnMuc2l6ZSlcblxuICAgIHByb3RvY29sc0Zyb21QZWVySW5mbyhwZWVySW5mbykuZm9yRWFjaCgocHJvdG9jb2xUYWcpID0+IHtcbiAgICAgIGNvbnN0IHByb3RvY29sID0gdGhpcy5fcGVlckNvdW50UGVyUHJvdG9jb2xbcHJvdG9jb2xUYWddXG4gICAgICBpZiAoIXByb3RvY29sKSB7XG4gICAgICAgIHRoaXMuX3BlZXJDb3VudFBlclByb3RvY29sW3Byb3RvY29sVGFnXSA9IDBcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BlZXJDb3VudFBlclByb3RvY29sW3Byb3RvY29sVGFnXSsrXG5cbiAgICAgIGxldCBwZWVyUHJvdG9jb2xzID0gdGhpcy5fcGVlclByb3RvY29sc1twZWVySWRdXG4gICAgICBpZiAoIXBlZXJQcm90b2NvbHMpIHtcbiAgICAgICAgcGVlclByb3RvY29scyA9IHRoaXMuX3BlZXJQcm90b2NvbHNbcGVlcklkXSA9IG5ldyBTZXQoKVxuICAgICAgfVxuICAgICAgcGVlclByb3RvY29scy5hZGQocHJvdG9jb2xUYWcpXG4gICAgICB0aGlzLl9jaGVja1Byb3RvY29sTWF4UGVlcnNMaW1pdChwcm90b2NvbFRhZywgdGhpcy5fcGVlckNvdW50UGVyUHJvdG9jb2xbcHJvdG9jb2xUYWddKVxuICAgIH0pXG4gIH1cblxuICBfb25QZWVyRGlzY29ubmVjdCAocGVlckluZm8pIHtcbiAgICBjb25zdCBwZWVySWQgPSBwZWVySW5mby5pZC50b0I1OFN0cmluZygpXG4gICAgZGVidWcoJyVzOiBkaXNjb25uZWN0ZWQgZnJvbSAlcycsIHRoaXMuX3BlZXJJZCwgcGVlcklkKVxuICAgIHRoaXMuX3BlZXJWYWx1ZXMuZGVsZXRlKHBlZXJJZClcbiAgICB0aGlzLl9wZWVycy5kZWxldGUocGVlcklkKVxuXG4gICAgY29uc3QgcGVlclByb3RvY29scyA9IHRoaXMuX3BlZXJQcm90b2NvbHNbcGVlcklkXVxuICAgIGlmIChwZWVyUHJvdG9jb2xzKSB7XG4gICAgICBBcnJheS5mcm9tKHBlZXJQcm90b2NvbHMpLmZvckVhY2goKHByb3RvY29sVGFnKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlZXJDb3VudEZvclByb3RvY29sID0gdGhpcy5fcGVlckNvdW50UGVyUHJvdG9jb2xbcHJvdG9jb2xUYWddXG4gICAgICAgIGlmIChwZWVyQ291bnRGb3JQcm90b2NvbCkge1xuICAgICAgICAgIHRoaXMuX3BlZXJDb3VudFBlclByb3RvY29sW3Byb3RvY29sVGFnXS0tXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdkaXNjb25uZWN0ZWQnLCBwZWVySWQpXG4gIH1cblxuICBfb25MYXRlbmN5TWVhc3VyZSAoc3VtbWFyeSkge1xuICAgIHRoaXMuX2NoZWNrTGltaXQoJ21heEV2ZW50TG9vcERlbGF5Jywgc3VtbWFyeS5hdmdNcylcbiAgfVxuXG4gIF9jaGVja0xpbWl0IChuYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IGxpbWl0ID0gdGhpcy5fb3B0aW9uc1tuYW1lXVxuICAgIGRlYnVnKCdjaGVja2luZyBsaW1pdCBvZiAlcy4gY3VycmVudCB2YWx1ZTogJWQgb2YgJWQnLCBuYW1lLCB2YWx1ZSwgbGltaXQpXG4gICAgaWYgKHZhbHVlID4gbGltaXQpIHtcbiAgICAgIGRlYnVnKCclczogbGltaXQgZXhjZWVkZWQ6ICVzLCAlZCcsIHRoaXMuX3BlZXJJZCwgbmFtZSwgdmFsdWUpXG4gICAgICB0aGlzLmVtaXQoJ2xpbWl0OmV4Y2VlZGVkJywgbmFtZSwgdmFsdWUpXG4gICAgICB0aGlzLl9tYXliZURpc2Nvbm5lY3RPbmUoKVxuICAgIH1cbiAgfVxuXG4gIF9jaGVja1Byb3RvY29sTWF4UGVlcnNMaW1pdCAocHJvdG9jb2xUYWcsIHZhbHVlKSB7XG4gICAgZGVidWcoJ2NoZWNraW5nIHByb3RvY29sIGxpbWl0LiBjdXJyZW50IHZhbHVlIG9mICVzIGlzICVkJywgcHJvdG9jb2xUYWcsIHZhbHVlKVxuICAgIGNvbnN0IGxpbWl0ID0gdGhpcy5fb3B0aW9ucy5tYXhQZWVyc1BlclByb3RvY29sW3Byb3RvY29sVGFnXVxuICAgIGlmICh2YWx1ZSA+IGxpbWl0KSB7XG4gICAgICBkZWJ1ZygnJXM6IHByb3RvY29sIG1heCBwZWVycyBsaW1pdCBleGNlZWRlZDogJXMsICVkJywgdGhpcy5fcGVlcklkLCBwcm90b2NvbFRhZywgdmFsdWUpXG4gICAgICB0aGlzLmVtaXQoJ2xpbWl0OmV4Y2VlZGVkJywgcHJvdG9jb2xUYWcsIHZhbHVlKVxuICAgICAgdGhpcy5fbWF5YmVEaXNjb25uZWN0T25lKClcbiAgICB9XG4gIH1cblxuICBfbWF5YmVEaXNjb25uZWN0T25lICgpIHtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5taW5QZWVycyA8IHRoaXMuX3BlZXJWYWx1ZXMuc2l6ZSkge1xuICAgICAgY29uc3QgcGVlclZhbHVlcyA9IEFycmF5LmZyb20odGhpcy5fcGVlclZhbHVlcykuc29ydChieVBlZXJWYWx1ZSlcbiAgICAgIGRlYnVnKCclczogc29ydGVkIHBlZXIgdmFsdWVzOiAlaicsIHRoaXMuX3BlZXJJZCwgcGVlclZhbHVlcylcbiAgICAgIGNvbnN0IGRpc2Nvbm5lY3RQZWVyID0gcGVlclZhbHVlc1swXVxuICAgICAgaWYgKGRpc2Nvbm5lY3RQZWVyKSB7XG4gICAgICAgIGNvbnN0IHBlZXJJZCA9IGRpc2Nvbm5lY3RQZWVyWzBdXG4gICAgICAgIGRlYnVnKCclczogbG93ZXN0IHZhbHVlIHBlZXIgaXMgJXMnLCB0aGlzLl9wZWVySWQsIHBlZXJJZClcbiAgICAgICAgZGVidWcoJyVzOiBmb3JjaW5nIGRpc2Nvbm5lY3Rpb24gZnJvbSAlaicsIHRoaXMuX3BlZXJJZCwgcGVlcklkKVxuICAgICAgICB0aGlzLl9kaXNjb25uZWN0UGVlcihwZWVySWQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2Rpc2Nvbm5lY3RQZWVyIChwZWVySWQpIHtcbiAgICBkZWJ1ZygncHJlZW1wdGl2ZWx5IGRpc2Nvbm5lY3RpbmcgcGVlcicsIHBlZXJJZClcbiAgICB0aGlzLmVtaXQoJyVzOiBkaXNjb25uZWN0OnByZWVtcHRpdmUnLCB0aGlzLl9wZWVySWQsIHBlZXJJZClcbiAgICBjb25zdCBwZWVyID0gdGhpcy5fcGVlcnMuZ2V0KHBlZXJJZClcbiAgICB0aGlzLl9saWJwMnAuaGFuZ1VwKHBlZXIsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbk1hbmFnZXJcblxuZnVuY3Rpb24gYnlQZWVyVmFsdWUgKHBlZXJWYWx1ZUVudHJ5QSwgcGVlclZhbHVlRW50cnlCKSB7XG4gIHJldHVybiBwZWVyVmFsdWVFbnRyeUFbMV0gLSBwZWVyVmFsdWVFbnRyeUJbMV1cbn1cblxuZnVuY3Rpb24gZml4TWF4UGVlcnNQZXJQcm90b2NvbCAobWF4UGVlcnNQZXJQcm90b2NvbCkge1xuICBpZiAoIW1heFBlZXJzUGVyUHJvdG9jb2wpIHtcbiAgICBtYXhQZWVyc1BlclByb3RvY29sID0ge31cbiAgfVxuXG4gIE9iamVjdC5rZXlzKG1heFBlZXJzUGVyUHJvdG9jb2wpLmZvckVhY2goKHRyYW5zcG9ydFRhZykgPT4ge1xuICAgIGNvbnN0IG1heCA9IG1heFBlZXJzUGVyUHJvdG9jb2xbdHJhbnNwb3J0VGFnXVxuICAgIGRlbGV0ZSBtYXhQZWVyc1BlclByb3RvY29sW3RyYW5zcG9ydFRhZ11cbiAgICBtYXhQZWVyc1BlclByb3RvY29sW3RyYW5zcG9ydFRhZy50b0xvd2VyQ2FzZSgpXSA9IG1heFxuICB9KVxuXG4gIHJldHVybiBtYXhQZWVyc1BlclByb3RvY29sXG59XG5cbmZ1bmN0aW9uIHByb3RvY29sc0Zyb21QZWVySW5mbyAocGVlckluZm8pIHtcbiAgY29uc3QgcHJvdG9jb2xUYWdzID0gbmV3IFNldCgpXG4gIHBlZXJJbmZvLm11bHRpYWRkcnMuZm9yRWFjaCgobXVsdGlhZGRyKSA9PiB7XG4gICAgbXVsdGlhZGRyLnByb3RvcygpLm1hcChwcm90b2NvbFRvUHJvdG9jb2xUYWcpLmZvckVhY2goKHByb3RvY29sVGFnKSA9PiB7XG4gICAgICBwcm90b2NvbFRhZ3MuYWRkKHByb3RvY29sVGFnKVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIEFycmF5LmZyb20ocHJvdG9jb2xUYWdzKVxufVxuXG5mdW5jdGlvbiBwcm90b2NvbFRvUHJvdG9jb2xUYWcgKHByb3RvY29sKSB7XG4gIHJldHVybiBwcm90b2NvbC5uYW1lLnRvTG93ZXJDYXNlKClcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBGU00gPSByZXF1aXJlKCdmc20tZXZlbnQnKVxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5jb25zdCBlYWNoID0gcmVxdWlyZSgnYXN5bmMvZWFjaCcpXG5jb25zdCBlYWNoU2VyaWVzID0gcmVxdWlyZSgnYXN5bmMvZWFjaFNlcmllcycpXG5jb25zdCBzZXJpZXMgPSByZXF1aXJlKCdhc3luYy9zZXJpZXMnKVxuY29uc3QgQ2lyY3VpdCA9IHJlcXVpcmUoJ2xpYnAycC1jaXJjdWl0JylcbmNvbnN0IFRyYW5zcG9ydE1hbmFnZXIgPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpXG5jb25zdCBDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbi9tYW5hZ2VyJylcbmNvbnN0IGdldFBlZXJJbmZvID0gcmVxdWlyZSgnLi9nZXQtcGVlci1pbmZvJylcbmNvbnN0IGdldERpYWxlciA9IHJlcXVpcmUoJy4vZGlhbGVyJylcbmNvbnN0IGNvbm5lY3Rpb25IYW5kbGVyID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uL2hhbmRsZXInKVxuY29uc3QgUHJvdG9jb2xNdXhlciA9IHJlcXVpcmUoJy4vcHJvdG9jb2wtbXV4ZXInKVxuY29uc3QgcGxhaW50ZXh0ID0gcmVxdWlyZSgnLi9wbGFpbnRleHQnKVxuY29uc3QgT2JzZXJ2ZXIgPSByZXF1aXJlKCcuL29ic2VydmVyJylcbmNvbnN0IFN0YXRzID0gcmVxdWlyZSgnLi9zdGF0cycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpXG5jb25zdCBsb2cgPSBkZWJ1ZygnbGlicDJwOnN3aXRjaCcpXG5sb2cuZXJyb3IgPSBkZWJ1ZygnbGlicDJwOnN3aXRjaDplcnJvcicpXG5cbi8qKlxuICogQGZpcmVzIFN3aXRjaCNzdG9wIFRyaWdnZXJlZCB3aGVuIHRoZSBzd2l0Y2ggaGFzIHN0b3BwZWRcbiAqIEBmaXJlcyBTd2l0Y2gjc3RhcnQgVHJpZ2dlcmVkIHdoZW4gdGhlIHN3aXRjaCBoYXMgc3RhcnRlZFxuICogQGZpcmVzIFN3aXRjaCNlcnJvciBUcmlnZ2VyZWQgd2hlbmV2ZXIgYW4gZXJyb3Igb2NjdXJzXG4gKi9cbmNsYXNzIFN3aXRjaCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChwZWVySW5mbywgcGVlckJvb2ssIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpXG4gICAgYXNzZXJ0KHBlZXJJbmZvLCAnWW91IG11c3QgcHJvdmlkZSBhIGBwZWVySW5mb2AnKVxuICAgIGFzc2VydChwZWVyQm9vaywgJ1lvdSBtdXN0IHByb3ZpZGUgYSBgcGVlckJvb2tgJylcblxuICAgIHRoaXMuX3BlZXJJbmZvID0gcGVlckluZm9cbiAgICB0aGlzLl9wZWVyQm9vayA9IHBlZXJCb29rXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKEluZmluaXR5KVxuICAgIC8vIHRyYW5zcG9ydHMgLS1cbiAgICAvLyB7IGtleTogdHJhbnNwb3J0IH07IGUuZyB7IHRjcDogPHRjcD4gfVxuICAgIHRoaXMudHJhbnNwb3J0cyA9IHt9XG5cbiAgICAvLyBjb25uZWN0aW9ucyAtLVxuICAgIC8vIHsgcGVlcklkQjU4OiB7IGNvbm46IDxjb25uPiB9fVxuICAgIHRoaXMuY29ubnMgPSB7fVxuXG4gICAgLy8geyBwcm90b2NvbDogaGFuZGxlciB9XG4gICAgdGhpcy5wcm90b2NvbHMgPSB7fVxuXG4gICAgLy8geyBtdXhlckNvZGVjOiA8bXV4ZXI+IH0gZS5nIHsgJy9zcGR5LzAuMy4xJzogc3BkeSB9XG4gICAgdGhpcy5tdXhlcnMgPSB7fVxuXG4gICAgLy8gaXMgdGhlIElkZW50aWZ5IHByb3RvY29sIGVuYWJsZWQ/XG4gICAgdGhpcy5pZGVudGlmeSA9IGZhbHNlXG5cbiAgICAvLyBDcnlwdG8gZGV0YWlsc1xuICAgIHRoaXMuY3J5cHRvID0gcGxhaW50ZXh0XG5cbiAgICB0aGlzLnByb3RlY3RvciA9IHRoaXMuX29wdGlvbnMucHJvdGVjdG9yIHx8IG51bGxcblxuICAgIHRoaXMudHJhbnNwb3J0ID0gbmV3IFRyYW5zcG9ydE1hbmFnZXIodGhpcylcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbk1hbmFnZXIodGhpcylcblxuICAgIHRoaXMub2JzZXJ2ZXIgPSBPYnNlcnZlcih0aGlzKVxuICAgIHRoaXMuc3RhdHMgPSBTdGF0cyh0aGlzLm9ic2VydmVyLCB0aGlzLl9vcHRpb25zLnN0YXRzKVxuICAgIHRoaXMucHJvdG9jb2xNdXhlciA9IFByb3RvY29sTXV4ZXIodGhpcy5wcm90b2NvbHMsIHRoaXMub2JzZXJ2ZXIpXG5cbiAgICAvLyBBbGwgcHVycG9zZSBjb25uZWN0aW9uIGhhbmRsZXIgZm9yIG1hbmFnaW5nIGluY29taW5nIGNvbm5lY3Rpb25zXG4gICAgdGhpcy5fY29ubmVjdGlvbkhhbmRsZXIgPSBjb25uZWN0aW9uSGFuZGxlcih0aGlzKVxuXG4gICAgLy8gU2V0dXAgdGhlIGludGVybmFsIHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IG5ldyBGU00oJ1NUT1BQRUQnLCB7XG4gICAgICBTVE9QUEVEOiB7XG4gICAgICAgIHN0YXJ0OiAnU1RBUlRJTkcnLFxuICAgICAgICBzdG9wOiAnU1RPUFBJTkcnIC8vIGVuc3VyZXMgdGhhdCBhbnkgdHJhbnNwb3J0cyB0aGF0IHdlcmUgbWFudWFsbHkgc3RhcnRlZCBhcmUgc3RvcHBlZFxuICAgICAgfSxcbiAgICAgIFNUQVJUSU5HOiB7XG4gICAgICAgIGRvbmU6ICdTVEFSVEVEJyxcbiAgICAgICAgc3RvcDogJ1NUT1BQSU5HJ1xuICAgICAgfSxcbiAgICAgIFNUQVJURUQ6IHtcbiAgICAgICAgc3RvcDogJ1NUT1BQSU5HJyxcbiAgICAgICAgc3RhcnQ6ICdTVEFSVEVEJ1xuICAgICAgfSxcbiAgICAgIFNUT1BQSU5HOiB7XG4gICAgICAgIHN0b3A6ICdTVE9QUElORycsXG4gICAgICAgIGRvbmU6ICdTVE9QUEVEJ1xuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5zdGF0ZS5vbignU1RBUlRJTkcnLCAoKSA9PiB7XG4gICAgICBsb2coJ1RoZSBzd2l0Y2ggaXMgc3RhcnRpbmcnKVxuICAgICAgdGhpcy5fb25TdGFydGluZygpXG4gICAgfSlcbiAgICB0aGlzLnN0YXRlLm9uKCdTVE9QUElORycsICgpID0+IHtcbiAgICAgIGxvZygnVGhlIHN3aXRjaCBpcyBzdG9wcGluZycpXG4gICAgICB0aGlzLl9vblN0b3BwaW5nKClcbiAgICB9KVxuICAgIHRoaXMuc3RhdGUub24oJ1NUQVJURUQnLCAoKSA9PiB7XG4gICAgICBsb2coJ1RoZSBzd2l0Y2ggaGFzIHN0YXJ0ZWQnKVxuICAgICAgdGhpcy5lbWl0KCdzdGFydCcpXG4gICAgfSlcbiAgICB0aGlzLnN0YXRlLm9uKCdTVE9QUEVEJywgKCkgPT4ge1xuICAgICAgbG9nKCdUaGUgc3dpdGNoIGhhcyBzdG9wcGVkJylcbiAgICAgIHRoaXMuZW1pdCgnc3RvcCcpXG4gICAgfSlcbiAgICB0aGlzLnN0YXRlLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgIGxvZy5lcnJvcihlcnIpXG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIH0pXG5cbiAgICAvLyBoaWdoZXIgbGV2ZWwgKHB1YmxpYykgQVBJXG4gICAgdGhpcy5kaWFsZXIgPSBnZXREaWFsZXIodGhpcylcbiAgICB0aGlzLmRpYWwgPSB0aGlzLmRpYWxlci5kaWFsXG4gICAgdGhpcy5kaWFsRlNNID0gdGhpcy5kaWFsZXIuZGlhbEZTTVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHRoZSB0cmFuc3BvcnRzIHBlZXJJbmZvIGhhcyBhZGRyZXNzZXMgZm9yXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlckluZm99IHBlZXJJbmZvXG4gICAqIEByZXR1cm5zIHtBcnJheTxUcmFuc3BvcnQ+fVxuICAgKi9cbiAgYXZhaWxhYmxlVHJhbnNwb3J0cyAocGVlckluZm8pIHtcbiAgICBjb25zdCBteUFkZHJzID0gcGVlckluZm8ubXVsdGlhZGRycy50b0FycmF5KClcbiAgICBjb25zdCBteVRyYW5zcG9ydHMgPSBPYmplY3Qua2V5cyh0aGlzLnRyYW5zcG9ydHMpXG5cbiAgICAvLyBPbmx5IGxpc3RlbiBvbiB0cmFuc3BvcnRzIHdlIGFjdHVhbGx5IGhhdmUgYWRkcmVzc2VzIGZvclxuICAgIHJldHVybiBteVRyYW5zcG9ydHMuZmlsdGVyKCh0cykgPT4gdGhpcy50cmFuc3BvcnRzW3RzXS5maWx0ZXIobXlBZGRycykubGVuZ3RoID4gMClcbiAgICAgIC8vIHB1c2ggQ2lyY3VpdCB0byBiZSB0aGUgbGFzdCBwcm90byB0byBiZSBkaWFsZWQsIGFuZCBhbHBoYWJldGl6ZSB0aGUgb3RoZXJzXG4gICAgICAuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBpZiAoYSA9PT0gQ2lyY3VpdC50YWcpIHJldHVybiAxXG4gICAgICAgIGlmIChiID09PSBDaXJjdWl0LnRhZykgcmV0dXJuIC0xXG4gICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogMVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBgaGFuZGxlckZ1bmNgIGFuZCBgbWF0Y2hGdW5jYCB0byB0aGUgU3dpdGNoJ3MgcHJvdG9jb2xcbiAgICogaGFuZGxlciBsaXN0IGZvciB0aGUgZ2l2ZW4gYHByb3RvY29sYC4gSWYgdGhlIGBtYXRjaEZ1bmNgIHJldHVybnNcbiAgICogdHJ1ZSBmb3IgYSBwcm90b2NvbCBjaGVjaywgdGhlIGBoYW5kbGVyRnVuY2Agd2lsbCBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgQ29ubmVjdGlvbil9IGhhbmRsZXJGdW5jXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nLCBzdHJpbmcsIGZ1bmN0aW9uKEVycm9yLCBib29sZWFuKSl9IG1hdGNoRnVuY1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGhhbmRsZSAocHJvdG9jb2wsIGhhbmRsZXJGdW5jLCBtYXRjaEZ1bmMpIHtcbiAgICB0aGlzLnByb3RvY29sc1twcm90b2NvbF0gPSB7XG4gICAgICBoYW5kbGVyRnVuYzogaGFuZGxlckZ1bmMsXG4gICAgICBtYXRjaEZ1bmM6IG1hdGNoRnVuY1xuICAgIH1cbiAgICB0aGlzLl9wZWVySW5mby5wcm90b2NvbHMuYWRkKHByb3RvY29sKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGdpdmVuIHByb3RvY29sIGZyb20gdGhlIFN3aXRjaCdzIHByb3RvY29sIGxpc3RcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgdW5oYW5kbGUgKHByb3RvY29sKSB7XG4gICAgaWYgKHRoaXMucHJvdG9jb2xzW3Byb3RvY29sXSkge1xuICAgICAgZGVsZXRlIHRoaXMucHJvdG9jb2xzW3Byb3RvY29sXVxuICAgIH1cbiAgICB0aGlzLl9wZWVySW5mby5wcm90b2NvbHMuZGVsZXRlKHByb3RvY29sKVxuICB9XG5cbiAgLyoqXG4gICAqIElmIGEgbXV4ZWQgQ29ubmVjdGlvbiBleGlzdHMgZm9yIHRoZSBnaXZlbiBwZWVyLCBpdCB3aWxsIGJlIGNsb3NlZFxuICAgKiBhbmQgaXRzIHJlZmVyZW5jZSBvbiB0aGUgU3dpdGNoIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICpcbiAgICogQHBhcmFtIHtQZWVySW5mb3xNdWx0aWFkZHJ8UGVlcklkfSBwZWVyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBoYW5nVXAgKHBlZXIsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgcGVlckluZm8gPSBnZXRQZWVySW5mbyhwZWVyLCB0aGlzLl9wZWVyQm9vaylcbiAgICBjb25zdCBrZXkgPSBwZWVySW5mby5pZC50b0I1OFN0cmluZygpXG4gICAgY29uc3QgY29ubnMgPSBbLi4udGhpcy5jb25uZWN0aW9uLmdldEFsbEJ5SWQoa2V5KV1cbiAgICBlYWNoKGNvbm5zLCAoY29ubiwgY2IpID0+IHtcbiAgICAgIGNvbm4ub25jZSgnY2xvc2UnLCBjYilcbiAgICAgIGNvbm4uY2xvc2UoKVxuICAgIH0sIGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN3aXRjaCBoYXMgYW55IHRyYW5zcG9ydHNcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBoYXNUcmFuc3BvcnRzICgpIHtcbiAgICBjb25zdCB0cmFuc3BvcnRzID0gT2JqZWN0LmtleXModGhpcy50cmFuc3BvcnRzKS5maWx0ZXIoKHQpID0+IHQgIT09IENpcmN1aXQudGFnKVxuICAgIHJldHVybiB0cmFuc3BvcnRzICYmIHRyYW5zcG9ydHMubGVuZ3RoID4gMFxuICB9XG5cbiAgLyoqXG4gICAqIElzc3VlcyBhIHN0YXJ0IG9uIHRoZSBTd2l0Y2ggc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGRlcHJlY2F0ZWQ6IExpc3RlbmluZyBmb3IgdGhlIGBlcnJvcmAgYW5kIGBzdGFydGAgZXZlbnRzIGFyZSByZWNvbW1lbmRlZFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHN0YXJ0IChjYWxsYmFjayA9ICgpID0+IHt9KSB7XG4gICAgLy8gQWRkIG9uY2UgbGlzdGVuZXIgZm9yIGRlcHJlY2F0ZWQgY2FsbGJhY2sgc3VwcG9ydFxuICAgIHRoaXMub25jZSgnc3RhcnQnLCBjYWxsYmFjaylcblxuICAgIHRoaXMuc3RhdGUoJ3N0YXJ0JylcbiAgfVxuXG4gIC8qKlxuICAgKiBJc3N1ZXMgYSBzdG9wIG9uIHRoZSBTd2l0Y2ggc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGRlcHJlY2F0ZWQ6IExpc3RlbmluZyBmb3IgdGhlIGBlcnJvcmAgYW5kIGBzdG9wYCBldmVudHMgYXJlIHJlY29tbWVuZGVkXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgc3RvcCAoY2FsbGJhY2sgPSAoKSA9PiB7fSkge1xuICAgIC8vIEFkZCBvbmNlIGxpc3RlbmVyIGZvciBkZXByZWNhdGVkIGNhbGxiYWNrIHN1cHBvcnRcbiAgICB0aGlzLm9uY2UoJ3N0b3AnLCBjYWxsYmFjaylcblxuICAgIHRoaXMuc3RhdGUoJ3N0b3AnKVxuICB9XG5cbiAgLyoqXG4gICAqIEEgbGlzdGVuZXIgdGhhdCB3aWxsIHN0YXJ0IGFueSBuZWNlc3Nhcnkgc2VydmljZXMgYW5kIGxpc3RlbmVyc1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9vblN0YXJ0aW5nICgpIHtcbiAgICB0aGlzLnN0YXRzLnN0YXJ0KClcbiAgICBlYWNoU2VyaWVzKHRoaXMuYXZhaWxhYmxlVHJhbnNwb3J0cyh0aGlzLl9wZWVySW5mbyksICh0cywgY2IpID0+IHtcbiAgICAgIC8vIExpc3RlbiBvbiB0aGUgZ2l2ZW4gdHJhbnNwb3J0XG4gICAgICB0aGlzLnRyYW5zcG9ydC5saXN0ZW4odHMsIHt9LCBudWxsLCBjYilcbiAgICB9LCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGxvZy5lcnJvcihlcnIpXG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlKCdzdG9wJylcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUoJ2RvbmUnKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQSBsaXN0ZW5lciB0aGF0IHdpbGwgdHVybiBvZmYgYWxsIHJ1bm5pbmcgc2VydmljZXMgYW5kIGxpc3RlbmVyc1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9vblN0b3BwaW5nICgpIHtcbiAgICB0aGlzLnN0YXRzLnN0b3AoKVxuICAgIHNlcmllcyhbXG4gICAgICAoY2IpID0+IHtcbiAgICAgICAgZWFjaCh0aGlzLnRyYW5zcG9ydHMsICh0cmFuc3BvcnQsIGNiKSA9PiB7XG4gICAgICAgICAgZWFjaCh0cmFuc3BvcnQubGlzdGVuZXJzLCAobGlzdGVuZXIsIGNiKSA9PiB7XG4gICAgICAgICAgICBsaXN0ZW5lci5jbG9zZSgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIGxvZy5lcnJvcihlcnIpXG4gICAgICAgICAgICAgIGNiKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSwgY2IpXG4gICAgICAgIH0sIGNiKVxuICAgICAgfSxcbiAgICAgIChjYikgPT4gZWFjaCh0aGlzLmNvbm5lY3Rpb24uZ2V0QWxsKCksIChjb25uLCBjYikgPT4ge1xuICAgICAgICBjb25uLm9uY2UoJ2Nsb3NlJywgY2IpXG4gICAgICAgIGNvbm4uY2xvc2UoKVxuICAgICAgfSwgY2IpXG4gICAgXSwgKF8pID0+IHtcbiAgICAgIHRoaXMuc3RhdGUoJ2RvbmUnKVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTd2l0Y2hcbm1vZHVsZS5leHBvcnRzLmVycm9ycyA9IEVycm9yc1xuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlYWQsIHJlYWRlciwgY2IsIGFib3J0LCBzdHJlYW1cblxuICBmdW5jdGlvbiBkZWxheWVkIChfcmVhZCkge1xuICAgIC8vaWYgd2UgYWxyZWFkeSBoYXZlIHRoZSBzdHJlYW0sIGdvIVxuICAgIGlmKHN0cmVhbSkgcmV0dXJuIHN0cmVhbShfcmVhZClcblxuICAgIHJlYWQgPSBfcmVhZFxuICAgIHJldHVybiBmdW5jdGlvbiAoX2Fib3J0LCBfY2IpIHtcbiAgICAgIGlmKHJlYWRlcikgcmVhZGVyKF9hYm9ydCwgX2NiKVxuICAgICAgZWxzZSBhYm9ydCA9IF9hYm9ydCwgY2IgPSBfY2JcblxuICAgIH1cbiAgfVxuXG4gIGRlbGF5ZWQucmVzb2x2ZSA9IGZ1bmN0aW9uIChfc3RyZWFtKSB7XG4gICAgaWYoc3RyZWFtKSB0aHJvdyBuZXcgRXJyb3IoJ2FscmVhZHkgcmVzb2x2ZWQnKVxuICAgIHN0cmVhbSA9IF9zdHJlYW1cbiAgICBpZighc3RyZWFtKSB0aHJvdyBuZXcgRXJyb3IoJ3Jlc29sdmUgKm11c3QqIGJlIHBhc3NlZCBhIHRyYW5zZm9ybSBzdHJlYW0nKVxuICAgIGlmKHJlYWQpIHtcbiAgICAgIHJlYWRlciA9IHN0cmVhbShyZWFkKVxuICAgICAgaWYoY2IpIHJlYWRlcihhYm9ydCwgY2IpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlbGF5ZWRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgcmVhZCwgc3RhcnRlZCA9IGZhbHNlXG5cbiAgZnVuY3Rpb24gY29uc3VtZSAoX3JlYWQpIHtcbiAgICBpZighX3JlYWQpIHRocm93IG5ldyBFcnJvcignbXVzdCBiZSBwYXNzZWQgYSByZWFkYWJsZScpXG4gICAgcmVhZCA9IF9yZWFkXG4gICAgaWYoc3RhcnRlZCkgc3RyZWFtKHJlYWQpXG4gIH1cblxuICBjb25zdW1lLnJlc29sdmUgPVxuICBjb25zdW1lLnJlYWR5ID1cbiAgY29uc3VtZS5zdGFydCA9IGZ1bmN0aW9uIChfc3RyZWFtKSB7XG4gICAgc3RhcnRlZCA9IHRydWU7IHN0cmVhbSA9IF9zdHJlYW0gfHwgc3RyZWFtXG4gICAgaWYocmVhZCkgc3RyZWFtKHJlYWQpXG4gICAgcmV0dXJuIGNvbnN1bWVcbiAgfVxuXG4gIHJldHVybiBjb25zdW1lXG59XG4iLCJcbnZhciBTb3VyY2UgPSByZXF1aXJlKCcuL3NvdXJjZScpXG52YXIgU2luayA9IHJlcXVpcmUoJy4vc2luaycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBzb3VyY2UgPSBTb3VyY2UoKVxuICB2YXIgc2luayA9IFNpbmsoKVxuXG4gIHJldHVybiB7XG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgc2luazogc2luayxcbiAgICByZXNvbHZlOiBmdW5jdGlvbiAoZHVwbGV4KSB7XG4gICAgICBzb3VyY2UucmVzb2x2ZShkdXBsZXguc291cmNlKVxuICAgICAgc2luay5yZXNvbHZlKGR1cGxleC5zaW5rKVxuXG4gICAgfVxuICB9XG5cblxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGxhc3QgPSBhc3luYyAoaXRlcmF0b3IpID0+IHtcbiAgbGV0IHJlc1xuXG4gIGZvciBhd2FpdCAoY29uc3QgZW50cnkgb2YgaXRlcmF0b3IpIHtcbiAgICByZXMgPSBlbnRyeVxuICB9XG5cbiAgcmV0dXJuIHJlc1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxhc3RcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBlcnJDb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuXG5jb25zdCByZXNvbHZlcnMgPSB7XG4gICdkYWctcGInOiByZXF1aXJlKCcuL3VuaXhmcy12MScpLFxuICByYXc6IHJlcXVpcmUoJy4vcmF3JyksXG4gICdkYWctY2Jvcic6IHJlcXVpcmUoJy4vZGFnLWNib3InKVxufVxuXG5jb25zdCByZXNvbHZlID0gKGNpZCwgbmFtZSwgcGF0aCwgdG9SZXNvbHZlLCBkZXB0aCwgaXBsZCkgPT4ge1xuICBjb25zdCByZXNvbHZlciA9IHJlc29sdmVyc1tjaWQuY29kZWNdXG5cbiAgaWYgKCFyZXNvbHZlcikge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKGBObyByZXNvbHZlciBmb3IgY29kZWMgJHtjaWQuY29kZWN9YCksICdFUlJfTk9fUkVTT0xWRVInKVxuICB9XG5cbiAgcmV0dXJuIHJlc29sdmVyKGNpZCwgbmFtZSwgcGF0aCwgdG9SZXNvbHZlLCByZXNvbHZlLCBkZXB0aCwgaXBsZClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFib3J0Q2IoY2IsIGFib3J0LCBvbkFib3J0KSB7XG4gIGNiKGFib3J0KVxuICBvbkFib3J0ICYmIG9uQWJvcnQoYWJvcnQgPT09IHRydWUgPyBudWxsOiBhYm9ydClcbiAgcmV0dXJuXG59XG5cbiIsInZhciBwcm9wID0gcmVxdWlyZSgnLi9wcm9wJylcblxuZnVuY3Rpb24gaWQgKGUpIHsgcmV0dXJuIGUgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRlc3RlciAodGVzdCkge1xuICByZXR1cm4gKFxuICAgICdvYmplY3QnID09PSB0eXBlb2YgdGVzdCAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgdGVzdC50ZXN0IC8vcmVnZXhwXG4gICAgPyBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gdGVzdC50ZXN0KGRhdGEpIH1cbiAgICA6IHByb3AgKHRlc3QpIHx8IGlkXG4gIClcbn1cbiIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaXNTdHJlYW0gPSBzdHJlYW0gPT5cblx0c3RyZWFtICE9PSBudWxsICYmXG5cdHR5cGVvZiBzdHJlYW0gPT09ICdvYmplY3QnICYmXG5cdHR5cGVvZiBzdHJlYW0ucGlwZSA9PT0gJ2Z1bmN0aW9uJztcblxuaXNTdHJlYW0ud3JpdGFibGUgPSBzdHJlYW0gPT5cblx0aXNTdHJlYW0oc3RyZWFtKSAmJlxuXHRzdHJlYW0ud3JpdGFibGUgIT09IGZhbHNlICYmXG5cdHR5cGVvZiBzdHJlYW0uX3dyaXRlID09PSAnZnVuY3Rpb24nICYmXG5cdHR5cGVvZiBzdHJlYW0uX3dyaXRhYmxlU3RhdGUgPT09ICdvYmplY3QnO1xuXG5pc1N0cmVhbS5yZWFkYWJsZSA9IHN0cmVhbSA9PlxuXHRpc1N0cmVhbShzdHJlYW0pICYmXG5cdHN0cmVhbS5yZWFkYWJsZSAhPT0gZmFsc2UgJiZcblx0dHlwZW9mIHN0cmVhbS5fcmVhZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHR0eXBlb2Ygc3RyZWFtLl9yZWFkYWJsZVN0YXRlID09PSAnb2JqZWN0JztcblxuaXNTdHJlYW0uZHVwbGV4ID0gc3RyZWFtID0+XG5cdGlzU3RyZWFtLndyaXRhYmxlKHN0cmVhbSkgJiZcblx0aXNTdHJlYW0ucmVhZGFibGUoc3RyZWFtKTtcblxuaXNTdHJlYW0udHJhbnNmb3JtID0gc3RyZWFtID0+XG5cdGlzU3RyZWFtLmR1cGxleChzdHJlYW0pICYmXG5cdHR5cGVvZiBzdHJlYW0uX3RyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHR0eXBlb2Ygc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZSA9PT0gJ29iamVjdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJlYW07XG4iLCJcbnZhciBsb29wZXIgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgKGZ1bmN0aW9uIG5leHQgKCkge1xuICAgIHZhciBsb29wID0gdHJ1ZSwgcmV0dXJuZWQgPSBmYWxzZSwgc3luYyA9IGZhbHNlXG4gICAgZG8ge1xuICAgICAgc3luYyA9IHRydWU7IGxvb3AgPSBmYWxzZVxuICAgICAgZnVuLmNhbGwodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZihzeW5jKSBsb29wID0gdHJ1ZVxuICAgICAgICBlbHNlICAgICBuZXh0KClcbiAgICAgIH0pXG4gICAgICBzeW5jID0gZmFsc2VcbiAgICB9IHdoaWxlKGxvb3ApXG4gIH0pKClcbn1cbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5leHBvcnRzLmZpbmlzaGVkID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzJyk7XG5leHBvcnRzLnBpcGVsaW5lID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcycpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IERpckZsYXQgPSByZXF1aXJlKCcuL2Rpci1mbGF0JylcbmNvbnN0IGZsYXRUb1NoYXJkID0gcmVxdWlyZSgnLi9mbGF0LXRvLXNoYXJkJylcbmNvbnN0IERpciA9IHJlcXVpcmUoJy4vZGlyJylcbmNvbnN0IHRvUGF0aENvbXBvbmVudHMgPSByZXF1aXJlKCcuL3V0aWxzL3RvLXBhdGgtY29tcG9uZW50cycpXG5jb25zdCBlcnJDb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuY29uc3QgZmlyc3QgPSByZXF1aXJlKCdhc3luYy1pdGVyYXRvci1maXJzdCcpXG5cbmFzeW5jIGZ1bmN0aW9uIGFkZFRvVHJlZSAoZWxlbSwgdHJlZSwgb3B0aW9ucykge1xuICBjb25zdCBwYXRoRWxlbXMgPSB0b1BhdGhDb21wb25lbnRzKGVsZW0ucGF0aCB8fCAnJylcbiAgY29uc3QgbGFzdEluZGV4ID0gcGF0aEVsZW1zLmxlbmd0aCAtIDFcbiAgbGV0IHBhcmVudCA9IHRyZWVcbiAgbGV0IGN1cnJlbnRQYXRoID0gJydcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhFbGVtcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBhdGhFbGVtID0gcGF0aEVsZW1zW2ldXG5cbiAgICBjdXJyZW50UGF0aCArPSBgJHtjdXJyZW50UGF0aCA/ICcvJyA6ICcnfSR7cGF0aEVsZW19YFxuXG4gICAgY29uc3QgbGFzdCA9IChpID09PSBsYXN0SW5kZXgpXG4gICAgcGFyZW50LmRpcnR5ID0gdHJ1ZVxuICAgIHBhcmVudC5jaWQgPSBudWxsXG4gICAgcGFyZW50LnNpemUgPSBudWxsXG5cbiAgICBpZiAobGFzdCkge1xuICAgICAgYXdhaXQgcGFyZW50LnB1dChwYXRoRWxlbSwgZWxlbSlcbiAgICAgIHRyZWUgPSBhd2FpdCBmbGF0VG9TaGFyZChudWxsLCBwYXJlbnQsIG9wdGlvbnMuc2hhcmRTcGxpdFRocmVzaG9sZCwgb3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRpciA9IGF3YWl0IHBhcmVudC5nZXQocGF0aEVsZW0pXG5cbiAgICAgIGlmICghZGlyIHx8ICEoZGlyIGluc3RhbmNlb2YgRGlyKSkge1xuICAgICAgICBkaXIgPSBuZXcgRGlyRmxhdCh7XG4gICAgICAgICAgZGlyOiB0cnVlLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgIHBhcmVudEtleTogcGF0aEVsZW0sXG4gICAgICAgICAgcGF0aDogY3VycmVudFBhdGgsXG4gICAgICAgICAgZGlydHk6IHRydWUsXG4gICAgICAgICAgZmxhdDogdHJ1ZVxuICAgICAgICB9LCBvcHRpb25zKVxuICAgICAgfVxuXG4gICAgICBhd2FpdCBwYXJlbnQucHV0KHBhdGhFbGVtLCBkaXIpXG5cbiAgICAgIHBhcmVudCA9IGRpclxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cmVlXG59XG5cbmFzeW5jIGZ1bmN0aW9uICogdHJlZUJ1aWxkZXIgKHNvdXJjZSwgaXBsZCwgb3B0aW9ucykge1xuICBsZXQgdHJlZSA9IG5ldyBEaXJGbGF0KHtcbiAgICByb290OiB0cnVlLFxuICAgIGRpcjogdHJ1ZSxcbiAgICBwYXRoOiAnJyxcbiAgICBkaXJ0eTogdHJ1ZSxcbiAgICBmbGF0OiB0cnVlXG4gIH0sIG9wdGlvbnMpXG5cbiAgZm9yIGF3YWl0IChjb25zdCBlbnRyeSBvZiBzb3VyY2UpIHtcbiAgICB0cmVlID0gYXdhaXQgYWRkVG9UcmVlKGVudHJ5LCB0cmVlLCBvcHRpb25zKVxuXG4gICAgeWllbGQgZW50cnlcbiAgfVxuXG4gIGlmICh0cmVlKSB7XG4gICAgaWYgKCFvcHRpb25zLndyYXBXaXRoRGlyZWN0b3J5KSB7XG4gICAgICBpZiAodHJlZS5jaGlsZENvdW50KCkgPiAxKSB7XG4gICAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdkZXRlY3RlZCBtb3JlIHRoYW4gb25lIHJvb3QnKSwgJ0VSUl9NT1JFX1RIQU5fT05FX1JPT1QnKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1bndyYXBwZWQgPSBhd2FpdCBmaXJzdCh0cmVlLmVhY2hDaGlsZFNlcmllcygpKVxuXG4gICAgICBpZiAoIXVud3JhcHBlZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdHJlZSA9IHVud3JhcHBlZC5jaGlsZFxuICAgIH1cblxuICAgIGlmICghdHJlZS5kaXIpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGZvciBhd2FpdCAoY29uc3QgZW50cnkgb2YgdHJlZS5mbHVzaCh0cmVlLnBhdGgsIGlwbGQpKSB7XG4gICAgICB5aWVsZCBlbnRyeVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyZWVCdWlsZGVyXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZGlyQnVpbGRlciA9IHJlcXVpcmUoJy4vZGlyJylcbmNvbnN0IGZpbGVCdWlsZGVyID0gcmVxdWlyZSgnLi9maWxlJylcbmNvbnN0IGNyZWF0ZUNodW5rZXIgPSByZXF1aXJlKCcuLi9jaHVua2VyJylcbmNvbnN0IHZhbGlkYXRlQ2h1bmtzID0gcmVxdWlyZSgnLi92YWxpZGF0ZS1jaHVua3MnKVxuXG5hc3luYyBmdW5jdGlvbiAqIGRhZ0J1aWxkZXIgKHNvdXJjZSwgaXBsZCwgb3B0aW9ucykge1xuICBmb3IgYXdhaXQgKGNvbnN0IGVudHJ5IG9mIHNvdXJjZSkge1xuICAgIGlmIChlbnRyeS5wYXRoKSB7XG4gICAgICBpZiAoZW50cnkucGF0aC5zdWJzdHJpbmcoMCwgMikgPT09ICcuLycpIHtcbiAgICAgICAgb3B0aW9ucy53cmFwV2l0aERpcmVjdG9yeSA9IHRydWVcbiAgICAgIH1cblxuICAgICAgZW50cnkucGF0aCA9IGVudHJ5LnBhdGhcbiAgICAgICAgLnNwbGl0KCcvJylcbiAgICAgICAgLmZpbHRlcihwYXRoID0+IHBhdGggJiYgcGF0aCAhPT0gJy4nKVxuICAgICAgICAuam9pbignLycpXG4gICAgfVxuXG4gICAgaWYgKGVudHJ5LmNvbnRlbnQpIHtcbiAgICAgIGxldCBzb3VyY2UgPSBlbnRyeS5jb250ZW50XG5cbiAgICAgIC8vIHdyYXAgaW4gaXRlcmF0b3IgaWYgaXQgaXMgYXJyYXktbGlrZSBvciBub3QgYW4gaXRlcmF0b3JcbiAgICAgIGlmICgoIXNvdXJjZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gJiYgIXNvdXJjZVtTeW1ib2wuaXRlcmF0b3JdKSB8fCBzb3VyY2UubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc291cmNlID0ge1xuICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiBmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgICAgIHlpZWxkIGVudHJ5LmNvbnRlbnRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgY2h1bmtlciA9IGNyZWF0ZUNodW5rZXIob3B0aW9ucy5jaHVua2VyLCB2YWxpZGF0ZUNodW5rcyhzb3VyY2UpLCBvcHRpb25zLmNodW5rZXJPcHRpb25zKVxuXG4gICAgICAvLyBpdGVtIGlzIGEgZmlsZVxuICAgICAgeWllbGQgZmlsZUJ1aWxkZXIoZW50cnksIGNodW5rZXIsIGlwbGQsIG9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGl0ZW0gaXMgYSBkaXJlY3RvcnlcbiAgICAgIHlpZWxkIGRpckJ1aWxkZXIoZW50cnksIGlwbGQsIG9wdGlvbnMpXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGFnQnVpbGRlclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGNvZGVzID0ge307XG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yVHlwZShjb2RlLCBtZXNzYWdlLCBCYXNlKSB7XG4gIGlmICghQmFzZSkge1xuICAgIEJhc2UgPSBFcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9XG4gIH1cblxuICB2YXIgTm9kZUVycm9yID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0Jhc2UpIHtcbiAgICBfaW5oZXJpdHNMb29zZShOb2RlRXJyb3IsIF9CYXNlKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICByZXR1cm4gX0Jhc2UuY2FsbCh0aGlzLCBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpKSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBOb2RlRXJyb3I7XG4gIH0oQmFzZSk7XG5cbiAgTm9kZUVycm9yLnByb3RvdHlwZS5uYW1lID0gQmFzZS5uYW1lO1xuICBOb2RlRXJyb3IucHJvdG90eXBlLmNvZGUgPSBjb2RlO1xuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHZhciBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcblxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfT1BUX1ZBTFVFJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiAnVGhlIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiJztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJywgZnVuY3Rpb24gKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcbiAgdmFyIGRldGVybWluZXI7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuXG4gIHZhciBtc2c7XG5cbiAgaWYgKGVuZHNXaXRoKG5hbWUsICcgYXJndW1lbnQnKSkge1xuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICBtc2cgPSBcIlRoZSBcIi5jb25jYXQobmFtZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBcIlRoZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBcIikuY29uY2F0KHR5cGUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH1cblxuICBtc2cgKz0gXCIuIFJlY2VpdmVkIHR5cGUgXCIuY29uY2F0KHR5cGVvZiBhY3R1YWwpO1xuICByZXR1cm4gbXNnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRicsICdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCcsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAnVGhlICcgKyBuYW1lICsgJyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkJztcbn0pO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScsICdQcmVtYXR1cmUgY2xvc2UnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9ERVNUUk9ZRUQnLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gJ0Nhbm5vdCBjYWxsICcgKyBuYW1lICsgJyBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkJztcbn0pO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTVVMVElQTEVfQ0FMTEJBQ0snLCAnQ2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fQ0FOTk9UX1BJUEUnLCAnQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCcsICd3cml0ZSBhZnRlciBlbmQnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUycsICdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScsIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9VTktOT1dOX0VOQ09ESU5HJywgZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBhcmc7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UJywgJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG5tb2R1bGUuZXhwb3J0cy5jb2RlcyA9IGNvZGVzO1xuIiwiJ3VzZSBzdHJpY3QnOyAvLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5cbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfSAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG5cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlTlQoc2VsZiwgZXJyKSB7XG4gIGVtaXRFcnJvck5UKHNlbGYsIGVycik7XG4gIGVtaXRDbG9zZU5UKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBlbWl0Q2xvc2VOVChzZWxmKSB7XG4gIGlmIChzZWxmLl93cml0YWJsZVN0YXRlICYmICFzZWxmLl93cml0YWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBpZiAoc2VsZi5fcmVhZGFibGVTdGF0ZSAmJiAhc2VsZi5fcmVhZGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgc2VsZi5lbWl0KCdjbG9zZScpO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5hbENhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbmZ1bmN0aW9uIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKSB7XG4gIC8vIFdlIGhhdmUgdGVzdHMgdGhhdCByZWx5IG9uIGVycm9ycyBiZWluZyBlbWl0dGVkXG4gIC8vIGluIHRoZSBzYW1lIHRpY2ssIHNvIGNoYW5naW5nIHRoaXMgaXMgc2VtdmVyIG1ham9yLlxuICAvLyBGb3Igbm93IHdoZW4geW91IG9wdC1pbiB0byBhdXRvRGVzdHJveSB3ZSBhbGxvd1xuICAvLyB0aGUgZXJyb3IgdG8gYmUgZW1pdHRlZCBuZXh0VGljay4gSW4gYSBmdXR1cmVcbiAgLy8gc2VtdmVyIG1ham9yIHVwZGF0ZSB3ZSBzaG91bGQgY2hhbmdlIHRoZSBkZWZhdWx0IHRvIHRoaXMuXG4gIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIGlmIChyU3RhdGUgJiYgclN0YXRlLmF1dG9EZXN0cm95IHx8IHdTdGF0ZSAmJiB3U3RhdGUuYXV0b0Rlc3Ryb3kpIHN0cmVhbS5kZXN0cm95KGVycik7ZWxzZSBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3ksXG4gIGVycm9yT3JEZXN0cm95OiBlcnJvck9yRGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEVSUl9JTlZBTElEX09QVF9WQUxVRSA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLkVSUl9JTlZBTElEX09QVF9WQUxVRTtcblxuZnVuY3Rpb24gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSkge1xuICByZXR1cm4gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrICE9IG51bGwgPyBvcHRpb25zLmhpZ2hXYXRlck1hcmsgOiBpc0R1cGxleCA/IG9wdGlvbnNbZHVwbGV4S2V5XSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEhpZ2hXYXRlck1hcmsoc3RhdGUsIG9wdGlvbnMsIGR1cGxleEtleSwgaXNEdXBsZXgpIHtcbiAgdmFyIGh3bSA9IGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpO1xuXG4gIGlmIChod20gIT0gbnVsbCkge1xuICAgIGlmICghKGlzRmluaXRlKGh3bSkgJiYgTWF0aC5mbG9vcihod20pID09PSBod20pIHx8IGh3bSA8IDApIHtcbiAgICAgIHZhciBuYW1lID0gaXNEdXBsZXggPyBkdXBsZXhLZXkgOiAnaGlnaFdhdGVyTWFyayc7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfT1BUX1ZBTFVFKG5hbWUsIGh3bSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoaHdtKTtcbiAgfSAvLyBEZWZhdWx0IHZhbHVlXG5cblxuICByZXR1cm4gc3RhdGUub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0SGlnaFdhdGVyTWFyazogZ2V0SGlnaFdhdGVyTWFya1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdSZWFkYWJsZS5mcm9tIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGJyb3dzZXInKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnYnVmZmVyJyksXG4gICAgQnVmZmVyID0gX3JlcXVpcmUuQnVmZmVyO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgndXRpbCcpLFxuICAgIGluc3BlY3QgPSBfcmVxdWlyZTIuaW5zcGVjdDtcblxudmFyIGN1c3RvbSA9IGluc3BlY3QgJiYgaW5zcGVjdC5jdXN0b20gfHwgJ2luc3BlY3QnO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5jb3B5LmNhbGwoc3JjLCB0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJ1ZmZlckxpc3QsIFt7XG4gICAga2V5OiBcInB1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIGRhdGE6IHYsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgICsrdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuc2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIGRhdGE6IHYsXG4gICAgICAgIG5leHQ6IHRoaXMuaGVhZFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICAgICsrdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImpvaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gam9pbihzKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuXG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29uY2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgb3IgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29uc3VtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdW1lKG4sIGhhc1N0cmluZ3MpIHtcbiAgICAgIHZhciByZXQ7XG5cbiAgICAgIGlmIChuIDwgdGhpcy5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIC8vIGBzbGljZWAgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICAgIHJldCA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgICAgICB0aGlzLmhlYWQuZGF0YSA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICAgICAgfSBlbHNlIGlmIChuID09PSB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gRmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoLlxuICAgICAgICByZXQgPSB0aGlzLnNoaWZ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXIuXG4gICAgICAgIHJldCA9IGhhc1N0cmluZ3MgPyB0aGlzLl9nZXRTdHJpbmcobikgOiB0aGlzLl9nZXRCdWZmZXIobik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpcnN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFN0cmluZyhuKSB7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBjID0gMTtcbiAgICAgIHZhciByZXQgPSBwLmRhdGE7XG4gICAgICBuIC09IHJldC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgICAgIG4gLT0gbmI7XG5cbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICsrYztcbiAgICAgICAgICAgIGlmIChwLm5leHQpIHRoaXMuaGVhZCA9IHAubmV4dDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHA7XG4gICAgICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgKytjO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCAtPSBjO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QnVmZmVyKG4pIHtcbiAgICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBjID0gMTtcbiAgICAgIHAuZGF0YS5jb3B5KHJldCk7XG4gICAgICBuIC09IHAuZGF0YS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICAgICAgbiAtPSBuYjtcblxuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gcDtcbiAgICAgICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICArK2M7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoIC09IGM7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gTWFrZSBzdXJlIHRoZSBsaW5rZWQgbGlzdCBvbmx5IHNob3dzIHRoZSBtaW5pbWFsIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbi5cblxuICB9LCB7XG4gICAga2V5OiBjdXN0b20sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKF8sIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgLy8gT25seSBpbnNwZWN0IG9uZSBsZXZlbC5cbiAgICAgICAgZGVwdGg6IDAsXG4gICAgICAgIC8vIEl0IHNob3VsZCBub3QgcmVjdXJzZS5cbiAgICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfT2JqZWN0JHNldFByb3RvdHlwZU87XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBmaW5pc2hlZCA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xuXG52YXIga0xhc3RSZXNvbHZlID0gU3ltYm9sKCdsYXN0UmVzb2x2ZScpO1xudmFyIGtMYXN0UmVqZWN0ID0gU3ltYm9sKCdsYXN0UmVqZWN0Jyk7XG52YXIga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xudmFyIGtFbmRlZCA9IFN5bWJvbCgnZW5kZWQnKTtcbnZhciBrTGFzdFByb21pc2UgPSBTeW1ib2woJ2xhc3RQcm9taXNlJyk7XG52YXIga0hhbmRsZVByb21pc2UgPSBTeW1ib2woJ2hhbmRsZVByb21pc2UnKTtcbnZhciBrU3RyZWFtID0gU3ltYm9sKCdzdHJlYW0nKTtcblxuZnVuY3Rpb24gY3JlYXRlSXRlclJlc3VsdCh2YWx1ZSwgZG9uZSkge1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBkb25lOiBkb25lXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmRSZXNvbHZlKGl0ZXIpIHtcbiAgdmFyIHJlc29sdmUgPSBpdGVyW2tMYXN0UmVzb2x2ZV07XG5cbiAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICB2YXIgZGF0YSA9IGl0ZXJba1N0cmVhbV0ucmVhZCgpOyAvLyB3ZSBkZWZlciBpZiBkYXRhIGlzIG51bGxcbiAgICAvLyB3ZSBjYW4gYmUgZXhwZWN0aW5nIGVpdGhlciAnZW5kJyBvclxuICAgIC8vICdlcnJvcidcblxuICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICBpdGVyW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvblJlYWRhYmxlKGl0ZXIpIHtcbiAgLy8gd2Ugd2FpdCBmb3IgdGhlIG5leHQgdGljaywgYmVjYXVzZSBpdCBtaWdodFxuICAvLyBlbWl0IGFuIGVycm9yIHdpdGggcHJvY2Vzcy5uZXh0VGlja1xuICBwcm9jZXNzLm5leHRUaWNrKHJlYWRBbmRSZXNvbHZlLCBpdGVyKTtcbn1cblxuZnVuY3Rpb24gd3JhcEZvck5leHQobGFzdFByb21pc2UsIGl0ZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBsYXN0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpdGVyW2tFbmRlZF0pIHtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGl0ZXJba0hhbmRsZVByb21pc2VdKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSwgcmVqZWN0KTtcbiAgfTtcbn1cblxudmFyIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnVuY3Rpb24gKCkge30pO1xudmFyIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZigoX09iamVjdCRzZXRQcm90b3R5cGVPID0ge1xuICBnZXQgc3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzW2tTdHJlYW1dO1xuICB9LFxuXG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIGlmIHdlIGhhdmUgZGV0ZWN0ZWQgYW4gZXJyb3IgaW4gdGhlIG1lYW53aGlsZVxuICAgIC8vIHJlamVjdCBzdHJhaWdodCBhd2F5XG4gICAgdmFyIGVycm9yID0gdGhpc1trRXJyb3JdO1xuXG4gICAgaWYgKGVycm9yICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tFbmRlZF0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1trU3RyZWFtXS5kZXN0cm95ZWQpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gZGVmZXIgdmlhIG5leHRUaWNrIGJlY2F1c2UgaWYgLmRlc3Ryb3koZXJyKSBpc1xuICAgICAgLy8gY2FsbGVkLCB0aGUgZXJyb3Igd2lsbCBiZSBlbWl0dGVkIHZpYSBuZXh0VGljaywgYW5kXG4gICAgICAvLyB3ZSBjYW5ub3QgZ3VhcmFudGVlIHRoYXQgdGhlcmUgaXMgbm8gZXJyb3IgbGluZ2VyaW5nIGFyb3VuZFxuICAgICAgLy8gd2FpdGluZyB0byBiZSBlbWl0dGVkLlxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzW2tFcnJvcl0pIHtcbiAgICAgICAgICAgIHJlamVjdChfdGhpc1trRXJyb3JdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IC8vIGlmIHdlIGhhdmUgbXVsdGlwbGUgbmV4dCgpIGNhbGxzXG4gICAgLy8gd2Ugd2lsbCB3YWl0IGZvciB0aGUgcHJldmlvdXMgUHJvbWlzZSB0byBmaW5pc2hcbiAgICAvLyB0aGlzIGxvZ2ljIGlzIG9wdGltaXplZCB0byBzdXBwb3J0IGZvciBhd2FpdCBsb29wcyxcbiAgICAvLyB3aGVyZSBuZXh0KCkgaXMgb25seSBjYWxsZWQgb25jZSBhdCBhIHRpbWVcblxuXG4gICAgdmFyIGxhc3RQcm9taXNlID0gdGhpc1trTGFzdFByb21pc2VdO1xuICAgIHZhciBwcm9taXNlO1xuXG4gICAgaWYgKGxhc3RQcm9taXNlKSB7XG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2Uod3JhcEZvck5leHQobGFzdFByb21pc2UsIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmFzdCBwYXRoIG5lZWRlZCB0byBzdXBwb3J0IG11bHRpcGxlIHRoaXMucHVzaCgpXG4gICAgICAvLyB3aXRob3V0IHRyaWdnZXJpbmcgdGhlIG5leHQoKSBxdWV1ZVxuICAgICAgdmFyIGRhdGEgPSB0aGlzW2tTdHJlYW1dLnJlYWQoKTtcblxuICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9XG5cbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh0aGlzW2tIYW5kbGVQcm9taXNlXSk7XG4gICAgfVxuXG4gICAgdGhpc1trTGFzdFByb21pc2VdID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgU3ltYm9sLmFzeW5jSXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgXCJyZXR1cm5cIiwgZnVuY3Rpb24gX3JldHVybigpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgLy8gZGVzdHJveShlcnIsIGNiKSBpcyBhIHByaXZhdGUgQVBJXG4gIC8vIHdlIGNhbiBndWFyYW50ZWUgd2UgaGF2ZSB0aGF0IGhlcmUsIGJlY2F1c2Ugd2UgY29udHJvbCB0aGVcbiAgLy8gUmVhZGFibGUgY2xhc3MgdGhpcyBpcyBhdHRhY2hlZCB0b1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIF90aGlzMltrU3RyZWFtXS5kZXN0cm95KG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9KTtcbn0pLCBfT2JqZWN0JHNldFByb3RvdHlwZU8pLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcblxudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IGZ1bmN0aW9uIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcihzdHJlYW0pIHtcbiAgdmFyIF9PYmplY3QkY3JlYXRlO1xuXG4gIHZhciBpdGVyYXRvciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCAoX09iamVjdCRjcmVhdGUgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrU3RyZWFtLCB7XG4gICAgdmFsdWU6IHN0cmVhbSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlc29sdmUsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlamVjdCwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFcnJvciwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFbmRlZCwge1xuICAgIHZhbHVlOiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrSGFuZGxlUHJvbWlzZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBkYXRhID0gaXRlcmF0b3Jba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IHJlc29sdmU7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IHJlamVjdDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfT2JqZWN0JGNyZWF0ZSkpO1xuICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgZmluaXNoZWQoc3RyZWFtLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVyciAmJiBlcnIuY29kZSAhPT0gJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJykge1xuICAgICAgdmFyIHJlamVjdCA9IGl0ZXJhdG9yW2tMYXN0UmVqZWN0XTsgLy8gcmVqZWN0IGlmIHdlIGFyZSB3YWl0aW5nIGZvciBkYXRhIGluIHRoZSBQcm9taXNlXG4gICAgICAvLyByZXR1cm5lZCBieSBuZXh0KCkgYW5kIHN0b3JlIHRoZSBlcnJvclxuXG4gICAgICBpZiAocmVqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdG9yW2tFcnJvcl0gPSBlcnI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlc29sdmUgPSBpdGVyYXRvcltrTGFzdFJlc29sdmVdO1xuXG4gICAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGl0ZXJhdG9yW2tFbmRlZF0gPSB0cnVlO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIG9uUmVhZGFibGUuYmluZChudWxsLCBpdGVyYXRvcikpO1xuICByZXR1cm4gaXRlcmF0b3I7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjsiLCIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2VuZC1vZi1zdHJlYW0gd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFO1xuXG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZW9zKHN0cmVhbSwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW9zKHN0cmVhbSwgbnVsbCwgb3B0cyk7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gIHZhciByZWFkYWJsZSA9IG9wdHMucmVhZGFibGUgfHwgb3B0cy5yZWFkYWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLnJlYWRhYmxlO1xuICB2YXIgd3JpdGFibGUgPSBvcHRzLndyaXRhYmxlIHx8IG9wdHMud3JpdGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS53cml0YWJsZTtcblxuICB2YXIgb25sZWdhY3lmaW5pc2ggPSBmdW5jdGlvbiBvbmxlZ2FjeWZpbmlzaCgpIHtcbiAgICBpZiAoIXN0cmVhbS53cml0YWJsZSkgb25maW5pc2goKTtcbiAgfTtcblxuICB2YXIgd3JpdGFibGVFbmRlZCA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZSAmJiBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQ7XG5cbiAgdmFyIG9uZmluaXNoID0gZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgd3JpdGFibGUgPSBmYWxzZTtcbiAgICB3cml0YWJsZUVuZGVkID0gdHJ1ZTtcbiAgICBpZiAoIXJlYWRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG4gIH07XG5cbiAgdmFyIHJlYWRhYmxlRW5kZWQgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGUgJiYgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQ7XG5cbiAgdmFyIG9uZW5kID0gZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICByZWFkYWJsZUVuZGVkID0gdHJ1ZTtcbiAgICBpZiAoIXdyaXRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG4gIH07XG5cbiAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICB9O1xuXG4gIHZhciBvbmNsb3NlID0gZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICB2YXIgZXJyO1xuXG4gICAgaWYgKHJlYWRhYmxlICYmICFyZWFkYWJsZUVuZGVkKSB7XG4gICAgICBpZiAoIXN0cmVhbS5fcmVhZGFibGVTdGF0ZSB8fCAhc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgICB9XG5cbiAgICBpZiAod3JpdGFibGUgJiYgIXdyaXRhYmxlRW5kZWQpIHtcbiAgICAgIGlmICghc3RyZWFtLl93cml0YWJsZVN0YXRlIHx8ICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZW5kZWQpIGVyciA9IG5ldyBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSgpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgb25yZXF1ZXN0ID0gZnVuY3Rpb24gb25yZXF1ZXN0KCkge1xuICAgIHN0cmVhbS5yZXEub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgfTtcblxuICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHtcbiAgICBzdHJlYW0ub24oJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5vbignYWJvcnQnLCBvbmNsb3NlKTtcbiAgICBpZiAoc3RyZWFtLnJlcSkgb25yZXF1ZXN0KCk7ZWxzZSBzdHJlYW0ub24oJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuICB9IGVsc2UgaWYgKHdyaXRhYmxlICYmICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAvLyBsZWdhY3kgc3RyZWFtc1xuICAgIHN0cmVhbS5vbignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5vbignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gIH1cblxuICBzdHJlYW0ub24oJ2VuZCcsIG9uZW5kKTtcbiAgc3RyZWFtLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gIGlmIChvcHRzLmVycm9yICE9PSBmYWxzZSkgc3RyZWFtLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBzdHJlYW0ub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0Jywgb25jbG9zZSk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcbiAgICBpZiAoc3RyZWFtLnJlcSkgc3RyZWFtLnJlcS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlb3M7IiwiLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9wdW1wIHdpdGhcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW9zO1xuXG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBjYWxsYmFjay5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9NSVNTSU5HX0FSR1MgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUlTU0lOR19BUkdTLFxuICAgIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQ7XG5cbmZ1bmN0aW9uIG5vb3AoZXJyKSB7XG4gIC8vIFJldGhyb3cgdGhlIGVycm9yIGlmIGl0IGV4aXN0cyB0byBhdm9pZCBzd2FsbG93aW5nIGl0XG4gIGlmIChlcnIpIHRocm93IGVycjtcbn1cblxuZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICB2YXIgY2xvc2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgfSk7XG4gIGlmIChlb3MgPT09IHVuZGVmaW5lZCkgZW9zID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG4gIGVvcyhzdHJlYW0sIHtcbiAgICByZWFkYWJsZTogcmVhZGluZyxcbiAgICB3cml0YWJsZTogd3JpdGluZ1xuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgICBjYWxsYmFjaygpO1xuICB9KTtcbiAgdmFyIGRlc3Ryb3llZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChjbG9zZWQpIHJldHVybjtcbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgZGVzdHJveWVkID0gdHJ1ZTsgLy8gcmVxdWVzdC5kZXN0cm95IGp1c3QgZG8gLmVuZCAtIC5hYm9ydCBpcyB3aGF0IHdlIHdhbnRcblxuICAgIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkgcmV0dXJuIHN0cmVhbS5hYm9ydCgpO1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHJldHVybiBzdHJlYW0uZGVzdHJveSgpO1xuICAgIGNhbGxiYWNrKGVyciB8fCBuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3BpcGUnKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhbGwoZm4pIHtcbiAgZm4oKTtcbn1cblxuZnVuY3Rpb24gcGlwZShmcm9tLCB0bykge1xuICByZXR1cm4gZnJvbS5waXBlKHRvKTtcbn1cblxuZnVuY3Rpb24gcG9wQ2FsbGJhY2soc3RyZWFtcykge1xuICBpZiAoIXN0cmVhbXMubGVuZ3RoKSByZXR1cm4gbm9vcDtcbiAgaWYgKHR5cGVvZiBzdHJlYW1zW3N0cmVhbXMubGVuZ3RoIC0gMV0gIT09ICdmdW5jdGlvbicpIHJldHVybiBub29wO1xuICByZXR1cm4gc3RyZWFtcy5wb3AoKTtcbn1cblxuZnVuY3Rpb24gcGlwZWxpbmUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdHJlYW1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHN0cmVhbXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgY2FsbGJhY2sgPSBwb3BDYWxsYmFjayhzdHJlYW1zKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RyZWFtc1swXSkpIHN0cmVhbXMgPSBzdHJlYW1zWzBdO1xuXG4gIGlmIChzdHJlYW1zLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnc3RyZWFtcycpO1xuICB9XG5cbiAgdmFyIGVycm9yO1xuICB2YXIgZGVzdHJveXMgPSBzdHJlYW1zLm1hcChmdW5jdGlvbiAoc3RyZWFtLCBpKSB7XG4gICAgdmFyIHJlYWRpbmcgPSBpIDwgc3RyZWFtcy5sZW5ndGggLSAxO1xuICAgIHZhciB3cml0aW5nID0gaSA+IDA7XG4gICAgcmV0dXJuIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmICghZXJyb3IpIGVycm9yID0gZXJyO1xuICAgICAgaWYgKGVycikgZGVzdHJveXMuZm9yRWFjaChjYWxsKTtcbiAgICAgIGlmIChyZWFkaW5nKSByZXR1cm47XG4gICAgICBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xuICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHN0cmVhbXMucmVkdWNlKHBpcGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBpcGVsaW5lOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cbid1c2Ugc3RyaWN0Jztcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcblxudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gQWxsb3cgdGhlIGtleXMgYXJyYXkgdG8gYmUgR0MnZWQuXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuXG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xuICAgIH1cbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7IC8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcblxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIElmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLCB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuOyAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuXG4gIHByb2Nlc3MubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcsXG4gICAgRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wID0gX3JlcXVpcmUkY29kZXMuRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmIChjYiA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuICBjYihlcik7XG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcblxuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTsgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfSAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG5cblxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07IC8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfdHJhbnNmb3JtKCknKSk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuXG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTsgLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcblxuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTsgLy8gVE9ETyhCcmlkZ2VBUik6IFdyaXRlIGEgdGVzdCBmb3IgdGhlc2UgdHdvIGVycm9yIGNhc2VzXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG5cbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAoKTtcbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORygpO1xuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn0gLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cblxuXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUsXG4gICAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRCxcbiAgICBFUlJfU1RSRUFNX05VTExfVkFMVUVTID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyxcbiAgICBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5ELFxuICAgIEVSUl9VTktOT1dOX0VOQ09ESU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1VOS05PV05fRU5DT0RJTkc7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLFxuICAvLyBlLmcuIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlIHZzLiBvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSwgZXRjLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTsgLy8gZHJhaW4gZXZlbnQgZmxhZy5cblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlOyAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7IC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcblxuICB0aGlzLmVuZGVkID0gZmFsc2U7IC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cblxuICB0aGlzLmxlbmd0aCA9IDA7IC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7IC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcblxuICB0aGlzLmNvcmtlZCA9IDA7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7IC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcblxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9OyAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcblxuXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7IC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cblxuICB0aGlzLndyaXRlbGVuID0gMDtcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsOyAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcblxuICB0aGlzLnBlbmRpbmdjYiA9IDA7IC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcblxuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7IC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdmaW5pc2gnIChhbmQgcG90ZW50aWFsbHkgJ2VuZCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDsgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG5cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG5cbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVCdWZmZXJHZXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpOyAvLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cblxuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiByZWFsSGFzSW5zdGFuY2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTsgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBXcml0YWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIGlmICghaXNEdXBsZXggJiYgIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5LlxuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn0gLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuXG5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSgpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQoKTsgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcblxuICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xufSAvLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5cblxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIGVyO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJ10sIGNodW5rKTtcbiAgfVxuXG4gIGlmIChlcikge1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG4gIGlmIChzdGF0ZS5lbmRpbmcpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBFUlJfVU5LTk9XTl9FTkNPRElORyhlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuXG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7IC8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyazsgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAoc3RhdGUuZGVzdHJveWVkKSBzdGF0ZS5vbndyaXRlKG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnd3JpdGUnKSk7ZWxzZSBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG5cbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpO1xuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSkgfHwgc3RyZWFtLmRlc3Ryb3llZDtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59IC8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuXG5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn0gLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcblxuXG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG5cbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTsgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcblxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTsgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cblxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ193cml0ZSgpJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTsgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9IC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cblxuXG4gIGlmICghc3RhdGUuZW5kaW5nKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuXG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicgJiYgIXN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuXG4gICAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgICAvLyBpZiB0aGUgcmVhZGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gICAgICAgIGlmICghclN0YXRlIHx8IHJTdGF0ZS5hdXRvRGVzdHJveSAmJiByU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuXG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9IC8vIHJldXNlIHRoZSBmcmVlIGNvcmtSZXEuXG5cblxuICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBFRWxpc3RlbmVyQ291bnQoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgZGVidWc7XG5cbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0Jyk7XG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICAgIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQ7IC8vIExhenkgbG9hZGVkIHRvIGltcHJvdmUgdGhlIHN0YXJ0dXAgcGVyZm9ybWFuY2UuXG5cblxudmFyIFN0cmluZ0RlY29kZXI7XG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yO1xudmFyIGZyb207XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7IC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cblxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OyAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlOyAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpOyAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG5cbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTsgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdGhpcy5wYXVzZWQgPSB0cnVlOyAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOyAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2VuZCcgKGFuZCBwb3RlbnRpYWxseSAnZmluaXNoJylcblxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95OyAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOyAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOyAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7IC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcblxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuXG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7IC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFJlYWRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG5cbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5XG5cbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblxuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07IC8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTsgLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgZGVidWcoJ3JlYWRhYmxlQWRkQ2h1bmsnLCBjaHVuayk7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcblxuICAgIGlmIChlcikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQoKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YoKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSAvLyBXZSBjYW4gcHVzaCBtb3JlIGRhdGEgaWYgd2UgYXJlIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLlxuICAvLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZSBtb3JlIGJ5dGVzLlxuICAvLyBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLCBzdWNoIGFzIHRoZSByZXBsLlxuXG5cbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG5cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG5cbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInLCAnVWludDhBcnJheSddLCBjaHVuayk7XG4gIH1cblxuICByZXR1cm4gZXI7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59OyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHZhciBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gZGVjb2RlcjsgLy8gSWYgc2V0RW5jb2RpbmcobnVsbCksIGRlY29kZXIuZW5jb2RpbmcgZXF1YWxzIHV0ZjhcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyLmVuY29kaW5nOyAvLyBJdGVyYXRlIG92ZXIgY3VycmVudCBidWZmZXIgdG8gY29udmVydCBhbHJlYWR5IHN0b3JlZCBCdWZmZXJzOlxuXG4gIHZhciBwID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuaGVhZDtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICB3aGlsZSAocCAhPT0gbnVsbCkge1xuICAgIGNvbnRlbnQgKz0gZGVjb2Rlci53cml0ZShwLmRhdGEpO1xuICAgIHAgPSBwLm5leHQ7XG4gIH1cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuXG4gIGlmIChjb250ZW50ICE9PSAnJykgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIucHVzaChjb250ZW50KTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMUdCXG5cblxudmFyIE1BWF9IV00gPSAweDQwMDAwMDAwO1xuXG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICAvLyBUT0RPKHJvbmFnKTogVGhyb3cgRVJSX1ZBTFVFX09VVF9PRl9SQU5HRS5cbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG5cbiAgcmV0dXJuIG47XG59IC8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG5cbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH0gLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG5cblxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjsgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcblxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59IC8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7IC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cblxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKChzdGF0ZS5oaWdoV2F0ZXJNYXJrICE9PSAwID8gc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgOiBzdGF0ZS5sZW5ndGggPiAwKSB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7IC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cblxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cblxuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTsgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfSAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG5cblxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlOyAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcblxuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTsgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1Zygnb25Fb2ZDaHVuaycpO1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcblxuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG5cbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS5zeW5jKSB7XG4gICAgLy8gaWYgd2UgYXJlIHN5bmMsIHdhaXQgdW50aWwgbmV4dCB0aWNrIHRvIGVtaXQgdGhlIGRhdGEuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIHJpc2sgZW1pdHRpbmcgZGF0YSBpbiB0aGUgZmxvdygpXG4gICAgLy8gdGhlIHJlYWRhYmxlIGNvZGUgdHJpZ2dlcnMgZHVyaW5nIGEgcmVhZCgpIGNhbGxcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAgIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgIH1cbiAgfVxufSAvLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuXG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUubmVlZFJlYWRhYmxlLCBzdGF0ZS5lbWl0dGVkUmVhZGFibGUpO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGVfJywgc3RhdGUuZGVzdHJveWVkLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcblxuICBpZiAoIXN0YXRlLmRlc3Ryb3llZCAmJiAoc3RhdGUubGVuZ3RoIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB9IC8vIFRoZSBzdHJlYW0gbmVlZHMgYW5vdGhlciByZWFkYWJsZSBldmVudCBpZlxuICAvLyAxLiBJdCBpcyBub3QgZmxvd2luZywgYXMgdGhlIGZsb3cgbWVjaGFuaXNtIHdpbGwgdGFrZVxuICAvLyAgICBjYXJlIG9mIGl0LlxuICAvLyAyLiBJdCBpcyBub3QgZW5kZWQuXG4gIC8vIDMuIEl0IGlzIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLCBzbyB3ZSBjYW4gc2NoZWR1bGVcbiAgLy8gICAgYW5vdGhlciByZWFkYWJsZSBsYXRlci5cblxuXG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9ICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgZmxvdyhzdHJlYW0pO1xufSAvLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cblxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIC8vIEF0dGVtcHQgdG8gcmVhZCBtb3JlIGRhdGEgaWYgd2Ugc2hvdWxkLlxuICAvL1xuICAvLyBUaGUgY29uZGl0aW9ucyBmb3IgcmVhZGluZyBtb3JlIGRhdGEgYXJlIChvbmUgb2YpOlxuICAvLyAtIE5vdCBlbm91Z2ggZGF0YSBidWZmZXJlZCAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykuIFRoZSBsb29wXG4gIC8vICAgaXMgcmVzcG9uc2libGUgZm9yIGZpbGxpbmcgdGhlIGJ1ZmZlciB3aXRoIGVub3VnaCBkYXRhIGlmIHN1Y2ggZGF0YVxuICAvLyAgIGlzIGF2YWlsYWJsZS4gSWYgaGlnaFdhdGVyTWFyayBpcyAwIGFuZCB3ZSBhcmUgbm90IGluIHRoZSBmbG93aW5nIG1vZGVcbiAgLy8gICB3ZSBzaG91bGQgX25vdF8gYXR0ZW1wdCB0byBidWZmZXIgYW55IGV4dHJhIGRhdGEuIFdlJ2xsIGdldCBtb3JlIGRhdGFcbiAgLy8gICB3aGVuIHRoZSBzdHJlYW0gY29uc3VtZXIgY2FsbHMgcmVhZCgpIGluc3RlYWQuXG4gIC8vIC0gTm8gZGF0YSBpbiB0aGUgYnVmZmVyLCBhbmQgdGhlIHN0cmVhbSBpcyBpbiBmbG93aW5nIG1vZGUuIEluIHRoaXMgbW9kZVxuICAvLyAgIHRoZSBsb29wIGJlbG93IGlzIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyByZWFkKCkgaXMgY2FsbGVkLiBGYWlsaW5nIHRvXG4gIC8vICAgY2FsbCByZWFkIGhlcmUgd291bGQgYWJvcnQgdGhlIGZsb3cgYW5kIHRoZXJlJ3Mgbm8gb3RoZXIgbWVjaGFuaXNtIGZvclxuICAvLyAgIGNvbnRpbnVpbmcgdGhlIGZsb3cgaWYgdGhlIHN0cmVhbSBjb25zdW1lciBoYXMganVzdCBzdWJzY3JpYmVkIHRvIHRoZVxuICAvLyAgICdkYXRhJyBldmVudC5cbiAgLy9cbiAgLy8gSW4gYWRkaXRpb24gdG8gdGhlIGFib3ZlIGNvbmRpdGlvbnMgdG8ga2VlcCByZWFkaW5nIGRhdGEsIHRoZSBmb2xsb3dpbmdcbiAgLy8gY29uZGl0aW9ucyBwcmV2ZW50IHRoZSBkYXRhIGZyb20gYmVpbmcgcmVhZDpcbiAgLy8gLSBUaGUgc3RyZWFtIGhhcyBlbmRlZCAoc3RhdGUuZW5kZWQpLlxuICAvLyAtIFRoZXJlIGlzIGFscmVhZHkgYSBwZW5kaW5nICdyZWFkJyBvcGVyYXRpb24gKHN0YXRlLnJlYWRpbmcpLiBUaGlzIGlzIGFcbiAgLy8gICBjYXNlIHdoZXJlIHRoZSB0aGUgc3RyZWFtIGhhcyBjYWxsZWQgdGhlIGltcGxlbWVudGF0aW9uIGRlZmluZWQgX3JlYWQoKVxuICAvLyAgIG1ldGhvZCwgYnV0IHRoZXkgYXJlIHByb2Nlc3NpbmcgdGhlIGNhbGwgYXN5bmNocm9ub3VzbHkgYW5kIGhhdmUgX25vdF9cbiAgLy8gICBjYWxsZWQgcHVzaCgpIHdpdGggbmV3IGRhdGEuIEluIHRoaXMgY2FzZSB3ZSBza2lwIHBlcmZvcm1pbmcgbW9yZVxuICAvLyAgIHJlYWQoKXMuIFRoZSBleGVjdXRpb24gZW5kcyBpbiB0aGlzIG1ldGhvZCBhZ2FpbiBhZnRlciB0aGUgX3JlYWQoKSBlbmRzXG4gIC8vICAgdXAgY2FsbGluZyBwdXNoKCkgd2l0aCBtb3JlIGRhdGEuXG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDApKSB7XG4gICAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59IC8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3JlYWQoKScpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzcy5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG5cbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcblxuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9IC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuXG5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpOyAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGNsZWFuZWRVcCA9IHRydWU7IC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgZGVidWcoJ2Rlc3Qud3JpdGUnLCByZXQpO1xuXG4gICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICB9XG5cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfSAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuXG5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZXJyb3JPckRlc3Ryb3koZGVzdCwgZXIpO1xuICB9IC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cblxuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTsgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuXG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcblxuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG5cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9IC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG5cblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpOyAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVPbkRyYWluRnVuY3Rpb25SZXN1bHQoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHtcbiAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICB9OyAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzOyAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7IC8vIGdvdCBhIG1hdGNoLlxuXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywge1xuICAgICAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cblxuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gdXBkYXRlIHJlYWRhYmxlTGlzdGVuaW5nIHNvIHRoYXQgcmVzdW1lKCkgbWF5IGJlIGEgbm8tb3BcbiAgICAvLyBhIGZldyBsaW5lcyBkb3duLiBUaGlzIGlzIG5lZWRlZCB0byBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJykuXG4gICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0aGlzLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwOyAvLyBUcnkgc3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG5cbiAgICBpZiAoc3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGRlYnVnKCdvbiByZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUucmVhZGluZyk7XG5cbiAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfSBlbHNlIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIuY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2KSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyB8fCBldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nKHNlbGYpIHtcbiAgdmFyIHN0YXRlID0gc2VsZi5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzZWxmLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwO1xuXG4gIGlmIChzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgJiYgIXN0YXRlLnBhdXNlZCkge1xuICAgIC8vIGZsb3dpbmcgbmVlZHMgdG8gYmUgc2V0IHRvIHRydWUgbm93LCBvdGhlcndpc2VcbiAgICAvLyB0aGUgdXBjb21pbmcgcmVzdW1lIHdpbGwgbm90IGZsb3cuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7IC8vIGNydWRlIHdheSB0byBjaGVjayBpZiB3ZSBzaG91bGQgcmVzdW1lXG4gIH0gZWxzZSBpZiAoc2VsZi5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwKSB7XG4gICAgc2VsZi5yZXN1bWUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59IC8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTsgLy8gd2UgZmxvdyBvbmx5IGlmIHRoZXJlIGlzIG5vIG9uZSBsaXN0ZW5pbmdcbiAgICAvLyBmb3IgcmVhZGFibGUsIGJ1dCB3ZSBzdGlsbCBoYXZlIHRvIGNhbGxcbiAgICAvLyByZXN1bWUoKVxuXG4gICAgc3RhdGUuZmxvd2luZyA9ICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZztcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG5cbiAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdyZXN1bWUnLCBzdGF0ZS5yZWFkaW5nKTtcblxuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5wYXVzZWQgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcblxuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7XG4gICAgO1xuICB9XG59IC8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuXG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTsgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG5cbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG5cbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7IC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiBtZXRob2RXcmFwKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWV0aG9kV3JhcFJldHVybkZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfSAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG5cblxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9IC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG5cblxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuXG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVhZGFibGUucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvcicpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcyk7XG4gIH07XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVGbG93aW5nJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldChzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBzdGF0ZTtcbiAgICB9XG4gIH1cbn0pOyAvLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pOyAvLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmZpcnN0KCk7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBzdGF0ZS5idWZmZXIuY29uc3VtZShuLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW5kUmVhZGFibGUnLCBzdGF0ZS5lbmRFbWl0dGVkKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlTlQnLCBzdGF0ZS5lbmRFbWl0dGVkLCBzdGF0ZS5sZW5ndGgpOyAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuXG4gICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAvLyBpZiB0aGUgd3JpdGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcblxuICAgICAgaWYgKCF3U3RhdGUgfHwgd1N0YXRlLmF1dG9EZXN0cm95ICYmIHdTdGF0ZS5maW5pc2hlZCkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5mcm9tID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBvcHRzKSB7XG4gICAgaWYgKGZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnJvbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9mcm9tJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cblxuICByZXR1cm4gLTE7XG59IiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGV4cG9ydGVyID0gcmVxdWlyZSgnaXBmcy11bml4ZnMtZXhwb3J0ZXInKVxuY29uc3QgYXBwbHlEZWZhdWx0T3B0aW9ucyA9IHJlcXVpcmUoJy4vdXRpbHMvYXBwbHktZGVmYXVsdC1vcHRpb25zJylcbmNvbnN0IHRvTWZzUGF0aCA9IHJlcXVpcmUoJy4vdXRpbHMvdG8tbWZzLXBhdGgnKVxuY29uc3QgZXJyQ29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIG9mZnNldDogMCxcbiAgbGVuZ3RoOiBJbmZpbml0eVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChjb250ZXh0KSA9PiB7XG4gIHJldHVybiBmdW5jdGlvbiBtZnNSZWFkIChwYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0gYXBwbHlEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCBkZWZhdWx0T3B0aW9ucylcblxuICAgIHJldHVybiB7XG4gICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdOiBhc3luYyBmdW5jdGlvbiAqIHJlYWQgKCkge1xuICAgICAgICBjb25zdCBtZnNQYXRoID0gYXdhaXQgdG9NZnNQYXRoKGNvbnRleHQsIHBhdGgpXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4cG9ydGVyKG1mc1BhdGgubWZzUGF0aCwgY29udGV4dC5pcGxkKVxuXG4gICAgICAgIGlmIChyZXN1bHQudW5peGZzLnR5cGUgIT09ICdmaWxlJykge1xuICAgICAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKGAke3BhdGh9IHdhcyBub3QgYSBmaWxlYCksICdFUlJfTk9UX0ZJTEUnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXN1bHQuY29udGVudCkge1xuICAgICAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKGBDb3VsZCBub3QgbG9hZCBjb250ZW50IHN0cmVhbSBmcm9tICR7cGF0aH1gKSwgJ0VSUl9OT19DT05URU5UJylcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgYnVmIG9mIHJlc3VsdC5jb250ZW50KHtcbiAgICAgICAgICBvZmZzZXQ6IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgICAgIGxlbmd0aDogb3B0aW9ucy5sZW5ndGhcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB5aWVsZCBidWZcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGV4cG9ydGVyID0gcmVxdWlyZSgnaXBmcy11bml4ZnMtZXhwb3J0ZXInKVxuY29uc3QgYXBwbHlEZWZhdWx0T3B0aW9ucyA9IHJlcXVpcmUoJy4vdXRpbHMvYXBwbHktZGVmYXVsdC1vcHRpb25zJylcbmNvbnN0IHRvTWZzUGF0aCA9IHJlcXVpcmUoJy4vdXRpbHMvdG8tbWZzLXBhdGgnKVxuY29uc3Qge1xuICBGSUxFX1NFUEFSQVRPUixcbiAgRklMRV9UWVBFU1xufSA9IHJlcXVpcmUoJy4vdXRpbHMvY29uc3RhbnRzJylcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG5cbn1cblxuY29uc3QgdG9PdXRwdXQgPSAoZnNFbnRyeSkgPT4ge1xuICBsZXQgdHlwZSA9IDBcbiAgbGV0IHNpemUgPSBmc0VudHJ5Lm5vZGUuc2l6ZSB8fCBmc0VudHJ5Lm5vZGUubGVuZ3RoXG5cbiAgaWYgKGZzRW50cnkudW5peGZzKSB7XG4gICAgc2l6ZSA9IGZzRW50cnkudW5peGZzLmZpbGVTaXplKClcbiAgICB0eXBlID0gRklMRV9UWVBFU1tmc0VudHJ5LnVuaXhmcy50eXBlXVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjaWQ6IGZzRW50cnkuY2lkLFxuICAgIG5hbWU6IGZzRW50cnkubmFtZSxcbiAgICB0eXBlLFxuICAgIHNpemVcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChjb250ZXh0KSA9PiB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiAqIG1mc0xzIChwYXRoID0gRklMRV9TRVBBUkFUT1IsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ29iamVjdCcgJiYgIShwYXRoIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgb3B0aW9ucyA9IHBhdGhcbiAgICAgIHBhdGggPSBGSUxFX1NFUEFSQVRPUlxuICAgIH1cblxuICAgIG9wdGlvbnMgPSBhcHBseURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKVxuXG4gICAgY29uc3QgbWZzUGF0aCA9IGF3YWl0IHRvTWZzUGF0aChjb250ZXh0LCBwYXRoKVxuICAgIGNvbnN0IGZzRGlyID0gYXdhaXQgZXhwb3J0ZXIobWZzUGF0aC5tZnNQYXRoLCBjb250ZXh0LmlwbGQpXG5cbiAgICAvLyBzaW5nbGUgZmlsZS9ub2RlXG4gICAgaWYgKCFmc0Rpci51bml4ZnMgfHwgIWZzRGlyLnVuaXhmcy50eXBlLmluY2x1ZGVzKCdkaXJlY3RvcnknKSkge1xuICAgICAgeWllbGQgdG9PdXRwdXQoZnNEaXIpXG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGRpcmVjdG9yeSwgcGVyaGFwcyBzaGFyZGVkXG4gICAgZm9yIGF3YWl0IChjb25zdCBmc0VudHJ5IG9mIGZzRGlyLmNvbnRlbnQob3B0aW9ucykpIHtcbiAgICAgIHlpZWxkIHRvT3V0cHV0KGZzRW50cnkpXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgYXBwbHlEZWZhdWx0T3B0aW9ucyA9IHJlcXVpcmUoJy4vdXRpbHMvYXBwbHktZGVmYXVsdC1vcHRpb25zJylcbmNvbnN0IHRvU291cmNlcyA9IHJlcXVpcmUoJy4vdXRpbHMvdG8tc291cmNlcycpXG5jb25zdCBjcCA9IHJlcXVpcmUoJy4vY3AnKVxuY29uc3Qgcm0gPSByZXF1aXJlKCcuL3JtJylcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHBhcmVudHM6IGZhbHNlLFxuICByZWN1cnNpdmU6IGZhbHNlLFxuICBmbHVzaDogdHJ1ZSxcbiAgZm9ybWF0OiAnZGFnLXBiJyxcbiAgaGFzaEFsZzogJ3NoYTItMjU2JyxcbiAgc2hhcmRTcGxpdFRocmVzaG9sZDogMTAwMFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChjb250ZXh0KSA9PiB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBtZnNNdiAoLi4uYXJncykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICBhcmdzID0gYXJnc1swXS5jb25jYXQoYXJncy5zbGljZSgxKSlcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBzb3VyY2VzXG4gICAgfSA9IGF3YWl0IHRvU291cmNlcyhjb250ZXh0LCBhcmdzKVxuICAgIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRPcHRpb25zKGFyZ3MsIGRlZmF1bHRPcHRpb25zKVxuXG4gICAgY29uc3QgY3BBcmdzID0gc291cmNlc1xuICAgICAgLm1hcChzb3VyY2UgPT4gc291cmNlLnBhdGgpLmNvbmNhdChvcHRpb25zKVxuXG4gICAgLy8gcmVtb3ZlIHRoZSBsYXN0IHNvdXJjZSBhcyBpdCdsbCBiZSB0aGUgZGVzdGluYXRpb25cbiAgICBjb25zdCBybUFyZ3MgPSBzb3VyY2VzXG4gICAgICAuc2xpY2UoMCwgLTEpXG4gICAgICAubWFwKHNvdXJjZSA9PiBzb3VyY2UucGF0aClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7XG4gICAgICAgIHJlY3Vyc2l2ZTogdHJ1ZVxuICAgICAgfSkpXG5cbiAgICBhd2FpdCBjcChjb250ZXh0KS5hcHBseShudWxsLCBjcEFyZ3MpXG4gICAgYXdhaXQgcm0oY29udGV4dCkuYXBwbHkobnVsbCwgcm1BcmdzKVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgYXBwbHlEZWZhdWx0T3B0aW9ucyA9IHJlcXVpcmUoJy4vdXRpbHMvYXBwbHktZGVmYXVsdC1vcHRpb25zJylcbmNvbnN0IHRvTWZzUGF0aCA9IHJlcXVpcmUoJy4vdXRpbHMvdG8tbWZzLXBhdGgnKVxuY29uc3QgZXhwb3J0ZXIgPSByZXF1aXJlKCdpcGZzLXVuaXhmcy1leHBvcnRlcicpXG5jb25zdCBsb2cgPSByZXF1aXJlKCdkZWJ1ZycpKCdpcGZzOm1mczpzdGF0JylcbmNvbnN0IGVyckNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICB3aXRoTG9jYWw6IGZhbHNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKGNvbnRleHQpID0+IHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIG1mc1N0YXQgKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gYXBwbHlEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCBkZWZhdWx0T3B0aW9ucylcblxuICAgIGxvZyhgRmV0Y2hpbmcgc3RhdHMgZm9yICR7cGF0aH1gKVxuXG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIGNpZCxcbiAgICAgIG1mc1BhdGhcbiAgICB9ID0gYXdhaXQgdG9NZnNQYXRoKGNvbnRleHQsIHBhdGgpXG5cbiAgICBsZXQgZXhwb3J0UGF0aCA9IHR5cGUgPT09ICdpcGZzJyAmJiBjaWQgPyBjaWQgOiBtZnNQYXRoXG4gICAgbGV0IGZpbGVcblxuICAgIHRyeSB7XG4gICAgICBmaWxlID0gYXdhaXQgZXhwb3J0ZXIoZXhwb3J0UGF0aCwgY29udGV4dC5pcGxkKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnRVJSX05PVF9GT1VORCcpIHtcbiAgICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoYCR7cGF0aH0gZG9lcyBub3QgZXhpc3RgKSwgJ0VSUl9OT1RfRk9VTkQnKVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICBpZiAoIXN0YXR0ZXJzW2ZpbGUuY2lkLmNvZGVjXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc3RhdCBjb2RlYyAke2ZpbGUuY2lkLmNvZGVjfWApXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXR0ZXJzW2ZpbGUuY2lkLmNvZGVjXShmaWxlLCBvcHRpb25zKVxuICB9XG59XG5cbmNvbnN0IHN0YXR0ZXJzID0ge1xuICByYXc6IChmaWxlKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNpZDogZmlsZS5jaWQsXG4gICAgICBzaXplOiBmaWxlLm5vZGUubGVuZ3RoLFxuICAgICAgY3VtdWxhdGl2ZVNpemU6IGZpbGUubm9kZS5sZW5ndGgsXG4gICAgICBibG9ja3M6IDAsXG4gICAgICB0eXBlOiAnZmlsZScsIC8vIGZvciBnbyBjb21wYXRpYmlsaXR5XG4gICAgICBsb2NhbDogdW5kZWZpbmVkLFxuICAgICAgc2l6ZUxvY2FsOiB1bmRlZmluZWQsXG4gICAgICB3aXRoTG9jYWxpdHk6IGZhbHNlXG4gICAgfVxuICB9LFxuICAnZGFnLXBiJzogKGZpbGUpID0+IHtcbiAgICBsZXQgYmxvY2tzID0gZmlsZS5ub2RlLkxpbmtzLmxlbmd0aFxuICAgIGxldCBzaXplID0gZmlsZS5ub2RlLnNpemVcbiAgICBsZXQgY3VtdWxhdGl2ZVNpemUgPSBmaWxlLm5vZGUuc2l6ZVxuICAgIGxldCBub2RlVHlwZSA9IG51bGxcblxuICAgIGlmIChmaWxlLnVuaXhmcykge1xuICAgICAgc2l6ZSA9IGZpbGUudW5peGZzLmZpbGVTaXplKClcbiAgICAgIG5vZGVUeXBlID0gZmlsZS51bml4ZnMudHlwZVxuXG4gICAgICBpZiAobm9kZVR5cGUuaW5jbHVkZXMoJ2RpcmVjdG9yeScpKSB7XG4gICAgICAgIHNpemUgPSAwXG4gICAgICAgIGN1bXVsYXRpdmVTaXplID0gZmlsZS5ub2RlLnNpemVcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGVUeXBlID09PSAnZmlsZScpIHtcbiAgICAgICAgYmxvY2tzID0gZmlsZS51bml4ZnMuYmxvY2tTaXplcy5sZW5ndGhcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2lkOiBmaWxlLmNpZCxcbiAgICAgIHNpemU6IHNpemUsXG4gICAgICBjdW11bGF0aXZlU2l6ZTogY3VtdWxhdGl2ZVNpemUsXG4gICAgICBibG9ja3M6IGJsb2NrcyxcbiAgICAgIHR5cGU6IG5vZGVUeXBlLFxuICAgICAgbG9jYWw6IHVuZGVmaW5lZCxcbiAgICAgIHNpemVMb2NhbDogdW5kZWZpbmVkLFxuICAgICAgd2l0aExvY2FsaXR5OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgJ2RhZy1jYm9yJzogKGZpbGUpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY2lkOiBmaWxlLmNpZCxcbiAgICAgIGxvY2FsOiB1bmRlZmluZWQsXG4gICAgICBzaXplTG9jYWw6IHVuZGVmaW5lZCxcbiAgICAgIHdpdGhMb2NhbGl0eTogZmFsc2VcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhcHBseURlZmF1bHRPcHRpb25zID0gcmVxdWlyZSgnLi91dGlscy9hcHBseS1kZWZhdWx0LW9wdGlvbnMnKVxuY29uc3Qgc3RhdCA9IHJlcXVpcmUoJy4vc3RhdCcpXG5jb25zdCB7XG4gIEZJTEVfU0VQQVJBVE9SXG59ID0gcmVxdWlyZSgnLi91dGlscy9jb25zdGFudHMnKVxuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gKGNvbnRleHQpID0+IHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIG1mc0ZsdXNoIChwYXRoID0gRklMRV9TRVBBUkFUT1IsIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBhcHBseURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKVxuXG4gICAgYXdhaXQgc3RhdChjb250ZXh0KShwYXRoLCBvcHRpb25zKVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZXJyQ29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcbmNvbnN0IGxvZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2lwZnM6bWZzOm1rZGlyJylcbmNvbnN0IGV4cG9ydGVyID0gcmVxdWlyZSgnaXBmcy11bml4ZnMtZXhwb3J0ZXInKVxuY29uc3QgY3JlYXRlTm9kZSA9IHJlcXVpcmUoJy4vdXRpbHMvY3JlYXRlLW5vZGUnKVxuY29uc3QgdG9QYXRoQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4vdXRpbHMvdG8tcGF0aC1jb21wb25lbnRzJylcbmNvbnN0IHVwZGF0ZU1mc1Jvb3QgPSByZXF1aXJlKCcuL3V0aWxzL3VwZGF0ZS1tZnMtcm9vdCcpXG5jb25zdCB1cGRhdGVUcmVlID0gcmVxdWlyZSgnLi91dGlscy91cGRhdGUtdHJlZScpXG5jb25zdCBhZGRMaW5rID0gcmVxdWlyZSgnLi91dGlscy9hZGQtbGluaycpXG5jb25zdCB3aXRoTWZzUm9vdCA9IHJlcXVpcmUoJy4vdXRpbHMvd2l0aC1tZnMtcm9vdCcpXG5jb25zdCBhcHBseURlZmF1bHRPcHRpb25zID0gcmVxdWlyZSgnLi91dGlscy9hcHBseS1kZWZhdWx0LW9wdGlvbnMnKVxuY29uc3Qge1xuICBGSUxFX1NFUEFSQVRPUlxufSA9IHJlcXVpcmUoJy4vdXRpbHMvY29uc3RhbnRzJylcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHBhcmVudHM6IGZhbHNlLFxuICBoYXNoQWxnOiAnc2hhMi0yNTYnLFxuICBjaWRWZXJzaW9uOiAwLFxuICBzaGFyZFNwbGl0VGhyZXNob2xkOiAxMDAwLFxuICBmb3JtYXQ6ICdkYWctcGInLFxuICBmbHVzaDogdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChjb250ZXh0KSA9PiB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBtZnNNa2RpciAocGF0aCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBhcHBseURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKVxuXG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHBhdGggZ2l2ZW4gdG8gTWtkaXInKVxuICAgIH1cblxuICAgIHBhdGggPSBwYXRoLnRyaW0oKVxuXG4gICAgaWYgKHBhdGggPT09IEZJTEVfU0VQQVJBVE9SKSB7XG4gICAgICBpZiAob3B0aW9ucy5wYXJlbnRzKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcihgY2Fubm90IGNyZWF0ZSBkaXJlY3RvcnkgJyR7RklMRV9TRVBBUkFUT1J9JzogQWxyZWFkeSBleGlzdHNgKSwgJ0VSUl9JTlZBTElEX1BBVEgnKVxuICAgIH1cblxuICAgIGlmIChwYXRoLnN1YnN0cmluZygwLCAxKSAhPT0gRklMRV9TRVBBUkFUT1IpIHtcbiAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdwYXRocyBtdXN0IHN0YXJ0IHdpdGggYSBsZWFkaW5nIC8nKSwgJ0VSUl9JTlZBTElEX1BBVEgnKVxuICAgIH1cblxuICAgIGxvZyhgQ3JlYXRpbmcgJHtwYXRofWApXG5cbiAgICBjb25zdCBwYXRoQ29tcG9uZW50cyA9IHRvUGF0aENvbXBvbmVudHMocGF0aClcblxuICAgIGlmIChwYXRoQ29tcG9uZW50c1swXSA9PT0gJ2lwZnMnKSB7XG4gICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcihcInBhdGggY2Fubm90IGhhdmUgdGhlIHByZWZpeCAnaXBmcydcIiksICdFUlJfSU5WQUxJRF9QQVRIJylcbiAgICB9XG5cbiAgICBsZXQgcm9vdCA9IGF3YWl0IHdpdGhNZnNSb290KGNvbnRleHQpXG4gICAgbGV0IHBhcmVudFxuICAgIGxldCB0cmFpbCA9IFtdXG4gICAgY29uc3QgZW1wdHlEaXIgPSBhd2FpdCBjcmVhdGVOb2RlKGNvbnRleHQsICdkaXJlY3RvcnknLCBvcHRpb25zKVxuXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBjb250YWluaW5nIGZvbGRlciBleGlzdHMsIGNyZWF0aW5nIGl0IGlmIG5lY2Vzc2FyeVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHBhdGhDb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdWJQYXRoQ29tcG9uZW50cyA9IHBhdGhDb21wb25lbnRzLnNsaWNlKDAsIGkpXG4gICAgICBjb25zdCBzdWJQYXRoID0gYC9pcGZzLyR7cm9vdH0vJHtzdWJQYXRoQ29tcG9uZW50cy5qb2luKCcvJyl9YFxuXG4gICAgICB0cnkge1xuICAgICAgICBwYXJlbnQgPSBhd2FpdCBleHBvcnRlcihzdWJQYXRoLCBjb250ZXh0LmlwbGQpXG4gICAgICAgIGxvZyhgJHtzdWJQYXRofSBleGlzdGVkYClcbiAgICAgICAgbG9nKGAke3N1YlBhdGh9IGhhZCBjaGlsZHJlbiAke3BhcmVudC5ub2RlLkxpbmtzLm1hcChsaW5rID0+IGxpbmsuTmFtZSl9YClcblxuICAgICAgICBpZiAoaSA9PT0gcGF0aENvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMucGFyZW50cykge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2ZpbGUgYWxyZWFkeSBleGlzdHMnKSwgJ0VSUl9BTFJFQURZX0VYSVNUUycpXG4gICAgICAgIH1cblxuICAgICAgICB0cmFpbC5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBwYXJlbnQubmFtZSxcbiAgICAgICAgICBjaWQ6IHBhcmVudC5jaWRcbiAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdFUlJfTk9UX0ZPVU5EJykge1xuICAgICAgICAgIGlmIChpIDwgcGF0aENvbXBvbmVudHMubGVuZ3RoICYmICFvcHRpb25zLnBhcmVudHMpIHtcbiAgICAgICAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKGBJbnRlcm1lZGlhdGUgZGlyZWN0b3J5IHBhdGggJHtzdWJQYXRofSBkb2VzIG5vdCBleGlzdCwgdXNlIHRoZSAtcCBmbGFnIHRvIGNyZWF0ZSBpdGApLCAnRVJSX05PVF9GT1VORCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWRkIHRoZSBpbnRlcm1lZGlhdGUgZGlyZWN0b3J5XG4gICAgICAgICAgYXdhaXQgYWRkRW1wdHlEaXIoY29udGV4dCwgc3ViUGF0aENvbXBvbmVudHNbc3ViUGF0aENvbXBvbmVudHMubGVuZ3RoIC0gMV0sIGVtcHR5RGlyLCB0cmFpbFt0cmFpbC5sZW5ndGggLSAxXSwgdHJhaWwsIG9wdGlvbnMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgYW4gZW1wdHkgZGlyIHRvIHRoZSBsYXN0IHBhdGggY29tcG9uZW50XG4gICAgLy8gYXdhaXQgYWRkRW1wdHlEaXIoY29udGV4dCwgcGF0aENvbXBvbmVudHNbcGF0aENvbXBvbmVudHMubGVuZ3RoIC0gMV0sIGVtcHR5RGlyLCBwYXJlbnQsIHRyYWlsKVxuXG4gICAgLy8gdXBkYXRlIHRoZSB0cmVlIGZyb20gdGhlIGxlYWYgdG8gdGhlIHJvb3RcbiAgICBjb25zdCBuZXdSb290Q2lkID0gYXdhaXQgdXBkYXRlVHJlZShjb250ZXh0LCB0cmFpbCwgb3B0aW9ucylcblxuICAgIC8vIFVwZGF0ZSB0aGUgTUZTIHJlY29yZCB3aXRoIHRoZSBuZXcgQ0lEIGZvciB0aGUgcm9vdCBvZiB0aGUgdHJlZVxuICAgIGF3YWl0IHVwZGF0ZU1mc1Jvb3QoY29udGV4dCwgbmV3Um9vdENpZClcbiAgfVxufVxuXG5jb25zdCBhZGRFbXB0eURpciA9IGFzeW5jIChjb250ZXh0LCBjaGlsZE5hbWUsIGVtcHR5RGlyLCBwYXJlbnQsIHRyYWlsLCBvcHRpb25zKSA9PiB7XG4gIGxvZyhgQWRkaW5nIGVtcHR5IGRpciBjYWxsZWQgJHtjaGlsZE5hbWV9IHRvICR7cGFyZW50LmNpZH1gKVxuXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFkZExpbmsoY29udGV4dCwge1xuICAgIHBhcmVudDogcGFyZW50Lm5vZGUsXG4gICAgcGFyZW50Q2lkOiBwYXJlbnQuY2lkLFxuICAgIHNpemU6IGVtcHR5RGlyLm5vZGUuc2l6ZSxcbiAgICBjaWQ6IGVtcHR5RGlyLmNpZCxcbiAgICBuYW1lOiBjaGlsZE5hbWUsXG4gICAgZm9ybWF0OiBvcHRpb25zLmZvcm1hdCxcbiAgICBoYXNoQWxnOiBvcHRpb25zLmhhc2hBbGcsXG4gICAgY2lkVmVyc2lvbjogb3B0aW9ucy5jaWRWZXJzaW9uXG4gIH0pXG5cbiAgdHJhaWxbdHJhaWwubGVuZ3RoIC0gMV0uY2lkID0gcmVzdWx0LmNpZFxuXG4gIHRyYWlsLnB1c2goe1xuICAgIG5hbWU6IGNoaWxkTmFtZSxcbiAgICBjaWQ6IGVtcHR5RGlyLmNpZFxuICB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGVyckNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5jb25zdCB1cGRhdGVUcmVlID0gcmVxdWlyZSgnLi91dGlscy91cGRhdGUtdHJlZScpXG5jb25zdCB1cGRhdGVNZnNSb290ID0gcmVxdWlyZSgnLi91dGlscy91cGRhdGUtbWZzLXJvb3QnKVxuY29uc3QgdG9Tb3VyY2VzID0gcmVxdWlyZSgnLi91dGlscy90by1zb3VyY2VzJylcbmNvbnN0IHJlbW92ZUxpbmsgPSByZXF1aXJlKCcuL3V0aWxzL3JlbW92ZS1saW5rJylcbmNvbnN0IHRvTWZzUGF0aCA9IHJlcXVpcmUoJy4vdXRpbHMvdG8tbWZzLXBhdGgnKVxuY29uc3QgdG9UcmFpbCA9IHJlcXVpcmUoJy4vdXRpbHMvdG8tdHJhaWwnKVxuY29uc3QgYXBwbHlEZWZhdWx0T3B0aW9ucyA9IHJlcXVpcmUoJy4vdXRpbHMvYXBwbHktZGVmYXVsdC1vcHRpb25zJylcbmNvbnN0IHtcbiAgRklMRV9TRVBBUkFUT1Jcbn0gPSByZXF1aXJlKCcuL3V0aWxzL2NvbnN0YW50cycpXG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICByZWN1cnNpdmU6IGZhbHNlLFxuICBjaWRWZXJzaW9uOiAwLFxuICBoYXNoQWxnOiAnc2hhMi0yNTYnLFxuICBmb3JtYXQ6ICdkYWctcGInLFxuICBmbHVzaDogdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChjb250ZXh0KSA9PiB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBtZnNSbSAoKSB7XG4gICAgY29uc3QgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKVxuXG4gICAgY29uc3Qge1xuICAgICAgc291cmNlc1xuICAgIH0gPSBhd2FpdCB0b1NvdXJjZXMoY29udGV4dCwgYXJncywgZGVmYXVsdE9wdGlvbnMpXG4gICAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdE9wdGlvbnMoYXJncywgZGVmYXVsdE9wdGlvbnMpXG5cbiAgICBpZiAoIXNvdXJjZXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignUGxlYXNlIHN1cHBseSBhdCBsZWFzdCBvbmUgcGF0aCB0byByZW1vdmUnKSwgJ0VSUl9JTlZBTElEX1BBUkFNUycpXG4gICAgfVxuXG4gICAgc291cmNlcy5mb3JFYWNoKHNvdXJjZSA9PiB7XG4gICAgICBpZiAoc291cmNlLnBhdGggPT09IEZJTEVfU0VQQVJBVE9SKSB7XG4gICAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdDYW5ub3QgZGVsZXRlIHJvb3QnKSwgJ0VSUl9JTlZBTElEX1BBUkFNUycpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgIGF3YWl0IHJlbW92ZVBhdGgoY29udGV4dCwgc291cmNlLnBhdGgsIG9wdGlvbnMpXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHJlbW92ZVBhdGggPSBhc3luYyAoY29udGV4dCwgcGF0aCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBtZnNQYXRoID0gYXdhaXQgdG9NZnNQYXRoKGNvbnRleHQsIHBhdGgpXG4gIGNvbnN0IHRyYWlsID0gYXdhaXQgdG9UcmFpbChjb250ZXh0LCBtZnNQYXRoLm1mc1BhdGgsIG9wdGlvbnMpXG4gIGNvbnN0IGNoaWxkID0gdHJhaWwucG9wKClcbiAgY29uc3QgcGFyZW50ID0gdHJhaWxbdHJhaWwubGVuZ3RoIC0gMV1cblxuICBpZiAoIXBhcmVudCkge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKGAke3BhdGh9IGRvZXMgbm90IGV4aXN0YCksICdFUlJfTk9UX0ZPVU5EJylcbiAgfVxuXG4gIGlmIChjaGlsZC50eXBlID09PSAnZGlyZWN0b3J5JyAmJiAhb3B0aW9ucy5yZWN1cnNpdmUpIHtcbiAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcihgJHtwYXRofSBpcyBhIGRpcmVjdG9yeSwgdXNlIC1yIHRvIHJlbW92ZSBkaXJlY3Rvcmllc2ApLCAnRVJSX1dBU19ESVInKVxuICB9XG5cbiAgY29uc3Qge1xuICAgIGNpZFxuICB9ID0gYXdhaXQgcmVtb3ZlTGluayhjb250ZXh0LCB7XG4gICAgcGFyZW50Q2lkOiBwYXJlbnQuY2lkLFxuICAgIG5hbWU6IGNoaWxkLm5hbWUsXG4gICAgZm9ybWF0OiBvcHRpb25zLmZvcm1hdCxcbiAgICBoYXNoQWxnOiBvcHRpb25zLmhhc2hBbGcsXG4gICAgY2lkVmVyc2lvbjogb3B0aW9ucy5jaWRWZXJzaW9uLFxuICAgIGZsdXNoOiBvcHRpb25zLmZsdXNoXG4gIH0pXG5cbiAgcGFyZW50LmNpZCA9IGNpZFxuXG4gIC8vIHVwZGF0ZSB0aGUgdHJlZSB3aXRoIHRoZSBuZXcgY2hpbGRcbiAgY29uc3QgbmV3Um9vdENpZCA9IGF3YWl0IHVwZGF0ZVRyZWUoY29udGV4dCwgdHJhaWwsIG9wdGlvbnMpXG5cbiAgLy8gVXBkYXRlIHRoZSBNRlMgcmVjb3JkIHdpdGggdGhlIG5ldyBDSUQgZm9yIHRoZSByb290IG9mIHRoZSB0cmVlXG4gIGF3YWl0IHVwZGF0ZU1mc1Jvb3QoY29udGV4dCwgbmV3Um9vdENpZClcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBsb2cgPSByZXF1aXJlKCdkZWJ1ZycpKCdpcGZzOm1mczp3cml0ZScpXG5jb25zdCBpbXBvcnRlciA9IHJlcXVpcmUoJ2lwZnMtdW5peGZzLWltcG9ydGVyJylcbmNvbnN0IHN0YXQgPSByZXF1aXJlKCcuL3N0YXQnKVxuY29uc3QgbWtkaXIgPSByZXF1aXJlKCcuL21rZGlyJylcbmNvbnN0IGFkZExpbmsgPSByZXF1aXJlKCcuL3V0aWxzL2FkZC1saW5rJylcbmNvbnN0IGFwcGx5RGVmYXVsdE9wdGlvbnMgPSByZXF1aXJlKCcuL3V0aWxzL2FwcGx5LWRlZmF1bHQtb3B0aW9ucycpXG5jb25zdCBjcmVhdGVMb2NrID0gcmVxdWlyZSgnLi91dGlscy9jcmVhdGUtbG9jaycpXG5jb25zdCB0b0FzeW5jSXRlcmF0b3IgPSByZXF1aXJlKCcuL3V0aWxzL3RvLWFzeW5jLWl0ZXJhdG9yJylcbmNvbnN0IHRvTWZzUGF0aCA9IHJlcXVpcmUoJy4vdXRpbHMvdG8tbWZzLXBhdGgnKVxuY29uc3QgdG9QYXRoQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4vdXRpbHMvdG8tcGF0aC1jb21wb25lbnRzJylcbmNvbnN0IHRvVHJhaWwgPSByZXF1aXJlKCcuL3V0aWxzL3RvLXRyYWlsJylcbmNvbnN0IHVwZGF0ZVRyZWUgPSByZXF1aXJlKCcuL3V0aWxzL3VwZGF0ZS10cmVlJylcbmNvbnN0IHVwZGF0ZU1mc1Jvb3QgPSByZXF1aXJlKCcuL3V0aWxzL3VwZGF0ZS1tZnMtcm9vdCcpXG5jb25zdCBlcnJDb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuY29uc3Qge1xuICBNQVhfQ0hVTktfU0laRVxufSA9IHJlcXVpcmUoJy4vdXRpbHMvY29uc3RhbnRzJylcbmNvbnN0IGxhc3QgPSByZXF1aXJlKCdhc3luYy1pdGVyYXRvci1sYXN0JylcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIG9mZnNldDogMCwgLy8gdGhlIG9mZnNldCBpbiB0aGUgZmlsZSB0byBiZWdpbiB3cml0aW5nXG4gIGxlbmd0aDogdW5kZWZpbmVkLCAvLyBob3cgbWFueSBieXRlcyBmcm9tIHRoZSBpbmNvbWluZyBidWZmZXIgdG8gd3JpdGVcbiAgY3JlYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byBjcmVhdGUgdGhlIGZpbGUgaWYgaXQgZG9lcyBub3QgZXhpc3RcbiAgdHJ1bmNhdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHRydW5jYXRlIHRoZSBmaWxlIGZpcnN0XG4gIHJhd0xlYXZlczogZmFsc2UsXG4gIHJlZHVjZVNpbmdsZUxlYWZUb1NlbGY6IGZhbHNlLFxuICBjaWRWZXJzaW9uOiAwLFxuICBoYXNoQWxnOiAnc2hhMi0yNTYnLFxuICBmb3JtYXQ6ICdkYWctcGInLFxuICBwYXJlbnRzOiBmYWxzZSwgLy8gd2hldGhlciB0byBjcmVhdGUgaW50ZXJtZWRpYXRlIGRpcmVjdG9yaWVzIGlmIHRoZXkgZG8gbm90IGV4aXN0XG4gIHByb2dyZXNzOiAoKSA9PiB7fSxcbiAgc3RyYXRlZ3k6ICd0cmlja2xlJyxcbiAgZmx1c2g6IHRydWUsXG4gIGxlYWZUeXBlOiAncmF3JyxcbiAgc2hhcmRTcGxpdFRocmVzaG9sZDogMTAwMFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChjb250ZXh0KSA9PiB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBtZnNXcml0ZSAocGF0aCwgY29udGVudCwgb3B0aW9ucykge1xuICAgIGxvZygnSGVsbG8gd29ybGQsIHdyaXRpbmcnLCBwYXRoLCBjb250ZW50LCBvcHRpb25zKVxuICAgIG9wdGlvbnMgPSBhcHBseURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKVxuXG4gICAgbGV0IHNvdXJjZSwgZGVzdGluYXRpb24sIHBhcmVudFxuICAgIGxvZygnUmVhZGluZyBzb3VyY2UsIGRlc3RpbmF0aW9uIGFuZCBwYXJlbnQnKVxuICAgIGF3YWl0IGNyZWF0ZUxvY2soKS5yZWFkTG9jayhhc3luYyAoKSA9PiB7XG4gICAgICBzb3VyY2UgPSBhd2FpdCB0b0FzeW5jSXRlcmF0b3IoY29udGVudCwgb3B0aW9ucylcbiAgICAgIGRlc3RpbmF0aW9uID0gYXdhaXQgdG9NZnNQYXRoKGNvbnRleHQsIHBhdGgpXG4gICAgICBwYXJlbnQgPSBhd2FpdCB0b01mc1BhdGgoY29udGV4dCwgZGVzdGluYXRpb24ubWZzRGlyZWN0b3J5KVxuICAgIH0pKClcbiAgICBsb2coJ1JlYWQgc291cmNlLCBkZXN0aW5hdGlvbiBhbmQgcGFyZW50JylcbiAgICBpZiAoIW9wdGlvbnMucGFyZW50cyAmJiAhcGFyZW50LmV4aXN0cykge1xuICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2RpcmVjdG9yeSBkb2VzIG5vdCBleGlzdCcpLCAnRVJSX05PX0VYSVNUJylcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMuY3JlYXRlICYmICFkZXN0aW5hdGlvbi5leGlzdHMpIHtcbiAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdmaWxlIGRvZXMgbm90IGV4aXN0JyksICdFUlJfTk9fRVhJU1QnKVxuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVPckltcG9ydChjb250ZXh0LCBwYXRoLCBzb3VyY2UsIGRlc3RpbmF0aW9uLCBvcHRpb25zKVxuICB9XG59XG5cbmNvbnN0IHVwZGF0ZU9ySW1wb3J0ID0gYXN5bmMgKGNvbnRleHQsIHBhdGgsIHNvdXJjZSwgZGVzdGluYXRpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgY2hpbGQgPSBhd2FpdCB3cml0ZShjb250ZXh0LCBzb3VyY2UsIGRlc3RpbmF0aW9uLCBvcHRpb25zKVxuXG4gIC8vIFRoZSBzbG93IGJpdCBpcyBkb25lLCBub3cgYWRkIG9yIHJlcGxhY2UgdGhlIERBR0xpbmsgaW4gdGhlIGNvbnRhaW5pbmcgZGlyZWN0b3J5XG4gIC8vIHJlLXJlYWRpbmcgdGhlIHBhdGggdG8gdGhlIGNvbnRhaW5pbmcgZm9sZGVyIGluIGNhc2UgaXQgaGFzIGNoYW5nZWQgaW4gdGhlIGludGVyaW1cbiAgYXdhaXQgY3JlYXRlTG9jaygpLndyaXRlTG9jayhhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcGF0aENvbXBvbmVudHMgPSB0b1BhdGhDb21wb25lbnRzKHBhdGgpXG4gICAgY29uc3QgZmlsZU5hbWUgPSBwYXRoQ29tcG9uZW50cy5wb3AoKVxuICAgIGxldCBwYXJlbnRFeGlzdHMgPSBmYWxzZVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHN0YXQoY29udGV4dCkoYC8ke3BhdGhDb21wb25lbnRzLmpvaW4oJy8nKX1gLCBvcHRpb25zKVxuICAgICAgcGFyZW50RXhpc3RzID0gdHJ1ZVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5jb2RlICE9PSAnRVJSX05PVF9GT1VORCcpIHtcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYXJlbnRFeGlzdHMpIHtcbiAgICAgIGF3YWl0IG1rZGlyKGNvbnRleHQpKGAvJHtwYXRoQ29tcG9uZW50cy5qb2luKCcvJyl9YCwgb3B0aW9ucylcbiAgICB9XG5cbiAgICAvLyBnZXQgYW4gdXBkYXRlZCBtZnMgcGF0aCBpbiBjYXNlIHRoZSByb290IGNoYW5nZWQgd2hpbGUgd2Ugd2VyZSB3cml0aW5nXG4gICAgY29uc3QgdXBkYXRlZFBhdGggPSBhd2FpdCB0b01mc1BhdGgoY29udGV4dCwgcGF0aClcbiAgICBjb25zdCB0cmFpbCA9IGF3YWl0IHRvVHJhaWwoY29udGV4dCwgdXBkYXRlZFBhdGgubWZzRGlyZWN0b3J5LCBvcHRpb25zKVxuICAgIGNvbnN0IHBhcmVudCA9IHRyYWlsW3RyYWlsLmxlbmd0aCAtIDFdXG5cbiAgICBpZiAoIXBhcmVudC50eXBlLmluY2x1ZGVzKCdkaXJlY3RvcnknKSkge1xuICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoYGNhbm5vdCB3cml0ZSB0byAke3BhcmVudC5uYW1lfTogTm90IGEgZGlyZWN0b3J5YCksICdFUlJfTk9UX0FfRElSRUNUT1JZJylcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnROb2RlID0gYXdhaXQgY29udGV4dC5pcGxkLmdldChwYXJlbnQuY2lkKVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWRkTGluayhjb250ZXh0LCB7XG4gICAgICBwYXJlbnQ6IHBhcmVudE5vZGUsXG4gICAgICBuYW1lOiBmaWxlTmFtZSxcbiAgICAgIGNpZDogY2hpbGQuY2lkLFxuICAgICAgc2l6ZTogY2hpbGQuc2l6ZSxcbiAgICAgIGZsdXNoOiBvcHRpb25zLmZsdXNoLFxuICAgICAgc2hhcmRTcGxpdFRocmVzaG9sZDogb3B0aW9ucy5zaGFyZFNwbGl0VGhyZXNob2xkLFxuICAgICAgZm9ybWF0OiBvcHRpb25zLmZvcm1hdCxcbiAgICAgIGhhc2hBbGc6IG9wdGlvbnMuaGFzaEFsZyxcbiAgICAgIGNpZFZlcnNpb246IG9wdGlvbnMuY2lkVmVyc2lvblxuICAgIH0pXG5cbiAgICBwYXJlbnQuY2lkID0gcmVzdWx0LmNpZFxuXG4gICAgLy8gdXBkYXRlIHRoZSB0cmVlIHdpdGggdGhlIG5ldyBjaGlsZFxuICAgIGNvbnN0IG5ld1Jvb3RDaWQgPSBhd2FpdCB1cGRhdGVUcmVlKGNvbnRleHQsIHRyYWlsLCBvcHRpb25zKVxuXG4gICAgLy8gVXBkYXRlIHRoZSBNRlMgcmVjb3JkIHdpdGggdGhlIG5ldyBDSUQgZm9yIHRoZSByb290IG9mIHRoZSB0cmVlXG4gICAgYXdhaXQgdXBkYXRlTWZzUm9vdChjb250ZXh0LCBuZXdSb290Q2lkKVxuICB9KSgpXG59XG5cbmNvbnN0IHdyaXRlID0gYXN5bmMgKGNvbnRleHQsIHNvdXJjZSwgZGVzdGluYXRpb24sIG9wdGlvbnMpID0+IHtcbiAgaWYgKGRlc3RpbmF0aW9uLmV4aXN0cykge1xuICAgIGxvZyhgT3ZlcndyaXRpbmcgZmlsZSAke2Rlc3RpbmF0aW9uLmNpZH0gb2Zmc2V0ICR7b3B0aW9ucy5vZmZzZXR9IGxlbmd0aCAke29wdGlvbnMubGVuZ3RofWApXG4gIH0gZWxzZSB7XG4gICAgbG9nKGBXcml0aW5nIGZpbGUgb2Zmc2V0ICR7b3B0aW9ucy5vZmZzZXR9IGxlbmd0aCAke29wdGlvbnMubGVuZ3RofWApXG4gIH1cblxuICBjb25zdCBzb3VyY2VzID0gW11cblxuICAvLyBwYWQgc3RhcnQgb2YgZmlsZSBpZiBuZWNlc3NhcnlcbiAgaWYgKG9wdGlvbnMub2Zmc2V0ID4gMCkge1xuICAgIGlmIChkZXN0aW5hdGlvbi51bml4ZnMgJiYgZGVzdGluYXRpb24udW5peGZzLmZpbGVTaXplKCkgPiBvcHRpb25zLm9mZnNldCkge1xuICAgICAgbG9nKGBXcml0aW5nIGZpcnN0ICR7b3B0aW9ucy5vZmZzZXR9IGJ5dGVzIG9mIG9yaWdpbmFsIGZpbGVgKVxuXG4gICAgICBzb3VyY2VzLnB1c2goXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gZGVzdGluYXRpb24uY29udGVudCh7XG4gICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICBsZW5ndGg6IG9wdGlvbnMub2Zmc2V0XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2coYFdyaXRpbmcgemVyb3MgZm9yIGZpcnN0ICR7b3B0aW9ucy5vZmZzZXR9IGJ5dGVzYClcbiAgICAgIHNvdXJjZXMucHVzaChcbiAgICAgICAgYXN5bmNaZXJvZXMob3B0aW9ucy5vZmZzZXQpXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgc291cmNlcy5wdXNoKFxuICAgIGxpbWl0QXN5bmNTdHJlYW1CeXRlcyhzb3VyY2UsIG9wdGlvbnMubGVuZ3RoKVxuICApXG5cbiAgY29uc3QgY29udGVudCA9IGNvdW50Qnl0ZXNTdHJlYW1lZChjYXRBc3luY0ludGVyYXRvcnMoc291cmNlcyksIChieXRlc1dyaXR0ZW4pID0+IHtcbiAgICBpZiAoZGVzdGluYXRpb24udW5peGZzICYmICFvcHRpb25zLnRydW5jYXRlKSB7XG4gICAgICAvLyBpZiB3ZSd2ZSBkb25lIHJlYWRpbmcgZnJvbSB0aGUgbmV3IHNvdXJjZSBhbmQgd2UgYXJlIG5vdCBnb2luZ1xuICAgICAgLy8gdG8gdHJ1bmNhdGUgdGhlIGZpbGUsIGFkZCB0aGUgZW5kIG9mIHRoZSBleGlzdGluZyBmaWxlIHRvIHRoZSBvdXRwdXRcbiAgICAgIGNvbnN0IGZpbGVTaXplID0gZGVzdGluYXRpb24udW5peGZzLmZpbGVTaXplKClcblxuICAgICAgaWYgKGZpbGVTaXplID4gYnl0ZXNXcml0dGVuKSB7XG4gICAgICAgIGxvZyhgV3JpdGluZyBsYXN0ICR7ZmlsZVNpemUgLSBieXRlc1dyaXR0ZW59IG9mICR7ZmlsZVNpemV9IGJ5dGVzIGZyb20gb3JpZ2luYWwgZmlsZSBzdGFydGluZyBhdCBvZmZzZXQgJHtieXRlc1dyaXR0ZW59YClcblxuICAgICAgICByZXR1cm4gZGVzdGluYXRpb24uY29udGVudCh7XG4gICAgICAgICAgb2Zmc2V0OiBieXRlc1dyaXR0ZW5cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZyhgTm90IHdyaXRpbmcgbGFzdCBieXRlcyBmcm9tIG9yaWdpbmFsIGZpbGVgKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdOiBhc3luYyBmdW5jdGlvbiAqICgpIHt9XG4gICAgfVxuICB9KVxuXG4gIGxldCByZXN1bHQgPSBhd2FpdCBsYXN0KGltcG9ydGVyKFt7XG4gICAgY29udGVudDogY29udGVudFxuICB9XSwgY29udGV4dC5pcGxkLCB7XG4gICAgcHJvZ3Jlc3M6IG9wdGlvbnMucHJvZ3Jlc3MsXG4gICAgaGFzaEFsZzogb3B0aW9ucy5oYXNoQWxnLFxuICAgIGNpZFZlcnNpb246IG9wdGlvbnMuY2lkVmVyc2lvbixcbiAgICBzdHJhdGVneTogb3B0aW9ucy5zdHJhdGVneSxcbiAgICByYXdMZWF2ZXM6IG9wdGlvbnMucmF3TGVhdmVzLFxuICAgIHJlZHVjZVNpbmdsZUxlYWZUb1NlbGY6IG9wdGlvbnMucmVkdWNlU2luZ2xlTGVhZlRvU2VsZixcbiAgICBsZWFmVHlwZTogb3B0aW9ucy5sZWFmVHlwZVxuICB9KSlcblxuICBsb2coYFdyb3RlICR7cmVzdWx0LmNpZH1gKVxuXG4gIHJldHVybiB7XG4gICAgY2lkOiByZXN1bHQuY2lkLFxuICAgIHNpemU6IHJlc3VsdC5zaXplXG4gIH1cbn1cblxuY29uc3QgbGltaXRBc3luY1N0cmVhbUJ5dGVzID0gKHN0cmVhbSwgbGltaXQpID0+IHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uICogX2xpbWl0QXN5bmNTdHJlYW1CeXRlcyAoKSB7XG4gICAgbGV0IGVtaXR0ZWQgPSAwXG5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGJ1ZiBvZiBzdHJlYW0pIHtcbiAgICAgIGVtaXR0ZWQgKz0gYnVmLmxlbmd0aFxuXG4gICAgICBpZiAoZW1pdHRlZCA+IGxpbWl0KSB7XG4gICAgICAgIHlpZWxkIGJ1Zi5zbGljZSgwLCBsaW1pdCAtIGVtaXR0ZWQpXG5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHlpZWxkIGJ1ZlxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBhc3luY1plcm9lcyA9IChjb3VudCwgY2h1bmtTaXplID0gTUFYX0NIVU5LX1NJWkUpID0+IHtcbiAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKGNodW5rU2l6ZSwgMClcblxuICBjb25zdCBzdHJlYW0gPSB7XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTogYXN5bmMgZnVuY3Rpb24gKiBfYXN5bmNaZXJvZXMgKCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgeWllbGQgYnVmLnNsaWNlKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGltaXRBc3luY1N0cmVhbUJ5dGVzKHN0cmVhbSwgY291bnQpXG59XG5cbmNvbnN0IGNhdEFzeW5jSW50ZXJhdG9ycyA9IGFzeW5jIGZ1bmN0aW9uICogKHNvdXJjZXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBidWYgb2Ygc291cmNlc1tpXSgpKSB7XG4gICAgICB5aWVsZCBidWZcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgY291bnRCeXRlc1N0cmVhbWVkID0gYXN5bmMgZnVuY3Rpb24gKiAoc291cmNlLCBub3RpZnkpIHtcbiAgbGV0IHdyb3RlID0gMFxuXG4gIGZvciBhd2FpdCAoY29uc3QgYnVmIG9mIHNvdXJjZSkge1xuICAgIHdyb3RlICs9IGJ1Zi5sZW5ndGhcblxuICAgIHlpZWxkIGJ1ZlxuICB9XG5cbiAgZm9yIGF3YWl0IChjb25zdCBidWYgb2Ygbm90aWZ5KHdyb3RlKSkge1xuICAgIHdyb3RlICs9IGJ1Zi5sZW5ndGhcblxuICAgIHlpZWxkIGJ1ZlxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgbWtkaXIgPSByZXF1aXJlKCcuL21rZGlyJylcbmNvbnN0IGxvZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2lwZnM6bWZzOmNwJylcbmNvbnN0IGVyckNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5jb25zdCB1cGRhdGVUcmVlID0gcmVxdWlyZSgnLi91dGlscy91cGRhdGUtdHJlZScpXG5jb25zdCB1cGRhdGVNZnNSb290ID0gcmVxdWlyZSgnLi91dGlscy91cGRhdGUtbWZzLXJvb3QnKVxuY29uc3QgYWRkTGluayA9IHJlcXVpcmUoJy4vdXRpbHMvYWRkLWxpbmsnKVxuY29uc3QgYXBwbHlEZWZhdWx0T3B0aW9ucyA9IHJlcXVpcmUoJy4vdXRpbHMvYXBwbHktZGVmYXVsdC1vcHRpb25zJylcbmNvbnN0IHRvTWZzUGF0aCA9IHJlcXVpcmUoJy4vdXRpbHMvdG8tbWZzLXBhdGgnKVxuY29uc3QgdG9Tb3VyY2VzQW5kRGVzdGluYXRpb24gPSByZXF1aXJlKCcuL3V0aWxzL3RvLXNvdXJjZXMtYW5kLWRlc3RpbmF0aW9uJylcbmNvbnN0IHRvVHJhaWwgPSByZXF1aXJlKCcuL3V0aWxzL3RvLXRyYWlsJylcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHBhcmVudHM6IGZhbHNlLFxuICBmbHVzaDogdHJ1ZSxcbiAgZm9ybWF0OiAnZGFnLXBiJyxcbiAgaGFzaEFsZzogJ3NoYTItMjU2JyxcbiAgY2lkVmVyc2lvbjogMCxcbiAgc2hhcmRTcGxpdFRocmVzaG9sZDogMTAwMFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChjb250ZXh0KSA9PiB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBtZnNDcCAoLi4uYXJncykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRPcHRpb25zKGFyZ3MsIGRlZmF1bHRPcHRpb25zKVxuICAgIGxldCB7XG4gICAgICBzb3VyY2VzLCBkZXN0aW5hdGlvblxuICAgIH0gPSBhd2FpdCB0b1NvdXJjZXNBbmREZXN0aW5hdGlvbihjb250ZXh0LCBhcmdzKVxuXG4gICAgaWYgKCFzb3VyY2VzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ1BsZWFzZSBzdXBwbHkgYXQgbGVhc3Qgb25lIHNvdXJjZScpLCAnRVJSX0lOVkFMSURfUEFSQU1TJylcbiAgICB9XG5cbiAgICBpZiAoIWRlc3RpbmF0aW9uKSB7XG4gICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignUGxlYXNlIHN1cHBseSBhIGRlc3RpbmF0aW9uJyksICdFUlJfSU5WQUxJRF9QQVJBTVMnKVxuICAgIH1cblxuICAgIG9wdGlvbnMucGFyZW50cyA9IG9wdGlvbnMucCB8fCBvcHRpb25zLnBhcmVudHNcblxuICAgIC8vIG1ha2Ugc3VyZSBhbGwgc291cmNlcyBleGlzdFxuICAgIGNvbnN0IG1pc3NpbmcgPSBzb3VyY2VzLmZpbmQoc291cmNlID0+ICFzb3VyY2UuZXhpc3RzKVxuXG4gICAgaWYgKG1pc3NpbmcpIHtcbiAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKGAke21pc3NpbmcucGF0aH0gZG9lcyBub3QgZXhpc3RgKSwgJ0VSUl9JTlZBTElEX1BBUkFNUycpXG4gICAgfVxuXG4gICAgY29uc3QgZGVzdGluYXRpb25Jc0RpcmVjdG9yeSA9IGlzRGlyZWN0b3J5KGRlc3RpbmF0aW9uKVxuXG4gICAgaWYgKGRlc3RpbmF0aW9uLmV4aXN0cykge1xuICAgICAgbG9nKCdEZXN0aW5hdGlvbiBleGlzdHMnKVxuXG4gICAgICBpZiAoc291cmNlcy5sZW5ndGggPT09IDEgJiYgIWRlc3RpbmF0aW9uSXNEaXJlY3RvcnkpIHtcbiAgICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2RpcmVjdG9yeSBhbHJlYWR5IGhhcyBlbnRyeSBieSB0aGF0IG5hbWUnKSwgJ0VSUl9BTFJFQURZX0VYSVNUUycpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZygnRGVzdGluYXRpb24gZG9lcyBub3QgZXhpc3QnKVxuXG4gICAgICBpZiAoc291cmNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5wYXJlbnRzKSB7XG4gICAgICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2Rlc3RpbmF0aW9uIGRpZCBub3QgZXhpc3QsIHBhc3MgLXAgdG8gY3JlYXRlIGludGVybWVkaWF0ZSBkaXJlY3RvcmllcycpLCAnRVJSX0lOVkFMSURfUEFSQU1TJylcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IG1rZGlyKGNvbnRleHQpKGRlc3RpbmF0aW9uLnBhdGgsIG9wdGlvbnMpXG4gICAgICAgIGRlc3RpbmF0aW9uID0gYXdhaXQgdG9NZnNQYXRoKGNvbnRleHQsIGRlc3RpbmF0aW9uLnBhdGgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZGVzdGluYXRpb25QYXRoID0gaXNEaXJlY3RvcnkoZGVzdGluYXRpb24pID8gZGVzdGluYXRpb24ubWZzUGF0aCA6IGRlc3RpbmF0aW9uLm1mc0RpcmVjdG9yeVxuICAgIGNvbnN0IHRyYWlsID0gYXdhaXQgdG9UcmFpbChjb250ZXh0LCBkZXN0aW5hdGlvblBhdGgsIG9wdGlvbnMpXG5cbiAgICBpZiAoc291cmNlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXMucG9wKClcbiAgICAgIGNvbnN0IGRlc3RpbmF0aW9uTmFtZSA9IGRlc3RpbmF0aW9uSXNEaXJlY3RvcnkgPyBzb3VyY2UubmFtZSA6IGRlc3RpbmF0aW9uLm5hbWVcblxuICAgICAgbG9nKGBPbmx5IG9uZSBzb3VyY2UsIGNvcHlpbmcgdG8gZGVzdGluYXRpb24gJHtkZXN0aW5hdGlvbklzRGlyZWN0b3J5ID8gJ2RpcmVjdG9yeScgOiAnZmlsZSd9ICR7ZGVzdGluYXRpb25OYW1lfWApXG5cbiAgICAgIHJldHVybiBjb3B5VG9GaWxlKGNvbnRleHQsIHNvdXJjZSwgZGVzdGluYXRpb25OYW1lLCB0cmFpbCwgb3B0aW9ucylcbiAgICB9XG5cbiAgICBsb2coJ011bHRpcGxlIHNvdXJjZXMsIHdyYXBwaW5nIGluIGEgZGlyZWN0b3J5JylcbiAgICByZXR1cm4gY29weVRvRGlyZWN0b3J5KGNvbnRleHQsIHNvdXJjZXMsIGRlc3RpbmF0aW9uLCB0cmFpbCwgb3B0aW9ucylcbiAgfVxufVxuXG5jb25zdCBpc0RpcmVjdG9yeSA9IChkZXN0aW5hdGlvbikgPT4ge1xuICByZXR1cm4gZGVzdGluYXRpb24udW5peGZzICYmXG4gICAgZGVzdGluYXRpb24udW5peGZzLnR5cGUgJiZcbiAgICBkZXN0aW5hdGlvbi51bml4ZnMudHlwZS5pbmNsdWRlcygnZGlyZWN0b3J5Jylcbn1cblxuY29uc3QgY29weVRvRmlsZSA9IGFzeW5jIChjb250ZXh0LCBzb3VyY2UsIGRlc3RpbmF0aW9uLCBkZXN0aW5hdGlvblRyYWlsLCBvcHRpb25zKSA9PiB7XG4gIGxldCBwYXJlbnQgPSBkZXN0aW5hdGlvblRyYWlsLnBvcCgpXG5cbiAgcGFyZW50ID0gYXdhaXQgYWRkU291cmNlVG9QYXJlbnQoY29udGV4dCwgc291cmNlLCBkZXN0aW5hdGlvbiwgcGFyZW50LCBvcHRpb25zKVxuXG4gIC8vIHVwZGF0ZSB0aGUgdHJlZSB3aXRoIHRoZSBuZXcgY29udGFpbmcgZGlyZWN0b3J5XG4gIGRlc3RpbmF0aW9uVHJhaWwucHVzaChwYXJlbnQpXG5cbiAgY29uc3QgbmV3Um9vdENpZCA9IGF3YWl0IHVwZGF0ZVRyZWUoY29udGV4dCwgZGVzdGluYXRpb25UcmFpbCwgb3B0aW9ucylcblxuICAvLyBVcGRhdGUgdGhlIE1GUyByZWNvcmQgd2l0aCB0aGUgbmV3IENJRCBmb3IgdGhlIHJvb3Qgb2YgdGhlIHRyZWVcbiAgYXdhaXQgdXBkYXRlTWZzUm9vdChjb250ZXh0LCBuZXdSb290Q2lkKVxufVxuXG5jb25zdCBjb3B5VG9EaXJlY3RvcnkgPSBhc3luYyAoY29udGV4dCwgc291cmNlcywgZGVzdGluYXRpb24sIGRlc3RpbmF0aW9uVHJhaWwsIG9wdGlvbnMpID0+IHtcbiAgLy8gY29weSBhbGwgdGhlIHNvdXJjZXMgdG8gdGhlIGRlc3RpbmF0aW9uXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaV1cblxuICAgIGRlc3RpbmF0aW9uID0gYXdhaXQgYWRkU291cmNlVG9QYXJlbnQoY29udGV4dCwgc291cmNlLCBzb3VyY2UubmFtZSwgZGVzdGluYXRpb24sIG9wdGlvbnMpXG4gIH1cblxuICAvLyB1cGRhdGUgdGhlIHRyZWUgd2l0aCB0aGUgbmV3IGNvbnRhaW5nIGRpcmVjdG9yeVxuICBkZXN0aW5hdGlvblRyYWlsW2Rlc3RpbmF0aW9uVHJhaWwubGVuZ3RoIC0gMV0gPSBkZXN0aW5hdGlvblxuXG4gIGNvbnN0IG5ld1Jvb3RDaWQgPSBhd2FpdCB1cGRhdGVUcmVlKGNvbnRleHQsIGRlc3RpbmF0aW9uVHJhaWwsIG9wdGlvbnMpXG5cbiAgLy8gVXBkYXRlIHRoZSBNRlMgcmVjb3JkIHdpdGggdGhlIG5ldyBDSUQgZm9yIHRoZSByb290IG9mIHRoZSB0cmVlXG4gIGF3YWl0IHVwZGF0ZU1mc1Jvb3QoY29udGV4dCwgbmV3Um9vdENpZClcbn1cblxuY29uc3QgYWRkU291cmNlVG9QYXJlbnQgPSBhc3luYyAoY29udGV4dCwgc291cmNlLCBjaGlsZE5hbWUsIHBhcmVudCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzb3VyY2VCbG9jayA9IGF3YWl0IGNvbnRleHQucmVwby5ibG9ja3MuZ2V0KHNvdXJjZS5jaWQpXG5cbiAgY29uc3Qge1xuICAgIG5vZGUsXG4gICAgY2lkXG4gIH0gPSBhd2FpdCBhZGRMaW5rKGNvbnRleHQsIHtcbiAgICBwYXJlbnRDaWQ6IHBhcmVudC5jaWQsXG4gICAgc2l6ZTogc291cmNlQmxvY2suZGF0YS5sZW5ndGgsXG4gICAgY2lkOiBzb3VyY2UuY2lkLFxuICAgIG5hbWU6IGNoaWxkTmFtZSxcbiAgICBmb3JtYXQ6IG9wdGlvbnMuZm9ybWF0LFxuICAgIGhhc2hBbGc6IG9wdGlvbnMuaGFzaEFsZyxcbiAgICBjaWRWZXJzaW9uOiBvcHRpb25zLmNpZFZlcnNpb25cbiAgfSlcblxuICBwYXJlbnQubm9kZSA9IG5vZGVcbiAgcGFyZW50LmNpZCA9IGNpZFxuICBwYXJlbnQuc2l6ZSA9IG5vZGUuc2l6ZVxuXG4gIHJldHVybiBwYXJlbnRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBtb3J0aWNlID0gcmVxdWlyZSgnbW9ydGljZScpXG5cbmxldCBsb2NrXG5cbm1vZHVsZS5leHBvcnRzID0gKHJlcG9Pd25lcikgPT4ge1xuICBpZiAobG9jaykge1xuICAgIHJldHVybiBsb2NrXG4gIH1cblxuICBjb25zdCBtdXRleCA9IG1vcnRpY2Uoe1xuICAgIC8vIG9yZGluYXJpbHkgdGhlIG1haW4gdGhyZWFkIHdvdWxkIHN0b3JlIHRoZSByZWFkL3dyaXRlIGxvY2sgYnV0XG4gICAgLy8gaWYgd2UgYXJlIHRoZSB0aHJlYWQgdGhhdCBvd25zIHRoZSByZXBvLCB3ZSBjYW4gc3RvcmUgdGhlIGxvY2tcbiAgICAvLyBvbiB0aGlzIHByb2Nlc3MgZXZlbiBpZiB3ZSBhcmUgYSB3b3JrZXIgdGhyZWFkXG4gICAgc2luZ2xlUHJvY2VzczogcmVwb093bmVyXG4gIH0pXG5cbiAgbG9jayA9IHtcbiAgICByZWFkTG9jazogKGZ1bmMpID0+IHtcbiAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICByZXR1cm4gbXV0ZXgucmVhZExvY2soKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSxcblxuICAgIHdyaXRlTG9jazogKGZ1bmMpID0+IHtcbiAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICByZXR1cm4gbXV0ZXgud3JpdGVMb2NrKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2NrXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU25hcENvbnRyb2xsZXIgPSBleHBvcnRzLlNuYXBTdGF0dXNFdmVudCA9IGV4cG9ydHMuU25hcFN0YXR1cyA9IGV4cG9ydHMuU05BUF9QUkVGSVhfUkVHRVggPSBleHBvcnRzLlNOQVBfUFJFRklYID0gZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9IHZvaWQgMDtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG5jb25zdCBjb250cm9sbGVyc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay9jb250cm9sbGVyc1wiKTtcbmNvbnN0IG5hbm9pZF8xID0gcmVxdWlyZShcIm5hbm9pZFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBpbmxpbmVTbmFwc18xID0gcmVxdWlyZShcIi4vaW5saW5lU25hcHNcIik7XG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1NuYXBDb250cm9sbGVyJztcbmV4cG9ydHMuU05BUF9QUkVGSVggPSAnd2FsbGV0X3NuYXBfJztcbmV4cG9ydHMuU05BUF9QUkVGSVhfUkVHRVggPSBuZXcgUmVnRXhwKGBeJHtleHBvcnRzLlNOQVBfUFJFRklYfWAsICd1Jyk7XG5jb25zdCBTRVJJQUxJWkFCTEVfU05BUF9QUk9QRVJUSUVTID0gbmV3IFNldChbXG4gICAgJ2luaXRpYWxQZXJtaXNzaW9ucycsXG4gICAgJ25hbWUnLFxuICAgICdwZXJtaXNzaW9uTmFtZScsXG5dKTtcbmNvbnN0IGRlZmF1bHRTdGF0ZSA9IHtcbiAgICBzbmFwRXJyb3JzOiB7fSxcbiAgICBpbmxpbmVTbmFwSXNSdW5uaW5nOiBmYWxzZSxcbiAgICBzbmFwczoge30sXG4gICAgc25hcFN0YXRlczoge30sXG59O1xudmFyIFNuYXBTdGF0dXM7XG4oZnVuY3Rpb24gKFNuYXBTdGF0dXMpIHtcbiAgICBTbmFwU3RhdHVzW1wiaW5zdGFsbGluZ1wiXSA9IFwiaW5zdGFsbGluZ1wiO1xuICAgIFNuYXBTdGF0dXNbXCJydW5uaW5nXCJdID0gXCJydW5uaW5nXCI7XG4gICAgU25hcFN0YXR1c1tcInN0b3BwZWRcIl0gPSBcInN0b3BwZWRcIjtcbiAgICBTbmFwU3RhdHVzW1wiY3Jhc2hlZFwiXSA9IFwiY3Jhc2hlZFwiO1xufSkoU25hcFN0YXR1cyA9IGV4cG9ydHMuU25hcFN0YXR1cyB8fCAoZXhwb3J0cy5TbmFwU3RhdHVzID0ge30pKTtcbnZhciBTbmFwU3RhdHVzRXZlbnQ7XG4oZnVuY3Rpb24gKFNuYXBTdGF0dXNFdmVudCkge1xuICAgIFNuYXBTdGF0dXNFdmVudFtcInN0YXJ0XCJdID0gXCJzdGFydFwiO1xuICAgIFNuYXBTdGF0dXNFdmVudFtcInN0b3BcIl0gPSBcInN0b3BcIjtcbiAgICBTbmFwU3RhdHVzRXZlbnRbXCJjcmFzaFwiXSA9IFwiY3Jhc2hcIjtcbn0pKFNuYXBTdGF0dXNFdmVudCA9IGV4cG9ydHMuU25hcFN0YXR1c0V2ZW50IHx8IChleHBvcnRzLlNuYXBTdGF0dXNFdmVudCA9IHt9KSk7XG4vKipcbiAqIEd1YXJkIHRyYW5zaXRpb25pbmcgd2hlbiB0aGUgc25hcCBpcyBkaXNhYmxlZC5cbiAqL1xuY29uc3QgZGlzYWJsZWRHdWFyZCA9IChzZXJpYWxpemVkU25hcCkgPT4ge1xuICAgIHJldHVybiBzZXJpYWxpemVkU25hcC5lbmFibGVkO1xufTtcbi8qKlxuICogVGhlIHN0YXRlIG1hY2hpbmUgY29uZmlndXJhdGlvbiBmb3IgYSBzbmFwcyBgc3RhdHVzYCBzdGF0ZS5cbiAqIFVzaW5nIGEgc3RhdGUgbWFjaGluZSBmb3IgYSBzbmFwcyBgc3RhdHVzYCBlbnN1cmVzIHRoYXQgdGhlIHNuYXAgdHJhbnNpdGlvbnMgdG8gYSB2YWxpZCBuZXh0IGxpZmVjeWNsZSBzdGF0ZS5cbiAqIFN1cHBvcnRzIGEgdmVyeSBtaW5pbWFsIHN1YnNldCBvZiBYU3RhdGUgY29udmVudGlvbnMgb3V0bGluZWQgaW4gYF90cmFuc2l0aW9uU25hcFN0YXRlYC5cbiAqL1xuY29uc3Qgc25hcFN0YXR1c1N0YXRlTWFjaGluZUNvbmZpZyA9IHtcbiAgICBpbml0aWFsOiBTbmFwU3RhdHVzLmluc3RhbGxpbmcsXG4gICAgc3RhdGVzOiB7XG4gICAgICAgIFtTbmFwU3RhdHVzLmluc3RhbGxpbmddOiB7XG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIFtTbmFwU3RhdHVzRXZlbnQuc3RhcnRdOiB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogU25hcFN0YXR1cy5ydW5uaW5nLFxuICAgICAgICAgICAgICAgICAgICBjb25kOiBkaXNhYmxlZEd1YXJkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBbU25hcFN0YXR1cy5ydW5uaW5nXToge1xuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBbU25hcFN0YXR1c0V2ZW50LnN0b3BdOiBTbmFwU3RhdHVzLnN0b3BwZWQsXG4gICAgICAgICAgICAgICAgW1NuYXBTdGF0dXNFdmVudC5jcmFzaF06IFNuYXBTdGF0dXMuY3Jhc2hlZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFtTbmFwU3RhdHVzLnN0b3BwZWRdOiB7XG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIFtTbmFwU3RhdHVzRXZlbnQuc3RhcnRdOiB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogU25hcFN0YXR1cy5ydW5uaW5nLFxuICAgICAgICAgICAgICAgICAgICBjb25kOiBkaXNhYmxlZEd1YXJkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBbU25hcFN0YXR1cy5jcmFzaGVkXToge1xuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBbU25hcFN0YXR1c0V2ZW50LnN0YXJ0XToge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IFNuYXBTdGF0dXMucnVubmluZyxcbiAgICAgICAgICAgICAgICAgICAgY29uZDogZGlzYWJsZWRHdWFyZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxufTtcbmNvbnN0IG5hbWUgPSAnU25hcENvbnRyb2xsZXInO1xuLypcbiAqIEEgc25hcCBpcyBpbml0aWFsaXplZCBpbiB0aHJlZSBwaGFzZXM6XG4gKiAtIEFkZDogTG9hZHMgdGhlIHNuYXAgZnJvbSBhIHJlbW90ZSBzb3VyY2UgYW5kIHBhcnNlcyBpdC5cbiAqIC0gQXV0aG9yaXplOiBSZXF1ZXN0cyB0aGUgc25hcCdzIHJlcXVpcmVkIHBlcm1pc3Npb25zIGZyb20gdGhlIHVzZXIuXG4gKiAtIFN0YXJ0OiBJbml0aWFsaXplcyB0aGUgc25hcCBpbiBpdHMgU0VTIHJlYWxtIHdpdGggdGhlIGF1dGhvcml6ZWQgcGVybWlzc2lvbnMuXG4gKi9cbmNsYXNzIFNuYXBDb250cm9sbGVyIGV4dGVuZHMgY29udHJvbGxlcnNfMS5CYXNlQ29udHJvbGxlclYyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHJlbW92ZUFsbFBlcm1pc3Npb25zRm9yLCBjbG9zZUFsbENvbm5lY3Rpb25zLCByZXF1ZXN0UGVybWlzc2lvbnMsIGdldFBlcm1pc3Npb25zLCB0ZXJtaW5hdGVTbmFwLCB0ZXJtaW5hdGVBbGxTbmFwcywgaGFzUGVybWlzc2lvbiwgZXhlY3V0ZVNuYXAsIGdldFJwY01lc3NhZ2VIYW5kbGVyLCBtZXNzZW5nZXIsIHN0YXRlLCBtYXhJZGxlVGltZSA9IDMwMDAwLCBpZGxlVGltZUNoZWNrSW50ZXJ2YWwgPSA1MDAwLCBtYXhSZXF1ZXN0VGltZSA9IDYwMDAwLCB9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG1lc3NlbmdlcixcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgc25hcEVycm9yczoge1xuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlubGluZVNuYXBJc1J1bm5pbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFub255bW91czogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzbmFwU3RhdGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFub255bW91czogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzbmFwczoge1xuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0OiAoc25hcHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHNuYXBzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKHNuYXApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzbmFwKSwgeyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXQgdGhlIHRpbWUgc3RhdGUgaXMgcmVoeWRyYXRlZCwgbm8gc25hcCB3aWxsIGJlIHJ1bm5pbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogU25hcFN0YXR1cy5zdG9wcGVkIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVkdWNlKChtZW1vLCBzbmFwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVtb1tzbmFwLm5hbWVdID0gc25hcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBzdGF0ZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0U3RhdGUpLCBzdGF0ZSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9yZW1vdmVBbGxQZXJtaXNzaW9uc0ZvciA9IHJlbW92ZUFsbFBlcm1pc3Npb25zRm9yO1xuICAgICAgICB0aGlzLl9jbG9zZUFsbENvbm5lY3Rpb25zID0gY2xvc2VBbGxDb25uZWN0aW9ucztcbiAgICAgICAgdGhpcy5fcmVxdWVzdFBlcm1pc3Npb25zID0gcmVxdWVzdFBlcm1pc3Npb25zO1xuICAgICAgICB0aGlzLl9nZXRQZXJtaXNzaW9ucyA9IGdldFBlcm1pc3Npb25zO1xuICAgICAgICB0aGlzLl9oYXNQZXJtaXNzaW9uID0gaGFzUGVybWlzc2lvbjtcbiAgICAgICAgdGhpcy5fdGVybWluYXRlU25hcCA9IHRlcm1pbmF0ZVNuYXA7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmF0ZUFsbFNuYXBzID0gdGVybWluYXRlQWxsU25hcHM7XG4gICAgICAgIHRoaXMuX2V4ZWN1dGVTbmFwID0gZXhlY3V0ZVNuYXA7XG4gICAgICAgIHRoaXMuX2dldFJwY01lc3NhZ2VIYW5kbGVyID0gZ2V0UnBjTWVzc2FnZUhhbmRsZXI7XG4gICAgICAgIHRoaXMuX29uVW5oYW5kbGVkU25hcEVycm9yID0gdGhpcy5fb25VbmhhbmRsZWRTbmFwRXJyb3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fb25VbnJlc3BvbnNpdmVTbmFwID0gdGhpcy5fb25VbnJlc3BvbnNpdmVTbmFwLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnN1YnNjcmliZSgnU2VydmljZU1lc3Nlbmdlcjp1bmhhbmRsZWRFcnJvcicsIHRoaXMuX29uVW5oYW5kbGVkU25hcEVycm9yKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0uc3Vic2NyaWJlKCdTZXJ2aWNlTWVzc2VuZ2VyOnVucmVzcG9uc2l2ZScsIHRoaXMuX29uVW5yZXNwb25zaXZlU25hcCk7XG4gICAgICAgIHRoaXMuX3NuYXBzQmVpbmdBZGRlZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbWF4SWRsZVRpbWUgPSBtYXhJZGxlVGltZTtcbiAgICAgICAgdGhpcy5fbWF4UmVxdWVzdFRpbWUgPSBtYXhSZXF1ZXN0VGltZTtcbiAgICAgICAgdGhpcy5faWRsZVRpbWVDaGVja0ludGVydmFsID0gaWRsZVRpbWVDaGVja0ludGVydmFsO1xuICAgICAgICB0aGlzLl9wb2xsRm9yTGFzdFJlcXVlc3RTdGF0dXMoKTtcbiAgICAgICAgdGhpcy5fbGFzdFJlcXVlc3RNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3JwY0hhbmRsZXJNYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIF9wb2xsRm9yTGFzdFJlcXVlc3RTdGF0dXMoKSB7XG4gICAgICAgIHRoaXMuX3RpbWVvdXRGb3JMYXN0UmVxdWVzdFN0YXR1cyA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc3RvcFNuYXBzTGFzdFJlcXVlc3RQYXN0TWF4KCk7XG4gICAgICAgICAgICB0aGlzLl9wb2xsRm9yTGFzdFJlcXVlc3RTdGF0dXMoKTtcbiAgICAgICAgfSwgdGhpcy5faWRsZVRpbWVDaGVja0ludGVydmFsKTtcbiAgICB9XG4gICAgX3N0b3BTbmFwc0xhc3RSZXF1ZXN0UGFzdE1heCgpIHtcbiAgICAgICAgdGhpcy5fbGFzdFJlcXVlc3RNYXAuZm9yRWFjaChhc3luYyAodGltZXN0YW1wLCBzbmFwTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21heElkbGVUaW1lICYmIHV0aWxzXzEudGltZVNpbmNlKHRpbWVzdGFtcCkgPiB0aGlzLl9tYXhJZGxlVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcFNuYXAoc25hcE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX29uVW5yZXNwb25zaXZlU25hcChzbmFwTmFtZSkge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uU25hcFN0YXRlKHNuYXBOYW1lLCBTbmFwU3RhdHVzRXZlbnQuY3Jhc2gpO1xuICAgICAgICB0aGlzLl9zdG9wU25hcChzbmFwTmFtZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLmFkZFNuYXBFcnJvcih7XG4gICAgICAgICAgICBjb2RlOiAtMzIwMDEsXG4gICAgICAgICAgICBtZXNzYWdlOiAnU25hcCBVbnJlc3BvbnNpdmUnLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHNuYXBOYW1lLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9vblVuaGFuZGxlZFNuYXBFcnJvcihzbmFwTmFtZSwgZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvblNuYXBTdGF0ZShzbmFwTmFtZSwgU25hcFN0YXR1c0V2ZW50LmNyYXNoKTtcbiAgICAgICAgdGhpcy5fc3RvcFNuYXAoc25hcE5hbWUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5hZGRTbmFwRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2l0aW9ucyBiZXR3ZWVuIHN0YXRlcyB1c2luZyBgc25hcFN0YXR1c1N0YXRlTWFjaGluZUNvbmZpZ2AgYXMgdGhlIHRlbXBsYXRlIHRvIGZpZ3VyZSBvdXQgdGhlIG5leHQgc3RhdGUuXG4gICAgICogVGhpcyB0cmFuc2l0aW9uIGZ1bmN0aW9uIHVzZXMgYSB2ZXJ5IG1pbmltYWwgc3Vic2V0IG9mIFhTdGF0ZSBjb252ZW50aW9uczpcbiAgICAgKiAtIHN1cHBvcnRzIGluaXRpYWwgc3RhdGVcbiAgICAgKiAtIC5vbiBzdXBwb3J0cyByYXcgZXZlbnQgdGFyZ2V0IHN0cmluZ1xuICAgICAqIC0gLm9uIHN1cHBvcnRzIHt0YXJnZXQsIGNvbmR9IG9iamVjdFxuICAgICAqIC0gdGhlIGFyZ3VtZW50cyBmb3IgYGNvbmRgIGlzIHRoZSBgU2VyaWFsaXplZFNuYXBgIGluc3RlYWQgb2YgWHN0YXRlIGNvbnZlbnRpb24gb2YgYChldmVudCwgY29udGV4dCkgPT4gYm9vbGVhbmBcbiAgICAgKiBAcGFyYW0gc25hcE5hbWUgdGhlIG5hbWUgb2YgdGhlIHNuYXAgdG8gdHJhbnNpdGlvblxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgZXZlbnQgZW51bSB0byB1c2UgdG8gdHJhbnNpdGlvblxuICAgICAqL1xuICAgIF90cmFuc2l0aW9uU25hcFN0YXRlKHNuYXBOYW1lLCBldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHNuYXBTdGF0dXMgPSB0aGlzLnN0YXRlLnNuYXBzW3NuYXBOYW1lXS5zdGF0dXM7XG4gICAgICAgIGxldCBuZXh0U3RhdHVzID0gKF9hID0gc25hcFN0YXR1c1N0YXRlTWFjaGluZUNvbmZpZy5zdGF0ZXNbc25hcFN0YXR1c10ub25bZXZlbnRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzbmFwU3RhdHVzO1xuICAgICAgICBpZiAobmV4dFN0YXR1cy5jb25kKSB7XG4gICAgICAgICAgICBjb25zdCBjb25kID0gbmV4dFN0YXR1cy5jb25kKHRoaXMuc3RhdGUuc25hcHNbc25hcE5hbWVdKTtcbiAgICAgICAgICAgIGlmIChjb25kID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29uZGl0aW9uIGZhaWxlZCBmb3Igc3RhdGUgdHJhbnNpdGlvbiBcIiR7c25hcE5hbWV9XCIgd2l0aCBldmVudCBcIiR7ZXZlbnR9XCIuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRTdGF0dXMudGFyZ2V0KSB7XG4gICAgICAgICAgICBuZXh0U3RhdHVzID0gbmV4dFN0YXR1cy50YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRTdGF0dXMgPT09IHNuYXBTdGF0dXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLnNuYXBzW3NuYXBOYW1lXS5zdGF0dXMgPSBuZXh0U3RhdHVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVucyBleGlzdGluZyAoaW5zdGFsbGVkKSBzbmFwcy5cbiAgICAgKiBEZWxldGVzIGFueSBzbmFwcyB0aGF0IGNhbm5vdCBiZSBzdGFydGVkLlxuICAgICAqL1xuICAgIGFzeW5jIHJ1bkV4aXN0aW5nU25hcHMoKSB7XG4gICAgICAgIGNvbnN0IHsgc25hcHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhzbmFwcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIGV4aXN0aW5nIHNuYXBzLi4uJywgc25hcHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ05vIGV4aXN0aW5nIHNuYXBzIHRvIHJ1bi4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QudmFsdWVzKHNuYXBzKS5tYXAoYXN5bmMgKHsgbmFtZTogc25hcE5hbWUsIHNvdXJjZUNvZGUgfSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFN0YXJ0aW5nOiAke3NuYXBOYW1lfWApO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zdGFydFNuYXAoe1xuICAgICAgICAgICAgICAgICAgICBzbmFwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlQ29kZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBzdGFydCBcIiR7c25hcE5hbWV9XCIsIGRlbGV0aW5nIGl0LmAsIGVycik7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZmFpbGVkIHNuYXBzOlxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU25hcChzbmFwTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBnaXZlbiBzbmFwLiBUaHJvd3MgYW4gZXJyb3IgaWYgbm8gc3VjaCBzbmFwIGV4aXN0c1xuICAgICAqIG9yIGlmIGl0IGlzIGFscmVhZHkgcnVubmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzbmFwTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzbmFwIHRvIHN0YXJ0LlxuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0U25hcChzbmFwTmFtZSkge1xuICAgICAgICBjb25zdCBzbmFwID0gdGhpcy5nZXQoc25hcE5hbWUpO1xuICAgICAgICBpZiAoIXNuYXApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU25hcCBcIiR7c25hcE5hbWV9XCIgbm90IGZvdW5kLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNuYXBzW3NuYXBOYW1lXS5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTbmFwIFwiJHtzbmFwTmFtZX1cIiBpcyBkaXNhYmxlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydFNuYXAoe1xuICAgICAgICAgICAgc25hcE5hbWUsXG4gICAgICAgICAgICBzb3VyY2VDb2RlOiBzbmFwLnNvdXJjZUNvZGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSBnaXZlbiBzbmFwLiBBIHNuYXAgY2FuIG9ubHkgYmUgc3RhcnRlZCBpZiBpdCBpcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNuYXAgdG8gZW5hYmxlLlxuICAgICAqL1xuICAgIGVuYWJsZVNuYXAoc25hcE5hbWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5zbmFwc1tzbmFwTmFtZV0uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyB0aGUgZ2l2ZW4gc25hcC4gQSBzbmFwIGNhbiBvbmx5IGJlIHN0YXJ0ZWQgaWYgaXQgaXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzbmFwTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzbmFwIHRvIGRpc2FibGUuXG4gICAgICovXG4gICAgZGlzYWJsZVNuYXAoc25hcE5hbWUpIHtcbiAgICAgICAgdGhpcy5zdG9wU25hcChzbmFwTmFtZSk7XG4gICAgICAgIHRoaXMudXBkYXRlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgc3RhdGUuc25hcHNbc25hcE5hbWVdLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSBnaXZlbiBzbmFwLiBUaHJvd3MgYW4gZXJyb3IgaWYgbm8gc3VjaCBzbmFwIGV4aXN0c1xuICAgICAqIG9yIGlmIGl0IGlzIGFscmVhZHkgc3RvcHBlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzbmFwTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzbmFwIHRvIHN0b3AuXG4gICAgICovXG4gICAgc3RvcFNuYXAoc25hcE5hbWUpIHtcbiAgICAgICAgY29uc3Qgc25hcCA9IHRoaXMuZ2V0KHNuYXBOYW1lKTtcbiAgICAgICAgaWYgKCFzbmFwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNuYXAgXCIke3NuYXBOYW1lfVwiIG5vdCBmb3VuZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKHNuYXBOYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTbmFwIFwiJHtzbmFwTmFtZX1cIiBhbHJlYWR5IHN0b3BwZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RvcFNuYXAoc25hcE5hbWUpO1xuICAgICAgICBjb25zb2xlLmxvZyhgU25hcCBcIiR7c25hcE5hbWV9XCIgc3RvcHBlZC5gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgdGhlIGdpdmVuIHNuYXAsIHJlbW92ZXMgYWxsIGhvb2tzLCBjbG9zZXMgYWxsIGNvbm5lY3Rpb25zLCBhbmRcbiAgICAgKiB0ZXJtaW5hdGVzIGl0cyB3b3JrZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc25hcE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc25hcCB0byBzdG9wLlxuICAgICAqIEBwYXJhbSBzZXROb3RSdW5uaW5nIC0gV2hldGhlciB0byBtYXJrIHRoZSBzbmFwIGFzIG5vdCBydW5uaW5nLlxuICAgICAqIFNob3VsZCBvbmx5IGJlIHNldCB0byBmYWxzZSBpZiB0aGUgc25hcCBpcyBhYm91dCB0byBiZSBkZWxldGVkLlxuICAgICAqL1xuICAgIF9zdG9wU25hcChzbmFwTmFtZSwgc2V0Tm90UnVubmluZyA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5fbGFzdFJlcXVlc3RNYXAuZGVsZXRlKHNuYXBOYW1lKTtcbiAgICAgICAgdGhpcy5fY2xvc2VBbGxDb25uZWN0aW9ucyhzbmFwTmFtZSk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmF0ZVNuYXAoc25hcE5hbWUpO1xuICAgICAgICBpZiAoc2V0Tm90UnVubmluZykge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvblNuYXBTdGF0ZShzbmFwTmFtZSwgU25hcFN0YXR1c0V2ZW50LnN0b3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gc25hcCBpcyBydW5uaW5nLlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgc25hcCBkb2Vzbid0IGV4aXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNuYXAgdG8gY2hlY2suXG4gICAgICovXG4gICAgaXNSdW5uaW5nKHNuYXBOYW1lKSB7XG4gICAgICAgIGNvbnN0IHNuYXAgPSB0aGlzLmdldChzbmFwTmFtZSk7XG4gICAgICAgIGlmICghc25hcCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTbmFwIFwiJHtzbmFwTmFtZX1cIiBub3QgZm91bmQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNuYXAuc3RhdHVzID09PSBTbmFwU3RhdHVzLnJ1bm5pbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gc25hcCBoYXMgYmVlbiBhZGRlZCB0byBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzbmFwTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzbmFwIHRvIGNoZWNrIGZvci5cbiAgICAgKi9cbiAgICBoYXMoc25hcE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHNuYXBOYW1lIGluIHRoaXMuc3RhdGUuc25hcHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNuYXAgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpZiBpdCBleGlzdHMsIGluY2x1ZGluZyBhbGwgZGF0YS5cbiAgICAgKiBUaGlzIHNob3VsZCBub3QgYmUgdXNlZCBpZiB0aGUgc25hcCBpcyB0byBiZSBzZXJpYWxpemFibGUsIGFzIGUuZy5cbiAgICAgKiB0aGUgc25hcCBzb3VyY2VDb2RlIG1heSBiZSBxdWl0ZSBsYXJnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzbmFwTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzbmFwIHRvIGdldC5cbiAgICAgKi9cbiAgICBnZXQoc25hcE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc25hcHNbc25hcE5hbWVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzbmFwIHdpdGggdGhlIGdpdmVuIG5hbWUgaWYgaXQgZXhpc3RzLCBleGNsdWRpbmcgYW55XG4gICAgICogbm9uLXNlcmlhbGl6YWJsZSBvciBleHBlbnNpdmUtdG8tc2VyaWFsaXplIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc25hcE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc25hcCB0byBnZXQuXG4gICAgICovXG4gICAgZ2V0U2VyaWFsaXphYmxlKHNuYXBOYW1lKSB7XG4gICAgICAgIGNvbnN0IHNuYXAgPSB0aGlzLmdldChzbmFwTmFtZSk7XG4gICAgICAgIHJldHVybiBzbmFwXG4gICAgICAgICAgICA/IC8vIFRoZSBjYXN0IHRvIFwiYW55XCIgb2YgdGhlIGFjY3VtdWxhdG9yIG9iamVjdCBpcyBkdWUgdG8gYSBUeXBlU2NyaXB0IGJ1Z1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHNuYXApLnJlZHVjZSgoc2VyaWFsaXplZCwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChTRVJJQUxJWkFCTEVfU05BUF9QUk9QRVJUSUVTLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBzbmFwW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgICAgICAgICAgICAgfSwge30pXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIG93biBzdGF0ZSBvZiB0aGUgc25hcCB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgICAqIFRoaXMgaXMgZGlzdGluY3QgZnJvbSB0aGUgc3RhdGUgTWV0YU1hc2sgdXNlcyB0byBtYW5hZ2Ugc25hcHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc25hcE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc25hcCB3aG9zZSBzdGF0ZSBzaG91bGQgYmUgdXBkYXRlZC5cbiAgICAgKiBAcGFyYW0gbmV3U25hcFN0YXRlIC0gVGhlIG5ldyBzdGF0ZSBvZiB0aGUgc25hcC5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVTbmFwU3RhdGUoc25hcE5hbWUsIG5ld1NuYXBTdGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLnNuYXBTdGF0ZXNbc25hcE5hbWVdID0gbmV3U25hcFN0YXRlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBlcnJvciBmcm9tIGEgc25hcCB0byB0aGUgU25hcENvbnRyb2xsZXJzIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBFcnJvciAtIFRoZSBlcnJvciB0byBzdG9yZSBvbiB0aGUgU25hcENvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBhc3luYyBhZGRTbmFwRXJyb3Ioc25hcEVycm9yKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBuYW5vaWRfMS5uYW5vaWQoKTtcbiAgICAgICAgICAgIHN0YXRlLnNuYXBFcnJvcnNbaWRdID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzbmFwRXJyb3IpLCB7IGludGVybmFsSUQ6IGlkIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBlcnJvciBieSBpbnRlcm5hbElEIGZyb20gYSB0aGUgU25hcENvbnRyb2xsZXJzIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGludGVybmFsSUQgLSBUaGUgaW50ZXJuYWwgZXJyb3IgSUQgdG8gcmVtb3ZlIG9uIHRoZSBTbmFwQ29udHJvbGxlclxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZVNuYXBFcnJvcihpbnRlcm5hbElEKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHN0YXRlLnNuYXBFcnJvcnNbaW50ZXJuYWxJRF07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGVycm9ycyBmcm9tIHRoZSBTbmFwQ29udHJvbGxlcnMgc3RhdGUuXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBjbGVhclNuYXBFcnJvcnMoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgc3RhdGUuc25hcEVycm9ycyA9IHt9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgb3duIHN0YXRlIG9mIHRoZSBzbmFwIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAgICogVGhpcyBpcyBkaXN0aW5jdCBmcm9tIHRoZSBzdGF0ZSBNZXRhTWFzayB1c2VzIHRvIG1hbmFnZSBzbmFwcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzbmFwTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzbmFwIHdob3NlIHN0YXRlIHRvIGdldC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTbmFwU3RhdGUoc25hcE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc25hcFN0YXRlc1tzbmFwTmFtZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlbHkgY2xlYXIgdGhlIGNvbnRyb2xsZXIncyBzdGF0ZTogZGVsZXRlIGFsbCBhc3NvY2lhdGVkIGRhdGEsXG4gICAgICogaGFuZGxlcnMsIGV2ZW50IGxpc3RlbmVycywgYW5kIHBlcm1pc3Npb25zOyB0ZWFyIGRvd24gYWxsIHNuYXAgcHJvdmlkZXJzLlxuICAgICAqL1xuICAgIGNsZWFyU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHNuYXBOYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuc3RhdGUuc25hcHMpO1xuICAgICAgICBzbmFwTmFtZXMuZm9yRWFjaCgoc25hcE5hbWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlQWxsQ29ubmVjdGlvbnMoc25hcE5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdGVybWluYXRlQWxsU25hcHMoKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlQWxsUGVybWlzc2lvbnNGb3Ioc25hcE5hbWVzKTtcbiAgICAgICAgdGhpcy51cGRhdGUoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5pbmxpbmVTbmFwSXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBzdGF0ZS5zbmFwcyA9IHt9O1xuICAgICAgICAgICAgc3RhdGUuc25hcFN0YXRlcyA9IHt9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gc25hcCBmcm9tIHN0YXRlLCBhbmQgY2xlYXJzIGFsbCBhc3NvY2lhdGVkIGhhbmRsZXJzXG4gICAgICogYW5kIGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzbmFwTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzbmFwLlxuICAgICAqL1xuICAgIHJlbW92ZVNuYXAoc25hcE5hbWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVTbmFwcyhbc25hcE5hbWVdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgdGhlIGdpdmVuIHNuYXBzLCByZW1vdmVzIHRoZW0gZnJvbSBzdGF0ZSwgYW5kIGNsZWFycyBhbGwgYXNzb2NpYXRlZFxuICAgICAqIHBlcm1pc3Npb25zLCBoYW5kbGVycywgYW5kIGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gc25hcE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc25hcHMuXG4gICAgICovXG4gICAgcmVtb3ZlU25hcHMoc25hcE5hbWVzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzbmFwTmFtZXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGFycmF5IG9mIHNuYXAgbmFtZXMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBzbmFwTmFtZXMuZm9yRWFjaCgoc25hcE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wU25hcChzbmFwTmFtZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JwY0hhbmRsZXJNYXAuZGVsZXRlKHNuYXBOYW1lKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGUuc25hcHNbc25hcE5hbWVdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5zbmFwU3RhdGVzW3NuYXBOYW1lXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlQWxsUGVybWlzc2lvbnNGb3Ioc25hcE5hbWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2VyaWFsaXplZCBwZXJtaXR0ZWQgc25hcHMgb2YgdGhlIGdpdmVuIG9yaWdpbiwgaWYgYW55LlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIHdob3NlIHBlcm1pdHRlZCBzbmFwcyB0byByZXRyaWV2ZS5cbiAgICAgKi9cbiAgICBnZXRQZXJtaXR0ZWRTbmFwcyhvcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFBlcm1pc3Npb25zKG9yaWdpbikucmVkdWNlKChwZXJtaXR0ZWRTbmFwcywgcGVybSkgPT4ge1xuICAgICAgICAgICAgaWYgKHBlcm0ucGFyZW50Q2FwYWJpbGl0eS5zdGFydHNXaXRoKGV4cG9ydHMuU05BUF9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc25hcE5hbWUgPSBwZXJtLnBhcmVudENhcGFiaWxpdHkucmVwbGFjZShleHBvcnRzLlNOQVBfUFJFRklYX1JFR0VYLCAnJyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc25hcCA9IHRoaXMuZ2V0U2VyaWFsaXphYmxlKHNuYXBOYW1lKTtcbiAgICAgICAgICAgICAgICBwZXJtaXR0ZWRTbmFwc1tzbmFwTmFtZV0gPSBzbmFwIHx8IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGV0aF9ycGNfZXJyb3JzXzEuc2VyaWFsaXplRXJyb3IobmV3IEVycm9yKCdTbmFwIHBlcm1pdHRlZCBidXQgbm90IGluc3RhbGxlZC4nKSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwZXJtaXR0ZWRTbmFwcztcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnN0YWxscyB0aGUgc25hcHMgcmVxdWVzdGVkIGJ5IHRoZSBnaXZlbiBvcmlnaW4sIHJldHVybmluZyB0aGUgc25hcFxuICAgICAqIG9iamVjdCBpZiB0aGUgb3JpZ2luIGlzIHBlcm1pdHRlZCB0byBpbnN0YWxsIGl0LCBhbmQgYW4gYXV0aG9yaXphdGlvbiBlcnJvclxuICAgICAqIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIHRoYXQgcmVxdWVzdGVkIHRvIGluc3RhbGwgdGhlIHNuYXBzLlxuICAgICAqIEBwYXJhbSByZXF1ZXN0ZWRTbmFwcyAtIFRoZSBzbmFwcyB0byBpbnN0YWxsLlxuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCBvZiBzbmFwIG5hbWVzIGFuZCBzbmFwIG9iamVjdHMsIG9yIGVycm9ycyBpZiBhXG4gICAgICogc25hcCBjb3VsZG4ndCBiZSBpbnN0YWxsZWQuXG4gICAgICovXG4gICAgYXN5bmMgaW5zdGFsbFNuYXBzKG9yaWdpbiwgcmVxdWVzdGVkU25hcHMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIC8vIHVzZSBhIGZvci1sb29wIHNvIHRoYXQgd2UgY2FuIHJldHVybiBhbiBvYmplY3QgYW5kIGF3YWl0IHRoZSByZXNvbHV0aW9uXG4gICAgICAgIC8vIG9mIGVhY2ggY2FsbCB0byBwcm9jZXNzUmVxdWVzdGVkU25hcFxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3Qua2V5cyhyZXF1ZXN0ZWRTbmFwcykubWFwKGFzeW5jIChzbmFwTmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGVybWlzc2lvbk5hbWUgPSBleHBvcnRzLlNOQVBfUFJFRklYICsgc25hcE5hbWU7XG4gICAgICAgICAgICBpZiAodGhpcy5faGFzUGVybWlzc2lvbihvcmlnaW4sIHBlcm1pc3Npb25OYW1lKSkge1xuICAgICAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gaW5zdGFsbCBhbmQgcnVuIHRoZSBzbmFwLCBzdG9yaW5nIGFueSBlcnJvcnMgdGhhdFxuICAgICAgICAgICAgICAgIC8vIG9jY3VyIGR1cmluZyB0aGUgcHJvY2Vzc1xuICAgICAgICAgICAgICAgIHJlc3VsdFtzbmFwTmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCAoYXdhaXQgdGhpcy5wcm9jZXNzUmVxdWVzdGVkU25hcChzbmFwTmFtZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgYWxsb3cgdGhlIGluc3RhbGxhdGlvbiBvZiBwZXJtaXR0ZWQgc25hcHNcbiAgICAgICAgICAgICAgICByZXN1bHRbc25hcE5hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucHJvdmlkZXIudW5hdXRob3JpemVkKGBOb3QgYXV0aG9yaXplZCB0byBpbnN0YWxsIHNuYXAgJyR7c25hcE5hbWV9Jy4gUmVxdWVzdCB0aGUgcGVybWlzc2lvbiBmb3IgdGhlIHNuYXAgYmVmb3JlIGF0dGVtcHRpbmcgdG8gaW5zdGFsbCBpdC5gKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMsIGF1dGhvcml6ZXMsIGFuZCBydW5zIHRoZSBnaXZlbiBzbmFwIHdpdGggYSBzbmFwIHByb3ZpZGVyLlxuICAgICAqIFJlc3VsdHMgZnJvbSB0aGlzIG1ldGhvZCBzaG91bGQgYmUgZWZmaWNpZW50bHkgc2VyaWFsaXphYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIC0gc25hcE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc25hcC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0aW5nIHNuYXAgb2JqZWN0LCBvciBhbiBlcnJvciBpZiBzb21ldGhpbmcgd2VudCB3cm9uZy5cbiAgICAgKi9cbiAgICBhc3luYyBwcm9jZXNzUmVxdWVzdGVkU25hcChzbmFwTmFtZSkge1xuICAgICAgICAvLyBJZiB0aGUgc25hcCBpcyBhbHJlYWR5IGluc3RhbGxlZCwganVzdCByZXR1cm4gaXRcbiAgICAgICAgY29uc3Qgc25hcCA9IHRoaXMuZ2V0KHNuYXBOYW1lKTtcbiAgICAgICAgaWYgKHNuYXApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlcmlhbGl6YWJsZShzbmFwTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc291cmNlQ29kZSB9ID0gYXdhaXQgdGhpcy5hZGQoe1xuICAgICAgICAgICAgICAgIG5hbWU6IHNuYXBOYW1lLFxuICAgICAgICAgICAgICAgIG1hbmlmZXN0VXJsOiBzbmFwTmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRob3JpemUoc25hcE5hbWUpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnRTbmFwKHtcbiAgICAgICAgICAgICAgICBzbmFwTmFtZSxcbiAgICAgICAgICAgICAgICBzb3VyY2VDb2RlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZXJpYWxpemFibGUoc25hcE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHdoZW4gYWRkaW5nIHNuYXAuYCwgZXJyKTtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBldGhfcnBjX2Vycm9yc18xLnNlcmlhbGl6ZUVycm9yKGVycikgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSByZXByZXNlbnRpbmcgdGhlIGNvbXBsZXRlIGluc3RhbGxhdGlvbiBvZiB0aGUgcmVxdWVzdGVkIHNuYXAuXG4gICAgICogSWYgdGhlIHNuYXAgaXMgYWxyZWFkeSBiZWluZyBpbnN0YWxsZWQsIHRoZSBwcmV2aW91c2x5IHBlbmRpbmcgcHJvbWlzZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNuYXAuXG4gICAgICogQHBhcmFtIGFyZ3MgLSBPYmplY3QgY29udGFpbmluZyBlaXRoZXIgdGhlIFVSTCBvZiB0aGUgc25hcCdzIG1hbmlmZXN0LFxuICAgICAqIG9yIHRoZSBzbmFwJ3MgbWFuaWZlc3QgYW5kIHNvdXJjZSBjb2RlLlxuICAgICAqIEByZXR1cm5zIFRoZSByZXN1bHRpbmcgc25hcCBvYmplY3QuXG4gICAgICovXG4gICAgYWRkKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgeyBuYW1lOiBzbmFwTmFtZSB9ID0gYXJncztcbiAgICAgICAgaWYgKCFzbmFwTmFtZSB8fCB0eXBlb2Ygc25hcE5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc25hcCBuYW1lOiAke3NuYXBOYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXJncyB8fFxuICAgICAgICAgICAgKCEoJ21hbmlmZXN0VXJsJyBpbiBhcmdzKSAmJlxuICAgICAgICAgICAgICAgICghKCdtYW5pZmVzdCcgaW4gYXJncykgfHwgISgnc291cmNlQ29kZScgaW4gYXJncykpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFkZCBzbmFwIGFyZ3MgZm9yIHNuYXAgXCIke3NuYXBOYW1lfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fc25hcHNCZWluZ0FkZGVkLmhhcyhzbmFwTmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBBZGRpbmcgc25hcDogJHtzbmFwTmFtZX1gKTtcbiAgICAgICAgICAgIHRoaXMuX3NuYXBzQmVpbmdBZGRlZC5zZXQoc25hcE5hbWUsIHRoaXMuX2FkZChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NuYXBzQmVpbmdBZGRlZC5nZXQoc25hcE5hbWUpO1xuICAgIH1cbiAgICBhc3luYyBfc3RhcnRTbmFwKHNuYXBEYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgc25hcE5hbWUgfSA9IHNuYXBEYXRhO1xuICAgICAgICBpZiAodGhpcy5pc1J1bm5pbmcoc25hcE5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNuYXAgXCIke3NuYXBOYW1lfVwiIGlzIGFscmVhZHkgc3RhcnRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9leGVjdXRlU25hcChzbmFwRGF0YSk7XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25TbmFwU3RhdGUoc25hcE5hbWUsIFNuYXBTdGF0dXNFdmVudC5zdGFydCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZC4gU2VlIHRoZSBcImFkZFwiIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzbmFwTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzbmFwLlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFkZCBzbmFwIGFyZ3MuXG4gICAgICogQHJldHVybnMgVGhlIHJlc3VsdGluZyBzbmFwIG9iamVjdC5cbiAgICAgKi9cbiAgICBhc3luYyBfYWRkKGFyZ3MpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IG5hbWU6IHNuYXBOYW1lIH0gPSBhcmdzO1xuICAgICAgICBsZXQgbWFuaWZlc3QsIHNvdXJjZUNvZGU7XG4gICAgICAgIGlmICgnbWFuaWZlc3RVcmwnIGluIGFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IF9zb3VyY2VVcmwgPSBhcmdzLm1hbmlmZXN0VXJsIHx8IHNuYXBOYW1lO1xuICAgICAgICAgICAgW21hbmlmZXN0LCBzb3VyY2VDb2RlXSA9IGF3YWl0IHRoaXMuX2ZldGNoU25hcChzbmFwTmFtZSwgX3NvdXJjZVVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYW5pZmVzdCA9IGFyZ3MubWFuaWZlc3Q7XG4gICAgICAgICAgICBzb3VyY2VDb2RlID0gYXJncy5zb3VyY2VDb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlQ29kZSAhPT0gJ3N0cmluZycgfHwgc291cmNlQ29kZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzb3VyY2UgY29kZSBmb3Igc25hcCBcIiR7c25hcE5hbWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5pdGlhbFBlcm1pc3Npb25zID0gKF9hID0gbWFuaWZlc3QgPT09IG51bGwgfHwgbWFuaWZlc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hbmlmZXN0LndlYjNXYWxsZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbml0aWFsUGVybWlzc2lvbnM7XG4gICAgICAgIGlmICghaW5pdGlhbFBlcm1pc3Npb25zIHx8XG4gICAgICAgICAgICB0eXBlb2YgaW5pdGlhbFBlcm1pc3Npb25zICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShpbml0aWFsUGVybWlzc2lvbnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaW5pdGlhbCBwZXJtaXNzaW9ucyBmb3Igc25hcCBcIiR7c25hcE5hbWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNuYXAgPSB7XG4gICAgICAgICAgICBpbml0aWFsUGVybWlzc2lvbnMsXG4gICAgICAgICAgICBuYW1lOiBzbmFwTmFtZSxcbiAgICAgICAgICAgIHBlcm1pc3Npb25OYW1lOiBleHBvcnRzLlNOQVBfUFJFRklYICsgc25hcE5hbWUsXG4gICAgICAgICAgICBzb3VyY2VDb2RlLFxuICAgICAgICAgICAgdmVyc2lvbjogbWFuaWZlc3QudmVyc2lvbixcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBzdGF0dXM6IHNuYXBTdGF0dXNTdGF0ZU1hY2hpbmVDb25maWcuaW5pdGlhbCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc25hcHNTdGF0ZSA9IHRoaXMuc3RhdGUuc25hcHM7XG4gICAgICAgIC8vIHJlc3RvcmUgcmVsZXZhbnQgc25hcCBzdGF0ZSBpZiBpdCBleGlzdHNcbiAgICAgICAgaWYgKHNuYXBzU3RhdGVbc25hcE5hbWVdKSB7XG4gICAgICAgICAgICBzbmFwID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzbmFwc1N0YXRlW3NuYXBOYW1lXSksIHNuYXApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0b3JlIHRoZSBzbmFwIGJhY2sgaW4gc3RhdGVcbiAgICAgICAgdGhpcy51cGRhdGUoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5zbmFwc1tzbmFwTmFtZV0gPSBzbmFwO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNuYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIG1hbmlmZXN0IGFuZCBzb3VyY2UgY29kZSBvZiBhIHNuYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzbmFwLlxuICAgICAqIEBwYXJhbSBtYW5pZmVzdFVybCAtIFRoZSBVUkwgb2YgdGhlIHNuYXAncyBtYW5pZmVzdCBmaWxlLlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSBzbmFwIG1hbmlmZXN0IG9iamVjdCBhbmQgdGhlIHNuYXAgc291cmNlIGNvZGUuXG4gICAgICovXG4gICAgYXN5bmMgX2ZldGNoU25hcChzbmFwTmFtZSwgbWFuaWZlc3RVcmwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyBzbmFwIG1hbmlmZXN0IGZyb206ICR7bWFuaWZlc3RVcmx9YCk7XG4gICAgICAgICAgICBjb25zdCBzbmFwU291cmNlID0gYXdhaXQgZmV0Y2gobWFuaWZlc3RVcmwpO1xuICAgICAgICAgICAgY29uc3QgbWFuaWZlc3QgPSBhd2FpdCBzbmFwU291cmNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBEZXN0cnVjdHVyaW5nIHNuYXA6IGAsIG1hbmlmZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IHsgd2ViM1dhbGxldDogeyBidW5kbGUgfSwgfSA9IG1hbmlmZXN0O1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEZldGNoaW5nIHNuYXAgc291cmNlIGNvZGUgZnJvbTogJHtidW5kbGUudXJsfWApO1xuICAgICAgICAgICAgY29uc3Qgc25hcEJ1bmRsZSA9IGF3YWl0IGZldGNoKGJ1bmRsZS51cmwpO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlQ29kZSA9IGF3YWl0IHNuYXBCdW5kbGUudGV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIFttYW5pZmVzdCwgc291cmNlQ29kZV07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9ibGVtIGZldGNoaW5nIHNuYXAgXCIke3NuYXBOYW1lfVwiOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlcyBhIHJlcXVlc3QgZm9yIHRoZSBnaXZlbiBzbmFwJ3MgaW5pdGlhbCBwZXJtaXNzaW9ucy5cbiAgICAgKiBNdXN0IGJlIGNhbGxlZCBpbiBvcmRlci4gU2VlIHByb2Nlc3NSZXF1ZXN0ZWRTbmFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNuYXAuXG4gICAgICogQHJldHVybnMgVGhlIHNuYXAncyBhcHByb3ZlZFBlcm1pc3Npb25zLlxuICAgICAqL1xuICAgIGFzeW5jIGF1dGhvcml6ZShzbmFwTmFtZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgQXV0aG9yaXppbmcgc25hcDogJHtzbmFwTmFtZX1gKTtcbiAgICAgICAgY29uc3Qgc25hcHNTdGF0ZSA9IHRoaXMuc3RhdGUuc25hcHM7XG4gICAgICAgIGNvbnN0IHNuYXAgPSBzbmFwc1N0YXRlW3NuYXBOYW1lXTtcbiAgICAgICAgY29uc3QgeyBpbml0aWFsUGVybWlzc2lvbnMgfSA9IHNuYXA7XG4gICAgICAgIC8vIERvbid0IHByb21wdCBpZiB0aGVyZSBhcmUgbm8gcGVybWlzc2lvbnMgcmVxdWVzdGVkOlxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoaW5pdGlhbFBlcm1pc3Npb25zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdGlhbFBlcm1pc3Npb25zID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFwcHJvdmVkUGVybWlzc2lvbnMgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0UGVybWlzc2lvbnMoc25hcE5hbWUsIGluaXRpYWxQZXJtaXNzaW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gYXBwcm92ZWRQZXJtaXNzaW9ucy5tYXAoKHBlcm0pID0+IHBlcm0ucGFyZW50Q2FwYWJpbGl0eSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9zbmFwc0JlaW5nQWRkZWQuZGVsZXRlKHNuYXBOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IG1ldGhvZC5cbiAgICAgKi9cbiAgICBydW5JbmxpbmVTbmFwKGlubGluZVNuYXBOYW1lID0gJ0lETEUnKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0U25hcCh7XG4gICAgICAgICAgICBzbmFwTmFtZTogJ2lubGluZVNuYXAnLFxuICAgICAgICAgICAgc291cmNlQ29kZTogaW5saW5lU25hcHNfMS5JTkxJTkVfU05BUFNbaW5saW5lU25hcE5hbWVdLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGUoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5pbmxpbmVTbmFwSXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgbWV0aG9kLlxuICAgICAqL1xuICAgIHJlbW92ZUlubGluZVNuYXAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgc3RhdGUuaW5saW5lU25hcElzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZW1vdmVTbmFwKCdpbmxpbmVTbmFwJyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVvdXRGb3JMYXN0UmVxdWVzdFN0YXR1cykge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRGb3JMYXN0UmVxdWVzdFN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0udW5zdWJzY3JpYmUoJ1NlcnZpY2VNZXNzZW5nZXI6dW5oYW5kbGVkRXJyb3InLCB0aGlzLl9vblVuaGFuZGxlZFNuYXBFcnJvcik7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnVuc3Vic2NyaWJlKCdTZXJ2aWNlTWVzc2VuZ2VyOnVucmVzcG9uc2l2ZScsIHRoaXMuX29uVW5yZXNwb25zaXZlU25hcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFJQQyBtZXNzYWdlIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBzbmFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNuYXAgd2hvc2UgbWVzc2FnZSBoYW5kbGVyIHRvIGdldC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRScGNNZXNzYWdlSGFuZGxlcihzbmFwTmFtZSkge1xuICAgICAgICBjb25zdCBleGlzdGluZ0hhbmRsZXIgPSB0aGlzLl9ycGNIYW5kbGVyTWFwLmdldChzbmFwTmFtZSk7XG4gICAgICAgIGlmIChleGlzdGluZ0hhbmRsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0hhbmRsZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnBjSGFuZGxlciA9IGFzeW5jIChvcmlnaW4sIHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIGxldCBoYW5kbGVyID0gYXdhaXQgdGhpcy5fZ2V0UnBjTWVzc2FnZUhhbmRsZXIoc25hcE5hbWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuc25hcHNbc25hcE5hbWVdLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTbmFwIFwiJHtzbmFwTmFtZX1cIiBpcyBkaXNhYmxlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnNuYXBzW3NuYXBOYW1lXS5zdGF0dXMgPT09IFNuYXBTdGF0dXMuaW5zdGFsbGluZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU25hcCBcIiR7c25hcE5hbWV9XCIgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQgeWV0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYW5kbGVyICYmIHRoaXMuaXNSdW5uaW5nKHNuYXBOYW1lKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBjb2xkIHN0YXJ0XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zdGFydFNuYXAoc25hcE5hbWUpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBhd2FpdCB0aGlzLl9nZXRScGNNZXNzYWdlSGFuZGxlcihzbmFwTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNuYXAgZXhlY3V0aW9uIHNlcnZpY2UgcmV0dXJuZWQgbm8gUlBDIGhhbmRsZXIgZm9yIHJ1bm5pbmcgc25hcCBcIiR7c25hcE5hbWV9XCIuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZWNvcmRTbmFwUnBjUmVxdWVzdChzbmFwTmFtZSk7XG4gICAgICAgICAgICAvLyBIYW5kbGUgbWF4IHJlcXVlc3QgdGltZVxuICAgICAgICAgICAgbGV0IHRpbWVvdXQ7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wU25hcChzbmFwTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RoZSByZXF1ZXN0IHRpbWVkIG91dC4nKSk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5fbWF4UmVxdWVzdFRpbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgZWl0aGVyIGdldCB0aGUgcmVzdWx0IG9yIHJlamVjdCBkdWUgdG8gdGhlIHRpbWVvdXQuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIGhhbmRsZXIob3JpZ2luLCByZXF1ZXN0KSxcbiAgICAgICAgICAgICAgICB0aW1lb3V0UHJvbWlzZSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcnBjSGFuZGxlck1hcC5zZXQoc25hcE5hbWUsIHJwY0hhbmRsZXIpO1xuICAgICAgICByZXR1cm4gcnBjSGFuZGxlcjtcbiAgICB9XG4gICAgX3JlY29yZFNuYXBScGNSZXF1ZXN0KHNuYXBOYW1lKSB7XG4gICAgICAgIHRoaXMuX2xhc3RSZXF1ZXN0TWFwLnNldChzbmFwTmFtZSwgRGF0ZS5ub3coKSk7XG4gICAgfVxufVxuZXhwb3J0cy5TbmFwQ29udHJvbGxlciA9IFNuYXBDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U25hcENvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBjb250cm9sbGVyc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay9jb250cm9sbGVyc1wiKTtcbmNvbnN0IGNvbnRyb2xsZXJOYW1lID0gJ1N1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXInO1xuY29uc3Qgc3RhdGVNZXRhZGF0YSA9IHtcbiAgICBzdWJqZWN0TWV0YWRhdGE6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiBmYWxzZSB9LFxufTtcbmNvbnN0IGRlZmF1bHRTdGF0ZSA9IHtcbiAgICBzdWJqZWN0TWV0YWRhdGE6IHt9LFxufTtcbi8qKlxuICogQSBjb250cm9sbGVyIGZvciBzdG9yaW5nIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCBwZXJtaXNzaW9uIHN1YmplY3RzLiBNb3JlXG4gKiBvciBsZXNzLCBhIGNhY2hlLlxuICovXG5jbGFzcyBTdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyIGV4dGVuZHMgY29udHJvbGxlcnNfMS5CYXNlQ29udHJvbGxlclYyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG1lc3Nlbmdlciwgc3ViamVjdENhY2hlTGltaXQsIHN0YXRlID0ge30sIH0pIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHN1YmplY3RDYWNoZUxpbWl0KSB8fCBzdWJqZWN0Q2FjaGVMaW1pdCA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc3ViamVjdENhY2hlTGltaXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuIFJlY2VpdmVkOiBcIiR7c3ViamVjdENhY2hlTGltaXR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNQZXJtaXNzaW9ucyA9IChvcmlnaW4pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzZW5nZXIuY2FsbCgnUGVybWlzc2lvbkNvbnRyb2xsZXI6aGFzUGVybWlzc2lvbnMnLCBvcmlnaW4pO1xuICAgICAgICB9O1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBuYW1lOiBjb250cm9sbGVyTmFtZSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBzdGF0ZU1ldGFkYXRhLFxuICAgICAgICAgICAgbWVzc2VuZ2VyLFxuICAgICAgICAgICAgc3RhdGU6IE9iamVjdC5hc3NpZ24oe30sIFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIuZ2V0VHJpbW1lZFN0YXRlKHN0YXRlLCBoYXNQZXJtaXNzaW9ucykpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdWJqZWN0SGFzUGVybWlzc2lvbnMgPSBoYXNQZXJtaXNzaW9ucztcbiAgICAgICAgdGhpcy5zdWJqZWN0Q2FjaGVMaW1pdCA9IHN1YmplY3RDYWNoZUxpbWl0O1xuICAgICAgICB0aGlzLnN1YmplY3RzV2l0aG91dFBlcm1pc3Npb25zRWNvdW50ZXJlZFNpbmNlU3RhcnR1cCA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBzdGF0ZSBvZiB0aGlzIGNvbnRyb2xsZXIuIEFsc28gcmVzZXRzIHRoZSBjYWNoZSBvZiBzdWJqZWN0c1xuICAgICAqIGVuY291bnRlcmVkIHNpbmNlIHN0YXJ0dXAsIHNvIGFzIHRvIG5vdCBwcmVtYXR1cmVseSByZWFjaCB0aGUgY2FjaGUgbGltaXQuXG4gICAgICovXG4gICAgY2xlYXJTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5zdWJqZWN0c1dpdGhvdXRQZXJtaXNzaW9uc0Vjb3VudGVyZWRTaW5jZVN0YXJ0dXAuY2xlYXIoKTtcbiAgICAgICAgdGhpcy51cGRhdGUoKF9kcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3JlcyBkb21haW4gbWV0YWRhdGEgZm9yIHRoZSBnaXZlbiBvcmlnaW4gKHN1YmplY3QpLiBEZWxldGVzIG1ldGFkYXRhIGZvclxuICAgICAqIHN1YmplY3RzIHdpdGhvdXQgcGVybWlzc2lvbnMgaW4gYSBGSUZPIG1hbm5lciBvbmNlIG1vcmUgdGhhblxuICAgICAqIHtAbGluayBTdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLnN1YmplY3RDYWNoZUxpbWl0fSBkaXN0aW5jdCBvcmlnaW5zIGhhdmVcbiAgICAgKiBiZWVuIGFkZGVkIHNpbmNlIGJvb3QuXG4gICAgICpcbiAgICAgKiBJbiBvcmRlciB0byBwcmV2ZW50IGEgZGVncmFkZWQgdXNlciBleHBlcmllbmNlLFxuICAgICAqIG1ldGFkYXRhIGlzIG5ldmVyIGRlbGV0ZWQgZm9yIHN1YmplY3RzIHdpdGggcGVybWlzc2lvbnMsIHNpbmNlIG1ldGFkYXRhXG4gICAgICogY2Fubm90IHlldCBiZSByZXF1ZXN0ZWQgb24gZGVtYW5kLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1ldGFkYXRhIC0gVGhlIHN1YmplY3QgbWV0YWRhdGEgdG8gc3RvcmUuXG4gICAgICovXG4gICAgYWRkU3ViamVjdE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgb3JpZ2luIH0gPSBtZXRhZGF0YTtcbiAgICAgICAgY29uc3QgbmV3TWV0YWRhdGEgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1ldGFkYXRhKSwgeyBleHRlbnNpb25JZDogbWV0YWRhdGEuZXh0ZW5zaW9uSWQgfHwgbnVsbCwgaWNvblVybDogbWV0YWRhdGEuaWNvblVybCB8fCBudWxsIH0pO1xuICAgICAgICBsZXQgb3JpZ2luVG9Gb3JnZXQgPSBudWxsO1xuICAgICAgICAvLyBXZSBvbmx5IGRlbGV0ZSB0aGUgb2xkZXN0IGVuY291bnRlcmVkIHN1YmplY3QgZnJvbSB0aGUgY2FjaGUsIGFnYWluIHRvXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSB1c2VyJ3MgZXhwZXJpZW5jZSBpc24ndCBkZWdyYWRlZCBieSBtaXNzaW5nIGljb25zIGV0Yy5cbiAgICAgICAgaWYgKHRoaXMuc3ViamVjdHNXaXRob3V0UGVybWlzc2lvbnNFY291bnRlcmVkU2luY2VTdGFydHVwLnNpemUgPj1cbiAgICAgICAgICAgIHRoaXMuc3ViamVjdENhY2hlTGltaXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZE9yaWdpbiA9IHRoaXMuc3ViamVjdHNXaXRob3V0UGVybWlzc2lvbnNFY291bnRlcmVkU2luY2VTdGFydHVwXG4gICAgICAgICAgICAgICAgLnZhbHVlcygpXG4gICAgICAgICAgICAgICAgLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc3ViamVjdHNXaXRob3V0UGVybWlzc2lvbnNFY291bnRlcmVkU2luY2VTdGFydHVwLmRlbGV0ZShjYWNoZWRPcmlnaW4pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN1YmplY3RIYXNQZXJtaXNzaW9ucyhjYWNoZWRPcmlnaW4pKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luVG9Gb3JnZXQgPSBjYWNoZWRPcmlnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJqZWN0c1dpdGhvdXRQZXJtaXNzaW9uc0Vjb3VudGVyZWRTaW5jZVN0YXJ0dXAuYWRkKG9yaWdpbik7XG4gICAgICAgIHRoaXMudXBkYXRlKChkcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICAvLyBUeXBlY2FzdDogdHMoMjU4OSlcbiAgICAgICAgICAgIGRyYWZ0U3RhdGUuc3ViamVjdE1ldGFkYXRhW29yaWdpbl0gPSBuZXdNZXRhZGF0YTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luVG9Gb3JnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRyYWZ0U3RhdGUuc3ViamVjdE1ldGFkYXRhW29yaWdpblRvRm9yZ2V0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYWxsIHN1YmplY3RzIHdpdGhvdXQgcGVybWlzc2lvbnMgZnJvbSB0aGUgY29udHJvbGxlcidzIHN0YXRlLlxuICAgICAqL1xuICAgIHRyaW1NZXRhZGF0YVN0YXRlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgoZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIuZ2V0VHJpbW1lZFN0YXRlKFxuICAgICAgICAgICAgLy8gVHlwZWNhc3Q6IHRzKDI1ODkpXG4gICAgICAgICAgICBkcmFmdFN0YXRlLCB0aGlzLnN1YmplY3RIYXNQZXJtaXNzaW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHN0YXRlIG9iamVjdCB0aGF0IG9ubHkgaW5jbHVkZXMgc3ViamVjdHMgd2l0aCBwZXJtaXNzaW9ucy5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBzdGF0aWMgYmVjYXVzZSB3ZSB3YW50IHRvIGNhbGwgaXQgaW4gdGhlIGNvbnN0cnVjdG9yLCBiZWZvcmVcbiAgICAgKiB0aGUgY29udHJvbGxlcidzIHN0YXRlIGlzIGluaXRpYWxpemVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlIC0gVGhlIHN0YXRlIG9iamVjdCB0byB0cmltLlxuICAgICAqIEBwYXJhbSBoYXNQZXJtaXNzaW9ucyAtIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nXG4gICAgICogd2hldGhlciBhIHBhcnRpY3VsYXIgc3ViamVjdCAoaWRlbnRpZmllZCBieSBpdHMgb3JpZ2luKSBoYXMgYW55XG4gICAgICogcGVybWlzc2lvbnMuXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBzdGF0ZSBvYmplY3QuIElmIHRoZSBzcGVjaWZpZWQgYHN0YXRlYCBvYmplY3QgaGFzIG5vXG4gICAgICogc3ViamVjdCBtZXRhZGF0YSwgdGhlIHJldHVybmVkIG9iamVjdCB3aWxsIGJlIGVxdWl2YWxlbnQgdG8gdGhlIGRlZmF1bHRcbiAgICAgKiBzdGF0ZSBvZiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgc3RhdGljIGdldFRyaW1tZWRTdGF0ZShzdGF0ZSwgaGFzUGVybWlzc2lvbnMpIHtcbiAgICAgICAgY29uc3QgeyBzdWJqZWN0TWV0YWRhdGEgPSB7fSB9ID0gc3RhdGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJqZWN0TWV0YWRhdGE6IE9iamVjdC5rZXlzKHN1YmplY3RNZXRhZGF0YSkucmVkdWNlKChuZXdTdWJqZWN0TWV0YWRhdGEsIG9yaWdpbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChoYXNQZXJtaXNzaW9ucyhvcmlnaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N1YmplY3RNZXRhZGF0YVtvcmlnaW5dID0gc3ViamVjdE1ldGFkYXRhW29yaWdpbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdTdWJqZWN0TWV0YWRhdGE7XG4gICAgICAgICAgICB9LCB7fSksXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5TdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyID0gU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FeGVjdXRpb25FbnZpcm9ubWVudFNlcnZpY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldlYldvcmtlckV4ZWN1dGlvbkVudmlyb25tZW50U2VydmljZSA9IHZvaWQgMDtcbmNvbnN0IG5hbm9pZF8xID0gcmVxdWlyZShcIm5hbm9pZFwiKTtcbmNvbnN0IHB1bXBfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicHVtcFwiKSk7XG5jb25zdCBvYnNfc3RvcmVfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svb2JzLXN0b3JlXCIpO1xuY29uc3Qgb2JqZWN0X211bHRpcGxleF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAbWV0YW1hc2svb2JqZWN0LW11bHRpcGxleFwiKSk7XG5jb25zdCBwb3N0X21lc3NhZ2Vfc3RyZWFtXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3Bvc3QtbWVzc2FnZS1zdHJlYW1cIik7XG5jb25zdCBzbmFwX3dvcmtlcnNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc25hcC13b3JrZXJzXCIpO1xuY29uc3QganNvbl9ycGNfbWlkZGxld2FyZV9zdHJlYW1fMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1taWRkbGV3YXJlLXN0cmVhbVwiKTtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNsYXNzIFdlYldvcmtlckV4ZWN1dGlvbkVudmlyb25tZW50U2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoeyBzZXR1cFNuYXBQcm92aWRlciwgd29ya2VyVXJsLCBtZXNzZW5nZXIsIHVucmVzcG9uc2l2ZVBvbGxpbmdJbnRlcnZhbCA9IDUwMDAsIHVucmVzcG9uc2l2ZVRpbWVvdXQgPSAzMDAwMCwgfSkge1xuICAgICAgICB0aGlzLndvcmtlclVybCA9IHdvcmtlclVybDtcbiAgICAgICAgdGhpcy5zZXR1cFNuYXBQcm92aWRlciA9IHNldHVwU25hcFByb3ZpZGVyO1xuICAgICAgICB0aGlzLnN0b3JlID0gbmV3IG9ic19zdG9yZV8xLk9ic2VydmFibGVTdG9yZSh7IHdvcmtlcnM6IHt9IH0pO1xuICAgICAgICB0aGlzLndvcmtlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc25hcFRvV29ya2VyTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLndvcmtlclRvU25hcE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fc25hcFJwY0hvb2tzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9tZXNzZW5nZXIgPSBtZXNzZW5nZXI7XG4gICAgICAgIHRoaXMuX3VucmVzcG9uc2l2ZVBvbGxpbmdJbnRlcnZhbCA9IHVucmVzcG9uc2l2ZVBvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgdGhpcy5fdW5yZXNwb25zaXZlVGltZW91dCA9IHVucmVzcG9uc2l2ZVRpbWVvdXQ7XG4gICAgICAgIHRoaXMuX3RpbWVvdXRGb3JVbnJlc3BvbnNpdmVNYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIF9zZXRXb3JrZXIod29ya2VySWQsIHdvcmtlcldyYXBwZXIpIHtcbiAgICAgICAgdGhpcy53b3JrZXJzLnNldCh3b3JrZXJJZCwgd29ya2VyV3JhcHBlcik7XG4gICAgICAgIGNvbnN0IG5ld1dvcmtlclN0YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0b3JlLmdldFN0YXRlKCkud29ya2VycyksIHsgW3dvcmtlcklkXTogd29ya2VyV3JhcHBlciB9KTtcbiAgICAgICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IHdvcmtlcnM6IG5ld1dvcmtlclN0YXRlIH0pO1xuICAgIH1cbiAgICBfZGVsZXRlV29ya2VyKHdvcmtlcklkKSB7XG4gICAgICAgIHRoaXMud29ya2Vycy5kZWxldGUod29ya2VySWQpO1xuICAgICAgICBjb25zdCBuZXdXb3JrZXJTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS53b3JrZXJzKTtcbiAgICAgICAgZGVsZXRlIG5ld1dvcmtlclN0YXRlW3dvcmtlcklkXTtcbiAgICAgICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IHdvcmtlcnM6IG5ld1dvcmtlclN0YXRlIH0pO1xuICAgIH1cbiAgICBhc3luYyBfY29tbWFuZCh3b3JrZXJJZCwgbWVzc2FnZSkge1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc2VuZCBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd29ya2VyV3JhcHBlciA9IHRoaXMud29ya2Vycy5nZXQod29ya2VySWQpO1xuICAgICAgICBpZiAoIXdvcmtlcldyYXBwZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV29ya2VyIHdpdGggaWQgJHt3b3JrZXJJZH0gbm90IGZvdW5kLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKCdQYXJlbnQ6IFNlbmRpbmcgQ29tbWFuZCcsIG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdvcmtlcldyYXBwZXIucnBjRW5naW5lLmhhbmRsZShtZXNzYWdlKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2UuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgdGVybWluYXRlQWxsU25hcHMoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgd29ya2VySWQgb2YgdGhpcy53b3JrZXJzLmtleXMoKSkge1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGUod29ya2VySWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NuYXBScGNIb29rcy5jbGVhcigpO1xuICAgIH1cbiAgICBhc3luYyB0ZXJtaW5hdGVTbmFwKHNuYXBOYW1lKSB7XG4gICAgICAgIGNvbnN0IHdvcmtlcklkID0gdGhpcy5zbmFwVG9Xb3JrZXJNYXAuZ2V0KHNuYXBOYW1lKTtcbiAgICAgICAgd29ya2VySWQgJiYgdGhpcy50ZXJtaW5hdGUod29ya2VySWQpO1xuICAgICAgICB0aGlzLl9yZW1vdmVTbmFwSG9va3Moc25hcE5hbWUpO1xuICAgIH1cbiAgICB0ZXJtaW5hdGUod29ya2VySWQpIHtcbiAgICAgICAgY29uc3Qgd29ya2VyV3JhcHBlciA9IHRoaXMud29ya2Vycy5nZXQod29ya2VySWQpO1xuICAgICAgICBpZiAoIXdvcmtlcldyYXBwZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV29ya2VyIHdpdGggaWQgXCIke3dvcmtlcklkfVwiIG5vdCBmb3VuZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzbmFwTmFtZSA9IHRoaXMuX2dldFNuYXBGb3JXb3JrZXIod29ya2VySWQpO1xuICAgICAgICBpZiAoIXNuYXBOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGEgc25hcCBmb3Igd29ya2VyIHdpdGggaWQgXCIke3dvcmtlcklkfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC52YWx1ZXMod29ya2VyV3JhcHBlci5zdHJlYW1zKS5mb3JFYWNoKChzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgIXN0cmVhbS5kZXN0cm95ZWQgJiYgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIHdoaWxlIGRlc3Ryb3lpbmcgc3RyZWFtJywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdvcmtlcldyYXBwZXIud29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICB0aGlzLl9yZW1vdmVTbmFwQW5kV29ya2VyTWFwcGluZyh3b3JrZXJJZCk7XG4gICAgICAgIHRoaXMuX2RlbGV0ZVdvcmtlcih3b3JrZXJJZCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0Rm9yVW5yZXNwb25zaXZlTWFwLmdldCh3b3JrZXJJZCkpO1xuICAgICAgICB0aGlzLl90aW1lb3V0Rm9yVW5yZXNwb25zaXZlTWFwLmRlbGV0ZSh3b3JrZXJJZCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGB3b3JrZXI6JHt3b3JrZXJJZH0gdGVybWluYXRlZGApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBSUEMgbWVzc2FnZSBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gc25hcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzbmFwTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzbmFwIHdob3NlIG1lc3NhZ2UgaGFuZGxlciB0byBnZXQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UnBjTWVzc2FnZUhhbmRsZXIoc25hcE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NuYXBScGNIb29rcy5nZXQoc25hcE5hbWUpO1xuICAgIH1cbiAgICBfcmVtb3ZlU25hcEhvb2tzKHNuYXBOYW1lKSB7XG4gICAgICAgIHRoaXMuX3NuYXBScGNIb29rcy5kZWxldGUoc25hcE5hbWUpO1xuICAgIH1cbiAgICBfY3JlYXRlU25hcEhvb2tzKHNuYXBOYW1lLCB3b3JrZXJJZCkge1xuICAgICAgICBjb25zdCBycGNIb29rID0gYXN5bmMgKG9yaWdpbiwgcmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2NvbW1hbmQod29ya2VySWQsIHtcbiAgICAgICAgICAgICAgICBpZDogbmFub2lkXzEubmFub2lkKCksXG4gICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnc25hcFJwYycsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBzbmFwTmFtZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NuYXBScGNIb29rcy5zZXQoc25hcE5hbWUsIHJwY0hvb2spO1xuICAgIH1cbiAgICBhc3luYyBleGVjdXRlU25hcChzbmFwRGF0YSkge1xuICAgICAgICBpZiAodGhpcy5zbmFwVG9Xb3JrZXJNYXAuaGFzKHNuYXBEYXRhLnNuYXBOYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTbmFwIFwiJHtzbmFwRGF0YS5zbmFwTmFtZX1cIiBpcyBhbHJlYWR5IGJlaW5nIGV4ZWN1dGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdvcmtlciA9IGF3YWl0IHRoaXMuX2luaXRXb3JrZXIoKTtcbiAgICAgICAgdGhpcy5fbWFwU25hcEFuZFdvcmtlcihzbmFwRGF0YS5zbmFwTmFtZSwgd29ya2VyLmlkKTtcbiAgICAgICAgdGhpcy5zZXR1cFNuYXBQcm92aWRlcihzbmFwRGF0YS5zbmFwTmFtZSwgd29ya2VyLnN0cmVhbXMucnBjKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fY29tbWFuZCh3b3JrZXIuaWQsIHtcbiAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgbWV0aG9kOiAnZXhlY3V0ZVNuYXAnLFxuICAgICAgICAgICAgcGFyYW1zOiBzbmFwRGF0YSxcbiAgICAgICAgICAgIGlkOiBuYW5vaWRfMS5uYW5vaWQoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHNldCB1cCBwb2xsL3BpbmcgZm9yIHN0YXR1cyB0byBzZWUgaWYgaXRzIHVwLCBpZiBpdHMgbm90IHRoZW4gZW1pdCBldmVudCB0aGF0IGl0IGNhbnQgYmUgcmVhY2hlZFxuICAgICAgICB0aGlzLl9wb2xsRm9yV29ya2VyU3RhdHVzKHNuYXBEYXRhLnNuYXBOYW1lKTtcbiAgICAgICAgdGhpcy5fY3JlYXRlU25hcEhvb2tzKHNuYXBEYXRhLnNuYXBOYW1lLCB3b3JrZXIuaWQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfcG9sbEZvcldvcmtlclN0YXR1cyhzbmFwTmFtZSkge1xuICAgICAgICBjb25zdCB3b3JrZXJJZCA9IHRoaXMuX2dldFdvcmtlckZvclNuYXAoc25hcE5hbWUpO1xuICAgICAgICBpZiAoIXdvcmtlcklkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHdvcmtlciBpZCBmb3VuZCBmb3Igc25hcCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2dldFdvcmtlclN0YXR1cyh3b3JrZXJJZClcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9sbEZvcldvcmtlclN0YXR1cyhzbmFwTmFtZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVzc2VuZ2VyLnB1Ymxpc2goJ1NlcnZpY2VNZXNzZW5nZXI6dW5yZXNwb25zaXZlJywgc25hcE5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRoaXMuX3VucmVzcG9uc2l2ZVBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuX3RpbWVvdXRGb3JVbnJlc3BvbnNpdmVNYXAuc2V0KHNuYXBOYW1lLCB0aW1lb3V0KTtcbiAgICB9XG4gICAgYXN5bmMgX2dldFdvcmtlclN0YXR1cyh3b3JrZXJJZCkge1xuICAgICAgICBsZXQgcmVzb2x2ZTtcbiAgICAgICAgbGV0IHJlamVjdDtcbiAgICAgICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUgPSByZXM7XG4gICAgICAgICAgICByZWplY3QgPSByZWo7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdwaW5nIHJlcXVlc3QgdGltZWQgb3V0JykpO1xuICAgICAgICB9LCB0aGlzLl91bnJlc3BvbnNpdmVUaW1lb3V0KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICAgICAgICB0aGlzLl9jb21tYW5kKHdvcmtlcklkLCB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAncGluZycsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgICAgICAgICBpZDogbmFub2lkXzEubmFub2lkKCksXG4gICAgICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aW1lb3V0UHJvbWlzZSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIF9tYXBTbmFwQW5kV29ya2VyKHNuYXBOYW1lLCB3b3JrZXJJZCkge1xuICAgICAgICB0aGlzLnNuYXBUb1dvcmtlck1hcC5zZXQoc25hcE5hbWUsIHdvcmtlcklkKTtcbiAgICAgICAgdGhpcy53b3JrZXJUb1NuYXBNYXAuc2V0KHdvcmtlcklkLCBzbmFwTmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBJRCBvZiB0aGUgc25hcCdzIHdvcmtlci5cbiAgICAgKi9cbiAgICBfZ2V0V29ya2VyRm9yU25hcChzbmFwTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbmFwVG9Xb3JrZXJNYXAuZ2V0KHNuYXBOYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIElEIHdvcmtlcidzIHNuYXAuXG4gICAgICovXG4gICAgX2dldFNuYXBGb3JXb3JrZXIod29ya2VySWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud29ya2VyVG9TbmFwTWFwLmdldCh3b3JrZXJJZCk7XG4gICAgfVxuICAgIF9yZW1vdmVTbmFwQW5kV29ya2VyTWFwcGluZyh3b3JrZXJJZCkge1xuICAgICAgICBjb25zdCBzbmFwTmFtZSA9IHRoaXMud29ya2VyVG9TbmFwTWFwLmdldCh3b3JrZXJJZCk7XG4gICAgICAgIGlmICghc25hcE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgd29ya2VyOiR7d29ya2VySWR9IGhhcyBubyBtYXBwZWQgc25hcC5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndvcmtlclRvU25hcE1hcC5kZWxldGUod29ya2VySWQpO1xuICAgICAgICB0aGlzLnNuYXBUb1dvcmtlck1hcC5kZWxldGUoc25hcE5hbWUpO1xuICAgIH1cbiAgICBhc3luYyBfaW5pdFdvcmtlcigpIHtcbiAgICAgICAgY29uc3Qgd29ya2VySWQgPSBuYW5vaWRfMS5uYW5vaWQoKTtcbiAgICAgICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcih0aGlzLndvcmtlclVybCwge1xuICAgICAgICAgICAgbmFtZTogd29ya2VySWQsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBIYW5kbGUgb3V0LW9mLWJhbmQgZXJyb3JzLCBpLmUuIGVycm9ycyB0aHJvd24gZnJvbSB0aGUgc25hcCBvdXRzaWRlIG9mIHRoZSByZXEvcmVzIGN5Y2xlLlxuICAgICAgICBjb25zdCBlcnJvckhhbmRsZXIgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tZXNzZW5nZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzbmFwTmFtZSA9IHRoaXMud29ya2VyVG9TbmFwTWFwLmdldCh3b3JrZXJJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHNuYXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lc3Nlbmdlci5wdWJsaXNoKCdTZXJ2aWNlTWVzc2VuZ2VyOnVuaGFuZGxlZEVycm9yJywgc25hcE5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGV2LmVycm9yLmNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBldi5lcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZXYuZXJyb3IuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvckhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3Qgc3RyZWFtcyA9IHRoaXMuX2luaXRXb3JrZXJTdHJlYW1zKHdvcmtlciwgd29ya2VySWQpO1xuICAgICAgICBjb25zdCBycGNFbmdpbmUgPSBuZXcganNvbl9ycGNfZW5naW5lXzEuSnNvblJwY0VuZ2luZSgpO1xuICAgICAgICBjb25zdCBqc29uUnBjQ29ubmVjdGlvbiA9IGpzb25fcnBjX21pZGRsZXdhcmVfc3RyZWFtXzEuY3JlYXRlU3RyZWFtTWlkZGxld2FyZSgpO1xuICAgICAgICBwdW1wXzEuZGVmYXVsdChqc29uUnBjQ29ubmVjdGlvbi5zdHJlYW0sIHN0cmVhbXMuY29tbWFuZCwganNvblJwY0Nvbm5lY3Rpb24uc3RyZWFtKTtcbiAgICAgICAgcnBjRW5naW5lLnB1c2goanNvblJwY0Nvbm5lY3Rpb24ubWlkZGxld2FyZSk7XG4gICAgICAgIGNvbnN0IHdvcmtlcldyYXBwZXIgPSB7XG4gICAgICAgICAgICBpZDogd29ya2VySWQsXG4gICAgICAgICAgICBzdHJlYW1zLFxuICAgICAgICAgICAgcnBjRW5naW5lLFxuICAgICAgICAgICAgd29ya2VyLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZXRXb3JrZXIod29ya2VySWQsIHdvcmtlcldyYXBwZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9jb21tYW5kKHdvcmtlcklkLCB7XG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgIG1ldGhvZDogJ3BpbmcnLFxuICAgICAgICAgICAgaWQ6IG5hbm9pZF8xLm5hbm9pZCgpLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdvcmtlcldyYXBwZXI7XG4gICAgfVxuICAgIF9pbml0V29ya2VyU3RyZWFtcyh3b3JrZXIsIHdvcmtlcklkKSB7XG4gICAgICAgIGNvbnN0IHdvcmtlclN0cmVhbSA9IG5ldyBwb3N0X21lc3NhZ2Vfc3RyZWFtXzEuV29ya2VyUGFyZW50UG9zdE1lc3NhZ2VTdHJlYW0oeyB3b3JrZXIgfSk7XG4gICAgICAgIC8vIFR5cGVjYXN0IGp1c3RpZmljYXRpb246IHN0cmVhbSB0eXBlIG1pc21hdGNoXG4gICAgICAgIGNvbnN0IG11eCA9IHNldHVwTXVsdGlwbGV4KHdvcmtlclN0cmVhbSwgYFdvcmtlcjoke3dvcmtlcklkfWApO1xuICAgICAgICBjb25zdCBjb21tYW5kU3RyZWFtID0gbXV4LmNyZWF0ZVN0cmVhbShzbmFwX3dvcmtlcnNfMS5TTkFQX1NUUkVBTV9OQU1FUy5DT01NQU5EKTtcbiAgICAgICAgY29uc3QgcnBjU3RyZWFtID0gbXV4LmNyZWF0ZVN0cmVhbShzbmFwX3dvcmtlcnNfMS5TTkFQX1NUUkVBTV9OQU1FUy5KU09OX1JQQyk7XG4gICAgICAgIC8vIFR5cGVjYXN0OiBzdHJlYW0gdHlwZSBtaXNtYXRjaFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tbWFuZDogY29tbWFuZFN0cmVhbSxcbiAgICAgICAgICAgIHJwYzogcnBjU3RyZWFtLFxuICAgICAgICAgICAgX2Nvbm5lY3Rpb246IHdvcmtlclN0cmVhbSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLldlYldvcmtlckV4ZWN1dGlvbkVudmlyb25tZW50U2VydmljZSA9IFdlYldvcmtlckV4ZWN1dGlvbkVudmlyb25tZW50U2VydmljZTtcbi8qKlxuICogU2V0cyB1cCBzdHJlYW0gbXVsdGlwbGV4aW5nIGZvciB0aGUgZ2l2ZW4gc3RyZWFtLlxuICpcbiAqIEBwYXJhbSB7YW55fSBjb25uZWN0aW9uU3RyZWFtIC0gdGhlIHN0cmVhbSB0byBtdXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJlYW1OYW1lIC0gdGhlIG5hbWUgb2YgdGhlIHN0cmVhbSwgZm9yIGlkZW50aWZpY2F0aW9uIGluIGVycm9yc1xuICogQHJldHVybiB7c3RyZWFtLlN0cmVhbX0gdGhlIG11bHRpcGxleGVkIHN0cmVhbVxuICovXG5mdW5jdGlvbiBzZXR1cE11bHRpcGxleChjb25uZWN0aW9uU3RyZWFtLCBzdHJlYW1OYW1lKSB7XG4gICAgY29uc3QgbXV4ID0gbmV3IG9iamVjdF9tdWx0aXBsZXhfMS5kZWZhdWx0KCk7XG4gICAgcHVtcF8xLmRlZmF1bHQoY29ubmVjdGlvblN0cmVhbSwgXG4gICAgLy8gVHlwZWNhc3Q6IHN0cmVhbSB0eXBlIG1pc21hdGNoXG4gICAgbXV4LCBjb25uZWN0aW9uU3RyZWFtLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHN0cmVhbU5hbWVcbiAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoYCR7c3RyZWFtTmFtZX0gc3RyZWFtIGZhaWx1cmUuYCwgZXJyKVxuICAgICAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG11eDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdlYldvcmtlckV4ZWN1dGlvbkVudmlyb25tZW50U2VydmljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRXh0ZXJuYWxSZXNvdXJjZUNvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBvYnNfc3RvcmVfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svb2JzLXN0b3JlXCIpO1xuY29uc3Qgc2FmZV9ldmVudF9lbWl0dGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBtZXRhbWFzay9zYWZlLWV2ZW50LWVtaXR0ZXJcIikpO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbmNvbnN0IG5hbm9pZF8xID0gcmVxdWlyZShcIm5hbm9pZFwiKTtcbmNvbnN0IGFsd2F5c1JlcXVpcmVkRmllbGRzID0gWydmcm9tRG9tYWluJ107XG5jb25zdCBjb21wdXRlU3RhdGUgPSAoc3RvcmFnZUtleSwgaW5pdGlhbFJlc291cmNlcykgPT4ge1xuICAgIHJldHVybiB7IFtzdG9yYWdlS2V5XTogaW5pdGlhbFJlc291cmNlcyB9O1xufTtcbmNvbnN0IGdldFVuYXV0aG9yaXplZE1lc3NhZ2UgPSAoaWQpID0+IGBOb3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgcmVzb3VyY2Ugd2l0aCBpZCBcIiR7aWR9XCIuYDtcbi8qKlxuICogQSBjbGFzcyBpbnRlbmRlZCB0byBkZXNjcmliZSBhIHBhcnRpY3VsYXIgcmVzb3VyY2UgdGhhdCBpcyBtYW5hZ2VkIGJ5IHNuYXBzLlxuICogRXhhbXBsZSByZXNvdXJjZXMgYXJlIGFzc2V0cy5cbiAqXG4gKiBUaGVzZSBhcmUgdGhpbmdzIHRoYXQgTWV0YU1hc2sgdHJlYXRzIGFzIGZpcnN0LWNsYXNzIG9iamVjdHMgd2l0aCBkaXN0aW5jdCBwcm9wZXJ0aWVzIHdpdGhpbiBpdHMgb3duIFVJLlxuICovXG5jbGFzcyBFeHRlcm5hbFJlc291cmNlQ29udHJvbGxlciBleHRlbmRzIHNhZmVfZXZlbnRfZW1pdHRlcl8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKHsgc3RvcmFnZUtleSwgcmVxdWlyZWRGaWVsZHMsIGluaXRpYWxSZXNvdXJjZXMsIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZXF1aXJlZEZpZWxkcyA9IHJlcXVpcmVkRmllbGRzO1xuICAgICAgICB0aGlzLnN0b3JhZ2VLZXkgPSBzdG9yYWdlS2V5O1xuICAgICAgICB0aGlzLnN0b3JlID0gbmV3IG9ic19zdG9yZV8xLk9ic2VydmFibGVTdG9yZShjb21wdXRlU3RhdGUoc3RvcmFnZUtleSwgaW5pdGlhbFJlc291cmNlcykpO1xuICAgIH1cbiAgICBnZXRSZXNvdXJjZXMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0b3JlLmdldFN0YXRlKClbdGhpcy5zdG9yYWdlS2V5XSk7XG4gICAgfVxuICAgIHNldFJlc291cmNlcyhyZXNvdXJjZXMpIHtcbiAgICAgICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICAgICAgICBbdGhpcy5zdG9yYWdlS2V5XTogcmVzb3VyY2VzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xlYXJSZXNvdXJjZXMoKSB7XG4gICAgICAgIHRoaXMuc2V0UmVzb3VyY2VzKHt9KTtcbiAgICB9XG4gICAgZGVsZXRlUmVzb3VyY2VzRm9yKGZyb21Eb21haW4pIHtcbiAgICAgICAgY29uc3QgcmVzb3VyY2VzID0gdGhpcy5nZXRSZXNvdXJjZXMoKTtcbiAgICAgICAgY29uc3QgbmV3UmVzb3VyY2VzID0gT2JqZWN0LmVudHJpZXMocmVzb3VyY2VzKS5yZWR1Y2UoKGFjYywgW2lkLCByZXNvdXJjZV0pID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZS5mcm9tRG9tYWluICE9PSBmcm9tRG9tYWluKSB7XG4gICAgICAgICAgICAgICAgYWNjW2lkXSA9IHJlc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICB0aGlzLnNldFJlc291cmNlcyhuZXdSZXNvdXJjZXMpO1xuICAgIH1cbiAgICBnZXQoZnJvbURvbWFpbiwgaWQpIHtcbiAgICAgICAgY29uc3QgcmVzb3VyY2UgPSB0aGlzLmdldFJlc291cmNlcygpW2lkXTtcbiAgICAgICAgaWYgKHJlc291cmNlICYmIHJlc291cmNlLmZyb21Eb21haW4gIT09IGZyb21Eb21haW4pIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnByb3ZpZGVyLnVuYXV0aG9yaXplZCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZ2V0VW5hdXRob3JpemVkTWVzc2FnZShpZCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb3VyY2UgPyBPYmplY3QuYXNzaWduKHt9LCByZXNvdXJjZSkgOiBudWxsO1xuICAgIH1cbiAgICBnZXRBbGxSZXNvdXJjZXMoZnJvbURvbWFpbikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLmdldFJlc291cmNlcygpKS5maWx0ZXIoKHJlc291cmNlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb3VyY2UuZnJvbURvbWFpbiA9PT0gZnJvbURvbWFpbjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZChmcm9tRG9tYWluLCByZXNvdXJjZSkge1xuICAgICAgICBjb25zdCBuZXdSZXNvdXJjZSA9IHRoaXMucHJvY2Vzc05ld1Jlc291cmNlKGZyb21Eb21haW4sIHJlc291cmNlKTtcbiAgICAgICAgY29uc3QgeyBpZCB9ID0gbmV3UmVzb3VyY2U7XG4gICAgICAgIGNvbnN0IHJlc291cmNlcyA9IHRoaXMuZ2V0UmVzb3VyY2VzKCk7XG4gICAgICAgIGlmIChyZXNvdXJjZXNbaWRdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlc291cmNlIHdpdGggaWQgXCIke2lkfVwiIGFscmVhZHkgZXhpc3RzLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb3VyY2VzW2lkXSA9IG5ld1Jlc291cmNlO1xuICAgICAgICAgICAgdGhpcy5zZXRSZXNvdXJjZXMocmVzb3VyY2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3UmVzb3VyY2UuaWQ7XG4gICAgfVxuICAgIHVwZGF0ZShmcm9tRG9tYWluLCByZXNvdXJjZSkge1xuICAgICAgICBjb25zdCB7IGlkIH0gPSByZXNvdXJjZTtcbiAgICAgICAgY29uc3QgcmVzb3VyY2VzID0gdGhpcy5nZXRSZXNvdXJjZXMoKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdSZXNvdXJjZSA9IHJlc291cmNlc1tpZF07XG4gICAgICAgIGlmICghZXhpc3RpbmdSZXNvdXJjZSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLnJlc291cmNlTm90Rm91bmQoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBSZXNvdXJjZSB3aXRoIGlkIFwiJHtpZH1cIiBub3QgZm91bmQuYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4aXN0aW5nUmVzb3VyY2UuZnJvbURvbWFpbiAhPT0gZnJvbURvbWFpbikge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucHJvdmlkZXIudW5hdXRob3JpemVkKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBnZXRVbmF1dGhvcml6ZWRNZXNzYWdlKGlkKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc291cmNlc1tpZF0gPSB0aGlzLnByb2Nlc3NOZXdSZXNvdXJjZShmcm9tRG9tYWluLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc291cmNlc1tpZF0pLCByZXNvdXJjZSkpO1xuICAgICAgICB0aGlzLnNldFJlc291cmNlcyhyZXNvdXJjZXMpO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIHByb2Nlc3NOZXdSZXNvdXJjZShmcm9tRG9tYWluLCByZXNvdXJjZSkge1xuICAgICAgICB0aGlzLnJlcXVpcmVkRmllbGRzLmZvckVhY2goKHJlcXVpcmVkRmllbGQpID0+IHtcbiAgICAgICAgICAgIGlmICghKHJlcXVpcmVkRmllbGQgaW4gcmVzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoYFJlc291cmNlIGZyb20gXCIke2Zyb21Eb21haW59XCIgbWlzc2luZyByZXF1aXJlZCBmaWVsZDogJHtyZXF1aXJlZEZpZWxkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzb3VyY2UpLCB7IGZyb21Eb21haW4sIGlkOiByZXNvdXJjZS5pZCB8fCBuYW5vaWRfMS5uYW5vaWQoKSB9KTtcbiAgICB9XG4gICAgZGVsZXRlKGZyb21Eb21haW4sIGlkKSB7XG4gICAgICAgIGNvbnN0IHJlc291cmNlcyA9IHRoaXMuZ2V0UmVzb3VyY2VzKCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nUmVzb3VyY2UgPSByZXNvdXJjZXNbaWRdO1xuICAgICAgICBpZiAoIWV4aXN0aW5nUmVzb3VyY2UpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgUmVzb3VyY2Ugd2l0aCBpZCBcIiR7aWR9XCIgbm90IGZvdW5kLmAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleGlzdGluZ1Jlc291cmNlLmZyb21Eb21haW4gIT09IGZyb21Eb21haW4pIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnByb3ZpZGVyLnVuYXV0aG9yaXplZCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZ2V0VW5hdXRob3JpemVkTWVzc2FnZShpZCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgcmVzb3VyY2VzW2lkXTtcbiAgICAgICAgdGhpcy5zZXRSZXNvdXJjZXMocmVzb3VyY2VzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGhhbmRsZVJwY1JlcXVlc3QoZnJvbURvbWFpbiwgbWV0aG9kLCBhcmcpIHtcbiAgICAgICAgaWYgKCFmcm9tRG9tYWluIHx8IHR5cGVvZiBmcm9tRG9tYWluICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZyb21Eb21haW4uJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgJ2dldCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGZyb21Eb21haW4sIGFyZyk7XG4gICAgICAgICAgICBjYXNlICdnZXRBbGwnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFsbFJlc291cmNlcyhmcm9tRG9tYWluKTtcbiAgICAgICAgICAgIGNhc2UgJ2FkZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGZyb21Eb21haW4sIGFyZyk7XG4gICAgICAgICAgICBjYXNlICd1cGRhdGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShmcm9tRG9tYWluLCBhcmcpO1xuICAgICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxldGUoZnJvbURvbWFpbiwgYXJnKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdEZvdW5kKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYE5vdCBhbiBhc3NldCBtZXRob2Q6ICR7bWV0aG9kfWAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkV4dGVybmFsUmVzb3VyY2VDb250cm9sbGVyID0gRXh0ZXJuYWxSZXNvdXJjZUNvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FeHRlcm5hbFJlc291cmNlQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWV0aG9kTmFtZXMgPSB2b2lkIDA7XG52YXIgTWV0aG9kTmFtZXM7XG4oZnVuY3Rpb24gKE1ldGhvZE5hbWVzKSB7XG4gICAgTWV0aG9kTmFtZXNbXCJyZXF1ZXN0UGVybWlzc2lvbnNcIl0gPSBcIndhbGxldF9yZXF1ZXN0UGVybWlzc2lvbnNcIjtcbiAgICBNZXRob2ROYW1lc1tcImdldFBlcm1pc3Npb25zXCJdID0gXCJ3YWxsZXRfZ2V0UGVybWlzc2lvbnNcIjtcbn0pKE1ldGhvZE5hbWVzID0gZXhwb3J0cy5NZXRob2ROYW1lcyB8fCAoZXhwb3J0cy5NZXRob2ROYW1lcyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZmluZENhdmVhdCA9IGV4cG9ydHMuY29uc3RydWN0UGVybWlzc2lvbiA9IHZvaWQgMDtcbmNvbnN0IG5hbm9pZF8xID0gcmVxdWlyZShcIm5hbm9pZFwiKTtcbi8qKlxuICogVGhlIGRlZmF1bHQgcGVybWlzc2lvbiBmYWN0b3J5IGZ1bmN0aW9uLiBOYWl2ZWx5IGNvbnN0cnVjdHMgYSBwZXJtaXNzaW9uIGZyb21cbiAqIHRoZSBpbnB1dHMuIFNldHMgYSBkZWZhdWx0LCByYW5kb20gYGlkYCBpZiBub25lIGlzIHByb3ZpZGVkLlxuICpcbiAqIEBzZWUge0BsaW5rIFBlcm1pc3Npb259IEZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHRlbXBsYXRlIFRhcmdldFBlcm1pc3Npb24gLSBUaGUge0BsaW5rIFBlcm1pc3Npb259IHRoYXQgd2lsbCBiZSBjb25zdHJ1Y3RlZC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBwZXJtaXNzaW9uLlxuICogQHJldHVybnMgVGhlIG5ldyBwZXJtaXNzaW9uIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0UGVybWlzc2lvbihvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjYXZlYXRzID0gbnVsbCwgaW52b2tlciwgdGFyZ2V0IH0gPSBvcHRpb25zO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBuYW5vaWRfMS5uYW5vaWQoKSxcbiAgICAgICAgcGFyZW50Q2FwYWJpbGl0eTogdGFyZ2V0LFxuICAgICAgICBpbnZva2VyLFxuICAgICAgICBjYXZlYXRzLFxuICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICB9O1xufVxuZXhwb3J0cy5jb25zdHJ1Y3RQZXJtaXNzaW9uID0gY29uc3RydWN0UGVybWlzc2lvbjtcbi8qKlxuICogR2V0cyB0aGUgY2F2ZWF0IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBiZWxvbmdpbmcgdG8gdGhlIHNwZWNpZmllZCBwZXJtaXNzaW9uLlxuICpcbiAqIEBwYXJhbSBwZXJtaXNzaW9uIFRoZSBwZXJtaXNzaW9uIHdob3NlIGNhdmVhdCB0byByZXRyaWV2ZS5cbiAqIEBwYXJhbSBjYXZlYXRUeXBlIFRoZSB0eXBlIG9mIHRoZSBjYXZlYXQgdG8gcmV0cmlldmUuXG4gKiBAcmV0dXJucyBUaGUgY2F2ZWF0LCBvciB1bmRlZmluZWQgaWYgbm8gc3VjaCBjYXZlYXQgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBmaW5kQ2F2ZWF0KHBlcm1pc3Npb24sIGNhdmVhdFR5cGUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHBlcm1pc3Npb24uY2F2ZWF0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbmQoKGNhdmVhdCkgPT4gY2F2ZWF0LnR5cGUgPT09IGNhdmVhdFR5cGUpO1xufVxuZXhwb3J0cy5maW5kQ2F2ZWF0ID0gZmluZENhdmVhdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBlcm1pc3Npb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29yYXRlV2l0aENhdmVhdHMgPSB2b2lkIDA7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbi8qKlxuICogRGVjb3JhdGUgYSByZXN0cmljdGVkIG1ldGhvZCBpbXBsZW1lbnRhdGlvbiB3aXRoIGl0cyBjYXZlYXRzLlxuICpcbiAqIE5vdGUgdGhhdCBhbGwgY2F2ZWF0IGZ1bmN0aW9ucyAoaS5lLiB0aGUgYXJndW1lbnQgYW5kIHJldHVybiB2YWx1ZSBvZiB0aGVcbiAqIGRlY29yYXRvcikgbXVzdCBiZSBhd2FpdGVkLlxuICovXG5mdW5jdGlvbiBkZWNvcmF0ZVdpdGhDYXZlYXRzKG1ldGhvZEltcGxlbWVudGF0aW9uLCBwZXJtaXNzaW9uLCAvLyBib3VuZCB0byB0aGUgcmVxdWVzdGluZyBvcmlnaW5cbmNhdmVhdFNwZWNpZmljYXRpb25zKSB7XG4gICAgY29uc3QgeyBjYXZlYXRzIH0gPSBwZXJtaXNzaW9uO1xuICAgIGlmICghY2F2ZWF0cykge1xuICAgICAgICByZXR1cm4gbWV0aG9kSW1wbGVtZW50YXRpb247XG4gICAgfVxuICAgIGxldCBkZWNvcmF0ZWQgPSBhc3luYyAoYXJncykgPT4gbWV0aG9kSW1wbGVtZW50YXRpb24oYXJncyk7XG4gICAgZm9yIChjb25zdCBjYXZlYXQgb2YgY2F2ZWF0cykge1xuICAgICAgICBjb25zdCBzcGVjaWZpY2F0aW9uID0gY2F2ZWF0U3BlY2lmaWNhdGlvbnNbY2F2ZWF0LnR5cGVdO1xuICAgICAgICBpZiAoIXNwZWNpZmljYXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnJlY29nbml6ZWRDYXZlYXRUeXBlRXJyb3IoY2F2ZWF0LnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGRlY29yYXRlZCA9IHNwZWNpZmljYXRpb24uZGVjb3JhdG9yKGRlY29yYXRlZCwgY2F2ZWF0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29yYXRlZDtcbn1cbmV4cG9ydHMuZGVjb3JhdGVXaXRoQ2F2ZWF0cyA9IGRlY29yYXRlV2l0aENhdmVhdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYXZlYXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhbmRsZXJzID0gdm9pZCAwO1xuY29uc3QgcmVxdWVzdFBlcm1pc3Npb25zXzEgPSByZXF1aXJlKFwiLi9yZXF1ZXN0UGVybWlzc2lvbnNcIik7XG5jb25zdCBnZXRQZXJtaXNzaW9uc18xID0gcmVxdWlyZShcIi4vZ2V0UGVybWlzc2lvbnNcIik7XG5leHBvcnRzLmhhbmRsZXJzID0gW3JlcXVlc3RQZXJtaXNzaW9uc18xLnJlcXVlc3RQZXJtaXNzaW9uc0hhbmRsZXIsIGdldFBlcm1pc3Npb25zXzEuZ2V0UGVybWlzc2lvbnNIYW5kbGVyXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QZXJtaXNzaW9uQ29udHJvbGxlciA9IGV4cG9ydHMuQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGNvbnRyb2xsZXJzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL2NvbnRyb2xsZXJzXCIpO1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbmNvbnN0IGRlZXBfZnJlZXplX3N0cmljdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWVwLWZyZWV6ZS1zdHJpY3RcIikpO1xuY29uc3QgaW1tZXJfMSA9IHJlcXVpcmUoXCJpbW1lclwiKTtcbmNvbnN0IG5hbm9pZF8xID0gcmVxdWlyZShcIm5hbm9pZFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBDYXZlYXRfMSA9IHJlcXVpcmUoXCIuL0NhdmVhdFwiKTtcbmNvbnN0IFBlcm1pc3Npb25fMSA9IHJlcXVpcmUoXCIuL1Blcm1pc3Npb25cIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IHV0aWxzXzIgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IHBlcm1pc3Npb25fbWlkZGxld2FyZV8xID0gcmVxdWlyZShcIi4vcGVybWlzc2lvbi1taWRkbGV3YXJlXCIpO1xuLyoqXG4gKiBUaGUgbmFtZSBvZiB0aGUge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyfS5cbiAqL1xuY29uc3QgY29udHJvbGxlck5hbWUgPSAnUGVybWlzc2lvbkNvbnRyb2xsZXInO1xuLyoqXG4gKiBHZXQgdGhlIHN0YXRlIG1ldGFkYXRhIG9mIHRoZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXJ9LlxuICpcbiAqIEB0ZW1wbGF0ZSBQZXJtaXNzaW9uIC0gVGhlIGNvbnRyb2xsZXIncyBwZXJtaXNzaW9uIHR5cGUgdW5pb24uXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXRlTWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHsgc3ViamVjdHM6IHsgYW5vbnltb3VzOiB0cnVlLCBwZXJzaXN0OiB0cnVlIH0gfTtcbn1cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHN0YXRlIG9mIHRoZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXJ9LlxuICpcbiAqIEB0ZW1wbGF0ZSBQZXJtaXNzaW9uIC0gVGhlIGNvbnRyb2xsZXIncyBwZXJtaXNzaW9uIHR5cGUgdW5pb24uXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRTdGF0ZSgpIHtcbiAgICByZXR1cm4geyBzdWJqZWN0czoge30gfTtcbn1cbi8qKlxuICogRGVzY3JpYmVzIHRoZSBwb3NzaWJsZSByZXN1bHRzIG9mIGEge0BsaW5rIENhdmVhdE11dGF0b3J9IGZ1bmN0aW9uLlxuICovXG52YXIgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbjtcbihmdW5jdGlvbiAoQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbikge1xuICAgIENhdmVhdE11dGF0b3JPcGVyYXRpb25bQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbltcIm5vb3BcIl0gPSAwXSA9IFwibm9vcFwiO1xuICAgIENhdmVhdE11dGF0b3JPcGVyYXRpb25bQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbltcInVwZGF0ZVZhbHVlXCJdID0gMV0gPSBcInVwZGF0ZVZhbHVlXCI7XG4gICAgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbltDYXZlYXRNdXRhdG9yT3BlcmF0aW9uW1wiZGVsZXRlQ2F2ZWF0XCJdID0gMl0gPSBcImRlbGV0ZUNhdmVhdFwiO1xuICAgIENhdmVhdE11dGF0b3JPcGVyYXRpb25bQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbltcInJldm9rZVBlcm1pc3Npb25cIl0gPSAzXSA9IFwicmV2b2tlUGVybWlzc2lvblwiO1xufSkoQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbiA9IGV4cG9ydHMuQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbiB8fCAoZXhwb3J0cy5DYXZlYXRNdXRhdG9yT3BlcmF0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIHBlcm1pc3Npb24gY29udHJvbGxlci4gU2VlIHRoZSBSRUFETUUgZm9yIGRldGFpbHMuXG4gKlxuICogQXNzdW1lcyB0aGUgZXhpc3RlbmNlIG9mIGFuIHtAbGluayBBcHByb3ZhbENvbnRyb2xsZXJ9IHJlYWNoYWJsZSB2aWEgdGhlXG4gKiB7QGxpbmsgQ29udHJvbGxlck1lc3Nlbmdlcn0uXG4gKlxuICogQHRlbXBsYXRlIENvbnRyb2xsZXJQZXJtaXNzaW9uU3BlY2lmaWNhdGlvbiAtIEEgdW5pb24gb2YgdGhlIHR5cGVzIG9mIGFsbFxuICogcGVybWlzc2lvbiBzcGVjaWZpY2F0aW9ucyBhdmFpbGFibGUgdG8gdGhlIGNvbnRyb2xsZXIuIEFueSByZWZlcmVuY2VkIGNhdmVhdHNcbiAqIG11c3QgYmUgaW5jbHVkZWQgaW4gdGhlIGNvbnRyb2xsZXIncyBjYXZlYXQgc3BlY2lmaWNhdGlvbnMuXG4gKiBAdGVtcGxhdGUgQ29udHJvbGxlckNhdmVhdFNwZWNpZmljYXRpb24gLSBBIHVuaW9uIG9mIHRoZSB0eXBlcyBvZiBhbGxcbiAqIGNhdmVhdCBzcGVjaWZpY2F0aW9ucyBhdmFpbGFibGUgdG8gdGhlIGNvbnRyb2xsZXIuXG4gKi9cbmNsYXNzIFBlcm1pc3Npb25Db250cm9sbGVyIGV4dGVuZHMgY29udHJvbGxlcnNfMS5CYXNlQ29udHJvbGxlclYyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFBlcm1pc3Npb24gY29udHJvbGxlciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNhdmVhdFNwZWNpZmljYXRpb25zIC0gVGhlIHNwZWNpZmljYXRpb25zIG9mIGFsbCBjYXZlYXRzXG4gICAgICogYXZhaWxhYmxlIHRvIHRoZSBjb250cm9sbGVyLiBTZWUge0BsaW5rIENhdmVhdFNwZWNpZmljYXRpb25NYXB9IGFuZCB0aGVcbiAgICAgKiBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGVybWlzc2lvblNwZWNpZmljYXRpb25zIC0gVGhlIHNwZWNpZmljYXRpb25zIG9mIGFsbFxuICAgICAqIHBlcm1pc3Npb25zIGF2YWlsYWJsZSB0byB0aGUgY29udHJvbGxlci4gU2VlXG4gICAgICoge0BsaW5rIFBlcm1pc3Npb25TcGVjaWZpY2F0aW9uTWFwfSBhbmQgdGhlIFJFQURNRSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnVucmVzdHJpY3RlZE1ldGhvZHMgLSBUaGUgY2FsbGFibGUgbmFtZXMgb2YgYWxsIEpTT04tUlBDXG4gICAgICogbWV0aG9kcyBpZ25vcmVkIGJ5IHRoZSBuZXcgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5tZXNzZW5nZXIgLSBUaGUgY29udHJvbGxlciBtZXNzZW5nZXIuIFNlZVxuICAgICAqIHtAbGluayBCYXNlQ29udHJvbGxlcn0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3RhdGUgLSBFeGlzdGluZyBzdGF0ZSB0byBoeWRyYXRlIHRoZSBjb250cm9sbGVyIHdpdGggYXRcbiAgICAgKiBpbml0aWFsaXphdGlvbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgY2F2ZWF0U3BlY2lmaWNhdGlvbnMsIHBlcm1pc3Npb25TcGVjaWZpY2F0aW9ucywgdW5yZXN0cmljdGVkTWV0aG9kcywgbWVzc2VuZ2VyLCBzdGF0ZSA9IHt9LCB9ID0gb3B0aW9ucztcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbmFtZTogY29udHJvbGxlck5hbWUsXG4gICAgICAgICAgICBtZXRhZGF0YTogZ2V0U3RhdGVNZXRhZGF0YSgpLFxuICAgICAgICAgICAgbWVzc2VuZ2VyLFxuICAgICAgICAgICAgc3RhdGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZ2V0RGVmYXVsdFN0YXRlKCkpLCBzdGF0ZSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl91bnJlc3RyaWN0ZWRNZXRob2RzID0gbmV3IFNldCh1bnJlc3RyaWN0ZWRNZXRob2RzKTtcbiAgICAgICAgdGhpcy5fY2F2ZWF0U3BlY2lmaWNhdGlvbnMgPSBkZWVwX2ZyZWV6ZV9zdHJpY3RfMS5kZWZhdWx0KE9iamVjdC5hc3NpZ24oe30sIGNhdmVhdFNwZWNpZmljYXRpb25zKSk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVQZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMocGVybWlzc2lvblNwZWNpZmljYXRpb25zLCB0aGlzLl9jYXZlYXRTcGVjaWZpY2F0aW9ucyk7XG4gICAgICAgIHRoaXMuX3Blcm1pc3Npb25TcGVjaWZpY2F0aW9ucyA9IGRlZXBfZnJlZXplX3N0cmljdF8xLmRlZmF1bHQoT2JqZWN0LmFzc2lnbih7fSwgcGVybWlzc2lvblNwZWNpZmljYXRpb25zKSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVQZXJtaXNzaW9uTWlkZGxld2FyZSA9IHBlcm1pc3Npb25fbWlkZGxld2FyZV8xLmdldFBlcm1pc3Npb25NaWRkbGV3YXJlRmFjdG9yeSh7XG4gICAgICAgICAgICBleGVjdXRlUmVzdHJpY3RlZE1ldGhvZDogdGhpcy5fZXhlY3V0ZVJlc3RyaWN0ZWRNZXRob2QuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldFJlc3RyaWN0ZWRNZXRob2Q6IHRoaXMuZ2V0UmVzdHJpY3RlZE1ldGhvZC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgaXNVbnJlc3RyaWN0ZWRNZXRob2Q6IHRoaXMudW5yZXN0cmljdGVkTWV0aG9kcy5oYXMuYmluZCh0aGlzLnVucmVzdHJpY3RlZE1ldGhvZHMpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWVzIG9mIGFsbCBKU09OLVJQQyBtZXRob2RzIHRoYXQgd2lsbCBiZSBpZ25vcmVkIGJ5IHRoZSBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIGdldCB1bnJlc3RyaWN0ZWRNZXRob2RzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5yZXN0cmljdGVkTWV0aG9kcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHBlcm1pc3Npb24gc3BlY2lmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXRLZXkgLSBUaGUgdGFyZ2V0IGtleSBvZiB0aGUgcGVybWlzc2lvbiBzcGVjaWZpY2F0aW9uIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcGVybWlzc2lvbiBzcGVjaWZpY2F0aW9uIHdpdGggdGhlIHNwZWNpZmllZCB0YXJnZXQga2V5LlxuICAgICAqL1xuICAgIGdldFBlcm1pc3Npb25TcGVjaWZpY2F0aW9uKHRhcmdldEtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVybWlzc2lvblNwZWNpZmljYXRpb25zW3RhcmdldEtleV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBjYXZlYXQgc3BlY2lmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYXZlYXRUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIGNhdmVhdCBzcGVjaWZpY2F0aW9uIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY2F2ZWF0IHNwZWNpZmljYXRpb24gd2l0aCB0aGUgc3BlY2lmaWVkIHR5cGUuXG4gICAgICovXG4gICAgZ2V0Q2F2ZWF0U3BlY2lmaWNhdGlvbihjYXZlYXRUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYXZlYXRTcGVjaWZpY2F0aW9uc1tjYXZlYXRUeXBlXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgaGVscGVyIGZvciB2YWxpZGF0aW5nIHBlcm1pc3Npb24gc3BlY2lmaWNhdGlvbnMuIFRoaXMgaXNcbiAgICAgKiBpbnRlbmRlZCB0byBwcmV2ZW50IHRoZSB1c2Ugb2YgaW52YWxpZCB0YXJnZXQga2V5cyB3aGljaCwgd2hpbGUgaW1wb3NzaWJsZVxuICAgICAqIHRvIGFkZCBpbiBUeXBlU2NyaXB0LCBjb3VsZCByYXRoZXIgZWFzaWx5IG9jY3VyIGluIHBsYWluIEphdmFTY3JpcHQuXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdmFsaWRhdGlvbiBmYWlscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMgLSBUaGUgcGVybWlzc2lvbiBzcGVjaWZpY2F0aW9ucyBwYXNzZWQgdG9cbiAgICAgKiB0aGlzIGNvbnRyb2xsZXIncyBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0gY2F2ZWF0U3BlY2lmaWNhdGlvbnMgLSBUaGUgY2F2ZWF0IHNwZWNpZmljYXRpb25zIHBhc3NlZCB0byB0aGlzXG4gICAgICogY29udHJvbGxlci5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZVBlcm1pc3Npb25TcGVjaWZpY2F0aW9ucyhwZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMsIGNhdmVhdFNwZWNpZmljYXRpb25zKSB7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHBlcm1pc3Npb25TcGVjaWZpY2F0aW9ucykuZm9yRWFjaCgoW3RhcmdldEtleSwgeyB0YXJnZXRLZXk6IGlubmVyVGFyZ2V0S2V5LCBhbGxvd2VkQ2F2ZWF0cyB9XSkgPT4ge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHRhcmdldCBrZXkgaXMgdGhlIGVtcHR5IHN0cmluZywgZW5kcyB3aXRoIFwiX1wiLCBvciBlbmRzXG4gICAgICAgICAgICAvLyB3aXRoIFwiKlwiIGJ1dCBub3QgXCJfKlwiXG4gICAgICAgICAgICBpZiAoIXRhcmdldEtleSB8fCAvXyQvdS50ZXN0KHRhcmdldEtleSkgfHwgL1teX11cXCokL3UudGVzdCh0YXJnZXRLZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBlcm1pc3Npb24gdGFyZ2V0IGtleTogXCIke3RhcmdldEtleX1cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldEtleSAhPT0gaW5uZXJUYXJnZXRLZXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGVybWlzc2lvbiBzcGVjaWZpY2F0aW9uOiBrZXkgXCIke3RhcmdldEtleX1cIiBtdXN0IG1hdGNoIHNwZWNpZmljYXRpb24udGFyZ2V0IHZhbHVlIFwiJHtpbm5lclRhcmdldEtleX1cIi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGxvd2VkQ2F2ZWF0cykge1xuICAgICAgICAgICAgICAgIGFsbG93ZWRDYXZlYXRzLmZvckVhY2goKGNhdmVhdFR5cGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1dGlsc18xLmhhc1Byb3BlcnR5KGNhdmVhdFNwZWNpZmljYXRpb25zLCBjYXZlYXRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVucmVjb2duaXplZENhdmVhdFR5cGVFcnJvcihjYXZlYXRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgaGVscGVyIGZvciByZWdpc3RlcmluZyB0aGUgY29udHJvbGxlcidzIG1lc3NhZ2luZyBzeXN0ZW1cbiAgICAgKiBhY3Rpb25zLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyTWVzc2FnZUhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7Y29udHJvbGxlck5hbWV9OmNsZWFyUGVybWlzc2lvbnNgLCAoKSA9PiB0aGlzLmNsZWFyU3RhdGUoKSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06Z2V0U3ViamVjdE5hbWVzYCwgKCkgPT4gdGhpcy5nZXRTdWJqZWN0TmFtZXMoKSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06aGFzUGVybWlzc2lvbnNgLCAob3JpZ2luKSA9PiB0aGlzLmhhc1Blcm1pc3Npb25zKG9yaWdpbikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIHN0YXRlIG9mIHRoZSBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIGNsZWFyU3RhdGUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKChfZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGdldERlZmF1bHRTdGF0ZSgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBzcGVjaWZpZWQgcmVzdHJpY3RlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBBIEpTT04tUlBDIGVycm9yIGlzIHRocm93biBpZiB0aGUgbWV0aG9kIGRvZXMgbm90IGV4aXN0LlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIuZXhlY3V0ZVJlc3RyaWN0ZWRNZXRob2R9IGFuZFxuICAgICAqIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5jcmVhdGVQZXJtaXNzaW9uTWlkZGxld2FyZX0gZm9yIGludGVybmFsIHVzYWdlLlxuICAgICAqIEBwYXJhbSBtZXRob2QgLSBUaGUgbmFtZSBvZiB0aGUgcmVzdHJpY3RlZCBtZXRob2QuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gYXNzb2NpYXRlZCB3aXRoIHRoZSByZXF1ZXN0IGZvciB0aGUgcmVzdHJpY3RlZFxuICAgICAqIG1ldGhvZCwgaWYgYW55LlxuICAgICAqIEByZXR1cm5zIFRoZSByZXN0cmljdGVkIG1ldGhvZCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKi9cbiAgICBnZXRSZXN0cmljdGVkTWV0aG9kKG1ldGhvZCwgb3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEtleSA9IHRoaXMuZ2V0VGFyZ2V0S2V5KG1ldGhvZCk7XG4gICAgICAgIGlmICghdGFyZ2V0S2V5KSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGVycm9yc18xLm1ldGhvZE5vdEZvdW5kKHsgbWV0aG9kIH0pO1xuICAgICAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgICAgIGVycm9yLmRhdGEgPSB7IG9yaWdpbiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGVybWlzc2lvblNwZWNpZmljYXRpb24odGFyZ2V0S2V5KS5tZXRob2RJbXBsZW1lbnRhdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIG9yaWdpbnMgKGkuZS4gSURzKSBvZiBhbGwgc3ViamVjdHMuXG4gICAgICovXG4gICAgZ2V0U3ViamVjdE5hbWVzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zdGF0ZS5zdWJqZWN0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBlcm1pc3Npb24gZm9yIHRoZSBzcGVjaWZpZWQgdGFyZ2V0IG9mIHRoZSBzdWJqZWN0IGNvcnJlc3BvbmRpbmdcbiAgICAgKiB0byB0aGUgc3BlY2lmaWVkIG9yaWdpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBzdWJqZWN0LlxuICAgICAqIEBwYXJhbSB0YXJnZXROYW1lIC0gVGhlIG1ldGhvZCBuYW1lIGFzIGludm9rZWQgYnkgYSB0aGlyZCBwYXJ0eSAoaS5lLiwgbm90XG4gICAgICogYSBtZXRob2Qga2V5KS5cbiAgICAgKiBAcmV0dXJucyBUaGUgcGVybWlzc2lvbiBpZiBpdCBleGlzdHMsIG9yIHVuZGVmaW5lZCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZ2V0UGVybWlzc2lvbihvcmlnaW4sIHRhcmdldE5hbWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5zdGF0ZS5zdWJqZWN0c1tvcmlnaW5dKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGVybWlzc2lvbnNbdGFyZ2V0TmFtZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIHBlcm1pc3Npb25zIGZvciB0aGUgc3BlY2lmaWVkIHN1YmplY3QsIGlmIGFueS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBzdWJqZWN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBwZXJtaXNzaW9ucyBvZiB0aGUgc3ViamVjdCwgaWYgYW55LlxuICAgICAqL1xuICAgIGdldFBlcm1pc3Npb25zKG9yaWdpbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnN0YXRlLnN1YmplY3RzW29yaWdpbl0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wZXJtaXNzaW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHN1YmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIG9yaWdpbiBoYXMgdGhlIHNwZWNpZmllZFxuICAgICAqIHBlcm1pc3Npb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc3ViamVjdC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBuYW1lIG9mIHRoZSBwZXJtaXNzaW9uLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHN1YmplY3QgaGFzIHRoZSBwZXJtaXNzaW9uLlxuICAgICAqL1xuICAgIGhhc1Blcm1pc3Npb24ob3JpZ2luLCB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5nZXRQZXJtaXNzaW9uKG9yaWdpbiwgdGFyZ2V0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBzdWJqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBvcmlnaW4gaGFzIGFueSBwZXJtaXNzaW9ucy5cbiAgICAgKiBVc2UgdGhpcyBpZiB5b3Ugd2FudCB0byBrbm93IGlmIGEgc3ViamVjdCBcImV4aXN0c1wiLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHN1YmplY3QgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgc3ViamVjdCBoYXMgYW55IHBlcm1pc3Npb25zLlxuICAgICAqL1xuICAgIGhhc1Blcm1pc3Npb25zKG9yaWdpbikge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnN0YXRlLnN1YmplY3RzW29yaWdpbl0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXZva2VzIGFsbCBwZXJtaXNzaW9ucyBmcm9tIHRoZSBzcGVjaWZpZWQgb3JpZ2luLlxuICAgICAqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIG9mIHRoZSBvcmlnaW4gaGFzIG5vIHBlcm1pc3Npb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gd2hvc2UgcGVybWlzc2lvbnMgdG8gcmV2b2tlLlxuICAgICAqL1xuICAgIHJldm9rZUFsbFBlcm1pc3Npb25zKG9yaWdpbikge1xuICAgICAgICB0aGlzLnVwZGF0ZSgoZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkcmFmdFN0YXRlLnN1YmplY3RzW29yaWdpbl0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5yZWNvZ25pemVkU3ViamVjdEVycm9yKG9yaWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgZHJhZnRTdGF0ZS5zdWJqZWN0c1tvcmlnaW5dO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV2b2tlcyB0aGUgc3BlY2lmaWVkIHBlcm1pc3Npb24gZnJvbSB0aGUgc3ViamVjdCB3aXRoIHRoZSBzcGVjaWZpZWRcbiAgICAgKiBvcmlnaW4uXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHN1YmplY3Qgb3IgdGhlIHBlcm1pc3Npb24gZG9lcyBub3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc3ViamVjdCB3aG9zZSBwZXJtaXNzaW9uIHRvIHJldm9rZS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBuYW1lIG9mIHRoZSBwZXJtaXNzaW9uIHRvIHJldm9rZS5cbiAgICAgKi9cbiAgICByZXZva2VQZXJtaXNzaW9uKG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgICAgIHRoaXMucmV2b2tlUGVybWlzc2lvbnMoeyBbb3JpZ2luXTogW3RhcmdldF0gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldm9rZXMgdGhlIHNwZWNpZmllZCBwZXJtaXNzaW9ucyBmcm9tIHRoZSBzcGVjaWZpZWQgc3ViamVjdHMuXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgYW55IG9mIHRoZSBzdWJqZWN0cyBvciBwZXJtaXNzaW9ucyBkbyBub3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3ViamVjdHNBbmRQZXJtaXNzaW9ucyAtIEFuIG9iamVjdCBtYXBwaW5nIHN1YmplY3Qgb3JpZ2luc1xuICAgICAqIHRvIGFycmF5cyBvZiBwZXJtaXNzaW9uIHRhcmdldCBuYW1lcyB0byByZXZva2UuXG4gICAgICovXG4gICAgcmV2b2tlUGVybWlzc2lvbnMoc3ViamVjdHNBbmRQZXJtaXNzaW9ucykge1xuICAgICAgICB0aGlzLnVwZGF0ZSgoZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3ViamVjdHNBbmRQZXJtaXNzaW9ucykuZm9yRWFjaCgob3JpZ2luKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsc18xLmhhc1Byb3BlcnR5KGRyYWZ0U3RhdGUuc3ViamVjdHMsIG9yaWdpbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVucmVjb2duaXplZFN1YmplY3RFcnJvcihvcmlnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWJqZWN0c0FuZFBlcm1pc3Npb25zW29yaWdpbl0uZm9yRWFjaCgodGFyZ2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcGVybWlzc2lvbnMgfSA9IGRyYWZ0U3RhdGUuc3ViamVjdHNbb3JpZ2luXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1dGlsc18xLmhhc1Byb3BlcnR5KHBlcm1pc3Npb25zLCB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUGVybWlzc2lvbkRvZXNOb3RFeGlzdEVycm9yKG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZVBlcm1pc3Npb24oZHJhZnRTdGF0ZS5zdWJqZWN0cywgb3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXZva2VzIGFsbCBwZXJtaXNzaW9ucyBjb3JyZXNwb25kaW5nIHRvIHRoZSBzcGVjaWZpZWQgdGFyZ2V0IGZvciBhbGwgc3ViamVjdHMuXG4gICAgICogRG9lcyBub3RoaW5nIGlmIG5vIHN1YmplY3RzIG9yIG5vIHN1Y2ggcGVybWlzc2lvbiBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIG5hbWUgb2YgdGhlIHRhcmdldCB0byByZXZva2UgYWxsIHBlcm1pc3Npb25zIGZvci5cbiAgICAgKi9cbiAgICByZXZva2VQZXJtaXNzaW9uRm9yQWxsU3ViamVjdHModGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmdldFN1YmplY3ROYW1lcygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKChkcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhkcmFmdFN0YXRlLnN1YmplY3RzKS5mb3JFYWNoKChbb3JpZ2luLCBzdWJqZWN0XSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGVybWlzc2lvbnMgfSA9IHN1YmplY3Q7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzXzEuaGFzUHJvcGVydHkocGVybWlzc2lvbnMsIHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxldGVQZXJtaXNzaW9uKGRyYWZ0U3RhdGUuc3ViamVjdHMsIG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdGhlIHBlcm1pc3Npb24gaWRlbnRpZmllZCBieSB0aGUgZ2l2ZW4gb3JpZ2luIGFuZCB0YXJnZXQuIElmIHRoZVxuICAgICAqIHBlcm1pc3Npb24gaXMgdGhlIHNpbmdsZSByZW1haW5pbmcgcGVybWlzc2lvbiBvZiBpdHMgc3ViamVjdCwgdGhlIHN1YmplY3RcbiAgICAgKiBpcyBhbHNvIGRlbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3ViamVjdHMgLSBUaGUgZHJhZnQgcGVybWlzc2lvbiBjb250cm9sbGVyIHN1YmplY3RzLlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBzdWJqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgcGVybWlzc2lvblxuICAgICAqIHRvIGRlbGV0ZS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBuYW1lIG9mIHRoZSBwZXJtaXNzaW9uIHRvIGRlbGV0ZS5cbiAgICAgKi9cbiAgICBkZWxldGVQZXJtaXNzaW9uKHN1YmplY3RzLCBvcmlnaW4sIHRhcmdldCkge1xuICAgICAgICBjb25zdCB7IHBlcm1pc3Npb25zIH0gPSBzdWJqZWN0c1tvcmlnaW5dO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMocGVybWlzc2lvbnMpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBwZXJtaXNzaW9uc1t0YXJnZXRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHN1YmplY3RzW29yaWdpbl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHBlcm1pc3Npb24gb2YgdGhlIHN1YmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW5cbiAgICAgKiBvcmlnaW4gaGFzIGEgY2F2ZWF0IG9mIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgc3ViamVjdCBkb2VzIG5vdCBoYXZlIGEgcGVybWlzc2lvbiB3aXRoIHRoZVxuICAgICAqIHNwZWNpZmllZCB0YXJnZXQgbmFtZS5cbiAgICAgKlxuICAgICAqIEB0ZW1wbGF0ZSBUYXJnZXROYW1lIC0gVGhlIHBlcm1pc3Npb24gdGFyZ2V0IG5hbWUuIFNob3VsZCBiZSBpbmZlcnJlZC5cbiAgICAgKiBAdGVtcGxhdGUgQ2F2ZWF0VHlwZSAtIFRoZSB2YWxpZCBjYXZlYXQgdHlwZXMgZm9yIHRoZSBwZXJtaXNzaW9uLiBTaG91bGRcbiAgICAgKiBiZSBpbmZlcnJlZC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc3ViamVjdC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBuYW1lIG9mIHRoZSBwZXJtaXNzaW9uLlxuICAgICAqIEBwYXJhbSBjYXZlYXRUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIGNhdmVhdCB0byBjaGVjayBmb3IuXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgcGVybWlzc2lvbiBoYXMgdGhlIHNwZWNpZmllZCBjYXZlYXQuXG4gICAgICovXG4gICAgaGFzQ2F2ZWF0KG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuZ2V0Q2F2ZWF0KG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNhdmVhdCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUsIGlmIGFueSwgZm9yIHRoZSBwZXJtaXNzaW9uIG9mXG4gICAgICogdGhlIHN1YmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gb3JpZ2luLlxuICAgICAqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBzdWJqZWN0IGRvZXMgbm90IGhhdmUgYSBwZXJtaXNzaW9uIHdpdGggdGhlXG4gICAgICogc3BlY2lmaWVkIHRhcmdldCBuYW1lLlxuICAgICAqXG4gICAgICogQHRlbXBsYXRlIFRhcmdldE5hbWUgLSBUaGUgcGVybWlzc2lvbiB0YXJnZXQgbmFtZS4gU2hvdWxkIGJlIGluZmVycmVkLlxuICAgICAqIEB0ZW1wbGF0ZSBDYXZlYXRUeXBlIC0gVGhlIHZhbGlkIGNhdmVhdCB0eXBlcyBmb3IgdGhlIHBlcm1pc3Npb24uIFNob3VsZFxuICAgICAqIGJlIGluZmVycmVkLlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBzdWJqZWN0LlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG5hbWUgb2YgdGhlIHBlcm1pc3Npb24uXG4gICAgICogQHBhcmFtIGNhdmVhdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgY2F2ZWF0IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY2F2ZWF0LCBvciBgdW5kZWZpbmVkYCBpZiBubyBzdWNoIGNhdmVhdCBleGlzdHMuXG4gICAgICovXG4gICAgZ2V0Q2F2ZWF0KG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlKSB7XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb24gPSB0aGlzLmdldFBlcm1pc3Npb24ob3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICBpZiAoIXBlcm1pc3Npb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5QZXJtaXNzaW9uRG9lc05vdEV4aXN0RXJyb3Iob3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQZXJtaXNzaW9uXzEuZmluZENhdmVhdChwZXJtaXNzaW9uLCBjYXZlYXRUeXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNhdmVhdCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUsIHdpdGggdGhlIHNwZWNpZmllZCBjYXZlYXQgdmFsdWUsIHRvXG4gICAgICogdGhlIHBlcm1pc3Npb24gY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gc3ViamVjdCBvcmlnaW4gYW5kIHBlcm1pc3Npb25cbiAgICAgKiB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBGb3IgbW9kaWZ5aW5nIGV4aXN0aW5nIGNhdmVhdHMsIHVzZVxuICAgICAqIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci51cGRhdGVDYXZlYXR9LlxuICAgICAqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIG5vIHN1Y2ggcGVybWlzc2lvbiBleGlzdHMsIG9yIGlmIHRoZSBjYXZlYXQgYWxyZWFkeVxuICAgICAqIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEB0ZW1wbGF0ZSBUYXJnZXROYW1lIC0gVGhlIHBlcm1pc3Npb24gdGFyZ2V0IG5hbWUuIFNob3VsZCBiZSBpbmZlcnJlZC5cbiAgICAgKiBAdGVtcGxhdGUgQ2F2ZWF0VHlwZSAtIFRoZSB2YWxpZCBjYXZlYXQgdHlwZXMgZm9yIHRoZSBwZXJtaXNzaW9uLiBTaG91bGRcbiAgICAgKiBiZSBpbmZlcnJlZC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc3ViamVjdC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBuYW1lIG9mIHRoZSBwZXJtaXNzaW9uLlxuICAgICAqIEBwYXJhbSBjYXZlYXRUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIGNhdmVhdCB0byBhZGQuXG4gICAgICogQHBhcmFtIGNhdmVhdFZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBjYXZlYXQgdG8gYWRkLlxuICAgICAqL1xuICAgIGFkZENhdmVhdChvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSwgY2F2ZWF0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ2F2ZWF0KG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkNhdmVhdEFscmVhZHlFeGlzdHNFcnJvcihvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRDYXZlYXQob3JpZ2luLCB0YXJnZXQsIGNhdmVhdFR5cGUsIGNhdmVhdFZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdmFsdWUgb2YgdGhlIGNhdmVhdCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgYmVsb25naW5nIHRvIHRoZVxuICAgICAqIHBlcm1pc3Npb24gY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gc3ViamVjdCBvcmlnaW4gYW5kIHBlcm1pc3Npb25cbiAgICAgKiB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBGb3IgYWRkaW5nIG5ldyBjYXZlYXRzLCB1c2VcbiAgICAgKiB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIuYWRkQ2F2ZWF0fS5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiBubyBzdWNoIHBlcm1pc3Npb24gb3IgY2F2ZWF0IGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEB0ZW1wbGF0ZSBUYXJnZXROYW1lIC0gVGhlIHBlcm1pc3Npb24gdGFyZ2V0IG5hbWUuIFNob3VsZCBiZSBpbmZlcnJlZC5cbiAgICAgKiBAdGVtcGxhdGUgQ2F2ZWF0VHlwZSAtIFRoZSB2YWxpZCBjYXZlYXQgdHlwZXMgZm9yIHRoZSBwZXJtaXNzaW9uLiBTaG91bGRcbiAgICAgKiBiZSBpbmZlcnJlZC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc3ViamVjdC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBuYW1lIG9mIHRoZSBwZXJtaXNzaW9uLlxuICAgICAqIEBwYXJhbSBjYXZlYXRUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIGNhdmVhdCB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIGNhdmVhdFZhbHVlIC0gVGhlIG5ldyB2YWx1ZSBvZiB0aGUgY2F2ZWF0LlxuICAgICAqL1xuICAgIHVwZGF0ZUNhdmVhdChvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSwgY2F2ZWF0VmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0NhdmVhdChvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5DYXZlYXREb2VzTm90RXhpc3RFcnJvcihvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRDYXZlYXQob3JpZ2luLCB0YXJnZXQsIGNhdmVhdFR5cGUsIGNhdmVhdFZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3BlY2lmaWVkIGNhdmVhdCBvbiB0aGUgc3BlY2lmaWVkIHBlcm1pc3Npb24uIE92ZXJ3cml0ZXMgZXhpc3RpbmdcbiAgICAgKiBjYXZlYXRzIG9mIHRoZSBzYW1lIHR5cGUgaW4tcGxhY2UgKHByZXNlcnZpbmcgYXJyYXkgb3JkZXIpLCBhbmQgYWRkcyB0aGVcbiAgICAgKiBjYXZlYXQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBwZXJtaXNzaW9uIGRvZXMgbm90IGV4aXN0IG9yIGZhaWxzIHRvIHZhbGlkYXRlIGFmdGVyXG4gICAgICogaXRzIGNhdmVhdHMgaGF2ZSBiZWVuIG1vZGlmaWVkLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIuYWRkQ2F2ZWF0fVxuICAgICAqIEBzZWUge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLnVwZGF0ZUNhdmVhdH1cbiAgICAgKiBAdGVtcGxhdGUgVGFyZ2V0TmFtZSAtIFRoZSBwZXJtaXNzaW9uIHRhcmdldCBuYW1lLiBTaG91bGQgYmUgaW5mZXJyZWQuXG4gICAgICogQHRlbXBsYXRlIENhdmVhdFR5cGUgLSBUaGUgdmFsaWQgY2F2ZWF0IHR5cGVzIGZvciB0aGUgcGVybWlzc2lvbi4gU2hvdWxkXG4gICAgICogYmUgaW5mZXJyZWQuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHN1YmplY3QuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgbmFtZSBvZiB0aGUgcGVybWlzc2lvbi5cbiAgICAgKiBAcGFyYW0gY2F2ZWF0VHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBjYXZlYXQgdG8gc2V0LlxuICAgICAqIEBwYXJhbSBjYXZlYXRWYWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgY2F2ZWF0IHRvIHNldC5cbiAgICAgKi9cbiAgICBzZXRDYXZlYXQob3JpZ2luLCB0YXJnZXQsIGNhdmVhdFR5cGUsIGNhdmVhdFZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKChkcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdWJqZWN0ID0gZHJhZnRTdGF0ZS5zdWJqZWN0c1tvcmlnaW5dO1xuICAgICAgICAgICAgLy8gVW5yZWFjaGFibGUgYmVjYXVzZSBgaGFzQ2F2ZWF0YCBpcyBhbHdheXMgY2FsbGVkIGJlZm9yZSB0aGlzLCBhbmQgaXRcbiAgICAgICAgICAgIC8vIHRocm93cyBpZiBwZXJtaXNzaW9ucyBhcmUgbWlzc2luZy4gVHlwZVNjcmlwdCBuZWVkcyB0aGlzLCBob3dldmVyLlxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIXN1YmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5yZWNvZ25pemVkU3ViamVjdEVycm9yKG9yaWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwZXJtaXNzaW9uID0gc3ViamVjdC5wZXJtaXNzaW9uc1t0YXJnZXRdO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiBwcmFjdGljYWxseSBpbXBvc3NpYmxlLCBidXQgVHlwZVNjcmlwdCB3YW50cyBpdCAqL1xuICAgICAgICAgICAgaWYgKCFwZXJtaXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlBlcm1pc3Npb25Eb2VzTm90RXhpc3RFcnJvcihvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYXZlYXQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogY2F2ZWF0VHlwZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2F2ZWF0VmFsdWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUNhdmVhdChjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChwZXJtaXNzaW9uLmNhdmVhdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXZlYXRJbmRleCA9IHBlcm1pc3Npb24uY2F2ZWF0cy5maW5kSW5kZXgoKGV4aXN0aW5nQ2F2ZWF0KSA9PiBleGlzdGluZ0NhdmVhdC50eXBlID09PSBjYXZlYXQudHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhdmVhdEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwZXJtaXNzaW9uLmNhdmVhdHMucHVzaChjYXZlYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGVybWlzc2lvbi5jYXZlYXRzLnNwbGljZShjYXZlYXRJbmRleCwgMSwgY2F2ZWF0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUeXBlY2FzdDogQXQgdGhpcyBwb2ludCwgd2UgZG9uJ3Qga25vdyBpZiB0aGUgc3BlY2lmaWMgcGVybWlzc2lvblxuICAgICAgICAgICAgICAgIC8vIGlzIGFsbG93ZWQgdG8gaGF2ZSBjYXZlYXRzLCBidXQgaXQgc2hvdWxkIGJlIGltcG9zc2libGUgdG8gY2FsbFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgbWV0aG9kIGZvciBhIHBlcm1pc3Npb24gdGhhdCBtYXkgbm90IGhhdmUgYW55IGNhdmVhdHMuXG4gICAgICAgICAgICAgICAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHRoZSBwZXJtaXNzaW9uIHZhbGlkYXRvciBpcyBhbHNvIGNhbGxlZC5cbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uLmNhdmVhdHMgPSBbY2F2ZWF0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVNb2RpZmllZFBlcm1pc3Npb24ocGVybWlzc2lvbiwgb3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhbGwgY2F2ZWF0cyB3aXRoIHRoZSBzcGVjaWZpZWQgdHlwZSBmb3IgYWxsIHN1YmplY3RzIGFuZFxuICAgICAqIHBlcm1pc3Npb25zIGJ5IGFwcGx5aW5nIHRoZSBzcGVjaWZpZWQgbXV0YXRvciBmdW5jdGlvbiB0byB0aGVtLlxuICAgICAqXG4gICAgICogKipBVFROOioqIFBlcm1pc3Npb25zIGNhbiBiZSByZXZva2VkIGVudGlyZWx5IGJ5IHRoZSBhY3Rpb24gb2YgdGhpcyBtZXRob2QsXG4gICAgICogcmVhZCBvbiBmb3IgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIENhdmVhdCBtdXRhdG9ycyBhcmUgZnVuY3Rpb25zIHRoYXQgcmVjZWl2ZSBhIGNhdmVhdCB2YWx1ZSBhbmQgcmV0dXJuIGFcbiAgICAgKiB0dXBsZSBjb25zaXN0aW5nIG9mIGEge0BsaW5rIENhdmVhdE11dGF0b3JPcGVyYXRpb259IGFuZCwgb3B0aW9uYWxseSwgYSBuZXdcbiAgICAgKiB2YWx1ZSB0byB1cGRhdGUgdGhlIGV4aXN0aW5nIGNhdmVhdCB3aXRoLlxuICAgICAqXG4gICAgICogRm9yIGVhY2ggY2F2ZWF0LCBkZXBlbmRpbmcgb24gdGhlIG11dGF0b3IgcmVzdWx0LCB0aGlzIG1ldGhvZCB3aWxsOlxuICAgICAqIC0gRG8gbm90aGluZyAoe0BsaW5rIENhdmVhdE11dGF0b3JPcGVyYXRpb24ubm9vcH0pXG4gICAgICogLSBVcGRhdGUgdGhlIHZhbHVlIG9mIHRoZSBjYXZlYXQgKHtAbGluayBDYXZlYXRNdXRhdG9yT3BlcmF0aW9uLnVwZGF0ZVZhbHVlfSlcbiAgICAgKiAgIC0gVGhlIGNhdmVhdCBzcGVjaWZpY2F0aW9uIHZhbGlkYXRvciwgaWYgYW55LCB3aWxsIGJlIGNhbGxlZCBhZnRlclxuICAgICAqICAgICB1cGRhdGluZyB0aGUgdmFsdWUuXG4gICAgICogLSBEZWxldGUgdGhlIGNhdmVhdCAoe0BsaW5rIENhdmVhdE11dGF0b3JPcGVyYXRpb24uZGVsZXRlQ2F2ZWF0fSlcbiAgICAgKiAgIC0gVGhlIHBlcm1pc3Npb24gc3BlY2lmaWNhdGlvbiB2YWxpZGF0b3IsIGlmIGFueSwgd2lsbCBiZSBjYWxsZWQgYWZ0ZXJcbiAgICAgKiAgICAgZGVsZXRpbmcgdGhlIGNhdmVhdC5cbiAgICAgKiAtIFJldm9rZSB0aGUgcGFyZW50IHBlcm1pc3Npb24gKHtAbGluayBDYXZlYXRNdXRhdG9yT3BlcmF0aW9uLnJldm9rZVBlcm1pc3Npb259KVxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgdGhyb3dzIGlmIHRoZSB2YWxpZGF0aW9uIG9mIGFueSBjYXZlYXQgb3IgcGVybWlzc2lvbiBmYWlscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXRDYXZlYXRUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIGNhdmVhdHMgdG8gdXBkYXRlLlxuICAgICAqIEBwYXJhbSBtdXRhdG9yIC0gVGhlIG11dGF0b3IgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCBjYXZlYXRcbiAgICAgKiB2YWx1ZXMuXG4gICAgICovXG4gICAgdXBkYXRlUGVybWlzc2lvbnNCeUNhdmVhdCh0YXJnZXRDYXZlYXRUeXBlLCBtdXRhdG9yKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLnN0YXRlLnN1YmplY3RzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSgoZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyhkcmFmdFN0YXRlLnN1YmplY3RzKS5mb3JFYWNoKChzdWJqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyhzdWJqZWN0LnBlcm1pc3Npb25zKS5mb3JFYWNoKChwZXJtaXNzaW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY2F2ZWF0cyB9ID0gcGVybWlzc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q2F2ZWF0ID0gY2F2ZWF0cyA9PT0gbnVsbCB8fCBjYXZlYXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXZlYXRzLmZpbmQoKHsgdHlwZSB9KSA9PiB0eXBlID09PSB0YXJnZXRDYXZlYXRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRDYXZlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbXV0YXRvciBtYXkgbW9kaWZ5IHRoZSBjYXZlYXQgdmFsdWUgaW4gcGxhY2UsIGFuZCBtdXN0IGFsd2F5c1xuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gYSB2YWxpZCBtdXRhdGlvbiByZXN1bHQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG11dGF0b3JSZXN1bHQgPSBtdXRhdG9yKHRhcmdldENhdmVhdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobXV0YXRvclJlc3VsdC5vcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbi5ub29wOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDYXZlYXRNdXRhdG9yT3BlcmF0aW9uLnVwZGF0ZVZhbHVlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFR5cGVjYXN0OiBgTXV0YWJsZWAgaXMgdXNlZCBoZXJlIHRvIGFzc2lnbiB0byBhIHJlYWRvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvcGVydHkuIGB0YXJnZXRDb25zdHJhaW50YCBzaG91bGQgYWxyZWFkeSBiZSBtdXRhYmxlIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIHBhcnQgb2YgYSBkcmFmdCwgYnV0IGZvciBzb21lIHJlYXNvbiBpdCdzIG5vdC4gV2UgY2FuJ3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIG1vcmUtY29ycmVjdCBgRHJhZnRgIHR5cGUgaGVyZSBlaXRoZXIgYmVjYXVzZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdHMgaW4gYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2F2ZWF0LnZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRvclJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlQ2F2ZWF0KHRhcmdldENhdmVhdCwgc3ViamVjdC5vcmlnaW4sIHBlcm1pc3Npb24ucGFyZW50Q2FwYWJpbGl0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENhdmVhdE11dGF0b3JPcGVyYXRpb24uZGVsZXRlQ2F2ZWF0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlQ2F2ZWF0KHBlcm1pc3Npb24sIHRhcmdldENhdmVhdFR5cGUsIHN1YmplY3Qub3JpZ2luLCBwZXJtaXNzaW9uLnBhcmVudENhcGFiaWxpdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDYXZlYXRNdXRhdG9yT3BlcmF0aW9uLnJldm9rZVBlcm1pc3Npb246XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxldGVQZXJtaXNzaW9uKGRyYWZ0U3RhdGUuc3ViamVjdHMsIHN1YmplY3Qub3JpZ2luLCBwZXJtaXNzaW9uLnBhcmVudENhcGFiaWxpdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgdHlwZSBjaGVjayBlbnN1cmVzIHRoYXQgdGhlIHN3aXRjaCBzdGF0ZW1lbnQgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBleGhhdXN0aXZlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBtdXRhdG9yUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIG11dGF0aW9uIHJlc3VsdDogXCIke19leGhhdXN0aXZlQ2hlY2sub3BlcmF0aW9ufVwiYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgY2F2ZWF0IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBmcm9tIHRoZSBwZXJtaXNzaW9uIGNvcnJlc3BvbmRpbmdcbiAgICAgKiB0byB0aGUgZ2l2ZW4gc3ViamVjdCBvcmlnaW4gYW5kIHRhcmdldCBuYW1lLlxuICAgICAqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIG5vIHN1Y2ggcGVybWlzc2lvbiBvciBjYXZlYXQgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHRlbXBsYXRlIFRhcmdldE5hbWUgLSBUaGUgcGVybWlzc2lvbiB0YXJnZXQgbmFtZS4gU2hvdWxkIGJlIGluZmVycmVkLlxuICAgICAqIEB0ZW1wbGF0ZSBDYXZlYXRUeXBlIC0gVGhlIHZhbGlkIGNhdmVhdCB0eXBlcyBmb3IgdGhlIHBlcm1pc3Npb24uIFNob3VsZFxuICAgICAqIGJlIGluZmVycmVkLlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBzdWJqZWN0LlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG5hbWUgb2YgdGhlIHBlcm1pc3Npb24uXG4gICAgICogQHBhcmFtIGNhdmVhdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgY2F2ZWF0IHRvIHJlbW92ZS5cbiAgICAgKi9cbiAgICByZW1vdmVDYXZlYXQob3JpZ2luLCB0YXJnZXQsIGNhdmVhdFR5cGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKGRyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHBlcm1pc3Npb24gPSAoX2EgPSBkcmFmdFN0YXRlLnN1YmplY3RzW29yaWdpbl0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wZXJtaXNzaW9uc1t0YXJnZXRdO1xuICAgICAgICAgICAgaWYgKCFwZXJtaXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlBlcm1pc3Npb25Eb2VzTm90RXhpc3RFcnJvcihvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBlcm1pc3Npb24uY2F2ZWF0cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5DYXZlYXREb2VzTm90RXhpc3RFcnJvcihvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZUNhdmVhdChwZXJtaXNzaW9uLCBjYXZlYXRUeXBlLCBvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBzcGVjaWZpZWQgY2F2ZWF0IGZyb20gdGhlIHNwZWNpZmllZCBwZXJtaXNzaW9uLiBJZiBubyBjYXZlYXRzXG4gICAgICogcmVtYWluIGFmdGVyIGRlbGV0aW9uLCB0aGUgcGVybWlzc2lvbidzIGNhdmVhdCBwcm9wZXJ0eSBpcyBzZXQgdG8gYG51bGxgLlxuICAgICAqIFRoZSBwZXJtaXNzaW9uIGlzIHZhbGlkYXRlZCBhZnRlciBiZWluZyBtb2RpZmllZC5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcGVybWlzc2lvbiBkb2VzIG5vdCBoYXZlIGEgY2F2ZWF0IHdpdGggdGhlIHNwZWNpZmllZFxuICAgICAqIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGVybWlzc2lvbiAtIFRoZSBwZXJtaXNzaW9uIHdob3NlIGNhdmVhdCB0byBkZWxldGUuXG4gICAgICogQHBhcmFtIGNhdmVhdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgY2F2ZWF0IHRvIGRlbGV0ZS5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiB0aGUgcGVybWlzc2lvbiBzdWJqZWN0LlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgbmFtZSBvZiB0aGUgcGVybWlzc2lvbiB0YXJnZXQuXG4gICAgICovXG4gICAgZGVsZXRlQ2F2ZWF0KHBlcm1pc3Npb24sIGNhdmVhdFR5cGUsIG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogbm90IHBvc3NpYmxlIGluIG91ciB1c2FnZSAqL1xuICAgICAgICBpZiAoIXBlcm1pc3Npb24uY2F2ZWF0cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkNhdmVhdERvZXNOb3RFeGlzdEVycm9yKG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYXZlYXRJbmRleCA9IHBlcm1pc3Npb24uY2F2ZWF0cy5maW5kSW5kZXgoKGV4aXN0aW5nQ2F2ZWF0KSA9PiBleGlzdGluZ0NhdmVhdC50eXBlID09PSBjYXZlYXRUeXBlKTtcbiAgICAgICAgaWYgKGNhdmVhdEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkNhdmVhdERvZXNOb3RFeGlzdEVycm9yKG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGVybWlzc2lvbi5jYXZlYXRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcGVybWlzc2lvbi5jYXZlYXRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBlcm1pc3Npb24uY2F2ZWF0cy5zcGxpY2UoY2F2ZWF0SW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsaWRhdGVNb2RpZmllZFBlcm1pc3Npb24ocGVybWlzc2lvbiwgb3JpZ2luLCB0YXJnZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIHNwZWNpZmllZCBtb2RpZmllZCBwZXJtaXNzaW9uLiBTaG91bGQgKiphbHdheXMqKiBiZSBpbnZva2VkXG4gICAgICogb24gYSBwZXJtaXNzaW9uIGFmdGVyIGl0cyBjYXZlYXRzIGhhdmUgYmVlbiBtb2RpZmllZC5cbiAgICAgKlxuICAgICAqIEp1c3QgbGlrZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIudmFsaWRhdGVQZXJtaXNzaW9ufSwgZXhjZXB0IHRoYXQgdGhlXG4gICAgICogY29ycmVzcG9uZGluZyB0YXJnZXQga2V5IGFuZCBzcGVjaWZpY2F0aW9uIGFyZSByZXRyaWV2ZWQgZmlyc3QsIGFuZCBhblxuICAgICAqIGVycm9yIGlzIHRocm93biBpZiB0aGUgdGFyZ2V0IGtleSBkb2VzIG5vdCBleGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwZXJtaXNzaW9uIC0gVGhlIG1vZGlmaWVkIHBlcm1pc3Npb24gdG8gdmFsaWRhdGUuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gYXNzb2NpYXRlZCB3aXRoIHRoZSBwZXJtaXNzaW9uLlxuICAgICAqIEBwYXJhbSB0YXJnZXROYW1lIC0gVGhlIHRhcmdldCBuYW1lIG5hbWUgb2YgdGhlIHBlcm1pc3Npb24uXG4gICAgICovXG4gICAgdmFsaWRhdGVNb2RpZmllZFBlcm1pc3Npb24ocGVybWlzc2lvbiwgb3JpZ2luLCB0YXJnZXROYW1lKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEtleSA9IHRoaXMuZ2V0VGFyZ2V0S2V5KHBlcm1pc3Npb24ucGFyZW50Q2FwYWJpbGl0eSk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogdGhpcyBzaG91bGQgYmUgaW1wb3NzaWJsZSAqL1xuICAgICAgICBpZiAoIXRhcmdldEtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYXRhbDogRXhpc3RpbmcgcGVybWlzc2lvbiB0YXJnZXQga2V5IFwiJHt0YXJnZXRLZXl9XCIgaGFzIG5vIHNwZWNpZmljYXRpb24uYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWxpZGF0ZVBlcm1pc3Npb24odGhpcy5nZXRQZXJtaXNzaW9uU3BlY2lmaWNhdGlvbih0YXJnZXRLZXkpLCBwZXJtaXNzaW9uLCBvcmlnaW4sIHRhcmdldE5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBrZXkgZm9yIHRoZSBzcGVjaWZpZWQgcGVybWlzc2lvbiB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBVc2VkIHRvIHN1cHBvcnQgb3VyIG5hbWVzcGFjZWQgcGVybWlzc2lvbiB0YXJnZXQgZmVhdHVyZSwgd2hpY2ggaXMgdXNlZFxuICAgICAqIHRvIGltcGxlbWVudCBuYW1lc3BhY2VkIHJlc3RyaWN0ZWQgSlNPTi1SUEMgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgcmVxdWVzdGVkIHBlcm1pc3Npb24gdGFyZ2V0LlxuICAgICAqIEByZXR1cm5zIFRoZSBpbnRlcm5hbCBrZXkgb2YgdGhlIHBlcm1pc3Npb24gdGFyZ2V0LlxuICAgICAqL1xuICAgIGdldFRhcmdldEtleSh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHV0aWxzXzEuaGFzUHJvcGVydHkodGhpcy5fcGVybWlzc2lvblNwZWNpZmljYXRpb25zLCB0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWVzcGFjZWRUYXJnZXRzV2l0aG91dFdpbGRjYXJkID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0S2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuX3Blcm1pc3Npb25TcGVjaWZpY2F0aW9ucykpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpbGRDYXJkTWF0Y2ggPSB0YXJnZXRLZXkubWF0Y2goLyguKylcXCokL3UpO1xuICAgICAgICAgICAgaWYgKHdpbGRDYXJkTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VkVGFyZ2V0c1dpdGhvdXRXaWxkY2FyZFt3aWxkQ2FyZE1hdGNoWzFdXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHBvdGVudGlhbGx5IG5lc3RlZCBuYW1lc3BhY2VzOlxuICAgICAgICAvLyBFeDogd2lsZHpvbmVfXG4gICAgICAgIC8vIEV4OiBldGhfcGx1Z2luX1xuICAgICAgICBjb25zdCBzZWdtZW50cyA9IHRhcmdldC5zcGxpdCgnXycpO1xuICAgICAgICBsZXQgdGFyZ2V0S2V5ID0gJyc7XG4gICAgICAgIHdoaWxlIChzZWdtZW50cy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAhdXRpbHNfMS5oYXNQcm9wZXJ0eSh0aGlzLl9wZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMsIHRhcmdldEtleSkgJiZcbiAgICAgICAgICAgICFuYW1lc3BhY2VkVGFyZ2V0c1dpdGhvdXRXaWxkY2FyZFt0YXJnZXRLZXldKSB7XG4gICAgICAgICAgICB0YXJnZXRLZXkgKz0gYCR7c2VnbWVudHMuc2hpZnQoKX1fYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZXNwYWNlZFRhcmdldHNXaXRob3V0V2lsZGNhcmRbdGFyZ2V0S2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3RhcmdldEtleX0qYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHcmFudHMgX2FwcHJvdmVkXyBwZXJtaXNzaW9ucyB0byB0aGUgc3BlY2lmaWVkIHN1YmplY3QuIEV2ZXJ5IHBlcm1pc3Npb24gYW5kXG4gICAgICogY2F2ZWF0IGlzIHN0cmluZ2VudGx5IHZhbGlkYXRlZCDigJMgaW5jbHVkaW5nIGJ5IGNhbGxpbmcgZXZlcnkgc3BlY2lmaWNhdGlvblxuICAgICAqIHZhbGlkYXRvciDigJMgYW5kIGFuIGVycm9yIGlzIHRocm93biBpZiBhbnkgdmFsaWRhdGlvbiBmYWlscy5cbiAgICAgKlxuICAgICAqICoqQVRUTjoqKiBUaGlzIG1ldGhvZCBkb2VzICoqbm90KiogcHJvbXB0IHRoZSB1c2VyIGZvciBhcHByb3ZhbC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLnJlcXVlc3RQZXJtaXNzaW9uc30gRm9yIGluaXRpYXRpbmcgYVxuICAgICAqIHBlcm1pc3Npb25zIHJlcXVlc3QgcmVxdWlyaW5nIHVzZXIgYXBwcm92YWwuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJhZy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hcHByb3ZlZFBlcm1pc3Npb25zIC0gVGhlIHJlcXVlc3RlZCBwZXJtaXNzaW9ucyBhcHByb3ZlZCBieVxuICAgICAqIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlcXVlc3REYXRhIC0gUGVybWlzc2lvbiByZXF1ZXN0IGRhdGEuIFBhc3NlZCB0byBwZXJtaXNzaW9uXG4gICAgICogZmFjdG9yeSBmdW5jdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucHJlc2VydmVFeGlzdGluZ1Blcm1pc3Npb25zIC0gV2hldGhlciB0byBwcmVzZXJ2ZSB0aGVcbiAgICAgKiBzdWJqZWN0J3MgZXhpc3RpbmcgcGVybWlzc2lvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3ViamVjdCAtIFRoZSBzdWJqZWN0IHRvIGdyYW50IHBlcm1pc3Npb25zIHRvLlxuICAgICAqIEByZXR1cm5zIFRoZSBncmFudGVkIHBlcm1pc3Npb25zLlxuICAgICAqL1xuICAgIGdyYW50UGVybWlzc2lvbnMoeyBhcHByb3ZlZFBlcm1pc3Npb25zLCByZXF1ZXN0RGF0YSwgcHJlc2VydmVFeGlzdGluZ1Blcm1pc3Npb25zID0gdHJ1ZSwgc3ViamVjdCwgfSkge1xuICAgICAgICBjb25zdCB7IG9yaWdpbiB9ID0gc3ViamVjdDtcbiAgICAgICAgaWYgKCFvcmlnaW4gfHwgdHlwZW9mIG9yaWdpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3ViamVjdElkZW50aWZpZXJFcnJvcihvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb25zID0gKHByZXNlcnZlRXhpc3RpbmdQZXJtaXNzaW9uc1xuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdldFBlcm1pc3Npb25zKG9yaWdpbikpIDoge30pO1xuICAgICAgICBmb3IgKGNvbnN0IFtyZXF1ZXN0ZWRUYXJnZXQsIGFwcHJvdmVkUGVybWlzc2lvbl0gb2YgT2JqZWN0LmVudHJpZXMoYXBwcm92ZWRQZXJtaXNzaW9ucykpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEtleSA9IHRoaXMuZ2V0VGFyZ2V0S2V5KHJlcXVlc3RlZFRhcmdldCk7XG4gICAgICAgICAgICBpZiAoIXRhcmdldEtleSkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yc18xLm1ldGhvZE5vdEZvdW5kKHsgbWV0aG9kOiByZXF1ZXN0ZWRUYXJnZXQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXBwcm92ZWRQZXJtaXNzaW9uLnBhcmVudENhcGFiaWxpdHkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHJlcXVlc3RlZFRhcmdldCAhPT0gYXBwcm92ZWRQZXJtaXNzaW9uLnBhcmVudENhcGFiaWxpdHkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZEFwcHJvdmVkUGVybWlzc2lvbkVycm9yKG9yaWdpbiwgcmVxdWVzdGVkVGFyZ2V0LCBhcHByb3ZlZFBlcm1pc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3RlZCB0YXJnZXQgbXVzdCBiZSBhIHZhbGlkIHRhcmdldCBuYW1lIGlmIHdlIGZvdW5kIGl0cyBrZXkuXG4gICAgICAgICAgICAvLyBXZSByZWFzc2lnbiBpdCB0byBjaGFuZ2UgaXRzIHR5cGUuXG4gICAgICAgICAgICBjb25zdCB0YXJnZXROYW1lID0gcmVxdWVzdGVkVGFyZ2V0O1xuICAgICAgICAgICAgY29uc3Qgc3BlY2lmaWNhdGlvbiA9IHRoaXMuZ2V0UGVybWlzc2lvblNwZWNpZmljYXRpb24odGFyZ2V0S2V5KTtcbiAgICAgICAgICAgIC8vIFRoZSByZXF1ZXN0ZWQgY2F2ZWF0cyBhcmUgdmFsaWRhdGVkIGhlcmUuXG4gICAgICAgICAgICBjb25zdCBjYXZlYXRzID0gdGhpcy5jb25zdHJ1Y3RDYXZlYXRzKG9yaWdpbiwgdGFyZ2V0TmFtZSwgYXBwcm92ZWRQZXJtaXNzaW9uLmNhdmVhdHMpO1xuICAgICAgICAgICAgY29uc3QgcGVybWlzc2lvbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgY2F2ZWF0cyxcbiAgICAgICAgICAgICAgICBpbnZva2VyOiBvcmlnaW4sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXROYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBwZXJtaXNzaW9uO1xuICAgICAgICAgICAgaWYgKHNwZWNpZmljYXRpb24uZmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIHBlcm1pc3Npb24gPSBzcGVjaWZpY2F0aW9uLmZhY3RvcnkocGVybWlzc2lvbk9wdGlvbnMsIHJlcXVlc3REYXRhKTtcbiAgICAgICAgICAgICAgICAvLyBGdWxsIGNhdmVhdCBhbmQgcGVybWlzc2lvbiB2YWxpZGF0aW9uIGlzIHBlcmZvcm1lZCBoZXJlIHNpbmNlIHRoZVxuICAgICAgICAgICAgICAgIC8vIGZhY3RvcnkgZnVuY3Rpb24gY2FuIGFyYml0cmFyaWx5IG1vZGlmeSB0aGUgZW50aXJlIHBlcm1pc3Npb24gb2JqZWN0LFxuICAgICAgICAgICAgICAgIC8vIGluY2x1ZGluZyBpdHMgY2F2ZWF0cy5cbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGVybWlzc2lvbihzcGVjaWZpY2F0aW9uLCBwZXJtaXNzaW9uLCBvcmlnaW4sIHRhcmdldE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbiA9IFBlcm1pc3Npb25fMS5jb25zdHJ1Y3RQZXJtaXNzaW9uKHBlcm1pc3Npb25PcHRpb25zKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBkbyBub3QgbmVlZCB0byB2YWxpZGF0ZSBjYXZlYXRzIGluIHRoaXMgY2FzZSwgYmVjYXVzZSB0aGUgcGxhaW5cbiAgICAgICAgICAgICAgICAvLyBwZXJtaXNzaW9uIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGRvZXMgbm90IG1vZGlmeSB0aGUgY2F2ZWF0cywgd2hpY2hcbiAgICAgICAgICAgICAgICAvLyB3ZXJlIGFscmVhZHkgdmFsaWRhdGVkIGJ5IGBjb25zdHJ1Y3RDYXZlYXRzYCBhYm92ZS5cbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGVybWlzc2lvbihzcGVjaWZpY2F0aW9uLCBwZXJtaXNzaW9uLCBvcmlnaW4sIHRhcmdldE5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlUGVybWlzc2lvblZhbGlkYXRvcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGVyZm9ybUNhdmVhdFZhbGlkYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVybWlzc2lvbnNbdGFyZ2V0TmFtZV0gPSBwZXJtaXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0VmFsaWRhdGVkUGVybWlzc2lvbnMob3JpZ2luLCBwZXJtaXNzaW9ucyk7XG4gICAgICAgIHJldHVybiBwZXJtaXNzaW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSBzcGVjaWZpZWQgcGVybWlzc2lvbiBieTpcbiAgICAgKiAtIEVuc3VyaW5nIHRoYXQgaXRzIGBjYXZlYXRzYCBwcm9wZXJ0eSBpcyBlaXRoZXIgYG51bGxgIG9yIGEgbm9uLWVtcHR5XG4gICAgICogICBhcnJheS5cbiAgICAgKiAtIEVuc3VyaW5nIHRoYXQgaXQgb25seSBpbmNsdWRlcyBjYXZlYXRzIGFsbG93ZWQgYnkgaXRzIHNwZWNpZmljYXRpb24uXG4gICAgICogLSBFbnN1cmluZyB0aGF0IGl0IGluY2x1ZGVzIG5vIGR1cGxpY2F0ZSBjYXZlYXRzIChieSBjYXZlYXQgdHlwZSkuXG4gICAgICogLSBWYWxpZGF0aW5nIGVhY2ggY2F2ZWF0IG9iamVjdCwgaWYgYHBlcmZvcm1DYXZlYXRWYWxpZGF0aW9uYCBpcyBgdHJ1ZWAuXG4gICAgICogLSBDYWxsaW5nIHRoZSB2YWxpZGF0b3Igb2YgaXRzIHNwZWNpZmljYXRpb24sIGlmIG9uZSBleGlzdHMgYW5kXG4gICAgICogICBgaW52b2tlUGVybWlzc2lvblZhbGlkYXRvcmAgaXMgYHRydWVgLlxuICAgICAqXG4gICAgICogQW4gZXJyb3IgaXMgdGhyb3duIGlmIHZhbGlkYXRpb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3BlY2lmaWNhdGlvbiAtIFRoZSBzcGVjaWZpY2F0aW9uIG9mIHRoZSBwZXJtaXNzaW9uLlxuICAgICAqIEBwYXJhbSBwZXJtaXNzaW9uIC0gVGhlIHBlcm1pc3Npb24gdG8gdmFsaWRhdGUuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gYXNzb2NpYXRlZCB3aXRoIHRoZSBwZXJtaXNzaW9uLlxuICAgICAqIEBwYXJhbSB0YXJnZXROYW1lIC0gVGhlIHRhcmdldCBuYW1lIG9mIHRoZSBwZXJtaXNzaW9uLlxuICAgICAqIEBwYXJhbSB2YWxpZGF0aW9uT3B0aW9ucyAtIFZhbGlkYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gdmFsaWRhdGlvbk9wdGlvbnMuaW52b2tlUGVybWlzc2lvblZhbGlkYXRvciAtIFdoZXRoZXIgdG8gaW52b2tlIHRoZVxuICAgICAqIHBlcm1pc3Npb24ncyBjb25zdW1lci1zcGVjaWZpZWQgdmFsaWRhdG9yIGZ1bmN0aW9uLCBpZiBhbnkuXG4gICAgICogQHBhcmFtIHZhbGlkYXRpb25PcHRpb25zLnBlcmZvcm1DYXZlYXRWYWxpZGF0aW9uIC0gV2hldGhlciB0byBpbnZva2VcbiAgICAgKiB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIudmFsaWRhdGVDYXZlYXR9IG9uIGVhY2ggb2YgdGhlIHBlcm1pc3Npb24nc1xuICAgICAqIGNhdmVhdHMuXG4gICAgICovXG4gICAgdmFsaWRhdGVQZXJtaXNzaW9uKHNwZWNpZmljYXRpb24sIHBlcm1pc3Npb24sIG9yaWdpbiwgdGFyZ2V0TmFtZSwgeyBpbnZva2VQZXJtaXNzaW9uVmFsaWRhdG9yLCBwZXJmb3JtQ2F2ZWF0VmFsaWRhdGlvbiB9ID0ge1xuICAgICAgICBpbnZva2VQZXJtaXNzaW9uVmFsaWRhdG9yOiB0cnVlLFxuICAgICAgICBwZXJmb3JtQ2F2ZWF0VmFsaWRhdGlvbjogdHJ1ZSxcbiAgICB9KSB7XG4gICAgICAgIGNvbnN0IHsgYWxsb3dlZENhdmVhdHMsIHZhbGlkYXRvciB9ID0gc3BlY2lmaWNhdGlvbjtcbiAgICAgICAgaWYgKHV0aWxzXzEuaGFzUHJvcGVydHkocGVybWlzc2lvbiwgJ2NhdmVhdHMnKSkge1xuICAgICAgICAgICAgY29uc3QgeyBjYXZlYXRzIH0gPSBwZXJtaXNzaW9uO1xuICAgICAgICAgICAgaWYgKGNhdmVhdHMgIT09IG51bGwgJiYgIShBcnJheS5pc0FycmF5KGNhdmVhdHMpICYmIGNhdmVhdHMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZENhdmVhdHNQcm9wZXJ0eUVycm9yKG9yaWdpbiwgdGFyZ2V0TmFtZSwgY2F2ZWF0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZWVuQ2F2ZWF0VHlwZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBjYXZlYXRzID09PSBudWxsIHx8IGNhdmVhdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhdmVhdHMuZm9yRWFjaCgoY2F2ZWF0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBlcmZvcm1DYXZlYXRWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVDYXZlYXQoY2F2ZWF0LCBvcmlnaW4sIHRhcmdldE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIShhbGxvd2VkQ2F2ZWF0cyA9PT0gbnVsbCB8fCBhbGxvd2VkQ2F2ZWF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWxsb3dlZENhdmVhdHMuaW5jbHVkZXMoY2F2ZWF0LnR5cGUpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuRm9yYmlkZGVuQ2F2ZWF0RXJyb3IoY2F2ZWF0LnR5cGUsIG9yaWdpbiwgdGFyZ2V0TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWVuQ2F2ZWF0VHlwZXMuaGFzKGNhdmVhdC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuRHVwbGljYXRlQ2F2ZWF0RXJyb3IoY2F2ZWF0LnR5cGUsIG9yaWdpbiwgdGFyZ2V0TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlZW5DYXZlYXRUeXBlcy5hZGQoY2F2ZWF0LnR5cGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludm9rZVBlcm1pc3Npb25WYWxpZGF0b3IgJiYgdmFsaWRhdG9yKSB7XG4gICAgICAgICAgICB2YWxpZGF0b3IocGVybWlzc2lvbiwgb3JpZ2luLCB0YXJnZXROYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIHRoZSBzcGVjaWZpZWQgcGVybWlzc2lvbnMgdG8gdGhlIHN1YmplY3Qgd2l0aCB0aGUgZ2l2ZW4gb3JpZ2luLlxuICAgICAqIE92ZXJ3cml0ZXMgYWxsIGV4aXN0aW5nIHBlcm1pc3Npb25zLCBhbmQgY3JlYXRlcyBhIHN1YmplY3QgZW50cnkgaWYgaXRcbiAgICAgKiBkb2Vzbid0IGFscmVhZHkgZXhpc3QuXG4gICAgICpcbiAgICAgKiAqKkFUVE46KiogQXNzdW1lcyB0aGF0IHRoZSBuZXcgcGVybWlzc2lvbnMgaGF2ZSBiZWVuIHZhbGlkYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBncmFudGVlIHN1YmplY3QuXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb25zIC0gVGhlIG5ldyBwZXJtaXNzaW9ucyBmb3IgdGhlIGdyYW50ZWUgc3ViamVjdC5cbiAgICAgKi9cbiAgICBzZXRWYWxpZGF0ZWRQZXJtaXNzaW9ucyhvcmlnaW4sIHBlcm1pc3Npb25zKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKChkcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRyYWZ0U3RhdGUuc3ViamVjdHNbb3JpZ2luXSkge1xuICAgICAgICAgICAgICAgIGRyYWZ0U3RhdGUuc3ViamVjdHNbb3JpZ2luXSA9IHsgb3JpZ2luLCBwZXJtaXNzaW9uczoge30gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRyYWZ0U3RhdGUuc3ViamVjdHNbb3JpZ2luXS5wZXJtaXNzaW9ucyA9IGltbWVyXzEuY2FzdERyYWZ0KHBlcm1pc3Npb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgcmVxdWVzdGVkIGNhdmVhdHMgZm9yIHRoZSBwZXJtaXNzaW9uIG9mIHRoZSBzcGVjaWZpZWRcbiAgICAgKiBzdWJqZWN0IG9yaWdpbiBhbmQgdGFyZ2V0IG5hbWUgYW5kIHJldHVybnMgdGhlIHZhbGlkYXRlZCBjYXZlYXQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdmFsaWRhdGlvbiBmYWlscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBwZXJtaXNzaW9uIHN1YmplY3QuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSBwZXJtaXNzaW9uIHRhcmdldCBuYW1lLlxuICAgICAqIEBwYXJhbSByZXF1ZXN0ZWRDYXZlYXRzIC0gVGhlIHJlcXVlc3RlZCBjYXZlYXRzIHRvIGNvbnN0cnVjdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY29uc3RydWN0ZWQgY2F2ZWF0cy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RDYXZlYXRzKG9yaWdpbiwgdGFyZ2V0LCByZXF1ZXN0ZWRDYXZlYXRzKSB7XG4gICAgICAgIGNvbnN0IGNhdmVhdEFycmF5ID0gcmVxdWVzdGVkQ2F2ZWF0cyA9PT0gbnVsbCB8fCByZXF1ZXN0ZWRDYXZlYXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXF1ZXN0ZWRDYXZlYXRzLm1hcCgocmVxdWVzdGVkQ2F2ZWF0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQ2F2ZWF0KHJlcXVlc3RlZENhdmVhdCwgb3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICAgICAgLy8gUmVhc3NpZ24gc28gdGhhdCB3ZSBoYXZlIGEgZnJlc2ggb2JqZWN0LlxuICAgICAgICAgICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gcmVxdWVzdGVkQ2F2ZWF0O1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZSwgdmFsdWUgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjYXZlYXRBcnJheSAmJiB1dGlsc18xLmlzTm9uRW1wdHlBcnJheShjYXZlYXRBcnJheSlcbiAgICAgICAgICAgID8gY2F2ZWF0QXJyYXlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZHMgdmFsaWRhdGVzIHRoYXQgdGhlIHNwZWNpZmllZCBjYXZlYXQgaXMgYW4gb2JqZWN0IHdpdGggdGhlXG4gICAgICogZXhwZWN0ZWQgcHJvcGVydGllcyBhbmQgdHlwZXMuIEl0IGFsc28gZW5zdXJlcyB0aGF0IGEgY2F2ZWF0IHNwZWNpZmljYXRpb25cbiAgICAgKiBleGlzdHMgZm9yIHRoZSByZXF1ZXN0ZWQgY2F2ZWF0IHR5cGUsIGFuZCBjYWxscyB0aGUgc3BlY2lmaWNhdGlvblxuICAgICAqIHZhbGlkYXRvciwgaWYgaXQgZXhpc3RzLCBvbiB0aGUgY2F2ZWF0IG9iamVjdC5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhdmVhdCAtIFRoZSBjYXZlYXQgb2JqZWN0IHRvIHZhbGlkYXRlLlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3ViamVjdCBvZiB0aGUgcGFyZW50XG4gICAgICogcGVybWlzc2lvbi5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBuYW1lIGFzc29jaWF0ZWQgd2l0aCB0aGUgcGFyZW50IHBlcm1pc3Npb24uXG4gICAgICovXG4gICAgdmFsaWRhdGVDYXZlYXQoY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdXRpbHNfMS5pc1BsYWluT2JqZWN0KGNhdmVhdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQ2F2ZWF0RXJyb3IoY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGNhdmVhdCkubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZENhdmVhdEZpZWxkc0Vycm9yKGNhdmVhdCwgb3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2F2ZWF0LnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZENhdmVhdFR5cGVFcnJvcihjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGVjaWZpY2F0aW9uID0gdGhpcy5nZXRDYXZlYXRTcGVjaWZpY2F0aW9uKGNhdmVhdC50eXBlKTtcbiAgICAgICAgaWYgKCFzcGVjaWZpY2F0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5yZWNvZ25pemVkQ2F2ZWF0VHlwZUVycm9yKGNhdmVhdC50eXBlLCBvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1dGlsc18xLmhhc1Byb3BlcnR5KGNhdmVhdCwgJ3ZhbHVlJykgfHwgY2F2ZWF0LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5DYXZlYXRNaXNzaW5nVmFsdWVFcnJvcihjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXV0aWxzXzEuaXNWYWxpZEpzb24oY2F2ZWF0LnZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkNhdmVhdEludmFsaWRKc29uRXJyb3IoY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHlwZWNhc3Q6IFR5cGVTY3JpcHQgc3RpbGwgYmVsaWV2ZXMgdGhhdCB0aGUgY2F2ZWF0IGlzIGEgUGxhaW5PYmplY3QuXG4gICAgICAgIChfYSA9IHNwZWNpZmljYXRpb24udmFsaWRhdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzcGVjaWZpY2F0aW9uLCBjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhdGVzIGEgcGVybWlzc2lvbiByZXF1ZXN0IHRoYXQgcmVxdWlyZXMgdXNlciBhcHByb3ZhbC4gVGhpcyBzaG91bGRcbiAgICAgKiBhbHdheXMgYmUgdXNlZCB0byBncmFudCBhZGRpdGlvbmFsIHBlcm1pc3Npb25zIHRvIGEgc3ViamVjdCwgdW5sZXNzIHVzZXJcbiAgICAgKiBhcHByb3ZhbCBoYXMgYmVlbiBvYnRhaW5lZCB0aHJvdWdoIHNvbWUgb3RoZXIgbWVhbnMuXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9ucyBhcmUgdmFsaWRhdGVkIGF0IGV2ZXJ5IHN0ZXAgb2YgdGhlIGFwcHJvdmFsIHByb2Nlc3MsIGFuZCB0aGlzXG4gICAgICogbWV0aG9kIHdpbGwgcmVqZWN0IGlmIHZhbGlkYXRpb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBBcHByb3ZhbENvbnRyb2xsZXJ9IEZvciB0aGUgdXNlciBhcHByb3ZhbCBsb2dpYy5cbiAgICAgKiBAc2VlIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5hY2NlcHRQZXJtaXNzaW9uc1JlcXVlc3R9IEZvciB0aGUgbWV0aG9kXG4gICAgICogdGhhdCBfYWNjZXB0c18gdGhlIHJlcXVlc3QgYW5kIHJlc29sdmVzIHRoZSB1c2VyIGFwcHJvdmFsIHByb21pc2UuXG4gICAgICogQHNlZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIucmVqZWN0UGVybWlzc2lvbnNSZXF1ZXN0fSBGb3IgdGhlIG1ldGhvZFxuICAgICAqIHRoYXQgX3JlamVjdHNfIHRoZSByZXF1ZXN0IGFuZCB0aGUgdXNlciBhcHByb3ZhbCBwcm9taXNlLlxuICAgICAqIEBwYXJhbSBzdWJqZWN0IC0gVGhlIGdyYW50ZWUgc3ViamVjdC5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdGVkUGVybWlzc2lvbnMgLSBUaGUgcmVxdWVzdGVkIHBlcm1pc3Npb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmlkIC0gVGhlIGlkIG9mIHRoZSBwZXJtaXNzaW9ucyByZXF1ZXN0LiBEZWZhdWx0cyB0byBhIHVuaXF1ZVxuICAgICAqIGlkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnByZXNlcnZlRXhpc3RpbmdQZXJtaXNzaW9ucyAtIFdoZXRoZXIgdG8gcHJlc2VydmUgdGhlXG4gICAgICogc3ViamVjdCdzIGV4aXN0aW5nIHBlcm1pc3Npb25zLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAgICogQHJldHVybnMgVGhlIGdyYW50ZWQgcGVybWlzc2lvbnMgYW5kIHJlcXVlc3QgbWV0YWRhdGEuXG4gICAgICovXG4gICAgYXN5bmMgcmVxdWVzdFBlcm1pc3Npb25zKHN1YmplY3QsIHJlcXVlc3RlZFBlcm1pc3Npb25zLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBvcmlnaW4gfSA9IHN1YmplY3Q7XG4gICAgICAgIGNvbnN0IHsgaWQgPSBuYW5vaWRfMS5uYW5vaWQoKSwgcHJlc2VydmVFeGlzdGluZ1Blcm1pc3Npb25zID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy52YWxpZGF0ZVJlcXVlc3RlZFBlcm1pc3Npb25zKG9yaWdpbiwgcmVxdWVzdGVkUGVybWlzc2lvbnMpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9uc1JlcXVlc3QgPSB7XG4gICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIHBlcm1pc3Npb25zOiByZXF1ZXN0ZWRQZXJtaXNzaW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgX2EgPSBhd2FpdCB0aGlzLnJlcXVlc3RVc2VyQXBwcm92YWwocGVybWlzc2lvbnNSZXF1ZXN0KSwgeyBwZXJtaXNzaW9uczogYXBwcm92ZWRQZXJtaXNzaW9ucyB9ID0gX2EsIHJlcXVlc3REYXRhID0gX19yZXN0KF9hLCBbXCJwZXJtaXNzaW9uc1wiXSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLmdyYW50UGVybWlzc2lvbnMoe1xuICAgICAgICAgICAgICAgIHN1YmplY3QsXG4gICAgICAgICAgICAgICAgYXBwcm92ZWRQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZUV4aXN0aW5nUGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgcmVxdWVzdERhdGEsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgcmVxdWVzdGVkIHBlcm1pc3Npb25zLiBUaHJvd3MgaWYgdmFsaWRhdGlvbiBmYWlscy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGVuc3VyZXMgdGhhdCB0aGUgcmVxdWVzdGVkIHBlcm1pc3Npb25zIGFyZSBhIHByb3Blcmx5XG4gICAgICogZm9ybWF0dGVkIHtAbGluayBSZXF1ZXN0ZWRQZXJtaXNzaW9uc30gb2JqZWN0LCBhbmQgcGVyZm9ybXMgdGhlIHNhbWVcbiAgICAgKiB2YWxpZGF0aW9uIGFzIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5ncmFudFBlcm1pc3Npb25zfSwgZXhjZXB0IHRoYXRcbiAgICAgKiBjb25zdW1lci1zcGVjaWZpZWQgcGVybWlzc2lvbiB2YWxpZGF0b3IgZnVuY3Rpb25zIGFyZSBub3QgY2FsbGVkLCBzaW5jZVxuICAgICAqIHRoZXkgYXJlIG9ubHkgY2FsbGVkIG9uIGZ1bGx5IGNvbnN0cnVjdGVkLCBhcHByb3ZlZCBwZXJtaXNzaW9ucyB0aGF0IGFyZVxuICAgICAqIG90aGVyd2lzZSBjb21wbGV0ZWx5IHZhbGlkLlxuICAgICAqXG4gICAgICogVW5yZWNvZ256aWVkIHByb3BlcnRpZXMgb24gcmVxdWVzdGVkIHBlcm1pc3Npb25zIGFyZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIGdyYW50ZWUgc3ViamVjdC5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdGVkUGVybWlzc2lvbnMgLSBUaGUgcmVxdWVzdGVkIHBlcm1pc3Npb25zLlxuICAgICAqL1xuICAgIHZhbGlkYXRlUmVxdWVzdGVkUGVybWlzc2lvbnMob3JpZ2luLCByZXF1ZXN0ZWRQZXJtaXNzaW9ucykge1xuICAgICAgICBpZiAoIXV0aWxzXzEuaXNQbGFpbk9iamVjdChyZXF1ZXN0ZWRQZXJtaXNzaW9ucykpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yc18xLmludmFsaWRQYXJhbXMoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBSZXF1ZXN0ZWQgcGVybWlzc2lvbnMgZm9yIG9yaWdpbiBcIiR7b3JpZ2lufVwiIGlzIG5vdCBhIHBsYWluIG9iamVjdC5gLFxuICAgICAgICAgICAgICAgIGRhdGE6IHsgb3JpZ2luLCByZXF1ZXN0ZWRQZXJtaXNzaW9ucyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHJlcXVlc3RlZFBlcm1pc3Npb25zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yc18xLmludmFsaWRQYXJhbXMoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBQZXJtaXNzaW9ucyByZXF1ZXN0IGZvciBvcmlnaW4gXCIke29yaWdpbn1cIiBjb250YWlucyBubyBwZXJtaXNzaW9ucy5gLFxuICAgICAgICAgICAgICAgIGRhdGE6IHsgcmVxdWVzdGVkUGVybWlzc2lvbnMgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0TmFtZSBvZiBPYmplY3Qua2V5cyhyZXF1ZXN0ZWRQZXJtaXNzaW9ucykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBlcm1pc3Npb24gPSByZXF1ZXN0ZWRQZXJtaXNzaW9uc1t0YXJnZXROYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEtleSA9IHRoaXMuZ2V0VGFyZ2V0S2V5KHRhcmdldE5hbWUpO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXRLZXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcnNfMS5tZXRob2ROb3RGb3VuZCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyBvcmlnaW4sIHJlcXVlc3RlZFBlcm1pc3Npb25zIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXV0aWxzXzEuaXNQbGFpbk9iamVjdChwZXJtaXNzaW9uKSB8fFxuICAgICAgICAgICAgICAgIChwZXJtaXNzaW9uLnBhcmVudENhcGFiaWxpdHkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXROYW1lICE9PSBwZXJtaXNzaW9uLnBhcmVudENhcGFiaWxpdHkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JzXzEuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBQZXJtaXNzaW9ucyByZXF1ZXN0IGZvciBvcmlnaW4gXCIke29yaWdpbn1cIiBjb250YWlucyBpbnZhbGlkIHJlcXVlc3RlZCBwZXJtaXNzaW9uKHMpLmAsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgb3JpZ2luLCByZXF1ZXN0ZWRQZXJtaXNzaW9ucyB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGVyZSB3ZSB2YWxpZGF0ZSB0aGUgcGVybWlzc2lvbiB3aXRob3V0IGludm9raW5nIGl0cyB2YWxpZGF0b3IsIGlmIGFueS5cbiAgICAgICAgICAgIC8vIFRoZSB2YWxpZGF0b3Igd2lsbCBiZSBpbnZva2VkIGFmdGVyIHRoZSBwZXJtaXNzaW9uIGhhcyBiZWVuIGFwcHJvdmVkLlxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVBlcm1pc3Npb24odGhpcy5nZXRQZXJtaXNzaW9uU3BlY2lmaWNhdGlvbih0YXJnZXRLZXkpLCBcbiAgICAgICAgICAgIC8vIFR5cGVjYXN0OiBUaGUgcGVybWlzc2lvbiBpcyBzdGlsbCBhIFwiUGxhaW5PYmplY3RcIiBoZXJlLlxuICAgICAgICAgICAgcGVybWlzc2lvbiwgb3JpZ2luLCB0YXJnZXROYW1lLCB7IGludm9rZVBlcm1pc3Npb25WYWxpZGF0b3I6IGZhbHNlLCBwZXJmb3JtQ2F2ZWF0VmFsaWRhdGlvbjogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcmVxdWVzdCB0byB0aGUge0BsaW5rIEFwcHJvdmFsQ29udHJvbGxlcn0gdXNpbmcgdGhlXG4gICAgICoge0BsaW5rIEFkZEFwcHJvdmFsUmVxdWVzdH0gYWN0aW9uLiBBbHNvIHZhbGlkYXRlcyB0aGUgcmVzdWx0aW5nIGFwcHJvdmVkXG4gICAgICogcGVybWlzc2lvbnMgcmVxdWVzdCwgYW5kIHRocm93cyBhbiBlcnJvciBpZiB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb25zUmVxdWVzdCAtIFRoZSBwZXJtaXNzaW9ucyByZXF1ZXN0IG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgYXBwcm92ZWQgcGVybWlzc2lvbnMgcmVxdWVzdCBvYmplY3QuXG4gICAgICovXG4gICAgYXN5bmMgcmVxdWVzdFVzZXJBcHByb3ZhbChwZXJtaXNzaW9uc1JlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgeyBvcmlnaW4sIGlkIH0gPSBwZXJtaXNzaW9uc1JlcXVlc3QubWV0YWRhdGE7XG4gICAgICAgIGNvbnN0IGFwcHJvdmVkUmVxdWVzdCA9IGF3YWl0IHRoaXMubWVzc2FnaW5nU3lzdGVtLmNhbGwoJ0FwcHJvdmFsQ29udHJvbGxlcjphZGRSZXF1ZXN0Jywge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICByZXF1ZXN0RGF0YTogcGVybWlzc2lvbnNSZXF1ZXN0LFxuICAgICAgICAgICAgdHlwZTogdXRpbHNfMi5NZXRob2ROYW1lcy5yZXF1ZXN0UGVybWlzc2lvbnMsXG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlQXBwcm92ZWRQZXJtaXNzaW9ucyhhcHByb3ZlZFJlcXVlc3QsIHsgaWQsIG9yaWdpbiB9KTtcbiAgICAgICAgcmV0dXJuIGFwcHJvdmVkUmVxdWVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIGFuIGFwcHJvdmVkIHtAbGluayBQZXJtaXNzaW9uc1JlcXVlc3R9IG9iamVjdC4gVGhlIGFwcHJvdmVkXG4gICAgICogcmVxdWVzdCBtdXN0IGhhdmUgdGhlIHJlcXVpcmVkIGBtZXRhZGF0YWAgYW5kIGBwZXJtaXNzaW9uc2AgcHJvcGVydGllcyxcbiAgICAgKiB0aGUgYGlkYCBhbmQgYG9yaWdpbmAgb2YgdGhlIGBtZXRhZGF0YWAgbXVzdCBtYXRjaCB0aGUgb3JpZ2luYWwgcmVxdWVzdFxuICAgICAqIG1ldGFkYXRhLCBhbmQgdGhlIHJlcXVlc3RlZCBwZXJtaXNzaW9ucyBtdXN0IGJlIHZhbGlkIHBlclxuICAgICAqIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci52YWxpZGF0ZVJlcXVlc3RlZFBlcm1pc3Npb25zfS4gQW55IGV4dHJhXG4gICAgICogbWV0YWRhdGEgcHJvcGVydGllcyBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEFuIGVycm9yIGlzIHRocm93biBpZiB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFwcHJvdmVkUmVxdWVzdCAtIFRoZSBhcHByb3ZlZCBwZXJtaXNzaW9ucyByZXF1ZXN0IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luYWxNZXRhZGF0YSAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0IG1ldGFkYXRhLlxuICAgICAqL1xuICAgIHZhbGlkYXRlQXBwcm92ZWRQZXJtaXNzaW9ucyhhcHByb3ZlZFJlcXVlc3QsIG9yaWdpbmFsTWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBpZCwgb3JpZ2luIH0gPSBvcmlnaW5hbE1ldGFkYXRhO1xuICAgICAgICBpZiAoIXV0aWxzXzEuaXNQbGFpbk9iamVjdChhcHByb3ZlZFJlcXVlc3QpIHx8XG4gICAgICAgICAgICAhdXRpbHNfMS5pc1BsYWluT2JqZWN0KGFwcHJvdmVkUmVxdWVzdC5tZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yc18xLmludGVybmFsRXJyb3IoYEFwcHJvdmVkIHBlcm1pc3Npb25zIHJlcXVlc3QgZm9yIHN1YmplY3QgXCIke29yaWdpbn1cIiBpcyBpbnZhbGlkLmAsIHsgZGF0YTogeyBhcHByb3ZlZFJlcXVlc3QgfSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG1ldGFkYXRhOiB7IGlkOiBuZXdJZCwgb3JpZ2luOiBuZXdPcmlnaW4gfSwgcGVybWlzc2lvbnMsIH0gPSBhcHByb3ZlZFJlcXVlc3Q7XG4gICAgICAgIGlmIChuZXdJZCAhPT0gaWQpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yc18xLmludGVybmFsRXJyb3IoYEFwcHJvdmVkIHBlcm1pc3Npb25zIHJlcXVlc3QgZm9yIHN1YmplY3QgXCIke29yaWdpbn1cIiBtdXRhdGVkIGl0cyBpZC5gLCB7IG9yaWdpbmFsSWQ6IGlkLCBtdXRhdGVkSWQ6IG5ld0lkIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdPcmlnaW4gIT09IG9yaWdpbikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzXzEuaW50ZXJuYWxFcnJvcihgQXBwcm92ZWQgcGVybWlzc2lvbnMgcmVxdWVzdCBmb3Igc3ViamVjdCBcIiR7b3JpZ2lufVwiIG11dGF0ZWQgaXRzIG9yaWdpbi5gLCB7IG9yaWdpbmFsT3JpZ2luOiBvcmlnaW4sIG11dGF0ZWRPcmlnaW46IG5ld09yaWdpbiB9KTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVJlcXVlc3RlZFBlcm1pc3Npb25zKG9yaWdpbiwgcGVybWlzc2lvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gUmUtdGhyb3cgYXMgYW4gaW50ZXJuYWwgZXJyb3I7IHdlIHNob3VsZCBuZXZlciByZWNlaXZlIGludmFsaWQgYXBwcm92ZWRcbiAgICAgICAgICAgIC8vIHBlcm1pc3Npb25zLlxuICAgICAgICAgICAgdGhyb3cgZXJyb3JzXzEuaW50ZXJuYWxFcnJvcihgSW52YWxpZCBhcHByb3ZlZCBwZXJtaXNzaW9ucyByZXF1ZXN0OiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3IuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNjZXB0cyBhIHBlcm1pc3Npb25zIHJlcXVlc3QgY3JlYXRlZCBieVxuICAgICAqIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5yZXF1ZXN0UGVybWlzc2lvbnN9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBUaGUgcGVybWlzc2lvbnMgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhc3luYyBhY2NlcHRQZXJtaXNzaW9uc1JlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICBjb25zdCB7IGlkIH0gPSByZXF1ZXN0Lm1ldGFkYXRhO1xuICAgICAgICBpZiAoIXRoaXMuaGFzQXBwcm92YWxSZXF1ZXN0KHsgaWQgfSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5QZXJtaXNzaW9uc1JlcXVlc3ROb3RGb3VuZEVycm9yKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMocmVxdWVzdC5wZXJtaXNzaW9ucykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3RQZXJtaXNzaW9uc1JlcXVlc3QoaWQsIGVycm9yc18xLmludmFsaWRQYXJhbXMoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdNdXN0IHJlcXVlc3QgYXQgbGVhc3Qgb25lIHBlcm1pc3Npb24uJyxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0uY2FsbCgnQXBwcm92YWxDb250cm9sbGVyOmFjY2VwdFJlcXVlc3QnLCBpZCwgcmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBJZiBhY2NlcHRpbmcgdW5leHBlY3RlZGx5IGZhaWxzLCByZWplY3QgdGhlIHJlcXVlc3QgYW5kIHJlLXRocm93IHRoZVxuICAgICAgICAgICAgLy8gZXJyb3JcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdFBlcm1pc3Npb25zUmVxdWVzdChpZCwgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVqZWN0cyBhIHBlcm1pc3Npb25zIHJlcXVlc3QgY3JlYXRlZCBieVxuICAgICAqIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5yZXF1ZXN0UGVybWlzc2lvbnN9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSByZXF1ZXN0IHRvIGJlIHJlamVjdGVkLlxuICAgICAqL1xuICAgIGFzeW5jIHJlamVjdFBlcm1pc3Npb25zUmVxdWVzdChpZCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzQXBwcm92YWxSZXF1ZXN0KHsgaWQgfSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5QZXJtaXNzaW9uc1JlcXVlc3ROb3RGb3VuZEVycm9yKGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWplY3RQZXJtaXNzaW9uc1JlcXVlc3QoaWQsIGVycm9yc18xLnVzZXJSZWplY3RlZFJlcXVlc3QoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSB7QGxpbmsgQXBwcm92YWxDb250cm9sbGVyfSBoYXMgYSBwYXJ0aWN1bGFyIHBlcm1pc3Npb25zXG4gICAgICogcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLmFjY2VwdFBlcm1pc3Npb25zUmVxdWVzdH0gYW5kXG4gICAgICoge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLnJlamVjdFBlcm1pc3Npb25zUmVxdWVzdH0gZm9yIHVzYWdlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHtAbGluayBIYXNBcHByb3ZhbFJlcXVlc3R9IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaWQgLSBUaGUgaWQgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QgdG8gY2hlY2sgZm9yLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHNwZWNpZmllZCByZXF1ZXN0IGV4aXN0cy5cbiAgICAgKi9cbiAgICBoYXNBcHByb3ZhbFJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdpbmdTeXN0ZW0uY2FsbCgnQXBwcm92YWxDb250cm9sbGVyOmhhc1JlcXVlc3QnLCBcbiAgICAgICAgLy8gVHlwZWNhc3Q6IEZvciBzb21lIHJlYXNvbiwgdGhlIHR5cGUgaGVyZSBleHBlY3RzIGFsbCBvZiB0aGUgcG9zc2libGVcbiAgICAgICAgLy8gSGFzQXBwcm92YWxSZXF1ZXN0IG9wdGlvbnMgdG8gYmUgc3BlY2lmaWVkLCB3aGVuIHRoZXkncmUgYWN0dWFsbHkgYWxsXG4gICAgICAgIC8vIG9wdGlvbmFsLiBQYXNzaW5nIGp1c3QgdGhlIGlkIGlzIGRlZmluaXRlbHkgdmFsaWQsIHNvIHdlIGp1c3QgY2FzdCBpdC5cbiAgICAgICAgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlamVjdHMgdGhlIHBlcm1pc3Npb25zIHJlcXVlc3Qgd2l0aCB0aGUgc3BlY2lmaWVkIGlkLCB3aXRoIHRoZSBzcGVjaWZpZWRcbiAgICAgKiBlcnJvciBhcyB0aGUgcmVhc29uLiBUaGlzIG1ldGhvZCBpcyBlZmZlY3RpdmVseSBhIHdyYXBwZXIgYXJvdW5kIGFcbiAgICAgKiBtZXNzZW5nZXIgY2FsbCBmb3IgdGhlIGBBcHByb3ZhbENvbnRyb2xsZXI6cmVqZWN0UmVxdWVzdGAgYWN0aW9uLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIuYWNjZXB0UGVybWlzc2lvbnNSZXF1ZXN0fSBhbmRcbiAgICAgKiB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIucmVqZWN0UGVybWlzc2lvbnNSZXF1ZXN0fSBmb3IgdXNhZ2UuXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSByZXF1ZXN0IHRvIHJlamVjdC5cbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWplY3Rpb24uXG4gICAgICovXG4gICAgX3JlamVjdFBlcm1pc3Npb25zUmVxdWVzdChpZCwgZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnaW5nU3lzdGVtLmNhbGwoJ0FwcHJvdmFsQ29udHJvbGxlcjpyZWplY3RSZXF1ZXN0JywgaWQsIGVycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgYSByZXN0cmljdGVkIG1ldGhvZCBhcyB0aGUgc3ViamVjdCB3aXRoIHRoZSBnaXZlbiBvcmlnaW4uXG4gICAgICogVGhlIHNwZWNpZmllZCBwYXJhbXMsIGlmIGFueSwgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIG1ldGhvZCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqICoqQVRUTjoqKiBHcmVhdCBjYXV0aW9uIHNob3VsZCBiZSBleGVyY2lzZWQgaW4gdGhlIHVzZSBvZiB0aGlzIG1ldGhvZC5cbiAgICAgKiBNZXRob2RzIHRoYXQgY2F1c2Ugc2lkZSBlZmZlY3RzIG9yIGFmZmVjdCBhcHBsaWNhdGlvbiBzdGF0ZSBzaG91bGRcbiAgICAgKiBiZSBhdm9pZGVkLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBmaXJzdCBhdHRlbXB0IHRvIHJldHJpZXZlIHRoZSByZXF1ZXN0ZWQgcmVzdHJpY3RlZCBtZXRob2RcbiAgICAgKiBpbXBsZW1lbnRhdGlvbiwgdGhyb3dpbmcgaWYgaXQgZG9lcyBub3QgZXhpc3QuIFRoZSBtZXRob2Qgd2lsbCB0aGVuIGJlXG4gICAgICogaW52b2tlZCBhcyB0aG91Z2ggdGhlIHN1YmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIG9yaWdpbiBoYWQgaW52b2tlZCBpdCB3aXRoXG4gICAgICogdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzLiBUaGlzIG1lYW5zIHRoYXQgYW55IGV4aXN0aW5nIGNhdmVhdHMgd2lsbCBiZVxuICAgICAqIGFwcGxpZWQgdG8gdGhlIHJlc3RyaWN0ZWQgbWV0aG9kLCBhbmQgdGhpcyBtZXRob2Qgd2lsbCB0aHJvdyBpZiB0aGVcbiAgICAgKiByZXN0cmljdGVkIG1ldGhvZCBvciBpdHMgY2F2ZWF0IGRlY29yYXRvcnMgdGhyb3cuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiwgdGhpcyBtZXRob2Qgd2lsbCB0aHJvdyBpZiB0aGUgc3ViamVjdCBkb2VzIG5vdCBoYXZlIGFcbiAgICAgKiBwZXJtaXNzaW9uIGZvciB0aGUgc3BlY2lmaWVkIHJlc3RyaWN0ZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHN1YmplY3QgdG8gZXhlY3V0ZSB0aGUgbWV0aG9kIG9uIGJlaGFsZlxuICAgICAqIG9mLlxuICAgICAqIEBwYXJhbSB0YXJnZXROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBleGVjdXRlLiBUaGlzIG11c3QgYmUgYSB2YWxpZFxuICAgICAqIHBlcm1pc3Npb24gdGFyZ2V0IG5hbWUuXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSBleGVjdXRlZCBtZXRob2QuXG4gICAgICovXG4gICAgYXN5bmMgZXhlY3V0ZVJlc3RyaWN0ZWRNZXRob2Qob3JpZ2luLCB0YXJnZXROYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gVGhyb3dzIGlmIHRoZSBtZXRob2QgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgY29uc3QgbWV0aG9kSW1wbGVtZW50YXRpb24gPSB0aGlzLmdldFJlc3RyaWN0ZWRNZXRob2QodGFyZ2V0TmFtZSwgb3JpZ2luKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fZXhlY3V0ZVJlc3RyaWN0ZWRNZXRob2QobWV0aG9kSW1wbGVtZW50YXRpb24sIHsgb3JpZ2luIH0sIHRhcmdldE5hbWUsIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCByZXF1ZXN0IGZvciBtZXRob2QgXCIke3RhcmdldE5hbWV9XCIgYXMgb3JpZ2luIFwiJHtvcmlnaW59XCIgcmV0dXJuZWQgbm8gcmVzdWx0LmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIGludGVybmFsIG1ldGhvZCB1c2VkIGluIHRoZSBjb250cm9sbGVyJ3MgYGpzb24tcnBjLWVuZ2luZWAgbWlkZGxld2FyZVxuICAgICAqIGFuZCB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIuZXhlY3V0ZVJlc3RyaWN0ZWRNZXRob2R9LiBDYWxscyB0aGVcbiAgICAgKiBzcGVjaWZpZWQgcmVzdHJpY3RlZCBtZXRob2QgaW1wbGVtZW50YXRpb24gYWZ0ZXIgZGVjb3JhdGluZyBpdCB3aXRoIHRoZVxuICAgICAqIGNhdmVhdHMgb2YgaXRzIHBlcm1pc3Npb24uIFRocm93cyBpZiB0aGUgc3ViamVjdCBkb2VzIG5vdCBoYXZlIHRoZVxuICAgICAqIHJlcXVpc2l0ZSBwZXJtaXNzaW9uLlxuICAgICAqXG4gICAgICogKipBVFROOioqIFBhcmFtZXRlciB2YWxpZGF0aW9uIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGVyLCBvclxuICAgICAqIHRoZSByZXN0cmljdGVkIG1ldGhvZCBpbXBsZW1lbnRhdGlvbiBpbiB0aGUgY2FzZSBvZiBgcGFyYW1zYC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLmV4ZWN1dGVSZXN0cmljdGVkTWV0aG9kfSBhbmRcbiAgICAgKiB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIuY3JlYXRlUGVybWlzc2lvbk1pZGRsZXdhcmV9IGZvciB1c2FnZS5cbiAgICAgKiBAcGFyYW0gbWV0aG9kSW1wbGVtZW50YXRpb24gLSBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIG1ldGhvZCB0byBjYWxsLlxuICAgICAqIEBwYXJhbSBzdWJqZWN0IC0gTWV0YWRhdGEgYWJvdXQgdGhlIHN1YmplY3QgdGhhdCBtYWRlIHRoZSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSByZXEgLSBUaGUgcmVxdWVzdCBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgX2V4ZWN1dGVSZXN0cmljdGVkTWV0aG9kKG1ldGhvZEltcGxlbWVudGF0aW9uLCBzdWJqZWN0LCBtZXRob2QsIHBhcmFtcyA9IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgb3JpZ2luIH0gPSBzdWJqZWN0O1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9uID0gdGhpcy5nZXRQZXJtaXNzaW9uKG9yaWdpbiwgbWV0aG9kKTtcbiAgICAgICAgaWYgKCFwZXJtaXNzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcnNfMS51bmF1dGhvcml6ZWQoeyBkYXRhOiB7IG9yaWdpbiwgbWV0aG9kIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENhdmVhdF8xLmRlY29yYXRlV2l0aENhdmVhdHMobWV0aG9kSW1wbGVtZW50YXRpb24sIHBlcm1pc3Npb24sIHRoaXMuX2NhdmVhdFNwZWNpZmljYXRpb25zKSh7IG1ldGhvZCwgcGFyYW1zLCBjb250ZXh0OiB7IG9yaWdpbiB9IH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUGVybWlzc2lvbkNvbnRyb2xsZXIgPSBQZXJtaXNzaW9uQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBlcm1pc3Npb25Db250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1ZhbGlkQmFzZTY0U3RyaW5nS2V5ID0gZXhwb3J0cy5pc1ZhbGlkSGV4U3RyaW5nS2V5ID0gZXhwb3J0cy5pc1ZhbGlkQnVmZmVyS2V5ID0gZXhwb3J0cy5idWZmZXJUb0Jhc2U2NFN0cmluZyA9IGV4cG9ydHMuaGV4U3RyaW5nVG9CdWZmZXIgPSBleHBvcnRzLmJhc2U2NFN0cmluZ1RvQnVmZmVyID0gZXhwb3J0cy5pc1ZhbGlkSGV4U3RyaW5nID0gZXhwb3J0cy5zdHJpcEhleFByZWZpeCA9IGV4cG9ydHMuaXNIYXJkZW5lZCA9IGV4cG9ydHMuaXNWYWxpZEJJUDMySW5kZXggPSBleHBvcnRzLnZhbGlkYXRlQklQMzJJbmRleCA9IGV4cG9ydHMuZ2V0VW5oYXJkZW5lZEJJUDMyTm9kZVRva2VuID0gZXhwb3J0cy5nZXRIYXJkZW5lZEJJUDMyTm9kZVRva2VuID0gZXhwb3J0cy5nZXRCSVA0NENvaW5UeXBlVG9BZGRyZXNzUGF0aFR1cGxlID0gZXhwb3J0cy5nZXRCSVA0NENoYW5nZVBhdGhTdHJpbmcgPSBleHBvcnRzLmdldEJJUDQ0Q29pblR5cGVQYXRoU3RyaW5nID0gdm9pZCAwO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG4vKipcbiAqIEdldHMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBCSVAtNDQgcGF0aCBvZiBkZXB0aCAyLCBpLmUuOlxuICogYG0gLyA0NCcgLyBjb2luX3R5cGUnYFxuICpcbiAqIEZvciBkaXNwbGF5IHB1cnBvc2VzIG9ubHkuXG4gKlxuICogQHBhcmFtIGNvaW5fdHlwZSAtIFRoZSBgY29pbl90eXBlYCBpbmRleCB0byBjcmVhdGUgYSBwYXRoIHZpc3VhbGl6YXRpb24gZm9yLlxuICogQHJldHVybnMgVGhlIHZpc3VhbGl6YXRpb24gb2YgdGhlIEJJUC00NCBwYXRoIGZvciB0aHRlIHNwZWNpZmllZCBgY29pbl90eXBlYC5cbiAqL1xuZnVuY3Rpb24gZ2V0QklQNDRDb2luVHlwZVBhdGhTdHJpbmcoY29pbl90eXBlKSB7XG4gICAgcmV0dXJuIGBtIC8gJHtjb25zdGFudHNfMS5CSVA0NFB1cnBvc2VOb2RlVG9rZW59IC8gJHtnZXRVbmhhcmRlbmVkQklQMzJOb2RlVG9rZW4oY29pbl90eXBlKX0nYDtcbn1cbmV4cG9ydHMuZ2V0QklQNDRDb2luVHlwZVBhdGhTdHJpbmcgPSBnZXRCSVA0NENvaW5UeXBlUGF0aFN0cmluZztcbi8qKlxuICogR2V0cyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIEJJUC00NCBwYXRoIG9mIGRlcHRoIDQsIGkuZS46XG4gKiBgbSAvIDQ0JyAvIGNvaW5fdHlwZScgLyBhY2NvdW50JyAvIGNoYW5nZWBcbiAqXG4gKiBGb3IgZGlzcGxheSBwdXJwb3NlcyBvbmx5LlxuICpcbiAqIEBwYXJhbSBjb2luVHlwZVBhdGggLSBUaGUgcGFyZW50IGBjb2luX3R5cGVgIHBhdGguXG4gKiBAcGFyYW0gY29pbl90eXBlIC0gVGhlIGBjaGFuZ2VgIGluZGV4IHRvIGNyZWF0ZSBhIHBhdGggdmlzdWFsaXphdGlvbiBmb3IuXG4gKiBAcmV0dXJucyBUaGUgdmlzdWFsaXphdGlvbiBvZiB0aGUgQklQLTQ0IHBhdGggZm9yIHRoZSBzcGVjaWZpZWQgYGNvaW5fdHlwZWBcbiAqIGFuZCBgY2hhbmdlYCBpbmRpY2VzLlxuICovXG5mdW5jdGlvbiBnZXRCSVA0NENoYW5nZVBhdGhTdHJpbmcoY29pblR5cGVQYXRoLCBpbmRpY2VzKSB7XG4gICAgcmV0dXJuIGAke2NvaW5UeXBlUGF0aH0gLyAke2dldEhhcmRlbmVkQklQMzJOb2RlVG9rZW4oaW5kaWNlcy5hY2NvdW50IHx8IDApfSAvICR7Z2V0VW5oYXJkZW5lZEJJUDMyTm9kZVRva2VuKGluZGljZXMuY2hhbmdlIHx8IDApfWA7XG59XG5leHBvcnRzLmdldEJJUDQ0Q2hhbmdlUGF0aFN0cmluZyA9IGdldEJJUDQ0Q2hhbmdlUGF0aFN0cmluZztcbi8qKlxuICogR2V0cyBhIEJJUC00NCBwYXRoIHR1cGxlIG9mIHRoZSBmb3JtIGBhY2NvdW50JyAvIGNoYW5nZSAvIGFkZHJlc3NfaW5kZXhgLFxuICogd2hpY2ggY2FuIGJlIHVzZWQgdG8gZGVyaXZlIGFkZHJlc3Mga2V5cyB0b2dldGhlciB3aXRoIGEgYGNvaW5fdHlwZWAga2V5LlxuICpcbiAqIEBwYXJhbSBpbmRpY2VzIC0gVGhlIEJJUC00NCBkZXJpdmF0aW9uIGluZGV4IHZhbHVlcy5cbiAqIEBwYXJhbSBpbmRpY2VzLmFjY291bnQgLSBUaGUgYGFjY291bnRgIGluZGV4IHZhbHVlLlxuICogQHBhcmFtIGluZGljZXMuY2hhbmdlIC0gVGhlIGBjaGFuZ2VgIGluZGV4IHZhbHVlLlxuICogQHBhcmFtIGluZGljZXMuYWRkcmVzc19pbmRleCAtIFRoZSBgYWRkcmVzc19pbmRleGAgaW5kZXggdmFsdWUuXG4gKiBAcmV0dXJucyBUaGUgYGFjY291bnQnIC8gY2hhbmdlIC8gYWRkcmVzc19pbmRleGAgcGF0aCBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICogc3BlY2lmaWVkIGluZGljZXMuXG4gKi9cbmZ1bmN0aW9uIGdldEJJUDQ0Q29pblR5cGVUb0FkZHJlc3NQYXRoVHVwbGUoeyBhY2NvdW50ID0gMCwgY2hhbmdlID0gMCwgYWRkcmVzc19pbmRleCwgfSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGdldEhhcmRlbmVkQklQMzJOb2RlVG9rZW4oYWNjb3VudCksXG4gICAgICAgIGdldFVuaGFyZGVuZWRCSVAzMk5vZGVUb2tlbihjaGFuZ2UpLFxuICAgICAgICBnZXRVbmhhcmRlbmVkQklQMzJOb2RlVG9rZW4oYWRkcmVzc19pbmRleCksXG4gICAgXTtcbn1cbmV4cG9ydHMuZ2V0QklQNDRDb2luVHlwZVRvQWRkcmVzc1BhdGhUdXBsZSA9IGdldEJJUDQ0Q29pblR5cGVUb0FkZHJlc3NQYXRoVHVwbGU7XG4vKipcbiAqIEEgaGFyZGVuZWQgQklQLTMyIG5vZGUgdG9rZW4sIGUuZy4gYGJpcDMyOjAnYC5cbiAqIFZhbGlkYXRlcyB0aGF0IHRoZSBpbmRleCBpcyBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIG51bWJlciwgYW5kIHRocm93cyBhblxuICogZXJyb3IgaWYgdmFsaWRhdGlvbiBmYWlscy5cbiAqXG4gKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIG5vZGUuXG4gKiBAcmV0dXJucyBUaGUgaGFyZGVuZWQgQklQLTMyIG5vZGUgdG9rZW4uXG4gKi9cbmZ1bmN0aW9uIGdldEhhcmRlbmVkQklQMzJOb2RlVG9rZW4oaW5kZXgpIHtcbiAgICB2YWxpZGF0ZUJJUDMySW5kZXgoaW5kZXgpO1xuICAgIHJldHVybiBgJHtnZXRVbmhhcmRlbmVkQklQMzJOb2RlVG9rZW4oaW5kZXgpfSdgO1xufVxuZXhwb3J0cy5nZXRIYXJkZW5lZEJJUDMyTm9kZVRva2VuID0gZ2V0SGFyZGVuZWRCSVAzMk5vZGVUb2tlbjtcbi8qKlxuICogQW4gdW5oYXJkZW5lZCBCSVAtMzIgbm9kZSB0b2tlbiwgZS5nLiBgYmlwMzI6MGAuXG4gKiBWYWxpZGF0ZXMgdGhhdCB0aGUgaW5kZXggaXMgYSBub24tbmVnYXRpdmUgaW50ZWdlciBudW1iZXIsIGFuZCB0aHJvd3MgYW5cbiAqIGVycm9yIGlmIHZhbGlkYXRpb24gZmFpbHMuXG4gKlxuICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBub2RlLlxuICogQHJldHVybnMgVGhlIHVuaGFyZGVuZWQgQklQLTMyIG5vZGUgdG9rZW4uXG4gKi9cbmZ1bmN0aW9uIGdldFVuaGFyZGVuZWRCSVAzMk5vZGVUb2tlbihpbmRleCkge1xuICAgIHZhbGlkYXRlQklQMzJJbmRleChpbmRleCk7XG4gICAgcmV0dXJuIGBiaXAzMjoke2luZGV4fWA7XG59XG5leHBvcnRzLmdldFVuaGFyZGVuZWRCSVAzMk5vZGVUb2tlbiA9IGdldFVuaGFyZGVuZWRCSVAzMk5vZGVUb2tlbjtcbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgdGhlIGluZGV4IGlzIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgbnVtYmVyLiBUaHJvd3MgYW5cbiAqIGVycm9yIGlmIHZhbGlkYXRpb24gZmFpbHMuXG4gKlxuICogQHBhcmFtIGFkZHJlc3NJbmRleCAtIFRoZSBpbmRleCB0byB2YWxpZGF0ZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVCSVAzMkluZGV4KGFkZHJlc3NJbmRleCkge1xuICAgIGlmICghaXNWYWxpZEJJUDMySW5kZXgoYWRkcmVzc0luZGV4KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQklQLTMyIGluZGV4OiBNdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIuYCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUJJUDMySW5kZXggPSB2YWxpZGF0ZUJJUDMySW5kZXg7XG4vKipcbiAqIEBwYXJhbSBpbmRleCAtIFRoZSBCSVAtMzIgaW5kZXggdG8gdGVzdC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGluZGV4IGlzIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgbnVtYmVyLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQklQMzJJbmRleChpbmRleCkge1xuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGluZGV4KSAmJiBpbmRleCA+PSAwO1xufVxuZXhwb3J0cy5pc1ZhbGlkQklQMzJJbmRleCA9IGlzVmFsaWRCSVAzMkluZGV4O1xuLyoqXG4gKiBAcGFyYW0gYmlwMzJUb2tlbiAtIFRoZSB0b2tlbiB0byB0ZXN0LlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdG9rZW4gaXMgaGFyZGVuZWQsIGkuZS4gZW5kcyB3aXRoIGAnYC5cbiAqL1xuZnVuY3Rpb24gaXNIYXJkZW5lZChiaXAzMlRva2VuKSB7XG4gICAgcmV0dXJuIGJpcDMyVG9rZW4uZW5kc1dpdGgoYCdgKTtcbn1cbmV4cG9ydHMuaXNIYXJkZW5lZCA9IGlzSGFyZGVuZWQ7XG4vKipcbiAqIEBwYXJhbSBoZXhTdHJpbmcgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIHN0cmlwLlxuICogQHJldHVybnMgVGhlIGhleGFkZWNpbWFsIHN0cmluZywgd2l0aG91dCBhIGAweGAtcHJlZml4LCBpZiBhbnkuXG4gKi9cbmZ1bmN0aW9uIHN0cmlwSGV4UHJlZml4KGhleFN0cmluZykge1xuICAgIHJldHVybiBoZXhTdHJpbmcucmVwbGFjZSgvXjB4L2l1LCAnJyk7XG59XG5leHBvcnRzLnN0cmlwSGV4UHJlZml4ID0gc3RyaXBIZXhQcmVmaXg7XG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBzdHJpbmcgaXMgYSB2YWxpZCBoZXhhZGVjaW1hbCBzdHJpbmcuIFRoZSBzdHJpbmdcbiAqIG1heSBvciBtYXkgbm90IGJlIGAweGAtcHJlZml4ZWQsIGFuZCB0aGUgdGVzdCBpcyBjYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEBwYXJhbSBoZXhTdHJpbmcgLSBUaGUgc3RyaW5nIHRvIHRlc3QuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgc3RyaW5nIGlzIGEgdmFsaWQgaGV4YWRlY2ltYWwgc3RyaW5nLiBUaGVcbiAqIHN0cmluZyBtYXkgb3IgbWF5IG5vdCBiZSBgMHhgLXByZWZpeGVkLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkSGV4U3RyaW5nKGhleFN0cmluZykge1xuICAgIHJldHVybiAvXig/OjB4KT9bYS1mMC05XSskL2l1LnRlc3QoaGV4U3RyaW5nKTtcbn1cbmV4cG9ydHMuaXNWYWxpZEhleFN0cmluZyA9IGlzVmFsaWRIZXhTdHJpbmc7XG4vKipcbiAqIEBwYXJhbSBiYXNlNjRTdHJpbmcgLSBUaGUgQmFzZTY0IHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIHtAbGluayBCdWZmZXJ9IGNvcnJlc3BvbmRpbmcgdG8gdGhlIEJhc2U2NCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2U2NFN0cmluZ1RvQnVmZmVyKGJhc2U2NFN0cmluZykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShiYXNlNjRTdHJpbmcsICdiYXNlNjQnKTtcbn1cbmV4cG9ydHMuYmFzZTY0U3RyaW5nVG9CdWZmZXIgPSBiYXNlNjRTdHJpbmdUb0J1ZmZlcjtcbi8qKlxuICogQHBhcmFtIGhleFN0cmluZyAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgQnVmZmVyfSBjb3JyZXNwb25kaW5nIHRvIHRoZSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGhleFN0cmluZ1RvQnVmZmVyKGhleFN0cmluZykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHJpcEhleFByZWZpeChoZXhTdHJpbmcpLCAnaGV4Jyk7XG59XG5leHBvcnRzLmhleFN0cmluZ1RvQnVmZmVyID0gaGV4U3RyaW5nVG9CdWZmZXI7XG4vKipcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB7QGxpbmsgQnVmZmVyfSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGJ1ZmZlciBhcyBhIEJhc2U2NCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvQmFzZTY0U3RyaW5nKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnRvU3RyaW5nKCdiYXNlNjQnKTtcbn1cbmV4cG9ydHMuYnVmZmVyVG9CYXNlNjRTdHJpbmcgPSBidWZmZXJUb0Jhc2U2NFN0cmluZztcbi8qKlxuICogVGVzdHMgd2hldGhlciB0aGUgc3BlY2lmaWVkIHtAbGluayBCdWZmZXJ9IGlzIGEgdmFsaWQgQklQLTMyIGtleS5cbiAqIEEgdmFsaWQgYnVmZmVyIGtleSBpcyA2NCBieXRlcyBsb25nIGFuZCBoYXMgYXQgbGVhc3Qgb25lIG5vbi16ZXJvIGJ5dGUuXG4gKlxuICogQHBhcmFtIGJ1ZmZlciAtIFRoZSB7QGxpbmsgQnVmZmVyfSB0byB0ZXN0LlxuICogQHJldHVybnMgV2hldGhlciB0aGUgYnVmZmVyIHJlcHJlc2VudHMgYSB2YWxpZCBCSVAtMzIga2V5LlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQnVmZmVyS2V5KGJ1ZmZlcikge1xuICAgIGlmIChidWZmZXIubGVuZ3RoICE9PSBjb25zdGFudHNfMS5CVUZGRVJfS0VZX0xFTkdUSCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYnl0ZSBvZiBidWZmZXIpIHtcbiAgICAgICAgaWYgKGJ5dGUgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNWYWxpZEJ1ZmZlcktleSA9IGlzVmFsaWRCdWZmZXJLZXk7XG4vKipcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSBzdHJpbmcgdG8gdGVzdC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHN0cmluZyBpcyBhIHZhbGlkIEJhc2U2NCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRCYXNlNjRTdHJpbmcoaW5wdXQpIHtcbiAgICByZXR1cm4gY29uc3RhbnRzXzEuQkFTRV82NF9SRUdFWC50ZXN0KGlucHV0KTtcbn1cbi8qKlxuICogVGVzdHMgd2hldGhlciB0aGUgc3BlY2lmaWVkIGhleGFkZWNpbWFsIHN0cmluZyBpcyBhIHZhbGlkIEJJUC0zMiBrZXkuXG4gKiBBIHZhbGlkIGhleGFkZWNpbWFsIHN0cmluZyBrZXkgaXMgMTI4IGNoYXJhY3RlcnMgbG9uZyAoZXhjbHVkaW5nIGFueSBgMHhgXG4gKiBwcmVmaXgpIGFuZCBoYXMgYXQgbGVhc3Qgb25lIG5vbi16ZXJvIGJ5dGUuXG4gKlxuICogQHBhcmFtIHN0cmluZ0tleSAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gdGVzdC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHN0cmluZyByZXByZXNlbnRzIGEgdmFsaWQgQklQLTMyIGtleS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEhleFN0cmluZ0tleShzdHJpbmdLZXkpIHtcbiAgICBpZiAoIWlzVmFsaWRIZXhTdHJpbmcoc3RyaW5nS2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHN0cmlwcGVkID0gc3RyaXBIZXhQcmVmaXgoc3RyaW5nS2V5KTtcbiAgICBpZiAoc3RyaXBwZWQubGVuZ3RoICE9PSBjb25zdGFudHNfMS5IRVhBREVDSU1BTF9LRVlfTEVOR1RIKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKC9eMCskL2l1LnRlc3Qoc3RyaXBwZWQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzVmFsaWRIZXhTdHJpbmdLZXkgPSBpc1ZhbGlkSGV4U3RyaW5nS2V5O1xuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgQmFzZTY0IHN0cmluZyBpcyBhIHZhbGlkIEJJUC0zMiBrZXkuXG4gKiBBIHZhbGlkIEJhc2U2NCBzdHJpbmcga2V5IGlzIDg4IGNoYXJhY3RlcnMgbG9uZyBhbmQgaGFzIGF0IGxlYXN0IG9uZSBub24temVyb1xuICogYnl0ZS5cbiAqXG4gKiBAcGFyYW0gc3RyaW5nS2V5IC0gVGhlIEJhc2U2NCBzdHJpbmcgdG8gdGVzdC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHN0cmluZyByZXByZXNlbnRzIGEgdmFsaWQgQklQLTMyIGtleS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEJhc2U2NFN0cmluZ0tleShzdHJpbmdLZXkpIHtcbiAgICBpZiAoIWlzVmFsaWRCYXNlNjRTdHJpbmcoc3RyaW5nS2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdHJpbmdLZXkubGVuZ3RoICE9PSBjb25zdGFudHNfMS5CQVNFXzY0X0tFWV9MRU5HVEgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nS2V5ID09PSBjb25zdGFudHNfMS5CQVNFXzY0X1pFUk8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuaXNWYWxpZEJhc2U2NFN0cmluZ0tleSA9IGlzVmFsaWRCYXNlNjRTdHJpbmdLZXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVQYXRoU2VnbWVudCA9IGV4cG9ydHMuZGVyaXZlS2V5RnJvbVBhdGggPSB2b2lkIDA7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGRlcml2ZXJzXzEgPSByZXF1aXJlKFwiLi9kZXJpdmVyc1wiKTtcbi8qKlxuICogZXRoZXJldW0gZGVmYXVsdCBzZWVkIHBhdGg6IFwibS80NCcvNjAnLzAnLzAve2FjY291bnRfaW5kZXh9XCJcbiAqIG11bHRpcGF0aDogXCJiaXAzMjo0NCcvYmlwMzI6NjAnL2JpcDMyOjAnL2JpcDMyOjAvYmlwMzI6e2FjY291bnRfaW5kZXh9XCJcbiAqXG4gKiBtOiB7IHByaXZhdGVLZXksIGNoYWluQ29kZSB9ID0gc2hhNTEySG1hYyhcIkJpdGNvaW4gc2VlZFwiLCBtYXN0ZXJTZWVkKVxuICogNDQnOiB7IHByaXZhdGVLZXksIGNoYWluQ29kZSB9ID0gcGFyZW50S2V5LnByaXZhdGVLZXkgKyBzaGE1MTJIbWFjKHBhcmVudEtleS5jaGFpbkNvZGUsIFsweDAwLCBwYXJlbnRLZXkucHJpdmF0ZUtleSwgaW5kZXggKyBIQVJERU5FRF9PRkZTRVRdKVxuICogNjAnOiB7IHByaXZhdGVLZXksIGNoYWluQ29kZSB9ID0gcGFyZW50S2V5LnByaXZhdGVLZXkgKyBzaGE1MTJIbWFjKHBhcmVudEtleS5jaGFpbkNvZGUsIFsweDAwLCBwYXJlbnRLZXkucHJpdmF0ZUtleSwgaW5kZXggKyBIQVJERU5FRF9PRkZTRVRdKVxuICogMCc6IHsgcHJpdmF0ZUtleSwgY2hhaW5Db2RlIH0gPSBwYXJlbnRLZXkucHJpdmF0ZUtleSArIHNoYTUxMkhtYWMocGFyZW50S2V5LmNoYWluQ29kZSwgWzB4MDAsIHBhcmVudEtleS5wcml2YXRlS2V5LCBpbmRleCArIEhBUkRFTkVEX09GRlNFVF0pXG4gKiAwOiB7IHByaXZhdGVLZXksIGNoYWluQ29kZSB9ID0gcGFyZW50S2V5LnByaXZhdGVLZXkgKyBzaGE1MTJIbWFjKHBhcmVudEtleS5jaGFpbkNvZGUsIFtwYXJlbnRLZXkucHVibGljS2V5LCBpbmRleF0pXG4gKiAwOiB7IHByaXZhdGVLZXksIGNoYWluQ29kZSB9ID0gcGFyZW50S2V5LnByaXZhdGVLZXkgKyBzaGE1MTJIbWFjKHBhcmVudEtleS5jaGFpbkNvZGUsIFtwYXJlbnRLZXkucHVibGljS2V5LCBpbmRleF0pXG4gKi9cbi8qKlxuICogVGFrZXMgYSBmdWxsIG9yIHBhcnRpYWwgSEQgcGF0aCBzdHJpbmcgYW5kIHJldHVybnMgdGhlIGtleSBjb3JyZXNwb25kaW5nIHRvXG4gKiB0aGUgZ2l2ZW4gcGF0aCwgd2l0aCB0aGUgZm9sbG93aW5nIGNvbnN0cmFpbnRzOlxuICpcbiAqIC0gSWYgdGhlIHBhdGggc3RhcnRzIHdpdGggYSBCSVAtMzIgbm9kZSwgYSBwYXJlbnQga2V5IG11c3QgYmUgcHJvdmlkZWQuXG4gKiAtIElmIHRoZSBwYXRoIHN0YXJ0cyB3aXRoIGEgQklQLTM5IG5vZGUsIGEgcGFyZW50IGtleSBtdXN0IE5PVCBiZSBwcm92aWRlZC5cbiAqIC0gVGhlIHBhdGggY2Fubm90IGV4Y2VlZCA1IEJJUC0zMiBub2RlcyBpbiBsZW5ndGgsIG9wdGlvbmFsbHkgcHJlY2VkZWQgYnlcbiAqICAgYSBzaW5nbGUgQklQLTM5IG5vZGUuXG4gKlxuICogV0FSTklORzogSXQgaXMgdGhlIGNvbnN1bWVyJ3MgcmVzcG9uc2liaWxpdHkgdG8gZW5zdXJlIHRoYXQgdGhlIHBhdGggaXMgdmFsaWRcbiAqIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQga2V5LlxuICpcbiAqIEBwYXJhbSBwYXRoU2VnbWVudCAtIEEgZnVsbCBvciBwYXJ0aWFsIEhEIHBhdGgsIGUuZy46XG4gKiBiaXAzOTpTRUVEX1BIUkFTRS9iaXAzMjo0NCcvYmlwMzI6NjAnL2JpcDMyOjAnL2JpcDMyOjAvYmlwMzI6MFxuICpcbiAqIEJJUC0zOSBzZWVkIHBocmFzZXMgbXVzdCBiZSBsb3dlcmNhc2UsIHNwYWNlLWRlbGltaXRlZCwgYW5kIDEyLTI0IHdvcmRzIGxvbmcuXG4gKiBAcGFyYW0gcGFyZW50S2V5IC0gVGhlIHBhcmVudCBrZXkgb2YgdGhlIGdpdmVuIHBhdGggc2VnbWVudCwgaWYgYW55LlxuICogQHJldHVybnMgVGhlIGRlcml2ZWQga2V5LlxuICovXG5mdW5jdGlvbiBkZXJpdmVLZXlGcm9tUGF0aChwYXRoU2VnbWVudCwgcGFyZW50S2V5LCBkZXB0aCkge1xuICAgIGlmIChwYXJlbnRLZXkgJiYgIUJ1ZmZlci5pc0J1ZmZlcihwYXJlbnRLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyZW50IGtleSBtdXN0IGJlIGEgQnVmZmVyIGlmIHNwZWNpZmllZC4nKTtcbiAgICB9XG4gICAgdmFsaWRhdGVQYXRoU2VnbWVudChwYXRoU2VnbWVudCwgQm9vbGVhbihwYXJlbnRLZXkpLCBkZXB0aCk7XG4gICAgbGV0IGtleSA9IHBhcmVudEtleTtcbiAgICAvLyBkZXJpdmUgdGhyb3VnaCBlYWNoIHBhcnQgb2YgcGF0aFxuICAgIHBhdGhTZWdtZW50LmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgW3BhdGhUeXBlLCBwYXRoVmFsdWVdID0gbm9kZS5zcGxpdCgnOicpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IHNob3VsZCBiZSBpbXBvc3NpYmxlICovXG4gICAgICAgIGlmICghaGFzRGVyaXZlcihwYXRoVHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkZXJpdmF0aW9uIHR5cGU6IFwiJHtwYXRoVHlwZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlcml2ZXIgPSBkZXJpdmVyc18xLmRlcml2ZXJzW3BhdGhUeXBlXTtcbiAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBkZXJpdmVyLmRlcml2ZUNoaWxkS2V5KHBhdGhWYWx1ZSwga2V5KTtcbiAgICAgICAgLy8gY29udGludWUgZGVyaXZpbmcgZnJvbSBjaGlsZCBrZXlcbiAgICAgICAga2V5ID0gY2hpbGRLZXk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGtleTtcbn1cbmV4cG9ydHMuZGVyaXZlS2V5RnJvbVBhdGggPSBkZXJpdmVLZXlGcm9tUGF0aDtcbi8qKlxuICogQHBhcmFtIHBhdGhUeXBlXG4gKi9cbmZ1bmN0aW9uIGhhc0Rlcml2ZXIocGF0aFR5cGUpIHtcbiAgICByZXR1cm4gcGF0aFR5cGUgaW4gZGVyaXZlcnNfMS5kZXJpdmVycztcbn1cbi8qKlxuICogVGhlIHBhdGggc2VnbWVudCBtdXN0IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICogLSBBIGxvbmUgQklQLTMyIHBhdGggbm9kZVxuICogLSBBIGxvbmUgQklQLTM5IHBhdGggbm9kZVxuICogLSBBIG11bHRpcGF0aFxuICpcbiAqIEBwYXJhbSBwYXRoU2VnbWVudCAtIFRoZSBwYXRoIHNlZ21lbnQgc3RyaW5nIHRvIHZhbGlkYXRlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVBhdGhTZWdtZW50KHBhdGhTZWdtZW50LCBoYXNLZXksIGRlcHRoKSB7XG4gICAgaWYgKHBhdGhTZWdtZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSEQgcGF0aCBzZWdtZW50OiBUaGUgc2VnbWVudCBtdXN0IG5vdCBiZSBlbXB0eS5gKTtcbiAgICB9XG4gICAgaWYgKHBhdGhTZWdtZW50Lmxlbmd0aCAtIDEgPiBjb25zdGFudHNfMS5NQVhfQklQXzQ0X0RFUFRIKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBIRCBwYXRoIHNlZ21lbnQ6IFRoZSBzZWdtZW50IGNhbm5vdCBleGNlZWQgYSAwLWluZGV4ZWQgZGVwdGggb2YgNS5gKTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0c1dpdGhCaXAzOSA9IGZhbHNlO1xuICAgIHBhdGhTZWdtZW50LmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgc3RhcnRzV2l0aEJpcDM5ID0gY29uc3RhbnRzXzEuQklQXzM5X1BBVEhfUkVHRVgudGVzdChub2RlKTtcbiAgICAgICAgICAgIGlmICghc3RhcnRzV2l0aEJpcDM5ICYmICFjb25zdGFudHNfMS5CSVBfMzJfUEFUSF9SRUdFWC50ZXN0KG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZ2V0TWFsZm9ybWVkRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghY29uc3RhbnRzXzEuQklQXzMyX1BBVEhfUkVHRVgudGVzdChub2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgZ2V0TWFsZm9ybWVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChkZXB0aCA9PT0gY29uc3RhbnRzXzEuTUlOX0JJUF80NF9ERVBUSCAmJlxuICAgICAgICAoIXN0YXJ0c1dpdGhCaXAzOSB8fCBwYXRoU2VnbWVudC5sZW5ndGggIT09IDEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBIRCBwYXRoIHNlZ21lbnQ6IFRoZSBzZWdtZW50IG11c3QgY29uc2lzdCBvZiBhIHNpbmdsZSBCSVAtMzkgbm9kZSBmb3IgZGVwdGhzIG9mICR7Y29uc3RhbnRzXzEuTUlOX0JJUF80NF9ERVBUSH0uIFJlY2VpdmVkOiBcIiR7cGF0aFNlZ21lbnR9XCJgKTtcbiAgICB9XG4gICAgaWYgKCFoYXNLZXkgJiYgIXN0YXJ0c1dpdGhCaXAzOSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGVyaXZhdGlvbiBwYXJhbWV0ZXJzOiBNdXN0IHNwZWNpZnkgcGFyZW50IGtleSBpZiB0aGUgZmlyc3Qgbm9kZSBvZiB0aGUgcGF0aCBzZWdtZW50IGlzIG5vdCBhIEJJUC0zOSBub2RlLicpO1xuICAgIH1cbiAgICBpZiAoaGFzS2V5ICYmIHN0YXJ0c1dpdGhCaXAzOSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGVyaXZhdGlvbiBwYXJhbWV0ZXJzOiBNYXkgbm90IHNwZWNpZnkgcGFyZW50IGtleSBpZiB0aGUgcGF0aCBzZWdtZW50IHN0YXJ0cyB3aXRoIGEgQklQLTM5IG5vZGUuJyk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVBhdGhTZWdtZW50ID0gdmFsaWRhdGVQYXRoU2VnbWVudDtcbmZ1bmN0aW9uIGdldE1hbGZvcm1lZEVycm9yKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBIRCBwYXRoIHNlZ21lbnQ6IFRoZSBwYXRoIHNlZ21lbnQgaXMgbWFsZm9ybWVkLicpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVyaXZhdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgbnVtYmVyVG9CTiA9IHJlcXVpcmUoJ251bWJlci10by1ibicpO1xudmFyIGtlY2NhazI1NiA9IHJlcXVpcmUoJ2pzLXNoYTMnKS5rZWNjYWtfMjU2O1xuXG4vLyBmcm9tIGV0aGVyZXVtanMtdXRpbFxuZnVuY3Rpb24gc3RyaXBaZXJvcyhhSW5wdXQpIHtcbiAgdmFyIGEgPSBhSW5wdXQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdmFyIGZpcnN0ID0gYVswXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB3aGlsZSAoYS5sZW5ndGggPiAwICYmIGZpcnN0LnRvU3RyaW5nKCkgPT09ICcwJykge1xuICAgIGEgPSBhLnNsaWNlKDEpO1xuICAgIGZpcnN0ID0gYVswXTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gYm5Ub0J1ZmZlcihibklucHV0KSB7XG4gIHZhciBibiA9IGJuSW5wdXQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdmFyIGhleCA9IGJuLnRvU3RyaW5nKDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcbiAgICBoZXggPSAnMCcgKyBoZXg7XG4gIH1cbiAgcmV0dXJuIHN0cmlwWmVyb3MobmV3IEJ1ZmZlcihoZXgsICdoZXgnKSk7XG59XG5cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBoZXhPckJ1ZmZlcih2YWx1ZUlucHV0LCBuYW1lKSB7XG4gIHZhciB2YWx1ZSA9IHZhbHVlSW5wdXQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihuYW1lID8gJ1tldGhqcy1hYmldIGludmFsaWQgJyArIG5hbWUgOiAnW2V0aGpzLWFiaV0gaW52YWxpZCBoZXggb3IgYnVmZmVyLCBtdXN0IGJlIGEgcHJlZml4ZWQgYWxwaGFudW1lcmljIGV2ZW4gbGVuZ3RoIGhleCBzdHJpbmcnKTtcbiAgICAgIGVycm9yLnJlYXNvbiA9ICdbZXRoanMtYWJpXSBpbnZhbGlkIGhleCBzdHJpbmcsIGhleCBtdXN0IGJlIHByZWZpeGVkIGFuZCBhbHBoYW51bWVyaWMgKGUuZy4gMHgwMjMuLiknO1xuICAgICAgZXJyb3IudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgIGlmICh2YWx1ZS5sZW5ndGggJSAyKSB7XG4gICAgICB2YWx1ZSA9ICcwJyArIHZhbHVlO1xuICAgIH1cbiAgICB2YWx1ZSA9IG5ldyBCdWZmZXIodmFsdWUsICdoZXgnKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gaGV4bGlmeSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiAnMHgnICsgYm5Ub0J1ZmZlcihuZXcgQk4odmFsdWUpKS50b1N0cmluZygnaGV4Jyk7XG4gIH0gZWxzZSBpZiAodmFsdWUubW9kIHx8IHZhbHVlLm1vZHVsbykge1xuICAgIHJldHVybiAnMHgnICsgYm5Ub0J1ZmZlcih2YWx1ZSkudG9TdHJpbmcoJ2hleCcpO1xuICB9IGVsc2Uge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICByZXR1cm4gJzB4JyArIGhleE9yQnVmZmVyKHZhbHVlKS50b1N0cmluZygnaGV4Jyk7XG4gIH1cbn1cblxuLy8gZ2V0S2V5cyhbe2E6IDEsIGI6IDJ9LCB7YTogMywgYjogNH1dLCAnYScpID0+IFsxLCAzXVxuZnVuY3Rpb24gZ2V0S2V5cyhwYXJhbXMsIGtleSwgYWxsb3dFbXB0eSkge1xuICB2YXIgcmVzdWx0ID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLWFiaV0gd2hpbGUgZ2V0dGluZyBrZXlzLCBpbnZhbGlkIHBhcmFtcyB2YWx1ZSAnICsgSlNPTi5zdHJpbmdpZnkocGFyYW1zKSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgdmFsdWUgPSBwYXJhbXNbaV1ba2V5XTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGlmIChhbGxvd0VtcHR5ICYmICF2YWx1ZSkge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLWFiaV0gd2hpbGUgZ2V0S2V5cyBmb3VuZCBpbnZhbGlkIEFCSSBkYXRhIHN0cnVjdHVyZSwgdHlwZSB2YWx1ZSBub3Qgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNvZGVyTnVtYmVyKHNpemUsIHNpZ25lZCkge1xuICByZXR1cm4ge1xuICAgIGVuY29kZTogZnVuY3Rpb24gZW5jb2RlTnVtYmVyKHZhbHVlSW5wdXQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW5wdXQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUudG9TdHJpbmcgJiYgKHZhbHVlLnRvVHdvcyB8fCB2YWx1ZS5kaXZpZGVkVG9JbnRlZ2VyQnkpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoMTApLnNwbGl0KCcuJylbMF07XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpLnNwbGl0KCcuJylbMF07XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gbnVtYmVyVG9CTih2YWx1ZSk7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvVHdvcyhzaXplICogOCkubWFza24oc2l6ZSAqIDgpO1xuICAgICAgaWYgKHNpZ25lZCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLmZyb21Ud29zKHNpemUgKiA4KS50b1R3b3MoMjU2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKTtcbiAgICB9LFxuICAgIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlTnVtYmVyKGRhdGEsIG9mZnNldCkge1xuICAgICAgdmFyIGp1bmtMZW5ndGggPSAzMiAtIHNpemU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHZhciB2YWx1ZSA9IG5ldyBCTihkYXRhLnNsaWNlKG9mZnNldCArIGp1bmtMZW5ndGgsIG9mZnNldCArIDMyKSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGlmIChzaWduZWQpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5mcm9tVHdvcyhzaXplICogOCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hc2tuKHNpemUgKiA4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN1bWVkOiAzMixcbiAgICAgICAgdmFsdWU6IG5ldyBCTih2YWx1ZS50b1N0cmluZygxMCkpXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbnZhciB1aW50MjU2Q29kZXIgPSBjb2Rlck51bWJlcigzMiwgZmFsc2UpO1xuXG52YXIgY29kZXJCb29sZWFuID0ge1xuICBlbmNvZGU6IGZ1bmN0aW9uIGVuY29kZUJvb2xlYW4odmFsdWUpIHtcbiAgICByZXR1cm4gdWludDI1NkNvZGVyLmVuY29kZSh2YWx1ZSA/IDEgOiAwKTtcbiAgfSxcbiAgZGVjb2RlOiBmdW5jdGlvbiBkZWNvZGVCb29sZWFuKGRhdGEsIG9mZnNldCkge1xuICAgIHZhciByZXN1bHQgPSB1aW50MjU2Q29kZXIuZGVjb2RlKGRhdGEsIG9mZnNldCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICByZXR1cm4ge1xuICAgICAgY29uc3VtZWQ6IHJlc3VsdC5jb25zdW1lZCxcbiAgICAgIHZhbHVlOiAhcmVzdWx0LnZhbHVlLmlzWmVybygpXG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY29kZXJGaXhlZEJ5dGVzKGxlbmd0aCkge1xuICByZXR1cm4ge1xuICAgIGVuY29kZTogZnVuY3Rpb24gZW5jb2RlRml4ZWRCeXRlcyh2YWx1ZUlucHV0KSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZUlucHV0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICB2YWx1ZSA9IGhleE9yQnVmZmVyKHZhbHVlKTtcblxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IEJ1ZmZlcigzMik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHJlc3VsdC5maWxsKDApO1xuICAgICAgdmFsdWUuY29weShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlRml4ZWRCeXRlcyhkYXRhLCBvZmZzZXQpIHtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gMCAmJiBkYXRhLmxlbmd0aCA8IG9mZnNldCArIDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLWFiaV0gd2hpbGUgZGVjb2RpbmcgZml4ZWQgYnl0ZXMsIGludmFsaWQgYnl0ZXMgZGF0YSBsZW5ndGg6ICcgKyBsZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb25zdW1lZDogMzIsXG4gICAgICAgIHZhbHVlOiAnMHgnICsgZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCkudG9TdHJpbmcoJ2hleCcpXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGNvZGVyQWRkcmVzcyA9IHtcbiAgZW5jb2RlOiBmdW5jdGlvbiBlbmNvZGVBZGRyZXNzKHZhbHVlSW5wdXQpIHtcbiAgICB2YXIgdmFsdWUgPSB2YWx1ZUlucHV0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIHJlc3VsdCA9IG5ldyBCdWZmZXIoMzIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSwgMjApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy1hYmldIHdoaWxlIGVuY29kaW5nIGFkZHJlc3MsIGludmFsaWQgYWRkcmVzcyB2YWx1ZSwgbm90IGFscGhhbnVtZXJpYyAyMCBieXRlIGhleCBzdHJpbmcnKTtcbiAgICB9XG4gICAgdmFsdWUgPSBoZXhPckJ1ZmZlcih2YWx1ZSk7XG4gICAgcmVzdWx0LmZpbGwoMCk7XG4gICAgdmFsdWUuY29weShyZXN1bHQsIDEyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZUFkZHJlc3MoZGF0YSwgb2Zmc2V0KSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb25zdW1lZDogMzIsXG4gICAgICAgIHZhbHVlOiAnMHgnXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoZGF0YS5sZW5ndGggIT09IDAgJiYgZGF0YS5sZW5ndGggPCBvZmZzZXQgKyAzMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtYWJpXSB3aGlsZSBkZWNvZGluZyBhZGRyZXNzIGRhdGEsIGludmFsaWQgYWRkcmVzcyBkYXRhLCBpbnZhbGlkIGJ5dGUgbGVuZ3RoICcgKyBkYXRhLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjb25zdW1lZDogMzIsXG4gICAgICB2YWx1ZTogJzB4JyArIGRhdGEuc2xpY2Uob2Zmc2V0ICsgMTIsIG9mZnNldCArIDMyKS50b1N0cmluZygnaGV4JylcbiAgICB9O1xuICB9XG59O1xuXG5mdW5jdGlvbiBlbmNvZGVEeW5hbWljQnl0ZXNIZWxwZXIodmFsdWUpIHtcbiAgdmFyIGRhdGFMZW5ndGggPSBwYXJzZUludCgzMiAqIE1hdGguY2VpbCh2YWx1ZS5sZW5ndGggLyAzMikpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIHZhciBwYWRkaW5nID0gbmV3IEJ1ZmZlcihkYXRhTGVuZ3RoIC0gdmFsdWUubGVuZ3RoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBwYWRkaW5nLmZpbGwoMCk7XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3VpbnQyNTZDb2Rlci5lbmNvZGUodmFsdWUubGVuZ3RoKSwgdmFsdWUsIHBhZGRpbmddKTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlRHluYW1pY0J5dGVzSGVscGVyKGRhdGEsIG9mZnNldCkge1xuICBpZiAoZGF0YS5sZW5ndGggIT09IDAgJiYgZGF0YS5sZW5ndGggPCBvZmZzZXQgKyAzMikge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLWFiaV0gd2hpbGUgZGVjb2RpbmcgZHluYW1pYyBieXRlcyBkYXRhLCBpbnZhbGlkIGJ5dGVzIGxlbmd0aDogJyArIGRhdGEubGVuZ3RoICsgJyBzaG91bGQgYmUgbGVzcyB0aGFuICcgKyAob2Zmc2V0ICsgMzIpKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSB1aW50MjU2Q29kZXIuZGVjb2RlKGRhdGEsIG9mZnNldCkudmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgbGVuZ3RoID0gbGVuZ3RoLnRvTnVtYmVyKCk7XG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gMCAmJiBkYXRhLmxlbmd0aCA8IG9mZnNldCArIDMyICsgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtYWJpXSB3aGlsZSBkZWNvZGluZyBkeW5hbWljIGJ5dGVzIGRhdGEsIGludmFsaWQgYnl0ZXMgbGVuZ3RoOiAnICsgZGF0YS5sZW5ndGggKyAnIHNob3VsZCBiZSBsZXNzIHRoYW4gJyArIChvZmZzZXQgKyAzMiArIGxlbmd0aCkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb25zdW1lZDogcGFyc2VJbnQoMzIgKyAzMiAqIE1hdGguY2VpbChsZW5ndGggLyAzMiksIDEwKSxcbiAgICB2YWx1ZTogZGF0YS5zbGljZShvZmZzZXQgKyAzMiwgb2Zmc2V0ICsgMzIgKyBsZW5ndGgpXG4gIH07XG59XG5cbnZhciBjb2RlckR5bmFtaWNCeXRlcyA9IHtcbiAgZW5jb2RlOiBmdW5jdGlvbiBlbmNvZGVEeW5hbWljQnl0ZXModmFsdWUpIHtcbiAgICByZXR1cm4gZW5jb2RlRHluYW1pY0J5dGVzSGVscGVyKGhleE9yQnVmZmVyKHZhbHVlKSk7XG4gIH0sXG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlRHluYW1pY0J5dGVzKGRhdGEsIG9mZnNldCkge1xuICAgIHZhciByZXN1bHQgPSBkZWNvZGVEeW5hbWljQnl0ZXNIZWxwZXIoZGF0YSwgb2Zmc2V0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHJlc3VsdC52YWx1ZSA9ICcweCcgKyByZXN1bHQudmFsdWUudG9TdHJpbmcoJ2hleCcpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIGR5bmFtaWM6IHRydWVcbn07XG5cbnZhciBjb2RlclN0cmluZyA9IHtcbiAgZW5jb2RlOiBmdW5jdGlvbiBlbmNvZGVTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gZW5jb2RlRHluYW1pY0J5dGVzSGVscGVyKG5ldyBCdWZmZXIodmFsdWUsICd1dGY4JykpO1xuICB9LFxuICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZVN0cmluZyhkYXRhLCBvZmZzZXQpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGVjb2RlRHluYW1pY0J5dGVzSGVscGVyKGRhdGEsIG9mZnNldCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICByZXN1bHQudmFsdWUgPSByZXN1bHQudmFsdWUudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBkeW5hbWljOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBjb2RlckFycmF5KGNvZGVyLCBsZW5ndGhJbnB1dCkge1xuICByZXR1cm4ge1xuICAgIGVuY29kZTogZnVuY3Rpb24gZW5jb2RlQXJyYXkodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQnVmZmVyKDApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoSW5wdXQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy1hYmldIHdoaWxlIGVuY29kaW5nIGFycmF5LCBpbnZhbGlkIGFycmF5IGRhdGEsIG5vdCB0eXBlIE9iamVjdCAoQXJyYXkpJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZW5ndGggPT09IC0xKSB7XG4gICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgcmVzdWx0ID0gdWludDI1NkNvZGVyLmVuY29kZShsZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoICE9PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtYWJpXSB3aGlsZSBlbmNvZGluZyBhcnJheSwgc2l6ZSBtaXNtYXRjaCBhcnJheSBsZW5ndGggJyArIGxlbmd0aCArICcgZG9lcyBub3QgZXF1YWwgJyArIHZhbHVlLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdFZhbHVlKSB7XG4gICAgICAgIHJlc3VsdCA9IEJ1ZmZlci5jb25jYXQoW3Jlc3VsdCwgY29kZXIuZW5jb2RlKHJlc3VsdFZhbHVlKV0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZUFycmF5KGRhdGEsIG9mZnNldElucHV0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoSW5wdXQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHZhciBvZmZzZXQgPSBvZmZzZXRJbnB1dDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgLy8gQFRPRE86XG4gICAgICAvLyBpZiAoZGF0YS5sZW5ndGggPCBvZmZzZXQgKyBsZW5ndGggKiAzMikgeyB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJyYXknKTsgfVxuXG4gICAgICB2YXIgY29uc3VtZWQgPSAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICB2YXIgZGVjb2RlUmVzdWx0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgIGlmIChsZW5ndGggPT09IC0xKSB7XG4gICAgICAgIGRlY29kZVJlc3VsdCA9IHVpbnQyNTZDb2Rlci5kZWNvZGUoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgbGVuZ3RoID0gZGVjb2RlUmVzdWx0LnZhbHVlLnRvTnVtYmVyKCk7XG4gICAgICAgIGNvbnN1bWVkICs9IGRlY29kZVJlc3VsdC5jb25zdW1lZDtcbiAgICAgICAgb2Zmc2V0ICs9IGRlY29kZVJlc3VsdC5jb25zdW1lZDtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIHZhciBsb29wUmVzdWx0ID0gY29kZXIuZGVjb2RlKGRhdGEsIG9mZnNldCk7XG4gICAgICAgIGNvbnN1bWVkICs9IGxvb3BSZXN1bHQuY29uc3VtZWQ7XG4gICAgICAgIG9mZnNldCArPSBsb29wUmVzdWx0LmNvbnN1bWVkO1xuICAgICAgICB2YWx1ZS5wdXNoKGxvb3BSZXN1bHQudmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb25zdW1lZDogY29uc3VtZWQsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9LFxuICAgIGR5bmFtaWM6IGxlbmd0aElucHV0ID09PSAtMVxuICB9O1xufVxuXG4vLyBCcmVhayB0aGUgdHlwZSB1cCBpbnRvIFtzdGF0aWNUeXBlXVtzdGF0aWNBcnJheV0qW2R5bmFtaWNBcnJheV0/IHwgW2R5bmFtaWNUeXBlXSBhbmRcbi8vIGJ1aWxkIHRoZSBjb2RlciB1cCBmcm9tIGl0cyBwYXJ0c1xudmFyIHBhcmFtVHlwZVBhcnQgPSBuZXcgUmVnRXhwKC9eKCh1P2ludHxieXRlcykoWzAtOV0qKXwoYWRkcmVzc3xib29sfHN0cmluZyl8KFxcWyhbMC05XSopXFxdKSkvKTtcblxuZnVuY3Rpb24gZ2V0UGFyYW1Db2Rlcih0eXBlSW5wdXQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlSW5wdXQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdmFyIGNvZGVyID0gbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB2YXIgaW52YWxpZFR5cGVFcnJvck1lc3NhZ2UgPSAnW2V0aGpzLWFiaV0gd2hpbGUgZ2V0dGluZyBwYXJhbSBjb2RlciAoZ2V0UGFyYW1Db2RlcikgdHlwZSB2YWx1ZSAnICsgSlNPTi5zdHJpbmdpZnkodHlwZSkgKyAnIGlzIGVpdGhlciBpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGJ5IGV0aGpzLWFiaS4nO1xuXG4gIHdoaWxlICh0eXBlKSB7XG4gICAgdmFyIHBhcnQgPSB0eXBlLm1hdGNoKHBhcmFtVHlwZVBhcnQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgaWYgKCFwYXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoaW52YWxpZFR5cGVFcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgICB0eXBlID0gdHlwZS5zdWJzdHJpbmcocGFydFswXS5sZW5ndGgpO1xuXG4gICAgdmFyIHByZWZpeCA9IHBhcnRbMl0gfHwgcGFydFs0XSB8fCBwYXJ0WzVdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgc3dpdGNoIChwcmVmaXgpIHtcbiAgICAgIGNhc2UgJ2ludCc6Y2FzZSAndWludCc6XG4gICAgICAgIGlmIChjb2Rlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbnZhbGlkVHlwZUVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGludFNpemUgPSBwYXJzZUludChwYXJ0WzNdIHx8IDI1Nik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgaWYgKGludFNpemUgPT09IDAgfHwgaW50U2l6ZSA+IDI1NiB8fCBpbnRTaXplICUgOCAhPT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLWFiaV0gd2hpbGUgZ2V0dGluZyBwYXJhbSBjb2RlciBmb3IgdHlwZSAnICsgdHlwZSArICcsIGludmFsaWQgJyArIHByZWZpeCArICc8Tj4gd2lkdGg6ICcgKyB0eXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGVyID0gY29kZXJOdW1iZXIoaW50U2l6ZSAvIDgsIHByZWZpeCA9PT0gJ2ludCcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgIGlmIChjb2Rlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbnZhbGlkVHlwZUVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29kZXIgPSBjb2RlckJvb2xlYW47XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBpZiAoY29kZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW52YWxpZFR5cGVFcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVyID0gY29kZXJTdHJpbmc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdieXRlcyc6XG4gICAgICAgIGlmIChjb2Rlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbnZhbGlkVHlwZUVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRbM10pIHtcbiAgICAgICAgICB2YXIgc2l6ZSA9IHBhcnNlSW50KHBhcnRbM10pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgaWYgKHNpemUgPT09IDAgfHwgc2l6ZSA+IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy1hYmldIHdoaWxlIGdldHRpbmcgcGFyYW0gY29kZXIgZm9yIHByZWZpeCBieXRlcywgaW52YWxpZCB0eXBlICcgKyB0eXBlICsgJywgc2l6ZSAnICsgc2l6ZSArICcgc2hvdWxkIGJlIDAgb3IgZ3JlYXRlciB0aGFuIDMyJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvZGVyID0gY29kZXJGaXhlZEJ5dGVzKHNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvZGVyID0gY29kZXJEeW5hbWljQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgICBpZiAoY29kZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW52YWxpZFR5cGVFcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVyID0gY29kZXJBZGRyZXNzO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnW10nOlxuICAgICAgICBpZiAoIWNvZGVyIHx8IGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW52YWxpZFR5cGVFcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVyID0gY29kZXJBcnJheShjb2RlciwgLTEpO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gXCJbMC05K11cIlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKCFjb2RlciB8fCBjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGludmFsaWRUeXBlRXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmYXVsdFNpemUgPSBwYXJzZUludChwYXJ0WzZdKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICBjb2RlciA9IGNvZGVyQXJyYXkoY29kZXIsIGRlZmF1bHRTaXplKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGludmFsaWRUeXBlRXJyb3JNZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gY29kZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCTjogQk4sXG4gIGJuVG9CdWZmZXI6IGJuVG9CdWZmZXIsXG4gIGlzSGV4U3RyaW5nOiBpc0hleFN0cmluZyxcbiAgaGV4T3JCdWZmZXI6IGhleE9yQnVmZmVyLFxuICBoZXhsaWZ5OiBoZXhsaWZ5LFxuICBzdHJpcFplcm9zOiBzdHJpcFplcm9zLFxuXG4gIGtlY2NhazI1Njoga2VjY2FrMjU2LFxuXG4gIGdldEtleXM6IGdldEtleXMsXG4gIG51bWJlclRvQk46IG51bWJlclRvQk4sXG4gIGNvZGVyTnVtYmVyOiBjb2Rlck51bWJlcixcbiAgdWludDI1NkNvZGVyOiB1aW50MjU2Q29kZXIsXG4gIGNvZGVyQm9vbGVhbjogY29kZXJCb29sZWFuLFxuICBjb2RlckZpeGVkQnl0ZXM6IGNvZGVyRml4ZWRCeXRlcyxcbiAgY29kZXJBZGRyZXNzOiBjb2RlckFkZHJlc3MsXG4gIGNvZGVyRHluYW1pY0J5dGVzOiBjb2RlckR5bmFtaWNCeXRlcyxcbiAgY29kZXJTdHJpbmc6IGNvZGVyU3RyaW5nLFxuICBjb2RlckFycmF5OiBjb2RlckFycmF5LFxuICBwYXJhbVR5cGVQYXJ0OiBwYXJhbVR5cGVQYXJ0LFxuICBnZXRQYXJhbUNvZGVyOiBnZXRQYXJhbUNvZGVyXG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSGV4UHJlZml4ZWQgPSByZXF1aXJlKCdpcy1oZXgtcHJlZml4ZWQnKTtcbnZhciBzdHJpcEhleFByZWZpeCA9IHJlcXVpcmUoJ3N0cmlwLWhleC1wcmVmaXgnKTtcblxuLyoqXG4gKiBQYWRzIGEgYFN0cmluZ2AgdG8gaGF2ZSBhbiBldmVuIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IG91dHB1dFxuICovXG5mdW5jdGlvbiBwYWRUb0V2ZW4odmFsdWUpIHtcbiAgdmFyIGEgPSB2YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmICh0eXBlb2YgYSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSB3aGlsZSBwYWRkaW5nIHRvIGV2ZW4sIHZhbHVlIG11c3QgYmUgc3RyaW5nLCBpcyBjdXJyZW50bHkgJyArIHR5cGVvZiBhICsgJywgd2hpbGUgcGFkVG9FdmVuLicpO1xuICB9XG5cbiAgaWYgKGEubGVuZ3RoICUgMikge1xuICAgIGEgPSAnMCcgKyBhO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBgTnVtYmVyYCBpbnRvIGEgaGV4IGBTdHJpbmdgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBpbnRUb0hleChpKSB7XG4gIHZhciBoZXggPSBpLnRvU3RyaW5nKDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIHJldHVybiAnMHgnICsgcGFkVG9FdmVuKGhleCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gYE51bWJlcmAgdG8gYSBgQnVmZmVyYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gaW50VG9CdWZmZXIoaSkge1xuICB2YXIgaGV4ID0gaW50VG9IZXgoaSk7XG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhleC5zbGljZSgyKSwgJ2hleCcpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYmluYXJ5IHNpemUgb2YgYSBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0QmluYXJ5U2l6ZShzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gd2hpbGUgZ2V0dGluZyBiaW5hcnkgc2l6ZSwgbWV0aG9kIGdldEJpbmFyeVNpemUgcmVxdWlyZXMgaW5wdXQgXFwnc3RyXFwnIHRvIGJlIHR5cGUgU3RyaW5nLCBnb3QgXFwnJyArIHR5cGVvZiBzdHIgKyAnXFwnLicpO1xuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKHN0ciwgJ3V0ZjgnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIFRSVUUgaWYgdGhlIGZpcnN0IHNwZWNpZmllZCBhcnJheSBjb250YWlucyBhbGwgZWxlbWVudHNcbiAqIGZyb20gdGhlIHNlY29uZCBvbmUuIEZBTFNFIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBzdXBlcnNldFxuICogQHBhcmFtIHthcnJheX0gc3Vic2V0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGFycmF5Q29udGFpbnNBcnJheShzdXBlcnNldCwgc3Vic2V0LCBzb21lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHN1cGVyc2V0KSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBhcnJheUNvbnRhaW5zQXJyYXkgcmVxdWlyZXMgaW5wdXQgXFwnc3VwZXJzZXRcXCcgdG8gYmUgYW4gYXJyYXkgZ290IHR5cGUgXFwnJyArIHR5cGVvZiBzdXBlcnNldCArICdcXCcnKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShzdWJzZXQpICE9PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGFycmF5Q29udGFpbnNBcnJheSByZXF1aXJlcyBpbnB1dCBcXCdzdWJzZXRcXCcgdG8gYmUgYW4gYXJyYXkgZ290IHR5cGUgXFwnJyArIHR5cGVvZiBzdWJzZXQgKyAnXFwnJyk7XG4gIH1cblxuICByZXR1cm4gc3Vic2V0W0Jvb2xlYW4oc29tZSkgJiYgJ3NvbWUnIHx8ICdldmVyeSddKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBzdXBlcnNldC5pbmRleE9mKHZhbHVlKSA+PSAwO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCB1dGY4IGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIHRvVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9VdGY4KGhleCkge1xuICB2YXIgYnVmZmVyVmFsdWUgPSBuZXcgQnVmZmVyKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeChoZXgpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpKSwgJ2hleCcpO1xuXG4gIHJldHVybiBidWZmZXJWYWx1ZS50b1N0cmluZygndXRmOCcpO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGFzY2lpIGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIHRvQXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvQXNjaWkoaGV4KSB7XG4gIHZhciBzdHIgPSAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB2YXIgaSA9IDAsXG4gICAgICBsID0gaGV4Lmxlbmd0aDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgaSA9IDI7XG4gIH1cblxuICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHZhciBjb2RlID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiB1dGY4IHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbVV0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21VdGY4KHN0cmluZ1ZhbHVlKSB7XG4gIHZhciBzdHIgPSBuZXcgQnVmZmVyKHN0cmluZ1ZhbHVlLCAndXRmOCcpO1xuXG4gIHJldHVybiAnMHgnICsgcGFkVG9FdmVuKHN0ci50b1N0cmluZygnaGV4JykpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIGFzY2lpIHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbUFzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tQXNjaWkoc3RyaW5nVmFsdWUpIHtcbiAgdmFyIGhleCA9ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIGNvZGUgPSBzdHJpbmdWYWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgIHZhciBuID0gY29kZS50b1N0cmluZygxNik7XG4gICAgaGV4ICs9IG4ubGVuZ3RoIDwgMiA/ICcwJyArIG4gOiBuO1xuICB9XG5cbiAgcmV0dXJuICcweCcgKyBoZXg7XG59XG5cbi8qKlxuICogZ2V0S2V5cyhbe2E6IDEsIGI6IDJ9LCB7YTogMywgYjogNH1dLCAnYScpID0+IFsxLCAzXVxuICpcbiAqIEBtZXRob2QgZ2V0S2V5cyBnZXQgc3BlY2lmaWMga2V5IGZyb20gaW5uZXIgb2JqZWN0IGFycmF5IG9mIG9iamVjdHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsb3dFbXB0eVxuICogQHJldHVybnMge0FycmF5fSBvdXRwdXQganVzdCBhIHNpbXBsZSBhcnJheSBvZiBvdXRwdXQga2V5c1xuICovXG5mdW5jdGlvbiBnZXRLZXlzKHBhcmFtcywga2V5LCBhbGxvd0VtcHR5KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGdldEtleXMgZXhwZWN0aW5nIHR5cGUgQXJyYXkgYXMgXFwncGFyYW1zXFwnIGlucHV0LCBnb3QgXFwnJyArIHR5cGVvZiBwYXJhbXMgKyAnXFwnJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGdldEtleXMgZXhwZWN0aW5nIHR5cGUgU3RyaW5nIGZvciBpbnB1dCBcXCdrZXlcXCcgZ290IFxcJycgKyB0eXBlb2Yga2V5ICsgJ1xcJy4nKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciB2YWx1ZSA9IHBhcmFtc1tpXVtrZXldOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgaWYgKGFsbG93RW1wdHkgJiYgIXZhbHVlKSB7XG4gICAgICB2YWx1ZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFiaScpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIElzIHRoZSBzdHJpbmcgYSBoZXggc3RyaW5nLlxuICpcbiAqIEBtZXRob2QgY2hlY2sgaWYgc3RyaW5nIGlzIGhleCBzdHJpbmcgb2Ygc3BlY2lmaWMgbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm5zIHtCb29sZWFufSBvdXRwdXQgdGhlIHN0cmluZyBpcyBhIGhleCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChsZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXJyYXlDb250YWluc0FycmF5OiBhcnJheUNvbnRhaW5zQXJyYXksXG4gIGludFRvQnVmZmVyOiBpbnRUb0J1ZmZlcixcbiAgZ2V0QmluYXJ5U2l6ZTogZ2V0QmluYXJ5U2l6ZSxcbiAgaXNIZXhQcmVmaXhlZDogaXNIZXhQcmVmaXhlZCxcbiAgc3RyaXBIZXhQcmVmaXg6IHN0cmlwSGV4UHJlZml4LFxuICBwYWRUb0V2ZW46IHBhZFRvRXZlbixcbiAgaW50VG9IZXg6IGludFRvSGV4LFxuICBmcm9tQXNjaWk6IGZyb21Bc2NpaSxcbiAgZnJvbVV0Zjg6IGZyb21VdGY4LFxuICB0b0FzY2lpOiB0b0FzY2lpLFxuICB0b1V0Zjg6IHRvVXRmOCxcbiAgZ2V0S2V5czogZ2V0S2V5cyxcbiAgaXNIZXhTdHJpbmc6IGlzSGV4U3RyaW5nXG59OyIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWRpc2FibGUgKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9pbmRleC5qcycpO1xudmFyIHVpbnQyNTZDb2RlciA9IHV0aWxzLnVpbnQyNTZDb2RlcjtcbnZhciBjb2RlckJvb2xlYW4gPSB1dGlscy5jb2RlckJvb2xlYW47XG52YXIgY29kZXJGaXhlZEJ5dGVzID0gdXRpbHMuY29kZXJGaXhlZEJ5dGVzO1xudmFyIGNvZGVyQWRkcmVzcyA9IHV0aWxzLmNvZGVyQWRkcmVzcztcbnZhciBjb2RlckR5bmFtaWNCeXRlcyA9IHV0aWxzLmNvZGVyRHluYW1pY0J5dGVzO1xudmFyIGNvZGVyU3RyaW5nID0gdXRpbHMuY29kZXJTdHJpbmc7XG52YXIgY29kZXJBcnJheSA9IHV0aWxzLmNvZGVyQXJyYXk7XG52YXIgcGFyYW1UeXBlUGFydCA9IHV0aWxzLnBhcmFtVHlwZVBhcnQ7XG52YXIgZ2V0UGFyYW1Db2RlciA9IHV0aWxzLmdldFBhcmFtQ29kZXI7XG5cbmZ1bmN0aW9uIFJlc3VsdCgpIHt9XG5cbmZ1bmN0aW9uIGVuY29kZVBhcmFtcyh0eXBlcywgdmFsdWVzKSB7XG4gIGlmICh0eXBlcy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy1hYmldIHdoaWxlIGVuY29kaW5nIHBhcmFtcywgdHlwZXMvdmFsdWVzIG1pc21hdGNoLCBZb3VyIGNvbnRyYWN0IHJlcXVpcmVzICcgKyB0eXBlcy5sZW5ndGggKyAnIHR5cGVzIChhcmd1bWVudHMpLCBhbmQgeW91IHBhc3NlZCBpbiAnICsgdmFsdWVzLmxlbmd0aCk7XG4gIH1cblxuICB2YXIgcGFydHMgPSBbXTtcblxuICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlLCBpbmRleCkge1xuICAgIHZhciBjb2RlciA9IGdldFBhcmFtQ29kZXIodHlwZSk7XG4gICAgcGFydHMucHVzaCh7IGR5bmFtaWM6IGNvZGVyLmR5bmFtaWMsIHZhbHVlOiBjb2Rlci5lbmNvZGUodmFsdWVzW2luZGV4XSkgfSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGFsaWduU2l6ZShzaXplKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KDMyICogTWF0aC5jZWlsKHNpemUgLyAzMikpO1xuICB9XG5cbiAgdmFyIHN0YXRpY1NpemUgPSAwLFxuICAgICAgZHluYW1pY1NpemUgPSAwO1xuICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgaWYgKHBhcnQuZHluYW1pYykge1xuICAgICAgc3RhdGljU2l6ZSArPSAzMjtcbiAgICAgIGR5bmFtaWNTaXplICs9IGFsaWduU2l6ZShwYXJ0LnZhbHVlLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRpY1NpemUgKz0gYWxpZ25TaXplKHBhcnQudmFsdWUubGVuZ3RoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBvZmZzZXQgPSAwLFxuICAgICAgZHluYW1pY09mZnNldCA9IHN0YXRpY1NpemU7XG4gIHZhciBkYXRhID0gbmV3IEJ1ZmZlcihzdGF0aWNTaXplICsgZHluYW1pY1NpemUpO1xuXG4gIHBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQsIGluZGV4KSB7XG4gICAgaWYgKHBhcnQuZHluYW1pYykge1xuICAgICAgdWludDI1NkNvZGVyLmVuY29kZShkeW5hbWljT2Zmc2V0KS5jb3B5KGRhdGEsIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gMzI7XG5cbiAgICAgIHBhcnQudmFsdWUuY29weShkYXRhLCBkeW5hbWljT2Zmc2V0KTtcbiAgICAgIGR5bmFtaWNPZmZzZXQgKz0gYWxpZ25TaXplKHBhcnQudmFsdWUubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydC52YWx1ZS5jb3B5KGRhdGEsIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gYWxpZ25TaXplKHBhcnQudmFsdWUubGVuZ3RoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiAnMHgnICsgZGF0YS50b1N0cmluZygnaGV4Jyk7XG59XG5cbi8vIGRlY29kZSBieXRlY29kZSBkYXRhIGZyb20gb3V0cHV0IG5hbWVzIGFuZCB0eXBlc1xuZnVuY3Rpb24gZGVjb2RlUGFyYW1zKG5hbWVzLCB0eXBlcywgZGF0YSkge1xuICB2YXIgdXNlTnVtYmVyZWRQYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG5cbiAgLy8gTmFtZXMgaXMgb3B0aW9uYWwsIHNvIHNoaWZ0IG92ZXIgYWxsIHRoZSBwYXJhbWV0ZXJzIGlmIG5vdCBwcm92aWRlZFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICBkYXRhID0gdHlwZXM7XG4gICAgdHlwZXMgPSBuYW1lcztcbiAgICBuYW1lcyA9IFtdO1xuICB9XG5cbiAgZGF0YSA9IHV0aWxzLmhleE9yQnVmZmVyKGRhdGEpO1xuICB2YXIgdmFsdWVzID0gbmV3IFJlc3VsdCgpO1xuXG4gIHZhciBvZmZzZXQgPSAwO1xuICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlLCBpbmRleCkge1xuICAgIHZhciBjb2RlciA9IGdldFBhcmFtQ29kZXIodHlwZSk7XG4gICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgIHZhciBkeW5hbWljT2Zmc2V0ID0gdWludDI1NkNvZGVyLmRlY29kZShkYXRhLCBvZmZzZXQpO1xuICAgICAgdmFyIHJlc3VsdCA9IGNvZGVyLmRlY29kZShkYXRhLCBkeW5hbWljT2Zmc2V0LnZhbHVlLnRvTnVtYmVyKCkpO1xuICAgICAgb2Zmc2V0ICs9IGR5bmFtaWNPZmZzZXQuY29uc3VtZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb2Rlci5kZWNvZGUoZGF0YSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSByZXN1bHQuY29uc3VtZWQ7XG4gICAgfVxuICAgIGlmICh1c2VOdW1iZXJlZFBhcmFtcykgdmFsdWVzW2luZGV4XSA9IHJlc3VsdC52YWx1ZTtcbiAgICBpZiAobmFtZXNbaW5kZXhdKSB7XG4gICAgICB2YWx1ZXNbbmFtZXNbaW5kZXhdXSA9IHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdmFsdWVzO1xufVxuXG4vLyBlbmNvZGUgbWV0aG9kIEFCSSBvYmplY3Qgd2l0aCB2YWx1ZXMgaW4gYW4gYXJyYXksIG91dHB1dCBieXRlY29kZVxuZnVuY3Rpb24gZW5jb2RlTWV0aG9kKG1ldGhvZCwgdmFsdWVzKSB7XG4gIHZhciBzaWduYXR1cmUgPSBtZXRob2QubmFtZSArICcoJyArIHV0aWxzLmdldEtleXMobWV0aG9kLmlucHV0cywgJ3R5cGUnKS5qb2luKCcsJykgKyAnKSc7XG4gIHZhciBzaWduYXR1cmVFbmNvZGVkID0gJzB4JyArIG5ldyBCdWZmZXIodXRpbHMua2VjY2FrMjU2KHNpZ25hdHVyZSksICdoZXgnKS5zbGljZSgwLCA0KS50b1N0cmluZygnaGV4Jyk7XG4gIHZhciBwYXJhbXNFbmNvZGVkID0gZW5jb2RlUGFyYW1zKHV0aWxzLmdldEtleXMobWV0aG9kLmlucHV0cywgJ3R5cGUnKSwgdmFsdWVzKS5zdWJzdHJpbmcoMik7XG5cbiAgcmV0dXJuICcnICsgc2lnbmF0dXJlRW5jb2RlZCArIHBhcmFtc0VuY29kZWQ7XG59XG5cbi8vIGRlY29kZSBtZXRob2QgZGF0YSBieXRlY29kZSwgZnJvbSBtZXRob2QgQUJJIG9iamVjdFxuZnVuY3Rpb24gZGVjb2RlTWV0aG9kKG1ldGhvZCwgZGF0YSkge1xuICB2YXIgb3V0cHV0TmFtZXMgPSB1dGlscy5nZXRLZXlzKG1ldGhvZC5vdXRwdXRzLCAnbmFtZScsIHRydWUpO1xuICB2YXIgb3V0cHV0VHlwZXMgPSB1dGlscy5nZXRLZXlzKG1ldGhvZC5vdXRwdXRzLCAndHlwZScpO1xuXG4gIHJldHVybiBkZWNvZGVQYXJhbXMob3V0cHV0TmFtZXMsIG91dHB1dFR5cGVzLCB1dGlscy5oZXhPckJ1ZmZlcihkYXRhKSk7XG59XG5cbi8vIGRlY29kZSBtZXRob2QgZGF0YSBieXRlY29kZSwgZnJvbSBtZXRob2QgQUJJIG9iamVjdFxuZnVuY3Rpb24gZW5jb2RlRXZlbnQoZXZlbnRPYmplY3QsIHZhbHVlcykge1xuICByZXR1cm4gZW5jb2RlTWV0aG9kKGV2ZW50T2JqZWN0LCB2YWx1ZXMpO1xufVxuXG5mdW5jdGlvbiBldmVudFNpZ25hdHVyZShldmVudE9iamVjdCkge1xuICB2YXIgc2lnbmF0dXJlID0gZXZlbnRPYmplY3QubmFtZSArICcoJyArIHV0aWxzLmdldEtleXMoZXZlbnRPYmplY3QuaW5wdXRzLCAndHlwZScpLmpvaW4oJywnKSArICcpJztcbiAgcmV0dXJuICcweCcgKyB1dGlscy5rZWNjYWsyNTYoc2lnbmF0dXJlKTtcbn1cblxuLy8gZGVjb2RlIG1ldGhvZCBkYXRhIGJ5dGVjb2RlLCBmcm9tIG1ldGhvZCBBQkkgb2JqZWN0XG5mdW5jdGlvbiBkZWNvZGVFdmVudChldmVudE9iamVjdCwgZGF0YSwgdG9waWNzKSB7XG4gIHZhciB1c2VOdW1iZXJlZFBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcblxuICB2YXIgbm9uSW5kZXhlZCA9IGV2ZW50T2JqZWN0LmlucHV0cy5maWx0ZXIoZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuICFpbnB1dC5pbmRleGVkO1xuICB9KTtcbiAgdmFyIG5vbkluZGV4ZWROYW1lcyA9IHV0aWxzLmdldEtleXMobm9uSW5kZXhlZCwgJ25hbWUnLCB0cnVlKTtcbiAgdmFyIG5vbkluZGV4ZWRUeXBlcyA9IHV0aWxzLmdldEtleXMobm9uSW5kZXhlZCwgJ3R5cGUnKTtcbiAgdmFyIGV2ZW50ID0gZGVjb2RlUGFyYW1zKG5vbkluZGV4ZWROYW1lcywgbm9uSW5kZXhlZFR5cGVzLCB1dGlscy5oZXhPckJ1ZmZlcihkYXRhKSwgdXNlTnVtYmVyZWRQYXJhbXMpO1xuICB2YXIgdG9waWNPZmZzZXQgPSBldmVudE9iamVjdC5hbm9ueW1vdXMgPyAwIDogMTtcbiAgZXZlbnRPYmplY3QuaW5wdXRzLmZpbHRlcihmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQuaW5kZXhlZDtcbiAgfSkubWFwKGZ1bmN0aW9uIChpbnB1dCwgaSkge1xuICAgIHZhciB0b3BpYyA9IG5ldyBCdWZmZXIodG9waWNzW2kgKyB0b3BpY09mZnNldF0uc2xpY2UoMiksICdoZXgnKTtcbiAgICB2YXIgY29kZXIgPSBnZXRQYXJhbUNvZGVyKGlucHV0LnR5cGUpO1xuICAgIGV2ZW50W2lucHV0Lm5hbWVdID0gY29kZXIuZGVjb2RlKHRvcGljLCAwKS52YWx1ZTtcbiAgfSk7XG4gIGV2ZW50Ll9ldmVudE5hbWUgPSBldmVudE9iamVjdC5uYW1lO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8vIERlY29kZSBhIHNwZWNpZmljIGxvZyBpdGVtIHdpdGggYSBzcGVjaWZpYyBldmVudCBhYmlcbmZ1bmN0aW9uIGRlY29kZUxvZ0l0ZW0oZXZlbnRPYmplY3QsIGxvZykge1xuICB2YXIgdXNlTnVtYmVyZWRQYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG5cbiAgaWYgKGV2ZW50T2JqZWN0ICYmIGxvZy50b3BpY3NbMF0gPT09IGV2ZW50U2lnbmF0dXJlKGV2ZW50T2JqZWN0KSkge1xuICAgIHJldHVybiBkZWNvZGVFdmVudChldmVudE9iamVjdCwgbG9nLmRhdGEsIGxvZy50b3BpY3MsIHVzZU51bWJlcmVkUGFyYW1zKTtcbiAgfVxufVxuXG4vLyBDcmVhdGUgYSBkZWNvZGVyIGZvciBhbGwgZXZlbnRzIGRlZmluZWQgaW4gYW4gYWJpLiBJdCByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkXG4vLyBvbiBhbiBhcnJheSBvZiBsb2cgZW50cmllcyBzdWNoIGFzIHJlY2VpdmVkIGZyb20gZ2V0TG9ncyBvciBnZXRUcmFuc2FjdGlvblJlY2VpcHQgYW5kIHBhcnNlc1xuLy8gYW55IG1hdGNoaW5nIGxvZyBlbnRyaWVzXG5mdW5jdGlvbiBsb2dEZWNvZGVyKGFiaSkge1xuICB2YXIgdXNlTnVtYmVyZWRQYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgdmFyIGV2ZW50TWFwID0ge307XG4gIGFiaS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS50eXBlID09PSAnZXZlbnQnO1xuICB9KS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBldmVudE1hcFtldmVudFNpZ25hdHVyZShpdGVtKV0gPSBpdGVtO1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChsb2dJdGVtcykge1xuICAgIHJldHVybiBsb2dJdGVtcy5tYXAoZnVuY3Rpb24gKGxvZykge1xuICAgICAgcmV0dXJuIGRlY29kZUxvZ0l0ZW0oZXZlbnRNYXBbbG9nLnRvcGljc1swXV0sIGxvZywgdXNlTnVtYmVyZWRQYXJhbXMpO1xuICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbmNvZGVQYXJhbXM6IGVuY29kZVBhcmFtcyxcbiAgZGVjb2RlUGFyYW1zOiBkZWNvZGVQYXJhbXMsXG4gIGVuY29kZU1ldGhvZDogZW5jb2RlTWV0aG9kLFxuICBkZWNvZGVNZXRob2Q6IGRlY29kZU1ldGhvZCxcbiAgZW5jb2RlRXZlbnQ6IGVuY29kZUV2ZW50LFxuICBkZWNvZGVFdmVudDogZGVjb2RlRXZlbnQsXG4gIGRlY29kZUxvZ0l0ZW06IGRlY29kZUxvZ0l0ZW0sXG4gIGxvZ0RlY29kZXI6IGxvZ0RlY29kZXIsXG4gIGV2ZW50U2lnbmF0dXJlOiBldmVudFNpZ25hdHVyZVxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfa2V5cyA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5cycpO1xuXG52YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHR4T2JqZWN0UHJvcGVydGllcyA9IFsnZnJvbScsICd0bycsICdkYXRhJywgJ3ZhbHVlJywgJ2dhc1ByaWNlJywgJ2dhcyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1RyYW5zYWN0aW9uT2JqZWN0O1xuXG5mdW5jdGlvbiBoYXNUcmFuc2FjdGlvbk9iamVjdChhcmdzKSB7XG4gIC8vIGJhZC9lbXB0eSBhcmdzOiBiYWRcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3MpIHx8IGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0QXJnID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAvLyBtaXNzaW5nIG9yIG5vbi1vYmplY3Q6IGJhZFxuICBpZiAoIWxhc3RBcmcpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBsYXN0QXJnICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBlbXB0eSBvYmplY3Q6IGdvb2RcbiAgaWYgKCgwLCBfa2V5czJbJ2RlZmF1bHQnXSkobGFzdEFyZykubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gdHhQYXJhbXMgb2JqZWN0OiBnb29kXG4gIHZhciBrZXlzID0gKDAsIF9rZXlzMlsnZGVmYXVsdCddKShsYXN0QXJnKTtcbiAgdmFyIGhhc01hdGNoaW5nS2V5cyA9IHR4T2JqZWN0UHJvcGVydGllcy5zb21lKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBrZXlzLmluY2x1ZGVzKHZhbHVlKTtcbiAgfSk7XG4gIGlmIChoYXNNYXRjaGluZ0tleXMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBubyBtYXRjaFxuICByZXR1cm4gZmFsc2U7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvcicpO1xuXG52YXIgX3JlZ2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlZ2VuZXJhdG9yKTtcblxudmFyIF9zdHJpbmdpZnkgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvanNvbi9zdHJpbmdpZnknKTtcblxudmFyIF9zdHJpbmdpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5naWZ5KTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yJyk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3luY1RvR2VuZXJhdG9yMik7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24nKTtcblxudmFyIF9hc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXNzaWduKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgYWJpID0gcmVxdWlyZSgnZXRoanMtYWJpJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbnZhciBFdGhGaWx0ZXIgPSByZXF1aXJlKCdldGhqcy1maWx0ZXInKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxudmFyIGdldEtleXMgPSByZXF1aXJlKCdldGhqcy11dGlsJykuZ2V0S2V5czsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxudmFyIGtlY2NhazI1NiA9IHJlcXVpcmUoJ2pzLXNoYTMnKS5rZWNjYWtfMjU2OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG52YXIgaGFzVHJhbnNhY3Rpb25PYmplY3QgPSByZXF1aXJlKCcuL2hhcy10eC1vYmplY3QnKTtcbnZhciBwcm9taXNlVG9DYWxsYmFjayA9IHJlcXVpcmUoJ3Byb21pc2UtdG8tY2FsbGJhY2snKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250cmFjdDtcblxuZnVuY3Rpb24gQ29udHJhY3QoKSB7XG4gIHZhciBwZXJmb3JtQ2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IzWydkZWZhdWx0J10pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yMlsnZGVmYXVsdCddLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShfcmVmKSB7XG4gICAgICB2YXIgbWV0aG9kT2JqZWN0ID0gX3JlZi5tZXRob2RPYmplY3QsXG4gICAgICAgICAgbWV0aG9kQXJncyA9IF9yZWYubWV0aG9kQXJncztcbiAgICAgIHZhciBxdWVyeU1ldGhvZCwgcHJvdmlkZWRUeE9iamVjdCwgbWV0aG9kVHhPYmplY3QsIHF1ZXJ5UmVzdWx0LCBkZWNvZGVkTWV0aG9kUmVzdWx0LCBkZWNvZGluZ0Vycm9yO1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcjJbJ2RlZmF1bHQnXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBxdWVyeU1ldGhvZCA9ICdjYWxsJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgICAgICAgICAgIHByb3ZpZGVkVHhPYmplY3QgPSB7fTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgICAgICAgICAgIGlmIChoYXNUcmFuc2FjdGlvbk9iamVjdChtZXRob2RBcmdzKSkgcHJvdmlkZWRUeE9iamVjdCA9IG1ldGhvZEFyZ3MucG9wKCk7XG4gICAgICAgICAgICAgIG1ldGhvZFR4T2JqZWN0ID0gKDAsIF9hc3NpZ24yWydkZWZhdWx0J10pKHt9LCBzZWxmLmRlZmF1bHRUeE9iamVjdCwgcHJvdmlkZWRUeE9iamVjdCwge1xuICAgICAgICAgICAgICAgIHRvOiBzZWxmLmFkZHJlc3NcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgbWV0aG9kVHhPYmplY3QuZGF0YSA9IGFiaS5lbmNvZGVNZXRob2QobWV0aG9kT2JqZWN0LCBtZXRob2RBcmdzKTtcblxuICAgICAgICAgICAgICBpZiAobWV0aG9kT2JqZWN0LmNvbnN0YW50ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5TWV0aG9kID0gJ3NlbmRUcmFuc2FjdGlvbic7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucXVlcnlbcXVlcnlNZXRob2RdKG1ldGhvZFR4T2JqZWN0KTtcblxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBxdWVyeVJlc3VsdCA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKCEocXVlcnlNZXRob2QgPT09ICdjYWxsJykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTA7XG4gICAgICAgICAgICAgIGRlY29kZWRNZXRob2RSZXN1bHQgPSBhYmkuZGVjb2RlTWV0aG9kKG1ldGhvZE9iamVjdCwgcXVlcnlSZXN1bHQpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCBkZWNvZGVkTWV0aG9kUmVzdWx0KTtcblxuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE1O1xuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0WydjYXRjaCddKDEwKTtcbiAgICAgICAgICAgICAgZGVjb2RpbmdFcnJvciA9IG5ldyBFcnJvcignW2V0aGpzLWNvbnRyYWN0XSB3aGlsZSBmb3JtYXR0aW5nIGluY29taW5nIHJhdyBjYWxsIGRhdGEgJyArICgwLCBfc3RyaW5naWZ5MlsnZGVmYXVsdCddKShxdWVyeVJlc3VsdCkgKyAnICcgKyBfY29udGV4dC50MCk7XG4gICAgICAgICAgICAgIHRocm93IGRlY29kaW5nRXJyb3I7XG5cbiAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoJ3JldHVybicsIHF1ZXJ5UmVzdWx0KTtcblxuICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzEwLCAxNV1dKTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gcGVyZm9ybUNhbGwoX3gyKSB7XG4gICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5hYmkgPSBvcHRzLmNvbnRyYWN0QUJJIHx8IFtdO1xuICBzZWxmLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgc2VsZi5hZGRyZXNzID0gb3B0cy5hZGRyZXNzIHx8ICcweCc7XG4gIHNlbGYuYnl0ZWNvZGUgPSBvcHRzLmNvbnRyYWN0Qnl0ZWNvZGUgfHwgJzB4JztcbiAgc2VsZi5kZWZhdWx0VHhPYmplY3QgPSBvcHRzLmNvbnRyYWN0RGVmYXVsdFR4T2JqZWN0IHx8IHt9O1xuICBzZWxmLmZpbHRlcnMgPSBuZXcgRXRoRmlsdGVyKHNlbGYucXVlcnkpO1xuXG4gIGdldENhbGxhYmxlTWV0aG9kc0Zyb21BQkkoc2VsZi5hYmkpLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZE9iamVjdCkge1xuICAgIGlmIChtZXRob2RPYmplY3QudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2VsZlttZXRob2RPYmplY3QubmFtZV0gPSBjcmVhdGVDb250cmFjdEZ1bmN0aW9uKG1ldGhvZE9iamVjdCk7XG4gICAgfSBlbHNlIGlmIChtZXRob2RPYmplY3QudHlwZSA9PT0gJ2V2ZW50Jykge1xuICAgICAgc2VsZlttZXRob2RPYmplY3QubmFtZV0gPSBjcmVhdGVDb250cmFjdEV2ZW50KG1ldGhvZE9iamVjdCk7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBjcmVhdGVDb250cmFjdEV2ZW50KG1ldGhvZE9iamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBjb250cmFjdEV2ZW50KCkge1xuICAgICAgdmFyIG1ldGhvZEFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgdmFyIGZpbHRlcklucHV0VHlwZXMgPSBnZXRLZXlzKG1ldGhvZE9iamVjdC5pbnB1dHMsICd0eXBlJywgZmFsc2UpO1xuICAgICAgdmFyIGZpbHRlclRvcGljID0gJzB4JyArIGtlY2NhazI1NihtZXRob2RPYmplY3QubmFtZSArICcoJyArIGZpbHRlcklucHV0VHlwZXMuam9pbignLCcpICsgJyknKTtcbiAgICAgIHZhciBmaWx0ZXJUb3BjaXMgPSBbZmlsdGVyVG9waWNdO1xuICAgICAgdmFyIGFyZ3NPYmplY3QgPSAoMCwgX2Fzc2lnbjJbJ2RlZmF1bHQnXSkoe30sIG1ldGhvZEFyZ3NbMF0pIHx8IHt9O1xuXG4gICAgICB2YXIgZGVmYXVsdEZpbHRlck9iamVjdCA9ICgwLCBfYXNzaWduMlsnZGVmYXVsdCddKSh7fSwgbWV0aG9kQXJnc1swXSB8fCB7fSwge1xuICAgICAgICB0bzogc2VsZi5hZGRyZXNzLFxuICAgICAgICB0b3BpY3M6IGZpbHRlclRvcGNpc1xuICAgICAgfSk7XG4gICAgICB2YXIgZmlsdGVyT3B0cyA9ICgwLCBfYXNzaWduMlsnZGVmYXVsdCddKSh7fSwgYXJnc09iamVjdCwge1xuICAgICAgICBkZWNvZGVyOiBmdW5jdGlvbiBkZWNvZGVyKGxvZ0RhdGEpIHtcbiAgICAgICAgICByZXR1cm4gYWJpLmRlY29kZUV2ZW50KG1ldGhvZE9iamVjdCwgbG9nRGF0YSwgZmlsdGVyVG9wY2lzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdEZpbHRlck9iamVjdDogZGVmYXVsdEZpbHRlck9iamVjdFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBuZXcgc2VsZi5maWx0ZXJzLkZpbHRlcihmaWx0ZXJPcHRzKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29udHJhY3RGdW5jdGlvbihtZXRob2RPYmplY3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY29udHJhY3RGdW5jdGlvbigpIHtcbiAgICAgIHZhciBtZXRob2RDYWxsYmFjayA9IHZvaWQgMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgdmFyIG1ldGhvZEFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGlmICh0eXBlb2YgbWV0aG9kQXJnc1ttZXRob2RBcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1ldGhvZENhbGxiYWNrID0gbWV0aG9kQXJncy5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb21pc2UgPSBwZXJmb3JtQ2FsbCh7IG1ldGhvZE9iamVjdDogbWV0aG9kT2JqZWN0LCBtZXRob2RBcmdzOiBtZXRob2RBcmdzIH0pO1xuXG4gICAgICBpZiAobWV0aG9kQ2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2VUb0NhbGxiYWNrKHByb21pc2UpKG1ldGhvZENhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDYWxsYWJsZU1ldGhvZHNGcm9tQUJJKGNvbnRyYWN0QUJJKSB7XG4gIHJldHVybiBjb250cmFjdEFCSS5maWx0ZXIoZnVuY3Rpb24gKGpzb24pIHtcbiAgICByZXR1cm4gKGpzb24udHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCBqc29uLnR5cGUgPT09ICdldmVudCcpICYmIGpzb24ubmFtZS5sZW5ndGggPiAwO1xuICB9KTtcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIgJiYgKCF0aGlzLl93cml0YWJsZVN0YXRlIHx8ICF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHtcbiAgICAgIHByb2Nlc3NOZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgcHJvY2Vzc05leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XG59OyIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICghcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gbmV4dFRpY2s7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3MubmV4dFRpY2s7XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgIH1yZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiAtMTtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSkgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCcucmVwZWF0KHApO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJy5yZXBlYXQocCArIDEpO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCcucmVwZWF0KHAgKyAyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBmb3IgZWFjaCBidWZmZXJlZCBieXRlIG9mIGEgKHBhcnRpYWwpXG4vLyBjaGFyYWN0ZXIgbmVlZHMgdG8gYmUgYWRkZWQgdG8gdGhlIG91dHB1dC5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnLnJlcGVhdCh0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCJ2YXIgcHJyID0gcmVxdWlyZSgncHJyJylcblxuZnVuY3Rpb24gaW5pdCAodHlwZSwgbWVzc2FnZSwgY2F1c2UpIHtcbiAgaWYgKCEhbWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSAhPSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlLm1lc3NhZ2UgfHwgbWVzc2FnZS5uYW1lXG4gIH1cbiAgcHJyKHRoaXMsIHtcbiAgICAgIHR5cGUgICAgOiB0eXBlXG4gICAgLCBuYW1lICAgIDogdHlwZVxuICAgICAgLy8gY2FuIGJlIHBhc3NlZCBqdXN0IGEgJ2NhdXNlJ1xuICAgICwgY2F1c2UgICA6IHR5cGVvZiBtZXNzYWdlICE9ICdzdHJpbmcnID8gbWVzc2FnZSA6IGNhdXNlXG4gICAgLCBtZXNzYWdlIDogbWVzc2FnZVxuICB9LCAnZXdyJylcbn1cblxuLy8gZ2VuZXJpYyBwcm90b3R5cGUsIG5vdCBpbnRlbmRlZCB0byBiZSBhY3R1YWxseSB1c2VkIC0gaGVscGZ1bCBmb3IgYGluc3RhbmNlb2ZgXG5mdW5jdGlvbiBDdXN0b21FcnJvciAobWVzc2FnZSwgY2F1c2UpIHtcbiAgRXJyb3IuY2FsbCh0aGlzKVxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3RvcilcbiAgaW5pdC5jYWxsKHRoaXMsICdDdXN0b21FcnJvcicsIG1lc3NhZ2UsIGNhdXNlKVxufVxuXG5DdXN0b21FcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKVxuXG5mdW5jdGlvbiBjcmVhdGVFcnJvciAoZXJybm8sIHR5cGUsIHByb3RvKSB7XG4gIHZhciBlcnIgPSBmdW5jdGlvbiAobWVzc2FnZSwgY2F1c2UpIHtcbiAgICBpbml0LmNhbGwodGhpcywgdHlwZSwgbWVzc2FnZSwgY2F1c2UpXG4gICAgLy9UT0RPOiB0aGUgc3BlY2lmaWNpdHkgaGVyZSBpcyBzdHVwaWQsIGVycm5vIHNob3VsZCBiZSBhdmFpbGFibGUgZXZlcnl3aGVyZVxuICAgIGlmICh0eXBlID09ICdGaWxlc3lzdGVtRXJyb3InKSB7XG4gICAgICB0aGlzLmNvZGUgICAgPSB0aGlzLmNhdXNlLmNvZGVcbiAgICAgIHRoaXMucGF0aCAgICA9IHRoaXMuY2F1c2UucGF0aFxuICAgICAgdGhpcy5lcnJubyAgID0gdGhpcy5jYXVzZS5lcnJub1xuICAgICAgdGhpcy5tZXNzYWdlID1cbiAgICAgICAgKGVycm5vLmVycm5vW3RoaXMuY2F1c2UuZXJybm9dXG4gICAgICAgICAgPyBlcnJuby5lcnJub1t0aGlzLmNhdXNlLmVycm5vXS5kZXNjcmlwdGlvblxuICAgICAgICAgIDogdGhpcy5jYXVzZS5tZXNzYWdlKVxuICAgICAgICArICh0aGlzLmNhdXNlLnBhdGggPyAnIFsnICsgdGhpcy5jYXVzZS5wYXRoICsgJ10nIDogJycpXG4gICAgfVxuICAgIEVycm9yLmNhbGwodGhpcylcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBlcnIpXG4gIH1cbiAgZXJyLnByb3RvdHlwZSA9ICEhcHJvdG8gPyBuZXcgcHJvdG8oKSA6IG5ldyBDdXN0b21FcnJvcigpXG4gIHJldHVybiBlcnJcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXJybm8pIHtcbiAgdmFyIGNlID0gZnVuY3Rpb24gKHR5cGUsIHByb3RvKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVycm9yKGVycm5vLCB0eXBlLCBwcm90bylcbiAgfVxuICByZXR1cm4ge1xuICAgICAgQ3VzdG9tRXJyb3IgICAgIDogQ3VzdG9tRXJyb3JcbiAgICAsIEZpbGVzeXN0ZW1FcnJvciA6IGNlKCdGaWxlc3lzdGVtRXJyb3InKVxuICAgICwgY3JlYXRlRXJyb3IgICAgIDogY2VcbiAgfVxufVxuIiwiLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9lbmQtb2Ytc3RyZWFtIHdpdGhcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2Rlcy5FUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRTtcblxuZnVuY3Rpb24gb25jZShjYWxsYmFjaykge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgIGNhbGxlZCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGVvcyhzdHJlYW0sIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVvcyhzdHJlYW0sIG51bGwsIG9wdHMpO1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICB2YXIgcmVhZGFibGUgPSBvcHRzLnJlYWRhYmxlIHx8IG9wdHMucmVhZGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS5yZWFkYWJsZTtcbiAgdmFyIHdyaXRhYmxlID0gb3B0cy53cml0YWJsZSB8fCBvcHRzLndyaXRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ud3JpdGFibGU7XG5cbiAgdmFyIG9ubGVnYWN5ZmluaXNoID0gZnVuY3Rpb24gb25sZWdhY3lmaW5pc2goKSB7XG4gICAgaWYgKCFzdHJlYW0ud3JpdGFibGUpIG9uZmluaXNoKCk7XG4gIH07XG5cbiAgdmFyIHdyaXRhYmxlRW5kZWQgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGUgJiYgc3RyZWFtLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkO1xuXG4gIHZhciBvbmZpbmlzaCA9IGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIHdyaXRhYmxlID0gZmFsc2U7XG4gICAgd3JpdGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCFyZWFkYWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuXG4gIHZhciByZWFkYWJsZUVuZGVkID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlICYmIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkO1xuXG4gIHZhciBvbmVuZCA9IGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIHJlYWRhYmxlID0gZmFsc2U7XG4gICAgcmVhZGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCF3cml0YWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuXG4gIHZhciBvbmVycm9yID0gZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgfTtcblxuICB2YXIgb25jbG9zZSA9IGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgdmFyIGVycjtcblxuICAgIGlmIChyZWFkYWJsZSAmJiAhcmVhZGFibGVFbmRlZCkge1xuICAgICAgaWYgKCFzdHJlYW0uX3JlYWRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfVxuXG4gICAgaWYgKHdyaXRhYmxlICYmICF3cml0YWJsZUVuZGVkKSB7XG4gICAgICBpZiAoIXN0cmVhbS5fd3JpdGFibGVTdGF0ZSB8fCAhc3RyZWFtLl93cml0YWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG9ucmVxdWVzdCA9IGZ1bmN0aW9uIG9ucmVxdWVzdCgpIHtcbiAgICBzdHJlYW0ucmVxLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gIH07XG5cbiAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XG4gICAgc3RyZWFtLm9uKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Fib3J0Jywgb25jbG9zZSk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIG9ucmVxdWVzdCgpO2Vsc2Ugc3RyZWFtLm9uKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcbiAgfSBlbHNlIGlmICh3cml0YWJsZSAmJiAhc3RyZWFtLl93cml0YWJsZVN0YXRlKSB7XG4gICAgLy8gbGVnYWN5IHN0cmVhbXNcbiAgICBzdHJlYW0ub24oJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICB9XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBvbmVuZCk7XG4gIHN0cmVhbS5vbignZmluaXNoJywgb25maW5pc2gpO1xuICBpZiAob3B0cy5lcnJvciAhPT0gZmFsc2UpIHN0cmVhbS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgc3RyZWFtLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY29tcGxldGUnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIG9uY2xvc2UpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIHN0cmVhbS5yZXEucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW9zOyIsIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvcHVtcCB3aXRoXG4vLyBwZXJtaXNzaW9uIGZyb20gdGhlIGF1dGhvciwgTWF0aGlhcyBCdXVzIChAbWFmaW50b3NoKS5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVvcztcblxuZnVuY3Rpb24gb25jZShjYWxsYmFjaykge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgY2FsbGJhY2suYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfTUlTU0lOR19BUkdTID0gX3JlcXVpcmUkY29kZXMuRVJSX01JU1NJTkdfQVJHUyxcbiAgICBFUlJfU1RSRUFNX0RFU1RST1lFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fREVTVFJPWUVEO1xuXG5mdW5jdGlvbiBub29wKGVycikge1xuICAvLyBSZXRocm93IHRoZSBlcnJvciBpZiBpdCBleGlzdHMgdG8gYXZvaWQgc3dhbGxvd2luZyBpdFxuICBpZiAoZXJyKSB0aHJvdyBlcnI7XG59XG5cbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKTtcbiAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGNsb3NlZCA9IHRydWU7XG4gIH0pO1xuICBpZiAoZW9zID09PSB1bmRlZmluZWQpIGVvcyA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xuICBlb3Moc3RyZWFtLCB7XG4gICAgcmVhZGFibGU6IHJlYWRpbmcsXG4gICAgd3JpdGFibGU6IHdyaXRpbmdcbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIGNsb3NlZCA9IHRydWU7XG4gICAgY2FsbGJhY2soKTtcbiAgfSk7XG4gIHZhciBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoY2xvc2VkKSByZXR1cm47XG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGRlc3Ryb3llZCA9IHRydWU7IC8vIHJlcXVlc3QuZGVzdHJveSBqdXN0IGRvIC5lbmQgLSAuYWJvcnQgaXMgd2hhdCB3ZSB3YW50XG5cbiAgICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHJldHVybiBzdHJlYW0uYWJvcnQoKTtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSByZXR1cm4gc3RyZWFtLmRlc3Ryb3koKTtcbiAgICBjYWxsYmFjayhlcnIgfHwgbmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCdwaXBlJykpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjYWxsKGZuKSB7XG4gIGZuKCk7XG59XG5cbmZ1bmN0aW9uIHBpcGUoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIGZyb20ucGlwZSh0byk7XG59XG5cbmZ1bmN0aW9uIHBvcENhbGxiYWNrKHN0cmVhbXMpIHtcbiAgaWYgKCFzdHJlYW1zLmxlbmd0aCkgcmV0dXJuIG5vb3A7XG4gIGlmICh0eXBlb2Ygc3RyZWFtc1tzdHJlYW1zLmxlbmd0aCAtIDFdICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gbm9vcDtcbiAgcmV0dXJuIHN0cmVhbXMucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHBpcGVsaW5lKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3RyZWFtcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzdHJlYW1zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIGNhbGxiYWNrID0gcG9wQ2FsbGJhY2soc3RyZWFtcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHN0cmVhbXNbMF0pKSBzdHJlYW1zID0gc3RyZWFtc1swXTtcblxuICBpZiAoc3RyZWFtcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ3N0cmVhbXMnKTtcbiAgfVxuXG4gIHZhciBlcnJvcjtcbiAgdmFyIGRlc3Ryb3lzID0gc3RyZWFtcy5tYXAoZnVuY3Rpb24gKHN0cmVhbSwgaSkge1xuICAgIHZhciByZWFkaW5nID0gaSA8IHN0cmVhbXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgd3JpdGluZyA9IGkgPiAwO1xuICAgIHJldHVybiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcbiAgICAgIGlmIChlcnIpIGRlc3Ryb3lzLmZvckVhY2goY2FsbCk7XG4gICAgICBpZiAocmVhZGluZykgcmV0dXJuO1xuICAgICAgZGVzdHJveXMuZm9yRWFjaChjYWxsKTtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBzdHJlYW1zLnJlZHVjZShwaXBlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwaXBlbGluZTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG4ndXNlIHN0cmljdCc7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG5cbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIEFsbG93IHRoZSBrZXlzIGFycmF5IHRvIGJlIEdDJ2VkLlxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcblxuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG4gICAgICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbiAgICB9XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pOyAvLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5cbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBJZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCwgdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjsgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cblxuICBwcm9jZXNzLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcbi8qIDxyZXBsYWNlbWVudD4gKi9cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufSAvLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuXG5cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcblxuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgICBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9DQU5OT1RfUElQRSxcbiAgICBFUlJfU1RSRUFNX0RFU1RST1lFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fREVTVFJPWUVELFxuICAgIEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX05VTExfVkFMVUVTLFxuICAgIEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQsXG4gICAgRVJSX1VOS05PV05fRU5DT0RJTkcgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVU5LTk9XTl9FTkNPRElORztcblxudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0sXG4gIC8vIGUuZy4gb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGUgdnMuIG9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlLCBldGMuXG5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cblxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTsgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpOyAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG5cbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlOyAvLyBkcmFpbiBldmVudCBmbGFnLlxuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7IC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG5cbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTsgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTsgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG5cbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlOyAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOyAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlOyAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOyAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuXG4gIHRoaXMubGVuZ3RoID0gMDsgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cblxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTsgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuXG4gIHRoaXMuY29ya2VkID0gMDsgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG5cbiAgdGhpcy5zeW5jID0gdHJ1ZTsgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cblxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTsgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07IC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuXG5cbiAgdGhpcy53cml0ZWNiID0gbnVsbDsgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7IC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuXG4gIHRoaXMucGVuZGluZ2NiID0gMDsgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTsgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlOyAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOyAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2ZpbmlzaCcgKGFuZCBwb3RlbnRpYWxseSAnZW5kJylcblxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95OyAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwOyAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cblxuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcblxuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gd3JpdGFibGVTdGF0ZUJ1ZmZlckdldHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7IC8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxuXG5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIHJlYWxIYXNJbnN0YW5jZShvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpOyAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFdyaXRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG5cbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgaWYgKCFpc0R1cGxleCAmJiAhcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpKSByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOyAvLyBsZWdhY3kuXG5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufSAvLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5cblxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFKCkpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCgpOyAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuXG4gIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG59IC8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cblxuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgZXI7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInXSwgY2h1bmspO1xuICB9XG5cbiAgaWYgKGVyKSB7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcbiAgaWYgKHN0YXRlLmVuZGluZykgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IEVSUl9VTktOT1dOX0VOQ09ESU5HKGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG5cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTsgLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cblxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG5cbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cblxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrOyAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cblxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHN0YXRlLm9ud3JpdGUobmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCd3cml0ZScpKTtlbHNlIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpOyAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcblxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRVJSX01VTFRJUExFX0NBTExCQUNLKCk7XG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKSB8fCBzdHJlYW0uZGVzdHJveWVkO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn0gLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5cblxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufSAvLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuXG5cbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcblxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG5cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpOyAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tOyAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3dyaXRlKCknKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpOyAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH0gLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuXG5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuXG4gICAgaWYgKGVycikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpO1xuICAgIH1cblxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJyAmJiAhc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG5cbiAgICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAgIC8vIGlmIHRoZSByZWFkYWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICAgIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgICAgICAgaWYgKCFyU3RhdGUgfHwgclN0YXRlLmF1dG9EZXN0cm95ICYmIHJTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcblxuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3MubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG5cbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH0gLy8gcmV1c2UgdGhlIGZyZWUgY29ya1JlcS5cblxuXG4gIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcsXG4gICAgRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wID0gX3JlcXVpcmUkY29kZXMuRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmIChjYiA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuICBjYihlcik7XG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcblxuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTsgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfSAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG5cblxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07IC8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfdHJhbnNmb3JtKCknKSk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuXG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTsgLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcblxuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTsgLy8gVE9ETyhCcmlkZ2VBUik6IFdyaXRlIGEgdGVzdCBmb3IgdGhlc2UgdHdvIGVycm9yIGNhc2VzXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG5cbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAoKTtcbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORygpO1xuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gRUVsaXN0ZW5lckNvdW50KGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIGRlYnVnO1xuXG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdCcpO1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRixcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UOyAvLyBMYXp5IGxvYWRlZCB0byBpbXByb3ZlIHRoZSBzdGFydHVwIHBlcmZvcm1hbmNlLlxuXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjtcbnZhciBmcm9tO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pOyAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcblxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTsgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cblxuICB0aGlzLnN5bmMgPSB0cnVlOyAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cblxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHRoaXMucGF1c2VkID0gdHJ1ZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdlbmQnIChhbmQgcG90ZW50aWFsbHkgJ2ZpbmlzaCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcblxuICB0aGlzLmF3YWl0RHJhaW4gPSAwOyAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG5cbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcblxuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpOyAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBSZWFkYWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7IC8vIGxlZ2FjeVxuXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59OyAvLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuXG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07IC8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIGRlYnVnKCdyZWFkYWJsZUFkZENodW5rJywgY2h1bmspO1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG5cbiAgICBpZiAoZXIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UKCkpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GKCkpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gLy8gV2UgY2FuIHB1c2ggbW9yZSBkYXRhIGlmIHdlIGFyZSBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyay5cbiAgLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWUgbW9yZSBieXRlcy5cbiAgLy8gVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCwgc3VjaCBhcyB0aGUgcmVwbC5cblxuXG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuXG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuXG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJywgJ1VpbnQ4QXJyYXknXSwgY2h1bmspO1xuICB9XG5cbiAgcmV0dXJuIGVyO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB2YXIgZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IGRlY29kZXI7IC8vIElmIHNldEVuY29kaW5nKG51bGwpLCBkZWNvZGVyLmVuY29kaW5nIGVxdWFscyB1dGY4XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2Rlci5lbmNvZGluZzsgLy8gSXRlcmF0ZSBvdmVyIGN1cnJlbnQgYnVmZmVyIHRvIGNvbnZlcnQgYWxyZWFkeSBzdG9yZWQgQnVmZmVyczpcblxuICB2YXIgcCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmhlYWQ7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgd2hpbGUgKHAgIT09IG51bGwpIHtcbiAgICBjb250ZW50ICs9IGRlY29kZXIud3JpdGUocC5kYXRhKTtcbiAgICBwID0gcC5uZXh0O1xuICB9XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuY2xlYXIoKTtcblxuICBpZiAoY29udGVudCAhPT0gJycpIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLnB1c2goY29udGVudCk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDFHQlxuXG5cbnZhciBNQVhfSFdNID0gMHg0MDAwMDAwMDtcblxuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgLy8gVE9ETyhyb25hZyk6IFRocm93IEVSUl9WQUxVRV9PVVRfT0ZfUkFOR0UuXG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuXG4gIHJldHVybiBuO1xufSAvLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cblxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuXG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9IC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuXG5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47IC8vIERvbid0IGhhdmUgZW5vdWdoXG5cbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufSAvLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlOyAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmICgoc3RhdGUuaGlnaFdhdGVyTWFyayAhPT0gMCA/IHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIDogc3RhdGUubGVuZ3RoID4gMCkgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpOyAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG5cblxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7IC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH0gLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuXG5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTsgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cblxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcblxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG5cbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7IC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ29uRW9mQ2h1bmsnKTtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuXG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUuc3luYykge1xuICAgIC8vIGlmIHdlIGFyZSBzeW5jLCB3YWl0IHVudGlsIG5leHQgdGljayB0byBlbWl0IHRoZSBkYXRhLlxuICAgIC8vIE90aGVyd2lzZSB3ZSByaXNrIGVtaXR0aW5nIGRhdGEgaW4gdGhlIGZsb3coKVxuICAgIC8vIHRoZSByZWFkYWJsZSBjb2RlIHRyaWdnZXJzIGR1cmluZyBhIHJlYWQoKSBjYWxsXG4gICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9XG4gIH1cbn0gLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cblxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLm5lZWRSZWFkYWJsZSwgc3RhdGUuZW1pdHRlZFJlYWRhYmxlKTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlXycsIHN0YXRlLmRlc3Ryb3llZCwgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG5cbiAgaWYgKCFzdGF0ZS5kZXN0cm95ZWQgJiYgKHN0YXRlLmxlbmd0aCB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgfSAvLyBUaGUgc3RyZWFtIG5lZWRzIGFub3RoZXIgcmVhZGFibGUgZXZlbnQgaWZcbiAgLy8gMS4gSXQgaXMgbm90IGZsb3dpbmcsIGFzIHRoZSBmbG93IG1lY2hhbmlzbSB3aWxsIHRha2VcbiAgLy8gICAgY2FyZSBvZiBpdC5cbiAgLy8gMi4gSXQgaXMgbm90IGVuZGVkLlxuICAvLyAzLiBJdCBpcyBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyaywgc28gd2UgY2FuIHNjaGVkdWxlXG4gIC8vICAgIGFub3RoZXIgcmVhZGFibGUgbGF0ZXIuXG5cblxuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIGZsb3coc3RyZWFtKTtcbn0gLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICAvLyBBdHRlbXB0IHRvIHJlYWQgbW9yZSBkYXRhIGlmIHdlIHNob3VsZC5cbiAgLy9cbiAgLy8gVGhlIGNvbmRpdGlvbnMgZm9yIHJlYWRpbmcgbW9yZSBkYXRhIGFyZSAob25lIG9mKTpcbiAgLy8gLSBOb3QgZW5vdWdoIGRhdGEgYnVmZmVyZWQgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspLiBUaGUgbG9vcFxuICAvLyAgIGlzIHJlc3BvbnNpYmxlIGZvciBmaWxsaW5nIHRoZSBidWZmZXIgd2l0aCBlbm91Z2ggZGF0YSBpZiBzdWNoIGRhdGFcbiAgLy8gICBpcyBhdmFpbGFibGUuIElmIGhpZ2hXYXRlck1hcmsgaXMgMCBhbmQgd2UgYXJlIG5vdCBpbiB0aGUgZmxvd2luZyBtb2RlXG4gIC8vICAgd2Ugc2hvdWxkIF9ub3RfIGF0dGVtcHQgdG8gYnVmZmVyIGFueSBleHRyYSBkYXRhLiBXZSdsbCBnZXQgbW9yZSBkYXRhXG4gIC8vICAgd2hlbiB0aGUgc3RyZWFtIGNvbnN1bWVyIGNhbGxzIHJlYWQoKSBpbnN0ZWFkLlxuICAvLyAtIE5vIGRhdGEgaW4gdGhlIGJ1ZmZlciwgYW5kIHRoZSBzdHJlYW0gaXMgaW4gZmxvd2luZyBtb2RlLiBJbiB0aGlzIG1vZGVcbiAgLy8gICB0aGUgbG9vcCBiZWxvdyBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgcmVhZCgpIGlzIGNhbGxlZC4gRmFpbGluZyB0b1xuICAvLyAgIGNhbGwgcmVhZCBoZXJlIHdvdWxkIGFib3J0IHRoZSBmbG93IGFuZCB0aGVyZSdzIG5vIG90aGVyIG1lY2hhbmlzbSBmb3JcbiAgLy8gICBjb250aW51aW5nIHRoZSBmbG93IGlmIHRoZSBzdHJlYW0gY29uc3VtZXIgaGFzIGp1c3Qgc3Vic2NyaWJlZCB0byB0aGVcbiAgLy8gICAnZGF0YScgZXZlbnQuXG4gIC8vXG4gIC8vIEluIGFkZGl0aW9uIHRvIHRoZSBhYm92ZSBjb25kaXRpb25zIHRvIGtlZXAgcmVhZGluZyBkYXRhLCB0aGUgZm9sbG93aW5nXG4gIC8vIGNvbmRpdGlvbnMgcHJldmVudCB0aGUgZGF0YSBmcm9tIGJlaW5nIHJlYWQ6XG4gIC8vIC0gVGhlIHN0cmVhbSBoYXMgZW5kZWQgKHN0YXRlLmVuZGVkKS5cbiAgLy8gLSBUaGVyZSBpcyBhbHJlYWR5IGEgcGVuZGluZyAncmVhZCcgb3BlcmF0aW9uIChzdGF0ZS5yZWFkaW5nKS4gVGhpcyBpcyBhXG4gIC8vICAgY2FzZSB3aGVyZSB0aGUgdGhlIHN0cmVhbSBoYXMgY2FsbGVkIHRoZSBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIF9yZWFkKClcbiAgLy8gICBtZXRob2QsIGJ1dCB0aGV5IGFyZSBwcm9jZXNzaW5nIHRoZSBjYWxsIGFzeW5jaHJvbm91c2x5IGFuZCBoYXZlIF9ub3RfXG4gIC8vICAgY2FsbGVkIHB1c2goKSB3aXRoIG5ldyBkYXRhLiBJbiB0aGlzIGNhc2Ugd2Ugc2tpcCBwZXJmb3JtaW5nIG1vcmVcbiAgLy8gICByZWFkKClzLiBUaGUgZXhlY3V0aW9uIGVuZHMgaW4gdGhpcyBtZXRob2QgYWdhaW4gYWZ0ZXIgdGhlIF9yZWFkKCkgZW5kc1xuICAvLyAgIHVwIGNhbGxpbmcgcHVzaCgpIHdpdGggbW9yZSBkYXRhLlxuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwKSkge1xuICAgIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKSAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufSAvLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ19yZWFkKCknKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuXG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG5cbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfSAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cblxuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTsgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBjbGVhbmVkVXAgPSB0cnVlOyAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGRlYnVnKCdkZXN0LndyaXRlJywgcmV0KTtcblxuICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgfVxuXG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH0gLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cblxuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGVycm9yT3JEZXN0cm95KGRlc3QsIGVyKTtcbiAgfSAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG5cblxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7IC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cblxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuXG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfSAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuXG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTsgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwaXBlT25EcmFpbkZ1bmN0aW9uUmVzdWx0KCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7XG4gICAgaGFzVW5waXBlZDogZmFsc2VcbiAgfTsgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpczsgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzOyAvLyBnb3QgYSBtYXRjaC5cblxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHtcbiAgICAgICAgaGFzVW5waXBlZDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG5cblxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblxuXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIHVwZGF0ZSByZWFkYWJsZUxpc3RlbmluZyBzbyB0aGF0IHJlc3VtZSgpIG1heSBiZSBhIG5vLW9wXG4gICAgLy8gYSBmZXcgbGluZXMgZG93bi4gVGhpcyBpcyBuZWVkZWQgdG8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScpLlxuICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdGhpcy5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDsgLy8gVHJ5IHN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBkZWJ1Zygnb24gcmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLnJlYWRpbmcpO1xuXG4gICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChldikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgfHwgZXYgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVSZWFkYWJsZUxpc3RlbmluZyhzZWxmKSB7XG4gIHZhciBzdGF0ZSA9IHNlbGYuX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc2VsZi5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDtcblxuICBpZiAoc3RhdGUucmVzdW1lU2NoZWR1bGVkICYmICFzdGF0ZS5wYXVzZWQpIHtcbiAgICAvLyBmbG93aW5nIG5lZWRzIHRvIGJlIHNldCB0byB0cnVlIG5vdywgb3RoZXJ3aXNlXG4gICAgLy8gdGhlIHVwY29taW5nIHJlc3VtZSB3aWxsIG5vdCBmbG93LlxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlOyAvLyBjcnVkZSB3YXkgdG8gY2hlY2sgaWYgd2Ugc2hvdWxkIHJlc3VtZVxuICB9IGVsc2UgaWYgKHNlbGYubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCkge1xuICAgIHNlbGYucmVzdW1lKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufSAvLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7IC8vIHdlIGZsb3cgb25seSBpZiB0aGVyZSBpcyBubyBvbmUgbGlzdGVuaW5nXG4gICAgLy8gZm9yIHJlYWRhYmxlLCBidXQgd2Ugc3RpbGwgaGF2ZSB0byBjYWxsXG4gICAgLy8gcmVzdW1lKClcblxuICAgIHN0YXRlLmZsb3dpbmcgPSAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmc7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuXG4gIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1ZygncmVzdW1lJywgc3RhdGUucmVhZGluZyk7XG5cbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUucGF1c2VkID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG5cbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge1xuICAgIDtcbiAgfVxufSAvLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcblxuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7IC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pOyAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gbWV0aG9kV3JhcChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1ldGhvZFdyYXBSZXR1cm5GdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH0gLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuXG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfSAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuXG5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcblxuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3InKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpO1xuICB9O1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlRmxvd2luZycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gc3RhdGU7XG4gICAgfVxuICB9XG59KTsgLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTsgLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5maXJzdCgpO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbnN1bWUobiwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlJywgc3RhdGUuZW5kRW1pdHRlZCk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZU5UJywgc3RhdGUuZW5kRW1pdHRlZCwgc3RhdGUubGVuZ3RoKTsgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcblxuICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgLy8gaWYgdGhlIHdyaXRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG5cbiAgICAgIGlmICghd1N0YXRlIHx8IHdTdGF0ZS5hdXRvRGVzdHJveSAmJiB3U3RhdGUuZmluaXNoZWQpIHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVhZGFibGUuZnJvbSA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgb3B0cykge1xuICAgIGlmIChmcm9tID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZyb20gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZnJvbScpO1xuICAgIH1cblxuICAgIHJldHVybiBmcm9tKFJlYWRhYmxlLCBpdGVyYWJsZSwgb3B0cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBETEw7XG4vLyBTaW1wbGUgZG91Ymx5IGxpbmtlZCBsaXN0IChodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VibHlfbGlua2VkX2xpc3QpIGltcGxlbWVudGF0aW9uXG4vLyB1c2VkIGZvciBxdWV1ZXMuIFRoaXMgaW1wbGVtZW50YXRpb24gYXNzdW1lcyB0aGF0IHRoZSBub2RlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyIGNhbiBiZSBtb2RpZmllZFxuLy8gdG8gYWRqdXN0IHRoZSBuZXh0IGFuZCBsYXN0IHByb3BlcnRpZXMuIFdlIGltcGxlbWVudCBvbmx5IHRoZSBtaW5pbWFsIGZ1bmN0aW9uYWxpdHlcbi8vIGZvciBxdWV1ZSBzdXBwb3J0LlxuZnVuY3Rpb24gRExMKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBzZXRJbml0aWFsKGRsbCwgbm9kZSkge1xuICAgIGRsbC5sZW5ndGggPSAxO1xuICAgIGRsbC5oZWFkID0gZGxsLnRhaWwgPSBub2RlO1xufVxuXG5ETEwucHJvdG90eXBlLnJlbW92ZUxpbmsgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChub2RlLnByZXYpIG5vZGUucHJldi5uZXh0ID0gbm9kZS5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gbm9kZS5uZXh0O1xuICAgIGlmIChub2RlLm5leHQpIG5vZGUubmV4dC5wcmV2ID0gbm9kZS5wcmV2O2Vsc2UgdGhpcy50YWlsID0gbm9kZS5wcmV2O1xuXG4gICAgbm9kZS5wcmV2ID0gbm9kZS5uZXh0ID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCAtPSAxO1xuICAgIHJldHVybiBub2RlO1xufTtcblxuRExMLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB3aGlsZSAodGhpcy5oZWFkKSB0aGlzLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5ETEwucHJvdG90eXBlLmluc2VydEFmdGVyID0gZnVuY3Rpb24gKG5vZGUsIG5ld05vZGUpIHtcbiAgICBuZXdOb2RlLnByZXYgPSBub2RlO1xuICAgIG5ld05vZGUubmV4dCA9IG5vZGUubmV4dDtcbiAgICBpZiAobm9kZS5uZXh0KSBub2RlLm5leHQucHJldiA9IG5ld05vZGU7ZWxzZSB0aGlzLnRhaWwgPSBuZXdOb2RlO1xuICAgIG5vZGUubmV4dCA9IG5ld05vZGU7XG4gICAgdGhpcy5sZW5ndGggKz0gMTtcbn07XG5cbkRMTC5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKG5vZGUsIG5ld05vZGUpIHtcbiAgICBuZXdOb2RlLnByZXYgPSBub2RlLnByZXY7XG4gICAgbmV3Tm9kZS5uZXh0ID0gbm9kZTtcbiAgICBpZiAobm9kZS5wcmV2KSBub2RlLnByZXYubmV4dCA9IG5ld05vZGU7ZWxzZSB0aGlzLmhlYWQgPSBuZXdOb2RlO1xuICAgIG5vZGUucHJldiA9IG5ld05vZGU7XG4gICAgdGhpcy5sZW5ndGggKz0gMTtcbn07XG5cbkRMTC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKHRoaXMuaGVhZCkgdGhpcy5pbnNlcnRCZWZvcmUodGhpcy5oZWFkLCBub2RlKTtlbHNlIHNldEluaXRpYWwodGhpcywgbm9kZSk7XG59O1xuXG5ETEwucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmICh0aGlzLnRhaWwpIHRoaXMuaW5zZXJ0QWZ0ZXIodGhpcy50YWlsLCBub2RlKTtlbHNlIHNldEluaXRpYWwodGhpcywgbm9kZSk7XG59O1xuXG5ETEwucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmhlYWQgJiYgdGhpcy5yZW1vdmVMaW5rKHRoaXMuaGVhZCk7XG59O1xuXG5ETEwucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50YWlsICYmIHRoaXMucmVtb3ZlTGluayh0aGlzLnRhaWwpO1xufTtcblxuRExMLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnIgPSBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgdmFyIGN1cnIgPSB0aGlzLmhlYWQ7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgdGhpcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGFycltpZHhdID0gY3Vyci5kYXRhO1xuICAgICAgICBjdXJyID0gY3Vyci5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufTtcblxuRExMLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAodGVzdEZuKSB7XG4gICAgdmFyIGN1cnIgPSB0aGlzLmhlYWQ7XG4gICAgd2hpbGUgKCEhY3Vycikge1xuICAgICAgICB2YXIgbmV4dCA9IGN1cnIubmV4dDtcbiAgICAgICAgaWYgKHRlc3RGbihjdXJyKSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVMaW5rKGN1cnIpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnIgPSBuZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIi8qIEBmbG93ICovXG4ndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBgVGhpcyBpcyBhIHJlcG9zaXRvcnkgb2YgSVBMRCBvYmplY3RzLiBFYWNoIElQTEQgb2JqZWN0IGlzIGluIGEgc2luZ2xlIGZpbGUsXG5uYW1lZCA8YmFzZTMyIGVuY29kaW5nIG9mIGNpZD4uZGF0YS4gV2hlcmUgPGJhc2UzMiBlbmNvZGluZyBvZiBjaWQ+IGlzIHRoZVxuXCJiYXNlMzJcIiBlbmNvZGluZyBvZiB0aGUgQ0lEIChhcyBzcGVjaWZpZWQgaW5cbmh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvbXVsdGliYXNlKSB3aXRob3V0IHRoZSAnQicgcHJlZml4LlxuQWxsIHRoZSBvYmplY3QgZmlsZXMgYXJlIHBsYWNlZCBpbiBhIHRyZWUgb2YgZGlyZWN0b3JpZXMsIGJhc2VkIG9uIGFcbmZ1bmN0aW9uIG9mIHRoZSBDSUQuIFRoaXMgaXMgYSBmb3JtIG9mIHNoYXJkaW5nIHNpbWlsYXIgdG9cbnRoZSBvYmplY3RzIGRpcmVjdG9yeSBpbiBnaXQgcmVwb3NpdG9yaWVzLiBQcmV2aW91c2x5LCB3ZSB1c2VkXG5wcmVmaXhlcywgd2Ugbm93IHVzZSB0aGUgbmV4dC10by1sYXN0IHR3byBjaGFydGVycy5cbiAgICBmdW5jIE5leHRUb0xhc3QoYmFzZTMyY2lkIHN0cmluZykge1xuICAgICAgbmV4dFRvTGFzdExlbiA6PSAyXG4gICAgICBvZmZzZXQgOj0gbGVuKGJhc2UzMmNpZCkgLSBuZXh0VG9MYXN0TGVuIC0gMVxuICAgICAgcmV0dXJuIHN0cltvZmZzZXQgOiBvZmZzZXQrbmV4dFRvTGFzdExlbl1cbiAgICB9XG5Gb3IgZXhhbXBsZSwgYW4gb2JqZWN0IHdpdGggYSBiYXNlNTggQ0lEdjEgb2ZcbiAgICB6YjJyaFlTeHc0Wmp1emdDbldTdDE5UTk0RVJhZUZodTl1U3FSZ2pTZHg5YnNnTTZmXG5oYXMgYSBiYXNlMzIgQ0lEdjEgb2ZcbiAgICBCQUZLUkVJQTIyRkxJRDVBSjJLVTdVUkc0N01ETFJPWklINllGMktBTFUyUFdFRlBWSTM3WUxLUlNDQVxuYW5kIHdpbGwgYmUgcGxhY2VkIGF0XG4gICAgU0MvQUZLUkVJQTIyRkxJRDVBSjJLVTdVUkc0N01ETFJPWklINllGMktBTFUyUFdFRlBWSTM3WUxLUlNDQS5kYXRhXG53aXRoICdTQycgYmVpbmcgdGhlIGxhc3QtdG8tbmV4dCB0d28gY2hhcmFjdGVycyBhbmQgdGhlICdCJyBhdCB0aGVcbmJlZ2lubmluZyBvZiB0aGUgQ0lEdjEgc3RyaW5nIGlzIHRoZSBtdWx0aWJhc2UgcHJlZml4IHRoYXQgaXMgbm90XG5zdG9yZWQgaW4gdGhlIGZpbGVuYW1lLlxuYFxuIiwiXG5cbi8qXG5hbGwgcHVsbCBzdHJlYW1zIGhhdmUgdGhlc2Ugc3RhdGVzOlxuXG57XG4gIFNUQVJUOiB7XG4gICAgcmVhZDogUkVBRElORyxcbiAgICBhYm9ydDogQUJPUlRJTkdcbiAgfSxcbiAgUkVBRFk6IHtcbiAgICByZWFkOiBSRUFESU5HLFxuICAgIGFib3J0OiBBQk9SVElOR1xuICB9LFxuICBSRUFESU5HOiB7XG4gICAgY2I6IFJFQURZLFxuICAgIGVycjogRVJST1IsXG4gICAgZW5kOiBFTkRcbiAgfSxcbiAgQUJPUlRJTkc6IHtcbiAgICBjYjogRU5EXG4gIH0sXG4gIEVSUk9SOiB7fSxcbiAgRU5EOiB7fVxufVxuXG50aGlzIG1vZHVsZSB0YWtlcyBhIGNvbGxlY3Rpb24gb2YgcHVsbC1zdHJlYW1zLFxuYW5kIGludGVybGVhdmVzIHRoZWlyIHN0YXRlcy5cbmlmIGFsbCB0aGUgc3RyZWFtcyBoYXZlIGVuZGVkLCBpdCBlbmRzLlxuSWYgaXQgaXMgaW4gcmVhZGluZyBzdGF0ZSwgYW5kIG9uZSBzdHJlYW0gZ29lcyBoYXMgUkVBRElORy0+Y2Jcbml0IGdvZXMgaW50byBSRUFEWVxuXG5vbiByZWFkLCB0cmlnZ2VyIHJlYWQgb24gZXZlcnkgc3RyZWFtIGluIFNUQVJUIG9yIFJFQURZXG5cbm9uIGFib3J0LCB0cmlnZ2VyIGFib3J0IG9uIGFsbCBzdHJlYW1zIGltbWVkaWF0ZWx5KioqXG5cbmlmIGEgc3RyZWFtIGlzIGluIFJFQURZLCBhbmQgYmlnIHN0cmVhbSBpcyBpbiBBQk9SVCxcbnRyaWdnZXIgYWJvcnRcblxuaWYgZXZlcnkgc3RyZWFtIGlzIGluIEVORCBvciBFUlJPUiwgdHJpZ2dlciBlbmQgb3IgZXJyb3JcblxuY291bGQgeW91IGRlc2NyaWJlIHRoaXMgZGVjbGFyaXRpdmVseSBvciBzb21ldGhpbmc/XG4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcnkpIHtcblxuICB2YXIgY2FwcGVkID0gISFhcnlcbiAgdmFyIGlucHV0cyA9IChhcnkgfHwgW10pLm1hcChjcmVhdGUpLCBpID0gMCwgYWJvcnQsIGNiXG5cbiAgZnVuY3Rpb24gY3JlYXRlIChzdHJlYW0pIHtcbiAgICByZXR1cm4ge3JlYWR5OiBmYWxzZSwgcmVhZGluZzogZmFsc2UsIGVuZGVkOiBmYWxzZSwgcmVhZDogc3RyZWFtLCBkYXRhOiBudWxsfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2sgKCkge1xuICAgIGlmKCFjYikgcmV0dXJuXG4gICAgY2xlYW4oKVxuICAgIHZhciBsID0gaW5wdXRzLmxlbmd0aFxuICAgIHZhciBfY2IgPSBjYlxuICAgIGlmKGwgPT09IDAgJiYgKGFib3J0IHx8IGNhcHBlZCkpIHtcbiAgICAgIGNiID0gbnVsbDsgX2NiKGFib3J0IHx8ICB0cnVlKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy9zY2FuIHRoZSBpbnB1dHMgdG8gY2hlY2sgd2hldGhlciB0aGVyZSBpcyBvbmUgd2UgY2FuIHVzZS5cbiAgICBmb3IodmFyIGogPSAwOyBqIDwgbDsgaisrKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGlucHV0c1soaSArIGopICUgbF1cbiAgICAgIGlmKGN1cnJlbnQucmVhZHkgJiYgIWN1cnJlbnQuZW5kZWQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBjdXJyZW50LmRhdGFcbiAgICAgICAgY3VycmVudC5yZWFkeSA9IGZhbHNlXG4gICAgICAgIGN1cnJlbnQuZGF0YSA9IG51bGxcbiAgICAgICAgaSArKzsgY2IgPSBudWxsXG4gICAgICAgIHJldHVybiBfY2IobnVsbCwgZGF0YSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbiAoKSB7XG4gICAgdmFyIGwgPSBpbnB1dHMubGVuZ3RoXG4gICAgLy9pdGVyYXRlIGJhY2t3YXJkcyBzbyB0aGF0IHdlIGNhbiByZW1vdmUgaXRlbXMuXG4gICAgd2hpbGUobC0tKSB7XG4gICAgICBpZihpbnB1dHNbbF0uZW5kZWQpXG4gICAgICAgIGlucHV0cy5zcGxpY2UobCwgMSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0ICgpIHtcbiAgICB2YXIgbCA9IGlucHV0cy5sZW5ndGhcbiAgICB3aGlsZShsLS0pXG4gICAgICAoZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICAgICAgLy9yZWFkIHRoZSBuZXh0IGl0ZW0gaWYgd2UgYXJlbid0IGFscmVhZHlcbiAgICAgICAgaWYobCA+IGlucHV0cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcigndGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuJylcbiAgICAgICAgaWYoY3VycmVudC5yZWFkaW5nIHx8IGN1cnJlbnQuZW5kZWQgfHwgY3VycmVudC5yZWFkeSkgcmV0dXJuXG4gICAgICAgIGN1cnJlbnQucmVhZGluZyA9IHRydWVcbiAgICAgICAgdmFyIHN5bmMgPSB0cnVlXG4gICAgICAgIGN1cnJlbnQucmVhZChhYm9ydCwgZnVuY3Rpb24gbmV4dCAoZW5kLCBkYXRhKSB7XG4gICAgICAgICAgY3VycmVudC5kYXRhID0gZGF0YVxuICAgICAgICAgIGN1cnJlbnQucmVhZHkgPSB0cnVlXG4gICAgICAgICAgY3VycmVudC5yZWFkaW5nID0gZmFsc2VcblxuICAgICAgICAgIGlmKGVuZCA9PT0gdHJ1ZSB8fCBhYm9ydCkgY3VycmVudC5lbmRlZCA9IHRydWVcbiAgICAgICAgICBlbHNlIGlmKGVuZCkgYWJvcnQgPSBjdXJyZW50LmVuZGVkID0gZW5kXG4gICAgICAgICAgLy9jaGVjayB3aGV0aGVyIHdlIG5lZWQgdG8gYWJvcnQgdGhpcyBzdHJlYW0uXG4gICAgICAgICAgaWYoYWJvcnQgJiYgIWVuZCkgY3VycmVudC5yZWFkKGFib3J0LCBuZXh0KVxuICAgICAgICAgIGlmKCFzeW5jKSBjaGVjaygpXG4gICAgICAgIH0pXG4gICAgICAgIHN5bmMgPSBmYWxzZVxuICAgICAgfSkoaW5wdXRzW2xdKVxuXG4gICAgLy9zY2FuIHRoZSBmZWVkXG4gICAgY2hlY2soKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoX2Fib3J0LCBfY2IpIHtcbiAgICBhYm9ydCA9IGFib3J0IHx8IF9hYm9ydDsgY2IgPSBfY2I7IG5leHQoKVxuICB9XG5cbiAgcmVhZC5hZGQgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgaWYoIXN0cmVhbSkge1xuICAgICAgLy90aGUgc3RyZWFtIHdpbGwgbm93IGVuZCB3aGVuIGFsbCB0aGUgc3RyZWFtcyBlbmQuXG4gICAgICBjYXBwZWQgPSB0cnVlXG4gICAgICAvL3dlIGp1c3QgY2hhbmdlZCBzdGF0ZSwgc28gd2UgbWF5IG5lZWQgdG8gY2JcbiAgICAgIHJldHVybiBuZXh0KClcbiAgICB9XG4gICAgaW5wdXRzLnB1c2goY3JlYXRlKHN0cmVhbSkpXG4gICAgbmV4dCgpXG4gIH1cblxuICByZWFkLmNhcCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICByZWFkLmFkZChudWxsKVxuICB9XG5cbiAgcmV0dXJuIHJlYWRcbn1cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBfZmlsdGVyO1xuXG52YXIgX2FycmF5TWFwID0gcmVxdWlyZSgnbG9kYXNoL19hcnJheU1hcCcpO1xuXG52YXIgX2FycmF5TWFwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FycmF5TWFwKTtcblxudmFyIF9pc0FycmF5TGlrZSA9IHJlcXVpcmUoJ2xvZGFzaC9pc0FycmF5TGlrZScpO1xuXG52YXIgX2lzQXJyYXlMaWtlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzQXJyYXlMaWtlKTtcblxudmFyIF9iYXNlUHJvcGVydHkgPSByZXF1aXJlKCdsb2Rhc2gvX2Jhc2VQcm9wZXJ0eScpO1xuXG52YXIgX2Jhc2VQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlUHJvcGVydHkpO1xuXG52YXIgX25vb3AgPSByZXF1aXJlKCdsb2Rhc2gvbm9vcCcpO1xuXG52YXIgX25vb3AyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbm9vcCk7XG5cbnZhciBfd3JhcEFzeW5jID0gcmVxdWlyZSgnLi93cmFwQXN5bmMnKTtcblxudmFyIF93cmFwQXN5bmMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd3JhcEFzeW5jKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZmlsdGVyQXJyYXkoZWFjaGZuLCBhcnIsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciB0cnV0aFZhbHVlcyA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgaW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICAgIGl0ZXJhdGVlKHgsIGZ1bmN0aW9uIChlcnIsIHYpIHtcbiAgICAgICAgICAgIHRydXRoVmFsdWVzW2luZGV4XSA9ICEhdjtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodHJ1dGhWYWx1ZXNbaV0pIHJlc3VsdHMucHVzaChhcnJbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJHZW5lcmljKGVhY2hmbiwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBlYWNoZm4oY29sbCwgZnVuY3Rpb24gKHgsIGluZGV4LCBjYWxsYmFjaykge1xuICAgICAgICBpdGVyYXRlZSh4LCBmdW5jdGlvbiAoZXJyLCB2KSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHsgaW5kZXg6IGluZGV4LCB2YWx1ZTogeCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgKDAsIF9hcnJheU1hcDIuZGVmYXVsdCkocmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICAgICAgfSksICgwLCBfYmFzZVByb3BlcnR5Mi5kZWZhdWx0KSgndmFsdWUnKSkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9maWx0ZXIoZWFjaGZuLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmlsdGVyID0gKDAsIF9pc0FycmF5TGlrZTIuZGVmYXVsdCkoY29sbCkgPyBmaWx0ZXJBcnJheSA6IGZpbHRlckdlbmVyaWM7XG4gICAgZmlsdGVyKGVhY2hmbiwgY29sbCwgKDAsIF93cmFwQXN5bmMyLmRlZmF1bHQpKGl0ZXJhdGVlKSwgY2FsbGJhY2sgfHwgX25vb3AyLmRlZmF1bHQpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwidmFyIGVuY29kaW5ncyA9IHJlcXVpcmUoJy4vbGliL2VuY29kaW5ncycpXG5cbm1vZHVsZS5leHBvcnRzID0gQ29kZWNcblxuZnVuY3Rpb24gQ29kZWMgKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvZGVjKSkge1xuICAgIHJldHVybiBuZXcgQ29kZWMob3B0cylcbiAgfVxuICB0aGlzLm9wdHMgPSBvcHRzIHx8IHt9XG4gIHRoaXMuZW5jb2RpbmdzID0gZW5jb2RpbmdzXG59XG5cbkNvZGVjLnByb3RvdHlwZS5fZW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmdzW2VuY29kaW5nXVxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IGVuY29kaW5ncy5pZFxuICByZXR1cm4gZW5jb2Rpbmdcbn1cblxuQ29kZWMucHJvdG90eXBlLl9rZXlFbmNvZGluZyA9IGZ1bmN0aW9uIChvcHRzLCBiYXRjaE9wdHMpIHtcbiAgcmV0dXJuIHRoaXMuX2VuY29kaW5nKChiYXRjaE9wdHMgJiYgYmF0Y2hPcHRzLmtleUVuY29kaW5nKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKG9wdHMgJiYgb3B0cy5rZXlFbmNvZGluZykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0cy5rZXlFbmNvZGluZylcbn1cblxuQ29kZWMucHJvdG90eXBlLl92YWx1ZUVuY29kaW5nID0gZnVuY3Rpb24gKG9wdHMsIGJhdGNoT3B0cykge1xuICByZXR1cm4gdGhpcy5fZW5jb2RpbmcoKGJhdGNoT3B0cyAmJiAoYmF0Y2hPcHRzLnZhbHVlRW5jb2RpbmcgfHwgYmF0Y2hPcHRzLmVuY29kaW5nKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChvcHRzICYmIChvcHRzLnZhbHVlRW5jb2RpbmcgfHwgb3B0cy5lbmNvZGluZykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5vcHRzLnZhbHVlRW5jb2RpbmcgfHwgdGhpcy5vcHRzLmVuY29kaW5nKSlcbn1cblxuQ29kZWMucHJvdG90eXBlLmVuY29kZUtleSA9IGZ1bmN0aW9uIChrZXksIG9wdHMsIGJhdGNoT3B0cykge1xuICByZXR1cm4gdGhpcy5fa2V5RW5jb2Rpbmcob3B0cywgYmF0Y2hPcHRzKS5lbmNvZGUoa2V5KVxufVxuXG5Db2RlYy5wcm90b3R5cGUuZW5jb2RlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIG9wdHMsIGJhdGNoT3B0cykge1xuICByZXR1cm4gdGhpcy5fdmFsdWVFbmNvZGluZyhvcHRzLCBiYXRjaE9wdHMpLmVuY29kZSh2YWx1ZSlcbn1cblxuQ29kZWMucHJvdG90eXBlLmRlY29kZUtleSA9IGZ1bmN0aW9uIChrZXksIG9wdHMpIHtcbiAgcmV0dXJuIHRoaXMuX2tleUVuY29kaW5nKG9wdHMpLmRlY29kZShrZXkpXG59XG5cbkNvZGVjLnByb3RvdHlwZS5kZWNvZGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0cykge1xuICByZXR1cm4gdGhpcy5fdmFsdWVFbmNvZGluZyhvcHRzKS5kZWNvZGUodmFsdWUpXG59XG5cbkNvZGVjLnByb3RvdHlwZS5lbmNvZGVCYXRjaCA9IGZ1bmN0aW9uIChvcHMsIG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgcmV0dXJuIG9wcy5tYXAoZnVuY3Rpb24gKF9vcCkge1xuICAgIHZhciBvcCA9IHtcbiAgICAgIHR5cGU6IF9vcC50eXBlLFxuICAgICAga2V5OiBzZWxmLmVuY29kZUtleShfb3Aua2V5LCBvcHRzLCBfb3ApXG4gICAgfVxuICAgIGlmIChzZWxmLmtleUFzQnVmZmVyKG9wdHMsIF9vcCkpIG9wLmtleUVuY29kaW5nID0gJ2JpbmFyeSdcbiAgICBpZiAoX29wLnByZWZpeCkgb3AucHJlZml4ID0gX29wLnByZWZpeFxuICAgIGlmICgndmFsdWUnIGluIF9vcCkge1xuICAgICAgb3AudmFsdWUgPSBzZWxmLmVuY29kZVZhbHVlKF9vcC52YWx1ZSwgb3B0cywgX29wKVxuICAgICAgaWYgKHNlbGYudmFsdWVBc0J1ZmZlcihvcHRzLCBfb3ApKSBvcC52YWx1ZUVuY29kaW5nID0gJ2JpbmFyeSdcbiAgICB9XG4gICAgcmV0dXJuIG9wXG4gIH0pXG59XG5cbnZhciBsdGd0S2V5cyA9IFsnbHQnLCAnZ3QnLCAnbHRlJywgJ2d0ZScsICdzdGFydCcsICdlbmQnXVxuXG5Db2RlYy5wcm90b3R5cGUuZW5jb2RlTHRndCA9IGZ1bmN0aW9uIChsdGd0KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgcmV0ID0ge31cbiAgT2JqZWN0LmtleXMobHRndCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0W2tleV0gPSBsdGd0S2V5cy5pbmRleE9mKGtleSkgPiAtMVxuICAgICAgPyBzZWxmLmVuY29kZUtleShsdGd0W2tleV0sIGx0Z3QpXG4gICAgICA6IGx0Z3Rba2V5XVxuICB9KVxuICByZXR1cm4gcmV0XG59XG5cbkNvZGVjLnByb3RvdHlwZS5jcmVhdGVTdHJlYW1EZWNvZGVyID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKG9wdHMua2V5cyAmJiBvcHRzLnZhbHVlcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBzZWxmLmRlY29kZUtleShrZXksIG9wdHMpLFxuICAgICAgICB2YWx1ZTogc2VsZi5kZWNvZGVWYWx1ZSh2YWx1ZSwgb3B0cylcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAob3B0cy5rZXlzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBzZWxmLmRlY29kZUtleShrZXksIG9wdHMpXG4gICAgfVxuICB9IGVsc2UgaWYgKG9wdHMudmFsdWVzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHNlbGYuZGVjb2RlVmFsdWUodmFsdWUsIG9wdHMpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fVxuICB9XG59XG5cbkNvZGVjLnByb3RvdHlwZS5rZXlBc0J1ZmZlciA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHJldHVybiB0aGlzLl9rZXlFbmNvZGluZyhvcHRzKS5idWZmZXJcbn1cblxuQ29kZWMucHJvdG90eXBlLnZhbHVlQXNCdWZmZXIgPSBmdW5jdGlvbiAob3B0cykge1xuICByZXR1cm4gdGhpcy5fdmFsdWVFbmNvZGluZyhvcHRzKS5idWZmZXJcbn1cbiIsInZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG52YXIgQWJzdHJhY3RJdGVyYXRvciAgPSByZXF1aXJlKCdhYnN0cmFjdC1sZXZlbGRvd24nKS5BYnN0cmFjdEl0ZXJhdG9yXG52YXIgbHRndCA9IHJlcXVpcmUoJ2x0Z3QnKVxudmFyIGlkYlJlYWRhYmxlU3RyZWFtID0gcmVxdWlyZSgnaWRiLXJlYWRhYmxlLXN0cmVhbScpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcbnZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcblxudmFyIFdyaXRhYmxlID0gc3RyZWFtLldyaXRhYmxlXG5cbm1vZHVsZS5leHBvcnRzID0gSXRlcmF0b3JcblxuLyoqXG4gKiBPcGVuIEluZGV4ZWREQiBjdXJzb3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRiICBkYiBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgb3B0aW9uc1xuICpcbiAqIG9wdGlvbnM6XG4gKiAgIHNuYXBzaG90IHtCb29sZWFufSAgV2hldGhlciB0byB1c2Ugc25hcHNob3QgbW9kZSwgdGhhdCBtYXkgbGVhZCB0byBtZW1vcnlcbiAqICAgICBzcGlrZXMsIG9yIHVzZSBiYWNrIHByZXNzdXJlLCB0aGF0IGNhbid0IGd1YXJhbnRlZSB0aGUgc2FtZSBzbmFwc2hvdC4gVGhpc1xuICogICAgIG9wdGlvbiBpcyB0cnVlIGJ5IGRlZmF1bHQuXG4gKi9cbmZ1bmN0aW9uIEl0ZXJhdG9yKGRiLCBvcHRpb25zKSB7XG4gIHRoaXMuX2RiID0gZGIuX2RiXG4gIHRoaXMuX2lkYk9wdHMgPSBkYi5faWRiT3B0c1xuXG4gIEFic3RyYWN0SXRlcmF0b3IuY2FsbCh0aGlzLCBkYilcblxuICB0aGlzLl9vcHRpb25zID0geHRlbmQoe1xuICAgIHNuYXBzaG90OiB0cnVlXG4gIH0sIHRoaXMuX2lkYk9wdHMsIG9wdGlvbnMpXG5cbiAgdGhpcy5fbGltaXQgPSB0aGlzLl9vcHRpb25zLmxpbWl0XG4gIGlmICh0aGlzLl9saW1pdCA9PSBudWxsIHx8IHRoaXMuX2xpbWl0ID09PSAtMSkge1xuICAgIHRoaXMuX2xpbWl0ID0gSW5maW5pdHlcbiAgfVxuICBpZiAodHlwZW9mIHRoaXMuX2xpbWl0ICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5saW1pdCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgaWYgKHRoaXMuX2xpbWl0ID09PSAwKSByZXR1cm4gLy8gc2tpcCBmdXJ0aGVyIHByb2Nlc3NpbmcgYW5kIHdhaXQgZm9yIGZpcnN0IGNhbGwgdG8gX25leHRcblxuICB0aGlzLl9jb3VudCA9IDBcblxuICB0aGlzLl9zdGFydEN1cnNvcih0aGlzLl9vcHRpb25zKVxufVxuXG51dGlsLmluaGVyaXRzKEl0ZXJhdG9yLCBBYnN0cmFjdEl0ZXJhdG9yKVxuXG5JdGVyYXRvci5wcm90b3R5cGUuX3N0YXJ0Q3Vyc29yID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0geHRlbmQodGhpcy5fb3B0aW9ucywgb3B0aW9ucylcblxuICB2YXIgc2VsZiA9IHRoaXNcblxuICB2YXIga2V5UmFuZ2UgPSBudWxsXG4gIHZhciBsb3dlciA9IGx0Z3QubG93ZXJCb3VuZChvcHRpb25zKVxuICB2YXIgdXBwZXIgPSBsdGd0LnVwcGVyQm91bmQob3B0aW9ucylcbiAgdmFyIGxvd2VyT3BlbiA9IGx0Z3QubG93ZXJCb3VuZEV4Y2x1c2l2ZShvcHRpb25zKVxuICB2YXIgdXBwZXJPcGVuID0gbHRndC51cHBlckJvdW5kRXhjbHVzaXZlKG9wdGlvbnMpXG5cbiAgdmFyIGRpcmVjdGlvbiA9IG9wdGlvbnMucmV2ZXJzZSA/ICdwcmV2JzogJ25leHQnXG5cbiAgLy8gc3VwcG9ydCBiaW5hcnkga2V5cyBmb3IgYW55IGl0ZXJhYmxlIHR5cGUgdmlhIGFycmF5IChBcnJheUJ1ZmZlcnMgYXMga2V5cyBhcmUgb25seSBzdXBwb3J0ZWQgaW4gSW5kZXhlZERCIFNlY29uZCBFZGl0aW9uKVxuICBpZiAobG93ZXIpXG4gICAgaWYgKG9wdGlvbnMua2V5RW5jb2RpbmcgPT09ICdiaW5hcnknICYmICFBcnJheS5pc0FycmF5KGxvd2VyKSkgbG93ZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsb3dlcilcbiAgaWYgKHVwcGVyKVxuICAgIGlmIChvcHRpb25zLmtleUVuY29kaW5nID09PSAnYmluYXJ5JyAmJiAhQXJyYXkuaXNBcnJheSh1cHBlcikpIHVwcGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodXBwZXIpXG5cbiAgaWYgKGxvd2VyICYmIHVwcGVyKVxuICAgIHRyeSB7XG4gICAgICBrZXlSYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKGxvd2VyLCB1cHBlciwgbG93ZXJPcGVuLCB1cHBlck9wZW4pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBza2lwIHRoZSBpdGVyYXRvciBhbmQgcmV0dXJuIDAgcmVzdWx0cyBpZiBJREJLZXlSYW5nZSB0aHJvd3MgYSBEYXRhRXJyb3IgKGlmIGtleXMgb3ZlcmxhcClcbiAgICAgIHRoaXMuX2tleVJhbmdlRXJyb3IgPSB0cnVlXG4gICAgICByZXR1cm5cbiAgICB9XG4gIGVsc2UgaWYgKGxvd2VyKVxuICAgIGtleVJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChsb3dlciwgbG93ZXJPcGVuKVxuICBlbHNlIGlmICh1cHBlcilcbiAgICBrZXlSYW5nZSA9IElEQktleVJhbmdlLnVwcGVyQm91bmQodXBwZXIsIHVwcGVyT3BlbilcblxuICB0aGlzLl9yZWFkZXIgPSBpZGJSZWFkYWJsZVN0cmVhbSh0aGlzLl9kYiwgdGhpcy5faWRiT3B0cy5zdG9yZU5hbWUsIHh0ZW5kKG9wdGlvbnMsIHsgcmFuZ2U6IGtleVJhbmdlLCBkaXJlY3Rpb246IGRpcmVjdGlvbiB9KSlcblxuICB0aGlzLl9yZWFkZXIub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgdmFyIGNiID0gc2VsZi5fY2FsbGJhY2tcbiAgICBzZWxmLl9jYWxsYmFjayA9IGZhbHNlXG5cbiAgICBpZiAoY2IpXG4gICAgICBjYihlcnIpXG4gICAgZWxzZSAvLyBlbHNlIHdhaXQgZm9yIF9uZXh0XG4gICAgICBzZWxmLl9yZWFkTmV4dCA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgIGNiKGVycilcbiAgICAgIH1cbiAgfSlcblxuICB0aGlzLl9yZWFkZXIucGlwZShuZXcgV3JpdGFibGUoe1xuICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgd3JpdGU6IGZ1bmN0aW9uKGl0ZW0sIGVuYywgY2IpIHtcbiAgICAgIGlmIChzZWxmLl9jb3VudCsrID49IHNlbGYuX2xpbWl0KSB7IC8vIGxpbWl0IHJlYWNoZWQsIGZpbmlzaFxuICAgICAgICBzZWxmLl9yZWFkZXIucGF1c2UoKVxuICAgICAgICBzZWxmLl9yZWFkZXIudW5waXBlKHRoaXMpXG4gICAgICAgIGNiKClcbiAgICAgICAgdGhpcy5lbmQoKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdmFyIGNiMiA9IHNlbGYuX2NhbGxiYWNrXG4gICAgICBzZWxmLl9jYWxsYmFjayA9IGZhbHNlXG5cbiAgICAgIGlmIChjYjIpXG4gICAgICAgIHNlbGYuX3Byb2Nlc3NJdGVtKGl0ZW0sIGZ1bmN0aW9uKGVyciwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGNiKGVycikgLy8gcHJvY2VlZCB3aXRoIG5leHQgaXRlbVxuICAgICAgICAgIGNiMihlcnIsIGtleSwgdmFsdWUpXG4gICAgICAgIH0pXG4gICAgICBlbHNlIC8vIGVsc2Ugd2FpdCBmb3IgX25leHRcbiAgICAgICAgc2VsZi5fcmVhZE5leHQgPSBmdW5jdGlvbihjYjIpIHtcbiAgICAgICAgICBzZWxmLl9wcm9jZXNzSXRlbShpdGVtLCBmdW5jdGlvbihlcnIsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGNiKGVycikgLy8gcHJvY2VlZCB3aXRoIG5leHQgaXRlbVxuICAgICAgICAgICAgY2IyKGVyciwga2V5LCB2YWx1ZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICB9XG4gIH0pKS5vbignZmluaXNoJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNiID0gc2VsZi5fY2FsbGJhY2tcbiAgICBzZWxmLl9jYWxsYmFjayA9IGZhbHNlXG5cbiAgICBpZiAoY2IpXG4gICAgICBjYigpXG4gICAgZWxzZSAvLyBlbHNlIHdhaXQgZm9yIF9uZXh0XG4gICAgICBzZWxmLl9yZWFkTmV4dCA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgIGNiKClcbiAgICAgIH1cbiAgfSlcbn1cblxuSXRlcmF0b3IucHJvdG90eXBlLl9wcm9jZXNzSXRlbSA9IGZ1bmN0aW9uKGl0ZW0sIGNiKSB7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NiIG11c3QgYmUgYSBmdW5jdGlvbicpXG5cbiAgdmFyIGtleSA9IGl0ZW0ua2V5XG4gIHZhciB2YWx1ZSA9IGl0ZW0udmFsdWVcblxuICAvLyBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgVWludDhBcnJheSB2YWx1ZXMgdG8gQnVmZmVyXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHZhbHVlID0gbmV3IEJ1ZmZlcih2YWx1ZSlcbiAgaWYgKHRoaXMuX29wdGlvbnMua2V5RW5jb2RpbmcgPT09ICdiaW5hcnknICYmIEFycmF5LmlzQXJyYXkoa2V5KSkga2V5ID0gbmV3IEJ1ZmZlcihrZXkpXG4gIGlmICh0aGlzLl9vcHRpb25zLnZhbHVlRW5jb2RpbmcgPT09ICdiaW5hcnknICYmICFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB2YWx1ZSA9IG5ldyBCdWZmZXIodmFsdWUpXG5cbiAgaWYgKHRoaXMuX29wdGlvbnMua2V5QXNCdWZmZXIgJiYgIUJ1ZmZlci5pc0J1ZmZlcihrZXkpKSB7XG4gICAgaWYgKGtleSA9PSBudWxsKSAgICAgICAgICAgICAgICAgICAgIGtleSA9IG5ldyBCdWZmZXIoMClcbiAgICBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykgICAga2V5ID0gbmV3IEJ1ZmZlcihrZXkpIC8vIGRlZmF1bHRzIHRvIHV0ZjgsIHNob3VsZCB0aGUgZW5jb2RpbmcgYmUgdXRmMTY/IChET01TdHJpbmcpXG4gICAgZWxzZSBpZiAodHlwZW9mIGtleSA9PT0gJ2Jvb2xlYW4nKSAgIGtleSA9IG5ldyBCdWZmZXIoU3RyaW5nKGtleSkpIC8vIGNvbXBhdGlibGUgd2l0aCBsZXZlbGRiXG4gICAgZWxzZSBpZiAodHlwZW9mIGtleSA9PT0gJ251bWJlcicpICAgIGtleSA9IG5ldyBCdWZmZXIoU3RyaW5nKGtleSkpIC8vIGNvbXBhdGlibGUgd2l0aCBsZXZlbGRiXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSAgICAgICAgIGtleSA9IG5ldyBCdWZmZXIoU3RyaW5nKGtleSkpIC8vIGNvbXBhdGlibGUgd2l0aCBsZXZlbGRiXG4gICAgZWxzZSBpZiAoa2V5IGluc3RhbmNlb2YgVWludDhBcnJheSkgIGtleSA9IG5ldyBCdWZmZXIoa2V5KVxuICAgIGVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FuXFwndCBjb2VyY2UgYCcgKyBrZXkuY29uc3RydWN0b3IubmFtZSArICdgIGludG8gYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMudmFsdWVBc0J1ZmZlciAmJiAhQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEJ1ZmZlcigwKVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpICAgIHZhbHVlID0gbmV3IEJ1ZmZlcih2YWx1ZSkgLy8gZGVmYXVsdHMgdG8gdXRmOCwgc2hvdWxkIHRoZSBlbmNvZGluZyBiZSB1dGYxNj8gKERPTVN0cmluZylcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykgICB2YWx1ZSA9IG5ldyBCdWZmZXIoU3RyaW5nKHZhbHVlKSkgLy8gY29tcGF0aWJsZSB3aXRoIGxldmVsZGJcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSAgICB2YWx1ZSA9IG5ldyBCdWZmZXIoU3RyaW5nKHZhbHVlKSkgLy8gY29tcGF0aWJsZSB3aXRoIGxldmVsZGJcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgICAgICAgICB2YWx1ZSA9IG5ldyBCdWZmZXIoU3RyaW5nKHZhbHVlKSkgLy8gY29tcGF0aWJsZSB3aXRoIGxldmVsZGJcbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpICB2YWx1ZSA9IG5ldyBCdWZmZXIodmFsdWUpXG4gICAgZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5cXCd0IGNvZXJjZSBgJyArIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgKyAnYCBpbnRvIGEgQnVmZmVyJylcbiAgfVxuXG4gIGNiKG51bGwsIGtleSwgdmFsdWUpXG59XG5cbi8vIHJlZ2lzdGVyIGEgY2FsbGJhY2ssIG9ubHkgY2FsbCBpdCBkaXJlY3RseSBpZiBhIG5leHRIYW5kbGVyIGlzIHJlZ2lzdGVyZWRcbkl0ZXJhdG9yLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIGlmICh0aGlzLl9jYWxsYmFjaykgdGhyb3cgbmV3IEVycm9yKCdjYWxsYmFjayBhbHJlYWR5IGV4aXN0cycpIC8vIGVhY2ggY2FsbGJhY2sgc2hvdWxkIGJlIGludm9rZWQgZXhhY3RseSBvbmNlXG4gIGlmICh0aGlzLl9rZXlSYW5nZUVycm9yIHx8IHRoaXMuX2xpbWl0ID09PSAwKSByZXR1cm4gdm9pZCBjYWxsYmFjaygpXG5cbiAgdmFyIHJlYWROZXh0ID0gdGhpcy5fcmVhZE5leHRcbiAgdGhpcy5fcmVhZE5leHQgPSBmYWxzZVxuXG4gIGlmIChyZWFkTmV4dCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICByZWFkTmV4dChjYWxsYmFjaylcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2tcbiAgfVxufVxuIiwiZXhwb3J0cy5BYnN0cmFjdExldmVsRE9XTiAgICA9IHJlcXVpcmUoJy4vYWJzdHJhY3QtbGV2ZWxkb3duJylcbmV4cG9ydHMuQWJzdHJhY3RJdGVyYXRvciAgICAgPSByZXF1aXJlKCcuL2Fic3RyYWN0LWl0ZXJhdG9yJylcbmV4cG9ydHMuQWJzdHJhY3RDaGFpbmVkQmF0Y2ggPSByZXF1aXJlKCcuL2Fic3RyYWN0LWNoYWluZWQtYmF0Y2gnKVxuZXhwb3J0cy5pc0xldmVsRE9XTiAgICAgICAgICA9IHJlcXVpcmUoJy4vaXMtbGV2ZWxkb3duJylcbiIsImV4cG9ydHMuZ2V0Q2FsbGJhY2sgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucyA6IGNhbGxiYWNrXG59XG5cbmV4cG9ydHMuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCA/IG9wdGlvbnMgOiB7fVxufVxuIiwiZnVuY3Rpb24gcHJvbWlzaWZ5ICgpIHtcbiAgdmFyIGNhbGxiYWNrXG4gIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2sgKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpXG4gICAgICBlbHNlIHJlc29sdmUodmFsdWUpXG4gICAgfVxuICB9KVxuICBjYWxsYmFjay5wcm9taXNlID0gcHJvbWlzZVxuICByZXR1cm4gY2FsbGJhY2tcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9taXNpZnlcbiIsInZhciBXcml0ZUVycm9yID0gcmVxdWlyZSgnbGV2ZWwtZXJyb3JzJykuV3JpdGVFcnJvclxudmFyIHByb21pc2lmeSA9IHJlcXVpcmUoJy4vcHJvbWlzaWZ5JylcbnZhciBnZXRDYWxsYmFjayA9IHJlcXVpcmUoJy4vY29tbW9uJykuZ2V0Q2FsbGJhY2tcbnZhciBnZXRPcHRpb25zID0gcmVxdWlyZSgnLi9jb21tb24nKS5nZXRPcHRpb25zXG5cbmZ1bmN0aW9uIEJhdGNoIChsZXZlbHVwKSB7XG4gIHRoaXMuX2xldmVsdXAgPSBsZXZlbHVwXG4gIHRoaXMuYmF0Y2ggPSBsZXZlbHVwLmRiLmJhdGNoKClcbiAgdGhpcy5vcHMgPSBbXVxuICB0aGlzLmxlbmd0aCA9IDBcbn1cblxuQmF0Y2gucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgdGhpcy5iYXRjaC5wdXQoa2V5LCB2YWx1ZSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBXcml0ZUVycm9yKGUpXG4gIH1cblxuICB0aGlzLm9wcy5wdXNoKHsgdHlwZTogJ3B1dCcsIGtleToga2V5LCB2YWx1ZTogdmFsdWUgfSlcbiAgdGhpcy5sZW5ndGgrK1xuXG4gIHJldHVybiB0aGlzXG59XG5cbkJhdGNoLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHRyeSB7XG4gICAgdGhpcy5iYXRjaC5kZWwoa2V5KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgV3JpdGVFcnJvcihlcnIpXG4gIH1cblxuICB0aGlzLm9wcy5wdXNoKHsgdHlwZTogJ2RlbCcsIGtleToga2V5IH0pXG4gIHRoaXMubGVuZ3RoKytcblxuICByZXR1cm4gdGhpc1xufVxuXG5CYXRjaC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgdGhpcy5iYXRjaC5jbGVhcigpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBXcml0ZUVycm9yKGVycilcbiAgfVxuXG4gIHRoaXMub3BzID0gW11cbiAgdGhpcy5sZW5ndGggPSAwXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuQmF0Y2gucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBsZXZlbHVwID0gdGhpcy5fbGV2ZWx1cFxuICB2YXIgb3BzID0gdGhpcy5vcHNcbiAgdmFyIHByb21pc2VcblxuICBjYWxsYmFjayA9IGdldENhbGxiYWNrKG9wdGlvbnMsIGNhbGxiYWNrKVxuXG4gIGlmICghY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IHByb21pc2lmeSgpXG4gICAgcHJvbWlzZSA9IGNhbGxiYWNrLnByb21pc2VcbiAgfVxuXG4gIG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbnMpXG5cbiAgdHJ5IHtcbiAgICB0aGlzLmJhdGNoLndyaXRlKG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKG5ldyBXcml0ZUVycm9yKGVycikpIH1cbiAgICAgIGxldmVsdXAuZW1pdCgnYmF0Y2gnLCBvcHMpXG4gICAgICBjYWxsYmFjaygpXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IFdyaXRlRXJyb3IoZXJyKVxuICB9XG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYXRjaFxuIiwidmFyIEFic3RyYWN0TGV2ZWxET1dOID0gcmVxdWlyZSgnYWJzdHJhY3QtbGV2ZWxkb3duJykuQWJzdHJhY3RMZXZlbERPV05cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBEZWZlcnJlZEl0ZXJhdG9yID0gcmVxdWlyZSgnLi9kZWZlcnJlZC1pdGVyYXRvcicpXG52YXIgZGVmZXJyYWJsZXMgPSAncHV0IGdldCBkZWwgYmF0Y2gnLnNwbGl0KCcgJylcblxuZnVuY3Rpb24gRGVmZXJyZWRMZXZlbERPV04gKGRiKSB7XG4gIEFic3RyYWN0TGV2ZWxET1dOLmNhbGwodGhpcywgJycpXG4gIHRoaXMuX2RiID0gZGJcbiAgdGhpcy5fb3BlcmF0aW9ucyA9IFtdXG4gIHRoaXMuX2l0ZXJhdG9ycyA9IFtdXG4gIGNsb3NlZCh0aGlzKVxufVxuXG5pbmhlcml0cyhEZWZlcnJlZExldmVsRE9XTiwgQWJzdHJhY3RMZXZlbERPV04pXG5cbkRlZmVycmVkTGV2ZWxET1dOLnByb3RvdHlwZS5fb3BlbiA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICB0aGlzLl9kYi5vcGVuKG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuXG4gICAgc2VsZi5fb3BlcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcCkge1xuICAgICAgc2VsZi5fZGJbb3AubWV0aG9kXS5hcHBseShzZWxmLl9kYiwgb3AuYXJncylcbiAgICB9KVxuICAgIHNlbGYuX29wZXJhdGlvbnMgPSBbXVxuICAgIHNlbGYuX2l0ZXJhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChpdCkge1xuICAgICAgaXQuc2V0RGIoc2VsZi5fZGIpXG4gICAgfSlcbiAgICBzZWxmLl9pdGVyYXRvcnMgPSBbXVxuICAgIG9wZW4oc2VsZilcbiAgICBjYWxsYmFjaygpXG4gIH0pXG59XG5cbkRlZmVycmVkTGV2ZWxET1dOLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdGhpcy5fZGIuY2xvc2UoZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgY2xvc2VkKHNlbGYpXG4gICAgY2FsbGJhY2soKVxuICB9KVxufVxuXG5mdW5jdGlvbiBvcGVuIChzZWxmKSB7XG4gIGRlZmVycmFibGVzLmNvbmNhdCgnaXRlcmF0b3InKS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgc2VsZlsnXycgKyBtXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYlttXS5hcHBseSh0aGlzLl9kYiwgYXJndW1lbnRzKVxuICAgIH1cbiAgfSlcbiAgaWYgKHNlbGYuX2RiLmFwcHJveGltYXRlU2l6ZSkge1xuICAgIHNlbGYuYXBwcm94aW1hdGVTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RiLmFwcHJveGltYXRlU2l6ZS5hcHBseSh0aGlzLl9kYiwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9zZWQgKHNlbGYpIHtcbiAgZGVmZXJyYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgIHNlbGZbJ18nICsgbV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vcGVyYXRpb25zLnB1c2goeyBtZXRob2Q6IG0sIGFyZ3M6IGFyZ3VtZW50cyB9KVxuICAgIH1cbiAgfSlcbiAgaWYgKHR5cGVvZiBzZWxmLl9kYi5hcHByb3hpbWF0ZVNpemUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzZWxmLmFwcHJveGltYXRlU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX29wZXJhdGlvbnMucHVzaCh7XG4gICAgICAgIG1ldGhvZDogJ2FwcHJveGltYXRlU2l6ZScsXG4gICAgICAgIGFyZ3M6IGFyZ3VtZW50c1xuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgc2VsZi5faXRlcmF0b3IgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBpdCA9IG5ldyBEZWZlcnJlZEl0ZXJhdG9yKG9wdGlvbnMpXG4gICAgdGhpcy5faXRlcmF0b3JzLnB1c2goaXQpXG4gICAgcmV0dXJuIGl0XG4gIH1cbn1cblxuRGVmZXJyZWRMZXZlbERPV04ucHJvdG90eXBlLl9zZXJpYWxpemVLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlcbn1cblxuRGVmZXJyZWRMZXZlbERPV04ucHJvdG90eXBlLl9zZXJpYWxpemVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEZWZlcnJlZExldmVsRE9XTlxubW9kdWxlLmV4cG9ydHMuRGVmZXJyZWRJdGVyYXRvciA9IERlZmVycmVkSXRlcmF0b3JcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlJlYWRhYmxlXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRTdHJlYW1cbmluaGVyaXRzKFJlYWRTdHJlYW0sIFJlYWRhYmxlKVxuXG5mdW5jdGlvbiBSZWFkU3RyZWFtIChpdGVyYXRvciwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZFN0cmVhbSkpIHJldHVybiBuZXcgUmVhZFN0cmVhbShpdGVyYXRvciwgb3B0aW9ucylcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBleHRlbmQob3B0aW9ucywge1xuICAgIG9iamVjdE1vZGU6IHRydWVcbiAgfSkpXG4gIHRoaXMuX2l0ZXJhdG9yID0gaXRlcmF0b3JcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnNcbiAgdGhpcy5vbignZW5kJywgdGhpcy5kZXN0cm95LmJpbmQodGhpcywgbnVsbCwgbnVsbCkpXG59XG5cblJlYWRTdHJlYW0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zXG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgdGhpcy5faXRlcmF0b3IubmV4dChmdW5jdGlvbiAoZXJyLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBpZiAoZXJyKSByZXR1cm4gc2VsZi5kZXN0cm95KGVycilcblxuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZWxmLnB1c2gobnVsbClcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMua2V5cyAhPT0gZmFsc2UgJiYgb3B0aW9ucy52YWx1ZXMgPT09IGZhbHNlKSB7XG4gICAgICBzZWxmLnB1c2goa2V5KVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5rZXlzID09PSBmYWxzZSAmJiBvcHRpb25zLnZhbHVlcyAhPT0gZmFsc2UpIHtcbiAgICAgIHNlbGYucHVzaCh2YWx1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9KVxuICAgIH1cbiAgfSlcbn1cblxuUmVhZFN0cmVhbS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYWxsYmFjaykge1xuICB0aGlzLl9pdGVyYXRvci5lbmQoZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYWxsYmFjayhlcnIgfHwgZXJyMilcbiAgfSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLnRvQ2FsbGJhY2sgPSAoZG9Xb3JrKSA9PiB7XG4gIHJldHVybiBmdW5jdGlvbiAoaW5wdXQsIGNhbGxiYWNrKSB7XG4gICAgbGV0IHJlc1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBkb1dvcmsoaW5wdXQpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBudWxsLCByZXMpXG4gIH1cbn1cblxuZXhwb3J0cy50b0J1ZiA9IChkb1dvcmssIG90aGVyKSA9PiAoaW5wdXQpID0+IHtcbiAgbGV0IHJlc3VsdCA9IGRvV29yayhpbnB1dCwgb3RoZXIpXG4gIHJldHVybiBCdWZmZXIuZnJvbShyZXN1bHQsICdoZXgnKVxufVxuXG5leHBvcnRzLmZyb21TdHJpbmcgPSAoZG9Xb3JrLCBvdGhlcikgPT4gKF9pbnB1dCkgPT4ge1xuICBjb25zdCBpbnB1dCA9IEJ1ZmZlci5pc0J1ZmZlcihfaW5wdXQpID8gX2lucHV0LnRvU3RyaW5nKCkgOiBfaW5wdXRcbiAgcmV0dXJuIGRvV29yayhpbnB1dCwgb3RoZXIpXG59XG5cbmV4cG9ydHMuZnJvbU51bWJlclRvMzJCaXRCdWYgPSAoZG9Xb3JrLCBvdGhlcikgPT4gKGlucHV0KSA9PiB7XG4gIGxldCBudW1iZXIgPSBkb1dvcmsoaW5wdXQsIG90aGVyKVxuICBjb25zdCBieXRlcyA9IG5ldyBBcnJheSg0KVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgYnl0ZXNbaV0gPSBudW1iZXIgJiAweGZmXG4gICAgbnVtYmVyID0gbnVtYmVyID4+IDhcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShieXRlcylcbn1cbiIsIi8qIGdsb2JhbCBzZWxmICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBub2RlaWZ5ID0gcmVxdWlyZSgnbm9kZWlmeScpXG5cbmNvbnN0IHdlYkNyeXB0byA9IGdldFdlYkNyeXB0bygpXG5cbmZ1bmN0aW9uIGdldFdlYkNyeXB0byAoKSB7XG4gIGlmIChzZWxmLmNyeXB0bykge1xuICAgIHJldHVybiBzZWxmLmNyeXB0by5zdWJ0bGUgfHwgc2VsZi5jcnlwdG8ud2Via2l0U3VidGxlXG4gIH1cblxuICBpZiAoc2VsZi5tc0NyeXB0bykge1xuICAgIHJldHVybiBzZWxmLm1zQ3J5cHRvLnN1YnRsZVxuICB9XG59XG5cbmZ1bmN0aW9uIHdlYkNyeXB0b0hhc2ggKHR5cGUpIHtcbiAgaWYgKCF3ZWJDcnlwdG8pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSB1c2UgYSBicm93c2VyIHdpdGggd2ViY3J5cHRvIHN1cHBvcnQgYW5kIGVuc3VyZSB0aGUgY29kZSBoYXMgYmVlbiBkZWxpdmVyZWQgc2VjdXJlbHkgdmlhIEhUVFBTL1RMUyBhbmQgcnVuIHdpdGhpbiBhIFNlY3VyZSBDb250ZXh0JylcbiAgfVxuXG4gIHJldHVybiAoZGF0YSwgY2FsbGJhY2spID0+IHtcbiAgICBjb25zdCByZXMgPSB3ZWJDcnlwdG8uZGlnZXN0KHsgbmFtZTogdHlwZSB9LCBkYXRhKVxuXG4gICAgaWYgKHR5cGVvZiByZXMudGhlbiAhPT0gJ2Z1bmN0aW9uJykgeyAvLyBJRTExXG4gICAgICByZXMub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKGBoYXNoaW5nIGRhdGEgdXNpbmcgJHt0eXBlfWApKVxuICAgICAgfVxuICAgICAgcmVzLm9uY29tcGxldGUgPSAoZSkgPT4ge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBlLnRhcmdldC5yZXN1bHQpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBub2RlaWZ5KFxuICAgICAgcmVzLnRoZW4oKHJhdykgPT4gQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkocmF3KSkpLFxuICAgICAgY2FsbGJhY2tcbiAgICApXG4gIH1cbn1cblxuZnVuY3Rpb24gc2hhMSAoYnVmLCBjYWxsYmFjaykge1xuICB3ZWJDcnlwdG9IYXNoKCdTSEEtMScpKGJ1ZiwgY2FsbGJhY2spXG59XG5cbmZ1bmN0aW9uIHNoYTIyNTYgKGJ1ZiwgY2FsbGJhY2spIHtcbiAgd2ViQ3J5cHRvSGFzaCgnU0hBLTI1NicpKGJ1ZiwgY2FsbGJhY2spXG59XG5cbmZ1bmN0aW9uIHNoYTI1MTIgKGJ1ZiwgY2FsbGJhY2spIHtcbiAgd2ViQ3J5cHRvSGFzaCgnU0hBLTUxMicpKGJ1ZiwgY2FsbGJhY2spXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzaGExOiBzaGExLFxuICBzaGEyMjU2OiBzaGEyMjU2LFxuICBzaGEyNTEyOiBzaGEyNTEyXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgYmxha2UgPSByZXF1aXJlKCdibGFrZWpzJylcblxuY29uc3QgdG9DYWxsYmFjayA9IHJlcXVpcmUoJy4vdXRpbHMnKS50b0NhbGxiYWNrXG5cbmNvbnN0IG1pbkIgPSAweGIyMDFcbmNvbnN0IG1pblMgPSAweGIyNDFcblxuY29uc3QgYmxha2UyYiA9IHtcbiAgaW5pdDogYmxha2UuYmxha2UyYkluaXQsXG4gIHVwZGF0ZTogYmxha2UuYmxha2UyYlVwZGF0ZSxcbiAgZGlnZXN0OiBibGFrZS5ibGFrZTJiRmluYWxcbn1cblxuY29uc3QgYmxha2UycyA9IHtcbiAgaW5pdDogYmxha2UuYmxha2Uyc0luaXQsXG4gIHVwZGF0ZTogYmxha2UuYmxha2Uyc1VwZGF0ZSxcbiAgZGlnZXN0OiBibGFrZS5ibGFrZTJzRmluYWxcbn1cblxuY29uc3QgbWFrZUIySGFzaCA9IChzaXplLCBoZikgPT4gdG9DYWxsYmFjaygoYnVmKSA9PiB7XG4gIGNvbnN0IGN0eCA9IGhmLmluaXQoc2l6ZSwgbnVsbClcbiAgaGYudXBkYXRlKGN0eCwgYnVmKVxuICByZXR1cm4gQnVmZmVyLmZyb20oaGYuZGlnZXN0KGN0eCkpXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9ICh0YWJsZSkgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICB0YWJsZVttaW5CICsgaV0gPSBtYWtlQjJIYXNoKGkgKyAxLCBibGFrZTJiKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIHRhYmxlW21pblMgKyBpXSA9IG1ha2VCMkhhc2goaSArIDEsIGJsYWtlMnMpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNjaCkge1xuICB2YXIgbm9Db21tZW50cyA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgdmFyIGkgPSBsaW5lLmluZGV4T2YoJy8vJylcbiAgICByZXR1cm4gaSA+IC0xID8gbGluZS5zbGljZSgwLCBpKSA6IGxpbmVcbiAgfVxuXG4gIHZhciBub011bHRpbGluZUNvbW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnNpZGUgPSBmYWxzZVxuICAgIHJldHVybiBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgIGlmICh0b2tlbiA9PT0gJy8qJykge1xuICAgICAgICBpbnNpZGUgPSB0cnVlXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKHRva2VuID09PSAnKi8nKSB7XG4gICAgICAgIGluc2lkZSA9IGZhbHNlXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgcmV0dXJuICFpbnNpZGVcbiAgICB9XG4gIH1cblxuICB2YXIgdHJpbSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgcmV0dXJuIGxpbmUudHJpbSgpXG4gIH1cblxuICByZXR1cm4gc2NoXG4gICAgLnJlcGxhY2UoLyhbOyx7fSgpPTpbXFxdPD5dfFxcL1xcKnxcXCpcXC8pL2csICcgJDEgJylcbiAgICAuc3BsaXQoL1xcbi8pXG4gICAgLm1hcCh0cmltKVxuICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAubWFwKG5vQ29tbWVudHMpXG4gICAgLm1hcCh0cmltKVxuICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAuam9pbignXFxuJylcbiAgICAuc3BsaXQoL1xccyt8XFxuKy9nbSlcbiAgICAuZmlsdGVyKG5vTXVsdGlsaW5lQ29tbWVudHMoKSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmRlZmluZWQgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdmFsICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInIHx8ICFpc05hTih2YWwpKVxufVxuIiwidmFyIHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZSAodiwgYiwgbykge1xuICB2ID0gdiA+PSAwID8gdioyIDogdiotMiAtIDFcbiAgdmFyIHIgPSB2YXJpbnQuZW5jb2RlKHYsIGIsIG8pXG4gIGVuY29kZS5ieXRlcyA9IHZhcmludC5lbmNvZGUuYnl0ZXNcbiAgcmV0dXJuIHJcbn1cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlIChiLCBvKSB7XG4gIHZhciB2ID0gdmFyaW50LmRlY29kZShiLCBvKVxuICBkZWNvZGUuYnl0ZXMgPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gIHJldHVybiB2ICYgMSA/ICh2KzEpIC8gLTIgOiB2IC8gMlxufVxuXG5leHBvcnRzLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKHYpIHtcbiAgcmV0dXJuIHZhcmludC5lbmNvZGluZ0xlbmd0aCh2ID49IDAgPyB2KjIgOiB2Ki0yIC0gMSlcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY29uc3RhbnRzID0gZXhwb3J0cztcblxuLy8gSGVscGVyXG5jb25zdGFudHMuX3JldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKG1hcCkge1xuICBjb25zdCByZXMgPSB7fTtcblxuICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgLy8gQ29udmVydCBrZXkgdG8gaW50ZWdlciBpZiBpdCBpcyBzdHJpbmdpZmllZFxuICAgIGlmICgoa2V5IHwgMCkgPT0ga2V5KVxuICAgICAga2V5ID0ga2V5IHwgMDtcblxuICAgIGNvbnN0IHZhbHVlID0gbWFwW2tleV07XG4gICAgcmVzW3ZhbHVlXSA9IGtleTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmNvbnN0YW50cy5kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBlbmNvZGVycyA9IHJlcXVpcmUoJy4vZW5jb2RlcnMnKTtcbmNvbnN0IGRlY29kZXJzID0gcmVxdWlyZSgnLi9kZWNvZGVycycpO1xuY29uc3QgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5jb25zdCBhcGkgPSBleHBvcnRzO1xuXG5hcGkuZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG5hbWUsIGJvZHkpIHtcbiAgcmV0dXJuIG5ldyBFbnRpdHkobmFtZSwgYm9keSk7XG59O1xuXG5mdW5jdGlvbiBFbnRpdHkobmFtZSwgYm9keSkge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gIHRoaXMuZGVjb2RlcnMgPSB7fTtcbiAgdGhpcy5lbmNvZGVycyA9IHt9O1xufVxuXG5FbnRpdHkucHJvdG90eXBlLl9jcmVhdGVOYW1lZCA9IGZ1bmN0aW9uIGNyZWF0ZU5hbWVkKEJhc2UpIHtcbiAgY29uc3QgbmFtZSA9IHRoaXMubmFtZTtcblxuICBmdW5jdGlvbiBHZW5lcmF0ZWQoZW50aXR5KSB7XG4gICAgdGhpcy5faW5pdE5hbWVkKGVudGl0eSwgbmFtZSk7XG4gIH1cbiAgaW5oZXJpdHMoR2VuZXJhdGVkLCBCYXNlKTtcbiAgR2VuZXJhdGVkLnByb3RvdHlwZS5faW5pdE5hbWVkID0gZnVuY3Rpb24gX2luaXROYW1lZChlbnRpdHksIG5hbWUpIHtcbiAgICBCYXNlLmNhbGwodGhpcywgZW50aXR5LCBuYW1lKTtcbiAgfTtcblxuICByZXR1cm4gbmV3IEdlbmVyYXRlZCh0aGlzKTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuX2dldERlY29kZXIgPSBmdW5jdGlvbiBfZ2V0RGVjb2RlcihlbmMpIHtcbiAgZW5jID0gZW5jIHx8ICdkZXInO1xuICAvLyBMYXppbHkgY3JlYXRlIGRlY29kZXJcbiAgaWYgKCF0aGlzLmRlY29kZXJzLmhhc093blByb3BlcnR5KGVuYykpXG4gICAgdGhpcy5kZWNvZGVyc1tlbmNdID0gdGhpcy5fY3JlYXRlTmFtZWQoZGVjb2RlcnNbZW5jXSk7XG4gIHJldHVybiB0aGlzLmRlY29kZXJzW2VuY107XG59O1xuXG5FbnRpdHkucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShkYXRhLCBlbmMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuX2dldERlY29kZXIoZW5jKS5kZWNvZGUoZGF0YSwgb3B0aW9ucyk7XG59O1xuXG5FbnRpdHkucHJvdG90eXBlLl9nZXRFbmNvZGVyID0gZnVuY3Rpb24gX2dldEVuY29kZXIoZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAnZGVyJztcbiAgLy8gTGF6aWx5IGNyZWF0ZSBlbmNvZGVyXG4gIGlmICghdGhpcy5lbmNvZGVycy5oYXNPd25Qcm9wZXJ0eShlbmMpKVxuICAgIHRoaXMuZW5jb2RlcnNbZW5jXSA9IHRoaXMuX2NyZWF0ZU5hbWVkKGVuY29kZXJzW2VuY10pO1xuICByZXR1cm4gdGhpcy5lbmNvZGVyc1tlbmNdO1xufTtcblxuRW50aXR5LnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZGF0YSwgZW5jLCAvKiBpbnRlcm5hbCAqLyByZXBvcnRlcikge1xuICByZXR1cm4gdGhpcy5fZ2V0RW5jb2RlcihlbmMpLmVuY29kZShkYXRhLCByZXBvcnRlcik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBiYXNlID0gZXhwb3J0cztcblxuYmFzZS5SZXBvcnRlciA9IHJlcXVpcmUoJy4vcmVwb3J0ZXInKS5SZXBvcnRlcjtcbmJhc2UuRGVjb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJykuRGVjb2RlckJ1ZmZlcjtcbmJhc2UuRW5jb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJykuRW5jb2RlckJ1ZmZlcjtcbmJhc2UuTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBlbmNvZGVycyA9IGV4cG9ydHM7XG5cbmVuY29kZXJzLmRlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG5lbmNvZGVycy5wZW0gPSByZXF1aXJlKCcuL3BlbScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkZWNvZGVycyA9IGV4cG9ydHM7XG5cbmRlY29kZXJzLmRlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG5kZWNvZGVycy5wZW0gPSByZXF1aXJlKCcuL3BlbScpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMudG9DYWxsYmFjayA9IChkb1dvcmspID0+IHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpbnB1dCwgY2FsbGJhY2spIHtcbiAgICBsZXQgcmVzXG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IGRvV29yayhpbnB1dClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIGVycilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG51bGwsIHJlcylcbiAgfVxufVxuXG5leHBvcnRzLnRvQnVmID0gKGRvV29yaywgb3RoZXIpID0+IChpbnB1dCkgPT4ge1xuICBsZXQgcmVzdWx0ID0gZG9Xb3JrKGlucHV0LCBvdGhlcilcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHJlc3VsdCwgJ2hleCcpXG59XG5cbmV4cG9ydHMuZnJvbVN0cmluZyA9IChkb1dvcmssIG90aGVyKSA9PiAoX2lucHV0KSA9PiB7XG4gIGNvbnN0IGlucHV0ID0gQnVmZmVyLmlzQnVmZmVyKF9pbnB1dCkgPyBfaW5wdXQudG9TdHJpbmcoKSA6IF9pbnB1dFxuICByZXR1cm4gZG9Xb3JrKGlucHV0LCBvdGhlcilcbn1cblxuZXhwb3J0cy5mcm9tTnVtYmVyVG8zMkJpdEJ1ZiA9IChkb1dvcmssIG90aGVyKSA9PiAoaW5wdXQpID0+IHtcbiAgbGV0IG51bWJlciA9IGRvV29yayhpbnB1dCwgb3RoZXIpXG4gIGNvbnN0IGJ5dGVzID0gbmV3IEFycmF5KDQpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBieXRlc1tpXSA9IG51bWJlciAmIDB4ZmZcbiAgICBudW1iZXIgPSBudW1iZXIgPj4gOFxuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzKVxufVxuIiwiLyogZ2xvYmFsIHNlbGYgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG5vZGVpZnkgPSByZXF1aXJlKCdub2RlaWZ5JylcblxuY29uc3Qgd2ViQ3J5cHRvID0gZ2V0V2ViQ3J5cHRvKClcblxuZnVuY3Rpb24gZ2V0V2ViQ3J5cHRvICgpIHtcbiAgaWYgKHNlbGYuY3J5cHRvKSB7XG4gICAgcmV0dXJuIHNlbGYuY3J5cHRvLnN1YnRsZSB8fCBzZWxmLmNyeXB0by53ZWJraXRTdWJ0bGVcbiAgfVxuXG4gIGlmIChzZWxmLm1zQ3J5cHRvKSB7XG4gICAgcmV0dXJuIHNlbGYubXNDcnlwdG8uc3VidGxlXG4gIH1cbn1cblxuZnVuY3Rpb24gd2ViQ3J5cHRvSGFzaCAodHlwZSkge1xuICBpZiAoIXdlYkNyeXB0bykge1xuICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHVzZSBhIGJyb3dzZXIgd2l0aCB3ZWJjcnlwdG8gc3VwcG9ydCBhbmQgZW5zdXJlIHRoZSBjb2RlIGhhcyBiZWVuIGRlbGl2ZXJlZCBzZWN1cmVseSB2aWEgSFRUUFMvVExTIGFuZCBydW4gd2l0aGluIGEgU2VjdXJlIENvbnRleHQnKVxuICB9XG5cbiAgcmV0dXJuIChkYXRhLCBjYWxsYmFjaykgPT4ge1xuICAgIGNvbnN0IHJlcyA9IHdlYkNyeXB0by5kaWdlc3QoeyBuYW1lOiB0eXBlIH0sIGRhdGEpXG5cbiAgICBpZiAodHlwZW9mIHJlcy50aGVuICE9PSAnZnVuY3Rpb24nKSB7IC8vIElFMTFcbiAgICAgIHJlcy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoYGhhc2hpbmcgZGF0YSB1c2luZyAke3R5cGV9YCkpXG4gICAgICB9XG4gICAgICByZXMub25jb21wbGV0ZSA9IChlKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGUudGFyZ2V0LnJlc3VsdClcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIG5vZGVpZnkoXG4gICAgICByZXMudGhlbigocmF3KSA9PiBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShyYXcpKSksXG4gICAgICBjYWxsYmFja1xuICAgIClcbiAgfVxufVxuXG5mdW5jdGlvbiBzaGExIChidWYsIGNhbGxiYWNrKSB7XG4gIHdlYkNyeXB0b0hhc2goJ1NIQS0xJykoYnVmLCBjYWxsYmFjaylcbn1cblxuZnVuY3Rpb24gc2hhMjI1NiAoYnVmLCBjYWxsYmFjaykge1xuICB3ZWJDcnlwdG9IYXNoKCdTSEEtMjU2JykoYnVmLCBjYWxsYmFjaylcbn1cblxuZnVuY3Rpb24gc2hhMjUxMiAoYnVmLCBjYWxsYmFjaykge1xuICB3ZWJDcnlwdG9IYXNoKCdTSEEtNTEyJykoYnVmLCBjYWxsYmFjaylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNoYTE6IHNoYTEsXG4gIHNoYTIyNTY6IHNoYTIyNTYsXG4gIHNoYTI1MTI6IHNoYTI1MTJcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBibGFrZSA9IHJlcXVpcmUoJ2JsYWtlanMnKVxuXG5jb25zdCB0b0NhbGxiYWNrID0gcmVxdWlyZSgnLi91dGlscycpLnRvQ2FsbGJhY2tcblxuY29uc3QgbWluQiA9IDB4YjIwMVxuY29uc3QgbWluUyA9IDB4YjI0MVxuXG5jb25zdCBibGFrZTJiID0ge1xuICBpbml0OiBibGFrZS5ibGFrZTJiSW5pdCxcbiAgdXBkYXRlOiBibGFrZS5ibGFrZTJiVXBkYXRlLFxuICBkaWdlc3Q6IGJsYWtlLmJsYWtlMmJGaW5hbFxufVxuXG5jb25zdCBibGFrZTJzID0ge1xuICBpbml0OiBibGFrZS5ibGFrZTJzSW5pdCxcbiAgdXBkYXRlOiBibGFrZS5ibGFrZTJzVXBkYXRlLFxuICBkaWdlc3Q6IGJsYWtlLmJsYWtlMnNGaW5hbFxufVxuXG5jb25zdCBtYWtlQjJIYXNoID0gKHNpemUsIGhmKSA9PiB0b0NhbGxiYWNrKChidWYpID0+IHtcbiAgY29uc3QgY3R4ID0gaGYuaW5pdChzaXplLCBudWxsKVxuICBoZi51cGRhdGUoY3R4LCBidWYpXG4gIHJldHVybiBCdWZmZXIuZnJvbShoZi5kaWdlc3QoY3R4KSlcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gKHRhYmxlKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgIHRhYmxlW21pbkIgKyBpXSA9IG1ha2VCMkhhc2goaSArIDEsIGJsYWtlMmIpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgdGFibGVbbWluUyArIGldID0gbWFrZUIySGFzaChpICsgMSwgYmxha2UycylcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKVxudmFyIEhtYWNEUkJHID0gcmVxdWlyZSgnZHJiZy5qcy9obWFjJylcbnZhciBtZXNzYWdlcyA9IHJlcXVpcmUoJy4uL21lc3NhZ2VzLmpzb24nKVxudmFyIEJOID0gcmVxdWlyZSgnLi9ibicpXG52YXIgRUNQb2ludCA9IHJlcXVpcmUoJy4vZWNwb2ludCcpXG52YXIgZyA9IHJlcXVpcmUoJy4vZWNwb2ludGcnKVxuXG5leHBvcnRzLnByaXZhdGVLZXlWZXJpZnkgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICB2YXIgYm4gPSBCTi5mcm9tQnVmZmVyKHByaXZhdGVLZXkpXG4gIHJldHVybiAhKGJuLmlzT3ZlcmZsb3coKSB8fCBibi5pc1plcm8oKSlcbn1cblxuZXhwb3J0cy5wcml2YXRlS2V5RXhwb3J0ID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgdmFyIGQgPSBCTi5mcm9tQnVmZmVyKHByaXZhdGVLZXkpXG4gIGlmIChkLmlzT3ZlcmZsb3coKSB8fCBkLmlzWmVybygpKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfRVhQT1JUX0RFUl9GQUlMKVxuXG4gIHJldHVybiBnLm11bChkKS50b1B1YmxpY0tleShjb21wcmVzc2VkKVxufVxuXG5leHBvcnRzLnByaXZhdGVLZXlOZWdhdGUgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICB2YXIgYm4gPSBCTi5mcm9tQnVmZmVyKHByaXZhdGVLZXkpXG4gIGlmIChibi5pc1plcm8oKSkgcmV0dXJuIEJ1ZmZlci5hbGxvYygzMilcblxuICBpZiAoYm4udWNtcChCTi5uKSA+IDApIGJuLmlzdWIoQk4ubilcbiAgcmV0dXJuIEJOLm4uc3ViKGJuKS50b0J1ZmZlcigpXG59XG5cbmV4cG9ydHMucHJpdmF0ZUtleU1vZEludmVyc2UgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICB2YXIgYm4gPSBCTi5mcm9tQnVmZmVyKHByaXZhdGVLZXkpXG4gIGlmIChibi5pc092ZXJmbG93KCkgfHwgYm4uaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9SQU5HRV9JTlZBTElEKVxuXG4gIHJldHVybiBibi51aW52bSgpLnRvQnVmZmVyKClcbn1cblxuZXhwb3J0cy5wcml2YXRlS2V5VHdlYWtBZGQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgdHdlYWspIHtcbiAgdmFyIGJuID0gQk4uZnJvbUJ1ZmZlcih0d2VhaylcbiAgaWYgKGJuLmlzT3ZlcmZsb3coKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RXRUFLX0FERF9GQUlMKVxuXG4gIGJuLmlhZGQoQk4uZnJvbUJ1ZmZlcihwcml2YXRlS2V5KSlcbiAgaWYgKGJuLmlzT3ZlcmZsb3coKSkgYm4uaXN1YihCTi5uKVxuICBpZiAoYm4uaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UV0VBS19BRERfRkFJTClcblxuICByZXR1cm4gYm4udG9CdWZmZXIoKVxufVxuXG5leHBvcnRzLnByaXZhdGVLZXlUd2Vha011bCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCB0d2Vhaykge1xuICB2YXIgYm4gPSBCTi5mcm9tQnVmZmVyKHR3ZWFrKVxuICBpZiAoYm4uaXNPdmVyZmxvdygpIHx8IGJuLmlzWmVybygpKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfVFdFQUtfTVVMX0ZBSUwpXG5cbiAgdmFyIGQgPSBCTi5mcm9tQnVmZmVyKHByaXZhdGVLZXkpXG4gIHJldHVybiBibi51bXVsKGQpLnVyZWR1Y2UoKS50b0J1ZmZlcigpXG59XG5cbmV4cG9ydHMucHVibGljS2V5Q3JlYXRlID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgdmFyIGQgPSBCTi5mcm9tQnVmZmVyKHByaXZhdGVLZXkpXG4gIGlmIChkLmlzT3ZlcmZsb3coKSB8fCBkLmlzWmVybygpKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9DUkVBVEVfRkFJTClcblxuICByZXR1cm4gZy5tdWwoZCkudG9QdWJsaWNLZXkoY29tcHJlc3NlZClcbn1cblxuZXhwb3J0cy5wdWJsaWNLZXlDb252ZXJ0ID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgY29tcHJlc3NlZCkge1xuICB2YXIgcG9pbnQgPSBFQ1BvaW50LmZyb21QdWJsaWNLZXkocHVibGljS2V5KVxuICBpZiAocG9pbnQgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1BBUlNFX0ZBSUwpXG5cbiAgcmV0dXJuIHBvaW50LnRvUHVibGljS2V5KGNvbXByZXNzZWQpXG59XG5cbmV4cG9ydHMucHVibGljS2V5VmVyaWZ5ID0gZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICByZXR1cm4gRUNQb2ludC5mcm9tUHVibGljS2V5KHB1YmxpY0tleSkgIT09IG51bGxcbn1cblxuZXhwb3J0cy5wdWJsaWNLZXlUd2Vha0FkZCA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKSB7XG4gIHZhciBwb2ludCA9IEVDUG9pbnQuZnJvbVB1YmxpY0tleShwdWJsaWNLZXkpXG4gIGlmIChwb2ludCA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfUEFSU0VfRkFJTClcblxuICB0d2VhayA9IEJOLmZyb21CdWZmZXIodHdlYWspXG4gIGlmICh0d2Vhay5pc092ZXJmbG93KCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1RXRUFLX0FERF9GQUlMKVxuXG4gIHZhciByZXN1bHQgPSBnLm11bCh0d2VhaykuYWRkKHBvaW50KVxuICBpZiAocmVzdWx0LmluZikgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFdFQUtfQUREX0ZBSUwpXG5cbiAgcmV0dXJuIHJlc3VsdC50b1B1YmxpY0tleShjb21wcmVzc2VkKVxufVxuXG5leHBvcnRzLnB1YmxpY0tleVR3ZWFrTXVsID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpIHtcbiAgdmFyIHBvaW50ID0gRUNQb2ludC5mcm9tUHVibGljS2V5KHB1YmxpY0tleSlcbiAgaWYgKHBvaW50ID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9QQVJTRV9GQUlMKVxuXG4gIHR3ZWFrID0gQk4uZnJvbUJ1ZmZlcih0d2VhaylcbiAgaWYgKHR3ZWFrLmlzT3ZlcmZsb3coKSB8fCB0d2Vhay5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFdFQUtfTVVMX0ZBSUwpXG5cbiAgcmV0dXJuIHBvaW50Lm11bCh0d2VhaykudG9QdWJsaWNLZXkoY29tcHJlc3NlZClcbn1cblxuZXhwb3J0cy5wdWJsaWNLZXlDb21iaW5lID0gZnVuY3Rpb24gKHB1YmxpY0tleXMsIGNvbXByZXNzZWQpIHtcbiAgdmFyIHBvaW50cyA9IG5ldyBBcnJheShwdWJsaWNLZXlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdWJsaWNLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgcG9pbnRzW2ldID0gRUNQb2ludC5mcm9tUHVibGljS2V5KHB1YmxpY0tleXNbaV0pXG4gICAgaWYgKHBvaW50c1tpXSA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfUEFSU0VfRkFJTClcbiAgfVxuXG4gIHZhciBwb2ludCA9IHBvaW50c1swXVxuICBmb3IgKHZhciBqID0gMTsgaiA8IHBvaW50cy5sZW5ndGg7ICsraikgcG9pbnQgPSBwb2ludC5hZGQocG9pbnRzW2pdKVxuICBpZiAocG9pbnQuaW5mKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9DT01CSU5FX0ZBSUwpXG5cbiAgcmV0dXJuIHBvaW50LnRvUHVibGljS2V5KGNvbXByZXNzZWQpXG59XG5cbmV4cG9ydHMuc2lnbmF0dXJlTm9ybWFsaXplID0gZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICB2YXIgciA9IEJOLmZyb21CdWZmZXIoc2lnbmF0dXJlLnNsaWNlKDAsIDMyKSlcbiAgdmFyIHMgPSBCTi5mcm9tQnVmZmVyKHNpZ25hdHVyZS5zbGljZSgzMiwgNjQpKVxuICBpZiAoci5pc092ZXJmbG93KCkgfHwgcy5pc092ZXJmbG93KCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfUEFSU0VfRkFJTClcblxuICB2YXIgcmVzdWx0ID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlKVxuICBpZiAocy5pc0hpZ2goKSkgQk4ubi5zdWIocykudG9CdWZmZXIoKS5jb3B5KHJlc3VsdCwgMzIpXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnRzLnNpZ25hdHVyZUV4cG9ydCA9IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgdmFyIHIgPSBzaWduYXR1cmUuc2xpY2UoMCwgMzIpXG4gIHZhciBzID0gc2lnbmF0dXJlLnNsaWNlKDMyLCA2NClcbiAgaWYgKEJOLmZyb21CdWZmZXIocikuaXNPdmVyZmxvdygpIHx8IEJOLmZyb21CdWZmZXIocykuaXNPdmVyZmxvdygpKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1BBUlNFX0ZBSUwpXG5cbiAgcmV0dXJuIHsgcjogciwgczogcyB9XG59XG5cbmV4cG9ydHMuc2lnbmF0dXJlSW1wb3J0ID0gZnVuY3Rpb24gKHNpZ09iaikge1xuICB2YXIgciA9IEJOLmZyb21CdWZmZXIoc2lnT2JqLnIpXG4gIGlmIChyLmlzT3ZlcmZsb3coKSkgciA9IEJOLmZyb21OdW1iZXIoMClcblxuICB2YXIgcyA9IEJOLmZyb21CdWZmZXIoc2lnT2JqLnMpXG4gIGlmIChzLmlzT3ZlcmZsb3coKSkgcyA9IEJOLmZyb21OdW1iZXIoMClcblxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbci50b0J1ZmZlcigpLCBzLnRvQnVmZmVyKCldKVxufVxuXG5leHBvcnRzLnNpZ24gPSBmdW5jdGlvbiAobWVzc2FnZSwgcHJpdmF0ZUtleSwgbm9uY2VmbiwgZGF0YSkge1xuICB2YXIgZCA9IEJOLmZyb21CdWZmZXIocHJpdmF0ZUtleSlcbiAgaWYgKGQuaXNPdmVyZmxvdygpIHx8IGQuaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOX0ZBSUwpXG5cbiAgaWYgKG5vbmNlZm4gPT09IG51bGwpIHtcbiAgICB2YXIgZHJiZyA9IG5ldyBIbWFjRFJCRygnc2hhMjU2JywgcHJpdmF0ZUtleSwgbWVzc2FnZSwgZGF0YSlcbiAgICBub25jZWZuID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZHJiZy5nZW5lcmF0ZSgzMikgfVxuICB9XG5cbiAgdmFyIGJuTWVzc2FnZSA9IEJOLmZyb21CdWZmZXIobWVzc2FnZSlcbiAgZm9yICh2YXIgY291bnQgPSAwOyA7ICsrY291bnQpIHtcbiAgICB2YXIgbm9uY2UgPSBub25jZWZuKG1lc3NhZ2UsIHByaXZhdGVLZXksIG51bGwsIGRhdGEsIGNvdW50KVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKG5vbmNlKSB8fCBub25jZS5sZW5ndGggIT09IDMyKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNEU0FfU0lHTl9GQUlMKVxuXG4gICAgdmFyIGsgPSBCTi5mcm9tQnVmZmVyKG5vbmNlKVxuICAgIGlmIChrLmlzT3ZlcmZsb3coKSB8fCBrLmlzWmVybygpKSBjb250aW51ZVxuXG4gICAgdmFyIGtwID0gZy5tdWwoaylcbiAgICB2YXIgciA9IGtwLnguZmlyZWR1Y2UoKVxuICAgIGlmIChyLmlzWmVybygpKSBjb250aW51ZVxuXG4gICAgdmFyIHMgPSBrLnVpbnZtKCkudW11bChyLnVtdWwoZCkudXJlZHVjZSgpLmlhZGQoYm5NZXNzYWdlKS5maXJlZHVjZSgpKS51cmVkdWNlKClcbiAgICBpZiAocy5pc1plcm8oKSkgY29udGludWVcblxuICAgIHZhciByZWNvdmVyeSA9IChrcC54LnVjbXAocikgIT09IDAgPyAyIDogMCkgfCAoa3AueS5pc09kZCgpID8gMSA6IDApXG4gICAgaWYgKHMuaXNIaWdoKCkpIHtcbiAgICAgIHMgPSBCTi5uLnN1YihzKVxuICAgICAgcmVjb3ZlcnkgXj0gMVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzaWduYXR1cmU6IEJ1ZmZlci5jb25jYXQoW3IudG9CdWZmZXIoKSwgcy50b0J1ZmZlcigpXSksXG4gICAgICByZWNvdmVyeTogcmVjb3ZlcnlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy52ZXJpZnkgPSBmdW5jdGlvbiAobWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpIHtcbiAgdmFyIHNpZ3IgPSBCTi5mcm9tQnVmZmVyKHNpZ25hdHVyZS5zbGljZSgwLCAzMikpXG4gIHZhciBzaWdzID0gQk4uZnJvbUJ1ZmZlcihzaWduYXR1cmUuc2xpY2UoMzIsIDY0KSlcbiAgaWYgKHNpZ3IuaXNPdmVyZmxvdygpIHx8IHNpZ3MuaXNPdmVyZmxvdygpKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1BBUlNFX0ZBSUwpXG5cbiAgaWYgKHNpZ3MuaXNIaWdoKCkgfHwgc2lnci5pc1plcm8oKSB8fCBzaWdzLmlzWmVybygpKSByZXR1cm4gZmFsc2VcblxuICB2YXIgcHViID0gRUNQb2ludC5mcm9tUHVibGljS2V5KHB1YmxpY0tleSlcbiAgaWYgKHB1YiA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfUEFSU0VfRkFJTClcblxuICB2YXIgc2ludiA9IHNpZ3MudWludm0oKVxuICB2YXIgdTEgPSBzaW52LnVtdWwoQk4uZnJvbUJ1ZmZlcihtZXNzYWdlKSkudXJlZHVjZSgpXG4gIHZhciB1MiA9IHNpbnYudW11bChzaWdyKS51cmVkdWNlKClcbiAgdmFyIHBvaW50ID0gZy5tdWxBZGQodTEsIHB1YiwgdTIpXG4gIGlmIChwb2ludC5pbmYpIHJldHVybiBmYWxzZVxuXG4gIC8vIHJldHVybiBFQ1BvaW50LmZyb21FQ0pQb2ludChwb2ludCkueC5maXJlZHVjZSgpLnVjbXAoc2lncikgPT09IDBcbiAgLy8gSW52ZXJzaW9uLWZyZWVcbiAgdmFyIHoyID0gcG9pbnQuei5yZWRTcXIoKVxuICBpZiAoc2lnci5yZWRNdWwoejIpLnVjbXAocG9pbnQueCkgPT09IDApIHJldHVybiB0cnVlXG4gIGlmIChzaWdyLnVjbXAoQk4ucHNuKSA+PSAwKSByZXR1cm4gZmFsc2VcblxuICByZXR1cm4gc2lnci5pYWRkKEJOLnBzbikucmVkTXVsKHoyKS51Y21wKHBvaW50LngpID09PSAwXG59XG5cbmV4cG9ydHMucmVjb3ZlciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBzaWduYXR1cmUsIHJlY292ZXJ5LCBjb21wcmVzc2VkKSB7XG4gIHZhciBzaWdyID0gQk4uZnJvbUJ1ZmZlcihzaWduYXR1cmUuc2xpY2UoMCwgMzIpKVxuICB2YXIgc2lncyA9IEJOLmZyb21CdWZmZXIoc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCkpXG4gIGlmIChzaWdyLmlzT3ZlcmZsb3coKSB8fCBzaWdzLmlzT3ZlcmZsb3coKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9QQVJTRV9GQUlMKVxuXG4gIGRvIHtcbiAgICBpZiAoc2lnci5pc1plcm8oKSB8fCBzaWdzLmlzWmVybygpKSBicmVha1xuXG4gICAgdmFyIGtweCA9IHNpZ3JcbiAgICBpZiAocmVjb3ZlcnkgPj4gMSkge1xuICAgICAgaWYgKGtweC51Y21wKEJOLnBzbikgPj0gMCkgYnJlYWtcbiAgICAgIGtweCA9IHNpZ3IuYWRkKEJOLm4pXG4gICAgfVxuXG4gICAgdmFyIGtwUHVibGljS2V5ID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzB4MDIgKyAocmVjb3ZlcnkgJiAweDAxKV0pLCBrcHgudG9CdWZmZXIoKV0pXG4gICAgdmFyIGtwID0gRUNQb2ludC5mcm9tUHVibGljS2V5KGtwUHVibGljS2V5KVxuICAgIGlmIChrcCA9PT0gbnVsbCkgYnJlYWtcblxuICAgIHZhciBySW52ID0gc2lnci51aW52bSgpXG4gICAgdmFyIHMxID0gQk4ubi5zdWIoQk4uZnJvbUJ1ZmZlcihtZXNzYWdlKSkudW11bChySW52KS51cmVkdWNlKClcbiAgICB2YXIgczIgPSBzaWdzLnVtdWwockludikudXJlZHVjZSgpXG4gICAgdmFyIHBvaW50ID0gRUNQb2ludC5mcm9tRUNKUG9pbnQoZy5tdWxBZGQoczEsIGtwLCBzMikpXG4gICAgcmV0dXJuIHBvaW50LnRvUHVibGljS2V5KGNvbXByZXNzZWQpXG4gIH0gd2hpbGUgKGZhbHNlKVxuXG4gIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9SRUNPVkVSX0ZBSUwpXG59XG5cbmV4cG9ydHMuZWNkaCA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHByaXZhdGVLZXkpIHtcbiAgdmFyIHNoYXJlZCA9IGV4cG9ydHMuZWNkaFVuc2FmZShwdWJsaWNLZXksIHByaXZhdGVLZXksIHRydWUpXG4gIHJldHVybiBjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoc2hhcmVkKS5kaWdlc3QoKVxufVxuXG5leHBvcnRzLmVjZGhVbnNhZmUgPSBmdW5jdGlvbiAocHVibGljS2V5LCBwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIHZhciBwb2ludCA9IEVDUG9pbnQuZnJvbVB1YmxpY0tleShwdWJsaWNLZXkpXG4gIGlmIChwb2ludCA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfUEFSU0VfRkFJTClcblxuICB2YXIgc2NhbGFyID0gQk4uZnJvbUJ1ZmZlcihwcml2YXRlS2V5KVxuICBpZiAoc2NhbGFyLmlzT3ZlcmZsb3coKSB8fCBzY2FsYXIuaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RIX0ZBSUwpXG5cbiAgcmV0dXJuIHBvaW50Lm11bChzY2FsYXIpLnRvUHVibGljS2V5KGNvbXByZXNzZWQpXG59XG4iLCIvKiBqc2hpbnQgLVcwODY6IHRydWUgKi9cbi8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuLy8gfCBtdXJtdXJIYXNoM2pzLmpzIHYzLjAuMSAvLyBodHRwczovL2dpdGh1Yi5jb20vcGlkL211cm11ckhhc2gzanNcbi8vIHwgQSBqYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIE11cm11ckhhc2gzJ3MgeDg2IGhhc2hpbmcgYWxnb3JpdGhtcy4gfFxuLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4vLyB8IENvcHlyaWdodCAoYykgMjAxMi0yMDE1IEthcmFuIEx5b25zICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuLy8gfCBodHRwczovL2dpdGh1Yi5jb20va2FyYW5seW9ucy9tdXJtdXJIYXNoMy5qcy9ibG9iL2MxNzc4Zjc1NzkyYWJlZjdiZGQ3NGJjODVkMmQ0ZTFhM2QyNWNmZTkvbXVybXVySGFzaDMuanMgfFxuLy8gfCBGcmVlbHkgZGlzdHJpYnV0YWJsZSB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4vLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcblxuOyhmdW5jdGlvbiAocm9vdCwgdW5kZWZpbmVkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gQ3JlYXRlIGEgbG9jYWwgb2JqZWN0IHRoYXQnbGwgYmUgZXhwb3J0ZWQgb3IgcmVmZXJlbmNlZCBnbG9iYWxseS5cbiAgICB2YXIgbGlicmFyeSA9IHtcbiAgICAgICAgJ3ZlcnNpb24nOiAnMy4wLjAnLFxuICAgICAgICAneDg2Jzoge30sXG4gICAgICAgICd4NjQnOiB7fSxcbiAgICAgICAgJ2lucHV0VmFsaWRhdGlvbic6IHRydWVcbiAgICB9O1xuXG4gICAgLy8gUFJJVkFURSBGVU5DVElPTlNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZnVuY3Rpb24gX3ZhbGlkQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgLy8gY2hlY2sgdGhlIGlucHV0IGlzIGFuIGFycmF5IG9yIGEgdHlwZWQgYXJyYXlcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGJ5dGVzKSAmJiAhQXJyYXlCdWZmZXIuaXNWaWV3KGJ5dGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgYWxsIGJ5dGVzIGFyZSBhY3R1YWxseSBieXRlc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYnl0ZXNbaV0pIHx8IGJ5dGVzW2ldIDwgMCB8fCBieXRlc1tpXSA+IDI1NSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfeDg2TXVsdGlwbHkobSwgbikge1xuICAgICAgICAvL1xuICAgICAgICAvLyBHaXZlbiB0d28gMzJiaXQgaW50cywgcmV0dXJucyB0aGUgdHdvIG11bHRpcGxpZWQgdG9nZXRoZXIgYXMgYVxuICAgICAgICAvLyAzMmJpdCBpbnQuXG4gICAgICAgIC8vXG5cbiAgICAgICAgcmV0dXJuICgobSAmIDB4ZmZmZikgKiBuKSArICgoKChtID4+PiAxNikgKiBuKSAmIDB4ZmZmZikgPDwgMTYpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF94ODZSb3RsKG0sIG4pIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gYSAzMmJpdCBpbnQgYW5kIGFuIGludCByZXByZXNlbnRpbmcgYSBudW1iZXIgb2YgYml0IHBvc2l0aW9ucyxcbiAgICAgICAgLy8gcmV0dXJucyB0aGUgMzJiaXQgaW50IHJvdGF0ZWQgbGVmdCBieSB0aGF0IG51bWJlciBvZiBwb3NpdGlvbnMuXG4gICAgICAgIC8vXG5cbiAgICAgICAgcmV0dXJuIChtIDw8IG4pIHwgKG0gPj4+ICgzMiAtIG4pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfeDg2Rm1peChoKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdpdmVuIGEgYmxvY2ssIHJldHVybnMgbXVybXVySGFzaDMncyBmaW5hbCB4ODYgbWl4IG9mIHRoYXQgYmxvY2suXG4gICAgICAgIC8vXG5cbiAgICAgICAgaCBePSBoID4+PiAxNjtcbiAgICAgICAgaCA9IF94ODZNdWx0aXBseShoLCAweDg1ZWJjYTZiKTtcbiAgICAgICAgaCBePSBoID4+PiAxMztcbiAgICAgICAgaCA9IF94ODZNdWx0aXBseShoLCAweGMyYjJhZTM1KTtcbiAgICAgICAgaCBePSBoID4+PiAxNjtcblxuICAgICAgICByZXR1cm4gaDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfeDY0QWRkKG0sIG4pIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gdHdvIDY0Yml0IGludHMgKGFzIGFuIGFycmF5IG9mIHR3byAzMmJpdCBpbnRzKSByZXR1cm5zIHRoZSB0d29cbiAgICAgICAgLy8gYWRkZWQgdG9nZXRoZXIgYXMgYSA2NGJpdCBpbnQgKGFzIGFuIGFycmF5IG9mIHR3byAzMmJpdCBpbnRzKS5cbiAgICAgICAgLy9cblxuICAgICAgICBtID0gW21bMF0gPj4+IDE2LCBtWzBdICYgMHhmZmZmLCBtWzFdID4+PiAxNiwgbVsxXSAmIDB4ZmZmZl07XG4gICAgICAgIG4gPSBbblswXSA+Pj4gMTYsIG5bMF0gJiAweGZmZmYsIG5bMV0gPj4+IDE2LCBuWzFdICYgMHhmZmZmXTtcbiAgICAgICAgdmFyIG8gPSBbMCwgMCwgMCwgMF07XG5cbiAgICAgICAgb1szXSArPSBtWzNdICsgblszXTtcbiAgICAgICAgb1syXSArPSBvWzNdID4+PiAxNjtcbiAgICAgICAgb1szXSAmPSAweGZmZmY7XG5cbiAgICAgICAgb1syXSArPSBtWzJdICsgblsyXTtcbiAgICAgICAgb1sxXSArPSBvWzJdID4+PiAxNjtcbiAgICAgICAgb1syXSAmPSAweGZmZmY7XG5cbiAgICAgICAgb1sxXSArPSBtWzFdICsgblsxXTtcbiAgICAgICAgb1swXSArPSBvWzFdID4+PiAxNjtcbiAgICAgICAgb1sxXSAmPSAweGZmZmY7XG5cbiAgICAgICAgb1swXSArPSBtWzBdICsgblswXTtcbiAgICAgICAgb1swXSAmPSAweGZmZmY7XG5cbiAgICAgICAgcmV0dXJuIFsob1swXSA8PCAxNikgfCBvWzFdLCAob1syXSA8PCAxNikgfCBvWzNdXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfeDY0TXVsdGlwbHkobSwgbikge1xuICAgICAgICAvL1xuICAgICAgICAvLyBHaXZlbiB0d28gNjRiaXQgaW50cyAoYXMgYW4gYXJyYXkgb2YgdHdvIDMyYml0IGludHMpIHJldHVybnMgdGhlIHR3b1xuICAgICAgICAvLyBtdWx0aXBsaWVkIHRvZ2V0aGVyIGFzIGEgNjRiaXQgaW50IChhcyBhbiBhcnJheSBvZiB0d28gMzJiaXQgaW50cykuXG4gICAgICAgIC8vXG5cbiAgICAgICAgbSA9IFttWzBdID4+PiAxNiwgbVswXSAmIDB4ZmZmZiwgbVsxXSA+Pj4gMTYsIG1bMV0gJiAweGZmZmZdO1xuICAgICAgICBuID0gW25bMF0gPj4+IDE2LCBuWzBdICYgMHhmZmZmLCBuWzFdID4+PiAxNiwgblsxXSAmIDB4ZmZmZl07XG4gICAgICAgIHZhciBvID0gWzAsIDAsIDAsIDBdO1xuXG4gICAgICAgIG9bM10gKz0gbVszXSAqIG5bM107XG4gICAgICAgIG9bMl0gKz0gb1szXSA+Pj4gMTY7XG4gICAgICAgIG9bM10gJj0gMHhmZmZmO1xuXG4gICAgICAgIG9bMl0gKz0gbVsyXSAqIG5bM107XG4gICAgICAgIG9bMV0gKz0gb1syXSA+Pj4gMTY7XG4gICAgICAgIG9bMl0gJj0gMHhmZmZmO1xuXG4gICAgICAgIG9bMl0gKz0gbVszXSAqIG5bMl07XG4gICAgICAgIG9bMV0gKz0gb1syXSA+Pj4gMTY7XG4gICAgICAgIG9bMl0gJj0gMHhmZmZmO1xuXG4gICAgICAgIG9bMV0gKz0gbVsxXSAqIG5bM107XG4gICAgICAgIG9bMF0gKz0gb1sxXSA+Pj4gMTY7XG4gICAgICAgIG9bMV0gJj0gMHhmZmZmO1xuXG4gICAgICAgIG9bMV0gKz0gbVsyXSAqIG5bMl07XG4gICAgICAgIG9bMF0gKz0gb1sxXSA+Pj4gMTY7XG4gICAgICAgIG9bMV0gJj0gMHhmZmZmO1xuXG4gICAgICAgIG9bMV0gKz0gbVszXSAqIG5bMV07XG4gICAgICAgIG9bMF0gKz0gb1sxXSA+Pj4gMTY7XG4gICAgICAgIG9bMV0gJj0gMHhmZmZmO1xuXG4gICAgICAgIG9bMF0gKz0gKG1bMF0gKiBuWzNdKSArIChtWzFdICogblsyXSkgKyAobVsyXSAqIG5bMV0pICsgKG1bM10gKiBuWzBdKTtcbiAgICAgICAgb1swXSAmPSAweGZmZmY7XG5cbiAgICAgICAgcmV0dXJuIFsob1swXSA8PCAxNikgfCBvWzFdLCAob1syXSA8PCAxNikgfCBvWzNdXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfeDY0Um90bChtLCBuKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdpdmVuIGEgNjRiaXQgaW50IChhcyBhbiBhcnJheSBvZiB0d28gMzJiaXQgaW50cykgYW5kIGFuIGludFxuICAgICAgICAvLyByZXByZXNlbnRpbmcgYSBudW1iZXIgb2YgYml0IHBvc2l0aW9ucywgcmV0dXJucyB0aGUgNjRiaXQgaW50IChhcyBhblxuICAgICAgICAvLyBhcnJheSBvZiB0d28gMzJiaXQgaW50cykgcm90YXRlZCBsZWZ0IGJ5IHRoYXQgbnVtYmVyIG9mIHBvc2l0aW9ucy5cbiAgICAgICAgLy9cblxuICAgICAgICBuICU9IDY0O1xuXG4gICAgICAgIGlmIChuID09PSAzMikge1xuICAgICAgICAgICAgcmV0dXJuIFttWzFdLCBtWzBdXTtcbiAgICAgICAgfSBlbHNlIGlmIChuIDwgMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBbKG1bMF0gPDwgbikgfCAobVsxXSA+Pj4gKDMyIC0gbikpLCAobVsxXSA8PCBuKSB8IChtWzBdID4+PiAoMzIgLSBuKSldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbiAtPSAzMjtcbiAgICAgICAgICAgIHJldHVybiBbKG1bMV0gPDwgbikgfCAobVswXSA+Pj4gKDMyIC0gbikpLCAobVswXSA8PCBuKSB8IChtWzFdID4+PiAoMzIgLSBuKSldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3g2NExlZnRTaGlmdChtLCBuKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdpdmVuIGEgNjRiaXQgaW50IChhcyBhbiBhcnJheSBvZiB0d28gMzJiaXQgaW50cykgYW5kIGFuIGludFxuICAgICAgICAvLyByZXByZXNlbnRpbmcgYSBudW1iZXIgb2YgYml0IHBvc2l0aW9ucywgcmV0dXJucyB0aGUgNjRiaXQgaW50IChhcyBhblxuICAgICAgICAvLyBhcnJheSBvZiB0d28gMzJiaXQgaW50cykgc2hpZnRlZCBsZWZ0IGJ5IHRoYXQgbnVtYmVyIG9mIHBvc2l0aW9ucy5cbiAgICAgICAgLy9cblxuICAgICAgICBuICU9IDY0O1xuXG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSBlbHNlIGlmIChuIDwgMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBbKG1bMF0gPDwgbikgfCAobVsxXSA+Pj4gKDMyIC0gbikpLCBtWzFdIDw8IG5dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFttWzFdIDw8IChuIC0gMzIpLCAwXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF94NjRYb3IobSwgbikge1xuICAgICAgICAvL1xuICAgICAgICAvLyBHaXZlbiB0d28gNjRiaXQgaW50cyAoYXMgYW4gYXJyYXkgb2YgdHdvIDMyYml0IGludHMpIHJldHVybnMgdGhlIHR3b1xuICAgICAgICAvLyB4b3JlZCB0b2dldGhlciBhcyBhIDY0Yml0IGludCAoYXMgYW4gYXJyYXkgb2YgdHdvIDMyYml0IGludHMpLlxuICAgICAgICAvL1xuXG4gICAgICAgIHJldHVybiBbbVswXSBeIG5bMF0sIG1bMV0gXiBuWzFdXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfeDY0Rm1peChoKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdpdmVuIGEgYmxvY2ssIHJldHVybnMgbXVybXVySGFzaDMncyBmaW5hbCB4NjQgbWl4IG9mIHRoYXQgYmxvY2suXG4gICAgICAgIC8vIChgWzAsIGhbMF0gPj4+IDFdYCBpcyBhIDMzIGJpdCB1bnNpZ25lZCByaWdodCBzaGlmdC4gVGhpcyBpcyB0aGVcbiAgICAgICAgLy8gb25seSBwbGFjZSB3aGVyZSB3ZSBuZWVkIHRvIHJpZ2h0IHNoaWZ0IDY0Yml0IGludHMuKVxuICAgICAgICAvL1xuXG4gICAgICAgIGggPSBfeDY0WG9yKGgsIFswLCBoWzBdID4+PiAxXSk7XG4gICAgICAgIGggPSBfeDY0TXVsdGlwbHkoaCwgWzB4ZmY1MWFmZDcsIDB4ZWQ1NThjY2RdKTtcbiAgICAgICAgaCA9IF94NjRYb3IoaCwgWzAsIGhbMF0gPj4+IDFdKTtcbiAgICAgICAgaCA9IF94NjRNdWx0aXBseShoLCBbMHhjNGNlYjlmZSwgMHgxYTg1ZWM1M10pO1xuICAgICAgICBoID0gX3g2NFhvcihoLCBbMCwgaFswXSA+Pj4gMV0pO1xuXG4gICAgICAgIHJldHVybiBoO1xuICAgIH1cblxuICAgIC8vIFBVQkxJQyBGVU5DVElPTlNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsaWJyYXJ5Lng4Ni5oYXNoMzIgPSBmdW5jdGlvbiAoYnl0ZXMsIHNlZWQpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gYSBzdHJpbmcgYW5kIGFuIG9wdGlvbmFsIHNlZWQgYXMgYW4gaW50LCByZXR1cm5zIGEgMzIgYml0IGhhc2hcbiAgICAgICAgLy8gdXNpbmcgdGhlIHg4NiBmbGF2b3Igb2YgTXVybXVySGFzaDMsIGFzIGFuIHVuc2lnbmVkIGludC5cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKGxpYnJhcnkuaW5wdXRWYWxpZGF0aW9uICYmICFfdmFsaWRCeXRlcyhieXRlcykpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc2VlZCA9IHNlZWQgfHwgMDtcblxuICAgICAgICB2YXIgcmVtYWluZGVyID0gYnl0ZXMubGVuZ3RoICUgNDtcbiAgICAgICAgdmFyIGJsb2NrcyA9IGJ5dGVzLmxlbmd0aCAtIHJlbWFpbmRlcjtcblxuICAgICAgICB2YXIgaDEgPSBzZWVkO1xuXG4gICAgICAgIHZhciBrMSA9IDA7XG5cbiAgICAgICAgdmFyIGMxID0gMHhjYzllMmQ1MTtcbiAgICAgICAgdmFyIGMyID0gMHgxYjg3MzU5MztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrczsgaSA9IGkgKyA0KSB7XG4gICAgICAgICAgICBrMSA9IChieXRlc1tpXSkgfCAoYnl0ZXNbaSArIDFdIDw8IDgpIHwgKGJ5dGVzW2kgKyAyXSA8PCAxNikgfCAoYnl0ZXNbaSArIDNdIDw8IDI0KTtcblxuICAgICAgICAgICAgazEgPSBfeDg2TXVsdGlwbHkoazEsIGMxKTtcbiAgICAgICAgICAgIGsxID0gX3g4NlJvdGwoazEsIDE1KTtcbiAgICAgICAgICAgIGsxID0gX3g4Nk11bHRpcGx5KGsxLCBjMik7XG5cbiAgICAgICAgICAgIGgxIF49IGsxO1xuICAgICAgICAgICAgaDEgPSBfeDg2Um90bChoMSwgMTMpO1xuICAgICAgICAgICAgaDEgPSBfeDg2TXVsdGlwbHkoaDEsIDUpICsgMHhlNjU0NmI2NDtcbiAgICAgICAgfVxuXG4gICAgICAgIGsxID0gMDtcblxuICAgICAgICBzd2l0Y2ggKHJlbWFpbmRlcikge1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGsxIF49IGJ5dGVzW2kgKyAyXSA8PCAxNjtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGsxIF49IGJ5dGVzW2kgKyAxXSA8PCA4O1xuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgazEgXj0gYnl0ZXNbaV07XG4gICAgICAgICAgICAgICAgazEgPSBfeDg2TXVsdGlwbHkoazEsIGMxKTtcbiAgICAgICAgICAgICAgICBrMSA9IF94ODZSb3RsKGsxLCAxNSk7XG4gICAgICAgICAgICAgICAgazEgPSBfeDg2TXVsdGlwbHkoazEsIGMyKTtcbiAgICAgICAgICAgICAgICBoMSBePSBrMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGgxIF49IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgaDEgPSBfeDg2Rm1peChoMSk7XG5cbiAgICAgICAgcmV0dXJuIGgxID4+PiAwO1xuICAgIH07XG5cbiAgICBsaWJyYXJ5Lng4Ni5oYXNoMTI4ID0gZnVuY3Rpb24gKGJ5dGVzLCBzZWVkKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdpdmVuIGEgc3RyaW5nIGFuZCBhbiBvcHRpb25hbCBzZWVkIGFzIGFuIGludCwgcmV0dXJucyBhIDEyOCBiaXRcbiAgICAgICAgLy8gaGFzaCB1c2luZyB0aGUgeDg2IGZsYXZvciBvZiBNdXJtdXJIYXNoMywgYXMgYW4gdW5zaWduZWQgaGV4LlxuICAgICAgICAvL1xuICAgICAgICBpZiAobGlicmFyeS5pbnB1dFZhbGlkYXRpb24gJiYgIV92YWxpZEJ5dGVzKGJ5dGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlZWQgPSBzZWVkIHx8IDA7XG4gICAgICAgIHZhciByZW1haW5kZXIgPSBieXRlcy5sZW5ndGggJSAxNjtcbiAgICAgICAgdmFyIGJsb2NrcyA9IGJ5dGVzLmxlbmd0aCAtIHJlbWFpbmRlcjtcblxuICAgICAgICB2YXIgaDEgPSBzZWVkO1xuICAgICAgICB2YXIgaDIgPSBzZWVkO1xuICAgICAgICB2YXIgaDMgPSBzZWVkO1xuICAgICAgICB2YXIgaDQgPSBzZWVkO1xuXG4gICAgICAgIHZhciBrMSA9IDA7XG4gICAgICAgIHZhciBrMiA9IDA7XG4gICAgICAgIHZhciBrMyA9IDA7XG4gICAgICAgIHZhciBrNCA9IDA7XG5cbiAgICAgICAgdmFyIGMxID0gMHgyMzliOTYxYjtcbiAgICAgICAgdmFyIGMyID0gMHhhYjBlOTc4OTtcbiAgICAgICAgdmFyIGMzID0gMHgzOGIzNGFlNTtcbiAgICAgICAgdmFyIGM0ID0gMHhhMWUzOGI5MztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrczsgaSA9IGkgKyAxNikge1xuICAgICAgICAgICAgazEgPSAoYnl0ZXNbaV0pIHwgKGJ5dGVzW2kgKyAxXSA8PCA4KSB8IChieXRlc1tpICsgMl0gPDwgMTYpIHwgKGJ5dGVzW2kgKyAzXSA8PCAyNCk7XG4gICAgICAgICAgICBrMiA9IChieXRlc1tpICsgNF0pIHwgKGJ5dGVzW2kgKyA1XSA8PCA4KSB8IChieXRlc1tpICsgNl0gPDwgMTYpIHwgKGJ5dGVzW2kgKyA3XSA8PCAyNCk7XG4gICAgICAgICAgICBrMyA9IChieXRlc1tpICsgOF0pIHwgKGJ5dGVzW2kgKyA5XSA8PCA4KSB8IChieXRlc1tpICsgMTBdIDw8IDE2KSB8IChieXRlc1tpICsgMTFdIDw8IDI0KTtcbiAgICAgICAgICAgIGs0ID0gKGJ5dGVzW2kgKyAxMl0pIHwgKGJ5dGVzW2kgKyAxM10gPDwgOCkgfCAoYnl0ZXNbaSArIDE0XSA8PCAxNikgfCAoYnl0ZXNbaSArIDE1XSA8PCAyNCk7XG5cbiAgICAgICAgICAgIGsxID0gX3g4Nk11bHRpcGx5KGsxLCBjMSk7XG4gICAgICAgICAgICBrMSA9IF94ODZSb3RsKGsxLCAxNSk7XG4gICAgICAgICAgICBrMSA9IF94ODZNdWx0aXBseShrMSwgYzIpO1xuICAgICAgICAgICAgaDEgXj0gazE7XG5cbiAgICAgICAgICAgIGgxID0gX3g4NlJvdGwoaDEsIDE5KTtcbiAgICAgICAgICAgIGgxICs9IGgyO1xuICAgICAgICAgICAgaDEgPSBfeDg2TXVsdGlwbHkoaDEsIDUpICsgMHg1NjFjY2QxYjtcblxuICAgICAgICAgICAgazIgPSBfeDg2TXVsdGlwbHkoazIsIGMyKTtcbiAgICAgICAgICAgIGsyID0gX3g4NlJvdGwoazIsIDE2KTtcbiAgICAgICAgICAgIGsyID0gX3g4Nk11bHRpcGx5KGsyLCBjMyk7XG4gICAgICAgICAgICBoMiBePSBrMjtcblxuICAgICAgICAgICAgaDIgPSBfeDg2Um90bChoMiwgMTcpO1xuICAgICAgICAgICAgaDIgKz0gaDM7XG4gICAgICAgICAgICBoMiA9IF94ODZNdWx0aXBseShoMiwgNSkgKyAweDBiY2FhNzQ3O1xuXG4gICAgICAgICAgICBrMyA9IF94ODZNdWx0aXBseShrMywgYzMpO1xuICAgICAgICAgICAgazMgPSBfeDg2Um90bChrMywgMTcpO1xuICAgICAgICAgICAgazMgPSBfeDg2TXVsdGlwbHkoazMsIGM0KTtcbiAgICAgICAgICAgIGgzIF49IGszO1xuXG4gICAgICAgICAgICBoMyA9IF94ODZSb3RsKGgzLCAxNSk7XG4gICAgICAgICAgICBoMyArPSBoNDtcbiAgICAgICAgICAgIGgzID0gX3g4Nk11bHRpcGx5KGgzLCA1KSArIDB4OTZjZDFjMzU7XG5cbiAgICAgICAgICAgIGs0ID0gX3g4Nk11bHRpcGx5KGs0LCBjNCk7XG4gICAgICAgICAgICBrNCA9IF94ODZSb3RsKGs0LCAxOCk7XG4gICAgICAgICAgICBrNCA9IF94ODZNdWx0aXBseShrNCwgYzEpO1xuICAgICAgICAgICAgaDQgXj0gazQ7XG5cbiAgICAgICAgICAgIGg0ID0gX3g4NlJvdGwoaDQsIDEzKTtcbiAgICAgICAgICAgIGg0ICs9IGgxO1xuICAgICAgICAgICAgaDQgPSBfeDg2TXVsdGlwbHkoaDQsIDUpICsgMHgzMmFjM2IxNztcbiAgICAgICAgfVxuXG4gICAgICAgIGsxID0gMDtcbiAgICAgICAgazIgPSAwO1xuICAgICAgICBrMyA9IDA7XG4gICAgICAgIGs0ID0gMDtcblxuICAgICAgICBzd2l0Y2ggKHJlbWFpbmRlcikge1xuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICBrNCBePSBieXRlc1tpICsgMTRdIDw8IDE2O1xuXG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIGs0IF49IGJ5dGVzW2kgKyAxM10gPDwgODtcblxuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICBrNCBePSBieXRlc1tpICsgMTJdO1xuICAgICAgICAgICAgICAgIGs0ID0gX3g4Nk11bHRpcGx5KGs0LCBjNCk7XG4gICAgICAgICAgICAgICAgazQgPSBfeDg2Um90bChrNCwgMTgpO1xuICAgICAgICAgICAgICAgIGs0ID0gX3g4Nk11bHRpcGx5KGs0LCBjMSk7XG4gICAgICAgICAgICAgICAgaDQgXj0gazQ7XG5cbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgazMgXj0gYnl0ZXNbaSArIDExXSA8PCAyNDtcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICBrMyBePSBieXRlc1tpICsgMTBdIDw8IDE2O1xuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgIGszIF49IGJ5dGVzW2kgKyA5XSA8PCA4O1xuXG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgazMgXj0gYnl0ZXNbaSArIDhdO1xuICAgICAgICAgICAgICAgIGszID0gX3g4Nk11bHRpcGx5KGszLCBjMyk7XG4gICAgICAgICAgICAgICAgazMgPSBfeDg2Um90bChrMywgMTcpO1xuICAgICAgICAgICAgICAgIGszID0gX3g4Nk11bHRpcGx5KGszLCBjNCk7XG4gICAgICAgICAgICAgICAgaDMgXj0gazM7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBrMiBePSBieXRlc1tpICsgN10gPDwgMjQ7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBrMiBePSBieXRlc1tpICsgNl0gPDwgMTY7XG5cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBrMiBePSBieXRlc1tpICsgNV0gPDwgODtcblxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGsyIF49IGJ5dGVzW2kgKyA0XTtcbiAgICAgICAgICAgICAgICBrMiA9IF94ODZNdWx0aXBseShrMiwgYzIpO1xuICAgICAgICAgICAgICAgIGsyID0gX3g4NlJvdGwoazIsIDE2KTtcbiAgICAgICAgICAgICAgICBrMiA9IF94ODZNdWx0aXBseShrMiwgYzMpO1xuICAgICAgICAgICAgICAgIGgyIF49IGsyO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgazEgXj0gYnl0ZXNbaSArIDNdIDw8IDI0O1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgazEgXj0gYnl0ZXNbaSArIDJdIDw8IDE2O1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgazEgXj0gYnl0ZXNbaSArIDFdIDw8IDg7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBrMSBePSBieXRlc1tpXTtcbiAgICAgICAgICAgICAgICBrMSA9IF94ODZNdWx0aXBseShrMSwgYzEpO1xuICAgICAgICAgICAgICAgIGsxID0gX3g4NlJvdGwoazEsIDE1KTtcbiAgICAgICAgICAgICAgICBrMSA9IF94ODZNdWx0aXBseShrMSwgYzIpO1xuICAgICAgICAgICAgICAgIGgxIF49IGsxO1xuICAgICAgICB9XG5cbiAgICAgICAgaDEgXj0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICBoMiBePSBieXRlcy5sZW5ndGg7XG4gICAgICAgIGgzIF49IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgaDQgXj0gYnl0ZXMubGVuZ3RoO1xuXG4gICAgICAgIGgxICs9IGgyO1xuICAgICAgICBoMSArPSBoMztcbiAgICAgICAgaDEgKz0gaDQ7XG4gICAgICAgIGgyICs9IGgxO1xuICAgICAgICBoMyArPSBoMTtcbiAgICAgICAgaDQgKz0gaDE7XG5cbiAgICAgICAgaDEgPSBfeDg2Rm1peChoMSk7XG4gICAgICAgIGgyID0gX3g4NkZtaXgoaDIpO1xuICAgICAgICBoMyA9IF94ODZGbWl4KGgzKTtcbiAgICAgICAgaDQgPSBfeDg2Rm1peChoNCk7XG5cbiAgICAgICAgaDEgKz0gaDI7XG4gICAgICAgIGgxICs9IGgzO1xuICAgICAgICBoMSArPSBoNDtcbiAgICAgICAgaDIgKz0gaDE7XG4gICAgICAgIGgzICs9IGgxO1xuICAgICAgICBoNCArPSBoMTtcblxuICAgICAgICByZXR1cm4gKFwiMDAwMDAwMDBcIiArIChoMSA+Pj4gMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtOCkgKyAoXCIwMDAwMDAwMFwiICsgKGgyID4+PiAwKS50b1N0cmluZygxNikpLnNsaWNlKC04KSArIChcIjAwMDAwMDAwXCIgKyAoaDMgPj4+IDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTgpICsgKFwiMDAwMDAwMDBcIiArIChoNCA+Pj4gMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtOCk7XG4gICAgfTtcblxuICAgIGxpYnJhcnkueDY0Lmhhc2gxMjggPSBmdW5jdGlvbiAoYnl0ZXMsIHNlZWQpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gYSBzdHJpbmcgYW5kIGFuIG9wdGlvbmFsIHNlZWQgYXMgYW4gaW50LCByZXR1cm5zIGEgMTI4IGJpdFxuICAgICAgICAvLyBoYXNoIHVzaW5nIHRoZSB4NjQgZmxhdm9yIG9mIE11cm11ckhhc2gzLCBhcyBhbiB1bnNpZ25lZCBoZXguXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChsaWJyYXJ5LmlucHV0VmFsaWRhdGlvbiAmJiAhX3ZhbGlkQnl0ZXMoYnl0ZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHNlZWQgPSBzZWVkIHx8IDA7XG5cbiAgICAgICAgdmFyIHJlbWFpbmRlciA9IGJ5dGVzLmxlbmd0aCAlIDE2O1xuICAgICAgICB2YXIgYmxvY2tzID0gYnl0ZXMubGVuZ3RoIC0gcmVtYWluZGVyO1xuXG4gICAgICAgIHZhciBoMSA9IFswLCBzZWVkXTtcbiAgICAgICAgdmFyIGgyID0gWzAsIHNlZWRdO1xuXG4gICAgICAgIHZhciBrMSA9IFswLCAwXTtcbiAgICAgICAgdmFyIGsyID0gWzAsIDBdO1xuXG4gICAgICAgIHZhciBjMSA9IFsweDg3YzM3YjkxLCAweDExNDI1M2Q1XTtcbiAgICAgICAgdmFyIGMyID0gWzB4NGNmNWFkNDMsIDB4Mjc0NTkzN2ZdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzOyBpID0gaSArIDE2KSB7XG4gICAgICAgICAgICBrMSA9IFsoYnl0ZXNbaSArIDRdKSB8IChieXRlc1tpICsgNV0gPDwgOCkgfCAoYnl0ZXNbaSArIDZdIDw8IDE2KSB8IChieXRlc1tpICsgN10gPDwgMjQpLCAoYnl0ZXNbaV0pIHxcbiAgICAgICAgICAgICAgICAoYnl0ZXNbaSArIDFdIDw8IDgpIHwgKGJ5dGVzW2kgKyAyXSA8PCAxNikgfCAoYnl0ZXNbaSArIDNdIDw8IDI0KV07XG4gICAgICAgICAgICBrMiA9IFsoYnl0ZXNbaSArIDEyXSkgfCAoYnl0ZXNbaSArIDEzXSA8PCA4KSB8IChieXRlc1tpICsgMTRdIDw8IDE2KSB8IChieXRlc1tpICsgMTVdIDw8IDI0KSwgKGJ5dGVzW2kgKyA4XSkgfFxuICAgICAgICAgICAgICAgIChieXRlc1tpICsgOV0gPDwgOCkgfCAoYnl0ZXNbaSArIDEwXSA8PCAxNikgfCAoYnl0ZXNbaSArIDExXSA8PCAyNCldO1xuXG4gICAgICAgICAgICBrMSA9IF94NjRNdWx0aXBseShrMSwgYzEpO1xuICAgICAgICAgICAgazEgPSBfeDY0Um90bChrMSwgMzEpO1xuICAgICAgICAgICAgazEgPSBfeDY0TXVsdGlwbHkoazEsIGMyKTtcbiAgICAgICAgICAgIGgxID0gX3g2NFhvcihoMSwgazEpO1xuXG4gICAgICAgICAgICBoMSA9IF94NjRSb3RsKGgxLCAyNyk7XG4gICAgICAgICAgICBoMSA9IF94NjRBZGQoaDEsIGgyKTtcbiAgICAgICAgICAgIGgxID0gX3g2NEFkZChfeDY0TXVsdGlwbHkoaDEsIFswLCA1XSksIFswLCAweDUyZGNlNzI5XSk7XG5cbiAgICAgICAgICAgIGsyID0gX3g2NE11bHRpcGx5KGsyLCBjMik7XG4gICAgICAgICAgICBrMiA9IF94NjRSb3RsKGsyLCAzMyk7XG4gICAgICAgICAgICBrMiA9IF94NjRNdWx0aXBseShrMiwgYzEpO1xuICAgICAgICAgICAgaDIgPSBfeDY0WG9yKGgyLCBrMik7XG5cbiAgICAgICAgICAgIGgyID0gX3g2NFJvdGwoaDIsIDMxKTtcbiAgICAgICAgICAgIGgyID0gX3g2NEFkZChoMiwgaDEpO1xuICAgICAgICAgICAgaDIgPSBfeDY0QWRkKF94NjRNdWx0aXBseShoMiwgWzAsIDVdKSwgWzAsIDB4Mzg0OTVhYjVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGsxID0gWzAsIDBdO1xuICAgICAgICBrMiA9IFswLCAwXTtcblxuICAgICAgICBzd2l0Y2ggKHJlbWFpbmRlcikge1xuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICBrMiA9IF94NjRYb3IoazIsIF94NjRMZWZ0U2hpZnQoWzAsIGJ5dGVzW2kgKyAxNF1dLCA0OCkpO1xuXG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIGsyID0gX3g2NFhvcihrMiwgX3g2NExlZnRTaGlmdChbMCwgYnl0ZXNbaSArIDEzXV0sIDQwKSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgazIgPSBfeDY0WG9yKGsyLCBfeDY0TGVmdFNoaWZ0KFswLCBieXRlc1tpICsgMTJdXSwgMzIpKTtcblxuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBrMiA9IF94NjRYb3IoazIsIF94NjRMZWZ0U2hpZnQoWzAsIGJ5dGVzW2kgKyAxMV1dLCAyNCkpO1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIGsyID0gX3g2NFhvcihrMiwgX3g2NExlZnRTaGlmdChbMCwgYnl0ZXNbaSArIDEwXV0sIDE2KSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgazIgPSBfeDY0WG9yKGsyLCBfeDY0TGVmdFNoaWZ0KFswLCBieXRlc1tpICsgOV1dLCA4KSk7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBrMiA9IF94NjRYb3IoazIsIFswLCBieXRlc1tpICsgOF1dKTtcbiAgICAgICAgICAgICAgICBrMiA9IF94NjRNdWx0aXBseShrMiwgYzIpO1xuICAgICAgICAgICAgICAgIGsyID0gX3g2NFJvdGwoazIsIDMzKTtcbiAgICAgICAgICAgICAgICBrMiA9IF94NjRNdWx0aXBseShrMiwgYzEpO1xuICAgICAgICAgICAgICAgIGgyID0gX3g2NFhvcihoMiwgazIpO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgazEgPSBfeDY0WG9yKGsxLCBfeDY0TGVmdFNoaWZ0KFswLCBieXRlc1tpICsgN11dLCA1NikpO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgazEgPSBfeDY0WG9yKGsxLCBfeDY0TGVmdFNoaWZ0KFswLCBieXRlc1tpICsgNl1dLCA0OCkpO1xuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgazEgPSBfeDY0WG9yKGsxLCBfeDY0TGVmdFNoaWZ0KFswLCBieXRlc1tpICsgNV1dLCA0MCkpO1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgazEgPSBfeDY0WG9yKGsxLCBfeDY0TGVmdFNoaWZ0KFswLCBieXRlc1tpICsgNF1dLCAzMikpO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgazEgPSBfeDY0WG9yKGsxLCBfeDY0TGVmdFNoaWZ0KFswLCBieXRlc1tpICsgM11dLCAyNCkpO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgazEgPSBfeDY0WG9yKGsxLCBfeDY0TGVmdFNoaWZ0KFswLCBieXRlc1tpICsgMl1dLCAxNikpO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgazEgPSBfeDY0WG9yKGsxLCBfeDY0TGVmdFNoaWZ0KFswLCBieXRlc1tpICsgMV1dLCA4KSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBrMSA9IF94NjRYb3IoazEsIFswLCBieXRlc1tpXV0pO1xuICAgICAgICAgICAgICAgIGsxID0gX3g2NE11bHRpcGx5KGsxLCBjMSk7XG4gICAgICAgICAgICAgICAgazEgPSBfeDY0Um90bChrMSwgMzEpO1xuICAgICAgICAgICAgICAgIGsxID0gX3g2NE11bHRpcGx5KGsxLCBjMik7XG4gICAgICAgICAgICAgICAgaDEgPSBfeDY0WG9yKGgxLCBrMSk7XG4gICAgICAgIH1cblxuICAgICAgICBoMSA9IF94NjRYb3IoaDEsIFswLCBieXRlcy5sZW5ndGhdKTtcbiAgICAgICAgaDIgPSBfeDY0WG9yKGgyLCBbMCwgYnl0ZXMubGVuZ3RoXSk7XG5cbiAgICAgICAgaDEgPSBfeDY0QWRkKGgxLCBoMik7XG4gICAgICAgIGgyID0gX3g2NEFkZChoMiwgaDEpO1xuXG4gICAgICAgIGgxID0gX3g2NEZtaXgoaDEpO1xuICAgICAgICBoMiA9IF94NjRGbWl4KGgyKTtcblxuICAgICAgICBoMSA9IF94NjRBZGQoaDEsIGgyKTtcbiAgICAgICAgaDIgPSBfeDY0QWRkKGgyLCBoMSk7XG5cbiAgICAgICAgcmV0dXJuIChcIjAwMDAwMDAwXCIgKyAoaDFbMF0gPj4+IDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTgpICsgKFwiMDAwMDAwMDBcIiArIChoMVsxXSA+Pj4gMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtOCkgKyAoXCIwMDAwMDAwMFwiICsgKGgyWzBdID4+PiAwKS50b1N0cmluZygxNikpLnNsaWNlKC04KSArIChcIjAwMDAwMDAwXCIgKyAoaDJbMV0gPj4+IDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTgpO1xuICAgIH07XG5cbiAgICAvLyBJTklUSUFMSVpBVElPTlxuICAgIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBFeHBvcnQgbXVybXVySGFzaDMgZm9yIENvbW1vbkpTLCBlaXRoZXIgYXMgYW4gQU1EIG1vZHVsZSBvciBqdXN0IGFzIHBhcnRcbiAgICAvLyBvZiB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBsaWJyYXJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwb3J0cy5tdXJtdXJIYXNoMyA9IGxpYnJhcnk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpYnJhcnk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gVXNlIG11cm11ckhhc2gzLm5vQ29uZmxpY3QgdG8gcmVzdG9yZSBgbXVybXVySGFzaDNgIGJhY2sgdG8gaXRzXG4gICAgICAgIC8vIG9yaWdpbmFsIHZhbHVlLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBsaWJyYXJ5IG9iamVjdCwgdG8gYWxsb3dcbiAgICAgICAgLy8gaXQgdG8gYmUgdXNlZCB1bmRlciBhIGRpZmZlcmVudCBuYW1lLlxuICAgICAgICBsaWJyYXJ5Ll9tdXJtdXJIYXNoMyA9IHJvb3QubXVybXVySGFzaDM7XG5cbiAgICAgICAgbGlicmFyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcm9vdC5tdXJtdXJIYXNoMyA9IGxpYnJhcnkuX211cm11ckhhc2gzO1xuICAgICAgICAgICAgbGlicmFyeS5fbXVybXVySGFzaDMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsaWJyYXJ5Lm5vQ29uZmxpY3QgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHJldHVybiBsaWJyYXJ5O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJvb3QubXVybXVySGFzaDMgPSBsaWJyYXJ5O1xuICAgIH1cbn0pKHRoaXMpO1xuIiwidmFyIEVSUk9SX01TR19JTlBVVCA9ICdJbnB1dCBtdXN0IGJlIGFuIHN0cmluZywgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG5cbi8vIEZvciBjb252ZW5pZW5jZSwgbGV0IHBlb3BsZSBoYXNoIGEgc3RyaW5nLCBub3QganVzdCBhIFVpbnQ4QXJyYXlcbmZ1bmN0aW9uIG5vcm1hbGl6ZUlucHV0IChpbnB1dCkge1xuICB2YXIgcmV0XG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXQgPSBpbnB1dFxuICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpXG4gIH0gZWxzZSBpZiAodHlwZW9mIChpbnB1dCkgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20oaW5wdXQsICd1dGY4JykpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR19JTlBVVClcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8vIENvbnZlcnRzIGEgVWludDhBcnJheSB0byBhIGhleGFkZWNpbWFsIHN0cmluZ1xuLy8gRm9yIGV4YW1wbGUsIHRvSGV4KFsyNTUsIDAsIDI1NV0pIHJldHVybnMgXCJmZjAwZmZcIlxuZnVuY3Rpb24gdG9IZXggKGJ5dGVzKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoYnl0ZXMsIGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIChuIDwgMTYgPyAnMCcgOiAnJykgKyBuLnRvU3RyaW5nKDE2KVxuICB9KS5qb2luKCcnKVxufVxuXG4vLyBDb252ZXJ0cyBhbnkgdmFsdWUgaW4gWzAuLi4yXjMyLTFdIHRvIGFuIDgtY2hhcmFjdGVyIGhleCBzdHJpbmdcbmZ1bmN0aW9uIHVpbnQzMlRvSGV4ICh2YWwpIHtcbiAgcmV0dXJuICgweDEwMDAwMDAwMCArIHZhbCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKVxufVxuXG4vLyBGb3IgZGVidWdnaW5nOiBwcmludHMgb3V0IGhhc2ggc3RhdGUgaW4gdGhlIHNhbWUgZm9ybWF0IGFzIHRoZSBSRkNcbi8vIHNhbXBsZSBjb21wdXRhdGlvbiBleGFjdGx5LCBzbyB0aGF0IHlvdSBjYW4gZGlmZlxuZnVuY3Rpb24gZGVidWdQcmludCAobGFiZWwsIGFyciwgc2l6ZSkge1xuICB2YXIgbXNnID0gJ1xcbicgKyBsYWJlbCArICcgPSAnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgaWYgKHNpemUgPT09IDMyKSB7XG4gICAgICBtc2cgKz0gdWludDMyVG9IZXgoYXJyW2ldKS50b1VwcGVyQ2FzZSgpXG4gICAgICBtc2cgKz0gJyAnXG4gICAgICBtc2cgKz0gdWludDMyVG9IZXgoYXJyW2kgKyAxXSkudG9VcHBlckNhc2UoKVxuICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gNjQpIHtcbiAgICAgIG1zZyArPSB1aW50MzJUb0hleChhcnJbaSArIDFdKS50b1VwcGVyQ2FzZSgpXG4gICAgICBtc2cgKz0gdWludDMyVG9IZXgoYXJyW2ldKS50b1VwcGVyQ2FzZSgpXG4gICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaXplICcgKyBzaXplKVxuICAgIGlmIChpICUgNiA9PT0gNCkge1xuICAgICAgbXNnICs9ICdcXG4nICsgbmV3IEFycmF5KGxhYmVsLmxlbmd0aCArIDQpLmpvaW4oJyAnKVxuICAgIH0gZWxzZSBpZiAoaSA8IGFyci5sZW5ndGggLSAyKSB7XG4gICAgICBtc2cgKz0gJyAnXG4gICAgfVxuICB9XG4gIGNvbnNvbGUubG9nKG1zZylcbn1cblxuLy8gRm9yIHBlcmZvcm1hbmNlIHRlc3Rpbmc6IGdlbmVyYXRlcyBOIGJ5dGVzIG9mIGlucHV0LCBoYXNoZXMgTSB0aW1lc1xuLy8gTWVhc3VyZXMgYW5kIHByaW50cyBNQi9zZWNvbmQgaGFzaCBwZXJmb3JtYW5jZSBlYWNoIHRpbWVcbmZ1bmN0aW9uIHRlc3RTcGVlZCAoaGFzaEZuLCBOLCBNKSB7XG4gIHZhciBzdGFydE1zID0gbmV3IERhdGUoKS5nZXRUaW1lKClcblxuICB2YXIgaW5wdXQgPSBuZXcgVWludDhBcnJheShOKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgIGlucHV0W2ldID0gaSAlIDI1NlxuICB9XG4gIHZhciBnZW5NcyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gIGNvbnNvbGUubG9nKCdHZW5lcmF0ZWQgcmFuZG9tIGlucHV0IGluICcgKyAoZ2VuTXMgLSBzdGFydE1zKSArICdtcycpXG4gIHN0YXJ0TXMgPSBnZW5Nc1xuXG4gIGZvciAoaSA9IDA7IGkgPCBNOyBpKyspIHtcbiAgICB2YXIgaGFzaEhleCA9IGhhc2hGbihpbnB1dClcbiAgICB2YXIgaGFzaE1zID0gbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICB2YXIgbXMgPSBoYXNoTXMgLSBzdGFydE1zXG4gICAgc3RhcnRNcyA9IGhhc2hNc1xuICAgIGNvbnNvbGUubG9nKCdIYXNoZWQgaW4gJyArIG1zICsgJ21zOiAnICsgaGFzaEhleC5zdWJzdHJpbmcoMCwgMjApICsgJy4uLicpXG4gICAgY29uc29sZS5sb2coTWF0aC5yb3VuZChOIC8gKDEgPDwgMjApIC8gKG1zIC8gMTAwMCkgKiAxMDApIC8gMTAwICsgJyBNQiBQRVIgU0VDT05EJylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbm9ybWFsaXplSW5wdXQ6IG5vcm1hbGl6ZUlucHV0LFxuICB0b0hleDogdG9IZXgsXG4gIGRlYnVnUHJpbnQ6IGRlYnVnUHJpbnQsXG4gIHRlc3RTcGVlZDogdGVzdFNwZWVkXG59XG4iLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgSW4gdGhlXG4vLyBicm93c2VyIHRoaXMgaXMgYSBsaXR0bGUgY29tcGxpY2F0ZWQgZHVlIHRvIHVua25vd24gcXVhbGl0eSBvZiBNYXRoLnJhbmRvbSgpXG4vLyBhbmQgaW5jb25zaXN0ZW50IHN1cHBvcnQgZm9yIHRoZSBgY3J5cHRvYCBBUEkuICBXZSBkbyB0aGUgYmVzdCB3ZSBjYW4gdmlhXG4vLyBmZWF0dXJlLWRldGVjdGlvblxuXG4vLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG9cbi8vIGltcGxlbWVudGF0aW9uLiBBbHNvLCBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gb24gSUUxMS5cbnZhciBnZXRSYW5kb21WYWx1ZXMgPSAodHlwZW9mKGNyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mKG1zQ3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93Lm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKSk7XG5cbmlmIChnZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0byBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIHZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG4gICAgcmV0dXJuIHJuZHM4O1xuICB9O1xufSBlbHNlIHtcbiAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAvL1xuICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAvLyBxdWFsaXR5LlxuICB2YXIgcm5kcyA9IG5ldyBBcnJheSgxNik7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXRoUk5HKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBybmRzO1xuICB9O1xufVxuIiwiLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9VdWlkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBidGggPSBieXRlVG9IZXg7XG4gIC8vIGpvaW4gdXNlZCB0byBmaXggbWVtb3J5IGlzc3VlIGNhdXNlZCBieSBjb25jYXRlbmF0aW9uOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMTc1I2M0XG4gIHJldHVybiAoW2J0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sIFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV1dKS5qb2luKCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBieXRlc1RvVXVpZDtcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBtdWx0aWJhc2UgPSByZXF1aXJlKCdtdWx0aWJhc2UnKVxuY29uc3QgZXJyY29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxuY29uc3QgbmFtZXNwYWNlID0gJy9yZWNvcmQvJ1xuY29uc3QgYmFzZTY0dXJsQ29kZSA9ICd1JyAvLyBiYXNlNjR1cmwgY29kZSBmcm9tIG11bHRpYmFzZVxuXG5tb2R1bGUuZXhwb3J0cy5lbmNvZGVCYXNlMzIgPSAoYnVmKSA9PiB7XG4gIHJldHVybiBtdWx0aWJhc2UuZW5jb2RlKCdiYXNlMzInLCBidWYpLnNsaWNlKDEpIC8vIHNsaWNlIG9mZiBtdWx0aWJhc2UgY29kZWNcbn1cblxuLy8gY29udmVydHMgYSBiaW5hcnkgcmVjb3JkIGtleSB0byBhIHB1YnN1YiB0b3BpYyBrZXkuXG5tb2R1bGUuZXhwb3J0cy5rZXlUb1RvcGljID0gKGtleSkgPT4ge1xuICAvLyBSZWNvcmQtc3RvcmUga2V5cyBhcmUgYXJiaXRyYXJ5IGJpbmFyeS4gSG93ZXZlciwgcHVic3ViIHJlcXVpcmVzIFVURi04IHN0cmluZyB0b3BpYyBJRHNcbiAgLy8gRW5jb2RlcyB0byBcIi9yZWNvcmQvYmFzZTY0dXJsKGtleSlcIlxuICBjb25zdCBiNjR1cmwgPSBtdWx0aWJhc2UuZW5jb2RlKCdiYXNlNjR1cmwnLCBrZXkpLnNsaWNlKDEpLnRvU3RyaW5nKClcblxuICByZXR1cm4gYCR7bmFtZXNwYWNlfSR7YjY0dXJsfWBcbn1cblxuLy8gY29udmVydHMgYSBwdWJzdWIgdG9waWMga2V5IHRvIGEgYmluYXJ5IHJlY29yZCBrZXkuXG5tb2R1bGUuZXhwb3J0cy50b3BpY1RvS2V5ID0gKHRvcGljKSA9PiB7XG4gIGlmICh0b3BpYy5zdWJzdHJpbmcoMCwgbmFtZXNwYWNlLmxlbmd0aCkgIT09IG5hbWVzcGFjZSkge1xuICAgIHRocm93IGVycmNvZGUobmV3IEVycm9yKCd0b3BpYyByZWNlaXZlZCBpcyBub3QgZnJvbSBhIHJlY29yZCcpLCAnRVJSX1RPUElDX0lTX05PVF9GUk9NX1JFQ09SRF9OQU1FU1BBQ0UnKVxuICB9XG5cbiAgY29uc3Qga2V5ID0gYCR7YmFzZTY0dXJsQ29kZX0ke3RvcGljLnN1YnN0cmluZyhuYW1lc3BhY2UubGVuZ3RoKX1gXG5cbiAgcmV0dXJuIG11bHRpYmFzZS5kZWNvZGUoa2V5KS50b1N0cmluZygpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0cnVuY2F0ZSA9IHJlcXVpcmUoXCIuL2xpYi90cnVuY2F0ZVwiKTtcbnZhciBnZXRMZW5ndGggPSByZXF1aXJlKFwidXRmOC1ieXRlLWxlbmd0aC9icm93c2VyXCIpO1xubW9kdWxlLmV4cG9ydHMgPSB0cnVuY2F0ZS5iaW5kKG51bGwsIGdldExlbmd0aCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfaWRlbnRpdHkgPSByZXF1aXJlKCdsb2Rhc2gvaWRlbnRpdHknKTtcblxudmFyIF9pZGVudGl0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pZGVudGl0eSk7XG5cbnZhciBfY3JlYXRlVGVzdGVyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9jcmVhdGVUZXN0ZXInKTtcblxudmFyIF9jcmVhdGVUZXN0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVGVzdGVyKTtcblxudmFyIF9kb1BhcmFsbGVsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9kb1BhcmFsbGVsJyk7XG5cbnZhciBfZG9QYXJhbGxlbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kb1BhcmFsbGVsKTtcblxudmFyIF9maW5kR2V0UmVzdWx0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9maW5kR2V0UmVzdWx0Jyk7XG5cbnZhciBfZmluZEdldFJlc3VsdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9maW5kR2V0UmVzdWx0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBpbiBgY29sbGAgdGhhdCBwYXNzZXMgYW4gYXN5bmMgdHJ1dGggdGVzdC4gVGhlXG4gKiBgaXRlcmF0ZWVgIGlzIGFwcGxpZWQgaW4gcGFyYWxsZWwsIG1lYW5pbmcgdGhlIGZpcnN0IGl0ZXJhdGVlIHRvIHJldHVyblxuICogYHRydWVgIHdpbGwgZmlyZSB0aGUgZGV0ZWN0IGBjYWxsYmFja2Agd2l0aCB0aGF0IHJlc3VsdC4gVGhhdCBtZWFucyB0aGVcbiAqIHJlc3VsdCBtaWdodCBub3QgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIG9yaWdpbmFsIGBjb2xsYCAoaW4gdGVybXMgb2Ygb3JkZXIpXG4gKiB0aGF0IHBhc3NlcyB0aGUgdGVzdC5cblxuICogSWYgb3JkZXIgd2l0aGluIHRoZSBvcmlnaW5hbCBgY29sbGAgaXMgaW1wb3J0YW50LCB0aGVuIGxvb2sgYXRcbiAqIFtgZGV0ZWN0U2VyaWVzYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdFNlcmllc30uXG4gKlxuICogQG5hbWUgZGV0ZWN0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgZmluZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgcmVzdWx0LlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnlcbiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuXG4gKiBSZXN1bHQgd2lsbCBiZSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgYXJyYXkgdGhhdCBwYXNzZXMgdGhlIHRydXRoIHRlc3RcbiAqIChpdGVyYXRlZSkgb3IgdGhlIHZhbHVlIGB1bmRlZmluZWRgIGlmIG5vbmUgcGFzc2VkLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdCkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLmRldGVjdChbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmdW5jdGlvbihmaWxlUGF0aCwgY2FsbGJhY2spIHtcbiAqICAgICBmcy5hY2Nlc3MoZmlsZVBhdGgsIGZ1bmN0aW9uKGVycikge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKVxuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyB0aGUgZmlyc3QgZmlsZSBpbiB0aGUgbGlzdCB0aGF0IGV4aXN0c1xuICogfSk7XG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfZG9QYXJhbGxlbDIuZGVmYXVsdCkoKDAsIF9jcmVhdGVUZXN0ZXIyLmRlZmF1bHQpKF9pZGVudGl0eTIuZGVmYXVsdCwgX2ZpbmRHZXRSZXN1bHQyLmRlZmF1bHQpKTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBQS0NTIzcgdjEuNS5cbiAqXG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKlxuICogQ3VycmVudGx5IHRoaXMgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBDb250ZW50VHlwZSBvZiBFbnZlbG9wZWREYXRhLFxuICogRW5jcnlwdGVkRGF0YSwgb3IgU2lnbmVkRGF0YSBhdCB0aGUgcm9vdCBsZXZlbC4gVGhlIHRvcCBsZXZlbCBlbGVtZW50cyBtYXlcbiAqIGNvbnRhaW4gb25seSBhIENvbnRlbnRJbmZvIG9mIENvbnRlbnRUeXBlIERhdGEsIGkuZS4gcGxhaW4gZGF0YS4gRnVydGhlclxuICogbmVzdGluZyBpcyBub3QgKHlldCkgc3VwcG9ydGVkLlxuICpcbiAqIFRoZSBGb3JnZSB2YWxpZGF0b3JzIGZvciBQS0NTICM3J3MgQVNOLjEgc3RydWN0dXJlcyBhcmUgYXZhaWxhYmxlIGZyb21cbiAqIGEgc2VwYXJhdGUgZmlsZSBwa2NzN2FzbjEuanMsIHNpbmNlIHRob3NlIGFyZSByZWZlcmVuY2VkIGZyb20gb3RoZXJcbiAqIFBLQ1Mgc3RhbmRhcmRzIGxpa2UgUEtDUyAjMTIuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vYWVzJyk7XG5yZXF1aXJlKCcuL2FzbjEnKTtcbnJlcXVpcmUoJy4vZGVzJyk7XG5yZXF1aXJlKCcuL29pZHMnKTtcbnJlcXVpcmUoJy4vcGVtJyk7XG5yZXF1aXJlKCcuL3BrY3M3YXNuMScpO1xucmVxdWlyZSgnLi9yYW5kb20nKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xucmVxdWlyZSgnLi94NTA5Jyk7XG5cbi8vIHNob3J0Y3V0IGZvciBBU04uMSBBUElcbnZhciBhc24xID0gZm9yZ2UuYXNuMTtcblxuLy8gc2hvcnRjdXQgZm9yIFBLQ1MjNyBBUElcbnZhciBwNyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtjczcgPSBmb3JnZS5wa2NzNyB8fCB7fTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFBLQ1MjNyBtZXNzYWdlIGZyb20gUEVNIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gcGVtIHRoZSBQRU0tZm9ybWF0dGVkIFBLQ1MjNyBtZXNzYWdlLlxuICpcbiAqIEByZXR1cm4gdGhlIFBLQ1MjNyBtZXNzYWdlLlxuICovXG5wNy5tZXNzYWdlRnJvbVBlbSA9IGZ1bmN0aW9uKHBlbSkge1xuICB2YXIgbXNnID0gZm9yZ2UucGVtLmRlY29kZShwZW0pWzBdO1xuXG4gIGlmKG1zZy50eXBlICE9PSAnUEtDUzcnKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBQS0NTIzcgbWVzc2FnZSBmcm9tIFBFTTsgUEVNICcgK1xuICAgICAgJ2hlYWRlciB0eXBlIGlzIG5vdCBcIlBLQ1MjN1wiLicpO1xuICAgIGVycm9yLmhlYWRlclR5cGUgPSBtc2cudHlwZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBQS0NTIzcgbWVzc2FnZSBmcm9tIFBFTTsgUEVNIGlzIGVuY3J5cHRlZC4nKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgREVSIHRvIEFTTi4xIG9iamVjdFxuICB2YXIgb2JqID0gYXNuMS5mcm9tRGVyKG1zZy5ib2R5KTtcblxuICByZXR1cm4gcDcubWVzc2FnZUZyb21Bc24xKG9iaik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUEtDUyM3IG1lc3NhZ2UgdG8gUEVNIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gbXNnIFRoZSBQS0NTIzcgbWVzc2FnZSBvYmplY3RcbiAqIEBwYXJhbSBtYXhsaW5lIFRoZSBtYXhpbXVtIGNoYXJhY3RlcnMgcGVyIGxpbmUsIGRlZmF1bHRzIHRvIDY0LlxuICpcbiAqIEByZXR1cm4gVGhlIFBFTS1mb3JtYXR0ZWQgUEtDUyM3IG1lc3NhZ2UuXG4gKi9cbnA3Lm1lc3NhZ2VUb1BlbSA9IGZ1bmN0aW9uKG1zZywgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIEFTTi4xLCB0aGVuIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBwZW1PYmogPSB7XG4gICAgdHlwZTogJ1BLQ1M3JyxcbiAgICBib2R5OiBhc24xLnRvRGVyKG1zZy50b0FzbjEoKSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShwZW1PYmosIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUEtDUyM3IG1lc3NhZ2UgZnJvbSBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgYSBDb250ZW50SW5mby5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQS0NTIzcgbWVzc2FnZS5cbiAqL1xucDcubWVzc2FnZUZyb21Bc24xID0gZnVuY3Rpb24ob2JqKSB7XG4gIC8vIHZhbGlkYXRlIHJvb3QgbGV2ZWwgQ29udGVudEluZm8gYW5kIGNhcHR1cmUgZGF0YVxuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKG9iaiwgcDcuYXNuMS5jb250ZW50SW5mb1ZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgUEtDUyM3IG1lc3NhZ2UuICcgK1xuICAgICAgJ0FTTi4xIG9iamVjdCBpcyBub3QgYW4gUEtDUyM3IENvbnRlbnRJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBjb250ZW50VHlwZSA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jb250ZW50VHlwZSk7XG4gIHZhciBtc2c7XG5cbiAgc3dpdGNoKGNvbnRlbnRUeXBlKSB7XG4gICAgY2FzZSBmb3JnZS5wa2kub2lkcy5lbnZlbG9wZWREYXRhOlxuICAgICAgbXNnID0gcDcuY3JlYXRlRW52ZWxvcGVkRGF0YSgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGZvcmdlLnBraS5vaWRzLmVuY3J5cHRlZERhdGE6XG4gICAgICBtc2cgPSBwNy5jcmVhdGVFbmNyeXB0ZWREYXRhKCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgZm9yZ2UucGtpLm9pZHMuc2lnbmVkRGF0YTpcbiAgICAgIG1zZyA9IHA3LmNyZWF0ZVNpZ25lZERhdGEoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgUEtDUyM3IG1lc3NhZ2UuIENvbnRlbnRUeXBlIHdpdGggT0lEICcgK1xuICAgICAgICBjb250ZW50VHlwZSArICcgaXMgbm90ICh5ZXQpIHN1cHBvcnRlZC4nKTtcbiAgfVxuXG4gIG1zZy5mcm9tQXNuMShjYXB0dXJlLmNvbnRlbnQudmFsdWVbMF0pO1xuICByZXR1cm4gbXNnO1xufTtcblxucDcuY3JlYXRlU2lnbmVkRGF0YSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbXNnID0gbnVsbDtcbiAgbXNnID0ge1xuICAgIHR5cGU6IGZvcmdlLnBraS5vaWRzLnNpZ25lZERhdGEsXG4gICAgdmVyc2lvbjogMSxcbiAgICBjZXJ0aWZpY2F0ZXM6IFtdLFxuICAgIGNybHM6IFtdLFxuICAgIC8vIFRPRE86IGFkZCBqc29uLWZvcm1hdHRlZCBzaWduZXIgc3R1ZmYgaGVyZT9cbiAgICBzaWduZXJzOiBbXSxcbiAgICAvLyBwb3B1bGF0ZWQgZHVyaW5nIHNpZ24oKVxuICAgIGRpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXJzOiBbXSxcbiAgICBjb250ZW50SW5mbzogbnVsbCxcbiAgICBzaWduZXJJbmZvczogW10sXG5cbiAgICBmcm9tQXNuMTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAvLyB2YWxpZGF0ZSBTaWduZWREYXRhIGNvbnRlbnQgYmxvY2sgYW5kIGNhcHR1cmUgZGF0YS5cbiAgICAgIF9mcm9tQXNuMShtc2csIG9iaiwgcDcuYXNuMS5zaWduZWREYXRhVmFsaWRhdG9yKTtcbiAgICAgIG1zZy5jZXJ0aWZpY2F0ZXMgPSBbXTtcbiAgICAgIG1zZy5jcmxzID0gW107XG4gICAgICBtc2cuZGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcnMgPSBbXTtcbiAgICAgIG1zZy5jb250ZW50SW5mbyA9IG51bGw7XG4gICAgICBtc2cuc2lnbmVySW5mb3MgPSBbXTtcblxuICAgICAgaWYobXNnLnJhd0NhcHR1cmUuY2VydGlmaWNhdGVzKSB7XG4gICAgICAgIHZhciBjZXJ0cyA9IG1zZy5yYXdDYXB0dXJlLmNlcnRpZmljYXRlcy52YWx1ZTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNlcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgbXNnLmNlcnRpZmljYXRlcy5wdXNoKGZvcmdlLnBraS5jZXJ0aWZpY2F0ZUZyb21Bc24xKGNlcnRzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogcGFyc2UgY3Jsc1xuICAgIH0sXG5cbiAgICB0b0FzbjE6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gZGVnZW5lcmF0ZSBjYXNlIHdpdGggbm8gY29udGVudFxuICAgICAgaWYoIW1zZy5jb250ZW50SW5mbykge1xuICAgICAgICBtc2cuc2lnbigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2VydHMgPSBbXTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtc2cuY2VydGlmaWNhdGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNlcnRzLnB1c2goZm9yZ2UucGtpLmNlcnRpZmljYXRlVG9Bc24xKG1zZy5jZXJ0aWZpY2F0ZXNbaV0pKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNybHMgPSBbXTtcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCBDUkxzXG5cbiAgICAgIC8vIFswXSBTaWduZWREYXRhXG4gICAgICB2YXIgc2lnbmVkRGF0YSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW1xuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgLy8gVmVyc2lvblxuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICAgICAgICBhc24xLmludGVnZXJUb0Rlcihtc2cudmVyc2lvbikuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgLy8gRGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcnNcbiAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLFxuICAgICAgICAgICAgbXNnLmRpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXJzKSxcbiAgICAgICAgICAvLyBDb250ZW50SW5mb1xuICAgICAgICAgIG1zZy5jb250ZW50SW5mb1xuICAgICAgICBdKVxuICAgICAgXSk7XG4gICAgICBpZihjZXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIFswXSBJTVBMSUNJVCBFeHRlbmRlZENlcnRpZmljYXRlc0FuZENlcnRpZmljYXRlcyBPUFRJT05BTFxuICAgICAgICBzaWduZWREYXRhLnZhbHVlWzBdLnZhbHVlLnB1c2goXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBjZXJ0cykpO1xuICAgICAgfVxuICAgICAgaWYoY3Jscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIFsxXSBJTVBMSUNJVCBDZXJ0aWZpY2F0ZVJldm9jYXRpb25MaXN0cyBPUFRJT05BTFxuICAgICAgICBzaWduZWREYXRhLnZhbHVlWzBdLnZhbHVlLnB1c2goXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAxLCB0cnVlLCBjcmxzKSk7XG4gICAgICB9XG4gICAgICAvLyBTaWduZXJJbmZvc1xuICAgICAgc2lnbmVkRGF0YS52YWx1ZVswXS52YWx1ZS5wdXNoKFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFVCwgdHJ1ZSxcbiAgICAgICAgICBtc2cuc2lnbmVySW5mb3MpKTtcblxuICAgICAgLy8gQ29udGVudEluZm9cbiAgICAgIHJldHVybiBhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIC8vIENvbnRlbnRUeXBlXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5vaWRUb0Rlcihtc2cudHlwZSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgLy8gWzBdIFNpZ25lZERhdGFcbiAgICAgICAgICBzaWduZWREYXRhXG4gICAgICAgIF0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgKGFub3RoZXIpIGVudGl0eSB0byBsaXN0IG9mIHNpZ25lcnMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJZiBhdXRoZW50aWNhdGVkQXR0cmlidXRlcyBhcmUgcHJvdmlkZWQsIHRoZW4sIHBlciBSRkMgMjMxNSxcbiAgICAgKiB0aGV5IG11c3QgaW5jbHVkZSBhdCBsZWFzdCB0d28gYXR0cmlidXRlczogY29udGVudCB0eXBlIGFuZFxuICAgICAqIG1lc3NhZ2UgZGlnZXN0LiBUaGUgbWVzc2FnZSBkaWdlc3QgYXR0cmlidXRlIHZhbHVlIHdpbGwgYmVcbiAgICAgKiBhdXRvLWNhbGN1bGF0ZWQgZHVyaW5nIHNpZ25pbmcgYW5kIHdpbGwgYmUgaWdub3JlZCBpZiBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEhlcmUncyBhbiBleGFtcGxlIG9mIHByb3ZpZGluZyB0aGVzZSB0d28gYXR0cmlidXRlczpcbiAgICAgKlxuICAgICAqIGZvcmdlLnBrY3M3LmNyZWF0ZVNpZ25lZERhdGEoKTtcbiAgICAgKiBwNy5hZGRTaWduZXIoe1xuICAgICAqICAgaXNzdWVyOiBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzLFxuICAgICAqICAgc2VyaWFsTnVtYmVyOiBjZXJ0LnNlcmlhbE51bWJlcixcbiAgICAgKiAgIGtleTogcHJpdmF0ZUtleSxcbiAgICAgKiAgIGRpZ2VzdEFsZ29yaXRobTogZm9yZ2UucGtpLm9pZHMuc2hhMSxcbiAgICAgKiAgIGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzOiBbe1xuICAgICAqICAgICB0eXBlOiBmb3JnZS5wa2kub2lkcy5jb250ZW50VHlwZSxcbiAgICAgKiAgICAgdmFsdWU6IGZvcmdlLnBraS5vaWRzLmRhdGFcbiAgICAgKiAgIH0sIHtcbiAgICAgKiAgICAgdHlwZTogZm9yZ2UucGtpLm9pZHMubWVzc2FnZURpZ2VzdFxuICAgICAqICAgfV1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIFRPRE86IFN1cHBvcnQgW3N1YmplY3RLZXlJZGVudGlmaWVyXSBhcyBzaWduZXIncyBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaWduZXIgdGhlIHNpZ25lciBpbmZvcm1hdGlvbjpcbiAgICAgKiAgICAgICAgICBrZXkgdGhlIHNpZ25lcidzIHByaXZhdGUga2V5LlxuICAgICAqICAgICAgICAgIFtjZXJ0aWZpY2F0ZV0gYSBjZXJ0aWZpY2F0ZSBjb250YWluaW5nIHRoZSBwdWJsaWMga2V5XG4gICAgICogICAgICAgICAgICBhc3NvY2lhdGVkIHdpdGggdGhlIHNpZ25lcidzIHByaXZhdGUga2V5OyB1c2UgdGhpcyBvcHRpb24gYXNcbiAgICAgKiAgICAgICAgICAgIGFuIGFsdGVybmF0aXZlIHRvIHNwZWNpZnlpbmcgc2lnbmVyLmlzc3VlciBhbmRcbiAgICAgKiAgICAgICAgICAgIHNpZ25lci5zZXJpYWxOdW1iZXIuXG4gICAgICogICAgICAgICAgW2lzc3Vlcl0gdGhlIGlzc3VlciBhdHRyaWJ1dGVzIChlZzogY2VydC5pc3N1ZXIuYXR0cmlidXRlcykuXG4gICAgICogICAgICAgICAgW3NlcmlhbE51bWJlcl0gdGhlIHNpZ25lcidzIGNlcnRpZmljYXRlJ3Mgc2VyaWFsIG51bWJlciBpblxuICAgICAqICAgICAgICAgICBoZXhhZGVjaW1hbCAoZWc6IGNlcnQuc2VyaWFsTnVtYmVyKS5cbiAgICAgKiAgICAgICAgICBbZGlnZXN0QWxnb3JpdGhtXSB0aGUgbWVzc2FnZSBkaWdlc3QgT0lELCBhcyBhIHN0cmluZywgdG8gdXNlXG4gICAgICogICAgICAgICAgICAoZWc6IGZvcmdlLnBraS5vaWRzLnNoYTEpLlxuICAgICAqICAgICAgICAgIFthdXRoZW50aWNhdGVkQXR0cmlidXRlc10gYW4gb3B0aW9uYWwgYXJyYXkgb2YgYXR0cmlidXRlc1xuICAgICAqICAgICAgICAgICAgdG8gYWxzbyBzaWduIGFsb25nIHdpdGggdGhlIGNvbnRlbnQuXG4gICAgICovXG4gICAgYWRkU2lnbmVyOiBmdW5jdGlvbihzaWduZXIpIHtcbiAgICAgIHZhciBpc3N1ZXIgPSBzaWduZXIuaXNzdWVyO1xuICAgICAgdmFyIHNlcmlhbE51bWJlciA9IHNpZ25lci5zZXJpYWxOdW1iZXI7XG4gICAgICBpZihzaWduZXIuY2VydGlmaWNhdGUpIHtcbiAgICAgICAgdmFyIGNlcnQgPSBzaWduZXIuY2VydGlmaWNhdGU7XG4gICAgICAgIGlmKHR5cGVvZiBjZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNlcnQgPSBmb3JnZS5wa2kuY2VydGlmaWNhdGVGcm9tUGVtKGNlcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlzc3VlciA9IGNlcnQuaXNzdWVyLmF0dHJpYnV0ZXM7XG4gICAgICAgIHNlcmlhbE51bWJlciA9IGNlcnQuc2VyaWFsTnVtYmVyO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHNpZ25lci5rZXk7XG4gICAgICBpZigha2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQ291bGQgbm90IGFkZCBQS0NTIzcgc2lnbmVyOyBubyBwcml2YXRlIGtleSBzcGVjaWZpZWQuJyk7XG4gICAgICB9XG4gICAgICBpZih0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBrZXkgPSBmb3JnZS5wa2kucHJpdmF0ZUtleUZyb21QZW0oa2V5KTtcbiAgICAgIH1cblxuICAgICAgLy8gZW5zdXJlIE9JRCBrbm93biBmb3IgZGlnZXN0IGFsZ29yaXRobVxuICAgICAgdmFyIGRpZ2VzdEFsZ29yaXRobSA9IHNpZ25lci5kaWdlc3RBbGdvcml0aG0gfHwgZm9yZ2UucGtpLm9pZHMuc2hhMTtcbiAgICAgIHN3aXRjaChkaWdlc3RBbGdvcml0aG0pIHtcbiAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHMuc2hhMTpcbiAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHMuc2hhMjU2OlxuICAgICAgY2FzZSBmb3JnZS5wa2kub2lkcy5zaGEzODQ6XG4gICAgICBjYXNlIGZvcmdlLnBraS5vaWRzLnNoYTUxMjpcbiAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHMubWQ1OlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQ291bGQgbm90IGFkZCBQS0NTIzcgc2lnbmVyOyB1bmtub3duIG1lc3NhZ2UgZGlnZXN0IGFsZ29yaXRobTogJyArXG4gICAgICAgICAgZGlnZXN0QWxnb3JpdGhtKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMgaXMgcHJlc2VudCwgdGhlbiB0aGUgYXR0cmlidXRlc1xuICAgICAgLy8gbXVzdCBjb250YWluIGF0IGxlYXN0IFBLQ1MgIzkgY29udGVudC10eXBlIGFuZCBtZXNzYWdlLWRpZ2VzdFxuICAgICAgdmFyIGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzID0gc2lnbmVyLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzIHx8IFtdO1xuICAgICAgaWYoYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgY29udGVudFR5cGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIG1lc3NhZ2VEaWdlc3QgPSBmYWxzZTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGF0dHIgPSBhdXRoZW50aWNhdGVkQXR0cmlidXRlc1tpXTtcbiAgICAgICAgICBpZighY29udGVudFR5cGUgJiYgYXR0ci50eXBlID09PSBmb3JnZS5wa2kub2lkcy5jb250ZW50VHlwZSkge1xuICAgICAgICAgICAgY29udGVudFR5cGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYobWVzc2FnZURpZ2VzdCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZighbWVzc2FnZURpZ2VzdCAmJiBhdHRyLnR5cGUgPT09IGZvcmdlLnBraS5vaWRzLm1lc3NhZ2VEaWdlc3QpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VEaWdlc3QgPSB0cnVlO1xuICAgICAgICAgICAgaWYoY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZighY29udGVudFR5cGUgfHwgIW1lc3NhZ2VEaWdlc3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmVyLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzLiBJZiAnICtcbiAgICAgICAgICAgICdzaWduZXIuYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMgaXMgc3BlY2lmaWVkLCB0aGVuIGl0IG11c3QgJyArXG4gICAgICAgICAgICAnY29udGFpbiBhdCBsZWFzdCB0d28gYXR0cmlidXRlcywgUEtDUyAjOSBjb250ZW50LXR5cGUgYW5kICcgK1xuICAgICAgICAgICAgJ1BLQ1MgIzkgbWVzc2FnZS1kaWdlc3QuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbXNnLnNpZ25lcnMucHVzaCh7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICBpc3N1ZXI6IGlzc3VlcixcbiAgICAgICAgc2VyaWFsTnVtYmVyOiBzZXJpYWxOdW1iZXIsXG4gICAgICAgIGRpZ2VzdEFsZ29yaXRobTogZGlnZXN0QWxnb3JpdGhtLFxuICAgICAgICBzaWduYXR1cmVBbGdvcml0aG06IGZvcmdlLnBraS5vaWRzLnJzYUVuY3J5cHRpb24sXG4gICAgICAgIHNpZ25hdHVyZTogbnVsbCxcbiAgICAgICAgYXV0aGVudGljYXRlZEF0dHJpYnV0ZXM6IGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzLFxuICAgICAgICB1bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzOiBbXVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNpZ25zIHRoZSBjb250ZW50LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gYXBwbHkgd2hlbiBzaWduaW5nOlxuICAgICAqICAgIFtkZXRhY2hlZF0gYm9vbGVhbi4gSWYgc2lnbmluZyBzaG91bGQgYmUgZG9uZSBpbiBkZXRhY2hlZCBtb2RlLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKi9cbiAgICBzaWduOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIC8vIGF1dG8tZ2VuZXJhdGUgY29udGVudCBpbmZvXG4gICAgICBpZih0eXBlb2YgbXNnLmNvbnRlbnQgIT09ICdvYmplY3QnIHx8IG1zZy5jb250ZW50SW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAvLyB1c2UgRGF0YSBDb250ZW50SW5mb1xuICAgICAgICBtc2cuY29udGVudEluZm8gPSBhc24xLmNyZWF0ZShcbiAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICAvLyBDb250ZW50VHlwZVxuICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKGZvcmdlLnBraS5vaWRzLmRhdGEpLmdldEJ5dGVzKCkpXG4gICAgICAgICAgXSk7XG5cbiAgICAgICAgLy8gYWRkIGFjdHVhbCBjb250ZW50LCBpZiBwcmVzZW50XG4gICAgICAgIGlmKCdjb250ZW50JyBpbiBtc2cpIHtcbiAgICAgICAgICB2YXIgY29udGVudDtcbiAgICAgICAgICBpZihtc2cuY29udGVudCBpbnN0YW5jZW9mIGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcikge1xuICAgICAgICAgICAgY29udGVudCA9IG1zZy5jb250ZW50LmJ5dGVzKCk7XG4gICAgICAgICAgfSBlbHNlIGlmKHR5cGVvZiBtc2cuY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgobXNnLmNvbnRlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLmRldGFjaGVkKSB7XG4gICAgICAgICAgICBtc2cuZGV0YWNoZWRDb250ZW50ID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIGNvbnRlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtc2cuY29udGVudEluZm8udmFsdWUucHVzaChcbiAgICAgICAgICAgICAgLy8gWzBdIEVYUExJQ0lUIGNvbnRlbnRcbiAgICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsXG4gICAgICAgICAgICAgICAgICBjb250ZW50KVxuICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5vIHNpZ25lcnMsIHJldHVybiBlYXJseSAoZGVnZW5lcmF0ZSBjYXNlIGZvciBjZXJ0aWZpY2F0ZSBjb250YWluZXIpXG4gICAgICBpZihtc2cuc2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBnZW5lcmF0ZSBkaWdlc3QgYWxnb3JpdGhtIGlkZW50aWZpZXJzXG4gICAgICB2YXIgbWRzID0gYWRkRGlnZXN0QWxnb3JpdGhtSWRzKCk7XG5cbiAgICAgIC8vIGdlbmVyYXRlIHNpZ25lckluZm9zXG4gICAgICBhZGRTaWduZXJJbmZvcyhtZHMpO1xuICAgIH0sXG5cbiAgICB2ZXJpZnk6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQS0NTIzcgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBub3QgeWV0IGltcGxlbWVudGVkLicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjZXJ0aWZpY2F0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZSB0byBhZGQuXG4gICAgICovXG4gICAgYWRkQ2VydGlmaWNhdGU6IGZ1bmN0aW9uKGNlcnQpIHtcbiAgICAgIC8vIGNvbnZlcnQgZnJvbSBQRU1cbiAgICAgIGlmKHR5cGVvZiBjZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBjZXJ0ID0gZm9yZ2UucGtpLmNlcnRpZmljYXRlRnJvbVBlbShjZXJ0KTtcbiAgICAgIH1cbiAgICAgIG1zZy5jZXJ0aWZpY2F0ZXMucHVzaChjZXJ0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgY2VydGlmaWNhdGUgcmV2b2thdGlvbiBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNybCB0aGUgY2VydGlmaWNhdGUgcmV2b2thdGlvbiBsaXN0IHRvIGFkZC5cbiAgICAgKi9cbiAgICBhZGRDZXJ0aWZpY2F0ZVJldm9rYXRpb25MaXN0OiBmdW5jdGlvbihjcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUEtDUyM3IENSTCBzdXBwb3J0IG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbXNnO1xuXG4gIGZ1bmN0aW9uIGFkZERpZ2VzdEFsZ29yaXRobUlkcygpIHtcbiAgICB2YXIgbWRzID0ge307XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbXNnLnNpZ25lcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzaWduZXIgPSBtc2cuc2lnbmVyc1tpXTtcbiAgICAgIHZhciBvaWQgPSBzaWduZXIuZGlnZXN0QWxnb3JpdGhtO1xuICAgICAgaWYoIShvaWQgaW4gbWRzKSkge1xuICAgICAgICAvLyBjb250ZW50IGRpZ2VzdFxuICAgICAgICBtZHNbb2lkXSA9IGZvcmdlLm1kW2ZvcmdlLnBraS5vaWRzW29pZF1dLmNyZWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYoc2lnbmVyLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBubyBjdXN0b20gYXR0cmlidXRlcyB0byBkaWdlc3Q7IHVzZSBjb250ZW50IG1lc3NhZ2UgZGlnZXN0XG4gICAgICAgIHNpZ25lci5tZCA9IG1kc1tvaWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3VzdG9tIGF0dHJpYnV0ZXMgdG8gYmUgZGlnZXN0ZWQ7IHVzZSBvd24gbWVzc2FnZSBkaWdlc3RcbiAgICAgICAgLy8gVE9ETzogb3B0aW1pemUgdG8ganVzdCBjb3B5IG1lc3NhZ2UgZGlnZXN0IHN0YXRlIGlmIHRoYXRcbiAgICAgICAgLy8gZmVhdHVyZSBpcyBldmVyIHN1cHBvcnRlZCB3aXRoIG1lc3NhZ2UgZGlnZXN0c1xuICAgICAgICBzaWduZXIubWQgPSBmb3JnZS5tZFtmb3JnZS5wa2kub2lkc1tvaWRdXS5jcmVhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgdW5pcXVlIGRpZ2VzdCBhbGdvcml0aG0gaWRlbnRpZmllcnNcbiAgICBtc2cuZGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcnMgPSBbXTtcbiAgICBmb3IodmFyIG9pZCBpbiBtZHMpIHtcbiAgICAgIG1zZy5kaWdlc3RBbGdvcml0aG1JZGVudGlmaWVycy5wdXNoKFxuICAgICAgICAvLyBBbGdvcml0aG1JZGVudGlmaWVyXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAvLyBhbGdvcml0aG1cbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgICBhc24xLm9pZFRvRGVyKG9pZCkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgLy8gcGFyYW1ldGVycyAobnVsbClcbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICAgICAgXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBtZHM7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRTaWduZXJJbmZvcyhtZHMpIHtcbiAgICB2YXIgY29udGVudDtcblxuICAgIGlmIChtc2cuZGV0YWNoZWRDb250ZW50KSB7XG4gICAgICAvLyBTaWduYXR1cmUgaGFzIGJlZW4gbWFkZSBpbiBkZXRhY2hlZCBtb2RlLlxuICAgICAgY29udGVudCA9IG1zZy5kZXRhY2hlZENvbnRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vdGU6IENvbnRlbnRJbmZvIGlzIGEgU0VRVUVOQ0Ugd2l0aCAyIHZhbHVlcywgc2Vjb25kIHZhbHVlIGlzXG4gICAgICAvLyB0aGUgY29udGVudCBmaWVsZCBhbmQgaXMgb3B0aW9uYWwgZm9yIGEgQ29udGVudEluZm8gYnV0IHJlcXVpcmVkIGhlcmVcbiAgICAgIC8vIHNpbmNlIHNpZ25lcnMgYXJlIHByZXNlbnRcbiAgICAgIC8vIGdldCBDb250ZW50SW5mbyBjb250ZW50XG4gICAgICBjb250ZW50ID0gbXNnLmNvbnRlbnRJbmZvLnZhbHVlWzFdO1xuICAgICAgLy8gc2tpcCBbMF0gRVhQTElDSVQgY29udGVudCB3cmFwcGVyXG4gICAgICBjb250ZW50ID0gY29udGVudC52YWx1ZVswXTtcbiAgICB9XG5cbiAgICBpZighY29udGVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ291bGQgbm90IHNpZ24gUEtDUyM3IG1lc3NhZ2U7IHRoZXJlIGlzIG5vIGNvbnRlbnQgdG8gc2lnbi4nKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgQ29udGVudEluZm8gY29udGVudCB0eXBlXG4gICAgdmFyIGNvbnRlbnRUeXBlID0gYXNuMS5kZXJUb09pZChtc2cuY29udGVudEluZm8udmFsdWVbMF0udmFsdWUpO1xuXG4gICAgLy8gc2VyaWFsaXplIGNvbnRlbnRcbiAgICB2YXIgYnl0ZXMgPSBhc24xLnRvRGVyKGNvbnRlbnQpO1xuXG4gICAgLy8gc2tpcCBpZGVudGlmaWVyIGFuZCBsZW5ndGggcGVyIFJGQyAyMzE1IDkuM1xuICAgIC8vIHNraXAgaWRlbnRpZmllciAoMSBieXRlKVxuICAgIGJ5dGVzLmdldEJ5dGUoKTtcbiAgICAvLyByZWFkIGFuZCBkaXNjYXJkIGxlbmd0aCBieXRlc1xuICAgIGFzbjEuZ2V0QmVyVmFsdWVMZW5ndGgoYnl0ZXMpO1xuICAgIGJ5dGVzID0gYnl0ZXMuZ2V0Qnl0ZXMoKTtcblxuICAgIC8vIGRpZ2VzdCBjb250ZW50IERFUiB2YWx1ZSBieXRlc1xuICAgIGZvcih2YXIgb2lkIGluIG1kcykge1xuICAgICAgbWRzW29pZF0uc3RhcnQoKS51cGRhdGUoYnl0ZXMpO1xuICAgIH1cblxuICAgIC8vIHNpZ24gY29udGVudFxuICAgIHZhciBzaWduaW5nVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1zZy5zaWduZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc2lnbmVyID0gbXNnLnNpZ25lcnNbaV07XG5cbiAgICAgIGlmKHNpZ25lci5hdXRoZW50aWNhdGVkQXR0cmlidXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gaWYgQ29udGVudEluZm8gY29udGVudCB0eXBlIGlzIG5vdCBcIkRhdGFcIiwgdGhlblxuICAgICAgICAvLyBhdXRoZW50aWNhdGVkQXR0cmlidXRlcyBtdXN0IGJlIHByZXNlbnQgcGVyIFJGQyAyMzE1XG4gICAgICAgIGlmKGNvbnRlbnRUeXBlICE9PSBmb3JnZS5wa2kub2lkcy5kYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgc2lnbmVyOyBhdXRoZW50aWNhdGVkQXR0cmlidXRlcyBtdXN0IGJlIHByZXNlbnQgJyArXG4gICAgICAgICAgICAnd2hlbiB0aGUgQ29udGVudEluZm8gY29udGVudCB0eXBlIGlzIG5vdCBQS0NTIzcgRGF0YS4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcHJvY2VzcyBhdXRoZW50aWNhdGVkIGF0dHJpYnV0ZXNcbiAgICAgICAgLy8gWzBdIElNUExJQ0lUXG4gICAgICAgIHNpZ25lci5hdXRoZW50aWNhdGVkQXR0cmlidXRlc0FzbjEgPSBhc24xLmNyZWF0ZShcbiAgICAgICAgICBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtdKTtcblxuICAgICAgICAvLyBwZXIgUkZDIDIzMTUsIGF0dHJpYnV0ZXMgYXJlIHRvIGJlIGRpZ2VzdGVkIHVzaW5nIGEgU0VUIGNvbnRhaW5lclxuICAgICAgICAvLyBub3QgdGhlIGFib3ZlIFswXSBJTVBMSUNJVCBjb250YWluZXJcbiAgICAgICAgdmFyIGF0dHJzQXNuMSA9IGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXSk7XG5cbiAgICAgICAgZm9yKHZhciBhaSA9IDA7IGFpIDwgc2lnbmVyLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzLmxlbmd0aDsgKythaSkge1xuICAgICAgICAgIHZhciBhdHRyID0gc2lnbmVyLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzW2FpXTtcbiAgICAgICAgICBpZihhdHRyLnR5cGUgPT09IGZvcmdlLnBraS5vaWRzLm1lc3NhZ2VEaWdlc3QpIHtcbiAgICAgICAgICAgIC8vIHVzZSBjb250ZW50IG1lc3NhZ2UgZGlnZXN0IGFzIHZhbHVlXG4gICAgICAgICAgICBhdHRyLnZhbHVlID0gbWRzW3NpZ25lci5kaWdlc3RBbGdvcml0aG1dLmRpZ2VzdCgpO1xuICAgICAgICAgIH0gZWxzZSBpZihhdHRyLnR5cGUgPT09IGZvcmdlLnBraS5vaWRzLnNpZ25pbmdUaW1lKSB7XG4gICAgICAgICAgICAvLyBhdXRvLXBvcHVsYXRlIHNpZ25pbmcgdGltZSBpZiBub3QgYWxyZWFkeSBzZXRcbiAgICAgICAgICAgIGlmKCFhdHRyLnZhbHVlKSB7XG4gICAgICAgICAgICAgIGF0dHIudmFsdWUgPSBzaWduaW5nVGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBjb252ZXJ0IHRvIEFTTi4xIGFuZCBwdXNoIG9udG8gQXR0cmlidXRlcyBTRVQgKGZvciBzaWduaW5nKSBhbmRcbiAgICAgICAgICAvLyBvbnRvIGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzQXNuMSB0byBjb21wbGV0ZSBTaWduZWREYXRhIEFTTi4xXG4gICAgICAgICAgLy8gVE9ETzogb3B0aW1pemUgYXdheSBkdXBsaWNhdGlvblxuICAgICAgICAgIGF0dHJzQXNuMS52YWx1ZS5wdXNoKF9hdHRyaWJ1dGVUb0FzbjEoYXR0cikpO1xuICAgICAgICAgIHNpZ25lci5hdXRoZW50aWNhdGVkQXR0cmlidXRlc0FzbjEudmFsdWUucHVzaChfYXR0cmlidXRlVG9Bc24xKGF0dHIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERFUi1zZXJpYWxpemUgYW5kIGRpZ2VzdCBTRVQgT0YgYXR0cmlidXRlcyBvbmx5XG4gICAgICAgIGJ5dGVzID0gYXNuMS50b0RlcihhdHRyc0FzbjEpLmdldEJ5dGVzKCk7XG4gICAgICAgIHNpZ25lci5tZC5zdGFydCgpLnVwZGF0ZShieXRlcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNpZ24gZGlnZXN0XG4gICAgICBzaWduZXIuc2lnbmF0dXJlID0gc2lnbmVyLmtleS5zaWduKHNpZ25lci5tZCwgJ1JTQVNTQS1QS0NTMS1WMV81Jyk7XG4gICAgfVxuXG4gICAgLy8gYWRkIHNpZ25lciBpbmZvXG4gICAgbXNnLnNpZ25lckluZm9zID0gX3NpZ25lcnNUb0FzbjEobXNnLnNpZ25lcnMpO1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW1wdHkgUEtDUyM3IG1lc3NhZ2Ugb2YgdHlwZSBFbmNyeXB0ZWREYXRhLlxuICpcbiAqIEByZXR1cm4gdGhlIG1lc3NhZ2UuXG4gKi9cbnA3LmNyZWF0ZUVuY3J5cHRlZERhdGEgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG1zZyA9IG51bGw7XG4gIG1zZyA9IHtcbiAgICB0eXBlOiBmb3JnZS5wa2kub2lkcy5lbmNyeXB0ZWREYXRhLFxuICAgIHZlcnNpb246IDAsXG4gICAgZW5jcnlwdGVkQ29udGVudDoge1xuICAgICAgYWxnb3JpdGhtOiBmb3JnZS5wa2kub2lkc1snYWVzMjU2LUNCQyddXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIEVuY3J5cHRlZERhdGEgY29udGVudCBibG9jayAoaW4gQVNOLjEgZm9ybWF0KVxuICAgICAqXG4gICAgICogQHBhcmFtIG9iaiBUaGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgdGhlIEVuY3J5cHRlZERhdGEgY29udGVudCBibG9ja1xuICAgICAqL1xuICAgIGZyb21Bc24xOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIC8vIFZhbGlkYXRlIEVuY3J5cHRlZERhdGEgY29udGVudCBibG9jayBhbmQgY2FwdHVyZSBkYXRhLlxuICAgICAgX2Zyb21Bc24xKG1zZywgb2JqLCBwNy5hc24xLmVuY3J5cHRlZERhdGFWYWxpZGF0b3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNyeXB0IGVuY3J5cHRlZCBjb250ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSAoc3ltbWV0cmljKSBrZXkgYXMgYSBieXRlIGJ1ZmZlclxuICAgICAqL1xuICAgIGRlY3J5cHQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbXNnLmVuY3J5cHRlZENvbnRlbnQua2V5ID0ga2V5O1xuICAgICAgfVxuICAgICAgX2RlY3J5cHRDb250ZW50KG1zZyk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbXNnO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVtcHR5IFBLQ1MjNyBtZXNzYWdlIG9mIHR5cGUgRW52ZWxvcGVkRGF0YS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBtZXNzYWdlLlxuICovXG5wNy5jcmVhdGVFbnZlbG9wZWREYXRhID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtc2cgPSBudWxsO1xuICBtc2cgPSB7XG4gICAgdHlwZTogZm9yZ2UucGtpLm9pZHMuZW52ZWxvcGVkRGF0YSxcbiAgICB2ZXJzaW9uOiAwLFxuICAgIHJlY2lwaWVudHM6IFtdLFxuICAgIGVuY3J5cHRlZENvbnRlbnQ6IHtcbiAgICAgIGFsZ29yaXRobTogZm9yZ2UucGtpLm9pZHNbJ2FlczI1Ni1DQkMnXVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBFbnZlbG9wZWREYXRhIGNvbnRlbnQgYmxvY2sgKGluIEFTTi4xIGZvcm1hdClcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvYmogdGhlIEFTTi4xIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBFbnZlbG9wZWREYXRhIGNvbnRlbnQgYmxvY2suXG4gICAgICovXG4gICAgZnJvbUFzbjE6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgLy8gdmFsaWRhdGUgRW52ZWxvcGVkRGF0YSBjb250ZW50IGJsb2NrIGFuZCBjYXB0dXJlIGRhdGFcbiAgICAgIHZhciBjYXB0dXJlID0gX2Zyb21Bc24xKG1zZywgb2JqLCBwNy5hc24xLmVudmVsb3BlZERhdGFWYWxpZGF0b3IpO1xuICAgICAgbXNnLnJlY2lwaWVudHMgPSBfcmVjaXBpZW50c0Zyb21Bc24xKGNhcHR1cmUucmVjaXBpZW50SW5mb3MudmFsdWUpO1xuICAgIH0sXG5cbiAgICB0b0FzbjE6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQ29udGVudEluZm9cbiAgICAgIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIENvbnRlbnRUeXBlXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICBhc24xLm9pZFRvRGVyKG1zZy50eXBlKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gWzBdIEVudmVsb3BlZERhdGFcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgICAgLy8gVmVyc2lvblxuICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIobXNnLnZlcnNpb24pLmdldEJ5dGVzKCkpLFxuICAgICAgICAgICAgLy8gUmVjaXBpZW50SW5mb3NcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLFxuICAgICAgICAgICAgICBfcmVjaXBpZW50c1RvQXNuMShtc2cucmVjaXBpZW50cykpLFxuICAgICAgICAgICAgLy8gRW5jcnlwdGVkQ29udGVudEluZm9cbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsXG4gICAgICAgICAgICAgIF9lbmNyeXB0ZWRDb250ZW50VG9Bc24xKG1zZy5lbmNyeXB0ZWRDb250ZW50KSlcbiAgICAgICAgICBdKVxuICAgICAgICBdKVxuICAgICAgXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgcmVjaXBpZW50IGJ5IFguNTA5IGNlcnRpZmljYXRlJ3MgaXNzdWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIHdpdGggdGhlIGlzc3VlciB0byBsb29rIGZvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhlIHJlY2lwaWVudCBvYmplY3QuXG4gICAgICovXG4gICAgZmluZFJlY2lwaWVudDogZnVuY3Rpb24oY2VydCkge1xuICAgICAgdmFyIHNBdHRyID0gY2VydC5pc3N1ZXIuYXR0cmlidXRlcztcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1zZy5yZWNpcGllbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciByID0gbXNnLnJlY2lwaWVudHNbaV07XG4gICAgICAgIHZhciByQXR0ciA9IHIuaXNzdWVyO1xuXG4gICAgICAgIGlmKHIuc2VyaWFsTnVtYmVyICE9PSBjZXJ0LnNlcmlhbE51bWJlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYockF0dHIubGVuZ3RoICE9PSBzQXR0ci5sZW5ndGgpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXRjaCA9IHRydWU7XG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBzQXR0ci5sZW5ndGg7ICsraikge1xuICAgICAgICAgIGlmKHJBdHRyW2pdLnR5cGUgIT09IHNBdHRyW2pdLnR5cGUgfHxcbiAgICAgICAgICAgIHJBdHRyW2pdLnZhbHVlICE9PSBzQXR0cltqXS52YWx1ZSkge1xuICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY3J5cHQgZW52ZWxvcGVkIGNvbnRlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWNpcGllbnQgVGhlIHJlY2lwaWVudCBvYmplY3QgcmVsYXRlZCB0byB0aGUgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gcHJpdktleSBUaGUgKFJTQSkgcHJpdmF0ZSBrZXkgb2JqZWN0XG4gICAgICovXG4gICAgZGVjcnlwdDogZnVuY3Rpb24ocmVjaXBpZW50LCBwcml2S2V5KSB7XG4gICAgICBpZihtc2cuZW5jcnlwdGVkQ29udGVudC5rZXkgPT09IHVuZGVmaW5lZCAmJiByZWNpcGllbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBwcml2S2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3dpdGNoKHJlY2lwaWVudC5lbmNyeXB0ZWRDb250ZW50LmFsZ29yaXRobSkge1xuICAgICAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHMucnNhRW5jcnlwdGlvbjpcbiAgICAgICAgICBjYXNlIGZvcmdlLnBraS5vaWRzLmRlc0NCQzpcbiAgICAgICAgICAgIHZhciBrZXkgPSBwcml2S2V5LmRlY3J5cHQocmVjaXBpZW50LmVuY3J5cHRlZENvbnRlbnQuY29udGVudCk7XG4gICAgICAgICAgICBtc2cuZW5jcnlwdGVkQ29udGVudC5rZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBhc3ltbWV0cmljIGNpcGhlciwgJyArXG4gICAgICAgICAgICAgICdPSUQgJyArIHJlY2lwaWVudC5lbmNyeXB0ZWRDb250ZW50LmFsZ29yaXRobSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2RlY3J5cHRDb250ZW50KG1zZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCAoYW5vdGhlcikgZW50aXR5IHRvIGxpc3Qgb2YgcmVjaXBpZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjZXJ0IFRoZSBjZXJ0aWZpY2F0ZSBvZiB0aGUgZW50aXR5IHRvIGFkZC5cbiAgICAgKi9cbiAgICBhZGRSZWNpcGllbnQ6IGZ1bmN0aW9uKGNlcnQpIHtcbiAgICAgIG1zZy5yZWNpcGllbnRzLnB1c2goe1xuICAgICAgICB2ZXJzaW9uOiAwLFxuICAgICAgICBpc3N1ZXI6IGNlcnQuaXNzdWVyLmF0dHJpYnV0ZXMsXG4gICAgICAgIHNlcmlhbE51bWJlcjogY2VydC5zZXJpYWxOdW1iZXIsXG4gICAgICAgIGVuY3J5cHRlZENvbnRlbnQ6IHtcbiAgICAgICAgICAvLyBXZSBzaW1wbHkgYXNzdW1lIHJzYUVuY3J5cHRpb24gaGVyZSwgc2luY2UgZm9yZ2UucGtpIG9ubHlcbiAgICAgICAgICAvLyBzdXBwb3J0cyBSU0Egc28gZmFyLiAgSWYgdGhlIFBLSSBtb2R1bGUgc3VwcG9ydHMgb3RoZXJcbiAgICAgICAgICAvLyBjaXBoZXJzIG9uZSBkYXksIHdlIG5lZWQgdG8gbW9kaWZ5IHRoaXMgb25lIGFzIHdlbGwuXG4gICAgICAgICAgYWxnb3JpdGhtOiBmb3JnZS5wa2kub2lkcy5yc2FFbmNyeXB0aW9uLFxuICAgICAgICAgIGtleTogY2VydC5wdWJsaWNLZXlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuY3J5cHQgZW52ZWxvcGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHN1cHBvcnRzIHR3byBvcHRpb25hbCBhcmd1bWVudHMsIGNpcGhlciBhbmQga2V5LCB3aGljaFxuICAgICAqIGNhbiBiZSB1c2VkIHRvIGluZmx1ZW5jZSBzeW1tZXRyaWMgZW5jcnlwdGlvbi4gIFVubGVzcyBjaXBoZXIgaXNcbiAgICAgKiBwcm92aWRlZCwgdGhlIGNpcGhlciBzcGVjaWZpZWQgaW4gZW5jcnlwdGVkQ29udGVudC5hbGdvcml0aG0gaXMgdXNlZFxuICAgICAqIChkZWZhdWx0cyB0byBBRVMtMjU2LUNCQykuICBJZiBubyBrZXkgaXMgcHJvdmlkZWQsIGVuY3J5cHRlZENvbnRlbnQua2V5XG4gICAgICogaXMgKHJlLSl1c2VkLiAgSWYgdGhhdCBvbmUncyBub3Qgc2V0LCBhIHJhbmRvbSBrZXkgd2lsbCBiZSBnZW5lcmF0ZWRcbiAgICAgKiBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIFtrZXldIFRoZSBrZXkgdG8gYmUgdXNlZCBmb3Igc3ltbWV0cmljIGVuY3J5cHRpb24uXG4gICAgICogQHBhcmFtIFtjaXBoZXJdIFRoZSBPSUQgb2YgdGhlIHN5bW1ldHJpYyBjaXBoZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIGVuY3J5cHQ6IGZ1bmN0aW9uKGtleSwgY2lwaGVyKSB7XG4gICAgICAvLyBQYXJ0IDE6IFN5bW1ldHJpYyBlbmNyeXB0aW9uXG4gICAgICBpZihtc2cuZW5jcnlwdGVkQ29udGVudC5jb250ZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2lwaGVyID0gY2lwaGVyIHx8IG1zZy5lbmNyeXB0ZWRDb250ZW50LmFsZ29yaXRobTtcbiAgICAgICAga2V5ID0ga2V5IHx8IG1zZy5lbmNyeXB0ZWRDb250ZW50LmtleTtcblxuICAgICAgICB2YXIga2V5TGVuLCBpdkxlbiwgY2lwaEZuO1xuICAgICAgICBzd2l0Y2goY2lwaGVyKSB7XG4gICAgICAgICAgY2FzZSBmb3JnZS5wa2kub2lkc1snYWVzMTI4LUNCQyddOlxuICAgICAgICAgICAga2V5TGVuID0gMTY7XG4gICAgICAgICAgICBpdkxlbiA9IDE2O1xuICAgICAgICAgICAgY2lwaEZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHNbJ2FlczE5Mi1DQkMnXTpcbiAgICAgICAgICAgIGtleUxlbiA9IDI0O1xuICAgICAgICAgICAgaXZMZW4gPSAxNjtcbiAgICAgICAgICAgIGNpcGhGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIGZvcmdlLnBraS5vaWRzWydhZXMyNTYtQ0JDJ106XG4gICAgICAgICAgICBrZXlMZW4gPSAzMjtcbiAgICAgICAgICAgIGl2TGVuID0gMTY7XG4gICAgICAgICAgICBjaXBoRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBmb3JnZS5wa2kub2lkc1snZGVzLUVERTMtQ0JDJ106XG4gICAgICAgICAgICBrZXlMZW4gPSAyNDtcbiAgICAgICAgICAgIGl2TGVuID0gODtcbiAgICAgICAgICAgIGNpcGhGbiA9IGZvcmdlLmRlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzeW1tZXRyaWMgY2lwaGVyLCBPSUQgJyArIGNpcGhlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZihrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGZvcmdlLnJhbmRvbS5nZXRCeXRlcyhrZXlMZW4pKTtcbiAgICAgICAgfSBlbHNlIGlmKGtleS5sZW5ndGgoKSAhPSBrZXlMZW4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N5bW1ldHJpYyBrZXkgaGFzIHdyb25nIGxlbmd0aDsgJyArXG4gICAgICAgICAgICAnZ290ICcgKyBrZXkubGVuZ3RoKCkgKyAnIGJ5dGVzLCBleHBlY3RlZCAnICsga2V5TGVuICsgJy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEtlZXAgYSBjb3B5IG9mIHRoZSBrZXkgJiBJViBpbiB0aGUgb2JqZWN0LCBzbyB0aGUgY2FsbGVyIGNhblxuICAgICAgICAvLyB1c2UgaXQgZm9yIHdoYXRldmVyIHJlYXNvbi5cbiAgICAgICAgbXNnLmVuY3J5cHRlZENvbnRlbnQuYWxnb3JpdGhtID0gY2lwaGVyO1xuICAgICAgICBtc2cuZW5jcnlwdGVkQ29udGVudC5rZXkgPSBrZXk7XG4gICAgICAgIG1zZy5lbmNyeXB0ZWRDb250ZW50LnBhcmFtZXRlciA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKFxuICAgICAgICAgIGZvcmdlLnJhbmRvbS5nZXRCeXRlcyhpdkxlbikpO1xuXG4gICAgICAgIHZhciBjaXBoID0gY2lwaEZuKGtleSk7XG4gICAgICAgIGNpcGguc3RhcnQobXNnLmVuY3J5cHRlZENvbnRlbnQucGFyYW1ldGVyLmNvcHkoKSk7XG4gICAgICAgIGNpcGgudXBkYXRlKG1zZy5jb250ZW50KTtcblxuICAgICAgICAvLyBUaGUgZmluaXNoIGZ1bmN0aW9uIGRvZXMgUEtDUyM3IHBhZGRpbmcgYnkgZGVmYXVsdCwgdGhlcmVmb3JlXG4gICAgICAgIC8vIG5vIGFjdGlvbiByZXF1aXJlZCBieSB1cy5cbiAgICAgICAgaWYoIWNpcGguZmluaXNoKCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N5bW1ldHJpYyBlbmNyeXB0aW9uIGZhaWxlZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1zZy5lbmNyeXB0ZWRDb250ZW50LmNvbnRlbnQgPSBjaXBoLm91dHB1dDtcbiAgICAgIH1cblxuICAgICAgLy8gUGFydCAyOiBhc3ltbWV0cmljIGVuY3J5cHRpb24gZm9yIGVhY2ggcmVjaXBpZW50XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbXNnLnJlY2lwaWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlY2lwaWVudCA9IG1zZy5yZWNpcGllbnRzW2ldO1xuXG4gICAgICAgIC8vIE5vdGhpbmcgdG8gZG8sIGVuY3J5cHRpb24gYWxyZWFkeSBkb25lLlxuICAgICAgICBpZihyZWNpcGllbnQuZW5jcnlwdGVkQ29udGVudC5jb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaChyZWNpcGllbnQuZW5jcnlwdGVkQ29udGVudC5hbGdvcml0aG0pIHtcbiAgICAgICAgICBjYXNlIGZvcmdlLnBraS5vaWRzLnJzYUVuY3J5cHRpb246XG4gICAgICAgICAgICByZWNpcGllbnQuZW5jcnlwdGVkQ29udGVudC5jb250ZW50ID1cbiAgICAgICAgICAgICAgcmVjaXBpZW50LmVuY3J5cHRlZENvbnRlbnQua2V5LmVuY3J5cHQoXG4gICAgICAgICAgICAgICAgbXNnLmVuY3J5cHRlZENvbnRlbnQua2V5LmRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBhc3ltbWV0cmljIGNpcGhlciwgT0lEICcgK1xuICAgICAgICAgICAgICByZWNpcGllbnQuZW5jcnlwdGVkQ29udGVudC5hbGdvcml0aG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gbXNnO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNpbmdsZSByZWNpcGllbnQgZnJvbSBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgQVNOLjEgUmVjaXBpZW50SW5mby5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZWNpcGllbnQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBfcmVjaXBpZW50RnJvbUFzbjEob2JqKSB7XG4gIC8vIHZhbGlkYXRlIEVudmVsb3BlZERhdGEgY29udGVudCBibG9jayBhbmQgY2FwdHVyZSBkYXRhXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCBwNy5hc24xLnJlY2lwaWVudEluZm9WYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIFBLQ1MjNyBSZWNpcGllbnRJbmZvLiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgaXMgbm90IGFuIFBLQ1MjNyBSZWNpcGllbnRJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmVyc2lvbjogY2FwdHVyZS52ZXJzaW9uLmNoYXJDb2RlQXQoMCksXG4gICAgaXNzdWVyOiBmb3JnZS5wa2kuUkROQXR0cmlidXRlc0FzQXJyYXkoY2FwdHVyZS5pc3N1ZXIpLFxuICAgIHNlcmlhbE51bWJlcjogZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5zZXJpYWwpLnRvSGV4KCksXG4gICAgZW5jcnlwdGVkQ29udGVudDoge1xuICAgICAgYWxnb3JpdGhtOiBhc24xLmRlclRvT2lkKGNhcHR1cmUuZW5jQWxnb3JpdGhtKSxcbiAgICAgIHBhcmFtZXRlcjogY2FwdHVyZS5lbmNQYXJhbWV0ZXIudmFsdWUsXG4gICAgICBjb250ZW50OiBjYXB0dXJlLmVuY0tleVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNpbmdsZSByZWNpcGllbnQgb2JqZWN0IHRvIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSByZWNpcGllbnQgb2JqZWN0LlxuICpcbiAqIEByZXR1cm4gdGhlIEFTTi4xIFJlY2lwaWVudEluZm8uXG4gKi9cbmZ1bmN0aW9uIF9yZWNpcGllbnRUb0FzbjEob2JqKSB7XG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gVmVyc2lvblxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBhc24xLmludGVnZXJUb0RlcihvYmoudmVyc2lvbikuZ2V0Qnl0ZXMoKSksXG4gICAgLy8gSXNzdWVyQW5kU2VyaWFsTnVtYmVyXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gTmFtZVxuICAgICAgZm9yZ2UucGtpLmRpc3Rpbmd1aXNoZWROYW1lVG9Bc24xKHthdHRyaWJ1dGVzOiBvYmouaXNzdWVyfSksXG4gICAgICAvLyBTZXJpYWxcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICAgIGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhvYmouc2VyaWFsTnVtYmVyKSlcbiAgICBdKSxcbiAgICAvLyBLZXlFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllclxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIC8vIEFsZ29yaXRobVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKG9iai5lbmNyeXB0ZWRDb250ZW50LmFsZ29yaXRobSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBQYXJhbWV0ZXIsIGZvcmNlIE5VTEwsIG9ubHkgUlNBIHN1cHBvcnRlZCBmb3Igbm93LlxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpXG4gICAgXSksXG4gICAgLy8gRW5jcnlwdGVkS2V5XG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsXG4gICAgICBvYmouZW5jcnlwdGVkQ29udGVudC5jb250ZW50KVxuICBdKTtcbn1cblxuLyoqXG4gKiBNYXAgYSBzZXQgb2YgUmVjaXBpZW50SW5mbyBBU04uMSBvYmplY3RzIHRvIHJlY2lwaWVudCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSBpbmZvcyBhbiBhcnJheSBvZiBBU04uMSByZXByZXNlbnRhdGlvbnMgUmVjaXBpZW50SW5mbyAoaS5lLiBTRVQgT0YpLlxuICpcbiAqIEByZXR1cm4gYW4gYXJyYXkgb2YgcmVjaXBpZW50IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIF9yZWNpcGllbnRzRnJvbUFzbjEoaW5mb3MpIHtcbiAgdmFyIHJldCA9IFtdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5mb3MubGVuZ3RoOyArK2kpIHtcbiAgICByZXQucHVzaChfcmVjaXBpZW50RnJvbUFzbjEoaW5mb3NbaV0pKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIE1hcCBhbiBhcnJheSBvZiByZWNpcGllbnQgb2JqZWN0cyB0byBBU04uMSBSZWNpcGllbnRJbmZvIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHJlY2lwaWVudHMgYW4gYXJyYXkgb2YgcmVjaXBpZW50SW5mbyBvYmplY3RzLlxuICpcbiAqIEByZXR1cm4gYW4gYXJyYXkgb2YgQVNOLjEgUmVjaXBpZW50SW5mb3MuXG4gKi9cbmZ1bmN0aW9uIF9yZWNpcGllbnRzVG9Bc24xKHJlY2lwaWVudHMpIHtcbiAgdmFyIHJldCA9IFtdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgcmVjaXBpZW50cy5sZW5ndGg7ICsraSkge1xuICAgIHJldC5wdXNoKF9yZWNpcGllbnRUb0FzbjEocmVjaXBpZW50c1tpXSkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzaW5nbGUgc2lnbmVyIGZyb20gYW4gQVNOLjEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIEFTTi4xIHJlcHJlc2VudGF0aW9uIG9mIGEgU2lnbmVySW5mby5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzaWduZXIgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBfc2lnbmVyRnJvbUFzbjEob2JqKSB7XG4gIC8vIHZhbGlkYXRlIEVudmVsb3BlZERhdGEgY29udGVudCBibG9jayBhbmQgY2FwdHVyZSBkYXRhXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCBwNy5hc24xLnNpZ25lckluZm9WYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIFBLQ1MjNyBTaWduZXJJbmZvLiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgaXMgbm90IGFuIFBLQ1MjNyBTaWduZXJJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBydmFsID0ge1xuICAgIHZlcnNpb246IGNhcHR1cmUudmVyc2lvbi5jaGFyQ29kZUF0KDApLFxuICAgIGlzc3VlcjogZm9yZ2UucGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5KGNhcHR1cmUuaXNzdWVyKSxcbiAgICBzZXJpYWxOdW1iZXI6IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUuc2VyaWFsKS50b0hleCgpLFxuICAgIGRpZ2VzdEFsZ29yaXRobTogYXNuMS5kZXJUb09pZChjYXB0dXJlLmRpZ2VzdEFsZ29yaXRobSksXG4gICAgc2lnbmF0dXJlQWxnb3JpdGhtOiBhc24xLmRlclRvT2lkKGNhcHR1cmUuc2lnbmF0dXJlQWxnb3JpdGhtKSxcbiAgICBzaWduYXR1cmU6IGNhcHR1cmUuc2lnbmF0dXJlLFxuICAgIGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzOiBbXSxcbiAgICB1bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzOiBbXVxuICB9O1xuXG4gIC8vIFRPRE86IGNvbnZlcnQgYXR0cmlidXRlc1xuICB2YXIgYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMgPSBjYXB0dXJlLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzIHx8IFtdO1xuICB2YXIgdW5hdXRoZW50aWNhdGVkQXR0cmlidXRlcyA9IGNhcHR1cmUudW5hdXRoZW50aWNhdGVkQXR0cmlidXRlcyB8fCBbXTtcblxuICByZXR1cm4gcnZhbDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNpbmdsZSBzaWduZXJJbmZvIG9iamVjdCB0byBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgc2lnbmVySW5mbyBvYmplY3QuXG4gKlxuICogQHJldHVybiB0aGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgYSBTaWduZXJJbmZvLlxuICovXG5mdW5jdGlvbiBfc2lnbmVyVG9Bc24xKG9iaikge1xuICAvLyBTaWduZXJJbmZvXG4gIHZhciBydmFsID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgIC8vIHZlcnNpb25cbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIob2JqLnZlcnNpb24pLmdldEJ5dGVzKCkpLFxuICAgIC8vIGlzc3VlckFuZFNlcmlhbE51bWJlclxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIC8vIG5hbWVcbiAgICAgIGZvcmdlLnBraS5kaXN0aW5ndWlzaGVkTmFtZVRvQXNuMSh7YXR0cmlidXRlczogb2JqLmlzc3Vlcn0pLFxuICAgICAgLy8gc2VyaWFsXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICBmb3JnZS51dGlsLmhleFRvQnl0ZXMob2JqLnNlcmlhbE51bWJlcikpXG4gICAgXSksXG4gICAgLy8gZGlnZXN0QWxnb3JpdGhtXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIob2JqLmRpZ2VzdEFsZ29yaXRobSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBwYXJhbWV0ZXJzIChudWxsKVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpXG4gICAgXSlcbiAgXSk7XG5cbiAgLy8gYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMgKE9QVElPTkFMKVxuICBpZihvYmouYXV0aGVudGljYXRlZEF0dHJpYnV0ZXNBc24xKSB7XG4gICAgLy8gYWRkIEFTTi4xIHByZXZpb3VzbHkgZ2VuZXJhdGVkIGR1cmluZyBzaWduaW5nXG4gICAgcnZhbC52YWx1ZS5wdXNoKG9iai5hdXRoZW50aWNhdGVkQXR0cmlidXRlc0FzbjEpO1xuICB9XG5cbiAgLy8gZGlnZXN0RW5jcnlwdGlvbkFsZ29yaXRobVxuICBydmFsLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgIC8vIGFsZ29yaXRobVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgIGFzbjEub2lkVG9EZXIob2JqLnNpZ25hdHVyZUFsZ29yaXRobSkuZ2V0Qnl0ZXMoKSksXG4gICAgLy8gcGFyYW1ldGVycyAobnVsbClcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgXSkpO1xuXG4gIC8vIGVuY3J5cHRlZERpZ2VzdFxuICBydmFsLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIG9iai5zaWduYXR1cmUpKTtcblxuICAvLyB1bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzIChPUFRJT05BTClcbiAgaWYob2JqLnVuYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgIC8vIFsxXSBJTVBMSUNJVFxuICAgIHZhciBhdHRyc0FzbjEgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDEsIHRydWUsIFtdKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgb2JqLnVuYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBhdHRyID0gb2JqLnVuYXV0aGVudGljYXRlZEF0dHJpYnV0ZXNbaV07XG4gICAgICBhdHRyc0FzbjEudmFsdWVzLnB1c2goX2F0dHJpYnV0ZVRvQXNuMShhdHRyKSk7XG4gICAgfVxuICAgIHJ2YWwudmFsdWUucHVzaChhdHRyc0FzbjEpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogTWFwIGEgc2V0IG9mIFNpZ25lckluZm8gQVNOLjEgb2JqZWN0cyB0byBhbiBhcnJheSBvZiBzaWduZXIgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gc2lnbmVySW5mb0FzbjFzIGFuIGFycmF5IG9mIEFTTi4xIFNpZ25lckluZm9zIChpLmUuIFNFVCBPRikuXG4gKlxuICogQHJldHVybiBhbiBhcnJheSBvZiBzaWduZXJzIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIF9zaWduZXJzRnJvbUFzbjEoc2lnbmVySW5mb0FzbjFzKSB7XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHNpZ25lckluZm9Bc24xcy5sZW5ndGg7ICsraSkge1xuICAgIHJldC5wdXNoKF9zaWduZXJGcm9tQXNuMShzaWduZXJJbmZvQXNuMXNbaV0pKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIE1hcCBhbiBhcnJheSBvZiBzaWduZXIgb2JqZWN0cyB0byBBU04uMSBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSBzaWduZXJzIGFuIGFycmF5IG9mIHNpZ25lciBvYmplY3RzLlxuICpcbiAqIEByZXR1cm4gYW4gYXJyYXkgb2YgQVNOLjEgU2lnbmVySW5mb3MuXG4gKi9cbmZ1bmN0aW9uIF9zaWduZXJzVG9Bc24xKHNpZ25lcnMpIHtcbiAgdmFyIHJldCA9IFtdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2lnbmVycy5sZW5ndGg7ICsraSkge1xuICAgIHJldC5wdXNoKF9zaWduZXJUb0FzbjEoc2lnbmVyc1tpXSkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBhdHRyaWJ1dGUgb2JqZWN0IHRvIGFuIEFTTi4xIEF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0gYXR0ciB0aGUgYXR0cmlidXRlIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBBdHRyaWJ1dGUuXG4gKi9cbmZ1bmN0aW9uIF9hdHRyaWJ1dGVUb0FzbjEoYXR0cikge1xuICB2YXIgdmFsdWU7XG5cbiAgLy8gVE9ETzogZ2VuZXJhbGl6ZSB0byBzdXBwb3J0IG1vcmUgYXR0cmlidXRlc1xuICBpZihhdHRyLnR5cGUgPT09IGZvcmdlLnBraS5vaWRzLmNvbnRlbnRUeXBlKSB7XG4gICAgdmFsdWUgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICBhc24xLm9pZFRvRGVyKGF0dHIudmFsdWUpLmdldEJ5dGVzKCkpO1xuICB9IGVsc2UgaWYoYXR0ci50eXBlID09PSBmb3JnZS5wa2kub2lkcy5tZXNzYWdlRGlnZXN0KSB7XG4gICAgdmFsdWUgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSxcbiAgICAgIGF0dHIudmFsdWUuYnl0ZXMoKSk7XG4gIH0gZWxzZSBpZihhdHRyLnR5cGUgPT09IGZvcmdlLnBraS5vaWRzLnNpZ25pbmdUaW1lKSB7XG4gICAgLyogTm90ZSBwZXIgUkZDIDI5ODU6IERhdGVzIGJldHdlZW4gMSBKYW51YXJ5IDE5NTAgYW5kIDMxIERlY2VtYmVyIDIwNDlcbiAgICAgIChpbmNsdXNpdmUpIE1VU1QgYmUgZW5jb2RlZCBhcyBVVENUaW1lLiBBbnkgZGF0ZXMgd2l0aCB5ZWFyIHZhbHVlc1xuICAgICAgYmVmb3JlIDE5NTAgb3IgYWZ0ZXIgMjA0OSBNVVNUIGJlIGVuY29kZWQgYXMgR2VuZXJhbGl6ZWRUaW1lLiBbRnVydGhlcixdXG4gICAgICBVVENUaW1lIHZhbHVlcyBNVVNUIGJlIGV4cHJlc3NlZCBpbiBHcmVlbndpY2ggTWVhbiBUaW1lIChadWx1KSBhbmQgTVVTVFxuICAgICAgaW5jbHVkZSBzZWNvbmRzIChpLmUuLCB0aW1lcyBhcmUgWVlNTURESEhNTVNTWiksIGV2ZW4gd2hlcmUgdGhlXG4gICAgICBudW1iZXIgb2Ygc2Vjb25kcyBpcyB6ZXJvLiAgTWlkbmlnaHQgKEdNVCkgbXVzdCBiZSByZXByZXNlbnRlZCBhc1xuICAgICAgXCJZWU1NREQwMDAwMDBaXCIuICovXG4gICAgLy8gVE9ETzogbWFrZSB0aGVzZSBtb2R1bGUtbGV2ZWwgY29uc3RhbnRzXG4gICAgdmFyIGphbl8xXzE5NTAgPSBuZXcgRGF0ZSgnMTk1MC0wMS0wMVQwMDowMDowMFonKTtcbiAgICB2YXIgamFuXzFfMjA1MCA9IG5ldyBEYXRlKCcyMDUwLTAxLTAxVDAwOjAwOjAwWicpO1xuICAgIHZhciBkYXRlID0gYXR0ci52YWx1ZTtcbiAgICBpZih0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIHRyeSB0byBwYXJzZSBkYXRlXG4gICAgICB2YXIgdGltZXN0YW1wID0gRGF0ZS5wYXJzZShkYXRlKTtcbiAgICAgIGlmKCFpc05hTih0aW1lc3RhbXApKSB7XG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh0aW1lc3RhbXApO1xuICAgICAgfSBlbHNlIGlmKGRhdGUubGVuZ3RoID09PSAxMykge1xuICAgICAgICAvLyBZWU1NRERISE1NU1NaICgxMyBjaGFycyBmb3IgVVRDVGltZSlcbiAgICAgICAgZGF0ZSA9IGFzbjEudXRjVGltZVRvRGF0ZShkYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFzc3VtZSBnZW5lcmFsaXplZCB0aW1lXG4gICAgICAgIGRhdGUgPSBhc24xLmdlbmVyYWxpemVkVGltZVRvRGF0ZShkYXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihkYXRlID49IGphbl8xXzE5NTAgJiYgZGF0ZSA8IGphbl8xXzIwNTApIHtcbiAgICAgIHZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuVVRDVElNRSwgZmFsc2UsXG4gICAgICAgIGFzbjEuZGF0ZVRvVXRjVGltZShkYXRlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuR0VORVJBTElaRURUSU1FLCBmYWxzZSxcbiAgICAgICAgYXNuMS5kYXRlVG9HZW5lcmFsaXplZFRpbWUoZGF0ZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IGV4cG9zZSBhcyBjb21tb24gQVBJIGNhbGxcbiAgLy8gY3JlYXRlIGEgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZSBzZXRcbiAgLy8gZWFjaCB2YWx1ZSBpbiB0aGUgc2V0IGlzIGFuIEF0dHJpYnV0ZVR5cGVBbmRWYWx1ZSBmaXJzdFxuICAvLyBjb250YWluaW5nIHRoZSB0eXBlIChhbiBPSUQpIGFuZCBzZWNvbmQgdGhlIHZhbHVlXG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gQXR0cmlidXRlVHlwZVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgIGFzbjEub2lkVG9EZXIoYXR0ci50eXBlKS5nZXRCeXRlcygpKSxcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFVCwgdHJ1ZSwgW1xuICAgICAgLy8gQXR0cmlidXRlVmFsdWVcbiAgICAgIHZhbHVlXG4gICAgXSlcbiAgXSk7XG59XG5cbi8qKlxuICogTWFwIG1lc3NhZ2VzIGVuY3J5cHRlZCBjb250ZW50IHRvIEFTTi4xIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIGVjIFRoZSBlbmNyeXB0ZWRDb250ZW50IG9iamVjdCBvZiB0aGUgbWVzc2FnZS5cbiAqXG4gKiBAcmV0dXJuIEFTTi4xIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlbmNyeXB0ZWRDb250ZW50IG9iamVjdCAoU0VRVUVOQ0UpLlxuICovXG5mdW5jdGlvbiBfZW5jcnlwdGVkQ29udGVudFRvQXNuMShlYykge1xuICByZXR1cm4gW1xuICAgIC8vIENvbnRlbnRUeXBlLCBhbHdheXMgRGF0YSBmb3IgdGhlIG1vbWVudFxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgIGFzbjEub2lkVG9EZXIoZm9yZ2UucGtpLm9pZHMuZGF0YSkuZ2V0Qnl0ZXMoKSksXG4gICAgLy8gQ29udGVudEVuY3J5cHRpb25BbGdvcml0aG1JZGVudGlmaWVyXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gQWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoZWMuYWxnb3JpdGhtKS5nZXRCeXRlcygpKSxcbiAgICAgIC8vIFBhcmFtZXRlcnMgKElWKVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsXG4gICAgICAgIGVjLnBhcmFtZXRlci5nZXRCeXRlcygpKVxuICAgIF0pLFxuICAgIC8vIFswXSBFbmNyeXB0ZWRDb250ZW50XG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgZWMuY29udGVudC5nZXRCeXRlcygpKVxuICAgIF0pXG4gIF07XG59XG5cbi8qKlxuICogUmVhZHMgdGhlIFwiY29tbW9uIHBhcnRcIiBvZiBhbiBQS0NTIzcgY29udGVudCBibG9jayAoaW4gQVNOLjEgZm9ybWF0KVxuICpcbiAqIFRoaXMgZnVuY3Rpb24gcmVhZHMgdGhlIFwiY29tbW9uIHBhcnRcIiBvZiB0aGUgUEtDUyM3IGNvbnRlbnQgYmxvY2tzXG4gKiBFbmNyeXB0ZWREYXRhIGFuZCBFbnZlbG9wZWREYXRhLCBpLmUuIHZlcnNpb24gbnVtYmVyIGFuZCBzeW1tZXRyaWNhbGx5XG4gKiBlbmNyeXB0ZWQgY29udGVudCBibG9jay5cbiAqXG4gKiBUaGUgcmVzdWx0IG9mIHRoZSBBU04uMSB2YWxpZGF0ZSBhbmQgY2FwdHVyZSBwcm9jZXNzIGlzIHJldHVybmVkXG4gKiB0byBhbGxvdyB0aGUgY2FsbGVyIHRvIGV4dHJhY3QgZnVydGhlciBkYXRhLCBlLmcuIHRoZSBsaXN0IG9mIHJlY2lwaWVudHNcbiAqIGluIGNhc2Ugb2YgYSBFbnZlbG9wZWREYXRhIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gbXNnIHRoZSBQS0NTIzcgb2JqZWN0IHRvIHJlYWQgdGhlIGRhdGEgdG8uXG4gKiBAcGFyYW0gb2JqIHRoZSBBU04uMSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29udGVudCBibG9jay5cbiAqIEBwYXJhbSB2YWxpZGF0b3IgdGhlIEFTTi4xIHN0cnVjdHVyZSB2YWxpZGF0b3Igb2JqZWN0IHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSB2YWx1ZSBtYXAgY2FwdHVyZWQgYnkgdmFsaWRhdG9yIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gX2Zyb21Bc24xKG1zZywgb2JqLCB2YWxpZGF0b3IpIHtcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIHZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgUEtDUyM3IG1lc3NhZ2UuICcgK1xuICAgICAgJ0FTTi4xIG9iamVjdCBpcyBub3QgYSBzdXBwb3J0ZWQgUEtDUyM3IG1lc3NhZ2UuJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3I7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBDaGVjayBjb250ZW50VHlwZSwgc28gZmFyIHdlIG9ubHkgc3VwcG9ydCAocmF3KSBEYXRhLlxuICB2YXIgY29udGVudFR5cGUgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpO1xuICBpZihjb250ZW50VHlwZSAhPT0gZm9yZ2UucGtpLm9pZHMuZGF0YSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUEtDUyM3IG1lc3NhZ2UuICcgK1xuICAgICAgJ09ubHkgd3JhcHBlZCBDb250ZW50VHlwZSBEYXRhIHN1cHBvcnRlZC4nKTtcbiAgfVxuXG4gIGlmKGNhcHR1cmUuZW5jcnlwdGVkQ29udGVudCkge1xuICAgIHZhciBjb250ZW50ID0gJyc7XG4gICAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KGNhcHR1cmUuZW5jcnlwdGVkQ29udGVudCkpIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjYXB0dXJlLmVuY3J5cHRlZENvbnRlbnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYoY2FwdHVyZS5lbmNyeXB0ZWRDb250ZW50W2ldLnR5cGUgIT09IGFzbjEuVHlwZS5PQ1RFVFNUUklORykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFBLQ1MjNyBtZXNzYWdlLCBleHBlY3RpbmcgZW5jcnlwdGVkICcgK1xuICAgICAgICAgICAgJ2NvbnRlbnQgY29uc3RydWN0ZWQgb2Ygb25seSBPQ1RFVCBTVFJJTkcgb2JqZWN0cy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50ICs9IGNhcHR1cmUuZW5jcnlwdGVkQ29udGVudFtpXS52YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IGNhcHR1cmUuZW5jcnlwdGVkQ29udGVudDtcbiAgICB9XG4gICAgbXNnLmVuY3J5cHRlZENvbnRlbnQgPSB7XG4gICAgICBhbGdvcml0aG06IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5lbmNBbGdvcml0aG0pLFxuICAgICAgcGFyYW1ldGVyOiBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLmVuY1BhcmFtZXRlci52YWx1ZSksXG4gICAgICBjb250ZW50OiBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjb250ZW50KVxuICAgIH07XG4gIH1cblxuICBpZihjYXB0dXJlLmNvbnRlbnQpIHtcbiAgICB2YXIgY29udGVudCA9ICcnO1xuICAgIGlmKGZvcmdlLnV0aWwuaXNBcnJheShjYXB0dXJlLmNvbnRlbnQpKSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2FwdHVyZS5jb250ZW50Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmKGNhcHR1cmUuY29udGVudFtpXS50eXBlICE9PSBhc24xLlR5cGUuT0NURVRTVFJJTkcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBQS0NTIzcgbWVzc2FnZSwgZXhwZWN0aW5nICcgK1xuICAgICAgICAgICAgJ2NvbnRlbnQgY29uc3RydWN0ZWQgb2Ygb25seSBPQ1RFVCBTVFJJTkcgb2JqZWN0cy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50ICs9IGNhcHR1cmUuY29udGVudFtpXS52YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IGNhcHR1cmUuY29udGVudDtcbiAgICB9XG4gICAgbXNnLmNvbnRlbnQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjb250ZW50KTtcbiAgfVxuXG4gIG1zZy52ZXJzaW9uID0gY2FwdHVyZS52ZXJzaW9uLmNoYXJDb2RlQXQoMCk7XG4gIG1zZy5yYXdDYXB0dXJlID0gY2FwdHVyZTtcblxuICByZXR1cm4gY2FwdHVyZTtcbn1cblxuLyoqXG4gKiBEZWNyeXB0IHRoZSBzeW1tZXRyaWNhbGx5IGVuY3J5cHRlZCBjb250ZW50IGJsb2NrIG9mIHRoZSBQS0NTIzcgbWVzc2FnZS5cbiAqXG4gKiBEZWNyeXB0aW9uIGlzIHNraXBwZWQgaW4gY2FzZSB0aGUgUEtDUyM3IG1lc3NhZ2Ugb2JqZWN0IGFscmVhZHkgaGFzIGFcbiAqIChkZWNyeXB0ZWQpIGNvbnRlbnQgYXR0cmlidXRlLiAgVGhlIGFsZ29yaXRobSwga2V5IGFuZCBjaXBoZXIgcGFyYW1ldGVyc1xuICogKHByb2JhYmx5IHRoZSBpdikgYXJlIHRha2VuIGZyb20gdGhlIGVuY3J5cHRlZENvbnRlbnQgYXR0cmlidXRlIG9mIHRoZVxuICogbWVzc2FnZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIFRoZSBQS0NTIzcgbWVzc2FnZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIF9kZWNyeXB0Q29udGVudChtc2cpIHtcbiAgaWYobXNnLmVuY3J5cHRlZENvbnRlbnQua2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N5bW1ldHJpYyBrZXkgbm90IGF2YWlsYWJsZS4nKTtcbiAgfVxuXG4gIGlmKG1zZy5jb250ZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgY2lwaDtcblxuICAgIHN3aXRjaChtc2cuZW5jcnlwdGVkQ29udGVudC5hbGdvcml0aG0pIHtcbiAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHNbJ2FlczEyOC1DQkMnXTpcbiAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHNbJ2FlczE5Mi1DQkMnXTpcbiAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHNbJ2FlczI1Ni1DQkMnXTpcbiAgICAgICAgY2lwaCA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyKG1zZy5lbmNyeXB0ZWRDb250ZW50LmtleSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGZvcmdlLnBraS5vaWRzWydkZXNDQkMnXTpcbiAgICAgIGNhc2UgZm9yZ2UucGtpLm9pZHNbJ2Rlcy1FREUzLUNCQyddOlxuICAgICAgICBjaXBoID0gZm9yZ2UuZGVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIobXNnLmVuY3J5cHRlZENvbnRlbnQua2V5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc3ltbWV0cmljIGNpcGhlciwgT0lEICcgK1xuICAgICAgICAgIG1zZy5lbmNyeXB0ZWRDb250ZW50LmFsZ29yaXRobSk7XG4gICAgfVxuICAgIGNpcGguc3RhcnQobXNnLmVuY3J5cHRlZENvbnRlbnQucGFyYW1ldGVyKTtcbiAgICBjaXBoLnVwZGF0ZShtc2cuZW5jcnlwdGVkQ29udGVudC5jb250ZW50KTtcblxuICAgIGlmKCFjaXBoLmZpbmlzaCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N5bW1ldHJpYyBkZWNyeXB0aW9uIGZhaWxlZC4nKTtcbiAgICB9XG5cbiAgICBtc2cuY29udGVudCA9IGNpcGgub3V0cHV0O1xuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxucmVxdWlyZSgnbm9kZS1mb3JnZS9saWIveDUwOScpXG5jb25zdCBmb3JnZSA9IHJlcXVpcmUoJ25vZGUtZm9yZ2UvbGliL2ZvcmdlJylcbmNvbnN0IHBraSA9IGZvcmdlLnBraVxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzXG5cbi8qKlxuICogR2V0cyBhIHNlbGYtc2lnbmVkIFguNTA5IGNlcnRpZmljYXRlIGZvciB0aGUga2V5LlxuICpcbiAqIFRoZSBvdXRwdXQgQnVmZmVyIGNvbnRhaW5zIHRoZSBQS0NTICM3IG1lc3NhZ2UgaW4gREVSLlxuICpcbiAqIFRPRE86IG1vdmUgdG8gbGlicDJwLWNyeXB0byBwYWNrYWdlXG4gKlxuICogQHBhcmFtIHtLZXlJbmZvfSBrZXkgLSBUaGUgaWQgYW5kIG5hbWUgb2YgdGhlIGtleVxuICogQHBhcmFtIHtSc2FQcml2YXRlS2V5fSBwcml2YXRlS2V5IC0gVGhlIG5ha2VkIGtleVxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQ2VydGlmaWNhdGUpfSBjYWxsYmFja1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZXhwb3J0cy5jZXJ0aWZpY2F0ZUZvcktleSA9IChrZXksIHByaXZhdGVLZXksIGNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IHB1YmxpY0tleSA9IHBraS5zZXRSc2FQdWJsaWNLZXkocHJpdmF0ZUtleS5uLCBwcml2YXRlS2V5LmUpXG4gIGNvbnN0IGNlcnQgPSBwa2kuY3JlYXRlQ2VydGlmaWNhdGUoKVxuICBjZXJ0LnB1YmxpY0tleSA9IHB1YmxpY0tleVxuICBjZXJ0LnNlcmlhbE51bWJlciA9ICcwMSdcbiAgY2VydC52YWxpZGl0eS5ub3RCZWZvcmUgPSBuZXcgRGF0ZSgpXG4gIGNlcnQudmFsaWRpdHkubm90QWZ0ZXIgPSBuZXcgRGF0ZSgpXG4gIGNlcnQudmFsaWRpdHkubm90QWZ0ZXIuc2V0RnVsbFllYXIoY2VydC52YWxpZGl0eS5ub3RCZWZvcmUuZ2V0RnVsbFllYXIoKSArIDEwKVxuICBjb25zdCBhdHRycyA9IFt7XG4gICAgbmFtZTogJ29yZ2FuaXphdGlvbk5hbWUnLFxuICAgIHZhbHVlOiAnaXBmcydcbiAgfSwge1xuICAgIHNob3J0TmFtZTogJ09VJyxcbiAgICB2YWx1ZTogJ2tleXN0b3JlJ1xuICB9LCB7XG4gICAgbmFtZTogJ2NvbW1vbk5hbWUnLFxuICAgIHZhbHVlOiBrZXkuaWRcbiAgfV1cbiAgY2VydC5zZXRTdWJqZWN0KGF0dHJzKVxuICBjZXJ0LnNldElzc3VlcihhdHRycylcbiAgY2VydC5zZXRFeHRlbnNpb25zKFt7XG4gICAgbmFtZTogJ2Jhc2ljQ29uc3RyYWludHMnLFxuICAgIGNBOiB0cnVlXG4gIH0sIHtcbiAgICBuYW1lOiAna2V5VXNhZ2UnLFxuICAgIGtleUNlcnRTaWduOiB0cnVlLFxuICAgIGRpZ2l0YWxTaWduYXR1cmU6IHRydWUsXG4gICAgbm9uUmVwdWRpYXRpb246IHRydWUsXG4gICAga2V5RW5jaXBoZXJtZW50OiB0cnVlLFxuICAgIGRhdGFFbmNpcGhlcm1lbnQ6IHRydWVcbiAgfSwge1xuICAgIG5hbWU6ICdleHRLZXlVc2FnZScsXG4gICAgc2VydmVyQXV0aDogdHJ1ZSxcbiAgICBjbGllbnRBdXRoOiB0cnVlLFxuICAgIGNvZGVTaWduaW5nOiB0cnVlLFxuICAgIGVtYWlsUHJvdGVjdGlvbjogdHJ1ZSxcbiAgICB0aW1lU3RhbXBpbmc6IHRydWVcbiAgfSwge1xuICAgIG5hbWU6ICduc0NlcnRUeXBlJyxcbiAgICBjbGllbnQ6IHRydWUsXG4gICAgc2VydmVyOiB0cnVlLFxuICAgIGVtYWlsOiB0cnVlLFxuICAgIG9ianNpZ246IHRydWUsXG4gICAgc3NsQ0E6IHRydWUsXG4gICAgZW1haWxDQTogdHJ1ZSxcbiAgICBvYmpDQTogdHJ1ZVxuICB9XSlcbiAgLy8gc2VsZi1zaWduIGNlcnRpZmljYXRlXG4gIGNlcnQuc2lnbihwcml2YXRlS2V5KVxuXG4gIHJldHVybiBjYWxsYmFjayhudWxsLCBjZXJ0KVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8vIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9pcGZzL2dvLWlwZnMvYmxvYi9tYXN0ZXIvZXhjaGFuZ2UvYml0c3dhcC9tZXNzYWdlL3BiL21lc3NhZ2UucHJvdG9cblxubW9kdWxlLmV4cG9ydHMgPSBgXG4gIG1lc3NhZ2UgTWVzc2FnZSB7XG4gICAgbWVzc2FnZSBXYW50bGlzdCB7XG4gICAgICBtZXNzYWdlIEVudHJ5IHtcbiAgICAgICAgLy8gY2hhbmdlZCBmcm9tIHN0cmluZyB0byBieXRlcywgaXQgbWFrZXMgYSBkaWZmZXJlbmNlIGluIEphdmFTY3JpcHRcbiAgICAgICAgb3B0aW9uYWwgYnl0ZXMgYmxvY2sgPSAxOyAgICAgIC8vIHRoZSBibG9jayBjaWQgKGNpZFYwIGluIGJpdHN3YXAgMS4wLjAsIGNpZFYxIGluIGJpdHN3YXAgMS4xLjApXG4gICAgICAgIG9wdGlvbmFsIGludDMyIHByaW9yaXR5ID0gMjsgICAgLy8gdGhlIHByaW9yaXR5IChub3JtYWxpemVkKS4gZGVmYXVsdCB0byAxXG4gICAgICAgIG9wdGlvbmFsIGJvb2wgY2FuY2VsID0gMzsgICAgICAgLy8gd2hldGhlciB0aGlzIHJldm9rZXMgYW4gZW50cnlcbiAgICAgIH1cblxuICAgICAgcmVwZWF0ZWQgRW50cnkgZW50cmllcyA9IDE7ICAgICAgIC8vIGEgbGlzdCBvZiB3YW50bGlzdCBlbnRyaWVzXG4gICAgICBvcHRpb25hbCBib29sIGZ1bGwgPSAyOyAgICAgICAgICAgLy8gd2hldGhlciB0aGlzIGlzIHRoZSBmdWxsIHdhbnRsaXN0LiBkZWZhdWx0IHRvIGZhbHNlXG4gICAgfVxuXG4gICAgbWVzc2FnZSBCbG9jayB7XG4gICAgICBvcHRpb25hbCBieXRlcyBwcmVmaXggPSAxOyAgICAgICAgLy8gQ0lEIHByZWZpeCAoY2lkIHZlcnNpb24sIG11bHRpY29kZWMgYW5kIG11bHRpaGFzaCBwcmVmaXggKHR5cGUgKyBsZW5ndGgpXG4gICAgICBvcHRpb25hbCBieXRlcyBkYXRhID0gMjtcbiAgICB9XG5cbiAgICBvcHRpb25hbCBXYW50bGlzdCB3YW50bGlzdCA9IDE7XG4gICAgcmVwZWF0ZWQgYnl0ZXMgYmxvY2tzID0gMjsgICAgICAgICAgLy8gdXNlZCB0byBzZW5kIEJsb2NrcyBpbiBiaXRzd2FwIDEuMC4wXG4gICAgcmVwZWF0ZWQgQmxvY2sgcGF5bG9hZCA9IDM7ICAgICAgICAgLy8gdXNlZCB0byBzZW5kIEJsb2NrcyBpbiBiaXRzd2FwIDEuMS4wXG4gIH1cbmBcbiJdLCJwcmVFeGlzdGluZ0NvbW1lbnQiOiIvLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAifQ==
