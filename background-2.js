LavaPack.loadBundle([
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/constants.js","bs58":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bs58/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/**
 * Multihash implementation in JavaScript.
 *
 * @module multihash
 */
'use strict'

const bs58 = require('bs58')

const cs = require('./constants')

exports.names = cs.names
exports.codes = cs.codes
exports.defaultLengths = cs.defaultLengths

const varint = require('varint')

/**
 * Convert the given multihash to a hex encoded string.
 *
 * @param {Buffer} hash
 * @returns {string}
 */
exports.toHexString = function toHexString (hash) {
  if (!Buffer.isBuffer(hash)) {
    throw new Error('must be passed a buffer')
  }

  return hash.toString('hex')
}

/**
 * Convert the given hex encoded string to a multihash.
 *
 * @param {string} hash
 * @returns {Buffer}
 */
exports.fromHexString = function fromHexString (hash) {
  return Buffer.from(hash, 'hex')
}

/**
 * Convert the given multihash to a base58 encoded string.
 *
 * @param {Buffer} hash
 * @returns {string}
 */
exports.toB58String = function toB58String (hash) {
  if (!Buffer.isBuffer(hash)) {
    throw new Error('must be passed a buffer')
  }

  return bs58.encode(hash)
}

/**
 * Convert the given base58 encoded string to a multihash.
 *
 * @param {string|Buffer} hash
 * @returns {Buffer}
 */
exports.fromB58String = function fromB58String (hash) {
  let encoded = hash
  if (Buffer.isBuffer(hash)) {
    encoded = hash.toString()
  }

  return Buffer.from(bs58.decode(encoded))
}

/**
 * Decode a hash from the given multihash.
 *
 * @param {Buffer} buf
 * @returns {{code: number, name: string, length: number, digest: Buffer}} result
 */
exports.decode = function decode (buf) {
  if (!(Buffer.isBuffer(buf))) {
    throw new Error('multihash must be a Buffer')
  }

  if (buf.length < 3) {
    throw new Error('multihash too short. must be > 3 bytes.')
  }

  const code = varint.decode(buf)
  if (!exports.isValidCode(code)) {
    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)
  }
  buf = buf.slice(varint.decode.bytes)

  const len = varint.decode(buf)
  if (len < 1) {
    throw new Error(`multihash invalid length: 0x${len.toString(16)}`)
  }
  buf = buf.slice(varint.decode.bytes)

  if (buf.length !== len) {
    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)
  }

  return {
    code: code,
    name: cs.codes[code],
    length: len,
    digest: buf
  }
}

/**
 *  Encode a hash digest along with the specified function code.
 *
 * > **Note:** the length is derived from the length of the digest itself.
 *
 * @param {Buffer} digest
 * @param {string|number} code
 * @param {number} [length]
 * @returns {Buffer}
 */
exports.encode = function encode (digest, code, length) {
  if (!digest || code === undefined) {
    throw new Error('multihash encode requires at least two args: digest, code')
  }

  // ensure it's a hashfunction code.
  const hashfn = exports.coerceCode(code)

  if (!(Buffer.isBuffer(digest))) {
    throw new Error('digest should be a Buffer')
  }

  if (length == null) {
    length = digest.length
  }

  if (length && digest.length !== length) {
    throw new Error('digest length should be equal to specified length.')
  }

  return Buffer.concat([
    Buffer.from(varint.encode(hashfn)),
    Buffer.from(varint.encode(length)),
    digest
  ])
}

/**
 * Converts a hash function name into the matching code.
 * If passed a number it will return the number if it's a valid code.
 * @param {string|number} name
 * @returns {number}
 */
exports.coerceCode = function coerceCode (name) {
  let code = name

  if (typeof name === 'string') {
    if (cs.names[name] === undefined) {
      throw new Error(`Unrecognized hash function named: ${name}`)
    }
    code = cs.names[name]
  }

  if (typeof code !== 'number') {
    throw new Error(`Hash function code should be a number. Got: ${code}`)
  }

  if (cs.codes[code] === undefined && !exports.isAppCode(code)) {
    throw new Error(`Unrecognized function code: ${code}`)
  }

  return code
}

/**
 * Checks wether a code is part of the app range
 *
 * @param {number} code
 * @returns {boolean}
 */
exports.isAppCode = function appCode (code) {
  return code > 0 && code < 0x10
}

/**
 * Checks whether a multihash code is valid.
 *
 * @param {number} code
 * @returns {boolean}
 */
exports.isValidCode = function validCode (code) {
  if (exports.isAppCode(code)) {
    return true
  }

  if (cs.codes[code]) {
    return true
  }

  return false
}

/**
 * Check if the given buffer is a valid multihash. Throws an error if it is not valid.
 *
 * @param {Buffer} multihash
 * @returns {undefined}
 * @throws {Error}
 */
function validate (multihash) {
  exports.decode(multihash) // throws if bad.
}
exports.validate = validate

/**
 * Returns a prefix from a valid multihash. Throws an error if it is not valid.
 *
 * @param {Buffer} multihash
 * @returns {undefined}
 * @throws {Error}
 */
exports.prefix = function prefix (multihash) {
  validate(multihash)

  return multihash.slice(0, 2)
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashes",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-pubsub/src/ipfs-pubsub.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ipfs-pubsub-peer-monitor":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-peer-monitor/src/ipfs-pubsub-peer-monitor.js","logplease":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/logplease/src/index.js","p-series":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-series/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-pubsub/src/ipfs-pubsub.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const pSeries = require('p-series')
const PeerMonitor = require('ipfs-pubsub-peer-monitor')

const Logger = require('logplease')
const logger = Logger.create("pubsub", { color: Logger.Colors.Yellow })
Logger.setLogLevel('ERROR')

const maxTopicsOpen = 256
let topicsOpenCount = 0

class IPFSPubsub {
  constructor(ipfs, id) {
    this._ipfs = ipfs
    this._id = id
    this._subscriptions = {}

    if (this._ipfs.pubsub === null)
      logger.error("The provided version of ipfs doesn't have pubsub support. Messages will not be exchanged.")

    this._handleMessage = this._handleMessage.bind(this)

    // Bump up the number of listeners we can have open,
    // ie. number of databases replicating
    if (this._ipfs.setMaxListeners)
      this._ipfs.setMaxListeners(maxTopicsOpen)
  }

  async subscribe(topic, onMessageCallback, onNewPeerCallback) {
    if(!this._subscriptions[topic] && this._ipfs.pubsub) {
      await this._ipfs.pubsub.subscribe(topic, this._handleMessage)

      const topicMonitor = new PeerMonitor(this._ipfs.pubsub, topic)

      topicMonitor.on('join', (peer) => {
        logger.debug(`Peer joined ${topic}:`)
        logger.debug(peer)
        if (this._subscriptions[topic]) {
          onNewPeerCallback(topic, peer)
        } else {
          logger.warn('Peer joined a room we don\'t have a subscription for')
          logger.warn(topic, peer)
        }
      })

      topicMonitor.on('leave', (peer) => logger.debug(`Peer ${peer} left ${topic}`))
      topicMonitor.on('error', (e) => logger.error(e))

      this._subscriptions[topic] = {
        topicMonitor: topicMonitor,
        onMessage: onMessageCallback,
        onNewPeer: onNewPeerCallback
      }

      topicsOpenCount ++
      logger.debug("Topics open:", topicsOpenCount)
    }
  }

  async unsubscribe(hash) {
    if(this._subscriptions[hash]) {
      await this._ipfs.pubsub.unsubscribe(hash, this._handleMessage)
      this._subscriptions[hash].topicMonitor.stop()
      delete this._subscriptions[hash]
      logger.debug(`Unsubscribed from '${hash}'`)
      topicsOpenCount --
      logger.debug("Topics open:", topicsOpenCount)
    }
  }

  publish(topic, message) {
    if(this._subscriptions[topic] && this._ipfs.pubsub) {
      this._ipfs.pubsub.publish(topic, Buffer.from(JSON.stringify(message)))
    }
  }

  async disconnect() {
    const topics = Object.keys(this._subscriptions)
    await pSeries(topics.map((t) => this.unsubscribe.bind(this, t)))
    this._subscriptions = {}
  }

  async _handleMessage(message) {
    // Don't process our own messages
    if (message.from === this._id)
      return

    // Get the message content and a subscription
    let content, subscription, topicId
    try {
      // Get the topic
      topicId = message.topicIDs[0]
      content = JSON.parse(message.data)
      subscription = this._subscriptions[topicId]
    } catch (e) {
      logger.error(e)
      logger.error('Couldn\'t parse pubsub message:', message)
    }

    if(subscription && subscription.onMessage && content) {
      await subscription.onMessage(topicId, content)
    }
  }
}

module.exports = IPFSPubsub

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"orbit-db-pubsub",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-pubsub/src/ipfs-pubsub.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/log.js", {"./default-access-controller":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/default-access-controller.js","./entry":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/entry.js","./entry-index":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/entry-index.js","./g-set":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/g-set.js","./lamport-clock":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/lamport-clock.js","./log-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/log-errors.js","./log-io":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/log-io.js","./log-sorting":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/log-sorting.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/utils/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","p-each-series":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-each-series/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/log.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const pEachSeries = require('p-each-series')
const GSet = require('./g-set')
const Entry = require('./entry')
const LogIO = require('./log-io')
const LogError = require('./log-errors')
const Clock = require('./lamport-clock')
const Sorting = require('./log-sorting')
const { LastWriteWins, NoZeroes } = Sorting
const AccessController = require('./default-access-controller')
const { isDefined, findUniques } = require('./utils')
const EntryIndex = require('./entry-index')
const randomId = () => new Date().getTime().toString()
const getHash = e => e.hash
const flatMap = (res, acc) => res.concat(acc)
const getNextPointers = entry => entry.next
const maxClockTimeReducer = (res, acc) => Math.max(res, acc.clock.time)
const uniqueEntriesReducer = (res, acc) => {
  res[acc.hash] = acc
  return res
}

/**
 * Log.
 *
 * @description
 * Log implements a G-Set CRDT and adds ordering.
 *
 * From:
 * "A comprehensive study of Convergent and Commutative Replicated Data Types"
 * https://hal.inria.fr/inria-00555588
 */
class Log extends GSet {
  /**
   * Create a new Log instance
   * @param {IPFS} ipfs An IPFS instance
   * @param {Object} identity Identity (https://github.com/orbitdb/orbit-db-identity-provider/blob/master/src/identity.js)
   * @param {Object} options
   * @param {string} options.logId ID of the log
   * @param {Object} options.access AccessController (./default-access-controller)
   * @param {Array<Entry>} options.entries An Array of Entries from which to create the log
   * @param {Array<Entry>} options.heads Set the heads of the log
   * @param {Clock} options.clock Set the clock of the log
   * @param {Function} options.sortFn The sort function - by default LastWriteWins
   * @return {Log} The log instance
   */
  constructor (ipfs, identity, { logId, access, entries, heads, clock, sortFn } = {}) {
    if (!isDefined(ipfs)) {
      throw LogError.IPFSNotDefinedError()
    }

    if (!isDefined(identity)) {
      throw new Error('Identity is required')
    }

    if (!isDefined(access)) {
      access = new AccessController()
    }

    if (isDefined(entries) && !Array.isArray(entries)) {
      throw new Error(`'entries' argument must be an array of Entry instances`)
    }

    if (isDefined(heads) && !Array.isArray(heads)) {
      throw new Error(`'heads' argument must be an array`)
    }

    if (!isDefined(sortFn)) {
      sortFn = LastWriteWins
    }

    super()

    this._sortFn = NoZeroes(sortFn)

    this._storage = ipfs
    this._id = logId || randomId()

    // Access Controller
    this._access = access
    // Identity
    this._identity = identity

    // Add entries to the internal cache
    entries = entries || []
    this._entryIndex = new EntryIndex(entries.reduce(uniqueEntriesReducer, {}))

    // Set heads if not passed as an argument
    heads = heads || Log.findHeads(entries)
    this._headsIndex = heads.reduce(uniqueEntriesReducer, {})

    // Index of all next pointers in this log
    this._nextsIndex = {}
    const addToNextsIndex = e => e.next.forEach(a => (this._nextsIndex[a] = e.hash))
    entries.forEach(addToNextsIndex)

    // Set the length, we calculate the length manually internally
    this._length = entries.length

    // Set the clock
    const maxTime = Math.max(clock ? clock.time : 0, this.heads.reduce(maxClockTimeReducer, 0))
    // Take the given key as the clock id is it's a Key instance,
    // otherwise if key was given, take whatever it is,
    // and if it was null, take the given id as the clock id
    this._clock = new Clock(this._identity.publicKey, maxTime)
  }

  /**
   * Returns the ID of the log.
   * @returns {string}
   */
  get id () {
    return this._id
  }

  /**
   * Returns the clock of the log.
   * @returns {string}
   */
  get clock () {
    return this._clock
  }

  /**
   * Returns the length of the log.
   * @return {number} Length
   */
  get length () {
    return this._length
  }

  /**
   * Returns the values in the log.
   * @returns {Array<Entry>}
   */
  get values () {
    return Object.values(this.traverse(this.heads)).reverse()
  }

  /**
   * Returns an array of heads as hashes.
   * @returns {Array<string>}
   */
  get heads () {
    return Object.values(this._headsIndex).sort(this._sortFn).reverse()
  }

  /**
   * Returns an array of Entry objects that reference entries which
   * are not in the log currently.
   * @returns {Array<Entry>}
   */
  get tails () {
    return Log.findTails(this.values)
  }

  /**
   * Returns an array of hashes that are referenced by entries which
   * are not in the log currently.
   * @returns {Array<string>} Array of hashes
   */
  get tailHashes () {
    return Log.findTailHashes(this.values)
  }

  /**
   * Set the identity for the log
   * @param {Identity} [identity] The identity to be set
   */
  setIdentity (identity) {
    this._identity = identity
    // Find the latest clock from the heads
    const time = Math.max(this.clock.time, this.heads.reduce(maxClockTimeReducer, 0))
    this._clock = new Clock(this._identity.publicKey, time)
  }

  /**
   * Find an entry.
   * @param {string} [hash] The hashes of the entry
   * @returns {Entry|undefined}
   */
  get (hash) {
    return this._entryIndex.get(hash)
  }

  /**
   * Checks if a entry is part of the log
   * @param {string} hash The hash of the entry
   * @returns {boolean}
   */
  has (entry) {
    return this._entryIndex.get(entry.hash || entry) !== undefined
  }

  traverse (rootEntries, amount = -1, endHash) {
    // Sort the given given root entries and use as the starting stack
    var stack = rootEntries.sort(this._sortFn).reverse()
    // Cache for checking if we've processed an entry already
    let traversed = {}
    // End result
    let result = {}
    // We keep a counter to check if we have traversed requested amount of entries
    let count = 0

    // Named function for getting an entry from the log
    const getEntry = e => this.get(e)

    // Add an entry to the stack and traversed nodes index
    const addToStack = entry => {
      // If we've already processed the entry, don't add it to the stack
      if (!entry || traversed[entry.hash]) {
        return
      }

      // Add the entry in front of the stack and sort
      stack = [entry, ...stack]
        .sort(this._sortFn)
        .reverse()

      // Add to the cache of processed entries
      traversed[entry.hash] = true
    }

    // Start traversal
    // Process stack until it's empty (traversed the full log)
    // or when we have the requested amount of entries
    // If requested entry amount is -1, traverse all
    while (stack.length > 0 && (amount === -1 || count < amount)) { // eslint-disable-line no-unmodified-loop-condition
      // Get the next element from the stack
      const entry = stack.shift()

      // Add to the result
      count++
      result[entry.hash] = entry
      // Add entry's next references to the stack
      entry.next.map(getEntry)
        .filter(isDefined)
        .forEach(addToStack)

      // If it is the specified end hash, break out of the while loop
      if (entry.hash === endHash) break
    }

    return result
  }

  /**
   * Append an entry to the log.
   * @param {Entry} entry Entry to add
   * @return {Log} New Log containing the appended value
   */
  async append (data, pointerCount = 1) {
    // Update the clock (find the latest clock)
    const newTime = Math.max(this.clock.time, this.heads.reduce(maxClockTimeReducer, 0)) + 1
    this._clock = new Clock(this.clock.id, newTime)

    // Get the required amount of hashes to next entries (as per current state of the log)
    const references = this.traverse(this.heads, Math.max(pointerCount, this.heads.length))

    const sortedHeadIndex = this.heads.reverse().reduce(uniqueEntriesReducer, {})
    const nexts = Object.keys(Object.assign({}, sortedHeadIndex, references))
    // @TODO: Split Entry.create into creating object, checking permission, signing and then posting to IPFS
    // Create the entry and add it to the internal cache
    const entry = await Entry.create(
      this._storage,
      this._identity,
      this.id,
      data,
      nexts,
      this.clock
    )

    const canAppend = await this._access.canAppend(entry, this._identity.provider)
    if (!canAppend) {
      throw new Error(`Could not append entry, key "${this._identity.id}" is not allowed to write to the log`)
    }

    this._entryIndex.set(entry.hash, entry)
    nexts.forEach(e => (this._nextsIndex[e] = entry.hash))
    this._headsIndex = {}
    this._headsIndex[entry.hash] = entry
    // Update the length
    this._length++
    return entry
  }

  /*
   * Creates a javscript iterator over log entries
   *
   * @param {Object} options
   * @param {string|Array} options.gt Beginning hash of the iterator, non-inclusive
   * @param {string|Array} options.gte Beginning hash of the iterator, inclusive
   * @param {string|Array} options.lt Ending hash of the iterator, non-inclusive
   * @param {string|Array} options.lte Ending hash of the iterator, inclusive
   * @param {amount} options.amount Number of entried to return to / from the gte / lte hash
   * @returns {Symbol.Iterator} Iterator object containing log entries
   *
   * @examples
   *
   * (async () => {
   *   log1 = new Log(ipfs, testIdentity, { logId: 'X' })
   *
   *   for (let i = 0; i <= 100; i++) {
   *     await log1.append('entry' + i)
   *   }
   *
   *   let it = log1.iterator({
   *     lte: 'zdpuApFd5XAPkCTmSx7qWQmQzvtdJPtx2K5p9to6ytCS79bfk',
   *     amount: 10
   *   })
   *
   *   [...it].length // 10
   * })()
   *
   *
   */
  iterator ({ gt = undefined, gte = undefined, lt = undefined, lte = undefined, amount = -1 } =
  {}) {
    if (amount === 0) return (function * () {})()
    if (typeof lte === 'string') lte = [this.get(lte)]
    if (typeof lt === 'string') lt = [this.get(this.get(lt).next)]

    if (lte && !Array.isArray(lte)) throw LogError.LtOrLteMustBeStringOrArray()
    if (lt && !Array.isArray(lt)) throw LogError.LtOrLteMustBeStringOrArray()

    let start = lte || (lt || this.heads)
    let endHash = gte ? this.get(gte).hash : gt ? this.get(gt).hash : null
    let count = endHash ? -1 : amount || -1

    let entries = this.traverse(start, count, endHash)
    let entryValues = Object.values(entries)

    // Strip off last entry if gt is non-inclusive
    if (gt) entryValues.pop()

    // Deal with the amount argument working backwards from gt/gte
    if ((gt || gte) && amount > -1) {
      entryValues = entryValues.slice(entryValues.length - amount, entryValues.length)
    }

    return (function * () {
      for (let i in entryValues) {
        yield entryValues[i]
      }
    })()
  }

  /**
   * Join two logs.
   *
   * Joins another log into this one.
   *
   * @param {Log} log Log to join with this Log
   * @param {number} [size=-1] Max size of the joined log
   * @returns {Promise<Log>} This Log instance
   * @example
   * await log1.join(log2)
   */
  async join (log, size = -1) {
    if (!isDefined(log)) throw LogError.LogNotDefinedError()
    if (!Log.isLog(log)) throw LogError.NotALogError()
    if (this.id !== log.id) return

    // Get the difference of the logs
    const newItems = Log.difference(log, this)

    const identityProvider = this._identity.provider
    // Verify if entries are allowed to be added to the log and throws if
    // there's an invalid entry
    const permitted = async (entry) => {
      const canAppend = await this._access.canAppend(entry, identityProvider)
      if (!canAppend) {
        throw new Error(`Could not append entry, key "${entry.identity.id}" is not allowed to write to the log`)
      }
    }

    // Verify signature for each entry and throws if there's an invalid signature
    const verify = async (entry) => {
      const isValid = await Entry.verify(identityProvider, entry)
      const publicKey = entry.identity ? entry.identity.publicKey : entry.key
      if (!isValid) throw new Error(`Could not validate signature "${entry.sig}" for entry "${entry.hash}" and key "${publicKey}"`)
    }

    const entriesToJoin = Object.values(newItems)
    await pEachSeries(entriesToJoin, async e => {
      await permitted(e)
      await verify(e)
    })

    // Update the internal next pointers index
    const addToNextsIndex = e => {
      const entry = this.get(e.hash)
      if (!entry) this._length++ /* istanbul ignore else */
      e.next.forEach(a => (this._nextsIndex[a] = e.hash))
    }
    Object.values(newItems).forEach(addToNextsIndex)

    // Update the internal entry index
    this._entryIndex.add(newItems)

    // Merge the heads
    const notReferencedByNewItems = e => !nextsFromNewItems.find(a => a === e.hash)
    const notInCurrentNexts = e => !this._nextsIndex[e.hash]
    const nextsFromNewItems = Object.values(newItems).map(getNextPointers).reduce(flatMap, [])
    const mergedHeads = Log.findHeads(Object.values(Object.assign({}, this._headsIndex, log._headsIndex)))
      .filter(notReferencedByNewItems)
      .filter(notInCurrentNexts)
      .reduce(uniqueEntriesReducer, {})

    this._headsIndex = mergedHeads

    // Slice to the requested size
    if (size > -1) {
      let tmp = this.values
      tmp = tmp.slice(-size)
      this._entryIndex = null
      this._entryIndex = new EntryIndex(tmp.reduce(uniqueEntriesReducer, {}))
      this._headsIndex = Log.findHeads(tmp).reduce(uniqueEntriesReducer, {})
      this._length = this._entryIndex.length
    }

    // Find the latest clock from the heads
    const maxClock = Object.values(this._headsIndex).reduce(maxClockTimeReducer, 0)
    this._clock = new Clock(this.clock.id, Math.max(this.clock.time, maxClock))
    return this
  }

  /**
   * Get the log in JSON format.
   * @returns {Object} An object with the id and heads properties
   */
  toJSON () {
    return {
      id: this.id,
      heads: this.heads
        .sort(this._sortFn) // default sorting
        .reverse() // we want the latest as the first element
        .map(getHash) // return only the head hashes
    }
  }

  /**
   * Get the log in JSON format as a snapshot.
   * @returns {Object} An object with the id, heads and value properties
   */
  toSnapshot () {
    return {
      id: this.id,
      heads: this.heads,
      values: this.values
    }
  }

  /**
   * Get the log as a Buffer.
   * @returns {Buffer}
   */
  toBuffer () {
    return Buffer.from(JSON.stringify(this.toJSON()))
  }

  /**
   * Returns the log entries as a formatted string.
   * @returns {string}
   * @example
   * two
   * └─one
   *   └─three
   */
  toString (payloadMapper) {
    return this.values
      .slice()
      .reverse()
      .map((e, idx) => {
        const parents = Entry.findChildren(e, this.values)
        const len = parents.length
        let padding = new Array(Math.max(len - 1, 0))
        padding = len > 1 ? padding.fill('  ') : padding
        padding = len > 0 ? padding.concat(['└─']) : padding
        /* istanbul ignore next */
        return padding.join('') + (payloadMapper ? payloadMapper(e.payload) : e.payload)
      })
      .join('\n')
  }

  /**
   * Check whether an object is a Log instance.
   * @param {Object} log An object to check
   * @returns {boolean}
   */
  static isLog (log) {
    return log.id !== undefined &&
      log.heads !== undefined &&
      log._entryIndex !== undefined
  }

  /**
   * Get the log's multihash.
   * @returns {Promise<string>} Multihash of the Log as Base58 encoded stringx
   */
  toMultihash ({ format } = {}) {
    return LogIO.toMultihash(this._storage, this, { format })
  }

  /**
   * Create a log from a hashes.
   * @param {IPFS} ipfs An IPFS instance
   * @param {Identity} identity The identity instance
   * @param {string} hash The log hash
   * @param {Object} options
   * @param {AccessController} options.access The access controller instance
   * @param {number} options.length How many items to include in the log
   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)
   * @param {function(hash, entry, parent, depth)} options.onProgressCallback
   * @param {Function} options.sortFn The sort function - by default LastWriteWins
   * @returns {Promise<Log>}
   */
  static async fromMultihash (ipfs, identity, hash,
    { access, length = -1, exclude, onProgressCallback, sortFn, timeout, format } = {}) {
    // TODO: need to verify the entries with 'key'
    const data = await LogIO.fromMultihash(ipfs, hash, { length, exclude, onProgressCallback, timeout, format })
    return new Log(ipfs, identity, {
      logId: data.id,
      access: access,
      entries: data.values,
      heads: data.heads,
      clock: new Clock(data.clock.id, data.clock.time),
      sortFn: sortFn
    })
  }

  /**
   * Create a log from a single entry's hash.
   * @param {IPFS} ipfs An IPFS instance
   * @param {Identity} identity The identity instance
   * @param {string} hash The entry's hash
   * @param {Object} options
   * @param {string} options.logId The ID of the log
   * @param {AccessController} options.access The access controller instance
   * @param {number} options.length How many entries to include in the log
   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)
   * @param {function(hash, entry, parent, depth)} options.onProgressCallback
   * @param {Function} options.sortFn The sort function - by default LastWriteWins
   * @param {number} options.timeout Timeout for fetching a log entry from IPFS
   * @return {Promise<Log>} New Log
   */
  static async fromEntryHash (ipfs, identity, hash,
    { logId, access, length = -1, exclude, onProgressCallback, sortFn, timeout }) {
    // TODO: need to verify the entries with 'key'
    const data = await LogIO.fromEntryHash(ipfs, hash, { length, exclude, onProgressCallback, timeout })
    return new Log(ipfs, identity, { logId, access, entries: data.values, sortFn })
  }

  /**
   * Create a log from a Log Snapshot JSON.
   * @param {IPFS} ipfs An IPFS instance
   * @param {Identity} identity The identity instance
   * @param {Object} json Log snapshot as JSON object
   * @param {Object} options
   * @param {AccessController} options.access The access controller instance
   * @param {number} options.length How many entries to include in the log
   * @param {number} options.timeout Maximum time to wait for each fetch operation, in ms
   * @param {function(hash, entry, parent, depth)} [options.onProgressCallback]
   * @param {Function} options.sortFn The sort function - by default LastWriteWins
   * @return {Promise<Log>} New Log
   */
  static async fromJSON (ipfs, identity, json,
    { access, length = -1, timeout, onProgressCallback, sortFn } = {}) {
    // TODO: need to verify the entries with 'key'
    const data = await LogIO.fromJSON(ipfs, json, { length, timeout, onProgressCallback })
    return new Log(ipfs, identity, { logId: data.id, access, entries: data.values, sortFn })
  }

  /**
   * Create a new log from an Entry instance.
   * @param {IPFS} ipfs An IPFS instance
   * @param {Identity} identity The identity instance
   * @param {Entry|Array<Entry>} sourceEntries An Entry or an array of entries to fetch a log from
   * @param {Object} options
   * @param {AccessController} options.access The access controller instance
   * @param {number} options.length How many entries to include. Default: infinite.
   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)
   * @param {function(hash, entry, parent, depth)} [options.onProgressCallback]
   * @param {Function} options.sortFn The sort function - by default LastWriteWins
   * @return {Promise<Log>} New Log
   */
  static async fromEntry (ipfs, identity, sourceEntries,
    { access, length = -1, exclude, onProgressCallback, timeout, sortFn } = {}) {
    // TODO: need to verify the entries with 'key'
    const data = await LogIO.fromEntry(ipfs, sourceEntries,
      { length, exclude, onProgressCallback, timeout })
    return new Log(ipfs, identity, { logId: data.id, access, entries: data.values, sortFn })
  }

  /**
   * Find heads from a collection of entries.
   *
   * Finds entries that are the heads of this collection,
   * ie. entries that are not referenced by other entries.
   *
   * @param {Array<Entry>} entries Entries to search heads from
   * @returns {Array<Entry>}
   */
  static findHeads (entries) {
    var indexReducer = (res, entry, idx, arr) => {
      var addToResult = e => (res[e] = entry.hash)
      entry.next.forEach(addToResult)
      return res
    }

    var items = entries.reduce(indexReducer, {})

    var exists = e => items[e.hash] === undefined
    var compareIds = (a, b) => a.clock.id > b.clock.id

    return entries.filter(exists).sort(compareIds)
  }

  // Find entries that point to another entry that is not in the
  // input array
  static findTails (entries) {
    // Reverse index { next -> entry }
    var reverseIndex = {}
    // Null index containing entries that have no parents (nexts)
    var nullIndex = []
    // Hashes for all entries for quick lookups
    var hashes = {}
    // Hashes of all next entries
    var nexts = []

    var addToIndex = (e) => {
      if (e.next.length === 0) {
        nullIndex.push(e)
      }
      var addToReverseIndex = (a) => {
        /* istanbul ignore else */
        if (!reverseIndex[a]) reverseIndex[a] = []
        reverseIndex[a].push(e)
      }

      // Add all entries and their parents to the reverse index
      e.next.forEach(addToReverseIndex)
      // Get all next references
      nexts = nexts.concat(e.next)
      // Get the hashes of input entries
      hashes[e.hash] = true
    }

    // Create our indices
    entries.forEach(addToIndex)

    var addUniques = (res, entries, idx, arr) => res.concat(findUniques(entries, 'hash'))
    var exists = e => hashes[e] === undefined
    var findFromReverseIndex = e => reverseIndex[e]

    // Drop hashes that are not in the input entries
    const tails = nexts // For every hash in nexts:
      .filter(exists) // Remove undefineds and nulls
      .map(findFromReverseIndex) // Get the Entry from the reverse index
      .reduce(addUniques, []) // Flatten the result and take only uniques
      .concat(nullIndex) // Combine with tails the have no next refs (ie. first-in-their-chain)

    return findUniques(tails, 'hash').sort(Entry.compare)
  }

  // Find the hashes to entries that are not in a collection
  // but referenced by other entries
  static findTailHashes (entries) {
    var hashes = {}
    var addToIndex = e => (hashes[e.hash] = true)
    var reduceTailHashes = (res, entry, idx, arr) => {
      var addToResult = (e) => {
        /* istanbul ignore else */
        if (hashes[e] === undefined) {
          res.splice(0, 0, e)
        }
      }
      entry.next.reverse().forEach(addToResult)
      return res
    }

    entries.forEach(addToIndex)
    return entries.reduce(reduceTailHashes, [])
  }

  static difference (a, b) {
    let stack = Object.keys(a._headsIndex)
    let traversed = {}
    let res = {}

    const pushToStack = hash => {
      if (!traversed[hash] && !b.get(hash)) {
        stack.push(hash)
        traversed[hash] = true
      }
    }

    while (stack.length > 0) {
      const hash = stack.shift()
      const entry = a.get(hash)
      if (entry && !b.get(hash) && entry.id === b.id) {
        res[entry.hash] = entry
        traversed[entry.hash] = true
        entry.next.forEach(pushToStack)
      }
    }
    return res
  }
}

module.exports = Log
module.exports.Sorting = Sorting
module.exports.AccessController = AccessController

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs-log",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/log.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/node_modules/did-jwt/lib/index.js", {"@stablelib/utf8":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@stablelib/utf8/lib/utf8.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","did-resolver":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-resolver/lib/resolver.js","elliptic":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/elliptic/lib/elliptic.js","js-sha256":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/js-sha256/src/sha256.js","js-sha3":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/node_modules/did-jwt/node_modules/js-sha3/src/sha3.js","tweetnacl":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/tweetnacl/nacl-fast.js","uport-base64url":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uport-base64url/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/node_modules/did-jwt/lib/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
function r(r){return r&&"object"==typeof r&&"default"in r?r.default:r}var e=require("js-sha256"),t=require("js-sha3"),n=require("elliptic"),o=r(require("tweetnacl")),i=require("@stablelib/utf8"),a=require("buffer"),u=r(require("uport-base64url")),c=r(require("did-resolver"));function f(r){return a.Buffer.from(e.sha256.arrayBuffer(r))}function s(r){return"0x"+(e=a.Buffer.from(r.slice(2),"hex"),a.Buffer.from(t.keccak_256.arrayBuffer(e))).slice(-20).toString("hex");var e}var d=new n.ec("secp256k1");function h(r,e){return void 0===e&&(e=64),r.length===e?r:"0".repeat(e-r.length)+r}function l(r){return new Uint8Array(Array.prototype.slice.call(Buffer.from(r,"base64"),0))}var p=new n.ec("secp256k1");function v(r,e){void 0===e&&(e=!1);var t=u.toBuffer(r);if(t.length!==(e?65:64))throw new Error("wrong signature length");var n={r:t.slice(0,32).toString("hex"),s:t.slice(32,64).toString("hex")};return e&&(n.recoveryParam=t[64]),n}var w={ES256K:function(r,e,t){var n=f(r),o=v(e),i=t.find(function(r){return p.keyFromPublic(r.publicKeyHex,"hex").verify(n,o)});if(!i)throw new Error("Signature invalid for JWT");return i},"ES256K-R":function(r,e,t){var n=v(e,!0),o=f(r),i=p.recoverPubKey(o,n,n.recoveryParam),a=i.encode("hex"),u=i.encode("hex",!0),c=s(a),d=t.find(function(r){var e=r.publicKeyHex;return e===a||e===u||r.ethereumAddress===c});if(!d)throw new Error("Signature invalid for JWT");return d},Ed25519:function(r,e,t){var n=i.encode(r),a=l(u.toBase64(e)),c=t.find(function(r){return o.sign.detached.verify(n,a,l(r.publicKeyBase64))});if(!c)throw new Error("Signature invalid for JWT");return c}};function y(r){var e=w[r];if(!e)throw new Error("Unsupported algorithm "+r);return e}function g(r){return"object"==typeof r&&"r"in r&&"s"in r}function m(r){return function(e,t){try{return Promise.resolve(t(e)).then(function(e){if(g(e))return function(t){var n=e.r,o=e.s,i=e.recoveryParam,c=a.Buffer.alloc(r?65:64);if(a.Buffer.from(n,"hex").copy(c,0),a.Buffer.from(o,"hex").copy(c,32),r){if(void 0===i)throw new Error("Signer did not return a recoveryParam");c[64]=i}return u.encode(c)}();throw new Error("expected a signer function that returns a signature object instead of string")})}catch(r){return Promise.reject(r)}}}y.toSignatureObject=v;var E={ES256K:m(),"ES256K-R":m(!0),Ed25519:function(r,e){try{return Promise.resolve(e(r)).then(function(r){if(g(r))throw new Error("expected a signer function that returns a string instead of signature object");return r})}catch(r){return Promise.reject(r)}}},b={ES256K:["Secp256k1VerificationKey2018","Secp256k1SignatureVerificationKey2018","EcdsaPublicKeySecp256k1"],"ES256K-R":["Secp256k1VerificationKey2018","Secp256k1SignatureVerificationKey2018","EcdsaPublicKeySecp256k1"],Ed25519:["ED25519SignatureVerification"]};function S(r){return u.encode(JSON.stringify(r))}function x(r){return r.match(/^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$/)}function P(r){if(r.match(/^did:/))return r;if(x(r))return"did:uport:"+r;throw new Error("Not a valid DID '"+r+"'")}function k(r){if(!r)throw new Error("no JWT passed into decodeJWT");var e=r.match(/^([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);if(e)return{header:JSON.parse(u.decode(e[1])),payload:JSON.parse(u.decode(e[2])),signature:e[3],data:e[1]+"."+e[2]};throw new Error("Incorrect format JWT")}exports.SimpleSigner=function(r){var e=d.keyFromPrivate(r);return function(r){try{var t=e.sign(f(r)),n=t.s,o=t.recoveryParam;return Promise.resolve({r:h(t.r.toString("hex")),s:h(n.toString("hex")),recoveryParam:o})}catch(r){return Promise.reject(r)}}},exports.NaclSigner=function(r){var e=l(r);return function(r){try{var t=i.encode(r),n=o.sign.detached(t,e),c=u.encode(a.Buffer.from(n));return Promise.resolve(c)}catch(r){return Promise.reject(r)}}},exports.verifyJWT=function(r,e){void 0===e&&(e={auth:null,audience:null,callbackUrl:null});try{var t=e.audience?P(e.audience):void 0,n=k(r),o=n.payload,i=n.header,a=n.signature,u=n.data;return Promise.resolve(function(r,e,t){try{var n=b[r];if(!n||0===n.length)throw new Error("No supported signature types for algorithm "+r);var o=P(e);return Promise.resolve(c(o)).then(function(e){if(!e)throw new Error("Unable to resolve DID document for "+o);var i=!t||(e.authentication||[]).map(function(r){return r.publicKey}),a=(e.publicKey||[]).filter(function(r){var e=r.type,o=r.id;return n.find(function(r){return r===e&&(!t||Array.isArray(i)&&i.indexOf(o)>=0)})});if(t&&(!a||0===a.length))throw new Error("DID document for "+o+" does not have public keys suitable for authenticationg user");if(!a||0===a.length)throw new Error("DID document for "+o+" does not have public keys for "+r);return{authenticators:a,issuer:o,doc:e}})}catch(r){return Promise.reject(r)}}(i.alg,o.iss,e.auth)).then(function(n){var c,f=n.doc,s=n.authenticators,d=n.issuer,h=y(i.alg)(u,a,s),l=Math.floor(Date.now()/1e3);if(h){if(o.iat&&o.iat>l+300)throw new Error("JWT not valid yet (issued in the future): iat: "+o.iat+" > now: "+l);if(o.exp&&o.exp<=l-300)throw new Error("JWT has expired: exp: "+o.exp+" < now: "+l);if(o.aud)if((c=o.aud)&&(c.match(/^did:/)||x(c))){if(!t)throw new Error("JWT audience is required but your app address has not been configured");if(t!==P(o.aud))throw new Error("JWT audience does not match your DID: aud: "+o.aud+" !== yours: "+t)}else{if(!e.callbackUrl)throw new Error("JWT audience matching your callback url is required but one wasn't passed in");if(o.aud!==e.callbackUrl)throw new Error("JWT audience does not match the callback url: aud: "+o.aud+" !== url: "+e.callbackUrl)}return{payload:o,doc:f,issuer:d,signer:h,jwt:r}}})}catch(r){return Promise.reject(r)}},exports.createJWT=function(r,e){var t=e.issuer,n=e.signer,o=e.alg,i=e.expiresIn;try{if(!n)throw new Error("No Signer functionality has been configured");if(!t)throw new Error("No issuing DID has been configured");var a={typ:"JWT",alg:o||"ES256K"},u={iat:Math.floor(Date.now()/1e3),exp:void 0};if(i){if("number"!=typeof i)throw new Error("JWT expiresIn is not a number");u.exp=u.iat+Math.floor(i)}var c=[S(a),S(Object.assign({},u,r,{iss:t}))].join("."),f=function(r){var e=E[r];if(!e)throw new Error("Unsupported algorithm "+r);return e}(a.alg);return Promise.resolve(f(c,n)).then(function(r){return[c,r].join(".")})}catch(r){return Promise.reject(r)}},exports.decodeJWT=k,exports.toEthereumAddress=s;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"did-jwt",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/node_modules/did-jwt/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/index.js", {"./src/identities":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/src/identities.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/index.js
      return function (require, module, exports) {
'use strict'
const IdentityProvider = require('./src/identities')

module.exports = IdentityProvider

      };
    };
  }
}, {package:"orbit-db-identity-provider",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-did-document/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-did-document/index.js
      return function (require, module, exports) {
const DID_PLACEHOLDER = 'GENESIS'

/**
 * A class for creating ipfs based DID Documents.
 * Based on the DID spec: https://w3c-ccg.github.io/did-spec/
 */
class DidDocument {
  /**
   * Create a new DID Document.
   *
   * @param     {Object}        ipfs            An js-ipfs instance
   * @param     {String}        method          The name of the DID Method
   * @return    {DidDocument}                   self
   */
  constructor (ipfs, method) {
    this._ipfs = ipfs
    this._content = {
      id: `did:${method}:${DID_PLACEHOLDER}`
    }
  }

  get DID () {
    if (this._content.id.includes(DID_PLACEHOLDER)) {
      throw new Error('DID is not available before commit')
    }
    return this._content.id
  }

  /**
   * Load an already existing DID Document.
   *
   * @param     {Object}        ipfs            An js-ipfs instance
   * @param     {String}        documentCid     The CID of the document
   * @return    {Promise<DidDocument>}                   self
   */
  static async load (ipfs, documentCid) {
    const doc = new DidDocument(ipfs)
    doc._content = await DidDocument.cidToDocument(ipfs, documentCid)
    doc._content.previousDocument = { '/': documentCid.toString() }
    return doc
  }

  /**
   * Add a new public key
   *
   * @param     {String}        id              The id of the key, e.g. "key1"
   * @param     {String}        type            The type of the key
   * @param     {String}        encoding        The encoding of the key
   * @param     {String}        key             The encoded public key
   * @param     {String}        owner           The owner of the key (optional)
   */
  addPublicKey (id, type, encoding, key, owner) {
    if (!this._content.publicKey) {
      this._content.publicKey = []
    }
    let entry = {
      id: `${this._content.id}#${id}`,
      type
    }
    entry[encoding] = key
    if (owner) {
      entry.owner = owner
    }
    this._content.publicKey.push(entry)
  }

  /**
   * Remove a public key
   *
   * @param     {String}        id              The id of the key, e.g. "key1"
   */
  removePublicKey (id) {
    const idx = this._content.publicKey.findIndex(e => e.id.endsWith(id))
    this._content.publicKey.splice(idx, 1)
    if (!this._content.publicKey.length) {
      delete this._content.publicKey
    }
  }

  /**
   * Add a new authentication
   *
   * @param     {String}        type            The type of the authentication
   * @param     {String}        id              The id of the key to be used, e.g. "key1"
   */
  addAuthentication (type, id) {
    if (!this._content.authentication) {
      this._content.authentication = []
    }
    this._content.authentication.push({
      type,
      publicKey: `${this._content.id}#${id}`
    })
  }

  /**
   * Remove an authentication
   *
   * @param     {String}        id              The id of the key, e.g. "key1"
   */
  removeAuthentication (id) {
    const idx = this._content.authentication.findIndex(e => e.publicKey.endsWith(id))
    this._content.authentication.splice(idx, 1)
    if (!this._content.authentication.length) {
      delete this._content.authentication
    }
  }

  /**
   * Add a new service
   *
   * @param     {String}        id                  The id of the key to be used, e.g. "key1"
   * @param     {String}        type                The type of the service
   * @param     {String}        serviceEndpoint     The endpoint of the service
   * @param     {Object}        additionalFields    Any additional fields (optional)
   */
  addService (id, type, serviceEndpoint, additionalFields) {
    if (!this._content.service) {
      this._content.service = []
    }
    this._content.service.push(Object.assign({
      id: `${this._content.id};${id}`,
      type,
      serviceEndpoint
    }, additionalFields))
  }

  /**
   * Remove a service
   *
   * @param     {String}        id              The id of the key, e.g. "key1"
   */
  removeService (id) {
    const idx = this._content.service.findIndex(e => e.id.endsWith(id))
    this._content.service.splice(idx, 1)
    if (!this._content.service.length) {
      delete this._content.service
    }
  }

  /**
   * Set the revocationMethod. This can be of any js object
   * and is determined by the implementer of a revocation module.
   *
   * @param     {Object}        methodDescriptor    the object that defines the revocation method
   */
  setRevocationMethod (methodDescriptor) {
    this._content.revocationMethod = methodDescriptor
  }

  /**
   * Add a new property
   *
   * @param     {String}        propName            The name of the property
   * @param     {Object}        propValue           The value of the property
   */
  addCustomProperty (propName, propValue) {
    this._content[propName] = propValue
  }

  /**
   * Remove a property
   *
   * @param     {String}        propName            The name of the property
   */
  removeCustomProperty (propName) {
    delete this._content[propName]
  }

  /**
   * Commit all changes and create a new ipfs dag object.
   *
   * @param     {Object}        opts                Optional parameters
   * @param     {Boolean}       noTimestamp         Don't use timestamps if true
   *
   * @return    {Promise<CID>}                   The CID of the object
   */
  async commit (opts = {}) {
    if (!this._content.created) {
      this._content['@context'] = 'https://w3id.org/did/v1'
      if (!opts.noTimestamp) {
        this._content.created = (new Date(Date.now())).toISOString()
      }
    } else if (!opts.noTimestamp) {
      this._content.updated = (new Date(Date.now())).toISOString()
    }
    const cid = await this._ipfs.dag.put(this._content, { format: 'dag-cbor', hashAlg: 'sha2-256' })
    // set up for further changes:
    this._content = await DidDocument.cidToDocument(this._ipfs, cid)
    this._content.previousDocument = { '/': cid.toString() }
    return cid
  }

  /**
   * Returns the DID document of a document CID
   *
   * @param     {Object}        ipfs            An js-ipfs instance
   * @param     {String}        documentCid     The CID of the document
   * @return    {Promise<Object>}                        The DID document as a js object
   */
  static async cidToDocument (ipfs, documentCid) {
    let doc = (await ipfs.dag.get(documentCid)).value
    // If genesis document replace placeholder identifier with cid
    if (doc.id.includes(DID_PLACEHOLDER)) {
      const re = new RegExp(DID_PLACEHOLDER, 'gi')
      doc.id = doc.id.replace(re, documentCid)
      if (doc.publicKey) {
        doc.publicKey = JSON.parse(JSON.stringify(doc.publicKey).replace(re, documentCid))
      }
      if (doc.authentication) {
        doc.authentication = JSON.parse(JSON.stringify(doc.authentication).replace(re, documentCid))
      }
      if (doc.service) {
        doc.service = JSON.parse(JSON.stringify(doc.service).replace(re, documentCid))
      }
    }
    if (doc.previousDocument) {
      // make CID human readable
      doc.previousDocument = { '/': doc.previousDocument.toString() }
    }
    return doc
  }
}

module.exports = DidDocument

      };
    };
  }
}, {package:"ipfs-did-document",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-did-document/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mini/src/index.js", {"./lib/XMLHttpRequest":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mini/src/lib/XMLHttpRequest-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mini/src/index.js
      return function (require, module, exports) {
var XMLHttpRequest = require('./lib/XMLHttpRequest');

module.exports = IPFS;

/**
 * The varructor object
 * @param {Object} `provider` the provider object
 * @return {Object} `ipfs` returns an IPFS instance
 * @throws if the `new` flag is not used
 */
function IPFS(provider) {
  if (!(this instanceof IPFS)) { throw new Error('[ipfs-mini] IPFS instance must be instantiated with "new" flag (e.g. var ipfs = new IPFS("http://localhost:8545");).'); }

  var self = this;
  self.setProvider(provider || {});
}

/**
 * No operation method
 */
function noop() {}
function newPromise(val) { return new Promise(val); }
function noopPromise(val) { val(noop, noop); }

/**
 * Sets the provider of the IPFS instance
 * @param {Object} `provider` the provider object
 * @throws if the provider object is not an object
 */
IPFS.prototype.setProvider = function setProvider(provider) {
  if (typeof provider !== 'object') { throw new Error(`[ifpsjs] provider must be type Object, got '${typeof provider}'.`); }
  var self = this;
  var data = self.provider = Object.assign({
    host: '127.0.0.1',
    pinning: true,
    port: '5001',
    protocol: 'http',
    base: '/api/v0' }, provider || {});
  self.requestBase = String(`${data.protocol}://${data.host}:${data.port}${data.base}`);
};

/**
 * Sends an async data packet to an IPFS node
 * @param {Object} `opts` the options object
 * @param {Function} `cb` the provider callback
 * @callback returns an error if any, or the data from IPFS
 */
IPFS.prototype.sendAsync = function sendAsync(opts, cb) {
  var self = this;
  var request = new XMLHttpRequest(); // eslint-disable-line
  var options = opts || {};

  return (cb ? noopPromise : newPromise)(function (resolve, reject) {
    function callback(e, r){
      (cb || noop)(e, options.takeHash && r ? r.Hash : r);
      if (e) return reject(e);
      if (!e && r) return resolve(options.takeHash ? r.Hash : r);
    };

    request.onreadystatechange = function () {
      if (request.readyState === 4 && request.timeout !== 1) {
        if (request.status !== 200) {
          callback(new Error(`[ipfs-mini] status ${request.status}: ${request.responseText}`), null);
        } else {
          try {
            callback(null, (options.jsonParse ? JSON.parse(request.responseText) : request.responseText));
          } catch (jsonError) {
            callback(new Error(`[ipfs-mini] while parsing data: '${String(request.responseText)}', error: ${String(jsonError)} with provider: '${self.requestBase}'`, null));
          }
        }
      }
    };

    try {
      var pinningURI = self.provider.pinning && opts.uri === '/add' ? '?pin=true' : '';

      if (options.payload) {
        request.open('POST', `${self.requestBase}${opts.uri}${pinningURI}`);
      } else {
        request.open('GET', `${self.requestBase}${opts.uri}${pinningURI}`);
      }

      if (options.accept) {
        request.setRequestHeader('accept', options.accept);
      }

      if (options.payload && options.boundary) {
        request.setRequestHeader('Content-Type', `multipart/form-data; boundary=${options.boundary}`);
        request.send(options.payload);
      } else {
        request.send();
      }
    } catch (err) {
      callback(err, null);
    }
  });
};

/**
 * creates a boundary that isn't part of the payload
 */
function createBoundary(data) {
  while (true) {
    var boundary = `----IPFSMini${Math.random() * 100000}.${Math.random() * 100000}`;
    if (data.indexOf(boundary) === -1) {
      return boundary;
    }
  }
}

/**
 * Add an string or buffer to IPFS
 * @param {String|Buffer} `input` a single string or buffer
 * @param {Function} `callback` a callback, with (error, ipfsHash String)
 * @callback {String} `ipfsHash` returns an IPFS hash string
 */
IPFS.prototype.add = function addData(input, callback) {
  var data = ((typeof input === 'object' && input.isBuffer) ? input.toString('binary') : input);
  var boundary = createBoundary(data);
  var payload = `--${boundary}\r\nContent-Disposition: form-data; name="path"\r\nContent-Type: application/octet-stream\r\n\r\n${data}\r\n--${boundary}--`;

  return this.sendAsync({
    jsonParse: true,
    accept: 'application/json',
    uri: '/add',
    takeHash: true,
    payload, boundary,
  }, callback);
};

/**
 * Add an JSON object to IPFS
 * @param {Object} `jsonData` a single JSON object
 * @param {Function} `callback` a callback, with (error, ipfsHash String)
 * @callback {String} `ipfsHash` returns an IPFS hash string
 */
IPFS.prototype.addJSON = function addJson(jsonData, callback) {
  var self = this;
  return self.add(JSON.stringify(jsonData), callback);
};

/**
 * Get an object stat `/object/stat` for an IPFS hash
 * @param {String} `ipfsHash` a single IPFS hash String
 * @param {Function} `callback` a callback, with (error, stats Object)
 * @callback {Object} `stats` returns the stats object for that IPFS hash
 */
IPFS.prototype.stat = function cat(ipfsHash, callback) {
  var self = this;
  return self.sendAsync({ jsonParse: true, uri: `/object/stat/${ipfsHash}` }, callback);
};

/**
 * Get the data from an IPFS hash
 * @param {String} `ipfsHash` a single IPFS hash String
 * @param {Function} `callback` a callback, with (error, stats Object)
 * @callback {String} `data` returns the output data
 */
IPFS.prototype.cat = function cat(ipfsHash, callback) {
  var self = this;
  return self.sendAsync({ uri: `/cat/${ipfsHash}` }, callback);
};

/**
 * Get the data from an IPFS hash that is a JSON object
 * @param {String} `ipfsHash` a single IPFS hash String
 * @param {Function} `callback` a callback, with (error, json Object)
 * @callback {Object} `data` returns the output data JSON object
 */
IPFS.prototype.catJSON = function catJSON(ipfsHash, callback) {
  var self = this;
  return self.sendAsync({ uri: `/cat/${ipfsHash}`, jsonParse: true }, callback);
};

      };
    };
  }
}, {package:"ipfs-mini",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mini/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/3id/keyring.js", {"../utils/index":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/index.js","@babel/runtime/helpers/classCallCheck":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/classCallCheck.js","@babel/runtime/helpers/createClass":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/createClass.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","did-jwt":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/node_modules/did-jwt/lib/index.js","elliptic":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/elliptic/lib/elliptic.js","ethers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/node_modules/ethers/dist/ethers.min.js","tweetnacl":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/tweetnacl/nacl-fast.js","tweetnacl-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/tweetnacl-util/nacl-util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/3id/keyring.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var HDNode = require('ethers').utils.HDNode;

var nacl = require('tweetnacl');

nacl.util = require('tweetnacl-util');

var SimpleSigner = require('did-jwt').SimpleSigner;

var _require = require('../utils/index'),
    sha256 = _require.sha256;

var EC = require('elliptic').ec;

var ec = new EC('secp256k1');
var BASE_PATH = "m/7696500'/0'/0'";
var MM_PATH = "m/44'/60'/0'/0";

var Keyring =
/*#__PURE__*/
function () {
  function Keyring(seed) {
    (0, _classCallCheck2["default"])(this, Keyring);
    this._seed = seed;
    var seedNode = HDNode.fromSeed(this._seed);
    var baseNode = seedNode.derivePath(BASE_PATH);
    this.signingKey = baseNode.derivePath("0");
    var tmpEncKey = Buffer.from(baseNode.derivePath("2").privateKey.slice(2), 'hex');
    this.asymEncryptionKey = nacl.box.keyPair.fromSecretKey(new Uint8Array(tmpEncKey));
    this.symEncryptionKey = new Uint8Array(Buffer.from(baseNode.derivePath("3").privateKey.slice(2), 'hex'));
    this.ethereumKey = seedNode.derivePath(MM_PATH).derivePath("0");
  }

  (0, _createClass2["default"])(Keyring, [{
    key: "asymEncrypt",
    value: function asymEncrypt(msg, toPublic, nonce) {
      nonce = nonce || randomNonce();
      toPublic = nacl.util.decodeBase64(toPublic);

      if (typeof msg === 'string') {
        msg = nacl.util.decodeUTF8(msg);
      }

      var ciphertext = nacl.box(msg, nonce, toPublic, this.asymEncryptionKey.secretKey);
      return {
        nonce: nacl.util.encodeBase64(nonce),
        ciphertext: nacl.util.encodeBase64(ciphertext)
      };
    }
  }, {
    key: "asymDecrypt",
    value: function asymDecrypt(ciphertext, fromPublic, nonce, toBuffer) {
      fromPublic = nacl.util.decodeBase64(fromPublic);
      ciphertext = nacl.util.decodeBase64(ciphertext);
      nonce = nacl.util.decodeBase64(nonce);
      var cleartext = nacl.box.open(ciphertext, nonce, fromPublic, this.asymEncryptionKey.secretKey);

      if (toBuffer) {
        return cleartext ? Buffer.from(cleartext) : null;
      }

      return cleartext ? nacl.util.encodeUTF8(cleartext) : null;
    }
  }, {
    key: "symEncrypt",
    value: function symEncrypt(msg, nonce) {
      return symEncryptBase(msg, this.symEncryptionKey, nonce);
    }
  }, {
    key: "symDecrypt",
    value: function symDecrypt(ciphertext, nonce, toBuffer) {
      return symDecryptBase(ciphertext, this.symEncryptionKey, nonce, toBuffer);
    }
  }, {
    key: "getJWTSigner",
    value: function getJWTSigner() {
      return SimpleSigner(this.signingKey.privateKey.slice(2));
    }
  }, {
    key: "getDBSalt",
    value: function getDBSalt() {
      return sha256(this.signingKey.derivePath('0').privateKey.slice(2));
    }
  }, {
    key: "getPublicKeys",
    value: function getPublicKeys(uncompressed) {
      var signingKey = this.signingKey.publicKey.slice(2);
      var ethereumKey = this.ethereumKey.publicKey.slice(2);

      if (uncompressed) {
        signingKey = ec.keyFromPublic(Buffer.from(signingKey, 'hex')).getPublic(false, 'hex');
        ethereumKey = ec.keyFromPublic(Buffer.from(ethereumKey, 'hex')).getPublic(false, 'hex');
      }

      return {
        signingKey: signingKey,
        ethereumKey: ethereumKey,
        asymEncryptionKey: nacl.util.encodeBase64(this.asymEncryptionKey.publicKey)
      };
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return this._seed;
    }
  }]);
  return Keyring;
}();

var randomNonce = function randomNonce() {
  return nacl.randomBytes(24);
};

var symEncryptBase = function symEncryptBase(msg, symKey, nonce) {
  nonce = nonce || randomNonce();

  if (typeof msg === 'string') {
    msg = nacl.util.decodeUTF8(msg);
  }

  var ciphertext = nacl.secretbox(msg, nonce, symKey);
  return {
    nonce: nacl.util.encodeBase64(nonce),
    ciphertext: nacl.util.encodeBase64(ciphertext)
  };
};

var symDecryptBase = function symDecryptBase(ciphertext, symKey, nonce, toBuffer) {
  ciphertext = nacl.util.decodeBase64(ciphertext);
  nonce = nacl.util.decodeBase64(nonce);
  var cleartext = nacl.secretbox.open(ciphertext, nonce, symKey);

  if (toBuffer) {
    return cleartext ? Buffer.from(cleartext) : null;
  }

  return cleartext ? nacl.util.encodeUTF8(cleartext) : null;
};

module.exports = Keyring;
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"3box",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/3id/keyring.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3id-resolver/lib/register.js", {"@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js","base64url":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/base64url/index.js","did-jwt":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/index.js","did-resolver":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-resolver/lib/resolver.js","ipfs-did-document":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-did-document/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3id-resolver/lib/register.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _didJwt = require("did-jwt");

var _ipfsDidDocument = _interopRequireDefault(require("ipfs-did-document"));

var _base64url = _interopRequireDefault(require("base64url"));

var _didResolver = require("did-resolver");

var PUBKEY_IDS = ['signingKey', 'managementKey', 'encryptionKey'];
var SUB_PUBKEY_IDS = ['subSigningKey', 'subEncryptionKey'];

function register(ipfs) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _didResolver.registerMethod)('3', function (_, _ref) {
    var id = _ref.id;
    return resolve(ipfs, id);
  });
}

function resolve(_x, _x2, _x3) {
  return _resolve.apply(this, arguments);
}

function _resolve() {
  _resolve = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee(ipfs, cid, isRoot) {
    var doc, rootDoc;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return _ipfsDidDocument["default"].cidToDocument(ipfs, cid);

          case 3:
            doc = _context.sent;
            validateDoc(doc);

            if (!doc.root) {
              _context.next = 14;
              break;
            }

            if (!isRoot) {
              _context.next = 8;
              break;
            }

            throw new Error('Only one layer subDoc allowed');

          case 8:
            _context.next = 10;
            return resolve(ipfs, doc.root.split(':')[2], true);

          case 10:
            rootDoc = _context.sent;
            _context.next = 13;
            return verifyProof(doc);

          case 13:
            doc = mergeDocuments(rootDoc, doc);

          case 14:
            _context.next = 26;
            break;

          case 16:
            _context.prev = 16;
            _context.t0 = _context["catch"](0);
            _context.prev = 18;
            _context.next = 21;
            return ipfs.pin.rm(cid);

          case 21:
            _context.next = 25;
            break;

          case 23:
            _context.prev = 23;
            _context.t1 = _context["catch"](18);

          case 25:
            throw new Error('Invalid 3ID');

          case 26:
            return _context.abrupt("return", doc);

          case 27:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 16], [18, 23]]);
  }));
  return _resolve.apply(this, arguments);
}

function validateDoc(doc) {
  var pubKeyIds = PUBKEY_IDS;

  if (!doc || !doc.publicKey || !doc.authentication) {
    throw new Error('Not a valid 3ID');
  }

  if (doc.root) {
    pubKeyIds = SUB_PUBKEY_IDS;
    if (!doc.space) throw new Error('Not a valid 3ID');
  }

  doc.publicKey.map(function (entry) {
    var id = entry.id.split('#')[1];
    if (!pubKeyIds.includes(id)) throw new Error('Not a valid 3ID');
  });
}

function encodeSection(data) {
  return _base64url["default"].encode(JSON.stringify(data));
}

function verifyProof(_x4) {
  return _verifyProof.apply(this, arguments);
}

function _verifyProof() {
  _verifyProof = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee2(subDoc) {
    var subSigningKey, subEncryptionKey, payload, header, jwt;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            subSigningKey = subDoc.publicKey.find(function (entry) {
              return entry.id.includes(SUB_PUBKEY_IDS[0]);
            }).publicKeyHex;
            subEncryptionKey = subDoc.publicKey.find(function (entry) {
              return entry.id.includes(SUB_PUBKEY_IDS[1]);
            }).publicKeyBase64;
            payload = encodeSection({
              iat: null,
              subSigningKey: subSigningKey,
              subEncryptionKey: subEncryptionKey,
              space: subDoc.space,
              iss: subDoc.root
            });
            header = encodeSection({
              typ: 'JWT',
              alg: subDoc.proof.alg
            });
            jwt = "".concat(header, ".").concat(payload, ".").concat(subDoc.proof.signature);
            _context2.next = 7;
            return (0, _didJwt.verifyJWT)(jwt);

          case 7:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _verifyProof.apply(this, arguments);
}

function mergeDocuments(doc, subDoc) {
  subDoc.publicKey = doc.publicKey.concat(subDoc.publicKey);
  return subDoc;
}

module.exports = register;
      };
    };
  }
}, {package:"3id-resolver",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3id-resolver/lib/register.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/access-controllers.js", {"./access-controller-manifest":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/access-controller-manifest.js","./ipfs-access-controller":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/ipfs-access-controller.js","./legacy-ipfs-access-controller":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/legacy-ipfs-access-controller.js","./orbitdb-access-controller":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/orbitdb-access-controller.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/access-controllers.js
      return function (require, module, exports) {
'use strict'

const AccessControllerManifest = require('./access-controller-manifest')
const LegacyIPFSAccessController = require('./legacy-ipfs-access-controller')
const IPFSAccessController = require('./ipfs-access-controller')
const OrbitDBAccessController = require('./orbitdb-access-controller')

let supportedTypes = {
  'legacy-ipfs': LegacyIPFSAccessController,
  'ipfs': IPFSAccessController,
  'orbitdb': OrbitDBAccessController
}

const getHandlerFor = (type) => {
  if (!AccessControllers.isSupported(type)) {
    throw new Error(`AccessController type '${type}' is not supported`)
  }
  return supportedTypes[type]
}

class AccessControllers {
  static isSupported (type) {
    return Object.keys(supportedTypes).includes(type)
  }

  static addAccessController (options) {
    if (!options.AccessController) {
      throw new Error('AccessController class needs to be given as an option')
    }

    if (!options.AccessController.type ||
      typeof options.AccessController.type !== 'string') {
      throw new Error('Given AccessController class needs to implement: static get type() { /* return a string */}.')
    }

    supportedTypes[options.AccessController.type] = options.AccessController
  }

  static addAccessControllers (options) {
    const accessControllers = options.AccessControllers
    if (!accessControllers) {
      throw new Error('AccessController classes need to be given as an option')
    }

    accessControllers.forEach((accessController) => {
      AccessControllers.addAccessController({ AccessController: accessController })
    })
  }

  static removeAccessController (type) {
    delete supportedTypes[type]
  }

  static async resolve (orbitdb, manifestAddress, options = {}) {
    const { type, params } = await AccessControllerManifest.resolve(orbitdb._ipfs, manifestAddress, options)
    const AccessController = getHandlerFor(type)
    const accessController = await AccessController.create(orbitdb, Object.assign({}, options, params))
    await accessController.load(params.address)
    return accessController
  }

  static async create (orbitdb, type, options = {}) {
    const AccessController = getHandlerFor(type)
    const ac = await AccessController.create(orbitdb, options)
    const params = await ac.save()
    const hash = await AccessControllerManifest.create(orbitdb._ipfs, type, params)
    return hash
  }
}

module.exports = AccessControllers

      };
    };
  }
}, {package:"orbit-db-access-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/access-controllers.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/moderatorAccessController.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/moderatorAccessController.js
      return function (require, module, exports) {
const type = 'moderator-access'

const MODERATOR = 'MODERATOR'
const MEMBER = 'MEMBER'

class ModeratorAccessController {
  constructor (firstModerator, options) {
    this._capabilityTypes = [MODERATOR]
    this._write = []     // Allowed to add other mods or members
    this._firstModerator = firstModerator
    this._write.push(this._firstModerator)
    this._members = Boolean(options.members)
    if (this._members) this._capabilityTypes.push(MEMBER)
  }

  static get type () { return type }

  isMod(id) {
    return this._write.includes(id)
  }

  isValidCapability (capability) {
    return this._capabilityTypes.includes(capability)
  }

  get firstModerator () {
    return this._firstModerator
  }

  async canAppend (entry, identityProvider) {
    const entryID = entry.identity.id
    const capability = entry.payload.value.capability
    const idAdd = entry.payload.value.id
    const isMod = this.isMod(entryID)
    const validCapability = this.isValidCapability(capability)
    const validSig = async () => identityProvider.verifyIdentity(entry.identity)
    if (isMod && validCapability && (await validSig())) {
      if (capability === MODERATOR) this._write.push(idAdd)
      return true
    }

    return false
  }

  async load (address) {
    const addList = address.split('/')
    const suffix = addList.pop()
    this._members = suffix === 'members'
    const mod = suffix.includes('mod') ? suffix : addList.pop()
    this._firstModerator = mod.split('_')[1]
  }

  async save () {
    // TODO if entire obj saved in manfest, can just pass our own fields
    let address = `${type}/mod_${this._firstModerator}`
    address += this._members ? '/members' : ''
    return { address }
  }

  static async create (orbitdb, options = {}) {
    if (!options.firstModerator) throw new Error('Moderator AC: firstModerator required')
    return new ModeratorAccessController(options.firstModerator, options)
  }
}

module.exports = ModeratorAccessController

      };
    };
  }
}, {package:"3box-orbitdb-plugins",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/moderatorAccessController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/legacyIpfs3boxAccessController.js", {"did-resolver":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-resolver/lib/resolver.js","orbit-db-io":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-io/index.js","safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/legacyIpfs3boxAccessController.js
      return function (require, module, exports) {
const io = require('orbit-db-io')
const Buffer = require('safe-buffer').Buffer
//const AccessController = require('./access-controller-interface')
const resolve = require('did-resolver').default
const type = 'legacy-ipfs-3box'

const publicKeyFromDID = async did => {
  // TODO - this should look at authentication keys and get publicKey from that
  const doc = await resolve(did)
  return doc.publicKey.find(entry => {
    const id = entry.id.split('#')
    return id[0] === doc.id &&
      (id[1] === 'subSigningKey' || id[1] === 'signingKey')
  }).publicKeyHex
}

class LegacyIPFS3BoxAccessController {
  constructor (ipfs, options) {
    //super()
    this._ipfs = ipfs
    this._write = Array.from(options.write || [])
  }

  // Returns the type of the access controller
  static get type () { return type }

  // Return a Set of keys that have `access` capability
  get write () {
    return this._write
  }

  async canAppend (entry, identityProvider) {
    // Allow if access list contain the writer's publicKey or is '*'
    const publicKey = entry.v === 0 ? entry.key : await publicKeyFromDID(entry.identity.id)
    if (this.write.includes(publicKey) ||
      this.write.includes('*')) {
      return entry.v === 0 ? true : await identityProvider.verifyIdentity(entry.identity)
    }
    return false
  }

  async load (address) {
    // Transform '/ipfs/QmPFtHi3cmfZerxtH9ySLdzpg1yFhocYDZgEZywdUXHxFU'
    // to 'QmPFtHi3cmfZerxtH9ySLdzpg1yFhocYDZgEZywdUXHxFU'
    if (address.indexOf('/ipfs') === 0) { address = address.split('/')[2] }

    try {
      const access = await io.read(this._ipfs, address)
      this._write = access.write
    } catch (e) {
      console.log('LegacyIPFS3BoxAccessController.load ERROR:', e)
    }
  }

  async save (options) {
    let cid
    const access = { admin: [], write: this.write, read: [] }
    try {
      cid = await io.write(this._ipfs, 'raw', Buffer.from(JSON.stringify(access, null, 2)), { format: 'dag-pb'})

    } catch (e) {
      console.log('LegacyIPFS3BoxAccessController.save ERROR:', e)
    }
    // return the manifest data
    return { address: cid, skipManifest: true }
  }

  static async create (orbitdb, options = {}) {
    options = { ...options, ...{ write: options.write || [orbitdb.identity.publicKey] } }
    return new LegacyIPFS3BoxAccessController(orbitdb._ipfs, options)
  }
}

module.exports = LegacyIPFS3BoxAccessController

      };
    };
  }
}, {package:"3box-orbitdb-plugins",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/legacyIpfs3boxAccessController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/threadAccessController.js", {"events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","ipfs-log/src/entry":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/entry.js","is-ipfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-ipfs/src/index.js","orbit-db-access-controllers/src/utils/ensure-ac-address":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/utils/ensure-ac-address.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/threadAccessController.js
      return function (require, module, exports) {
const ensureAddress = require('orbit-db-access-controllers/src/utils/ensure-ac-address')
const EventEmitter = require('events').EventEmitter
const entryIPFS = require('ipfs-log/src/entry')
const isIPFS = require('is-ipfs')

const type = 'thread-access'
const MODERATOR = 'MODERATOR'
const MEMBER = 'MEMBER'

const isValid3ID = did => {
  const parts = did.split(':')
  if (!parts[0] === 'did' || !parts[1] === '3') return false
  return isIPFS.cid(parts[2])
}

class ThreadAccessController extends EventEmitter{
  constructor (orbitdb, ipfs, identity, firstModerator, options) {
    super()
    this._orbitdb = orbitdb
    this._db = null
    this._options = options || {}
    this._ipfs = ipfs
    this._members = Boolean(options.members)
    this._firstModerator = firstModerator
    this._threadName = options.threadName
    this._identity = identity
  }

  static get type () { return type }

  // return addres of AC (in this case orbitdb address of AC)
  get address () {
    return this._db.address
  }

  async canAppend (entry, identityProvider) {
    const trueIfValidSig = async () => await identityProvider.verifyIdentity(entry.identity)

    const op = entry.payload.op
    const mods = this.capabilities['moderators']
    const members = this.capabilities['members']
    const isMod = mods.includes(entry.identity.id)
    const isMember = members.includes(entry.identity.id)

    if (op === 'ADD') {
      // Anyone can add entry if open thread
      if (!this._members) return await trueIfValidSig()
      // Not open thread, any member or mod can add to thread
      if (isMember || isMod) return await trueIfValidSig()
    }

    if (op === 'DEL') {
      const hash = entry.payload.value
      const delEntry = await entryIPFS.fromMultihash(this._ipfs, hash)

      // An id can delete their own entries
      if (delEntry.identity.id === entry.identity.id) return await trueIfValidSig()

      // Mods can delete any entry
      if (isMod) return await trueIfValidSig()
    }

    return false
  }

  get capabilities () {
    if (!this._capabilities) this._updateCapabilites()
    return this._capabilities
  }

  _updateCapabilites () {
    let moderators = [], members = []
    if (this._db) {
      moderators.push(this._db.access._firstModerator)
      Object.entries(this._db.index).forEach(entry => {
        const capability = entry[1].payload.value.capability
        const id = entry[1].payload.value.id
        if (capability === MODERATOR) moderators.push(id)
        if (capability === MEMBER) members.push(id)
      })
    }
    this._capabilities = {moderators, members}
    return this._capabilities
  }

  get (capability) {
    return this.capabilities[capability] || []
  }

  async close () {
    await this._db.close()
  }

  async load (address) {
    if (this._db) { await this._db.close() }

    // TODO - skip manifest for mod-access
    this._db = await this._orbitdb.feed(ensureAddress(address), {
      identity: this._identity,
      accessController: {
        type: 'moderator-access',
        firstModerator: this._firstModerator,
        members: this._members
      },
      sync: true
    })

    this._db.events.on('ready', this._onUpdate.bind(this))
    this._db.events.on('write', this._onUpdate.bind(this))
    this._db.events.on('replicated', this._onUpdate.bind(this))

    await this._db.load()
  }

  async save () {
    return {
      address: this._db.address.toString(),
      firstModerator: this._firstModerator,
      members: this._members
    }
  }

  async grant (capability, id) {
    if (!this._db.access.isValidCapability(capability)) {
      throw new Error('grant: Invalid capability to grant')
    }
    if (capability === MEMBER && this.capabilities['members'].includes(id)) {
        throw new Error(`grant: capability ${capability} has already been granted to ${id}`)
    }
    if (capability === MODERATOR && this.capabilities['moderators'].includes(id)) {
        throw new Error(`grant: capability ${capability} has already been granted to ${id}`)
    }
    try {
      await this._db.add({capability, id})
    } catch (e) {
      if (e.toString().includes('not append entry')) throw new Error(`grant: Capability ${capability} can not be granted to ${id}`)
      throw e
    }
  }

  _onUpdate () {
    this._updateCapabilites()
    this.emit('updated')
  }

  /* Factory */
  static async create (orbitdb, options = {}) {
    if (!options.firstModerator) throw new Error('Thread AC: firstModerator required')
    const ac = new ThreadAccessController(orbitdb, orbitdb._ipfs, options.identity, options.firstModerator, options)
    await ac.load(options.address || options.threadName)
    return ac
  }
}

module.exports = ThreadAccessController

      };
    };
  }
}, {package:"3box-orbitdb-plugins",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/threadAccessController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/odbIdentityProvider.js", {"base64url":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/base64url/index.js","did-jwt":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/odbIdentityProvider.js
      return function (require, module, exports) {
const base64url = require('base64url')
const { verifyJWT } = require('did-jwt')

const encodeSection = data => base64url.encode(JSON.stringify(data))

const TYPE = '3ID'
const JWT_HEADER = encodeSection({ typ: 'JWT', alg: 'ES256K' })


class OdbIdentityProvider {
  constructor ({ threeId }) {
    // super(options)
    this.threeId = threeId
  }

  static get type () {
    return '3ID'
  }

  async getId ({ space }) {
    if (space) {
      return this.threeId.getSubDID(space)
    } else {
      return this.threeId.DID
    }
  }

  async signIdentity (data, { space }) {
    const payload = {
      data,
      iat: null
    }
    const opts = !space ? { use3ID: true } : { space }
    return (await this.threeId.signJWT(payload, opts)).split('.')[2]
  }

  static async verifyIdentity (identity) {
    const payload = encodeSection({
      iat: null,
      data: identity.publicKey + identity.signatures.id,
      iss: identity.id
    })
    const jwt = `${JWT_HEADER}.${payload}.${identity.signatures.publicKey}`
    try {
      await verifyJWT(jwt, { auth: true })
    } catch (e) {
      return false
    }
    return true
   }
}

module.exports = OdbIdentityProvider

      };
    };
  }
}, {package:"3box-orbitdb-plugins",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/odbIdentityProvider.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/logplease/src/index.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","fs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js","util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/util/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/logplease/src/index.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict';

const fs = require('fs');
const format = require('util').format;
const EventEmitter = require('events').EventEmitter;

let isElectronRenderer = process.type && process.type === 'renderer';
let isNodejs = !isElectronRenderer && process.version ? true : false;

const LogLevels = {
  'DEBUG': 'DEBUG',
  'INFO':  'INFO',
  'WARN':  'WARN',
  'ERROR': 'ERROR',
  'NONE':  'NONE',
};

// Global log level
let GlobalLogLevel = LogLevels.DEBUG;

// Global log file name
let GlobalLogfile = null;

let GlobalEvents = new EventEmitter();

// ANSI colors
let Colors = {
  'Black':   0,
  'Red':     1,
  'Green':   2,
  'Yellow':  3,
  'Blue':    4,
  'Magenta': 5,
  'Cyan':    6,
  'Grey':    7,
  'White':   9,
  'Default': 9,
};

// CSS colors
if(!isNodejs) {
  Colors = {
    'Black':   'Black',
    'Red':     'IndianRed',
    'Green':   'LimeGreen',
    'Yellow':  'Orange',
    'Blue':    'RoyalBlue',
    'Magenta': 'Orchid',
    'Cyan':    'SkyBlue',
    'Grey':    'DimGrey',
    'White':   'White',
    'Default': 'Black',
  };
}

const loglevelColors = [Colors.Cyan, Colors.Green, Colors.Yellow, Colors.Red, Colors.Default];

const defaultOptions = {
  useColors: true,
  color: Colors.Default,
  showTimestamp: true,
  useLocalTime: false,
  showLevel: true,
  filename: GlobalLogfile,
  appendFile: true,
};

class Logger {
  constructor(category, options) {
    this.category = category;
    let opts = {};
    Object.assign(opts, defaultOptions);
    Object.assign(opts, options);
    this.options = opts;
    this.debug = this.debug.bind(this);
    this.log = this.log.bind(this);
    this.info = this.info.bind(this);
    this.warn = this.warn.bind(this);
    this.error = this.error.bind(this);
  }

  debug() {
    if(this._shouldLog(LogLevels.DEBUG))
      this._write(LogLevels.DEBUG, format.apply(null, arguments));
  }

  log() {
    if(this._shouldLog(LogLevels.DEBUG))
      this.debug.apply(this, arguments);
  }

  info() {
    if(this._shouldLog(LogLevels.INFO))
      this._write(LogLevels.INFO, format.apply(null, arguments));
  }

  warn() {
    if(this._shouldLog(LogLevels.WARN))
      this._write(LogLevels.WARN, format.apply(null, arguments));
  }

  error() {
    if(this._shouldLog(LogLevels.ERROR))
      this._write(LogLevels.ERROR, format.apply(null, arguments));
  }

  _write(level, text) {
    if((this.options.filename || GlobalLogfile) && !this.fileWriter && isNodejs)
      this.fileWriter = fs.openSync(this.options.filename || GlobalLogfile, this.options.appendFile ? 'a+' : 'w+');

    let format = this._format(level, text);
    let unformattedText = this._createLogMessage(level, text);
    let formattedText = this._createLogMessage(level, text, format.timestamp, format.level, format.category, format.text);

    if(this.fileWriter && isNodejs)
      fs.writeSync(this.fileWriter, unformattedText + '\n', null, 'utf-8');

    if(isNodejs || !this.options.useColors) {
      console.log(formattedText)
      GlobalEvents.emit('data', this.category, level, text)
    } else {
      // TODO: clean this up
      if(level === LogLevels.ERROR) {
        if(this.options.showTimestamp && this.options.showLevel) {
          console.error(formattedText, format.timestamp, format.level, format.category, format.text)
        } else if(this.options.showTimestamp && !this.options.showLevel) {
          console.error(formattedText, format.timestamp, format.category, format.text)
        } else if(!this.options.showTimestamp && this.options.showLevel) {
          console.error(formattedText, format.level, format.category, format.text)
        } else {
          console.error(formattedText, format.category, format.text)
        }
      } else {
        if(this.options.showTimestamp && this.options.showLevel) {
          console.log(formattedText, format.timestamp, format.level, format.category, format.text)
        } else if(this.options.showTimestamp && !this.options.showLevel) {
          console.log(formattedText, format.timestamp, format.category, format.text)
        } else if(!this.options.showTimestamp && this.options.showLevel) {
          console.log(formattedText, format.level, format.category, format.text)
        } else {
          console.log(formattedText, format.category, format.text)
        }
      }
    }
  }

  _format(level, text) {
    let timestampFormat = '';
    let levelFormat     = '';
    let categoryFormat  = '';
    let textFormat      = ': ';

    if(this.options.useColors) {
        const levelColor    = Object.keys(LogLevels).map((f) => LogLevels[f]).indexOf(level);
        const categoryColor = this.options.color;

      if(isNodejs) {
        if(this.options.showTimestamp)
          timestampFormat = '\u001b[3' + Colors.Grey + 'm';

        if(this.options.showLevel)
          levelFormat = '\u001b[3' + loglevelColors[levelColor] + ';22m';

        categoryFormat = '\u001b[3' + categoryColor + ';1m';
        textFormat = '\u001b[0m: ';
      } else {
        if(this.options.showTimestamp)
          timestampFormat = 'color:' + Colors.Grey;

        if(this.options.showLevel)
          levelFormat = 'color:' + loglevelColors[levelColor];

        categoryFormat = 'color:' + categoryColor + '; font-weight: bold';
      }
    }

    return {
      timestamp: timestampFormat,
      level: levelFormat,
      category: categoryFormat,
      text: textFormat
    };
  }

  _createLogMessage(level, text, timestampFormat, levelFormat, categoryFormat, textFormat) {
    timestampFormat = timestampFormat || '';
    levelFormat     = levelFormat     || '';
    categoryFormat  = categoryFormat  || '';
    textFormat      = textFormat      || ': ';

    if(!isNodejs && this.options.useColors) {
      if(this.options.showTimestamp)
        timestampFormat = '%c';

      if(this.options.showLevel)
        levelFormat = '%c';

      categoryFormat  = '%c';
      textFormat = ': %c';
    }

    let result = '';

    if(this.options.showTimestamp && !this.options.useLocalTime)
      result += '' + new Date().toISOString() + ' ';

    if(this.options.showTimestamp && this.options.useLocalTime)
      result += '' + new Date().toLocaleString() + ' ';

    result = timestampFormat + result;

    if(this.options.showLevel)
      result += levelFormat + '[' + level +']' + (level === LogLevels.INFO || level === LogLevels.WARN ? ' ' : '') + ' ';

    result += categoryFormat + this.category;
    result += textFormat + text;
    return result;
  }

  _shouldLog(level) {
    let envLogLevel = (typeof process !== "undefined" && process.env !== undefined && process.env.LOG !== undefined) ? process.env.LOG.toUpperCase() : null;
    envLogLevel = (typeof window !== "undefined" && window.LOG) ? window.LOG.toUpperCase() : envLogLevel;

    const logLevel = envLogLevel || GlobalLogLevel;
    const levels   = Object.keys(LogLevels).map((f) => LogLevels[f]);
    const index    = levels.indexOf(level);
    const levelIdx = levels.indexOf(logLevel);
    return index >= levelIdx;
  }
};

/* Public API */
module.exports = {
  Colors: Colors,
  LogLevels: LogLevels,
  setLogLevel: (level) => {
    GlobalLogLevel = level;
  },
  setLogfile: (filename) => {
    GlobalLogfile = filename;
  },
  create: (category, options) => {
    const logger = new Logger(category, options);
    return logger;
  },
  forceBrowserMode: (force) => isNodejs = !force, // for testing,
  events: GlobalEvents,
};

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"logplease",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/logplease/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-feedstore/src/FeedStore.js", {"./FeedIndex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-feedstore/src/FeedIndex.js","orbit-db-eventstore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-eventstore/src/EventStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-feedstore/src/FeedStore.js
      return function (require, module, exports) {
'use strict'

const EventStore = require('orbit-db-eventstore')
const FeedIndex  = require('./FeedIndex')

class FeedStore extends EventStore {
  constructor (ipfs, id, dbname, options) {
    if(!options) options = {}
    if(!options.Index) Object.assign(options, { Index: FeedIndex })
    super(ipfs, id, dbname, options)
    this._type = 'feed'
  }

  remove (hash) {
    return this.del(hash)
  }

  del (hash) {
    const operation = {
      op: 'DEL',
      key: null,
      value: hash
    }
    return this._addOperation(operation)
  }
}

module.exports = FeedStore

      };
    };
  }
}, {package:"orbit-db-feedstore",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-feedstore/src/FeedStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-kvstore/src/KeyValueStore.js", {"./KeyValueIndex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-kvstore/src/KeyValueIndex.js","orbit-db-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/src/Store.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-kvstore/src/KeyValueStore.js
      return function (require, module, exports) {
'use strict'

const Store = require('orbit-db-store')
const KeyValueIndex = require('./KeyValueIndex')

class KeyValueStore extends Store {
  constructor(ipfs, id, dbname, options) {
    let opts = Object.assign({}, { Index: KeyValueIndex })
    Object.assign(opts, options)
    super(ipfs, id, dbname, opts)
    this._type = 'keyvalue'
  }

  get all () {
    return this._index._index
  }

  get (key) {
    return this._index.get(key)
  }

  set (key, data) {
    return this.put(key, data)
  }

  put (key, data) {
    return this._addOperation({
      op: 'PUT',
      key: key,
      value: data
    })
  }

  del (key) {
    return this._addOperation({
      op: 'DEL',
      key: key,
      value: null
    })
  }
}

module.exports = KeyValueStore

      };
    };
  }
}, {package:"orbit-db-kvstore",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-kvstore/src/KeyValueStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-docstore/src/DocumentStore.js", {"./DocumentIndex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-docstore/src/DocumentIndex.js","orbit-db-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/src/Store.js","p-map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-docstore/node_modules/p-map/index.js","readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/readable-stream/readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-docstore/src/DocumentStore.js
      return function (require, module, exports) {
'use strict'

const Store = require('orbit-db-store')
const DocumentIndex = require('./DocumentIndex')
const pMap = require('p-map')
const Readable = require('readable-stream')

const replaceAll = (str, search, replacement) => str.toString().split(search).join(replacement)

class DocumentStore extends Store {
  constructor (ipfs, id, dbname, options) {
    if (!options) options = {}
    if (!options.indexBy) Object.assign(options, { indexBy: '_id' })
    if (!options.Index) Object.assign(options, { Index: DocumentIndex })
    super(ipfs, id, dbname, options)
    this._type = 'docstore'
  }

  get (key, caseSensitive = false) {
    key = key.toString()
    const terms = key.split(' ')
    key = terms.length > 1 ? replaceAll(key, '.', ' ').toLowerCase() : key.toLowerCase()

    const search = (e) => {
      if (terms.length > 1) {
        return replaceAll(e, '.', ' ').toLowerCase().indexOf(key) !== -1
      }
      return e.toLowerCase().indexOf(key) !== -1
    }
    const mapper = e => this._index.get(e)
    const filter = e => caseSensitive
      ? e.indexOf(key) !== -1 
      : search(e)

    return Object.keys(this._index._index)
      .filter(filter)
      .map(mapper)
  }

  query (mapper, options = {}) {
    // Whether we return the full operation data or just the db value
    const fullOp = options.fullOp || false

    return Object.keys(this._index._index)
      .map((e) => this._index.get(e, fullOp))
      .filter(mapper)
  }

  batchPut (docs, onProgressCallback) {
    const mapper = (doc, idx) => {
      return this._addOperationBatch(
        {
          op: 'PUT',
          key: doc[this.options.indexBy],
          value: doc
        },
        true,
        idx === docs.length - 1,
        onProgressCallback
      )
    }

    return pMap(docs, mapper, { concurrency: 1 })
      .then(() => this.saveSnapshot())
  }

  put (doc) {
    if (!doc[this.options.indexBy])
      throw new Error(`The provided document doesn't contain field '${this.options.indexBy}'`)

    return this._addOperation({
      op: 'PUT',
      key: doc[this.options.indexBy],
      value: doc
    })
  }

  del (key) {
    if (!this._index.get(key))
      throw new Error(`No entry with key '${key}' in the database`)

    return this._addOperation({
      op: 'DEL',
      key: key,
      value: null
    })
  }
}

module.exports = DocumentStore
      };
    };
  }
}, {package:"orbit-db-docstore",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-docstore/src/DocumentStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/utils/index.js", {"./is-defined":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/utils/is-defined.js","orbit-db-io":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-io/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/utils/index.js
      return function (require, module, exports) {
'use strict'

const isDefined = require('./is-defined')
const io = require('orbit-db-io')

module.exports = {
  isDefined,
  io
}

      };
    };
  }
}, {package:"orbit-db",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/utils/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/db-manifest.js", {"orbit-db-io":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-io/index.js","path":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/path-browserify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/db-manifest.js
      return function (require, module, exports) {
const path = require('path')
const io = require('orbit-db-io')

// Creates a DB manifest file and saves it in IPFS
const createDBManifest = async (ipfs, name, type, accessControllerAddress, options) => {
  const manifest = {
    name: name,
    type: type,
    accessController: path.join('/ipfs', accessControllerAddress),
  }

  return io.write(ipfs, options.format || 'dag-cbor', manifest, options)
}

module.exports = createDBManifest

      };
    };
  }
}, {package:"orbit-db",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/db-manifest.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-counterstore/src/CounterStore.js", {"./CounterIndex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-counterstore/src/CounterIndex.js","crdts/src/G-Counter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/crdts/src/G-Counter.js","orbit-db-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/src/Store.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-counterstore/src/CounterStore.js
      return function (require, module, exports) {
'use strict'

const Store = require('orbit-db-store')
const CounterIndex = require('./CounterIndex')
const Counter = require('crdts/src/G-Counter')

class CounterStore extends Store {
  constructor(ipfs, id, dbname, options = {}) {
    if(!options.Index) Object.assign(options, { Index: CounterIndex })
    super(ipfs, id, dbname, options)
    this._type = 'counter'
  }

  get value() {
    return this._index.get().value
  }

  inc(amount) {
    const counter = new Counter(this.identity.publicKey, Object.assign({}, this._index.get()._counters))
    counter.increment(amount)
    return this._addOperation({
      op: 'COUNTER',
      key: null,
      value: counter.toJSON(),
    })
  }
}

module.exports = CounterStore

      };
    };
  }
}, {package:"orbit-db-counterstore",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-counterstore/src/CounterStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/exchange-heads.js", {"ipfs-pubsub-1on1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/src/direct-channel.js","logplease":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/logplease/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/exchange-heads.js
      return function (require, module, exports) {
'use strict'

const Channel = require('ipfs-pubsub-1on1')

const Logger = require('logplease')
const logger = Logger.create("exchange-heads", { color: Logger.Colors.Yellow })
Logger.setLogLevel('ERROR')

const getHeadsForDatabase = store => (store && store._oplog) ? store._oplog.heads : []

const exchangeHeads = async (ipfs, address, peer, getStore, getDirectConnection, onMessage, onChannelCreated) => {
  const _handleMessage = message => {
    const msg = JSON.parse(message.data)
    const { address, heads } = msg
    onMessage(address, heads)
  }

  let channel = getDirectConnection(peer)
  if (!channel) {
    try {
      logger.debug(`Create a channel to ${peer}`)
      channel = await Channel.open(ipfs, peer)
      channel.on('message', _handleMessage)
      logger.debug(`Channel created to ${peer}`)
      onChannelCreated(channel)
    } catch (e) {
      logger.error(e)
    }
  }

  // Wait for the direct channel to be fully connected
  await channel.connect()
  logger.debug(`Connected to ${peer}`)

  // Send the heads if we have any
  const heads = getHeadsForDatabase(getStore(address))
  logger.debug(`Send latest heads of '${address}':\n`, JSON.stringify(heads.map(e => e.hash), null, 2))
  if (heads) {
    await channel.send(JSON.stringify({ address: address, heads: heads }))
  }

  return channel
}

module.exports = exchangeHeads

      };
    };
  }
}, {package:"orbit-db",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/exchange-heads.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-eventstore/src/EventStore.js", {"./EventIndex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-eventstore/src/EventIndex.js","orbit-db-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/src/Store.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-eventstore/src/EventStore.js
      return function (require, module, exports) {
'use strict'

const Store = require('orbit-db-store')
const EventIndex = require('./EventIndex')

// TODO: generalize the Iterator functions and spin to its own module

class EventStore extends Store {
  constructor (ipfs, id, dbname, options = {}) {
    if (options.Index === undefined) Object.assign(options, { Index: EventIndex })
    super(ipfs, id, dbname, options)
    this._type = 'eventlog'
  }

  add (data) {
    return this._addOperation({
      op: 'ADD',
      key: null,
      value: data
    })
  }

  get (hash) {
    return this.iterator({ gte: hash, limit: 1 }).collect()[0]
  }

  iterator (options) {
    const messages = this._query(options)
    let currentIndex = 0
    let iterator = {
      [Symbol.iterator] () {
        return this
      },
      next () {
        let item = { value: null, done: true }
        if (currentIndex < messages.length) {
          item = { value: messages[currentIndex], done: false }
          currentIndex++
        }
        return item
      },
      collect: () => messages
    }

    return iterator
  }

  _query (opts) {
    if (!opts) opts = {}

    const amount = opts.limit ? (opts.limit > -1 ? opts.limit : this._index.get().length) : 1 // Return 1 if no limit is provided
    const events = this._index.get().slice()
    let result = []

    if (opts.gt || opts.gte) {
      // Greater than case
      result = this._read(events, opts.gt ? opts.gt : opts.gte, amount, !!opts.gte)
    } else {
      // Lower than and lastN case, search latest first by reversing the sequence
      result = this._read(events.reverse(), opts.lt ? opts.lt : opts.lte, amount, opts.lte || !opts.lt).reverse()
    }

    return result
  }

  _read (ops, hash, amount, inclusive) {
    // Find the index of the gt/lt hash, or start from the beginning of the array if not found
    const index = ops.map((e) => e.hash).indexOf(hash)
    let startIndex = Math.max(index, 0)
    // If gte/lte is set, we include the given hash, if not, start from the next element
    startIndex += inclusive ? 0 : 1
    // Slice the array to its requested size
    const res = ops.slice(startIndex).slice(0, amount)
    return res
  }
}

module.exports = EventStore

      };
    };
  }
}, {package:"orbit-db-eventstore",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-eventstore/src/EventStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-cache/index-browser.js", {"./Cache":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-cache/Cache.js","level-js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-cache/index-browser.js
      return function (require, module, exports) {
const level = require('level-js')
const Cache = require('./Cache')
module.exports = Cache(level)

      };
    };
  }
}, {package:"orbit-db-cache",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-cache/index-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/index-browser.js", {"./src/keystore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/src/keystore.js","level-js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/index-browser.js
      return function (require, module, exports) {
const level = require('level-js')
const Keystore = require('./src/keystore')
module.exports = Keystore(level)

      };
    };
  }
}, {package:"orbit-db-keystore",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/index-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-ipfs/src/index.js", {"bs58":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bs58/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","mafmt":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/mafmt/src/index.js","multiaddr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js","multibase":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/is-ipfs/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const base58 = require('bs58')
const multihash = require('multihashes')
const multibase = require('multibase')
const Multiaddr = require('multiaddr')
const mafmt = require('mafmt')
const CID = require('cids')

const urlPattern = /^https?:\/\/[^/]+\/(ip(f|n)s)\/((\w+).*)/
const pathPattern = /^\/(ip(f|n)s)\/((\w+).*)/
const defaultProtocolMatch = 1
const defaultHashMath = 4

const fqdnPattern = /^https?:\/\/([^/]+)\.(ip(?:f|n)s)\.[^/]+/
const fqdnHashMatch = 1
const fqdnProtocolMatch = 2

function isMultihash (hash) {
  const formatted = convertToString(hash)
  try {
    const buffer = Buffer.from(base58.decode(formatted))
    multihash.decode(buffer)
    return true
  } catch (e) {
    return false
  }
}

function isMultibase (hash) {
  try {
    return multibase.isEncoded(hash)
  } catch (e) {
    return false
  }
}

function isCID (hash) {
  try {
    new CID(hash) // eslint-disable-line no-new
    return true
  } catch (e) {
    return false
  }
}

function isMultiaddr (input) {
  if (!input) return false
  if (Multiaddr.isMultiaddr(input)) return true
  try {
    new Multiaddr(input) // eslint-disable-line no-new
    return true
  } catch (e) {
    return false
  }
}

function isPeerMultiaddr (input) {
  return isMultiaddr(input) && mafmt.IPFS.matches(input)
}

function isIpfs (input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {
  const formatted = convertToString(input)
  if (!formatted) {
    return false
  }

  const match = formatted.match(pattern)
  if (!match) {
    return false
  }

  if (match[protocolMatch] !== 'ipfs') {
    return false
  }

  let hash = match[hashMatch]

  if (hash && pattern === fqdnPattern) {
    // when doing checks for subdomain context
    // ensure hash is case-insensitive
    // (browsers force-lowercase authority compotent anyway)
    hash = hash.toLowerCase()
  }

  return isCID(hash)
}

function isIpns (input, pattern, protocolMatch = defaultProtocolMatch, hashMatch) {
  const formatted = convertToString(input)
  if (!formatted) {
    return false
  }
  const match = formatted.match(pattern)
  if (!match) {
    return false
  }

  if (match[protocolMatch] !== 'ipns') {
    return false
  }

  if (hashMatch && pattern === fqdnPattern) {
    let hash = match[hashMatch]
    // when doing checks for subdomain context
    // ensure hash is case-insensitive
    // (browsers force-lowercase authority compotent anyway)
    hash = hash.toLowerCase()
    return isCID(hash)
  }

  return true
}

function isString (input) {
  return typeof input === 'string'
}

function convertToString (input) {
  if (Buffer.isBuffer(input)) {
    return base58.encode(input)
  }

  if (isString(input)) {
    return input
  }

  return false
}

const ipfsSubdomain = (url) => isIpfs(url, fqdnPattern, fqdnProtocolMatch, fqdnHashMatch)
const ipnsSubdomain = (url) => isIpns(url, fqdnPattern, fqdnProtocolMatch, fqdnHashMatch)

module.exports = {
  multihash: isMultihash,
  multiaddr: isMultiaddr,
  peerMultiaddr: isPeerMultiaddr,
  cid: isCID,
  base32cid: (cid) => (isMultibase(cid) === 'base32' && isCID(cid)),
  ipfsSubdomain: ipfsSubdomain,
  ipnsSubdomain: ipnsSubdomain,
  subdomain: (url) => (ipfsSubdomain(url) || ipnsSubdomain(url)),
  subdomainPattern: fqdnPattern,
  ipfsUrl: (url) => isIpfs(url, urlPattern),
  ipnsUrl: (url) => isIpns(url, urlPattern),
  url: (url) => (isIpfs(url, urlPattern) || isIpns(url, urlPattern)),
  urlPattern: urlPattern,
  ipfsPath: (path) => isIpfs(path, pathPattern),
  ipnsPath: (path) => isIpns(path, pathPattern),
  path: (path) => (isIpfs(path, pathPattern) || isIpns(path, pathPattern)),
  pathPattern: pathPattern,
  urlOrPath: (x) => (isIpfs(x, urlPattern) || isIpns(x, urlPattern) || isIpfs(x, pathPattern) || isIpns(x, pathPattern)),
  cidPath: path => isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern)
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"is-ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-ipfs/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/merge-options/index.js", {"is-plain-obj":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-plain-obj/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/merge-options/index.js
      return function (require, module, exports) {
'use strict';
const isOptionObject = require('is-plain-obj');

const hasOwnProperty = Object.prototype.hasOwnProperty;
const propIsEnumerable = Object.propertyIsEnumerable;
const defineProperty = (obj, name, value) => Object.defineProperty(obj, name, {
	value,
	writable: true,
	enumerable: true,
	configurable: true
});

const globalThis = this;
const defaultMergeOpts = {
	concatArrays: false
};

const getEnumerableOwnPropertyKeys = value => {
	const keys = [];

	for (const key in value) {
		if (hasOwnProperty.call(value, key)) {
			keys.push(key);
		}
	}

	/* istanbul ignore else  */
	if (Object.getOwnPropertySymbols) {
		const symbols = Object.getOwnPropertySymbols(value);

		for (let i = 0; i < symbols.length; i++) {
			if (propIsEnumerable.call(value, symbols[i])) {
				keys.push(symbols[i]);
			}
		}
	}

	return keys;
};

function clone(value) {
	if (Array.isArray(value)) {
		return cloneArray(value);
	}

	if (isOptionObject(value)) {
		return cloneOptionObject(value);
	}

	return value;
}

function cloneArray(array) {
	const result = array.slice(0, 0);

	getEnumerableOwnPropertyKeys(array).forEach(key => {
		defineProperty(result, key, clone(array[key]));
	});

	return result;
}

function cloneOptionObject(obj) {
	const result = Object.getPrototypeOf(obj) === null ? Object.create(null) : {};

	getEnumerableOwnPropertyKeys(obj).forEach(key => {
		defineProperty(result, key, clone(obj[key]));
	});

	return result;
}

/**
 * @param merged {already cloned}
 * @return {cloned Object}
 */
const mergeKeys = (merged, source, keys, mergeOpts) => {
	keys.forEach(key => {
		// Do not recurse into prototype chain of merged
		if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
			defineProperty(merged, key, merge(merged[key], source[key], mergeOpts));
		} else {
			defineProperty(merged, key, clone(source[key]));
		}
	});

	return merged;
};

/**
 * @param merged {already cloned}
 * @return {cloned Object}
 *
 * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)
 */
const concatArrays = (merged, source, mergeOpts) => {
	let result = merged.slice(0, 0);
	let resultIndex = 0;

	[merged, source].forEach(array => {
		const indices = [];

		// `result.concat(array)` with cloning
		for (let k = 0; k < array.length; k++) {
			if (!hasOwnProperty.call(array, k)) {
				continue;
			}

			indices.push(String(k));

			if (array === merged) {
				// Already cloned
				defineProperty(result, resultIndex++, array[k]);
			} else {
				defineProperty(result, resultIndex++, clone(array[k]));
			}
		}

		// Merge non-index keys
		result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(key => {
			return indices.indexOf(key) === -1;
		}), mergeOpts);
	});

	return result;
};

/**
 * @param merged {already cloned}
 * @return {cloned Object}
 */
function merge(merged, source, mergeOpts) {
	if (mergeOpts.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
		return concatArrays(merged, source, mergeOpts);
	}

	if (!isOptionObject(source) || !isOptionObject(merged)) {
		return clone(source);
	}

	return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), mergeOpts);
}

module.exports = function () {
	const mergeOpts = merge(clone(defaultMergeOpts), (this !== globalThis && this) || {}, defaultMergeOpts);
	let merged = {foobar: {}};

	for (let i = 0; i < arguments.length; i++) {
		const option = arguments[i];

		if (option === undefined) {
			continue;
		}

		if (!isOptionObject(option)) {
			throw new TypeError('`' + option + '` is not an Option Object');
		}

		merged = merge(merged, {foobar: option}, mergeOpts);
	}

	return merged.foobar;
};

      };
    };
  }
}, {package:"merge-options",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/merge-options/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/repo-browser.js", {"ipfs-repo":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/repo-browser.js
      return function (require, module, exports) {
'use strict'

const IPFSRepo = require('ipfs-repo')

module.exports = (dir) => {
  const repoPath = dir || 'ipfs'
  return new IPFSRepo(repoPath)
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/repo-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/mfs-preload.js", {"async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/mfs-preload.js
      return function (require, module, exports) {
'use strict'

const debug = require('debug')
const setImmediate = require('async/setImmediate')
const log = debug('ipfs:mfs-preload')
log.error = debug('ipfs:mfs-preload:error')

module.exports = (self) => {
  const options = self._options.preload || {}
  options.interval = options.interval || 30 * 1000

  if (!options.enabled) {
    log('MFS preload disabled')
    return {
      start: (cb) => setImmediate(cb),
      stop: (cb) => setImmediate(cb)
    }
  }

  let rootCid
  let timeoutId

  const preloadMfs = () => {
    self.files.stat('/', (err, stats) => {
      if (err) {
        timeoutId = setTimeout(preloadMfs, options.interval)
        return log.error('failed to stat MFS root for preload', err)
      }

      if (rootCid !== stats.hash) {
        log(`preloading updated MFS root ${rootCid} -> ${stats.hash}`)

        return self._preload(stats.hash, (err) => {
          timeoutId = setTimeout(preloadMfs, options.interval)
          if (err) return log.error(`failed to preload MFS root ${stats.hash}`, err)
          rootCid = stats.hash
        })
      }

      timeoutId = setTimeout(preloadMfs, options.interval)
    })
  }

  return {
    start (cb) {
      self.files.stat('/', (err, stats) => {
        if (err) return cb(err)
        rootCid = stats.hash
        log(`monitoring MFS root ${rootCid}`)
        timeoutId = setTimeout(preloadMfs, options.interval)
        cb()
      })
    },
    stop (cb) {
      clearTimeout(timeoutId)
      cb()
    }
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/mfs-preload.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-book/src/index.js", {"../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","bs58":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bs58/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","peer-info":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-book/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const bs58 = require('bs58')
const PeerId = require('peer-id')
const PeerInfo = require('peer-info')

function getB58Str (peer) {
  let b58Str

  if (typeof peer === 'string') {
    b58Str = peer
  } else if (Buffer.isBuffer(peer)) {
    b58Str = bs58.encode(peer).toString()
  } else if (PeerId.isPeerId(peer)) {
    b58Str = peer.toB58String()
  } else if (PeerInfo.isPeerInfo(peer)) {
    b58Str = peer.id.toB58String()
  } else {
    throw new Error('not valid PeerId or PeerInfo, or B58Str')
  }

  return b58Str
}

class PeerBook {
  constructor () {
    this._peers = {}
  }

  // checks if peer exists
  // peer can be PeerId, b58String or PeerInfo
  has (peer) {
    const b58Str = getB58Str(peer)
    return Boolean(this._peers[b58Str])
  }

  /**
   * Stores a peerInfo, if already exist, merges the new into the old.
   *
   * @param {PeerInfo} peerInfo
   * @param {Boolean} replace
   * @returns {PeerInfo}
   */
  put (peerInfo, replace) {
    const localPeerInfo = this._peers[peerInfo.id.toB58String()]

    // insert if doesn't exist or replace if replace flag is true
    if (!localPeerInfo || replace) {
      this._peers[peerInfo.id.toB58String()] = peerInfo
      return peerInfo
    }

    // peerInfo.replace merges by default if none to replace are passed
    peerInfo.multiaddrs.forEach((ma) => localPeerInfo.multiaddrs.add(ma))

    // pass active connection state
    const ma = peerInfo.isConnected()
    if (ma) {
      localPeerInfo.connect(ma)
    }

    // pass known protocols
    peerInfo.protocols.forEach((p) => localPeerInfo.protocols.add(p))

    if (!localPeerInfo.id.privKey && peerInfo.id.privKey) {
      localPeerInfo.id.privKey = peerInfo.id.privKey
    }

    if (!localPeerInfo.id.pubKey && peerInfo.id.pubKey) {
      localPeerInfo.id.pubKey = peerInfo.id.pubKey
    }

    return localPeerInfo
  }

  /**
   * Get the info to the given PeerId, PeerInfo or b58Str id
   *
   * @param {PeerId} peer
   * @returns {PeerInfo}
   */
  get (peer) {
    const b58Str = getB58Str(peer)

    const peerInfo = this._peers[b58Str]

    if (peerInfo) {
      return peerInfo
    }
    throw new Error('PeerInfo not found')
  }

  getAll () {
    return this._peers
  }

  getAllArray () {
    return Object.keys(this._peers).map((b58Str) => this._peers[b58Str])
  }

  getMultiaddrs (peer) {
    const info = this.get(peer)
    return info.multiaddrs.toArray()
  }

  remove (peer) {
    const b58Str = getB58Str(peer)

    if (this._peers[b58Str]) {
      delete this._peers[b58Str]
    }
  }
}

module.exports = PeerBook

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

      };
    };
  }
}, {package:"peer-book",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-book/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-block-service/src/index.js", {"async/map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/map.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-block-service/src/index.js
      return function (require, module, exports) {
'use strict'

const asyncMap = require('async/map')

/**
 * BlockService is a hybrid block datastore. It stores data in a local
 * datastore and may retrieve data from a remote Exchange.
 * It uses an internal `datastore.Datastore` instance to store values.
 */
class BlockService {
  /**
   * Create a new BlockService
   *
   * @param {IPFSRepo} ipfsRepo
   */
  constructor (ipfsRepo) {
    this._repo = ipfsRepo
    this._bitswap = null
  }

  /**
   * Add a bitswap instance that communicates with the
   * network to retreive blocks that are not in the local store.
   *
   * If the node is online all requests for blocks first
   * check locally and afterwards ask the network for the blocks.
   *
   * @param {Bitswap} bitswap
   * @returns {void}
   */
  setExchange (bitswap) {
    this._bitswap = bitswap
  }

  /**
   * Go offline, i.e. drop the reference to bitswap.
   *
   * @returns {void}
   */
  unsetExchange () {
    this._bitswap = null
  }

  /**
   * Is the blockservice online, i.e. is bitswap present.
   *
   * @returns {bool}
   */
  hasExchange () {
    return this._bitswap != null
  }

  /**
   * Put a block to the underlying datastore.
   *
   * @param {Block} block
   * @param {function(Error)} callback
   * @returns {void}
   */
  put (block, callback) {
    if (this.hasExchange()) {
      this._bitswap.put(block, callback)
    } else {
      this._repo.blocks.put(block, callback)
    }
  }

  /**
   * Put a multiple blocks to the underlying datastore.
   *
   * @param {Array<Block>} blocks
   * @param {function(Error)} callback
   * @returns {void}
   */
  putMany (blocks, callback) {
    if (this.hasExchange()) {
      this._bitswap.putMany(blocks, callback)
    } else {
      this._repo.blocks.putMany(blocks, callback)
    }
  }

  /**
   * Get a block by cid.
   *
   * @param {CID} cid
   * @param {function(Error, Block)} callback
   * @returns {void}
   */
  get (cid, callback) {
    if (this.hasExchange()) {
      this._bitswap.get(cid, callback)
    } else {
      this._repo.blocks.get(cid, callback)
    }
  }

  /**
   * Get multiple blocks back from an array of cids.
   *
   * @param {Array<CID>} cids
   * @param {function(Error, Block)} callback
   * @returns {void}
   */
  getMany (cids, callback) {
    if (!Array.isArray(cids)) {
      callback(new Error('first arg must be an array of cids'))
    } else if (this.hasExchange()) {
      this._bitswap.getMany(cids, callback)
    } else {
      asyncMap(cids, (cid, cb) => this._repo.blocks.get(cid, cb), callback)
    }
  }

  /**
   * Delete a block from the blockstore.
   *
   * @param {CID} cid
   * @param {function(Error)} callback
   * @return {void}
   */
  delete (cid, callback) {
    this._repo.blocks.delete(cid, callback)
  }
}

module.exports = BlockService

      };
    };
  }
}, {package:"ipfs-block-service",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-block-service/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/state.js", {"debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","fsm-event":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fsm-event/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/state.js
      return function (require, module, exports) {
'use strict'

const debug = require('debug')
const log = debug('ipfs:state')
log.error = debug('ipfs:state:error')

const fsm = require('fsm-event')

module.exports = (self) => {
  const s = fsm('uninitialized', {
    uninitialized: {
      init: 'initializing',
      initialized: 'stopped'
    },
    initializing: {
      initialized: 'stopped'
    },
    stopped: {
      start: 'starting'
    },
    starting: {
      started: 'running'
    },
    running: {
      stop: 'stopping'
    },
    stopping: {
      stopped: 'stopped'
    }
  })

  // log events
  s.on('error', (err) => log.error(err))
  s.on('done', () => log('-> ' + s._state))

  // -- Actions

  s.init = () => {
    s('init')
  }

  s.initialized = () => {
    s('initialized')
  }

  s.stop = () => {
    s('stop')
  }

  s.stopped = () => {
    s('stopped')
  }

  s.start = () => {
    s('start')
  }

  s.started = () => {
    s('started')
  }

  s.state = () => s._state

  return s
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/state.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/index.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/constants.js","./name-table":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/name-table.js","./print":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/print.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/util.js","./varint-table":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/varint-table.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/**
 * Implementation of the multicodec specification.
 *
 * @module multicodec
 * @example
 * const multicodec = require('multicodec')
 *
 * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)
 * // prefixedProtobuf 0x50...
 *
 */
'use strict'

const varint = require('varint')
const codecNameToCodeVarint = require('./varint-table')
const codeToCodecName = require('./name-table')
const util = require('./util')

exports = module.exports

/**
 * Prefix a buffer with a multicodec-packed.
 *
 * @param {string|number} multicodecStrOrCode
 * @param {Buffer} data
 * @returns {Buffer}
 */
exports.addPrefix = (multicodecStrOrCode, data) => {
  let prefix

  if (Buffer.isBuffer(multicodecStrOrCode)) {
    prefix = util.varintBufferEncode(multicodecStrOrCode)
  } else {
    if (codecNameToCodeVarint[multicodecStrOrCode]) {
      prefix = codecNameToCodeVarint[multicodecStrOrCode]
    } else {
      throw new Error('multicodec not recognized')
    }
  }
  return Buffer.concat([prefix, data])
}

/**
 * Decapsulate the multicodec-packed prefix from the data.
 *
 * @param {Buffer} data
 * @returns {Buffer}
 */
exports.rmPrefix = (data) => {
  varint.decode(data)
  return data.slice(varint.decode.bytes)
}

/**
 * Get the codec of the prefixed data.
 * @param {Buffer} prefixedData
 * @returns {string}
 */
exports.getCodec = (prefixedData) => {
  const code = util.varintBufferDecode(prefixedData)
  const codecName = codeToCodecName[code.toString('hex')]
  if (codecName === undefined) {
    throw new Error('Code `0x' + code.toString('hex') + '` not found')
  }
  return codecName
}

/**
 * Get the name of the codec.
 * @param {number} codec
 * @returns {string}
 */
exports.getName = (codec) => {
  return codeToCodecName[codec.toString(16)]
}

/**
 * Get the code of the codec
 * @param {string} name
 * @returns {number}
 */
exports.getNumber = (name) => {
  const code = codecNameToCodeVarint[name]
  if (code === undefined) {
    throw new Error('Codec `' + name + '` not found')
  }
  return util.varintBufferDecode(code)[0]
}

/**
 * Get the code of the prefixed data.
 * @param {Buffer} prefixedData
 * @returns {number}
 */
exports.getCode = (prefixedData) => {
  return varint.decode(prefixedData)
}

/**
 * Get the code as varint of a codec name.
 * @param {string} codecName
 * @returns {Buffer}
 */
exports.getCodeVarint = (codecName) => {
  const code = codecNameToCodeVarint[codecName]
  if (code === undefined) {
    throw new Error('Codec `' + codecName + '` not found')
  }
  return code
}

/**
 * Get the varint of a code.
 * @param {Number} code
 * @returns {Array.<number>}
 */
exports.getVarint = (code) => {
  return varint.encode(code)
}

// Make the constants top-level constants
const constants = require('./constants')
Object.assign(exports, constants)

// Human friendly names for printing, e.g. in error messages
exports.print = require('./print')

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multicodec",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js", {"./cid-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/cid-util.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","class-is":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/class-is/index.js","multibase":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/index.js","multicodec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/index.js","multicodec/src/base-table":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/base-table.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const mh = require('multihashes')
const multibase = require('multibase')
const multicodec = require('multicodec')
const codecs = require('multicodec/src/base-table')
const CIDUtil = require('./cid-util')
const withIs = require('class-is')

/**
 * @typedef {Object} SerializedCID
 * @param {string} codec
 * @param {number} version
 * @param {Buffer} multihash
 */

/**
 * Test if the given input is a CID.
 * @function isCID
 * @memberof CID
 * @static
 * @param {any} other
 * @returns {bool}
 */

/**
 * Class representing a CID `<mbase><version><mcodec><mhash>`
 * , as defined in [ipld/cid](https://github.com/multiformats/cid).
 * @class CID
 */
class CID {
  /**
   * Create a new CID.
   *
   * The algorithm for argument input is roughly:
   * ```
   * if (cid)
   *   -> create a copy
   * else if (str)
   *   if (1st char is on multibase table) -> CID String
   *   else -> bs58 encoded multihash
   * else if (Buffer)
   *   if (1st byte is 0 or 1) -> CID
   *   else -> multihash
   * else if (Number)
   *   -> construct CID by parts
   * ```
   *
   * @param {string|Buffer|CID} version
   * @param {string} [codec]
   * @param {Buffer} [multihash]
   * @param {string} [multibaseName]
   *
   * @example
   * new CID(<version>, <codec>, <multihash>, <multibaseName>)
   * new CID(<cidStr>)
   * new CID(<cid.buffer>)
   * new CID(<multihash>)
   * new CID(<bs58 encoded multihash>)
   * new CID(<cid>)
   */
  constructor (version, codec, multihash, multibaseName) {
    if (_CID.isCID(version)) {
      // version is an exising CID instance
      const cid = version
      this.version = cid.version
      this.codec = cid.codec
      this.multihash = Buffer.from(cid.multihash)
      // Default guard for when a CID < 0.7 is passed with no multibaseName
      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32')
      return
    }

    if (typeof version === 'string') {
      // e.g. 'base32' or false
      const baseName = multibase.isEncoded(version)
      if (baseName) {
        // version is a CID String encoded with multibase, so v1
        const cid = multibase.decode(version)
        this.version = parseInt(cid.slice(0, 1).toString('hex'), 16)
        this.codec = multicodec.getCodec(cid.slice(1))
        this.multihash = multicodec.rmPrefix(cid.slice(1))
        this.multibaseName = baseName
      } else {
        // version is a base58btc string multihash, so v0
        this.version = 0
        this.codec = 'dag-pb'
        this.multihash = mh.fromB58String(version)
        this.multibaseName = 'base58btc'
      }
      CID.validateCID(this)
      Object.defineProperty(this, 'string', { value: version })
      return
    }

    if (Buffer.isBuffer(version)) {
      const firstByte = version.slice(0, 1)
      const v = parseInt(firstByte.toString('hex'), 16)
      if (v === 1) {
        // version is a CID buffer
        const cid = version
        this.version = v
        this.codec = multicodec.getCodec(cid.slice(1))
        this.multihash = multicodec.rmPrefix(cid.slice(1))
        this.multibaseName = 'base32'
      } else {
        // version is a raw multihash buffer, so v0
        this.version = 0
        this.codec = 'dag-pb'
        this.multihash = version
        this.multibaseName = 'base58btc'
      }
      CID.validateCID(this)
      return
    }

    // otherwise, assemble the CID from the parameters

    /**
     * @type {number}
     */
    this.version = version

    /**
     * @type {string}
     */
    this.codec = codec

    /**
     * @type {Buffer}
     */
    this.multihash = multihash

    /**
     * @type {string}
     */
    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32')

    CID.validateCID(this)
  }

  /**
   * The CID as a `Buffer`
   *
   * @return {Buffer}
   * @readonly
   *
   * @memberOf CID
   */
  get buffer () {
    let buffer = this._buffer

    if (!buffer) {
      if (this.version === 0) {
        buffer = this.multihash
      } else if (this.version === 1) {
        buffer = Buffer.concat([
          Buffer.from('01', 'hex'),
          multicodec.getCodeVarint(this.codec),
          this.multihash
        ])
      } else {
        throw new Error('unsupported version')
      }

      // Cache this buffer so it doesn't have to be recreated
      Object.defineProperty(this, '_buffer', { value: buffer })
    }

    return buffer
  }

  /**
   * Get the prefix of the CID.
   *
   * @returns {Buffer}
   * @readonly
   */
  get prefix () {
    return Buffer.concat([
      Buffer.from(`0${this.version}`, 'hex'),
      multicodec.getCodeVarint(this.codec),
      mh.prefix(this.multihash)
    ])
  }

  /**
   * Convert to a CID of version `0`.
   *
   * @returns {CID}
   */
  toV0 () {
    if (this.codec !== 'dag-pb') {
      throw new Error('Cannot convert a non dag-pb CID to CIDv0')
    }

    const { name, length } = mh.decode(this.multihash)

    if (name !== 'sha2-256') {
      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')
    }

    if (length !== 32) {
      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0')
    }

    return new _CID(0, this.codec, this.multihash)
  }

  /**
   * Convert to a CID of version `1`.
   *
   * @returns {CID}
   */
  toV1 () {
    return new _CID(1, this.codec, this.multihash)
  }

  /**
   * Encode the CID into a string.
   *
   * @param {string} [base=this.multibaseName] - Base encoding to use.
   * @returns {string}
   */
  toBaseEncodedString (base = this.multibaseName) {
    if (this.string && base === this.multibaseName) {
      return this.string
    }
    let str = null
    if (this.version === 0) {
      if (base !== 'base58btc') {
        throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()')
      }
      str = mh.toB58String(this.multihash)
    } else if (this.version === 1) {
      str = multibase.encode(base, this.buffer).toString()
    } else {
      throw new Error('unsupported version')
    }
    if (base === this.multibaseName) {
      // cache the string value
      Object.defineProperty(this, 'string', { value: str })
    }
    return str
  }

  toString (base) {
    return this.toBaseEncodedString(base)
  }

  /**
   * Serialize to a plain object.
   *
   * @returns {SerializedCID}
   */
  toJSON () {
    return {
      codec: this.codec,
      version: this.version,
      hash: this.multihash
    }
  }

  /**
   * Compare equality with another CID.
   *
   * @param {CID} other
   * @returns {bool}
   */
  equals (other) {
    return this.codec === other.codec &&
      this.version === other.version &&
      this.multihash.equals(other.multihash)
  }

  /**
   * Test if the given input is a valid CID object.
   * Throws if it is not.
   *
   * @param {any} other
   * @returns {void}
   */
  static validateCID (other) {
    let errorMsg = CIDUtil.checkCIDComponents(other)
    if (errorMsg) {
      throw new Error(errorMsg)
    }
  }
}

const _CID = withIs(CID, {
  className: 'CID',
  symbolName: '@ipld/js-cid/CID'
})

_CID.codecs = codecs

module.exports = _CID

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"cids",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/index.js", {"./multiaddr-set":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/multiaddr-set.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/utils.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/index.js
      return function (require, module, exports) {
'use strict'

const PeerId = require('peer-id')
const { ensureMultiaddr } = require('./utils')
const MultiaddrSet = require('./multiaddr-set')
const assert = require('assert')

// Peer represents a peer on the IPFS network
class PeerInfo {
  constructor (peerId) {
    assert(peerId, 'Missing peerId. Use Peer.create(cb) to create one')

    this.id = peerId
    this.multiaddrs = new MultiaddrSet()
    this.protocols = new Set()
    this._connectedMultiaddr = undefined
  }

  // only stores the current multiaddr being used
  connect (ma) {
    ma = ensureMultiaddr(ma)
    if (!this.multiaddrs.has(ma) && ma.toString() !== `/ipfs/${this.id.toB58String()}`) {
      throw new Error('can\'t be connected to missing multiaddr from set')
    }
    this._connectedMultiaddr = ma
  }

  disconnect () {
    this._connectedMultiaddr = undefined
  }

  isConnected () {
    return this._connectedMultiaddr
  }
}

PeerInfo.create = (peerId, callback) => {
  if (typeof peerId === 'function') {
    callback = peerId
    peerId = null

    PeerId.create((err, id) => {
      if (err) {
        return callback(err)
      }

      callback(null, new PeerInfo(id))
    })
    return
  }

  // Already a PeerId instance
  if (typeof peerId.toJSON === 'function') {
    callback(null, new PeerInfo(peerId))
  } else {
    PeerId.createFromJSON(peerId, (err, id) => callback(err, new PeerInfo(id)))
  }
}

PeerInfo.isPeerInfo = (peerInfo) => {
  return Boolean(typeof peerInfo === 'object' &&
    peerInfo.id &&
    peerInfo.multiaddrs)
}

module.exports = PeerInfo

      };
    };
  }
}, {package:"peer-info",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/config.js", {"mafmt":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/mafmt/src/index.js","multiaddr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js","superstruct":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/superstruct/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/config.js
      return function (require, module, exports) {
'use strict'

const Multiaddr = require('multiaddr')
const mafmt = require('mafmt')
const { struct, superstruct } = require('superstruct')

const { optional, union } = struct
const s = superstruct({
  types: {
    multiaddr: v => {
      if (v === null) {
        return `multiaddr invalid, value must be a string, Buffer, or another Multiaddr got ${v}`
      }

      try {
        Multiaddr(v)
      } catch (err) {
        return `multiaddr invalid, ${err.message}`
      }

      return true
    },
    'multiaddr-ipfs': v => mafmt.IPFS.matches(v) ? true : `multiaddr IPFS invalid`
  }
})

const configSchema = s({
  repo: optional(s('object|string')),
  repoOwner: 'boolean?',
  preload: s({
    enabled: 'boolean?',
    addresses: optional(s(['multiaddr'])),
    interval: 'number?'
  }, { enabled: true, interval: 30 * 1000 }),
  init: optional(union(['boolean', s({
    bits: 'number?',
    emptyRepo: 'boolean?',
    privateKey: optional(s('object|string')), // object should be a custom type for PeerId using 'kind-of'
    pass: 'string?'
  })])),
  start: 'boolean?',
  offline: 'boolean?',
  pass: 'string?',
  silent: 'boolean?',
  relay: 'object?', // relay validates in libp2p
  EXPERIMENTAL: optional(s({
    pubsub: 'boolean?',
    ipnsPubsub: 'boolean?',
    sharding: 'boolean?',
    dht: 'boolean?'
  })),
  connectionManager: 'object?',
  config: optional(s({
    API: 'object?',
    Addresses: optional(s({
      Swarm: optional(s(['multiaddr'])),
      API: 'multiaddr?',
      Gateway: 'multiaddr'
    })),
    Discovery: optional(s({
      MDNS: optional(s({
        Enabled: 'boolean?',
        Interval: 'number?'
      })),
      webRTCStar: optional(s({
        Enabled: 'boolean?'
      }))
    })),
    Bootstrap: optional(s(['multiaddr-ipfs']))
  })),
  ipld: 'object?',
  libp2p: optional(union(['function', 'object'])) // libp2p validates this
}, {
  repoOwner: true
})

const validate = (opts) => {
  const [err, options] = configSchema.validate(opts)

  if (err) {
    throw err
  }

  return options
}

module.exports = { validate }

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/config.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js", {"assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","class-is":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/class-is/index.js","libp2p-crypto/src/keys":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/*
 * Id is an object representation of a peer Id. a peer Id is a multihash
 */

'use strict'

const mh = require('multihashes')
const cryptoKeys = require('libp2p-crypto/src/keys')
const assert = require('assert')
const waterfall = require('async/waterfall')
const withIs = require('class-is')

class PeerId {
  constructor (id, privKey, pubKey) {
    assert(Buffer.isBuffer(id), 'invalid id provided')

    if (privKey && pubKey) {
      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments')
    }

    this._id = id
    this._idB58String = mh.toB58String(this.id)
    this._privKey = privKey
    this._pubKey = pubKey
  }

  get id () {
    return this._id
  }

  set id (val) {
    throw new Error('Id is immutable')
  }

  get privKey () {
    return this._privKey
  }

  set privKey (privKey) {
    this._privKey = privKey
  }

  get pubKey () {
    if (this._pubKey) {
      return this._pubKey
    }

    if (this._privKey) {
      return this._privKey.public
    }
  }

  set pubKey (pubKey) {
    this._pubKey = pubKey
  }

  // Return the protobuf version of the public key, matching go ipfs formatting
  marshalPubKey () {
    if (this.pubKey) {
      return cryptoKeys.marshalPublicKey(this.pubKey)
    }
  }

  // Return the protobuf version of the private key, matching go ipfs formatting
  marshalPrivKey () {
    if (this.privKey) {
      return cryptoKeys.marshalPrivateKey(this.privKey)
    }
  }

  toPrint () {
    let pid = this.toB58String()
    // All sha256 nodes start with Qm
    // We can skip the Qm to make the peer.ID more useful
    if (pid.startsWith('Qm')) {
      pid = pid.slice(2)
    }
    let maxRunes = 6
    if (pid.length < maxRunes) {
      maxRunes = pid.length
    }

    return '<peer.ID ' + pid.substr(0, maxRunes) + '>'
  }

  // return the jsonified version of the key, matching the formatting
  // of go-ipfs for its config file
  toJSON () {
    return {
      id: this.toB58String(),
      privKey: toB64Opt(this.marshalPrivKey()),
      pubKey: toB64Opt(this.marshalPubKey())
    }
  }

  // encode/decode functions
  toHexString () {
    return mh.toHexString(this.id)
  }

  toBytes () {
    return this.id
  }

  toB58String () {
    return this._idB58String
  }

  isEqual (id) {
    if (Buffer.isBuffer(id)) {
      return this.id.equals(id)
    } else if (id.id) {
      return this.id.equals(id.id)
    } else {
      throw new Error('not valid Id')
    }
  }

  /*
   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)
   */
  isValid (callback) {
    // TODO Needs better checking
    if (this.privKey &&
      this.privKey.public &&
      this.privKey.public.bytes &&
      Buffer.isBuffer(this.pubKey.bytes) &&
      this.privKey.public.bytes.equals(this.pubKey.bytes)) {
      callback()
    } else {
      callback(new Error('Keys not match'))
    }
  }
}

const PeerIdWithIs = withIs(PeerId, { className: 'PeerId', symbolName: '@libp2p/js-peer-id/PeerId' })

exports = module.exports = PeerIdWithIs

const computeDigest = (pubKey, cb) => {
  if (pubKey.bytes.length <= 42) {
    const digest = mh.encode(pubKey.bytes, 'identity')
    cb(null, digest)
  } else {
    pubKey.hash((err, digest) => {
      cb(err, digest)
    })
  }
}

const computePeerId = (privKey, pubKey, cb) => {
  computeDigest(pubKey, (err, digest) => {
    if (err != null) {
      cb(err)
    } else {
      cb(null, new PeerIdWithIs(digest, privKey, pubKey))
    }
  })
}

// generation
exports.create = function (opts, callback) {
  if (typeof opts === 'function') {
    callback = opts
    opts = {}
  }
  opts = opts || {}
  opts.bits = opts.bits || 2048
  opts.keyType = opts.keyType || 'RSA'

  cryptoKeys.generateKeyPair(opts.keyType, opts.bits, (err, privKey) => {
    if (err != null) {
      callback(err)
    } else {
      computePeerId(privKey, privKey.public, callback)
    }
  })
}

exports.createFromHexString = function (str) {
  return new PeerIdWithIs(mh.fromHexString(str))
}

exports.createFromBytes = function (buf) {
  return new PeerIdWithIs(buf)
}

exports.createFromB58String = function (str) {
  return new PeerIdWithIs(mh.fromB58String(str))
}

// Public Key input will be a buffer
exports.createFromPubKey = function (key, callback) {
  if (typeof callback !== 'function') {
    throw new Error('callback is required')
  }

  let pubKey

  try {
    let buf = key
    if (typeof buf === 'string') {
      buf = Buffer.from(key, 'base64')
    }

    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')

    pubKey = cryptoKeys.unmarshalPublicKey(buf)
  } catch (err) {
    return callback(err)
  }

  computePeerId(null, pubKey, callback)
}

// Private key input will be a string
exports.createFromPrivKey = function (key, callback) {
  if (typeof callback !== 'function') {
    throw new Error('callback is required')
  }

  let buf = key

  try {
    if (typeof buf === 'string') {
      buf = Buffer.from(key, 'base64')
    }

    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')
  } catch (err) {
    return callback(err)
  }

  cryptoKeys.unmarshalPrivateKey(buf, (err, privKey) => {
    if (err != null) {
      callback(err)
    } else {
      computePeerId(privKey, privKey.public, callback)
    }
  })
}

exports.createFromJSON = function (obj, callback) {
  if (typeof callback !== 'function') {
    throw new Error('callback is required')
  }

  let id
  let rawPrivKey
  let rawPubKey
  let pub

  try {
    id = mh.fromB58String(obj.id)
    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64')
    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64')
    pub = rawPubKey && cryptoKeys.unmarshalPublicKey(rawPubKey)
  } catch (err) {
    return callback(err)
  }

  if (!rawPrivKey) {
    callback(null, new PeerIdWithIs(id, null, pub))
    return
  }

  waterfall([
    (cb) => cryptoKeys.unmarshalPrivateKey(rawPrivKey, cb),
    (priv, cb) => {
      computeDigest(priv.public, (err, digest) => {
        cb(err, digest, priv)
      })
    },
    (privDigest, priv, cb) => {
      if (pub) {
        computeDigest(pub, (err, pubDigest) => {
          cb(err, privDigest, priv, pubDigest)
        })
      } else {
        cb(null, privDigest, priv)
      }
    }
  ], (err, privDigest, priv, pubDigest) => {
    if (err) {
      return callback(err)
    }

    if (pub && !privDigest.equals(pubDigest)) {
      return callback(new Error('Public and private key do not match'))
    }

    if (id && !privDigest.equals(id)) {
      return callback(new Error('Id and private key do not match'))
    }

    callback(null, new PeerIdWithIs(id, priv, pub))
  })
}

exports.isPeerId = function (peerId) {
  return Boolean(typeof peerId === 'object' &&
    peerId._id &&
    peerId._idB58String)
}

function toB64Opt (val) {
  if (val) {
    return val.toString('base64')
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"peer-id",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/preload.js", {"./runtime/preload-nodejs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/preload-browser.js","async/retry":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/retry.js","async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","multiaddr-to-uri":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr-to-uri/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/preload.js
      return function (require, module, exports) {
'use strict'

const setImmediate = require('async/setImmediate')
const retry = require('async/retry')
const toUri = require('multiaddr-to-uri')
const debug = require('debug')
const CID = require('cids')
const preload = require('./runtime/preload-nodejs')

const log = debug('ipfs:preload')
log.error = debug('ipfs:preload:error')

const noop = (err) => { if (err) log.error(err) }

module.exports = self => {
  const options = self._options.preload || {}
  options.enabled = Boolean(options.enabled)
  options.addresses = options.addresses || []

  if (!options.enabled || !options.addresses.length) {
    log('preload disabled')
    const api = (_, callback) => {
      if (callback) {
        setImmediate(() => callback())
      }
    }
    api.start = () => {}
    api.stop = () => {}
    return api
  }

  let stopped = true
  let requests = []
  const apiUris = options.addresses.map(apiAddrToUri)

  const api = (cid, callback) => {
    callback = callback || noop

    if (typeof cid !== 'string') {
      try {
        cid = new CID(cid).toBaseEncodedString()
      } catch (err) {
        return setImmediate(() => callback(err))
      }
    }

    const fallbackApiUris = Array.from(apiUris)
    let request
    const now = Date.now()

    retry({ times: fallbackApiUris.length }, (cb) => {
      if (stopped) return cb(new Error(`preload aborted for ${cid}`))

      // Remove failed request from a previous attempt
      requests = requests.filter(r => r !== request)

      const apiUri = fallbackApiUris.shift()

      request = preload(`${apiUri}/api/v0/refs?r=true&arg=${cid}`, cb)
      requests = requests.concat(request)
    }, (err) => {
      requests = requests.filter(r => r !== request)

      if (err) {
        return callback(err)
      }

      log(`preloaded ${cid} in ${Date.now() - now}ms`)
      callback()
    })
  }

  api.start = () => {
    stopped = false
  }

  api.stop = () => {
    stopped = true
    log(`canceling ${requests.length} pending preload request(s)`)
    requests.forEach(r => r.cancel())
    requests = []
  }

  return api
}

function apiAddrToUri (addr) {
  if (!(addr.endsWith('http') || addr.endsWith('https'))) {
    addr = addr + '/http'
  }
  return toUri(addr)
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/preload.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld/src/index.js", {"../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld/src/util.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","ipfs-block":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-block/src/index.js","ipld-dag-cbor":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-cbor/src/index.js","ipld-dag-pb":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/index.js","ipld-raw":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-raw/src/index.js","merge-options":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/merge-options/index.js","multicodec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js","typical":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/typical/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const Block = require('ipfs-block')
const CID = require('cids')
const mergeOptions = require('merge-options')
const ipldDagCbor = require('ipld-dag-cbor')
const ipldDagPb = require('ipld-dag-pb')
const ipldRaw = require('ipld-raw')
const multicodec = require('multicodec')
const promisify = require('promisify-es6')
const typical = require('typical')
const { extendIterator } = require('./util')

class IPLDResolver {
  constructor (userOptions) {
    const options = mergeOptions(IPLDResolver.defaultOptions, userOptions)

    if (!options.blockService) {
      throw new Error('Missing blockservice')
    }
    this.bs = options.blockService

    // Object with current list of active resolvers
    this.resolvers = {}

    if (typeof options.loadFormat !== 'function') {
      this.loadFormat = async (codec) => {
        const codecName = multicodec.print[codec]
        throw new Error(`No resolver found for codec "${codecName}"`)
      }
    } else {
      this.loadFormat = options.loadFormat
    }

    // Enable all supplied formats
    for (const format of options.formats) {
      this.addFormat(format)
    }
  }

  /**
   * Add support for an IPLD Format.
   *
   * @param {Object} format - The implementation of an IPLD Format.
   * @returns {this}
   */
  addFormat (format) {
    const codec = format.codec
    if (this.resolvers[format.format]) {
      const codecName = multicodec.print[codec]
      throw new Error(`Resolver already exists for codec "${codecName}"`)
    }

    this.resolvers[codec] = format

    return this
  }

  /**
   * Remove support for an IPLD Format.
   *
   * @param {number} codec - The codec of the IPLD Format to remove.
   * @returns {this}
   */
  removeFormat (codec) {
    if (this.resolvers[codec]) {
      delete this.resolvers[codec]
    }

    return this
  }

  /**
   * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.
   *
   * @param {CID} cid - the CID the resolving starts.
   * @param {string} path - the path that should be resolved.
   * @returns {Iterable.<Promise.<{remainderPath: string, value}>>} - Returns an async iterator of all the IPLD Nodes that were traversed during the path resolving. Every element is an object with these fields:
   *   - `remainderPath`: the part of the path that wasn’t resolved yet.
   *   - `value`: the value where the resolved path points to. If further traversing is possible, then the value is a CID object linking to another IPLD Node. If it was possible to fully resolve the path, value is the value the path points to. So if you need the CID of the IPLD Node you’re currently at, just take the value of the previously returned IPLD Node.
   */
  resolve (cid, path) {
    if (!CID.isCID(cid)) {
      throw new Error('`cid` argument must be a CID')
    }
    if (typeof path !== 'string') {
      throw new Error('`path` argument must be a string')
    }

    const generator = async function * () {
      // End iteration if there isn't a CID to follow anymore
      while (cid !== null) {
        const format = await this._getFormat(cid.codec)

        // get block
        // use local resolver
        // update path value
        const block = await promisify(this.bs.get.bind(this.bs))(cid)
        const result = format.resolver.resolve(block.data, path)

        // Prepare for the next iteration if there is a `remainderPath`
        path = result.remainderPath
        let value = result.value
        // NOTE vmx 2018-11-29: Not all IPLD Formats return links as
        // CIDs yet. Hence try to convert old style links to CIDs
        if (Object.keys(value).length === 1 && '/' in value) {
          try {
            value = new CID(value['/'])
          } catch (_error) {
            value = null
          }
        }
        cid = CID.isCID(value) ? value : null

        yield {
          remainderPath: path,
          value
        }
      }
    }.bind(this)

    return extendIterator(generator())
  }

  /**
   * Get a node by CID.
   *
   * @param {CID} cid - The CID of the IPLD Node that should be retrieved.
   * @returns {Promise.<Object>} - Returns a Promise with the IPLD Node that correspond to the given `cid`.
   */
  async get (cid) {
    const block = await promisify(this.bs.get.bind(this.bs))(cid)
    const format = await this._getFormat(block.cid.codec)
    const node = format.util.deserialize(block.data)

    return node
  }

  /**
   * Get multiple nodes back from an array of CIDs.
   *
   * @param {Iterable.<CID>} cids - The CIDs of the IPLD Nodes that should be retrieved.
   * @returns {Iterable.<Promise.<Object>>} - Returns an async iterator with the IPLD Nodes that correspond to the given `cids`.
   */
  getMany (cids) {
    if (!typical.isIterable(cids) || typeof cids === 'string' ||
        Buffer.isBuffer(cids)) {
      throw new Error('`cids` must be an iterable of CIDs')
    }

    const generator = async function * () {
      for await (const cid of cids) {
        yield this.get(cid)
      }
    }.bind(this)

    return extendIterator(generator())
  }

  /**
   * Stores the given IPLD Node of a recognized IPLD Format.
   *
   * @param {Object} node - The deserialized IPLD node that should be inserted.
   * @param {number} format - The multicodec of the format that IPLD Node should be encoded in.
   * @param {Object} [userOptions] -  Options is an object with the following properties.
   * @param {number} [userOtions.hashAlg=hash algorithm of the given multicodec] - The hashing algorithm that is used to calculate the CID.
   * @param {number} [userOptions.cidVersion=1] - The CID version to use.
   * @param {boolean} [userOptions.onlyHash=false] - If true the serialized form of the IPLD Node will not be passed to the underlying block store.
   * @returns {Promise.<CID>} - Returns the CID of the serialized IPLD Nodes.
   */
  async put (node, format, userOptions) {
    if (format === undefined) {
      throw new Error('`put` requires a format')
    }
    if (typeof format !== 'number') {
      throw new Error('`format` parameter must be number (multicodec)')
    }

    const formatImpl = await this._getFormat(format)
    const defaultOptions = {
      hashAlg: formatImpl.defaultHashAlg,
      cidVersion: 1,
      onlyHash: false
    }
    const options = mergeOptions(defaultOptions, userOptions)

    const cidOptions = {
      cidVersion: options.cidVersion,
      hashAlg: options.hashAlg,
      onlyHash: options.onlyHash
    }
    const serialized = formatImpl.util.serialize(node)
    const cid = await formatImpl.util.cid(serialized, cidOptions)

    if (!options.onlyHash) {
      const block = new Block(serialized, cid)
      await promisify(this.bs.put.bind(this.bs))(block)
    }

    return cid
  }

  /**
   * Stores the given IPLD Nodes of a recognized IPLD Format.
   *
   * @param {Iterable.<Object>} nodes - Deserialized IPLD nodes that should be inserted.
   * @param {number} format - The multicodec of the format that IPLD Node should be encoded in.
   * @param {Object} [userOptions] -  Options are applied to any of the `nodes` and is an object with the following properties.
   * @param {number} [userOtions.hashAlg=hash algorithm of the given multicodec] - The hashing algorithm that is used to calculate the CID.
   * @param {number} [userOptions.cidVersion=1] - The CID version to use.
   * @param {boolean} [userOptions.onlyHash=false] - If true the serialized form of the IPLD Node will not be passed to the underlying block store.
   * @returns {Iterable.<Promise.<CID>>} - Returns an async iterator with the CIDs of the serialized IPLD Nodes.
   */
  putMany (nodes, format, userOptions) {
    if (!typical.isIterable(nodes) || typeof nodes === 'string' ||
        Buffer.isBuffer(nodes)) {
      throw new Error('`nodes` must be an iterable')
    }
    if (format === undefined) {
      throw new Error('`put` requires a format')
    }
    if (typeof format !== 'number') {
      throw new Error('`format` parameter must be number (multicodec)')
    }

    let options
    let formatImpl

    const generator = async function * () {
      for await (const node of nodes) {
        // Lazy load the options not when the iterator is initialized, but
        // when we hit the first iteration. This way the constructor can be
        // a synchronous function.
        if (options === undefined) {
          formatImpl = await this._getFormat(format)
          const defaultOptions = {
            hashAlg: formatImpl.defaultHashAlg,
            cidVersion: 1,
            onlyHash: false
          }
          options = mergeOptions(defaultOptions, userOptions)
        }

        yield this.put(node, format, options)
      }
    }.bind(this)

    return extendIterator(generator())
  }

  /**
   * Remove an IPLD Node by the given CID.
   *
   * @param {CID} cid - The CID of the IPLD Node that should be removed.
   * @return {Promise.<CID>} The CID of the removed IPLD Node.
   */
  async remove (cid) {
    return promisify(this.bs.delete.bind(this.bs))(cid)
  }

  /**
   * Remove IPLD Nodes by the given CIDs.
   *
   * Throws an error if any of the Blocks can’t be removed. This operation is
   * *not* atomic, some Blocks might have already been removed.
   *
   * @param {Iterable.<CID>} cids - The CIDs of the IPLD Nodes that should be removed.
   * @return {Iterable.<Promise.<CID>>} Returns an async iterator with the CIDs of the removed IPLD Nodes.
   */
  removeMany (cids) {
    if (!typical.isIterable(cids) || typeof cids === 'string' ||
        Buffer.isBuffer(cids)) {
      throw new Error('`cids` must be an iterable of CIDs')
    }

    const generator = async function * () {
      for await (const cid of cids) {
        yield this.remove(cid)
      }
    }.bind(this)

    return extendIterator(generator())
  }

  /**
   * Returns all the paths that can be resolved into.
   *
   * @param {Object} cid - The ID to get the paths from
   * @param {string} [offsetPath=''] - the path to start to retrieve the other paths from.
   * @param {Object} [userOptions]
   * @param {number} [userOptions.recursive=false] - whether to get the paths recursively or not. `false` resolves only the paths of the given CID.
   * @returns {Iterable.<Promise.<String>>} - Returns an async iterator with paths that can be resolved into
   */
  tree (cid, offsetPath, userOptions) {
    if (typeof offsetPath === 'object') {
      userOptions = offsetPath
      offsetPath = undefined
    }
    offsetPath = offsetPath || ''

    const defaultOptions = {
      recursive: false
    }
    const options = mergeOptions(defaultOptions, userOptions)

    // If a path is a link then follow it and return its CID
    const maybeRecurse = async (block, treePath) => {
      // A treepath we might want to follow recursively
      const format = await this._getFormat(block.cid.codec)
      const result = format.resolver.resolve(block.data, treePath)
      // Something to follow recusively, hence push it into the queue
      if (CID.isCID(result.value)) {
        return result.value
      } else {
        return null
      }
    }

    const generator = async function * () {
      // The list of paths that will get returned
      const treePaths = []
      // The current block, needed to call `isLink()` on every interation
      let block
      // The list of items we want to follow recursively. The items are
      // an object consisting of the CID and the currently already resolved
      // path
      const queue = [{ cid, basePath: '' }]
      // The path that was already traversed
      let basePath

      // End of iteration if there aren't any paths left to return or
      // if we don't want to traverse recursively and have already
      // returne the first level
      while (treePaths.length > 0 || queue.length > 0) {
        // There aren't any paths left, get them from the given CID
        if (treePaths.length === 0 && queue.length > 0) {
          ({ cid, basePath } = queue.shift())
          const format = await this._getFormat(cid.codec)
          block = await promisify(this.bs.get.bind(this.bs))(cid)

          const paths = format.resolver.tree(block.data)
          treePaths.push(...paths)
        }

        const treePath = treePaths.shift()
        let fullPath = basePath + treePath

        // Only follow links if recursion is intended
        if (options.recursive) {
          cid = await maybeRecurse(block, treePath)
          if (cid !== null) {
            queue.push({ cid, basePath: fullPath + '/' })
          }
        }

        // Return it if it matches the given offset path, but is not the
        // offset path itself
        if (fullPath.startsWith(offsetPath) &&
            fullPath.length > offsetPath.length) {
          if (offsetPath.length > 0) {
            fullPath = fullPath.slice(offsetPath.length + 1)
          }

          yield fullPath
        }
      }
    }.bind(this)

    return extendIterator(generator())
  }

  /*           */
  /* internals */
  /*           */
  async _getFormat (codec) {
    // TODO vmx 2019-01-24: Once all CIDs support accessing the codec code
    // instead of the name, remove this part
    if (typeof codec === 'string') {
      const constantName = codec.toUpperCase().replace(/-/g, '_')
      codec = multicodec[constantName]
    }

    if (this.resolvers[codec]) {
      return this.resolvers[codec]
    }

    // If not supported, attempt to dynamically load this format
    const format = await this.loadFormat(codec)
    this.addFormat(format)
    return format
  }
}

/**
 * Default options for IPLD.
 */
IPLDResolver.defaultOptions = {
  formats: [ipldDagCbor, ipldDagPb, ipldRaw]
}

module.exports = IPLDResolver

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

      };
    };
  }
}, {package:"ipld",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/index.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/constants.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/**
 * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
 * @module Multibase
 */
'use strict'

const constants = require('./constants')

exports = module.exports = multibase
exports.encode = encode
exports.decode = decode
exports.isEncoded = isEncoded
exports.names = Object.freeze(Object.keys(constants.names))
exports.codes = Object.freeze(Object.keys(constants.codes))

const errNotSupported = new Error('Unsupported encoding')

/**
 * Create a new buffer with the multibase varint+code.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Buffer} buf - The data to be prefixed with multibase.
 * @memberof Multibase
 * @returns {Buffer}
 */
function multibase (nameOrCode, buf) {
  if (!buf) {
    throw new Error('requires an encoded buffer')
  }
  const base = getBase(nameOrCode)
  const codeBuf = Buffer.from(base.code)

  const name = base.name
  validEncode(name, buf)
  return Buffer.concat([codeBuf, buf])
}

/**
 * Encode data with the specified base and add the multibase prefix.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Buffer} buf - The data to be encoded.
 * @returns {Buffer}
 * @memberof Multibase
 */
function encode (nameOrCode, buf) {
  const base = getBase(nameOrCode)
  const name = base.name

  return multibase(name, Buffer.from(base.encode(buf)))
}

/**
 * Takes a buffer or string encoded with multibase header, decodes it and
 * returns the decoded buffer
 *
 * @param {Buffer|string} bufOrString
 * @returns {Buffer}
 * @memberof Multibase
 *
 */
function decode (bufOrString) {
  if (Buffer.isBuffer(bufOrString)) {
    bufOrString = bufOrString.toString()
  }

  const code = bufOrString.substring(0, 1)
  bufOrString = bufOrString.substring(1, bufOrString.length)

  if (typeof bufOrString === 'string') {
    bufOrString = Buffer.from(bufOrString)
  }

  const base = getBase(code)
  return Buffer.from(base.decode(bufOrString.toString()))
}

/**
 * Is the given data multibase encoded?
 *
 * @param {Buffer|string} bufOrString
 * @returns {boolean}
 * @memberof Multibase
 */
function isEncoded (bufOrString) {
  if (Buffer.isBuffer(bufOrString)) {
    bufOrString = bufOrString.toString()
  }

  // Ensure bufOrString is a string
  if (Object.prototype.toString.call(bufOrString) !== '[object String]') {
    return false
  }

  const code = bufOrString.substring(0, 1)
  try {
    const base = getBase(code)
    return base.name
  } catch (err) {
    return false
  }
}

/**
 * @param {string} name
 * @param {Buffer} buf
 * @private
 * @returns {undefined}
 */
function validEncode (name, buf) {
  const base = getBase(name)
  base.decode(buf.toString())
}

function getBase (nameOrCode) {
  let base

  if (constants.names[nameOrCode]) {
    base = constants.names[nameOrCode]
  } else if (constants.codes[nameOrCode]) {
    base = constants.codes[nameOrCode]
  } else {
    throw errNotSupported
  }

  if (!base.isImplemented()) {
    throw new Error('Base ' + nameOrCode + ' is not implemented yet')
  }

  return base
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multibase",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js", {"./codec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/codec.js","./protocols-table":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/protocols-table.js","bs58":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bs58/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","class-is":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/class-is/index.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const codec = require('./codec')
const protocols = require('./protocols-table')
const varint = require('varint')
const bs58 = require('bs58')
const withIs = require('class-is')

/**
 * Creates a [multiaddr](https://github.com/multiformats/multiaddr) from
 * a Buffer, String or another Multiaddr instance
 * public key.
 * @class Multiaddr
 * @param {(String|Buffer|Multiaddr)} addr - If String or Buffer, needs to adhere
 * to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)
 * @example
 * Multiaddr('/ip4/127.0.0.1/tcp/4001')
 * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
 */
const Multiaddr = withIs.proto(function (addr) {
  if (!(this instanceof Multiaddr)) {
    return new Multiaddr(addr)
  }

  // default
  if (addr == null) {
    addr = ''
  }

  if (addr instanceof Buffer) {
    /**
     * @type {Buffer} - The raw bytes representing this multiaddress
     */
    this.buffer = codec.fromBuffer(addr)
  } else if (typeof addr === 'string' || addr instanceof String) {
    if (addr.length > 0 && addr.charAt(0) !== '/') {
      throw new Error(`multiaddr "${addr}" must start with a "/"`)
    }
    this.buffer = codec.fromString(addr)
  } else if (addr.buffer && addr.protos && addr.protoCodes) { // Multiaddr
    this.buffer = codec.fromBuffer(addr.buffer) // validate + copy buffer
  } else {
    throw new Error('addr must be a string, Buffer, or another Multiaddr')
  }
}, { className: 'Multiaddr', symbolName: '@multiformats/js-multiaddr/multiaddr' })

/**
 * Returns Multiaddr as a String
 *
 * @returns {String}
 * @example
 * Multiaddr('/ip4/127.0.0.1/tcp/4001').toString()
 * // '/ip4/127.0.0.1/tcp/4001'
 */
Multiaddr.prototype.toString = function toString () {
  return codec.bufferToString(this.buffer)
}

/**
 * Returns Multiaddr as a JSON encoded object
 *
 * @returns {String}
 * @example
 * JSON.stringify(Multiaddr('/ip4/127.0.0.1/tcp/4001'))
 * // '/ip4/127.0.0.1/tcp/4001'
 */
Multiaddr.prototype.toJSON = Multiaddr.prototype.toString

/**
 * Returns Multiaddr as a convinient options object to be used with net.createConnection
 *
 * @returns {{family: String, host: String, transport: String, port: String}}
 * @example
 * Multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()
 * // { family: 'ipv4', host: '127.0.0.1', transport: 'tcp', port: '4001' }
 */
Multiaddr.prototype.toOptions = function toOptions () {
  const opts = {}
  const parsed = this.toString().split('/')
  opts.family = parsed[1] === 'ip4' ? 'ipv4' : 'ipv6'
  opts.host = parsed[2]
  opts.transport = parsed[3]
  opts.port = parsed[4]
  return opts
}

/**
 * Returns Multiaddr as a human-readable string
 *
 * @returns {String}
 * @example
 * Multiaddr('/ip4/127.0.0.1/tcp/4001').inspect()
 * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'
 */
Multiaddr.prototype.inspect = function inspect () {
  return '<Multiaddr ' +
    this.buffer.toString('hex') + ' - ' +
    codec.bufferToString(this.buffer) + '>'
}

/**
 * Returns the protocols the Multiaddr is defined with, as an array of objects, in
 * left-to-right order. Each object contains the protocol code, protocol name,
 * and the size of its address space in bits.
 * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)
 *
 * @returns {Array.<Object>} protocols - All the protocols the address is composed of
 * @returns {Number} protocols[].code
 * @returns {Number} protocols[].size
 * @returns {String} protocols[].name
 * @example
 * Multiaddr('/ip4/127.0.0.1/tcp/4001').protos()
 * // [ { code: 4, size: 32, name: 'ip4' },
 * //   { code: 6, size: 16, name: 'tcp' } ]
 */
Multiaddr.prototype.protos = function protos () {
  return this.protoCodes().map(code => Object.assign({}, protocols(code)))
}

/**
 * Returns the codes of the protocols in left-to-right order.
 * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)
 *
 * @returns {Array.<Number>} protocol codes
 * @example
 * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()
 * // [ 4, 6 ]
 */
Multiaddr.prototype.protoCodes = function protoCodes () {
  const codes = []
  const buf = this.buffer
  let i = 0
  while (i < buf.length) {
    const code = varint.decode(buf, i)
    const n = varint.decode.bytes

    const p = protocols(code)
    const size = codec.sizeForAddr(p, buf.slice(i + n))

    i += (size + n)
    codes.push(code)
  }

  return codes
}

/**
 * Returns the names of the protocols in left-to-right order.
 * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)
 *
 * @return {Array.<String>} protocol names
 * @example
 * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()
 * // [ 'ip4', 'tcp' ]
 */
Multiaddr.prototype.protoNames = function protoNames () {
  return this.protos().map(proto => proto.name)
}

/**
 * Returns a tuple of parts
 *
 * @return {Array.<Array>} tuples
 * @return {Number} tuples[].0 code of protocol
 * @return {Buffer} tuples[].1 contents of address
 * @example
 * Multiaddr("/ip4/127.0.0.1/tcp/4001").tuples()
 * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]
 */
Multiaddr.prototype.tuples = function tuples () {
  return codec.bufferToTuples(this.buffer)
}

/**
 * Returns a tuple of string/number parts
 *
 * @return {Array.<Array>} tuples
 * @return {Number} tuples[].0 code of protocol
 * @return {(String|Number)} tuples[].1 contents of address
 * @example
 * Multiaddr("/ip4/127.0.0.1/tcp/4001").stringTuples()
 * // [ [ 4, '127.0.0.1' ], [ 6, 4001 ] ]
 */
Multiaddr.prototype.stringTuples = function stringTuples () {
  const t = codec.bufferToTuples(this.buffer)
  return codec.tuplesToStringTuples(t)
}

/**
 * Encapsulates a Multiaddr in another Multiaddr
 *
 * @param {Multiaddr} addr - Multiaddr to add into this Multiaddr
 * @return {Multiaddr}
 * @example
 * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')
 * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>
 *
 * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')
 * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
 *
 * const mh3 = mh1.encapsulate(mh2)
 * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>
 *
 * mh3.toString()
 * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'
 */
Multiaddr.prototype.encapsulate = function encapsulate (addr) {
  addr = Multiaddr(addr)
  return Multiaddr(this.toString() + addr.toString())
}

/**
 * Decapsulates a Multiaddr from another Multiaddr
 *
 * @param {Multiaddr} addr - Multiaddr to remove from this Multiaddr
 * @return {Multiaddr}
 * @example
 * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')
 * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>
 *
 * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')
 * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
 *
 * const mh3 = mh1.encapsulate(mh2)
 * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>
 *
 * mh3.decapsulate(mh2).toString()
 * // '/ip4/8.8.8.8/tcp/1080'
 */
Multiaddr.prototype.decapsulate = function decapsulate (addr) {
  addr = addr.toString()
  const s = this.toString()
  const i = s.lastIndexOf(addr)
  if (i < 0) {
    throw new Error('Address ' + this + ' does not contain subaddress: ' + addr)
  }
  return Multiaddr(s.slice(0, i))
}

/**
 * Extract the peerId if the multiaddr contains one
 *
 * @return {String|null} peerId - The id of the peer or null if invalid or missing from the ma
 * @example
 * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')
 * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string>
 *
 * // should return QmValidBase58string or null if the id is missing or invalid
 * const peerId = mh1.getPeerId()
 */
Multiaddr.prototype.getPeerId = function getPeerId () {
  let b58str = null
  try {
    b58str = this.stringTuples().filter((tuple) => {
      if (tuple[0] === protocols.names.ipfs.code) {
        return true
      }
    })[0][1]

    bs58.decode(b58str)
  } catch (e) {
    b58str = null
  }

  return b58str
}

/**
 * Extract the path if the multiaddr contains one
 *
 * @return {String|null} path - The path of the multiaddr, or null if no path protocol is present
 * @example
 * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')
 * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock>
 *
 * // should return utf8 string or null if the id is missing or invalid
 * const path = mh1.getPath()
 */
Multiaddr.prototype.getPath = function getPath () {
  let path = null
  try {
    path = this.stringTuples().filter((tuple) => {
      const proto = protocols(tuple[0])
      if (proto.path) {
        return true
      }
    })[0][1]
  } catch (e) {
    path = null
  }

  return path
}

/**
 * Checks if two Multiaddrs are the same
 *
 * @param {Multiaddr} addr
 * @return {Bool}
 * @example
 * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')
 * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>
 *
 * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')
 * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
 *
 * mh1.equals(mh1)
 * // true
 *
 * mh1.equals(mh2)
 * // false
 */
Multiaddr.prototype.equals = function equals (addr) {
  return this.buffer.equals(addr.buffer)
}

/**
 * Gets a Multiaddrs node-friendly address object. Note that protocol information
 * is left out: in Node (and most network systems) the protocol is unknowable
 * given only the address.
 *
 * Has to be a ThinWaist Address, otherwise throws error
 *
 * @returns {{family: String, address: String, port: String}}
 * @throws {Error} Throws error if Multiaddr is not a Thin Waist address
 * @example
 * Multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()
 * // {family: 'IPv4', address: '127.0.0.1', port: '4001'}
 */
Multiaddr.prototype.nodeAddress = function nodeAddress () {
  const codes = this.protoCodes()
  const names = this.protoNames()
  const parts = this.toString().split('/').slice(1)

  if (parts.length < 4) {
    throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".')
  } else if (codes[0] !== 4 && codes[0] !== 41 && codes[0] !== 54 && codes[0] !== 55) {
    throw new Error(`no protocol with name: "'${names[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`)
  } else if (parts[2] !== 'tcp' && parts[2] !== 'udp') {
    throw new Error(`no protocol with name: "'${names[1]}'". Must have a valid transport protocol: "{tcp, udp}".`)
  }

  return {
    family: (codes[0] === 41 || codes[0] === 55) ? 6 : 4,
    address: parts[1], // ip addr
    port: parts[3] // tcp or udp port
  }
}

/**
 * Creates a Multiaddr from a node-friendly address object
 *
 * @param {String} addr
 * @param {String} transport
 * @returns {Multiaddr} multiaddr
 * @throws {Error} Throws error if addr is not truthy
 * @throws {Error} Throws error if transport is not truthy
 * @example
 * Multiaddr.fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')
 * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
 */
Multiaddr.fromNodeAddress = function fromNodeAddress (addr, transport) {
  if (!addr) throw new Error('requires node address object')
  if (!transport) throw new Error('requires transport protocol')
  const ip = (addr.family === 'IPv6') ? 'ip6' : 'ip4'
  return Multiaddr('/' + [ip, addr.address, transport, addr.port].join('/'))
}

// TODO find a better example, not sure about it's good enough
/**
 * Returns if a Multiaddr is a Thin Waist address or not.
 *
 * Thin Waist is if a Multiaddr adheres to the standard combination of:
 *
 * `{IPv4, IPv6}/{TCP, UDP}`
 *
 * @param {Multiaddr} [addr] - Defaults to using `this` instance
 * @returns {Boolean} isThinWaistAddress
 * @example
 * const mh1 = Multiaddr('/ip4/127.0.0.1/tcp/4001')
 * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
 * const mh2 = Multiaddr('/ip4/192.168.2.1/tcp/5001')
 * // <Multiaddr 04c0a80201061389 - /ip4/192.168.2.1/tcp/5001>
 * const mh3 = mh1.encapsulate(mh2)
 * // <Multiaddr 047f000001060fa104c0a80201061389 - /ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001>
 * mh1.isThinWaistAddress()
 * // true
 * mh2.isThinWaistAddress()
 * // true
 * mh3.isThinWaistAddress()
 * // false
 */
Multiaddr.prototype.isThinWaistAddress = function isThinWaistAddress (addr) {
  const protos = (addr || this).protos()

  if (protos.length !== 2) {
    return false
  }

  if (protos[0].code !== 4 && protos[0].code !== 41) {
    return false
  }
  if (protos[1].code !== 6 && protos[1].code !== 273) {
    return false
  }
  return true
}

/**
 * Object containing table, names and codes of all supported protocols.
 * To get the protocol values from a Multiaddr, you can use
 * [`.protos()`](#multiaddrprotos),
 * [`.protoCodes()`](#multiaddrprotocodes) or
 * [`.protoNames()`](#multiaddrprotonames)
 *
 * @instance
 * @returns {{table: Array, names: Object, codes: Object}}
 *
 */
Multiaddr.protocols = protocols

/**
 * Returns if something is a Multiaddr that is a name
 *
 * @param {Multiaddr} addr
 * @return {Bool} isName
 */
Multiaddr.isName = function isName (addr) {
  if (!Multiaddr.isMultiaddr(addr)) {
    return false
  }

  // if a part of the multiaddr is resolvable, then return true
  return addr.protos().some((proto) => proto.resolvable)
}

/**
 * Returns an array of multiaddrs, by resolving the multiaddr that is a name
 *
 * @param {Multiaddr} addr
 *
 * @param {Function} callback
 * @return {Bool} isName
 */
Multiaddr.resolve = function resolve (addr, callback) {
  if (!Multiaddr.isMultiaddr(addr) || !Multiaddr.isName(addr)) {
    return callback(new Error('not a valid name'))
  }

  /*
   * Needs more consideration from spec design:
   *   - what to return
   *   - how to achieve it in the browser?
   */
  return callback(new Error('not implemented yet'))
}

exports = module.exports = Multiaddr

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multiaddr",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/index.js", {"./crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/crypto.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const multihash = require('multihashes')
const crypto = require('./crypto')

module.exports = Multihashing

/**
 * Hash the given `buf` using the algorithm specified
 * by `func`.
 *
 * @param {Buffer} buf - The value to hash.
 * @param {number|string} func - The algorithm to use.
 * @param {number} [length] - Optionally trim the result to this length.
 * @param {function(Error, Buffer)} callback
 * @returns {undefined}
 */
function Multihashing (buf, func, length, callback) {
  if (typeof length === 'function') {
    callback = length
    length = undefined
  }

  if (!callback) {
    throw new Error('Missing callback')
  }

  Multihashing.digest(buf, func, length, (err, digest) => {
    if (err) {
      return callback(err)
    }

    callback(null, multihash.encode(digest, func, length))
  })
}

/**
 * The `buffer` module for easy use in the browser.
 *
 * @type {Buffer}
 */
Multihashing.Buffer = Buffer // for browser things

/**
 * Expose multihash itself, to avoid silly double requires.
 */
Multihashing.multihash = multihash

/**
 * @param {Buffer} buf - The value to hash.
 * @param {number|string} func - The algorithm to use.
 * @param {number} [length] - Optionally trim the result to this length.
 * @param {function(Error, Buffer)} callback
 * @returns {undefined}
 */
Multihashing.digest = function (buf, func, length, callback) {
  if (typeof length === 'function') {
    callback = length
    length = undefined
  }

  if (!callback) {
    throw new Error('Missing callback')
  }

  let cb = callback
  if (length) {
    cb = (err, digest) => {
      if (err) {
        return callback(err)
      }

      callback(null, digest.slice(0, length))
    }
  }

  let hash
  try {
    hash = Multihashing.createHash(func)
  } catch (err) {
    return cb(err)
  }

  hash(buf, cb)
}

/**
 * @param {string|number} func
 *
 * @returns {function} - The to `func` corresponding hash function.
 */
Multihashing.createHash = function (func) {
  func = multihash.coerceCode(func)
  if (!Multihashing.functions[func]) {
    throw new Error('multihash function ' + func + ' not yet supported')
  }

  return Multihashing.functions[func]
}

/**
 * Mapping of multihash codes to their hashing functions.
 * @type {Object}
 */
Multihashing.functions = {
  // sha1
  0x11: crypto.sha1,
  // sha2-256
  0x12: crypto.sha2256,
  // sha2-512
  0x13: crypto.sha2512,
  // sha3-512
  0x14: crypto.sha3512,
  // sha3-384
  0x15: crypto.sha3384,
  // sha3-256
  0x16: crypto.sha3256,
  // sha3-224
  0x17: crypto.sha3224,
  // shake-128
  0x18: crypto.shake128,
  // shake-256
  0x19: crypto.shake256,
  // keccak-224
  0x1A: crypto.keccak224,
  // keccak-256
  0x1B: crypto.keccak256,
  // keccak-384
  0x1C: crypto.keccak384,
  // keccak-512
  0x1D: crypto.keccak512,
  // murmur3-128
  0x22: crypto.murmur3128,
  // murmur3-32
  0x23: crypto.murmur332,
  // dbl-sha2-256
  0x56: crypto.dblSha2256
}

// add blake functions
crypto.addBlake(Multihashing.functions)

Multihashing.validate = (data, hash, callback) => {
  let algo = multihash.decode(hash).name
  Multihashing(data, algo, (err, newHash) => {
    if (err) return callback(err)
    callback(err, Buffer.compare(hash, newHash) === 0)
  })
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/ipld-browser.js", {"ipld-dag-cbor":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-cbor/src/index.js","ipld-dag-pb":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/index.js","ipld-raw":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-raw/src/index.js","merge-options":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/merge-options/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/ipld-browser.js
      return function (require, module, exports) {
'use strict'
const mergeOptions = require('merge-options')
const ipldDagCbor = require('ipld-dag-cbor')
const ipldDagPb = require('ipld-dag-pb')
const ipldRaw = require('ipld-raw')

module.exports = (blockService, options = {}) => {
  return mergeOptions.call(
    // ensure we have the defaults formats even if the user overrides `formats: []`
    { concatArrays: true },
    {
      blockService: blockService,
      formats: [ipldDagCbor, ipldDagPb, ipldRaw]
    }, options)
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/ipld-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/boot.js", {"async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js","ipfs-repo":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/boot.js
      return function (require, module, exports) {
'use strict'

const waterfall = require('async/waterfall')
const RepoErrors = require('ipfs-repo').errors

// Boot an IPFS node depending on the options set
module.exports = (self) => {
  self.log('booting')
  const options = self._options
  const doInit = options.init
  const doStart = options.start

  // Do the actual boot sequence
  waterfall([
    // Checks if a repo exists, and if so opens it
    // Will return callback with a bool indicating the existence
    // of the repo
    (cb) => {
      // nothing to do
      if (!self._repo.closed) {
        return cb(null, true)
      }

      self._repo.open((err, res) => {
        if (isRepoUninitializedError(err)) return cb(null, false)
        if (err) return cb(err)
        cb(null, true)
      })
    },
    (repoOpened, cb) => {
      // Init with existing initialized, opened, repo
      if (repoOpened) {
        return self.init({ repo: self._repo }, (err) => {
          if (err) return cb(Object.assign(err, { emitted: true }))
          cb()
        })
      }

      if (doInit) {
        const initOptions = Object.assign(
          { bits: 2048, pass: self._options.pass },
          typeof options.init === 'object' ? options.init : {}
        )
        return self.init(initOptions, (err) => {
          if (err) return cb(Object.assign(err, { emitted: true }))
          cb()
        })
      }

      cb()
    },
    (cb) => {
      // No problem, we don't have to start the node
      if (!doStart) {
        return cb()
      }

      self.start((err) => {
        if (err) return cb(Object.assign(err, { emitted: true }))
        cb()
      })
    }
  ], (err) => {
    if (err) {
      if (!err.emitted) {
        self.emit('error', err)
      }
      return
    }
    self.log('booted')
    self.emit('ready')
  })
}

function isRepoUninitializedError (err) {
  if (!err) {
    return false
  }

  // If the error is that no repo exists,
  // which happens when the version file is not found
  // we just want to signal that no repo exist, not
  // fail the whole process.

  // Use standardized errors as much as possible
  if (err.code === RepoErrors.ERR_REPO_NOT_INITIALIZED) {
    return true
  }

  // TODO: As error codes continue to be standardized, this logic can be phase out;
  // it is here to maintain compatibility
  if (err.message.match(/not found/) || // indexeddb
    err.message.match(/ENOENT/) || // fs
    err.message.match(/No value/) // memory
  ) {
    return true
  }

  return false
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/boot.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/index.js", {"./aes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/aes/index.js","./hmac":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/hmac/index-browser.js","./keys":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/index.js","./pbkdf2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/pbkdf2.js","./random-bytes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/random-bytes.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/index.js
      return function (require, module, exports) {
'use strict'

const hmac = require('./hmac')
const aes = require('./aes')
const keys = require('./keys')

exports = module.exports

exports.aes = aes
exports.hmac = hmac
exports.keys = keys
exports.randomBytes = require('./random-bytes')
exports.pbkdf2 = require('./pbkdf2')

      };
    };
  }
}, {package:"libp2p-crypto",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/index.js", {"./bitswap":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/bitswap.js","./block":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/block.js","./bootstrap":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/bootstrap.js","./config":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/config.js","./dag":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/dag.js","./dht":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/dht.js","./dns":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/dns.js","./files-mfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-mfs.js","./files-regular":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/index.js","./id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/id.js","./init":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/init.js","./is-online":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/is-online.js","./key":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/key.js","./libp2p":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/libp2p.js","./name":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/name.js","./object":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/object.js","./pin":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/pin.js","./ping":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/ping.js","./ping-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/ping-pull-stream.js","./ping-readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/ping-readable-stream.js","./pre-start":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/pre-start.js","./pubsub":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/pubsub.js","./repo":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/repo.js","./resolve":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/resolve.js","./start":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/start.js","./stats":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/stats.js","./stop":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/stop.js","./swarm":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/swarm.js","./version":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/version.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/index.js
      return function (require, module, exports) {
'use strict'

exports.preStart = require('./pre-start')
exports.start = require('./start')
exports.stop = require('./stop')
exports.isOnline = require('./is-online')
exports.version = require('./version')
exports.id = require('./id')
exports.repo = require('./repo')
exports.init = require('./init')
exports.bootstrap = require('./bootstrap')
exports.config = require('./config')
exports.block = require('./block')
exports.object = require('./object')
exports.dag = require('./dag')
exports.libp2p = require('./libp2p')
exports.swarm = require('./swarm')
exports.ping = require('./ping')
exports.pingPullStream = require('./ping-pull-stream')
exports.pingReadableStream = require('./ping-readable-stream')
exports.pin = require('./pin')
exports.filesRegular = require('./files-regular')
exports.filesMFS = require('./files-mfs')
exports.bitswap = require('./bitswap')
exports.pubsub = require('./pubsub')
exports.dht = require('./dht')
exports.dns = require('./dns')
exports.key = require('./key')
exports.stats = require('./stats')
exports.resolve = require('./resolve')
exports.name = require('./name')

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/eth-accounts.js", {"../../../../../shared/constants/app":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/app.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/eth-accounts.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _app = require("../../../../../shared/constants/app");

/**
 * A wrapper for `eth_accounts` that returns an empty array when permission is denied.
 */
const requestEthereumAccounts = {
  methodNames: [_app.MESSAGE_TYPE.ETH_ACCOUNTS],
  implementation: ethAccountsHandler,
  hookNames: {
    getAccounts: true
  }
};
var _default = requestEthereumAccounts;
/**
 * @typedef {Record<string, Function>} EthAccountsOptions
 * @property {Function} getAccounts - Gets the accounts for the requesting
 * origin.
 */

/**
 *
 * @param {__import__('json-rpc-engine').JsonRpcRequest<unknown>} req - The JSON-RPC request object.
 * @param {__import__('json-rpc-engine').JsonRpcResponse<true>} res - The JSON-RPC response object.
 * @param {Function} _next - The json-rpc-engine 'next' callback.
 * @param {Function} end - The json-rpc-engine 'end' callback.
 * @param {EthAccountsOptions} options - The RPC method hooks.
 */

exports.default = _default;

async function ethAccountsHandler(_req, res, _next, end, {
  getAccounts
}) {
  res.result = await getAccounts();
  return end();
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/eth-accounts.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/log-web3-shim-usage.js", {"../../../../../shared/constants/app":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/app.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/log-web3-shim-usage.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _app = require("../../../../../shared/constants/app");

/**
 * This RPC method is called by the inpage provider whenever it detects the
 * accessing of a non-existent property on our window.web3 shim.
 * We collect this data to understand which sites are breaking due to the
 * removal of our window.web3.
 */
const logWeb3ShimUsage = {
  methodNames: [_app.MESSAGE_TYPE.LOG_WEB3_SHIM_USAGE],
  implementation: logWeb3ShimUsageHandler,
  hookNames: {
    sendMetrics: true,
    getWeb3ShimUsageState: true,
    setWeb3ShimUsageRecorded: true
  }
};
var _default = logWeb3ShimUsage;
/**
 * @typedef {Object} LogWeb3ShimUsageOptions
 * @property {Function} sendMetrics - A function that registers a metrics event.
 * @property {Function} getWeb3ShimUsageState - A function that gets web3 shim
 * usage state for the given origin.
 * @property {Function} setWeb3ShimUsageRecorded - A function that records web3 shim
 * usage for a particular origin.
 */

/**
 * @param {__import__('json-rpc-engine').JsonRpcRequest<unknown>} req - The JSON-RPC request object.
 * @param {__import__('json-rpc-engine').JsonRpcResponse<true>} res - The JSON-RPC response object.
 * @param {Function} _next - The json-rpc-engine 'next' callback.
 * @param {Function} end - The json-rpc-engine 'end' callback.
 * @param {LogWeb3ShimUsageOptions} options
 */

exports.default = _default;

function logWeb3ShimUsageHandler(req, res, _next, end, {
  sendMetrics,
  getWeb3ShimUsageState,
  setWeb3ShimUsageRecorded
}) {
  const {
    origin
  } = req;

  if (getWeb3ShimUsageState(origin) === undefined) {
    setWeb3ShimUsageRecorded(origin);
    sendMetrics({
      event: `Website Accessed window.web3 Shim`,
      category: 'inpage_provider',
      referrer: {
        url: origin
      }
    }, {
      excludeMetaMetricsId: true
    });
  }

  res.result = true;
  return end();
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/log-web3-shim-usage.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/watch-asset.js", {"../../../../../shared/constants/app":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/app.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/watch-asset.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _app = require("../../../../../shared/constants/app");

const watchAsset = {
  methodNames: [_app.MESSAGE_TYPE.WATCH_ASSET, _app.MESSAGE_TYPE.WATCH_ASSET_LEGACY],
  implementation: watchAssetHandler,
  hookNames: {
    handleWatchAssetRequest: true
  }
};
var _default = watchAsset;
/**
 * @typedef {Object} WatchAssetOptions
 * @property {Function} handleWatchAssetRequest - The wallet_watchAsset method implementation.
 */

/**
 * @typedef {Object} WatchAssetParam
 * @property {string} type - The type of the asset to watch.
 * @property {Object} options - Watch options for the asset.
 */

/**
 * @param {__import__('json-rpc-engine').JsonRpcRequest<WatchAssetParam>} req - The JSON-RPC request object.
 * @param {__import__('json-rpc-engine').JsonRpcResponse<true>} res - The JSON-RPC response object.
 * @param {Function} _next - The json-rpc-engine 'next' callback.
 * @param {Function} end - The json-rpc-engine 'end' callback.
 * @param {WatchAssetOptions} options
 */

exports.default = _default;

async function watchAssetHandler(req, res, _next, end, {
  handleWatchAssetRequest
}) {
  try {
    const {
      options: asset,
      type
    } = req.params;
    res.result = await handleWatchAssetRequest(asset, type);
    return end();
  } catch (error) {
    return end(error);
  }
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/watch-asset.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/request-accounts.js", {"../../../../../shared/constants/app":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/app.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/request-accounts.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethRpcErrors = require("eth-rpc-errors");

var _app = require("../../../../../shared/constants/app");

/**
 * This method attempts to retrieve the Ethereum accounts available to the
 * requester, or initiate a request for account access if none are currently
 * available. It is essentially a wrapper of wallet_requestPermissions that
 * only errors if the user rejects the request. We maintain the method for
 * backwards compatibility reasons.
 */
const requestEthereumAccounts = {
  methodNames: [_app.MESSAGE_TYPE.ETH_REQUEST_ACCOUNTS],
  implementation: requestEthereumAccountsHandler,
  hookNames: {
    origin: true,
    getAccounts: true,
    getUnlockPromise: true,
    hasPermission: true,
    requestAccountsPermission: true
  }
};
var _default = requestEthereumAccounts; // Used to rate-limit pending requests to one per origin

exports.default = _default;
const locks = new Set();
/**
 * @typedef {Record<string, string | Function>} RequestEthereumAccountsOptions
 * @property {string} origin - The requesting origin.
 * @property {Function} getAccounts - Gets the accounts for the requesting
 * origin.
 * @property {Function} getUnlockPromise - Gets a promise that resolves when
 * the extension unlocks.
 * @property {Function} hasPermission - Returns whether the requesting origin
 * has the specified permission.
 * @property {Function} requestAccountsPermission - Requests the `eth_accounts`
 * permission for the requesting origin.
 */

/**
 *
 * @param {__import__('json-rpc-engine').JsonRpcRequest<unknown>} _req - The JSON-RPC request object.
 * @param {__import__('json-rpc-engine').JsonRpcResponse<true>} res - The JSON-RPC response object.
 * @param {Function} _next - The json-rpc-engine 'next' callback.
 * @param {Function} end - The json-rpc-engine 'end' callback.
 * @param {RequestEthereumAccountsOptions} options - The RPC method hooks.
 */

async function requestEthereumAccountsHandler(_req, res, _next, end, {
  origin,
  getAccounts,
  getUnlockPromise,
  hasPermission,
  requestAccountsPermission
}) {
  if (locks.has(origin)) {
    res.error = _ethRpcErrors.ethErrors.rpc.resourceUnavailable(`Already processing ${_app.MESSAGE_TYPE.ETH_REQUEST_ACCOUNTS}. Please wait.`);
    return end();
  }

  if (hasPermission(_app.MESSAGE_TYPE.ETH_ACCOUNTS)) {
    // We wait for the extension to unlock in this case only, because permission
    // requests are handled when the extension is unlocked, regardless of the
    // lock state when they were received.
    try {
      locks.add(origin);
      await getUnlockPromise();
      res.result = await getAccounts();
      end();
    } catch (error) {
      end(error);
    } finally {
      locks.delete(origin);
    }

    return undefined;
  } // If no accounts, request the accounts permission


  try {
    await requestAccountsPermission();
  } catch (err) {
    res.error = err;
    return end();
  } // Get the approved accounts


  const accounts = await getAccounts();
  /* istanbul ignore else: too hard to induce, see below comment */

  if (accounts.length > 0) {
    res.result = accounts;
  } else {
    // This should never happen, because it should be caught in the
    // above catch clause
    res.error = _ethRpcErrors.ethErrors.rpc.internal('Accounts unexpectedly unavailable. Please report this bug.');
  }

  return end();
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/request-accounts.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/switch-ethereum-chain.js", {"../../../../../shared/constants/app":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/app.js","../../../../../shared/constants/network":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/network.js","../../../../../shared/modules/network.utils":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/network.utils.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/switch-ethereum-chain.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethRpcErrors = require("eth-rpc-errors");

var _lodash = require("lodash");

var _app = require("../../../../../shared/constants/app");

var _network = require("../../../../../shared/constants/network");

var _network2 = require("../../../../../shared/modules/network.utils");

const switchEthereumChain = {
  methodNames: [_app.MESSAGE_TYPE.SWITCH_ETHEREUM_CHAIN],
  implementation: switchEthereumChainHandler,
  hookNames: {
    getCurrentChainId: true,
    findCustomRpcBy: true,
    setProviderType: true,
    updateRpcTarget: true,
    requestUserApproval: true
  }
};
var _default = switchEthereumChain;
exports.default = _default;

function findExistingNetwork(chainId, findCustomRpcBy) {
  if (chainId in _network.CHAIN_ID_TO_TYPE_MAP) {
    return {
      chainId,
      ticker: _network.ETH_SYMBOL,
      nickname: _network.NETWORK_TO_NAME_MAP[chainId],
      rpcUrl: _network.CHAIN_ID_TO_RPC_URL_MAP[chainId],
      type: _network.CHAIN_ID_TO_TYPE_MAP[chainId]
    };
  }

  return findCustomRpcBy({
    chainId
  });
}

async function switchEthereumChainHandler(req, res, _next, end, {
  getCurrentChainId,
  findCustomRpcBy,
  setProviderType,
  updateRpcTarget,
  requestUserApproval
}) {
  var _req$params;

  if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params[0]) || typeof req.params[0] !== 'object') {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected single, object parameter. Received:\n${JSON.stringify(req.params)}`
    }));
  }

  const {
    origin
  } = req;
  const {
    chainId
  } = req.params[0];
  const otherKeys = Object.keys((0, _lodash.omit)(req.params[0], ['chainId']));

  if (otherKeys.length > 0) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Received unexpected keys on object parameter. Unsupported keys:\n${otherKeys}`
    }));
  }

  const _chainId = typeof chainId === 'string' && chainId.toLowerCase();

  if (!(0, _network2.isPrefixedFormattedHexString)(_chainId)) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected 0x-prefixed, unpadded, non-zero hexadecimal string 'chainId'. Received:\n${chainId}`
    }));
  }

  if (!(0, _network2.isSafeChainId)(parseInt(_chainId, 16))) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Invalid chain ID "${_chainId}": numerical value greater than max safe value. Received:\n${chainId}`
    }));
  }

  const requestData = findExistingNetwork(_chainId, findCustomRpcBy);

  if (requestData) {
    const currentChainId = getCurrentChainId();

    if (currentChainId === _chainId) {
      res.result = null;
      return end();
    }

    try {
      const approvedRequestData = await requestUserApproval({
        origin,
        type: _app.MESSAGE_TYPE.SWITCH_ETHEREUM_CHAIN,
        requestData
      });

      if (chainId in _network.CHAIN_ID_TO_TYPE_MAP) {
        setProviderType(approvedRequestData.type);
      } else {
        await updateRpcTarget(approvedRequestData);
      }

      res.result = null;
    } catch (error) {
      return end(error);
    }

    return end();
  }

  return end(_ethRpcErrors.ethErrors.provider.custom({
    code: 4902,
    // To-be-standardized "unrecognized chain ID" error
    message: `Unrecognized chain ID "${chainId}". Try adding the chain using ${_app.MESSAGE_TYPE.ADD_ETHEREUM_CHAIN} first.`
  }));
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/switch-ethereum-chain.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/add-ethereum-chain.js", {"../../../../../shared/constants/app":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/app.js","../../../../../shared/constants/network":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/network.js","../../../../../shared/modules/network.utils":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/network.utils.js","../../../../../shared/modules/rpc.utils":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/rpc.utils.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js","valid-url":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/valid-url/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/add-ethereum-chain.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethRpcErrors = require("eth-rpc-errors");

var _validUrl = _interopRequireDefault(require("valid-url"));

var _lodash = require("lodash");

var _app = require("../../../../../shared/constants/app");

var _network = require("../../../../../shared/modules/network.utils");

var _rpc = require("../../../../../shared/modules/rpc.utils");

var _network2 = require("../../../../../shared/constants/network");

const addEthereumChain = {
  methodNames: [_app.MESSAGE_TYPE.ADD_ETHEREUM_CHAIN],
  implementation: addEthereumChainHandler,
  hookNames: {
    addCustomRpc: true,
    getCurrentChainId: true,
    findCustomRpcBy: true,
    updateRpcTarget: true,
    requestUserApproval: true,
    sendMetrics: true
  }
};
var _default = addEthereumChain;
exports.default = _default;

async function addEthereumChainHandler(req, res, _next, end, {
  addCustomRpc,
  getCurrentChainId,
  findCustomRpcBy,
  updateRpcTarget,
  requestUserApproval,
  sendMetrics
}) {
  var _req$params;

  if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params[0]) || typeof req.params[0] !== 'object') {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected single, object parameter. Received:\n${JSON.stringify(req.params)}`
    }));
  }

  const {
    origin
  } = req;
  const {
    chainId,
    chainName = null,
    blockExplorerUrls = null,
    nativeCurrency = null,
    rpcUrls
  } = req.params[0];
  const otherKeys = Object.keys((0, _lodash.omit)(req.params[0], ['chainId', 'chainName', 'blockExplorerUrls', 'iconUrls', 'rpcUrls', 'nativeCurrency']));

  if (otherKeys.length > 0) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Received unexpected keys on object parameter. Unsupported keys:\n${otherKeys}`
    }));
  }

  const firstValidRPCUrl = Array.isArray(rpcUrls) ? rpcUrls.find(rpcUrl => _validUrl.default.isHttpsUri(rpcUrl)) : null;
  const firstValidBlockExplorerUrl = blockExplorerUrls !== null && Array.isArray(blockExplorerUrls) ? blockExplorerUrls.find(blockExplorerUrl => _validUrl.default.isHttpsUri(blockExplorerUrl)) : null;

  if (!firstValidRPCUrl) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected an array with at least one valid string HTTPS url 'rpcUrls', Received:\n${rpcUrls}`
    }));
  }

  if (blockExplorerUrls !== null && !firstValidBlockExplorerUrl) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected null or array with at least one valid string HTTPS URL 'blockExplorerUrl'. Received: ${blockExplorerUrls}`
    }));
  }

  const _chainId = typeof chainId === 'string' && chainId.toLowerCase();

  if (!(0, _network.isPrefixedFormattedHexString)(_chainId)) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected 0x-prefixed, unpadded, non-zero hexadecimal string 'chainId'. Received:\n${chainId}`
    }));
  }

  if (!(0, _network.isSafeChainId)(parseInt(_chainId, 16))) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Invalid chain ID "${_chainId}": numerical value greater than max safe value. Received:\n${chainId}`
    }));
  }

  if (_network2.CHAIN_ID_TO_NETWORK_ID_MAP[_chainId]) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `May not specify default MetaMask chain.`
    }));
  }

  const existingNetwork = findCustomRpcBy({
    chainId: _chainId
  });

  if (existingNetwork) {
    // If the network already exists, the request is considered successful
    res.result = null;
    const currentChainId = getCurrentChainId();

    if (currentChainId === _chainId) {
      return end();
    } // Ask the user to switch the network


    try {
      await updateRpcTarget(await requestUserApproval({
        origin,
        type: _app.MESSAGE_TYPE.SWITCH_ETHEREUM_CHAIN,
        requestData: {
          rpcUrl: existingNetwork.rpcUrl,
          chainId: existingNetwork.chainId,
          nickname: existingNetwork.nickname,
          ticker: existingNetwork.ticker
        }
      }));
      res.result = null;
    } catch (error) {
      // For the purposes of this method, it does not matter if the user
      // declines to switch the selected network. However, other errors indicate
      // that something is wrong.
      if (error.code !== _ethRpcErrors.errorCodes.provider.userRejectedRequest) {
        return end(error);
      }
    }

    return end();
  }

  let endpointChainId;

  try {
    endpointChainId = await (0, _rpc.jsonRpcRequest)(firstValidRPCUrl, 'eth_chainId');
  } catch (err) {
    return end(_ethRpcErrors.ethErrors.rpc.internal({
      message: `Request for method 'eth_chainId on ${firstValidRPCUrl} failed`,
      data: {
        networkErr: err
      }
    }));
  }

  if (_chainId !== endpointChainId) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Chain ID returned by RPC URL ${firstValidRPCUrl} does not match ${_chainId}`,
      data: {
        chainId: endpointChainId
      }
    }));
  }

  if (typeof chainName !== 'string' || !chainName) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected non-empty string 'chainName'. Received:\n${chainName}`
    }));
  }

  const _chainName = chainName.length > 100 ? chainName.substring(0, 100) : chainName;

  if (nativeCurrency !== null) {
    if (typeof nativeCurrency !== 'object' || Array.isArray(nativeCurrency)) {
      return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
        message: `Expected null or object 'nativeCurrency'. Received:\n${nativeCurrency}`
      }));
    }

    if (nativeCurrency.decimals !== 18) {
      return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
        message: `Expected the number 18 for 'nativeCurrency.decimals' when 'nativeCurrency' is provided. Received: ${nativeCurrency.decimals}`
      }));
    }

    if (!nativeCurrency.symbol || typeof nativeCurrency.symbol !== 'string') {
      return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
        message: `Expected a string 'nativeCurrency.symbol'. Received: ${nativeCurrency.symbol}`
      }));
    }
  }

  const ticker = (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || 'ETH';

  if (typeof ticker !== 'string' || ticker.length < 2 || ticker.length > 6) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected 2-6 character string 'nativeCurrency.symbol'. Received:\n${ticker}`
    }));
  }

  try {
    await addCustomRpc(await requestUserApproval({
      origin,
      type: _app.MESSAGE_TYPE.ADD_ETHEREUM_CHAIN,
      requestData: {
        chainId: _chainId,
        blockExplorerUrl: firstValidBlockExplorerUrl,
        chainName: _chainName,
        rpcUrl: firstValidRPCUrl,
        ticker
      }
    }));
    sendMetrics({
      event: 'Custom Network Added',
      category: 'Network',
      referrer: {
        url: origin
      },
      sensitiveProperties: {
        chain_id: _chainId,
        rpc_url: firstValidRPCUrl,
        network_name: _chainName,
        // Including network to override the default network
        // property included in all events. For RPC type networks
        // the MetaMetrics controller uses the rpcUrl for the network
        // property.
        network: firstValidRPCUrl,
        symbol: ticker,
        block_explorer_url: firstValidBlockExplorerUrl,
        source: 'dapp'
      }
    }); // Once the network has been added, the requested is considered successful

    res.result = null;
  } catch (error) {
    return end(error);
  } // Ask the user to switch the network


  try {
    await updateRpcTarget(await requestUserApproval({
      origin,
      type: _app.MESSAGE_TYPE.SWITCH_ETHEREUM_CHAIN,
      requestData: {
        rpcUrl: firstValidRPCUrl,
        chainId: _chainId,
        nickname: _chainName,
        ticker
      }
    }));
  } catch (error) {
    // For the purposes of this method, it does not matter if the user
    // declines to switch the selected network. However, other errors indicate
    // that something is wrong.
    if (error.code !== _ethRpcErrors.errorCodes.provider.userRejectedRequest) {
      return end(error);
    }
  }

  return end();
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/add-ethereum-chain.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/get-provider-state.js", {"../../../../../shared/constants/app":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/app.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/get-provider-state.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _app = require("../../../../../shared/constants/app");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * This RPC method gets background state relevant to the provider.
 * The background sends RPC notifications on state changes, but the provider
 * first requests state on initialization.
 */
const getProviderState = {
  methodNames: [_app.MESSAGE_TYPE.GET_PROVIDER_STATE],
  implementation: getProviderStateHandler,
  hookNames: {
    getProviderState: true
  }
};
var _default = getProviderState;
/**
 * @typedef {Object} ProviderStateHandlerResult
 * @property {string} chainId - The current chain ID.
 * @property {boolean} isUnlocked - Whether the extension is unlocked or not.
 * @property {string} networkVersion - The current network ID.
 */

/**
 * @typedef {Object} ProviderStateHandlerOptions
 * @property {() => ProviderStateHandlerResult} getProviderState - A function that
 * gets the current provider state.
 */

/**
 * @param {__import__('json-rpc-engine').JsonRpcRequest<[]>} req - The JSON-RPC request object.
 * @param {__import__('json-rpc-engine').JsonRpcResponse<ProviderStateHandlerResult>} res - The JSON-RPC response object.
 * @param {Function} _next - The json-rpc-engine 'next' callback.
 * @param {Function} end - The json-rpc-engine 'end' callback.
 * @param {ProviderStateHandlerOptions} options
 */

exports.default = _default;

async function getProviderStateHandler(req, res, _next, end, {
  getProviderState: _getProviderState
}) {
  res.result = _objectSpread({}, await _getProviderState(req.origin));
  return end();
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/get-provider-state.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/send-metadata.js", {"../../../../../shared/constants/app":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/app.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/helpers/objectWithoutProperties":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/objectWithoutProperties.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/send-metadata.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _ethRpcErrors = require("eth-rpc-errors");

var _app = require("../../../../../shared/constants/app");

const _excluded = ["icon", "name"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * This internal method is used by our external provider to send metadata about
 * permission subjects so that we can e.g. display a proper name and icon in
 * our UI.
 */
const sendMetadata = {
  methodNames: [_app.MESSAGE_TYPE.SEND_METADATA],
  implementation: sendMetadataHandler,
  hookNames: {
    addSubjectMetadata: true,
    subjectType: true
  }
};
var _default = sendMetadata;
/**
 * @typedef {Record<string, Function>} SendMetadataOptions
 * @property {Function} addSubjectMetadata - A function that records subject
 * metadata, bound to the requesting origin.
 * @property {string} subjectType - The type of the requesting origin / subject.
 */

/**
 * @param {__import__('json-rpc-engine').JsonRpcRequest<unknown>} req - The JSON-RPC request object.
 * @param {__import__('json-rpc-engine').JsonRpcResponse<true>} res - The JSON-RPC response object.
 * @param {Function} _next - The json-rpc-engine 'next' callback.
 * @param {Function} end - The json-rpc-engine 'end' callback.
 * @param {SendMetadataOptions} options
 */

exports.default = _default;

function sendMetadataHandler(req, res, _next, end, {
  addSubjectMetadata,
  subjectType
}) {
  const {
    origin,
    params
  } = req;

  if (params && typeof params === 'object' && !Array.isArray(params)) {
    const {
      icon = null,
      name = null
    } = params,
          remainingParams = (0, _objectWithoutProperties2.default)(params, _excluded);
    addSubjectMetadata(_objectSpread(_objectSpread({}, remainingParams), {}, {
      iconUrl: icon,
      name,
      subjectType,
      origin
    }));
  } else {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      data: params
    }));
  }

  res.result = true;
  return end();
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/send-metadata.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/utils.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/utils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectHooks = exports.isPlainObject = void 0;
function isPlainObject(value) {
    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}
exports.isPlainObject = isPlainObject;
function selectHooks(hooks, hookNames) {
    if (hookNames) {
        return Object.keys(hookNames).reduce((hookSubset, _hookName) => {
            const hookName = _hookName;
            hookSubset[hookName] = hooks[hookName];
            return hookSubset;
        }, {});
    }
    return undefined;
}
exports.selectHooks = selectHooks;
//# sourceMappingURL=utils.js.map
      };
    };
  }
}, {package:"@metamask/rpc-methods",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/restricted/index.js", {"./confirm":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/restricted/confirm.js","./getBip44Entropy":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/restricted/getBip44Entropy.js","./invokeSnap":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/restricted/invokeSnap.js","./manageState":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/restricted/manageState.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/restricted/index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.builders = exports.ManageStateOperation = void 0;
const confirm_1 = require("./confirm");
const getBip44Entropy_1 = require("./getBip44Entropy");
const invokeSnap_1 = require("./invokeSnap");
const manageState_1 = require("./manageState");
var manageState_2 = require("./manageState");
Object.defineProperty(exports, "ManageStateOperation", { enumerable: true, get: function () { return manageState_2.ManageStateOperation; } });
exports.builders = {
    [confirm_1.confirmBuilder.targetKey]: confirm_1.confirmBuilder,
    [getBip44Entropy_1.getBip44EntropyBuilder.targetKey]: getBip44Entropy_1.getBip44EntropyBuilder,
    [invokeSnap_1.invokeSnapBuilder.targetKey]: invokeSnap_1.invokeSnapBuilder,
    [manageState_1.manageStateBuilder.targetKey]: manageState_1.manageStateBuilder,
};
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/rpc-methods",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/restricted/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/index.js", {"./enable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/enable.js","./getAppKey":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/getAppKey.js","./getSnaps":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/getSnaps.js","./installSnaps":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/installSnaps.js","./invokeSnapSugar":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/invokeSnapSugar.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handlers = void 0;
const enable_1 = require("./enable");
const getAppKey_1 = require("./getAppKey");
const getSnaps_1 = require("./getSnaps");
const installSnaps_1 = require("./installSnaps");
const invokeSnapSugar_1 = require("./invokeSnapSugar");
exports.handlers = [
    enable_1.enableWalletHandler,
    getAppKey_1.getAppKeyHandler,
    getSnaps_1.getSnapsHandler,
    installSnaps_1.installSnapsHandler,
    invokeSnapSugar_1.invokeSnapSugarHandler,
];
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/rpc-methods",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-json-patch/node_modules/fast-deep-equal/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-json-patch/node_modules/fast-deep-equal/index.js
      return function (require, module, exports) {
'use strict';

var isArray = Array.isArray;
var keyList = Object.keys;
var hasProp = Object.prototype.hasOwnProperty;

module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    var arrA = isArray(a)
      , arrB = isArray(b)
      , i
      , length
      , key;

    if (arrA && arrB) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }

    if (arrA != arrB) return false;

    var dateA = a instanceof Date
      , dateB = b instanceof Date;
    if (dateA != dateB) return false;
    if (dateA && dateB) return a.getTime() == b.getTime();

    var regexpA = a instanceof RegExp
      , regexpB = b instanceof RegExp;
    if (regexpA != regexpB) return false;
    if (regexpA && regexpB) return a.toString() == b.toString();

    var keys = keyList(a);
    length = keys.length;

    if (length !== keyList(b).length)
      return false;

    for (i = length; i-- !== 0;)
      if (!hasProp.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      key = keys[i];
      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  return a!==a && b!==b;
};

      };
    };
  }
}, {package:"fast-deep-equal",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-json-patch/node_modules/fast-deep-equal/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/concat.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/concat.js
      return function (require, module, exports) {
'use strict'

/**
 * Returns a new Uint8Array created by concatenating the passed ArrayLikes
 *
 * @param {Array<ArrayLike<number>>} arrays
 * @param {number} [length]
 */
function concat (arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0)
  }

  const output = new Uint8Array(length)
  let offset = 0

  for (const arr of arrays) {
    output.set(arr, offset)
    offset += arr.length
  }

  return output
}

module.exports = concat

      };
    };
  }
}, {package:"uint8arrays",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/concat.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/equals.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/equals.js
      return function (require, module, exports) {
'use strict'

/**
 * Returns true if the two passed Uint8Arrays have the same content
 *
 * @param {Uint8Array} a
 * @param {Uint8Array} b
 */
function equals (a, b) {
  if (a === b) {
    return true
  }

  if (a.byteLength !== b.byteLength) {
    return false
  }

  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false
    }
  }

  return true
}

module.exports = equals

      };
    };
  }
}, {package:"uint8arrays",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/equals.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/src/cid-util.js", {"multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/src/cid-util.js
      return function (require, module, exports) {
'use strict'

const mh = require('multihashes')

const CIDUtil = {
  /**
   * Test if the given input is a valid CID object.
   * Returns an error message if it is not.
   * Returns undefined if it is a valid CID.
   *
   * @param {any} other
   * @returns {string|undefined}
   */
  checkCIDComponents: function (other) {
    if (other == null) {
      return 'null values are not valid CIDs'
    }

    if (!(other.version === 0 || other.version === 1)) {
      return 'Invalid version, must be a number equal to 1 or 0'
    }

    if (typeof other.codec !== 'string') {
      return 'codec must be string'
    }

    if (other.version === 0) {
      if (other.codec !== 'dag-pb') {
        return "codec must be 'dag-pb' for CIDv0"
      }
      if (other.multibaseName !== 'base58btc') {
        return "multibaseName must be 'base58btc' for CIDv0"
      }
    }

    if (!(other.multihash instanceof Uint8Array)) {
      return 'multihash must be a Uint8Array'
    }

    try {
      mh.validate(other.multihash)
    } catch (err) {
      let errorMsg = err.message
      if (!errorMsg) { // Just in case mh.validate() throws an error with empty error message
        errorMsg = 'Multihash validation failed'
      }
      return errorMsg
    }
  }
}

module.exports = CIDUtil

      };
    };
  }
}, {package:"cids",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/src/cid-util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/to-string.js", {"multibase":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/to-string.js
      return function (require, module, exports) {
'use strict'

const { encoding: getCodec } = require('multibase')
const utf8Decoder = new TextDecoder('utf8')

/**
 * @typedef {__import__('multibase/src/types').BaseName | 'utf8' | 'utf-8' | 'ascii' | undefined} SupportedEncodings
 */

/**
 * Turns a Uint8Array of bytes into a string with each
 * character being the char code of the corresponding byte
 *
 * @param {Uint8Array} array - The array to turn into a string
 */
function uint8ArrayToAsciiString (array) {
  let string = ''

  for (let i = 0; i < array.length; i++) {
    string += String.fromCharCode(array[i])
  }
  return string
}

/**
 * Turns a `Uint8Array` into a string.
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 *
 * @param {Uint8Array} array - The array to turn into a string
 * @param {SupportedEncodings} [encoding=utf8] - The encoding to use
 * @returns {string}
 */
function toString (array, encoding = 'utf8') {
  if (encoding === 'utf8' || encoding === 'utf-8') {
    return utf8Decoder.decode(array)
  }

  if (encoding === 'ascii') {
    return uint8ArrayToAsciiString(array)
  }

  return getCodec(encoding).encode(array)
}

module.exports = toString

      };
    };
  }
}, {package:"uint8arrays",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/to-string.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/src/index.js", {"./maps":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/src/maps.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/src/util.js","uint8arrays/concat":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/concat.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/src/index.js
      return function (require, module, exports) {
/**
 * Implementation of the multicodec specification.
 *
 * @module multicodec
 * @example
 * const multicodec = require('multicodec')
 *
 * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)
 * // prefixedProtobuf 0x50...
 *
 */
'use strict'

/** @typedef {__import__('./generated-types').CodecName} CodecName */
/** @typedef {__import__('./generated-types').CodecCode} CodecCode */

const varint = require('varint')
const uint8ArrayConcat = require('uint8arrays/concat')
const util = require('./util')
const { nameToVarint, constantToCode, nameToCode, codeToName } = require('./maps')

/**
 * Prefix a buffer with a multicodec-packed.
 *
 * @param {CodecName|Uint8Array} multicodecStrOrCode
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
function addPrefix (multicodecStrOrCode, data) {
  let prefix

  if (multicodecStrOrCode instanceof Uint8Array) {
    prefix = util.varintUint8ArrayEncode(multicodecStrOrCode)
  } else {
    if (nameToVarint[multicodecStrOrCode]) {
      prefix = nameToVarint[multicodecStrOrCode]
    } else {
      throw new Error('multicodec not recognized')
    }
  }

  return uint8ArrayConcat([prefix, data], prefix.length + data.length)
}

/**
 * Decapsulate the multicodec-packed prefix from the data.
 *
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
function rmPrefix (data) {
  varint.decode(/** @type {Buffer} */(data))
  return data.slice(varint.decode.bytes)
}

/**
 * Get the codec name of the prefixed data.
 *
 * @param {Uint8Array} prefixedData
 * @returns {CodecName}
 */
function getNameFromData (prefixedData) {
  const code = /** @type {CodecCode} */(varint.decode(/** @type {Buffer} */(prefixedData)))
  const name = codeToName[code]
  if (name === undefined) {
    throw new Error(`Code "${code}" not found`)
  }
  return name
}

/**
 * Get the codec name from a code.
 *
 * @param {CodecCode} codec
 * @returns {CodecName}
 */
function getNameFromCode (codec) {
  return codeToName[codec]
}

/**
 * Get the code of the codec
 *
 * @param {CodecName} name
 * @returns {CodecCode}
 */
function getCodeFromName (name) {
  const code = nameToCode[name]
  if (code === undefined) {
    throw new Error(`Codec "${name}" not found`)
  }
  return code
}

/**
 * Get the code of the prefixed data.
 *
 * @param {Uint8Array} prefixedData
 * @returns {CodecCode}
 */
function getCodeFromData (prefixedData) {
  return /** @type {CodecCode} */(varint.decode(/** @type {Buffer} */(prefixedData)))
}

/**
 * Get the code as varint of a codec name.
 *
 * @param {CodecName} name
 * @returns {Uint8Array}
 */
function getVarintFromName (name) {
  const code = nameToVarint[name]
  if (code === undefined) {
    throw new Error(`Codec "${name}" not found`)
  }
  return code
}

/**
 * Get the varint of a code.
 *
 * @param {CodecCode} code
 * @returns {Uint8Array}
 */
function getVarintFromCode (code) {
  return util.varintEncode(code)
}

/**
 * Get the codec name of the prefixed data.
 *
 * @deprecated use getNameFromData instead.
 * @param {Uint8Array} prefixedData
 * @returns {CodecName}
 */
function getCodec (prefixedData) {
  return getNameFromData(prefixedData)
}

/**
 * Get the codec name from a code.
 *
 * @deprecated use getNameFromCode instead.
 * @param {CodecCode} codec
 * @returns {CodecName}
 */
function getName (codec) {
  return getNameFromCode(codec)
}

/**
 * Get the code of the codec
 *
 * @deprecated use getCodeFromName instead.
 * @param {CodecName} name
 * @returns {CodecCode}
 */
function getNumber (name) {
  return getCodeFromName(name)
}

/**
 * Get the code of the prefixed data.
 *
 * @deprecated use getCodeFromData instead.
 * @param {Uint8Array} prefixedData
 * @returns {CodecCode}
 */
function getCode (prefixedData) {
  return getCodeFromData(prefixedData)
}

/**
 * Get the code as varint of a codec name.
 *
 * @deprecated use getVarintFromName instead.
 * @param {CodecName} name
 * @returns {Uint8Array}
 */
function getCodeVarint (name) {
  return getVarintFromName(name)
}

/**
 * Get the varint of a code.
 *
 * @deprecated use getVarintFromCode instead.
 * @param {CodecCode} code
 * @returns {Array.<number>}
 */
function getVarint (code) {
  return Array.from(getVarintFromCode(code))
}

module.exports = {
  addPrefix,
  rmPrefix,
  getNameFromData,
  getNameFromCode,
  getCodeFromName,
  getCodeFromData,
  getVarintFromName,
  getVarintFromCode,
  // Deprecated
  getCodec,
  getName,
  getNumber,
  getCode,
  getCodeVarint,
  getVarint,
  // Make the constants top-level constants
  ...constantToCode,
  // Export the maps
  nameToVarint,
  nameToCode,
  codeToName
}

      };
    };
  }
}, {package:"multicodec",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multihashes/src/index.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multihashes/src/constants.js","multibase":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/index.js","uint8arrays/concat":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/concat.js","uint8arrays/from-string":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/from-string.js","uint8arrays/to-string":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/to-string.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multihashes/src/index.js
      return function (require, module, exports) {
/**
 * Multihash implementation in JavaScript.
 */
'use strict'

const multibase = require('multibase')
const varint = require('varint')
const { names } = require('./constants')
const uint8ArrayToString = require('uint8arrays/to-string')
const uint8ArrayFromString = require('uint8arrays/from-string')
const uint8ArrayConcat = require('uint8arrays/concat')

const codes = /** @type {__import__('./types').CodeNameMap} */({})

// eslint-disable-next-line guard-for-in
for (const key in names) {
  const name = /** @type {HashName} */(key)
  codes[names[name]] = name
}
Object.freeze(codes)

/**
 * Convert the given multihash to a hex encoded string.
 *
 * @param {Uint8Array} hash
 * @returns {string}
 */
function toHexString (hash) {
  if (!(hash instanceof Uint8Array)) {
    throw new Error('must be passed a Uint8Array')
  }

  return uint8ArrayToString(hash, 'base16')
}

/**
 * Convert the given hex encoded string to a multihash.
 *
 * @param {string} hash
 * @returns {Uint8Array}
 */
function fromHexString (hash) {
  return uint8ArrayFromString(hash, 'base16')
}

/**
 * Convert the given multihash to a base58 encoded string.
 *
 * @param {Uint8Array} hash
 * @returns {string}
 */
function toB58String (hash) {
  if (!(hash instanceof Uint8Array)) {
    throw new Error('must be passed a Uint8Array')
  }

  return uint8ArrayToString(multibase.encode('base58btc', hash)).slice(1)
}

/**
 * Convert the given base58 encoded string to a multihash.
 *
 * @param {string|Uint8Array} hash
 * @returns {Uint8Array}
 */
function fromB58String (hash) {
  const encoded = hash instanceof Uint8Array
    ? uint8ArrayToString(hash)
    : hash

  return multibase.decode('z' + encoded)
}

/**
 * Decode a hash from the given multihash.
 *
 * @param {Uint8Array} bytes
 * @returns {{code: HashCode, name: HashName, length: number, digest: Uint8Array}} result
 */
function decode (bytes) {
  if (!(bytes instanceof Uint8Array)) {
    throw new Error('multihash must be a Uint8Array')
  }

  if (bytes.length < 2) {
    throw new Error('multihash too short. must be > 2 bytes.')
  }

  const code = /** @type {HashCode} */(varint.decode(bytes))
  if (!isValidCode(code)) {
    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)
  }
  bytes = bytes.slice(varint.decode.bytes)

  const len = varint.decode(bytes)
  if (len < 0) {
    throw new Error(`multihash invalid length: ${len}`)
  }
  bytes = bytes.slice(varint.decode.bytes)

  if (bytes.length !== len) {
    throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, 'base16')}`)
  }

  return {
    code,
    name: codes[code],
    length: len,
    digest: bytes
  }
}

/**
 * Encode a hash digest along with the specified function code.
 *
 * > **Note:** the length is derived from the length of the digest itself.
 *
 * @param {Uint8Array} digest
 * @param {HashName | HashCode} code
 * @param {number} [length]
 * @returns {Uint8Array}
 */
function encode (digest, code, length) {
  if (!digest || code === undefined) {
    throw new Error('multihash encode requires at least two args: digest, code')
  }

  // ensure it's a hashfunction code.
  const hashfn = coerceCode(code)

  if (!(digest instanceof Uint8Array)) {
    throw new Error('digest should be a Uint8Array')
  }

  if (length == null) {
    length = digest.length
  }

  if (length && digest.length !== length) {
    throw new Error('digest length should be equal to specified length.')
  }

  const hash = varint.encode(hashfn)
  const len = varint.encode(length)
  return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length)
}

/**
 * Converts a hash function name into the matching code.
 * If passed a number it will return the number if it's a valid code.
 *
 * @param {HashName | number} name
 * @returns {number}
 */
function coerceCode (name) {
  let code = name

  if (typeof name === 'string') {
    if (names[name] === undefined) {
      throw new Error(`Unrecognized hash function named: ${name}`)
    }
    code = names[name]
  }

  if (typeof code !== 'number') {
    throw new Error(`Hash function code should be a number. Got: ${code}`)
  }

  // @ts-ignore
  if (codes[code] === undefined && !isAppCode(code)) {
    throw new Error(`Unrecognized function code: ${code}`)
  }

  return code
}

/**
 * Checks if a code is part of the app range
 *
 * @param {number} code
 * @returns {boolean}
 */
function isAppCode (code) {
  return code > 0 && code < 0x10
}

/**
 * Checks whether a multihash code is valid.
 *
 * @param {HashCode} code
 * @returns {boolean}
 */
function isValidCode (code) {
  if (isAppCode(code)) {
    return true
  }

  if (codes[code]) {
    return true
  }

  return false
}

/**
 * Check if the given buffer is a valid multihash. Throws an error if it is not valid.
 *
 * @param {Uint8Array} multihash
 * @returns {void}
 * @throws {Error}
 */
function validate (multihash) {
  decode(multihash) // throws if bad.
}

/**
 * Returns a prefix from a valid multihash. Throws an error if it is not valid.
 *
 * @param {Uint8Array} multihash
 * @returns {Uint8Array}
 * @throws {Error}
 */
function prefix (multihash) {
  validate(multihash)

  return multihash.subarray(0, 2)
}

module.exports = {
  names,
  codes,
  toHexString,
  fromHexString,
  toB58String,
  fromB58String,
  decode,
  encode,
  coerceCode,
  isAppCode,
  validate,
  prefix,
  isValidCode
}

/**
 * @typedef { __import__("./constants").HashCode } HashCode
 * @typedef { __import__("./constants").HashName } HashName
 */

      };
    };
  }
}, {package:"multihashes",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multihashes/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/index.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/constants.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/index.js
      return function (require, module, exports) {
/**
 * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
 *
 */
'use strict'

const constants = require('./constants')
const { encodeText, decodeText, concat } = require('./util')

/** @typedef {__import__('./base')} Base */
/** @typedef {__import__("./types").BaseNameOrCode} BaseNameOrCode */
/** @typedef {__import__("./types").BaseCode} BaseCode */
/** @typedef {__import__("./types").BaseName} BaseName */

/**
 * Create a new Uint8Array with the multibase varint+code.
 *
 * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be prefixed with multibase.
 * @returns {Uint8Array}
 * @throws {Error} Will throw if the encoding is not supported
 */
function multibase (nameOrCode, buf) {
  if (!buf) {
    throw new Error('requires an encoded Uint8Array')
  }
  const { name, codeBuf } = encoding(nameOrCode)
  validEncode(name, buf)

  return concat([codeBuf, buf], codeBuf.length + buf.length)
}

/**
 * Encode data with the specified base and add the multibase prefix.
 *
 * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be encoded.
 * @returns {Uint8Array}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */
function encode (nameOrCode, buf) {
  const enc = encoding(nameOrCode)
  const data = encodeText(enc.encode(buf))

  return concat([enc.codeBuf, data], enc.codeBuf.length + data.length)
}

/**
 * Takes a Uint8Array or string encoded with multibase header, decodes it and
 * returns the decoded buffer
 *
 * @param {Uint8Array|string} data
 * @returns {Uint8Array}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */
function decode (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }
  const prefix = data[0]

  // Make all encodings case-insensitive except the ones that include upper and lower chars in the alphabet
  if (['f', 'F', 'v', 'V', 't', 'T', 'b', 'B', 'c', 'C', 'h', 'k', 'K'].includes(prefix)) {
    data = data.toLowerCase()
  }
  const enc = encoding(/** @type {BaseCode} */(data[0]))
  return enc.decode(data.substring(1))
}

/**
 * Is the given data multibase encoded?
 *
 * @param {Uint8Array|string} data
 */
function isEncoded (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }

  // Ensure bufOrString is a string
  if (Object.prototype.toString.call(data) !== '[object String]') {
    return false
  }

  try {
    const enc = encoding(/** @type {BaseCode} */(data[0]))
    return enc.name
  } catch (err) {
    return false
  }
}

/**
 * Validate encoded data
 *
 * @param {BaseNameOrCode} name
 * @param {Uint8Array} buf
 * @returns {void}
 * @throws {Error} Will throw if the encoding is not supported
 */
function validEncode (name, buf) {
  const enc = encoding(name)
  enc.decode(decodeText(buf))
}

/**
 * Get the encoding by name or code
 *
 * @param {BaseNameOrCode} nameOrCode
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */
function encoding (nameOrCode) {
  if (Object.prototype.hasOwnProperty.call(constants.names, /** @type {BaseName} */(nameOrCode))) {
    return constants.names[/** @type {BaseName} */(nameOrCode)]
  } else if (Object.prototype.hasOwnProperty.call(constants.codes, /** @type {BaseCode} */(nameOrCode))) {
    return constants.codes[/** @type {BaseCode} */(nameOrCode)]
  } else {
    throw new Error(`Unsupported encoding: ${nameOrCode}`)
  }
}

/**
 * Get encoding from data
 *
 * @param {string|Uint8Array} data
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */
function encodingFromData (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }

  return encoding(/** @type {BaseCode} */(data[0]))
}

exports = module.exports = multibase
exports.encode = encode
exports.decode = decode
exports.isEncoded = isEncoded
exports.encoding = encoding
exports.encodingFromData = encodingFromData
const names = Object.freeze(constants.names)
const codes = Object.freeze(constants.codes)
exports.names = names
exports.codes = codes

      };
    };
  }
}, {package:"multibase",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/encode.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/encode.js
      return function (require, module, exports) {
module.exports = encode

var MSB = 0x80
  , REST = 0x7F
  , MSBALL = ~REST
  , INT = Math.pow(2, 31)

function encode(num, out, offset) {
  out = out || []
  offset = offset || 0
  var oldOffset = offset

  while(num >= INT) {
    out[offset++] = (num & 0xFF) | MSB
    num /= 128
  }
  while(num & MSBALL) {
    out[offset++] = (num & 0xFF) | MSB
    num >>>= 7
  }
  out[offset] = num | 0
  
  encode.bytes = offset - oldOffset + 1
  
  return out
}

      };
    };
  }
}, {package:"varint",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/encode.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/decode.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/decode.js
      return function (require, module, exports) {
module.exports = read

var MSB = 0x80
  , REST = 0x7F

function read(buf, offset) {
  var res    = 0
    , offset = offset || 0
    , shift  = 0
    , counter = offset
    , b
    , l = buf.length

  do {
    if (counter >= l) {
      read.bytes = 0
      throw new RangeError('Could not decode varint')
    }
    b = buf[counter++]
    res += shift < 28
      ? (b & REST) << shift
      : (b & REST) * Math.pow(2, shift)
    shift += 7
  } while (b >= MSB)

  read.bytes = counter - offset

  return res
}

      };
    };
  }
}, {package:"varint",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/decode.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/length.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/length.js
      return function (require, module, exports) {

var N1 = Math.pow(2,  7)
var N2 = Math.pow(2, 14)
var N3 = Math.pow(2, 21)
var N4 = Math.pow(2, 28)
var N5 = Math.pow(2, 35)
var N6 = Math.pow(2, 42)
var N7 = Math.pow(2, 49)
var N8 = Math.pow(2, 56)
var N9 = Math.pow(2, 63)

module.exports = function (value) {
  return (
    value < N1 ? 1
  : value < N2 ? 2
  : value < N3 ? 3
  : value < N4 ? 4
  : value < N5 ? 5
  : value < N6 ? 6
  : value < N7 ? 7
  : value < N8 ? 8
  : value < N9 ? 9
  :              10
  )
}

      };
    };
  }
}, {package:"varint",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/length.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/constants.js", {"./base.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/base.js","./rfc4648":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/rfc4648.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/util.js","base-x":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/base-x/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/constants.js
      return function (require, module, exports) {
// @ts-check
'use strict'

const baseX = require('base-x')
const Base = require('./base.js')
const rfc4648 = require('./rfc4648')
const { decodeText, encodeText } = require('./util')

const identity = () => {
  return {
    encode: decodeText,
    decode: encodeText
  }
}

/**
 * @typedef {__import__('./base').CodecFactory} CodecFactory
 *
 * name, code, implementation, alphabet
 * @type {Array<[string, string, CodecFactory, string]>}
 */
const constants = [
  ['identity', '\x00', identity, ''],
  ['base2', '0', rfc4648(1), '01'],
  ['base8', '7', rfc4648(3), '01234567'],
  ['base10', '9', baseX, '0123456789'],
  ['base16', 'f', rfc4648(4), '0123456789abcdef'],
  ['base16upper', 'F', rfc4648(4), '0123456789ABCDEF'],
  ['base32hex', 'v', rfc4648(5), '0123456789abcdefghijklmnopqrstuv'],
  ['base32hexupper', 'V', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV'],
  ['base32hexpad', 't', rfc4648(5), '0123456789abcdefghijklmnopqrstuv='],
  ['base32hexpadupper', 'T', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV='],
  ['base32', 'b', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567'],
  ['base32upper', 'B', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'],
  ['base32pad', 'c', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567='],
  ['base32padupper', 'C', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='],
  ['base32z', 'h', rfc4648(5), 'ybndrfg8ejkmcpqxot1uwisza345h769'],
  ['base36', 'k', baseX, '0123456789abcdefghijklmnopqrstuvwxyz'],
  ['base36upper', 'K', baseX, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'],
  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
  ['base64', 'm', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
  ['base64pad', 'M', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
  ['base64url', 'u', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
  ['base64urlpad', 'U', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
]

const names = constants.reduce((prev, tupple) => {
  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
  return prev
}, {})

const codes = constants.reduce((prev, tupple) => {
  prev[tupple[1]] = names[tupple[0]]
  return prev
}, {})

module.exports = {
  names,
  codes
}

      };
    };
  }
}, {package:"multibase",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/util.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","web-encoding":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/web-encoding/src/lib.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/util.js
      return function (require, module, exports) {
// @ts-check
'use strict'

const { Buffer } = require('buffer')
const { TextEncoder, TextDecoder } = require('web-encoding')

const textDecoder = new TextDecoder()
/**
 * @param {ArrayBufferView|ArrayBuffer} bytes
 * @returns {string}
 */
const decodeText = (bytes) => textDecoder.decode(bytes)

const textEncoder = new TextEncoder()
/**
 * @param {string} text
 * @returns {Uint8Array}
 */
const encodeText = (text) => textEncoder.encode(text)

/**
 * @param {ArrayBufferView} bytes
 * @returns {Buffer}
 */
const asBuffer = ({ buffer, byteLength, byteOffset }) =>
  Buffer.from(buffer, byteOffset, byteLength)

module.exports = { decodeText, encodeText, asBuffer }

      };
    };
  }
}, {package:"multibase",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/base-table.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/base-table.js
      return function (require, module, exports) {
// DO NOT CHANGE THIS FILE. IT IS GENERATED BY tools/update-table.js
/* eslint quote-props: off */
'use strict'

/**
 * @type {__import__('./generated-types').NameNumberMap}
 */
const baseTable = Object.freeze({
  'identity': 0x00,
  'cidv1': 0x01,
  'cidv2': 0x02,
  'cidv3': 0x03,
  'ip4': 0x04,
  'tcp': 0x06,
  'sha1': 0x11,
  'sha2-256': 0x12,
  'sha2-512': 0x13,
  'sha3-512': 0x14,
  'sha3-384': 0x15,
  'sha3-256': 0x16,
  'sha3-224': 0x17,
  'shake-128': 0x18,
  'shake-256': 0x19,
  'keccak-224': 0x1a,
  'keccak-256': 0x1b,
  'keccak-384': 0x1c,
  'keccak-512': 0x1d,
  'blake3': 0x1e,
  'dccp': 0x21,
  'murmur3-128': 0x22,
  'murmur3-32': 0x23,
  'ip6': 0x29,
  'ip6zone': 0x2a,
  'path': 0x2f,
  'multicodec': 0x30,
  'multihash': 0x31,
  'multiaddr': 0x32,
  'multibase': 0x33,
  'dns': 0x35,
  'dns4': 0x36,
  'dns6': 0x37,
  'dnsaddr': 0x38,
  'protobuf': 0x50,
  'cbor': 0x51,
  'raw': 0x55,
  'dbl-sha2-256': 0x56,
  'rlp': 0x60,
  'bencode': 0x63,
  'dag-pb': 0x70,
  'dag-cbor': 0x71,
  'libp2p-key': 0x72,
  'git-raw': 0x78,
  'torrent-info': 0x7b,
  'torrent-file': 0x7c,
  'leofcoin-block': 0x81,
  'leofcoin-tx': 0x82,
  'leofcoin-pr': 0x83,
  'sctp': 0x84,
  'dag-jose': 0x85,
  'dag-cose': 0x86,
  'eth-block': 0x90,
  'eth-block-list': 0x91,
  'eth-tx-trie': 0x92,
  'eth-tx': 0x93,
  'eth-tx-receipt-trie': 0x94,
  'eth-tx-receipt': 0x95,
  'eth-state-trie': 0x96,
  'eth-account-snapshot': 0x97,
  'eth-storage-trie': 0x98,
  'bitcoin-block': 0xb0,
  'bitcoin-tx': 0xb1,
  'bitcoin-witness-commitment': 0xb2,
  'zcash-block': 0xc0,
  'zcash-tx': 0xc1,
  'docid': 0xce,
  'stellar-block': 0xd0,
  'stellar-tx': 0xd1,
  'md4': 0xd4,
  'md5': 0xd5,
  'bmt': 0xd6,
  'decred-block': 0xe0,
  'decred-tx': 0xe1,
  'ipld-ns': 0xe2,
  'ipfs-ns': 0xe3,
  'swarm-ns': 0xe4,
  'ipns-ns': 0xe5,
  'zeronet': 0xe6,
  'secp256k1-pub': 0xe7,
  'bls12_381-g1-pub': 0xea,
  'bls12_381-g2-pub': 0xeb,
  'x25519-pub': 0xec,
  'ed25519-pub': 0xed,
  'bls12_381-g1g2-pub': 0xee,
  'dash-block': 0xf0,
  'dash-tx': 0xf1,
  'swarm-manifest': 0xfa,
  'swarm-feed': 0xfb,
  'udp': 0x0111,
  'p2p-webrtc-star': 0x0113,
  'p2p-webrtc-direct': 0x0114,
  'p2p-stardust': 0x0115,
  'p2p-circuit': 0x0122,
  'dag-json': 0x0129,
  'udt': 0x012d,
  'utp': 0x012e,
  'unix': 0x0190,
  'p2p': 0x01a5,
  'ipfs': 0x01a5,
  'https': 0x01bb,
  'onion': 0x01bc,
  'onion3': 0x01bd,
  'garlic64': 0x01be,
  'garlic32': 0x01bf,
  'tls': 0x01c0,
  'quic': 0x01cc,
  'ws': 0x01dd,
  'wss': 0x01de,
  'p2p-websocket-star': 0x01df,
  'http': 0x01e0,
  'json': 0x0200,
  'messagepack': 0x0201,
  'libp2p-peer-record': 0x0301,
  'sha2-256-trunc254-padded': 0x1012,
  'ripemd-128': 0x1052,
  'ripemd-160': 0x1053,
  'ripemd-256': 0x1054,
  'ripemd-320': 0x1055,
  'x11': 0x1100,
  'p256-pub': 0x1200,
  'p384-pub': 0x1201,
  'p521-pub': 0x1202,
  'ed448-pub': 0x1203,
  'x448-pub': 0x1204,
  'ed25519-priv': 0x1300,
  'kangarootwelve': 0x1d01,
  'sm3-256': 0x534d,
  'blake2b-8': 0xb201,
  'blake2b-16': 0xb202,
  'blake2b-24': 0xb203,
  'blake2b-32': 0xb204,
  'blake2b-40': 0xb205,
  'blake2b-48': 0xb206,
  'blake2b-56': 0xb207,
  'blake2b-64': 0xb208,
  'blake2b-72': 0xb209,
  'blake2b-80': 0xb20a,
  'blake2b-88': 0xb20b,
  'blake2b-96': 0xb20c,
  'blake2b-104': 0xb20d,
  'blake2b-112': 0xb20e,
  'blake2b-120': 0xb20f,
  'blake2b-128': 0xb210,
  'blake2b-136': 0xb211,
  'blake2b-144': 0xb212,
  'blake2b-152': 0xb213,
  'blake2b-160': 0xb214,
  'blake2b-168': 0xb215,
  'blake2b-176': 0xb216,
  'blake2b-184': 0xb217,
  'blake2b-192': 0xb218,
  'blake2b-200': 0xb219,
  'blake2b-208': 0xb21a,
  'blake2b-216': 0xb21b,
  'blake2b-224': 0xb21c,
  'blake2b-232': 0xb21d,
  'blake2b-240': 0xb21e,
  'blake2b-248': 0xb21f,
  'blake2b-256': 0xb220,
  'blake2b-264': 0xb221,
  'blake2b-272': 0xb222,
  'blake2b-280': 0xb223,
  'blake2b-288': 0xb224,
  'blake2b-296': 0xb225,
  'blake2b-304': 0xb226,
  'blake2b-312': 0xb227,
  'blake2b-320': 0xb228,
  'blake2b-328': 0xb229,
  'blake2b-336': 0xb22a,
  'blake2b-344': 0xb22b,
  'blake2b-352': 0xb22c,
  'blake2b-360': 0xb22d,
  'blake2b-368': 0xb22e,
  'blake2b-376': 0xb22f,
  'blake2b-384': 0xb230,
  'blake2b-392': 0xb231,
  'blake2b-400': 0xb232,
  'blake2b-408': 0xb233,
  'blake2b-416': 0xb234,
  'blake2b-424': 0xb235,
  'blake2b-432': 0xb236,
  'blake2b-440': 0xb237,
  'blake2b-448': 0xb238,
  'blake2b-456': 0xb239,
  'blake2b-464': 0xb23a,
  'blake2b-472': 0xb23b,
  'blake2b-480': 0xb23c,
  'blake2b-488': 0xb23d,
  'blake2b-496': 0xb23e,
  'blake2b-504': 0xb23f,
  'blake2b-512': 0xb240,
  'blake2s-8': 0xb241,
  'blake2s-16': 0xb242,
  'blake2s-24': 0xb243,
  'blake2s-32': 0xb244,
  'blake2s-40': 0xb245,
  'blake2s-48': 0xb246,
  'blake2s-56': 0xb247,
  'blake2s-64': 0xb248,
  'blake2s-72': 0xb249,
  'blake2s-80': 0xb24a,
  'blake2s-88': 0xb24b,
  'blake2s-96': 0xb24c,
  'blake2s-104': 0xb24d,
  'blake2s-112': 0xb24e,
  'blake2s-120': 0xb24f,
  'blake2s-128': 0xb250,
  'blake2s-136': 0xb251,
  'blake2s-144': 0xb252,
  'blake2s-152': 0xb253,
  'blake2s-160': 0xb254,
  'blake2s-168': 0xb255,
  'blake2s-176': 0xb256,
  'blake2s-184': 0xb257,
  'blake2s-192': 0xb258,
  'blake2s-200': 0xb259,
  'blake2s-208': 0xb25a,
  'blake2s-216': 0xb25b,
  'blake2s-224': 0xb25c,
  'blake2s-232': 0xb25d,
  'blake2s-240': 0xb25e,
  'blake2s-248': 0xb25f,
  'blake2s-256': 0xb260,
  'skein256-8': 0xb301,
  'skein256-16': 0xb302,
  'skein256-24': 0xb303,
  'skein256-32': 0xb304,
  'skein256-40': 0xb305,
  'skein256-48': 0xb306,
  'skein256-56': 0xb307,
  'skein256-64': 0xb308,
  'skein256-72': 0xb309,
  'skein256-80': 0xb30a,
  'skein256-88': 0xb30b,
  'skein256-96': 0xb30c,
  'skein256-104': 0xb30d,
  'skein256-112': 0xb30e,
  'skein256-120': 0xb30f,
  'skein256-128': 0xb310,
  'skein256-136': 0xb311,
  'skein256-144': 0xb312,
  'skein256-152': 0xb313,
  'skein256-160': 0xb314,
  'skein256-168': 0xb315,
  'skein256-176': 0xb316,
  'skein256-184': 0xb317,
  'skein256-192': 0xb318,
  'skein256-200': 0xb319,
  'skein256-208': 0xb31a,
  'skein256-216': 0xb31b,
  'skein256-224': 0xb31c,
  'skein256-232': 0xb31d,
  'skein256-240': 0xb31e,
  'skein256-248': 0xb31f,
  'skein256-256': 0xb320,
  'skein512-8': 0xb321,
  'skein512-16': 0xb322,
  'skein512-24': 0xb323,
  'skein512-32': 0xb324,
  'skein512-40': 0xb325,
  'skein512-48': 0xb326,
  'skein512-56': 0xb327,
  'skein512-64': 0xb328,
  'skein512-72': 0xb329,
  'skein512-80': 0xb32a,
  'skein512-88': 0xb32b,
  'skein512-96': 0xb32c,
  'skein512-104': 0xb32d,
  'skein512-112': 0xb32e,
  'skein512-120': 0xb32f,
  'skein512-128': 0xb330,
  'skein512-136': 0xb331,
  'skein512-144': 0xb332,
  'skein512-152': 0xb333,
  'skein512-160': 0xb334,
  'skein512-168': 0xb335,
  'skein512-176': 0xb336,
  'skein512-184': 0xb337,
  'skein512-192': 0xb338,
  'skein512-200': 0xb339,
  'skein512-208': 0xb33a,
  'skein512-216': 0xb33b,
  'skein512-224': 0xb33c,
  'skein512-232': 0xb33d,
  'skein512-240': 0xb33e,
  'skein512-248': 0xb33f,
  'skein512-256': 0xb340,
  'skein512-264': 0xb341,
  'skein512-272': 0xb342,
  'skein512-280': 0xb343,
  'skein512-288': 0xb344,
  'skein512-296': 0xb345,
  'skein512-304': 0xb346,
  'skein512-312': 0xb347,
  'skein512-320': 0xb348,
  'skein512-328': 0xb349,
  'skein512-336': 0xb34a,
  'skein512-344': 0xb34b,
  'skein512-352': 0xb34c,
  'skein512-360': 0xb34d,
  'skein512-368': 0xb34e,
  'skein512-376': 0xb34f,
  'skein512-384': 0xb350,
  'skein512-392': 0xb351,
  'skein512-400': 0xb352,
  'skein512-408': 0xb353,
  'skein512-416': 0xb354,
  'skein512-424': 0xb355,
  'skein512-432': 0xb356,
  'skein512-440': 0xb357,
  'skein512-448': 0xb358,
  'skein512-456': 0xb359,
  'skein512-464': 0xb35a,
  'skein512-472': 0xb35b,
  'skein512-480': 0xb35c,
  'skein512-488': 0xb35d,
  'skein512-496': 0xb35e,
  'skein512-504': 0xb35f,
  'skein512-512': 0xb360,
  'skein1024-8': 0xb361,
  'skein1024-16': 0xb362,
  'skein1024-24': 0xb363,
  'skein1024-32': 0xb364,
  'skein1024-40': 0xb365,
  'skein1024-48': 0xb366,
  'skein1024-56': 0xb367,
  'skein1024-64': 0xb368,
  'skein1024-72': 0xb369,
  'skein1024-80': 0xb36a,
  'skein1024-88': 0xb36b,
  'skein1024-96': 0xb36c,
  'skein1024-104': 0xb36d,
  'skein1024-112': 0xb36e,
  'skein1024-120': 0xb36f,
  'skein1024-128': 0xb370,
  'skein1024-136': 0xb371,
  'skein1024-144': 0xb372,
  'skein1024-152': 0xb373,
  'skein1024-160': 0xb374,
  'skein1024-168': 0xb375,
  'skein1024-176': 0xb376,
  'skein1024-184': 0xb377,
  'skein1024-192': 0xb378,
  'skein1024-200': 0xb379,
  'skein1024-208': 0xb37a,
  'skein1024-216': 0xb37b,
  'skein1024-224': 0xb37c,
  'skein1024-232': 0xb37d,
  'skein1024-240': 0xb37e,
  'skein1024-248': 0xb37f,
  'skein1024-256': 0xb380,
  'skein1024-264': 0xb381,
  'skein1024-272': 0xb382,
  'skein1024-280': 0xb383,
  'skein1024-288': 0xb384,
  'skein1024-296': 0xb385,
  'skein1024-304': 0xb386,
  'skein1024-312': 0xb387,
  'skein1024-320': 0xb388,
  'skein1024-328': 0xb389,
  'skein1024-336': 0xb38a,
  'skein1024-344': 0xb38b,
  'skein1024-352': 0xb38c,
  'skein1024-360': 0xb38d,
  'skein1024-368': 0xb38e,
  'skein1024-376': 0xb38f,
  'skein1024-384': 0xb390,
  'skein1024-392': 0xb391,
  'skein1024-400': 0xb392,
  'skein1024-408': 0xb393,
  'skein1024-416': 0xb394,
  'skein1024-424': 0xb395,
  'skein1024-432': 0xb396,
  'skein1024-440': 0xb397,
  'skein1024-448': 0xb398,
  'skein1024-456': 0xb399,
  'skein1024-464': 0xb39a,
  'skein1024-472': 0xb39b,
  'skein1024-480': 0xb39c,
  'skein1024-488': 0xb39d,
  'skein1024-496': 0xb39e,
  'skein1024-504': 0xb39f,
  'skein1024-512': 0xb3a0,
  'skein1024-520': 0xb3a1,
  'skein1024-528': 0xb3a2,
  'skein1024-536': 0xb3a3,
  'skein1024-544': 0xb3a4,
  'skein1024-552': 0xb3a5,
  'skein1024-560': 0xb3a6,
  'skein1024-568': 0xb3a7,
  'skein1024-576': 0xb3a8,
  'skein1024-584': 0xb3a9,
  'skein1024-592': 0xb3aa,
  'skein1024-600': 0xb3ab,
  'skein1024-608': 0xb3ac,
  'skein1024-616': 0xb3ad,
  'skein1024-624': 0xb3ae,
  'skein1024-632': 0xb3af,
  'skein1024-640': 0xb3b0,
  'skein1024-648': 0xb3b1,
  'skein1024-656': 0xb3b2,
  'skein1024-664': 0xb3b3,
  'skein1024-672': 0xb3b4,
  'skein1024-680': 0xb3b5,
  'skein1024-688': 0xb3b6,
  'skein1024-696': 0xb3b7,
  'skein1024-704': 0xb3b8,
  'skein1024-712': 0xb3b9,
  'skein1024-720': 0xb3ba,
  'skein1024-728': 0xb3bb,
  'skein1024-736': 0xb3bc,
  'skein1024-744': 0xb3bd,
  'skein1024-752': 0xb3be,
  'skein1024-760': 0xb3bf,
  'skein1024-768': 0xb3c0,
  'skein1024-776': 0xb3c1,
  'skein1024-784': 0xb3c2,
  'skein1024-792': 0xb3c3,
  'skein1024-800': 0xb3c4,
  'skein1024-808': 0xb3c5,
  'skein1024-816': 0xb3c6,
  'skein1024-824': 0xb3c7,
  'skein1024-832': 0xb3c8,
  'skein1024-840': 0xb3c9,
  'skein1024-848': 0xb3ca,
  'skein1024-856': 0xb3cb,
  'skein1024-864': 0xb3cc,
  'skein1024-872': 0xb3cd,
  'skein1024-880': 0xb3ce,
  'skein1024-888': 0xb3cf,
  'skein1024-896': 0xb3d0,
  'skein1024-904': 0xb3d1,
  'skein1024-912': 0xb3d2,
  'skein1024-920': 0xb3d3,
  'skein1024-928': 0xb3d4,
  'skein1024-936': 0xb3d5,
  'skein1024-944': 0xb3d6,
  'skein1024-952': 0xb3d7,
  'skein1024-960': 0xb3d8,
  'skein1024-968': 0xb3d9,
  'skein1024-976': 0xb3da,
  'skein1024-984': 0xb3db,
  'skein1024-992': 0xb3dc,
  'skein1024-1000': 0xb3dd,
  'skein1024-1008': 0xb3de,
  'skein1024-1016': 0xb3df,
  'skein1024-1024': 0xb3e0,
  'poseidon-bls12_381-a2-fc1': 0xb401,
  'poseidon-bls12_381-a2-fc1-sc': 0xb402,
  'zeroxcert-imprint-256': 0xce11,
  'fil-commitment-unsealed': 0xf101,
  'fil-commitment-sealed': 0xf102,
  'holochain-adr-v0': 0x807124,
  'holochain-adr-v1': 0x817124,
  'holochain-key-v0': 0x947124,
  'holochain-key-v1': 0x957124,
  'holochain-sig-v0': 0xa27124,
  'holochain-sig-v1': 0xa37124,
  'skynet-ns': 0xb19910
})

module.exports = { baseTable }

      };
    };
  }
}, {package:"multicodec",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/base-table.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/node_modules/varint/encode.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/node_modules/varint/encode.js
      return function (require, module, exports) {
module.exports = encode

var MSB = 0x80
  , REST = 0x7F
  , MSBALL = ~REST
  , INT = Math.pow(2, 31)

function encode(num, out, offset) {
  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
    encode.bytes = 0
    throw new RangeError('Could not encode varint')
  }
  out = out || []
  offset = offset || 0
  var oldOffset = offset

  while(num >= INT) {
    out[offset++] = (num & 0xFF) | MSB
    num /= 128
  }
  while(num & MSBALL) {
    out[offset++] = (num & 0xFF) | MSB
    num >>>= 7
  }
  out[offset] = num | 0
  
  encode.bytes = offset - oldOffset + 1
  
  return out
}

      };
    };
  }
}, {package:"varint",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/node_modules/varint/encode.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/node_modules/varint/length.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/node_modules/varint/length.js
      return function (require, module, exports) {

var N1 = Math.pow(2,  7)
var N2 = Math.pow(2, 14)
var N3 = Math.pow(2, 21)
var N4 = Math.pow(2, 28)
var N5 = Math.pow(2, 35)
var N6 = Math.pow(2, 42)
var N7 = Math.pow(2, 49)
var N8 = Math.pow(2, 56)
var N9 = Math.pow(2, 63)

module.exports = function (value) {
  return (
    value < N1 ? 1
  : value < N2 ? 2
  : value < N3 ? 3
  : value < N4 ? 4
  : value < N5 ? 5
  : value < N6 ? 6
  : value < N7 ? 7
  : value < N8 ? 8
  : value < N9 ? 9
  :              10
  )
}

      };
    };
  }
}, {package:"varint",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/node_modules/varint/length.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/node_modules/varint/decode.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/node_modules/varint/decode.js
      return function (require, module, exports) {
module.exports = read

var MSB = 0x80
  , REST = 0x7F

function read(buf, offset) {
  var res    = 0
    , offset = offset || 0
    , shift  = 0
    , counter = offset
    , b
    , l = buf.length

  do {
    if (counter >= l || shift > 49) {
      read.bytes = 0
      throw new RangeError('Could not decode varint')
    }
    b = buf[counter++]
    res += shift < 28
      ? (b & REST) << shift
      : (b & REST) * Math.pow(2, shift)
    shift += 7
  } while (b >= MSB)

  read.bytes = counter - offset

  return res
}

      };
    };
  }
}, {package:"varint",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/node_modules/varint/decode.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/from-string.js", {"multibase/src/constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/node_modules/multibase/src/constants.js","web-encoding":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/web-encoding/src/lib.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/from-string.js
      return function (require, module, exports) {
'use strict'

const { names } = require('multibase/src/constants')
const { TextEncoder } = require('web-encoding')
const utf8Encoder = new TextEncoder()

/**
 * Interperets each character in a string as a byte and
 * returns a Uint8Array of those bytes.
 *
 * @param {String} string The string to turn into an array
 * @returns {Uint8Array}
 */
function asciiStringToUint8Array (string) {
  const array = new Uint8Array(string.length)

  for (let i = 0; i < string.length; i++) {
    array[i] = string.charCodeAt(i)
  }

  return array
}

/**
 * Create a `Uint8Array` from the passed string
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 *
 * @param {String} string
 * @param {String} [encoding=utf8] utf8, base16, base64, base64urlpad, etc
 * @returns {Uint8Array}
 * @see {@link https://www.npmjs.com/package/multibase|multibase} for supported encodings other than `utf8`
 */
function fromString (string, encoding = 'utf8') {
  if (encoding === 'utf8' || encoding === 'utf-8') {
    return utf8Encoder.encode(string)
  }

  if (encoding === 'ascii') {
    return asciiStringToUint8Array(string)
  }

  const codec = names[encoding]

  if (!codec) {
    throw new Error('Unknown base')
  }

  return codec.decode(string)
}

module.exports = fromString

      };
    };
  }
}, {package:"uint8arrays",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/from-string.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/to-string.js", {"multibase/src/constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/node_modules/multibase/src/constants.js","web-encoding":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/web-encoding/src/lib.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/to-string.js
      return function (require, module, exports) {
'use strict'

const { names } = require('multibase/src/constants')
const { TextDecoder } = require('web-encoding')
const utf8Decoder = new TextDecoder('utf8')

/**
 * Turns a Uint8Array of bytes into a string with each
 * character being the char code of the corresponding byte
 *
 * @param {Uint8Array} array The array to turn into a string
 * @returns {String}
 */
function uint8ArrayToAsciiString (array) {
  let string = ''

  for (let i = 0; i < array.length; i++) {
    string += String.fromCharCode(array[i])
  }
  return string
}

/**
 * Turns a `Uint8Array` into a string.
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 *
 * @param {Uint8Array} array The array to turn into a string
 * @param {String} [encoding=utf8] The encoding to use
 * @returns {String}
 * @see {@link https://www.npmjs.com/package/multibase|multibase} for supported encodings other than `utf8`
 */
function toString (array, encoding = 'utf8') {
  if (encoding === 'utf8' || encoding === 'utf-8') {
    return utf8Decoder.decode(array)
  }

  if (encoding === 'ascii') {
    return uint8ArrayToAsciiString(array)
  }

  const codec = names[encoding]

  if (!codec) {
    throw new Error('Unknown base')
  }

  return codec.encode(array)
}

module.exports = toString

      };
    };
  }
}, {package:"uint8arrays",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/to-string.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-retry-allowed/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/is-retry-allowed/index.js
      return function (require, module, exports) {
'use strict';

var WHITELIST = [
	'ETIMEDOUT',
	'ECONNRESET',
	'EADDRINUSE',
	'ESOCKETTIMEDOUT',
	'ECONNREFUSED',
	'EPIPE',
	'EHOSTUNREACH',
	'EAI_AGAIN'
];

var BLACKLIST = [
	'ENOTFOUND',
	'ENETUNREACH',

	// SSL errors from https://github.com/nodejs/node/blob/ed3d8b13ee9a705d89f9e0397d9e96519e7e47ac/src/node_crypto.cc#L1950
	'UNABLE_TO_GET_ISSUER_CERT',
	'UNABLE_TO_GET_CRL',
	'UNABLE_TO_DECRYPT_CERT_SIGNATURE',
	'UNABLE_TO_DECRYPT_CRL_SIGNATURE',
	'UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY',
	'CERT_SIGNATURE_FAILURE',
	'CRL_SIGNATURE_FAILURE',
	'CERT_NOT_YET_VALID',
	'CERT_HAS_EXPIRED',
	'CRL_NOT_YET_VALID',
	'CRL_HAS_EXPIRED',
	'ERROR_IN_CERT_NOT_BEFORE_FIELD',
	'ERROR_IN_CERT_NOT_AFTER_FIELD',
	'ERROR_IN_CRL_LAST_UPDATE_FIELD',
	'ERROR_IN_CRL_NEXT_UPDATE_FIELD',
	'OUT_OF_MEM',
	'DEPTH_ZERO_SELF_SIGNED_CERT',
	'SELF_SIGNED_CERT_IN_CHAIN',
	'UNABLE_TO_GET_ISSUER_CERT_LOCALLY',
	'UNABLE_TO_VERIFY_LEAF_SIGNATURE',
	'CERT_CHAIN_TOO_LONG',
	'CERT_REVOKED',
	'INVALID_CA',
	'PATH_LENGTH_EXCEEDED',
	'INVALID_PURPOSE',
	'CERT_UNTRUSTED',
	'CERT_REJECTED'
];

module.exports = function (err) {
	if (!err || !err.code) {
		return true;
	}

	if (WHITELIST.indexOf(err.code) !== -1) {
		return true;
	}

	if (BLACKLIST.indexOf(err.code) !== -1) {
		return false;
	}

	return true;
};

      };
    };
  }
}, {package:"is-retry-allowed",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-retry-allowed/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/bind.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/bind.js
      return function (require, module, exports) {
'use strict';

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/bind.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/cancel/Cancel.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/cancel/Cancel.js
      return function (require, module, exports) {
'use strict';

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/cancel/Cancel.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/cancel/isCancel.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/cancel/isCancel.js
      return function (require, module, exports) {
'use strict';

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/cancel/isCancel.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/spread.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/spread.js
      return function (require, module, exports) {
'use strict';

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/spread.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/isAxiosError.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/isAxiosError.js
      return function (require, module, exports) {
'use strict';

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/isAxiosError.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/utils.js", {"./helpers/bind":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/bind.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/utils.js
      return function (require, module, exports) {
'use strict';

var bind = require('./helpers/bind');

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/mergeConfig.js", {"../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/mergeConfig.js
      return function (require, module, exports) {
'use strict';

var utils = require('../utils');

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/mergeConfig.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/cancel/CancelToken.js", {"./Cancel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/cancel/Cancel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/cancel/CancelToken.js
      return function (require, module, exports) {
'use strict';

var Cancel = require('./Cancel');

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/cancel/CancelToken.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/Axios.js", {"../helpers/buildURL":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/buildURL.js","../helpers/validator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/validator.js","./../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/utils.js","./InterceptorManager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/InterceptorManager.js","./dispatchRequest":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/dispatchRequest.js","./mergeConfig":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/mergeConfig.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/Axios.js
      return function (require, module, exports) {
'use strict';

var utils = require('./../utils');
var buildURL = require('../helpers/buildURL');
var InterceptorManager = require('./InterceptorManager');
var dispatchRequest = require('./dispatchRequest');
var mergeConfig = require('./mergeConfig');
var validator = require('../helpers/validator');

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/Axios.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/defaults.js", {"./adapters/http":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/adapters/xhr.js","./adapters/xhr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/adapters/xhr.js","./core/enhanceError":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/enhanceError.js","./helpers/normalizeHeaderName":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/normalizeHeaderName.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/utils.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/defaults.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict';

var utils = require('./utils');
var normalizeHeaderName = require('./helpers/normalizeHeaderName');
var enhanceError = require('./core/enhanceError');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('./adapters/xhr');
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = require('./adapters/http');
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/defaults.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/secp256k1v3-lib/der.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/secp256k1v3-lib/der.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE
Object.defineProperty(exports, "__esModule", { value: true });
var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
    // begin
    0x30,
    0x81,
    0xd3,
    0x02,
    0x01,
    0x01,
    0x04,
    0x20,
    // private key
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    // middle
    0xa0,
    0x81,
    0x85,
    0x30,
    0x81,
    0x82,
    0x02,
    0x01,
    0x01,
    0x30,
    0x2c,
    0x06,
    0x07,
    0x2a,
    0x86,
    0x48,
    0xce,
    0x3d,
    0x01,
    0x01,
    0x02,
    0x21,
    0x00,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xfe,
    0xff,
    0xff,
    0xfc,
    0x2f,
    0x30,
    0x06,
    0x04,
    0x01,
    0x00,
    0x04,
    0x01,
    0x07,
    0x04,
    0x21,
    0x02,
    0x79,
    0xbe,
    0x66,
    0x7e,
    0xf9,
    0xdc,
    0xbb,
    0xac,
    0x55,
    0xa0,
    0x62,
    0x95,
    0xce,
    0x87,
    0x0b,
    0x07,
    0x02,
    0x9b,
    0xfc,
    0xdb,
    0x2d,
    0xce,
    0x28,
    0xd9,
    0x59,
    0xf2,
    0x81,
    0x5b,
    0x16,
    0xf8,
    0x17,
    0x98,
    0x02,
    0x21,
    0x00,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xfe,
    0xba,
    0xae,
    0xdc,
    0xe6,
    0xaf,
    0x48,
    0xa0,
    0x3b,
    0xbf,
    0xd2,
    0x5e,
    0x8c,
    0xd0,
    0x36,
    0x41,
    0x41,
    0x02,
    0x01,
    0x01,
    0xa1,
    0x24,
    0x03,
    0x22,
    0x00,
    // public key
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
]);
var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
    // begin
    0x30,
    0x82,
    0x01,
    0x13,
    0x02,
    0x01,
    0x01,
    0x04,
    0x20,
    // private key
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    // middle
    0xa0,
    0x81,
    0xa5,
    0x30,
    0x81,
    0xa2,
    0x02,
    0x01,
    0x01,
    0x30,
    0x2c,
    0x06,
    0x07,
    0x2a,
    0x86,
    0x48,
    0xce,
    0x3d,
    0x01,
    0x01,
    0x02,
    0x21,
    0x00,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xfe,
    0xff,
    0xff,
    0xfc,
    0x2f,
    0x30,
    0x06,
    0x04,
    0x01,
    0x00,
    0x04,
    0x01,
    0x07,
    0x04,
    0x41,
    0x04,
    0x79,
    0xbe,
    0x66,
    0x7e,
    0xf9,
    0xdc,
    0xbb,
    0xac,
    0x55,
    0xa0,
    0x62,
    0x95,
    0xce,
    0x87,
    0x0b,
    0x07,
    0x02,
    0x9b,
    0xfc,
    0xdb,
    0x2d,
    0xce,
    0x28,
    0xd9,
    0x59,
    0xf2,
    0x81,
    0x5b,
    0x16,
    0xf8,
    0x17,
    0x98,
    0x48,
    0x3a,
    0xda,
    0x77,
    0x26,
    0xa3,
    0xc4,
    0x65,
    0x5d,
    0xa4,
    0xfb,
    0xfc,
    0x0e,
    0x11,
    0x08,
    0xa8,
    0xfd,
    0x17,
    0xb4,
    0x48,
    0xa6,
    0x85,
    0x54,
    0x19,
    0x9c,
    0x47,
    0xd0,
    0x8f,
    0xfb,
    0x10,
    0xd4,
    0xb8,
    0x02,
    0x21,
    0x00,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xfe,
    0xba,
    0xae,
    0xdc,
    0xe6,
    0xaf,
    0x48,
    0xa0,
    0x3b,
    0xbf,
    0xd2,
    0x5e,
    0x8c,
    0xd0,
    0x36,
    0x41,
    0x41,
    0x02,
    0x01,
    0x01,
    0xa1,
    0x44,
    0x03,
    0x42,
    0x00,
    // public key
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
]);
exports.privateKeyExport = function (privateKey, publicKey, compressed) {
    if (compressed === void 0) { compressed = true; }
    var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
    privateKey.copy(result, compressed ? 8 : 9);
    publicKey.copy(result, compressed ? 181 : 214);
    return result;
};
exports.privateKeyImport = function (privateKey) {
    var length = privateKey.length;
    // sequence header
    var index = 0;
    if (length < index + 1 || privateKey[index] !== 0x30)
        return null;
    index += 1;
    // sequence length constructor
    if (length < index + 1 || !(privateKey[index] & 0x80))
        return null;
    var lenb = privateKey[index] & 0x7f;
    index += 1;
    if (lenb < 1 || lenb > 2)
        return null;
    if (length < index + lenb)
        return null;
    // sequence length
    var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
    index += lenb;
    if (length < index + len)
        return null;
    // sequence element 0: version number (=1)
    if (length < index + 3 ||
        privateKey[index] !== 0x02 ||
        privateKey[index + 1] !== 0x01 ||
        privateKey[index + 2] !== 0x01) {
        return null;
    }
    index += 3;
    // sequence element 1: octet string, up to 32 bytes
    if (length < index + 2 ||
        privateKey[index] !== 0x04 ||
        privateKey[index + 1] > 0x20 ||
        length < index + 2 + privateKey[index + 1]) {
        return null;
    }
    return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
};
exports.signatureImportLax = function (signature) {
    var r = Buffer.alloc(32, 0);
    var s = Buffer.alloc(32, 0);
    var length = signature.length;
    var index = 0;
    // sequence tag byte
    if (signature[index++] !== 0x30) {
        return null;
    }
    // sequence length byte
    var lenbyte = signature[index++];
    if (lenbyte & 0x80) {
        index += lenbyte - 0x80;
        if (index > length) {
            return null;
        }
    }
    // sequence tag byte for r
    if (signature[index++] !== 0x02) {
        return null;
    }
    // length for r
    var rlen = signature[index++];
    if (rlen & 0x80) {
        lenbyte = rlen - 0x80;
        if (index + lenbyte > length) {
            return null;
        }
        for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1)
            ;
        for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
            rlen = (rlen << 8) + signature[index];
    }
    if (rlen > length - index) {
        return null;
    }
    var rindex = index;
    index += rlen;
    // sequence tag byte for s
    if (signature[index++] !== 0x02) {
        return null;
    }
    // length for s
    var slen = signature[index++];
    if (slen & 0x80) {
        lenbyte = slen - 0x80;
        if (index + lenbyte > length) {
            return null;
        }
        for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1)
            ;
        for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
            slen = (slen << 8) + signature[index];
    }
    if (slen > length - index) {
        return null;
    }
    var sindex = index;
    index += slen;
    // ignore leading zeros in r
    for (; rlen > 0 && signature[rindex] === 0x00; rlen -= 1, rindex += 1)
        ;
    // copy r value
    if (rlen > 32) {
        return null;
    }
    var rvalue = signature.slice(rindex, rindex + rlen);
    rvalue.copy(r, 32 - rvalue.length);
    // ignore leading zeros in s
    for (; slen > 0 && signature[sindex] === 0x00; slen -= 1, sindex += 1)
        ;
    // copy s value
    if (slen > 32) {
        return null;
    }
    var svalue = signature.slice(sindex, sindex + slen);
    svalue.copy(s, 32 - svalue.length);
    return { r: r, s: s };
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/secp256k1v3-lib/der.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js", {"bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bn.js/lib/bn.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","elliptic":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/elliptic/lib/elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE
Object.defineProperty(exports, "__esModule", { value: true });
var BN = require("bn.js");
var EC = require('elliptic').ec;
var ec = new EC('secp256k1');
var ecparams = ec.curve;
exports.privateKeyExport = function (privateKey, compressed) {
    if (compressed === void 0) { compressed = true; }
    var d = new BN(privateKey);
    if (d.ucmp(ecparams.n) >= 0) {
        throw new Error("couldn't export to DER format");
    }
    var point = ec.g.mul(d);
    return toPublicKey(point.getX(), point.getY(), compressed);
};
exports.privateKeyModInverse = function (privateKey) {
    var bn = new BN(privateKey);
    if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
        throw new Error('private key range is invalid');
    }
    return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);
};
exports.signatureImport = function (sigObj) {
    var r = new BN(sigObj.r);
    if (r.ucmp(ecparams.n) >= 0) {
        r = new BN(0);
    }
    var s = new BN(sigObj.s);
    if (s.ucmp(ecparams.n) >= 0) {
        s = new BN(0);
    }
    return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);
};
exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
    if (compressed === void 0) { compressed = true; }
    var point = ec.keyFromPublic(publicKey);
    var scalar = new BN(privateKey);
    if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
        throw new Error('scalar was invalid (zero or overflow)');
    }
    var shared = point.pub.mul(scalar);
    return toPublicKey(shared.getX(), shared.getY(), compressed);
};
var toPublicKey = function (x, y, compressed) {
    var publicKey;
    if (compressed) {
        publicKey = Buffer.alloc(33);
        publicKey[0] = y.isOdd() ? 0x03 : 0x02;
        x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
    }
    else {
        publicKey = Buffer.alloc(65);
        publicKey[0] = 0x04;
        x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
        y.toArrayLike(Buffer, 'be', 32).copy(publicKey, 33);
    }
    return publicKey;
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/dist/PollingBlockTracker.js", {"./BaseBlockTracker":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/dist/BaseBlockTracker.js","json-rpc-random-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-random-id/index.js","pify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/node_modules/pify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/dist/PollingBlockTracker.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PollingBlockTracker = void 0;
const json_rpc_random_id_1 = __importDefault(require("json-rpc-random-id"));
const pify_1 = __importDefault(require("pify"));
const BaseBlockTracker_1 = require("./BaseBlockTracker");
const createRandomId = json_rpc_random_id_1.default();
const sec = 1000;
class PollingBlockTracker extends BaseBlockTracker_1.BaseBlockTracker {
    constructor(opts = {}) {
        // parse + validate args
        if (!opts.provider) {
            throw new Error('PollingBlockTracker - no provider specified.');
        }
        super({
            blockResetDuration: opts.pollingInterval,
        });
        // config
        this._provider = opts.provider;
        this._pollingInterval = opts.pollingInterval || 20 * sec;
        this._retryTimeout = opts.retryTimeout || this._pollingInterval / 10;
        this._keepEventLoopActive = opts.keepEventLoopActive === undefined ? true : opts.keepEventLoopActive;
        this._setSkipCacheFlag = opts.setSkipCacheFlag || false;
    }
    // trigger block polling
    async checkForLatestBlock() {
        await this._updateLatestBlock();
        return await this.getLatestBlock();
    }
    _start() {
        this._synchronize().catch((err) => this.emit('error', err));
    }
    async _synchronize() {
        while (this._isRunning) {
            try {
                await this._updateLatestBlock();
                await timeout(this._pollingInterval, !this._keepEventLoopActive);
            }
            catch (err) {
                const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:\n${err.stack}`);
                try {
                    this.emit('error', newErr);
                }
                catch (emitErr) {
                    console.error(newErr);
                }
                await timeout(this._retryTimeout, !this._keepEventLoopActive);
            }
        }
    }
    async _updateLatestBlock() {
        // fetch + set latest block
        const latestBlock = await this._fetchLatestBlock();
        this._newPotentialLatest(latestBlock);
    }
    async _fetchLatestBlock() {
        const req = {
            jsonrpc: '2.0',
            id: createRandomId(),
            method: 'eth_blockNumber',
            params: [],
        };
        if (this._setSkipCacheFlag) {
            req.skipCache = true;
        }
        const res = await pify_1.default((cb) => this._provider.sendAsync(req, cb))();
        if (res.error) {
            throw new Error(`PollingBlockTracker - encountered error fetching block:\n${res.error}`);
        }
        return res.result;
    }
}
exports.PollingBlockTracker = PollingBlockTracker;
function timeout(duration, unref) {
    return new Promise((resolve) => {
        const timeoutRef = setTimeout(resolve, duration);
        // don't keep process open
        if (timeoutRef.unref && unref) {
            timeoutRef.unref();
        }
    });
}
//# sourceMappingURL=PollingBlockTracker.js.map
      };
    };
  }
}, {package:"eth-block-tracker",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/dist/PollingBlockTracker.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/dist/SubscribeBlockTracker.js", {"./BaseBlockTracker":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/dist/BaseBlockTracker.js","json-rpc-random-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-random-id/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/dist/SubscribeBlockTracker.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubscribeBlockTracker = void 0;
const json_rpc_random_id_1 = __importDefault(require("json-rpc-random-id"));
const BaseBlockTracker_1 = require("./BaseBlockTracker");
const createRandomId = json_rpc_random_id_1.default();
class SubscribeBlockTracker extends BaseBlockTracker_1.BaseBlockTracker {
    constructor(opts = {}) {
        // parse + validate args
        if (!opts.provider) {
            throw new Error('SubscribeBlockTracker - no provider specified.');
        }
        // BaseBlockTracker constructor
        super(opts);
        // config
        this._provider = opts.provider;
        this._subscriptionId = null;
    }
    async checkForLatestBlock() {
        return await this.getLatestBlock();
    }
    async _start() {
        if (this._subscriptionId === undefined || this._subscriptionId === null) {
            try {
                const blockNumber = await this._call('eth_blockNumber');
                this._subscriptionId = await this._call('eth_subscribe', 'newHeads', {});
                this._provider.on('data', this._handleSubData.bind(this));
                this._newPotentialLatest(blockNumber);
            }
            catch (e) {
                this.emit('error', e);
            }
        }
    }
    async _end() {
        if (this._subscriptionId !== null && this._subscriptionId !== undefined) {
            try {
                await this._call('eth_unsubscribe', this._subscriptionId);
                this._subscriptionId = null;
            }
            catch (e) {
                this.emit('error', e);
            }
        }
    }
    _call(method, ...params) {
        return new Promise((resolve, reject) => {
            this._provider.sendAsync({
                id: createRandomId(), method, params, jsonrpc: '2.0',
            }, (err, res) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(res.result);
                }
            });
        });
    }
    _handleSubData(_, response) {
        var _a;
        if (response.method === 'eth_subscription' && ((_a = response.params) === null || _a === void 0 ? void 0 : _a.subscription) === this._subscriptionId) {
            this._newPotentialLatest(response.params.result.number);
        }
    }
}
exports.SubscribeBlockTracker = SubscribeBlockTracker;
//# sourceMappingURL=SubscribeBlockTracker.js.map
      };
    };
  }
}, {package:"eth-block-tracker",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/dist/SubscribeBlockTracker.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/dist/BaseBlockTracker.js", {"@metamask/safe-event-emitter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/safe-event-emitter/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/dist/BaseBlockTracker.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseBlockTracker = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
const sec = 1000;
const calculateSum = (accumulator, currentValue) => accumulator + currentValue;
const blockTrackerEvents = ['sync', 'latest'];
class BaseBlockTracker extends safe_event_emitter_1.default {
    constructor(opts = {}) {
        super();
        // config
        this._blockResetDuration = opts.blockResetDuration || 20 * sec;
        // state
        this._currentBlock = null;
        this._isRunning = false;
        // bind functions for internal use
        this._onNewListener = this._onNewListener.bind(this);
        this._onRemoveListener = this._onRemoveListener.bind(this);
        this._resetCurrentBlock = this._resetCurrentBlock.bind(this);
        // listen for handler changes
        this._setupInternalEvents();
    }
    isRunning() {
        return this._isRunning;
    }
    getCurrentBlock() {
        return this._currentBlock;
    }
    async getLatestBlock() {
        // return if available
        if (this._currentBlock) {
            return this._currentBlock;
        }
        // wait for a new latest block
        const latestBlock = await new Promise((resolve) => this.once('latest', resolve));
        // return newly set current block
        return latestBlock;
    }
    // dont allow module consumer to remove our internal event listeners
    removeAllListeners(eventName) {
        // perform default behavior, preserve fn arity
        if (eventName) {
            super.removeAllListeners(eventName);
        }
        else {
            super.removeAllListeners();
        }
        // re-add internal events
        this._setupInternalEvents();
        // trigger stop check just in case
        this._onRemoveListener();
        return this;
    }
    /**
     * To be implemented in subclass.
     */
    _start() {
        // default behavior is noop
    }
    /**
     * To be implemented in subclass.
     */
    _end() {
        // default behavior is noop
    }
    _setupInternalEvents() {
        // first remove listeners for idempotence
        this.removeListener('newListener', this._onNewListener);
        this.removeListener('removeListener', this._onRemoveListener);
        // then add them
        this.on('newListener', this._onNewListener);
        this.on('removeListener', this._onRemoveListener);
    }
    _onNewListener(eventName) {
        // `newListener` is called *before* the listener is added
        if (blockTrackerEvents.includes(eventName)) {
            this._maybeStart();
        }
    }
    _onRemoveListener() {
        // `removeListener` is called *after* the listener is removed
        if (this._getBlockTrackerEventCount() > 0) {
            return;
        }
        this._maybeEnd();
    }
    _maybeStart() {
        if (this._isRunning) {
            return;
        }
        this._isRunning = true;
        // cancel setting latest block to stale
        this._cancelBlockResetTimeout();
        this._start();
    }
    _maybeEnd() {
        if (!this._isRunning) {
            return;
        }
        this._isRunning = false;
        this._setupBlockResetTimeout();
        this._end();
    }
    _getBlockTrackerEventCount() {
        return blockTrackerEvents
            .map((eventName) => this.listenerCount(eventName))
            .reduce(calculateSum);
    }
    _newPotentialLatest(newBlock) {
        const currentBlock = this._currentBlock;
        // only update if blok number is higher
        if (currentBlock && (hexToInt(newBlock) <= hexToInt(currentBlock))) {
            return;
        }
        this._setCurrentBlock(newBlock);
    }
    _setCurrentBlock(newBlock) {
        const oldBlock = this._currentBlock;
        this._currentBlock = newBlock;
        this.emit('latest', newBlock);
        this.emit('sync', { oldBlock, newBlock });
    }
    _setupBlockResetTimeout() {
        // clear any existing timeout
        this._cancelBlockResetTimeout();
        // clear latest block when stale
        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);
        // nodejs - dont hold process open
        if (this._blockResetTimeout.unref) {
            this._blockResetTimeout.unref();
        }
    }
    _cancelBlockResetTimeout() {
        if (this._blockResetTimeout) {
            clearTimeout(this._blockResetTimeout);
        }
    }
    _resetCurrentBlock() {
        this._currentBlock = null;
    }
}
exports.BaseBlockTracker = BaseBlockTracker;
function hexToInt(hexInt) {
    return Number.parseInt(hexInt, 16);
}
//# sourceMappingURL=BaseBlockTracker.js.map
      };
    };
  }
}, {package:"eth-block-tracker",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/dist/BaseBlockTracker.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/trezor/protobuf.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/trezor/protobuf.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.Enum_TezosBallotType = exports.Enum_TezosContractType = exports.Enum_StellarSignerType = exports.Enum_StellarMemoType = exports.Enum_StellarAssetType = exports.Enum_NEMImportanceTransferMode = exports.Enum_NEMModificationType = exports.Enum_NEMSupplyChangeType = exports.Enum_NEMMosaicLevy = exports.Enum_WordRequestType = exports.Enum_RecoveryDeviceType = exports.Enum_SdProtectOperationType = exports.Enum_Capability = exports.Enum_SafetyCheckLevel = exports.Enum_EthereumDataType = exports.Enum_BackupType = exports.Enum_DebugSwipeDirection = exports.Enum_PinMatrixRequestType = exports.Enum_ButtonRequestType = exports.Enum_FailureType = exports.Enum_CardanoTxWitnessType = exports.Enum_CardanoTxSigningMode = exports.Enum_CardanoTxAuxiliaryDataSupplementType = exports.Enum_CardanoPoolRelayType = exports.Enum_CardanoCertificateType = exports.Enum_CardanoNativeScriptHashDisplayFormat = exports.Enum_CardanoNativeScriptType = exports.Enum_CardanoAddressType = exports.Enum_CardanoDerivationType = exports.Enum_RequestType = exports.Enum_AmountUnit = exports.Enum_DecredStakingSpendType = exports.Enum_OutputScriptType = exports.Enum_InputScriptType = exports.Enum_BinanceTimeInForce = exports.Enum_BinanceOrderSide = exports.Enum_BinanceOrderType = void 0;
// This file is auto generated from data/messages/message.json
// BinanceGetAddress
// BinanceAddress
// BinanceGetPublicKey
// BinancePublicKey
// BinanceSignTx
// BinanceTxRequest
// BinanceTransferMsg
var Enum_BinanceOrderType = Object.freeze({
  OT_UNKNOWN: 0,
  MARKET: 1,
  LIMIT: 2,
  OT_RESERVED: 3
});
exports.Enum_BinanceOrderType = Enum_BinanceOrderType;
var Enum_BinanceOrderSide = Object.freeze({
  SIDE_UNKNOWN: 0,
  BUY: 1,
  SELL: 2
});
exports.Enum_BinanceOrderSide = Enum_BinanceOrderSide;
var Enum_BinanceTimeInForce = Object.freeze({
  TIF_UNKNOWN: 0,
  GTE: 1,
  TIF_RESERVED: 2,
  IOC: 3
});
exports.Enum_BinanceTimeInForce = Enum_BinanceTimeInForce;
var Enum_InputScriptType = Object.freeze({
  SPENDADDRESS: 0,
  SPENDMULTISIG: 1,
  EXTERNAL: 2,
  SPENDWITNESS: 3,
  SPENDP2SHWITNESS: 4,
  SPENDTAPROOT: 5
});
exports.Enum_InputScriptType = Enum_InputScriptType;
var Enum_OutputScriptType = Object.freeze({
  PAYTOADDRESS: 0,
  PAYTOSCRIPTHASH: 1,
  PAYTOMULTISIG: 2,
  PAYTOOPRETURN: 3,
  PAYTOWITNESS: 4,
  PAYTOP2SHWITNESS: 5,
  PAYTOTAPROOT: 6
});
exports.Enum_OutputScriptType = Enum_OutputScriptType;
var Enum_DecredStakingSpendType = Object.freeze({
  SSGen: 0,
  SSRTX: 1
});
exports.Enum_DecredStakingSpendType = Enum_DecredStakingSpendType;
var Enum_AmountUnit = Object.freeze({
  BITCOIN: 0,
  MILLIBITCOIN: 1,
  MICROBITCOIN: 2,
  SATOSHI: 3
});
exports.Enum_AmountUnit = Enum_AmountUnit;
var Enum_RequestType = Object.freeze({
  TXINPUT: 0,
  TXOUTPUT: 1,
  TXMETA: 2,
  TXFINISHED: 3,
  TXEXTRADATA: 4,
  TXORIGINPUT: 5,
  TXORIGOUTPUT: 6
});
exports.Enum_RequestType = Enum_RequestType;
var Enum_CardanoDerivationType = Object.freeze({
  LEDGER: 0,
  ICARUS: 1,
  ICARUS_TREZOR: 2
});
exports.Enum_CardanoDerivationType = Enum_CardanoDerivationType;
var Enum_CardanoAddressType = Object.freeze({
  BASE: 0,
  BASE_SCRIPT_KEY: 1,
  BASE_KEY_SCRIPT: 2,
  BASE_SCRIPT_SCRIPT: 3,
  POINTER: 4,
  POINTER_SCRIPT: 5,
  ENTERPRISE: 6,
  ENTERPRISE_SCRIPT: 7,
  BYRON: 8,
  REWARD: 14,
  REWARD_SCRIPT: 15
});
exports.Enum_CardanoAddressType = Enum_CardanoAddressType;
var Enum_CardanoNativeScriptType = Object.freeze({
  PUB_KEY: 0,
  ALL: 1,
  ANY: 2,
  N_OF_K: 3,
  INVALID_BEFORE: 4,
  INVALID_HEREAFTER: 5
});
exports.Enum_CardanoNativeScriptType = Enum_CardanoNativeScriptType;
var Enum_CardanoNativeScriptHashDisplayFormat = Object.freeze({
  HIDE: 0,
  BECH32: 1,
  POLICY_ID: 2
});
exports.Enum_CardanoNativeScriptHashDisplayFormat = Enum_CardanoNativeScriptHashDisplayFormat;
var Enum_CardanoCertificateType = Object.freeze({
  STAKE_REGISTRATION: 0,
  STAKE_DEREGISTRATION: 1,
  STAKE_DELEGATION: 2,
  STAKE_POOL_REGISTRATION: 3
});
exports.Enum_CardanoCertificateType = Enum_CardanoCertificateType;
var Enum_CardanoPoolRelayType = Object.freeze({
  SINGLE_HOST_IP: 0,
  SINGLE_HOST_NAME: 1,
  MULTIPLE_HOST_NAME: 2
});
exports.Enum_CardanoPoolRelayType = Enum_CardanoPoolRelayType;
var Enum_CardanoTxAuxiliaryDataSupplementType = Object.freeze({
  NONE: 0,
  CATALYST_REGISTRATION_SIGNATURE: 1
});
exports.Enum_CardanoTxAuxiliaryDataSupplementType = Enum_CardanoTxAuxiliaryDataSupplementType;
var Enum_CardanoTxSigningMode = Object.freeze({
  ORDINARY_TRANSACTION: 0,
  POOL_REGISTRATION_AS_OWNER: 1,
  MULTISIG_TRANSACTION: 2
});
exports.Enum_CardanoTxSigningMode = Enum_CardanoTxSigningMode;
var Enum_CardanoTxWitnessType = Object.freeze({
  BYRON_WITNESS: 0,
  SHELLEY_WITNESS: 1
});
exports.Enum_CardanoTxWitnessType = Enum_CardanoTxWitnessType;
var Enum_FailureType = Object.freeze({
  Failure_UnexpectedMessage: 1,
  Failure_ButtonExpected: 2,
  Failure_DataError: 3,
  Failure_ActionCancelled: 4,
  Failure_PinExpected: 5,
  Failure_PinCancelled: 6,
  Failure_PinInvalid: 7,
  Failure_InvalidSignature: 8,
  Failure_ProcessError: 9,
  Failure_NotEnoughFunds: 10,
  Failure_NotInitialized: 11,
  Failure_PinMismatch: 12,
  Failure_WipeCodeMismatch: 13,
  Failure_InvalidSession: 14,
  Failure_FirmwareError: 99
});
exports.Enum_FailureType = Enum_FailureType;
var Enum_ButtonRequestType = Object.freeze({
  ButtonRequest_Other: 1,
  ButtonRequest_FeeOverThreshold: 2,
  ButtonRequest_ConfirmOutput: 3,
  ButtonRequest_ResetDevice: 4,
  ButtonRequest_ConfirmWord: 5,
  ButtonRequest_WipeDevice: 6,
  ButtonRequest_ProtectCall: 7,
  ButtonRequest_SignTx: 8,
  ButtonRequest_FirmwareCheck: 9,
  ButtonRequest_Address: 10,
  ButtonRequest_PublicKey: 11,
  ButtonRequest_MnemonicWordCount: 12,
  ButtonRequest_MnemonicInput: 13,
  _Deprecated_ButtonRequest_PassphraseType: 14,
  ButtonRequest_UnknownDerivationPath: 15,
  ButtonRequest_RecoveryHomepage: 16,
  ButtonRequest_Success: 17,
  ButtonRequest_Warning: 18,
  ButtonRequest_PassphraseEntry: 19,
  ButtonRequest_PinEntry: 20
});
exports.Enum_ButtonRequestType = Enum_ButtonRequestType;
var Enum_PinMatrixRequestType = Object.freeze({
  PinMatrixRequestType_Current: 1,
  PinMatrixRequestType_NewFirst: 2,
  PinMatrixRequestType_NewSecond: 3,
  PinMatrixRequestType_WipeCodeFirst: 4,
  PinMatrixRequestType_WipeCodeSecond: 5
});
exports.Enum_PinMatrixRequestType = Enum_PinMatrixRequestType;
var Enum_DebugSwipeDirection = Object.freeze({
  UP: 0,
  DOWN: 1,
  LEFT: 2,
  RIGHT: 3
});
exports.Enum_DebugSwipeDirection = Enum_DebugSwipeDirection;
var Enum_BackupType = Object.freeze({
  Bip39: 0,
  Slip39_Basic: 1,
  Slip39_Advanced: 2
});
exports.Enum_BackupType = Enum_BackupType;
var Enum_EthereumDataType = Object.freeze({
  UINT: 1,
  INT: 2,
  BYTES: 3,
  STRING: 4,
  BOOL: 5,
  ADDRESS: 6,
  ARRAY: 7,
  STRUCT: 8
});
exports.Enum_EthereumDataType = Enum_EthereumDataType;
var Enum_SafetyCheckLevel = Object.freeze({
  Strict: 0,
  PromptAlways: 1,
  PromptTemporarily: 2
});
exports.Enum_SafetyCheckLevel = Enum_SafetyCheckLevel;
var Enum_Capability = Object.freeze({
  Capability_Bitcoin: 1,
  Capability_Bitcoin_like: 2,
  Capability_Binance: 3,
  Capability_Cardano: 4,
  Capability_Crypto: 5,
  Capability_EOS: 6,
  Capability_Ethereum: 7,
  Capability_Lisk: 8,
  Capability_Monero: 9,
  Capability_NEM: 10,
  Capability_Ripple: 11,
  Capability_Stellar: 12,
  Capability_Tezos: 13,
  Capability_U2F: 14,
  Capability_Shamir: 15,
  Capability_ShamirGroups: 16,
  Capability_PassphraseEntry: 17
});
exports.Enum_Capability = Enum_Capability;
var Enum_SdProtectOperationType = Object.freeze({
  DISABLE: 0,
  ENABLE: 1,
  REFRESH: 2
});
exports.Enum_SdProtectOperationType = Enum_SdProtectOperationType;
var Enum_RecoveryDeviceType = Object.freeze({
  RecoveryDeviceType_ScrambledWords: 0,
  RecoveryDeviceType_Matrix: 1
});
exports.Enum_RecoveryDeviceType = Enum_RecoveryDeviceType;
var Enum_WordRequestType = Object.freeze({
  WordRequestType_Plain: 0,
  WordRequestType_Matrix9: 1,
  WordRequestType_Matrix6: 2
});
exports.Enum_WordRequestType = Enum_WordRequestType;
var Enum_NEMMosaicLevy = Object.freeze({
  MosaicLevy_Absolute: 1,
  MosaicLevy_Percentile: 2
});
exports.Enum_NEMMosaicLevy = Enum_NEMMosaicLevy;
var Enum_NEMSupplyChangeType = Object.freeze({
  SupplyChange_Increase: 1,
  SupplyChange_Decrease: 2
});
exports.Enum_NEMSupplyChangeType = Enum_NEMSupplyChangeType;
var Enum_NEMModificationType = Object.freeze({
  CosignatoryModification_Add: 1,
  CosignatoryModification_Delete: 2
});
exports.Enum_NEMModificationType = Enum_NEMModificationType;
var Enum_NEMImportanceTransferMode = Object.freeze({
  ImportanceTransfer_Activate: 1,
  ImportanceTransfer_Deactivate: 2
});
exports.Enum_NEMImportanceTransferMode = Enum_NEMImportanceTransferMode;
var Enum_StellarAssetType = Object.freeze({
  NATIVE: 0,
  ALPHANUM4: 1,
  ALPHANUM12: 2
});
exports.Enum_StellarAssetType = Enum_StellarAssetType;
var Enum_StellarMemoType = Object.freeze({
  NONE: 0,
  TEXT: 1,
  ID: 2,
  HASH: 3,
  RETURN: 4
});
exports.Enum_StellarMemoType = Enum_StellarMemoType;
var Enum_StellarSignerType = Object.freeze({
  ACCOUNT: 0,
  PRE_AUTH: 1,
  HASH: 2
});
exports.Enum_StellarSignerType = Enum_StellarSignerType;
var Enum_TezosContractType = Object.freeze({
  Implicit: 0,
  Originated: 1
});
exports.Enum_TezosContractType = Enum_TezosContractType;
var Enum_TezosBallotType = Object.freeze({
  Yay: 0,
  Nay: 1,
  Pass: 2
});
exports.Enum_TezosBallotType = Enum_TezosBallotType;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/trezor/protobuf.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/wrapNativeSuper.js", {"./construct.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/construct.js","./getPrototypeOf.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/getPrototypeOf.js","./isNativeFunction.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/isNativeFunction.js","./setPrototypeOf.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/setPrototypeOf.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/wrapNativeSuper.js
      return function (require, module, exports) {
var getPrototypeOf = require("./getPrototypeOf.js");

var setPrototypeOf = require("./setPrototypeOf.js");

var isNativeFunction = require("./isNativeFunction.js");

var construct = require("./construct.js");

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;
module.exports["default"] = module.exports, module.exports.__esModule = true;
      };
    };
  }
}, {package:"@babel/runtime",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/wrapNativeSuper.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/utils/deferred.js", {"@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/utils/deferred.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.create = create;
exports.createAsync = createAsync;
exports.resolveTimeoutPromise = resolveTimeoutPromise;
exports.rejectTimeoutPromise = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function create(arg, device) {
  var localResolve = function localResolve(_t) {};

  var localReject = function localReject(_e) {};

  var id; // eslint-disable-next-line no-async-promise-executor

  var promise = new Promise( /*#__PURE__*/function () {
    var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(resolve, reject) {
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              localResolve = resolve;
              localReject = reject;

              if (!(typeof arg === 'function')) {
                _context.next = 11;
                break;
              }

              _context.prev = 3;
              _context.next = 6;
              return arg();

            case 6:
              _context.next = 11;
              break;

            case 8:
              _context.prev = 8;
              _context.t0 = _context["catch"](3);
              reject(_context.t0);

            case 11:
              if (typeof arg === 'string') id = arg;

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[3, 8]]);
    }));

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }());
  return {
    id: id,
    device: device,
    resolve: localResolve,
    reject: localReject,
    promise: promise
  };
}

function createAsync(innerFn) {
  var localResolve = function localResolve(_t) {};

  var localReject = function localReject(_e) {};

  var promise = new Promise(function (resolve, reject) {
    localResolve = resolve;
    localReject = reject;
  });

  var inner = /*#__PURE__*/function () {
    var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return innerFn();

            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function inner() {
      return _ref2.apply(this, arguments);
    };
  }();

  return {
    resolve: localResolve,
    reject: localReject,
    promise: promise,
    run: function run() {
      inner();
      return promise;
    }
  };
}

function resolveTimeoutPromise(delay, result) {
  return new Promise(function (resolve) {
    setTimeout(function () {
      resolve(result);
    }, delay);
  });
}

var rejectTimeoutPromise = function rejectTimeoutPromise(delay, error) {
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      reject(error);
    }, delay);
  });
};

exports.rejectTimeoutPromise = rejectTimeoutPromise;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/utils/deferred.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/env/browser/networkUtils.js", {"@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js","whatwg-fetch":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/node_modules/whatwg-fetch/dist/fetch.umd.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/env/browser/networkUtils.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.getOrigin = exports.httpRequest = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

require("whatwg-fetch");

var httpRequest = /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(url, type) {
    var response, txt;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (type === void 0) {
              type = 'text';
            }

            _context.next = 3;
            return fetch(url, {
              credentials: 'same-origin'
            });

          case 3:
            response = _context.sent;

            if (!response.ok) {
              _context.next = 13;
              break;
            }

            if (!(type === 'json')) {
              _context.next = 10;
              break;
            }

            _context.next = 8;
            return response.text();

          case 8:
            txt = _context.sent;
            return _context.abrupt("return", JSON.parse(txt));

          case 10:
            if (!(type === 'binary')) {
              _context.next = 12;
              break;
            }

            return _context.abrupt("return", response.arrayBuffer());

          case 12:
            return _context.abrupt("return", response.text());

          case 13:
            throw new Error("httpRequest error: " + url + " " + response.statusText);

          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function httpRequest(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

exports.httpRequest = httpRequest;

var getOrigin = function getOrigin(url) {
  if (url.indexOf('file://') === 0) return 'file://'; // eslint-disable-next-line no-useless-escape

  var parts = url.match(/^.+\:\/\/[^\/]+/);
  return Array.isArray(parts) && parts.length > 0 ? parts[0] : 'unknown';
};

exports.getOrigin = getOrigin;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/env/browser/networkUtils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/iframe/inline-styles.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/iframe/inline-styles.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports["default"] = void 0;
var css = '.trezorconnect-container{position:fixed!important;display:-webkit-box!important;display:-webkit-flex!important;display:-ms-flexbox!important;display:flex!important;-webkit-box-orient:vertical!important;-webkit-box-direction:normal!important;-webkit-flex-direction:column!important;-ms-flex-direction:column!important;flex-direction:column!important;-webkit-box-align:center!important;-webkit-align-items:center!important;-ms-flex-align:center!important;align-items:center!important;z-index:10000!important;width:100%!important;height:100%!important;top:0!important;left:0!important;background:rgba(0,0,0,.35)!important;overflow:auto!important;padding:20px!important;margin:0!important}.trezorconnect-container .trezorconnect-window{position:relative!important;display:block!important;width:370px!important;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif!important;margin:auto!important;border-radius:3px!important;background-color:#fff!important;text-align:center!important;overflow:hidden!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head{text-align:left;padding:12px 24px!important;display:-webkit-box!important;display:-webkit-flex!important;display:-ms-flexbox!important;display:flex!important;-webkit-box-align:center!important;-webkit-align-items:center!important;-ms-flex-align:center!important;align-items:center!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-logo{-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close{cursor:pointer!important;height:24px!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close svg{fill:#757575;-webkit-transition:fill .3s ease-in-out!important;transition:fill .3s ease-in-out!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close:hover svg{fill:#494949}.trezorconnect-container .trezorconnect-window .trezorconnect-body{padding:24px 24px 32px!important;background:#FBFBFB!important;border-top:1px solid #EBEBEB}.trezorconnect-container .trezorconnect-window .trezorconnect-body h3{color:#505050!important;font-size:16px!important;font-weight:500!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body p{margin:8px 0 24px!important;font-weight:400!important;color:#A9A9A9!important;font-size:12px!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button{width:100%!important;padding:12px 24px!important;margin:0!important;border-radius:3px!important;font-size:14px!important;font-weight:300!important;cursor:pointer!important;background:#01B757!important;color:#fff!important;border:0!important;-webkit-transition:background-color .3s ease-in-out!important;transition:background-color .3s ease-in-out!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button:hover{background-color:#00AB51!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button:active{background-color:#009546!important}/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImlucHV0IiwiJHN0ZGluIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWNBLHlCQUNJLFNBQUEsZ0JBQ0EsUUFBQSxzQkFDQSxRQUFBLHVCQUNBLFFBQUEsc0JBRUEsUUFBQSxlQUNBLG1CQUFBLG1CQUNBLHNCQUFBLGlCQUNBLHVCQUFBLGlCQUNBLG1CQUFBLGlCQUNBLGVBQUEsaUJBRUEsa0JBQUEsaUJBQ0Esb0JBQUEsaUJBQ0EsZUFBQSxpQkNmTSxZQUFhLGlCREFyQixRQUFTLGdCQWtCSCxNQUFBLGVBQ0EsT0FBQSxlQUNBLElBQUEsWUFDQSxLQUFBLFlBQ0EsV0FBQSwwQkFDQSxTQUFBLGVBQ0EsUUFBQSxlQUNBLE9BQUEsWUNkUiwrQ0RYRSxTQUFVLG1CQTZCQSxRQUFBLGdCQUNBLE1BQUEsZ0JBQ0EsWUFBQSxjQUFBLG1CQUFBLFdBQUEsT0FBQSxpQkFBQSxNQUFBLHFCQUNBLE9BQUEsZUNmVixjQUFlLGNEakJmLGlCQWlCRSxlQWtCWSxXQUFBLGlCQ2ZkLFNBQVUsaUJEbUJJLG1FQUNBLFdBQUEsS0NoQmQsUUFBUyxLQUFLLGVEeEJkLFFBQVMsc0JBMENTLFFBQUEsdUJBQ0EsUUFBQSxzQkNmbEIsUUFBUyxlRGlCSyxrQkE1QlosaUJBOEJvQixvQkFBQSxpQkNoQmxCLGVBQWdCLGlCRC9CWixZQWlCTixpQkFzQ1EsdUZBQ0EsaUJBQUEsRUNwQlYsYUFBYyxFRHBDVixTQUFVLEVBMkRBLEtBQUEsRUFFQSx3RkNwQmQsT0FBUSxrQkR6Q1IsT0FBUSxlQWlFTSw0RkFDQSxLQUFBLFFBQ0EsbUJBQUEsS0FBQSxJQUFBLHNCQ3BCZCxXQUFZLEtBQUssSUFBSyxzQkR3QlIsa0dBQ0EsS0FBQSxRQUVBLG1FQUNBLFFBQUEsS0FBQSxLQUFBLGVBQ0EsV0FBQSxrQkFDQSxXQUFBLElBQUEsTUFBQSxRQUVBLHNFQUNBLE1BQUEsa0JBQ0EsVUFBQSxlQ3JCZCxZQUFhLGNEd0JLLHFFQ3JCbEIsT0FBUSxJQUFJLEVBQUksZUR3QkYsWUFBQSxjQUNJLE1BQUEsa0JDdEJsQixVQUFXLGVBRWIsMEVBQ0UsTUFBTyxlQUNQLFFBQVMsS0FBSyxlQUNkLE9BQVEsWUFDUixjQUFlLGNBQ2YsVUFBVyxlQUNYLFlBQWEsY0FDYixPQUFRLGtCQUNSLFdBQVksa0JBQ1osTUFBTyxlQUNQLE9BQVEsWUFDUixtQkFBb0IsaUJBQWlCLElBQUssc0JBQzFDLFdBQVksaUJBQWlCLElBQUssc0JBRXBDLGdGQUNFLGlCQUFrQixrQkFFcEIsaUZBQ0UsaUJBQWtCIn0= */';
var _default = css;
exports["default"] = _default;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/iframe/inline-styles.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/popup/showPopupRequest.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/popup/showPopupRequest.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.showPopupRequest = void 0;
var LAYER_ID = 'TrezorConnectInteractionLayer';
var HTML = "\n    <div class=\"trezorconnect-container\" id=\"" + LAYER_ID + "\">\n        <div class=\"trezorconnect-window\">\n            <div class=\"trezorconnect-head\">\n                <svg class=\"trezorconnect-logo\" x=\"0px\" y=\"0px\" viewBox=\"0 0 163.7 41.9\" width=\"78px\" height=\"20px\" preserveAspectRatio=\"xMinYMin meet\">\n                    <polygon points=\"101.1,12.8 118.2,12.8 118.2,17.3 108.9,29.9 118.2,29.9 118.2,35.2 101.1,35.2 101.1,30.7 110.4,18.1 101.1,18.1\"/>\n                    <path d=\"M158.8,26.9c2.1-0.8,4.3-2.9,4.3-6.6c0-4.5-3.1-7.4-7.7-7.4h-10.5v22.3h5.8v-7.5h2.2l4.1,7.5h6.7L158.8,26.9z M154.7,22.5 h-4V18h4c1.5,0,2.5,0.9,2.5,2.2C157.2,21.6,156.2,22.5,154.7,22.5z\"/>\n                    <path d=\"M130.8,12.5c-6.8,0-11.6,4.9-11.6,11.5s4.9,11.5,11.6,11.5s11.7-4.9,11.7-11.5S137.6,12.5,130.8,12.5z M130.8,30.3 c-3.4,0-5.7-2.6-5.7-6.3c0-3.8,2.3-6.3,5.7-6.3c3.4,0,5.8,2.6,5.8,6.3C136.6,27.7,134.2,30.3,130.8,30.3z\"/>\n                    <polygon points=\"82.1,12.8 98.3,12.8 98.3,18 87.9,18 87.9,21.3 98,21.3 98,26.4 87.9,26.4 87.9,30 98.3,30 98.3,35.2 82.1,35.2 \"/>\n                    <path d=\"M24.6,9.7C24.6,4.4,20,0,14.4,0S4.2,4.4,4.2,9.7v3.1H0v22.3h0l14.4,6.7l14.4-6.7h0V12.9h-4.2V9.7z M9.4,9.7 c0-2.5,2.2-4.5,5-4.5s5,2,5,4.5v3.1H9.4V9.7z M23,31.5l-8.6,4l-8.6-4V18.1H23V31.5z\"/>\n                    <path d=\"M79.4,20.3c0-4.5-3.1-7.4-7.7-7.4H61.2v22.3H67v-7.5h2.2l4.1,7.5H80l-4.9-8.3C77.2,26.1,79.4,24,79.4,20.3z M71,22.5h-4V18 h4c1.5,0,2.5,0.9,2.5,2.2C73.5,21.6,72.5,22.5,71,22.5z\"/>\n                    <polygon points=\"40.5,12.8 58.6,12.8 58.6,18.1 52.4,18.1 52.4,35.2 46.6,35.2 46.6,18.1 40.5,18.1 \"/>\n                </svg>\n                <div class=\"trezorconnect-close\">\n                    <svg x=\"0px\" y=\"0px\" viewBox=\"24 24 60 60\" width=\"24px\" height=\"24px\" preserveAspectRatio=\"xMinYMin meet\">\n                        <polygon class=\"st0\" points=\"40,67.9 42.1,70 55,57.1 67.9,70 70,67.9 57.1,55 70,42.1 67.9,40 55,52.9 42.1,40 40,42.1 52.9,55 \"/>\n                    </svg>\n                </div>\n            </div>\n            <div class=\"trezorconnect-body\">\n                <h3>Popup was blocked</h3>\n                <p>Please click to \u201CContinue\u201D to open popup manually</p>\n                <button class=\"trezorconnect-open\">Continue</button>\n            </div>\n        </div>\n    </div>\n";

var showPopupRequest = function showPopupRequest(open, cancel) {
  if (document.getElementById(LAYER_ID)) {
    return;
  }

  var div = document.createElement('div');
  div.id = LAYER_ID;
  div.className = 'trezorconnect-container';
  div.innerHTML = HTML;

  if (document.body) {
    document.body.appendChild(div);
  }

  var button = div.getElementsByClassName('trezorconnect-open')[0];

  button.onclick = function () {
    open();

    if (document.body) {
      document.body.removeChild(div);
    }
  };

  var close = div.getElementsByClassName('trezorconnect-close')[0];

  close.onclick = function () {
    cancel();

    if (document.body) {
      document.body.removeChild(div);
    }
  };
};

exports.showPopupRequest = showPopupRequest;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/popup/showPopupRequest.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/lib/keccak.js", {"./keccak-state-unroll":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/lib/keccak-state-unroll.js","safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/lib/keccak.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var keccakState = require('./keccak-state-unroll')

function Keccak () {
  // much faster than `new Array(50)`
  this.state = [
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0
  ]

  this.blockSize = null
  this.count = 0
  this.squeezing = false
}

Keccak.prototype.initialize = function (rate, capacity) {
  for (var i = 0; i < 50; ++i) this.state[i] = 0
  this.blockSize = rate / 8
  this.count = 0
  this.squeezing = false
}

Keccak.prototype.absorb = function (data) {
  for (var i = 0; i < data.length; ++i) {
    this.state[~~(this.count / 4)] ^= data[i] << (8 * (this.count % 4))
    this.count += 1
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state)
      this.count = 0
    }
  }
}

Keccak.prototype.absorbLastFewBits = function (bits) {
  this.state[~~(this.count / 4)] ^= bits << (8 * (this.count % 4))
  if ((bits & 0x80) !== 0 && this.count === (this.blockSize - 1)) keccakState.p1600(this.state)
  this.state[~~((this.blockSize - 1) / 4)] ^= 0x80 << (8 * ((this.blockSize - 1) % 4))
  keccakState.p1600(this.state)
  this.count = 0
  this.squeezing = true
}

Keccak.prototype.squeeze = function (length) {
  if (!this.squeezing) this.absorbLastFewBits(0x01)

  var output = Buffer.alloc(length)
  for (var i = 0; i < length; ++i) {
    output[i] = (this.state[~~(this.count / 4)] >>> (8 * (this.count % 4))) & 0xff
    this.count += 1
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state)
      this.count = 0
    }
  }

  return output
}

Keccak.prototype.copy = function (dest) {
  for (var i = 0; i < 50; ++i) dest.state[i] = this.state[i]
  dest.blockSize = this.blockSize
  dest.count = this.count
  dest.squeezing = this.squeezing
}

module.exports = Keccak

      };
    };
  }
}, {package:"keccak",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/lib/keccak.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/lib/api/index.js", {"./keccak":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/lib/api/keccak.js","./shake":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/lib/api/shake.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/lib/api/index.js
      return function (require, module, exports) {
'use strict'
var createKeccak = require('./keccak')
var createShake = require('./shake')

module.exports = function (KeccakState) {
  var Keccak = createKeccak(KeccakState)
  var Shake = createShake(KeccakState)

  return function (algorithm, options) {
    var hash = typeof algorithm === 'string' ? algorithm.toLowerCase() : algorithm
    switch (hash) {
      case 'keccak224': return new Keccak(1152, 448, null, 224, options)
      case 'keccak256': return new Keccak(1088, 512, null, 256, options)
      case 'keccak384': return new Keccak(832, 768, null, 384, options)
      case 'keccak512': return new Keccak(576, 1024, null, 512, options)

      case 'sha3-224': return new Keccak(1152, 448, 0x06, 224, options)
      case 'sha3-256': return new Keccak(1088, 512, 0x06, 256, options)
      case 'sha3-384': return new Keccak(832, 768, 0x06, 384, options)
      case 'sha3-512': return new Keccak(576, 1024, 0x06, 512, options)

      case 'shake128': return new Shake(1344, 256, 0x1f, options)
      case 'shake256': return new Shake(1088, 512, 0x1f, options)

      default: throw new Error('Invald algorithm: ' + algorithm)
    }
  }
}

      };
    };
  }
}, {package:"keccak",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/lib/api/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethjs-util/lib/index.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","is-hex-prefixed":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-hex-prefixed/src/index.js","strip-hex-prefix":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/strip-hex-prefix/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethjs-util/lib/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethjs-util/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/js.js", {"./lib/api":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/lib/api/index.js","./lib/keccak":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/lib/keccak.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/js.js
      return function (require, module, exports) {
'use strict'
module.exports = require('./lib/api')(require('./lib/keccak'))

      };
    };
  }
}, {package:"keccak",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/js.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/lib/index.js", {"bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bn.js/lib/bn.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/lib/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/* eslint-disable no-useless-escape */
const utils = require('ethereumjs-util')
const BN = require('bn.js')

var ABI = function () {
}

// Convert from short to canonical names
// FIXME: optimise or make this nicer?
function elementaryName (name) {
  if (name.startsWith('int[')) {
    return 'int256' + name.slice(3)
  } else if (name === 'int') {
    return 'int256'
  } else if (name.startsWith('uint[')) {
    return 'uint256' + name.slice(4)
  } else if (name === 'uint') {
    return 'uint256'
  } else if (name.startsWith('fixed[')) {
    return 'fixed128x128' + name.slice(5)
  } else if (name === 'fixed') {
    return 'fixed128x128'
  } else if (name.startsWith('ufixed[')) {
    return 'ufixed128x128' + name.slice(6)
  } else if (name === 'ufixed') {
    return 'ufixed128x128'
  }
  return name
}

ABI.eventID = function (name, types) {
  // FIXME: use node.js util.format?
  var sig = name + '(' + types.map(elementaryName).join(',') + ')'
  return utils.keccak256(Buffer.from(sig))
}

ABI.methodID = function (name, types) {
  return ABI.eventID(name, types).slice(0, 4)
}

// Parse N from type<N>
function parseTypeN (type) {
  return parseInt(/^\D+(\d+)$/.exec(type)[1], 10)
}

// Parse N,M from type<N>x<M>
function parseTypeNxM (type) {
  var tmp = /^\D+(\d+)x(\d+)$/.exec(type)
  return [ parseInt(tmp[1], 10), parseInt(tmp[2], 10) ]
}

// Parse N in type[<N>] where "type" can itself be an array type.
function parseTypeArray (type) {
  var tmp = type.match(/(.*)\[(.*?)\]$/)
  if (tmp) {
    return tmp[2] === '' ? 'dynamic' : parseInt(tmp[2], 10)
  }
  return null
}

function parseNumber (arg) {
  var type = typeof arg
  if (type === 'string') {
    if (utils.isHexPrefixed(arg)) {
      return new BN(utils.stripHexPrefix(arg), 16)
    } else {
      return new BN(arg, 10)
    }
  } else if (type === 'number') {
    return new BN(arg)
  } else if (arg.toArray) {
    // assume this is a BN for the moment, replace with BN.isBN soon
    return arg
  } else {
    throw new Error('Argument is not a number')
  }
}

// someMethod(bytes,uint)
// someMethod(bytes,uint):(boolean)
function parseSignature (sig) {
  var tmp = /^(\w+)\((.*)\)$/.exec(sig)

  if (tmp.length !== 3) {
    throw new Error('Invalid method signature')
  }

  var args = /^(.+)\):\((.+)$/.exec(tmp[2])

  if (args !== null && args.length === 3) {
    return {
      method: tmp[1],
      args: args[1].split(','),
      retargs: args[2].split(',')
    }
  } else {
    var params = tmp[2].split(',')
    if (params.length === 1 && params[0] === '') {
      // Special-case (possibly naive) fixup for functions that take no arguments.
      // TODO: special cases are always bad, but this makes the function return
      // match what the calling functions expect
      params = []
    }
    return {
      method: tmp[1],
      args: params
    }
  }
}

// Encodes a single item (can be dynamic array)
// @returns: Buffer
function encodeSingle (type, arg) {
  var size, num, ret, i

  if (type === 'address') {
    return encodeSingle('uint160', parseNumber(arg))
  } else if (type === 'bool') {
    return encodeSingle('uint8', arg ? 1 : 0)
  } else if (type === 'string') {
    return encodeSingle('bytes', Buffer.from(arg, 'utf8'))
  } else if (isArray(type)) {
    // this part handles fixed-length ([2]) and variable length ([]) arrays
    // NOTE: we catch here all calls to arrays, that simplifies the rest
    if (typeof arg.length === 'undefined') {
      throw new Error('Not an array?')
    }
    size = parseTypeArray(type)
    if (size !== 'dynamic' && size !== 0 && arg.length > size) {
      throw new Error('Elements exceed array size: ' + size)
    }
    ret = []
    type = type.slice(0, type.lastIndexOf('['))
    if (typeof arg === 'string') {
      arg = JSON.parse(arg)
    }
    for (i in arg) {
      ret.push(encodeSingle(type, arg[i]))
    }
    if (size === 'dynamic') {
      var length = encodeSingle('uint256', arg.length)
      ret.unshift(length)
    }
    return Buffer.concat(ret)
  } else if (type === 'bytes') {
    arg = Buffer.from(arg)

    ret = Buffer.concat([ encodeSingle('uint256', arg.length), arg ])

    if ((arg.length % 32) !== 0) {
      ret = Buffer.concat([ ret, utils.zeros(32 - (arg.length % 32)) ])
    }

    return ret
  } else if (type.startsWith('bytes')) {
    size = parseTypeN(type)
    if (size < 1 || size > 32) {
      throw new Error('Invalid bytes<N> width: ' + size)
    }

    return utils.setLengthRight(arg, 32)
  } else if (type.startsWith('uint')) {
    size = parseTypeN(type)
    if ((size % 8) || (size < 8) || (size > 256)) {
      throw new Error('Invalid uint<N> width: ' + size)
    }

    num = parseNumber(arg)
    if (num.bitLength() > size) {
      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength())
    }

    if (num < 0) {
      throw new Error('Supplied uint is negative')
    }

    return num.toArrayLike(Buffer, 'be', 32)
  } else if (type.startsWith('int')) {
    size = parseTypeN(type)
    if ((size % 8) || (size < 8) || (size > 256)) {
      throw new Error('Invalid int<N> width: ' + size)
    }

    num = parseNumber(arg)
    if (num.bitLength() > size) {
      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength())
    }

    return num.toTwos(256).toArrayLike(Buffer, 'be', 32)
  } else if (type.startsWith('ufixed')) {
    size = parseTypeNxM(type)

    num = parseNumber(arg)

    if (num < 0) {
      throw new Error('Supplied ufixed is negative')
    }

    return encodeSingle('uint256', num.mul(new BN(2).pow(new BN(size[1]))))
  } else if (type.startsWith('fixed')) {
    size = parseTypeNxM(type)

    return encodeSingle('int256', parseNumber(arg).mul(new BN(2).pow(new BN(size[1]))))
  }

  throw new Error('Unsupported or invalid type: ' + type)
}

// Decodes a single item (can be dynamic array)
// @returns: array
// FIXME: this method will need a lot of attention at checking limits and validation
function decodeSingle (parsedType, data, offset) {
  if (typeof parsedType === 'string') {
    parsedType = parseType(parsedType)
  }
  var size, num, ret, i

  if (parsedType.name === 'address') {
    return decodeSingle(parsedType.rawType, data, offset).toArrayLike(Buffer, 'be', 20).toString('hex')
  } else if (parsedType.name === 'bool') {
    return decodeSingle(parsedType.rawType, data, offset).toString() === new BN(1).toString()
  } else if (parsedType.name === 'string') {
    var bytes = decodeSingle(parsedType.rawType, data, offset)
    return Buffer.from(bytes, 'utf8').toString()
  } else if (parsedType.isArray) {
    // this part handles fixed-length arrays ([2]) and variable length ([]) arrays
    // NOTE: we catch here all calls to arrays, that simplifies the rest
    ret = []
    size = parsedType.size

    if (parsedType.size === 'dynamic') {
      offset = decodeSingle('uint256', data, offset).toNumber()
      size = decodeSingle('uint256', data, offset).toNumber()
      offset = offset + 32
    }
    for (i = 0; i < size; i++) {
      var decoded = decodeSingle(parsedType.subArray, data, offset)
      ret.push(decoded)
      offset += parsedType.subArray.memoryUsage
    }
    return ret
  } else if (parsedType.name === 'bytes') {
    offset = decodeSingle('uint256', data, offset).toNumber()
    size = decodeSingle('uint256', data, offset).toNumber()
    return data.slice(offset + 32, offset + 32 + size)
  } else if (parsedType.name.startsWith('bytes')) {
    return data.slice(offset, offset + parsedType.size)
  } else if (parsedType.name.startsWith('uint')) {
    num = new BN(data.slice(offset, offset + 32), 16, 'be')
    if (num.bitLength() > parsedType.size) {
      throw new Error('Decoded int exceeds width: ' + parsedType.size + ' vs ' + num.bitLength())
    }
    return num
  } else if (parsedType.name.startsWith('int')) {
    num = new BN(data.slice(offset, offset + 32), 16, 'be').fromTwos(256)
    if (num.bitLength() > parsedType.size) {
      throw new Error('Decoded uint exceeds width: ' + parsedType.size + ' vs ' + num.bitLength())
    }

    return num
  } else if (parsedType.name.startsWith('ufixed')) {
    size = new BN(2).pow(new BN(parsedType.size[1]))
    num = decodeSingle('uint256', data, offset)
    if (!num.mod(size).isZero()) {
      throw new Error('Decimals not supported yet')
    }
    return num.div(size)
  } else if (parsedType.name.startsWith('fixed')) {
    size = new BN(2).pow(new BN(parsedType.size[1]))
    num = decodeSingle('int256', data, offset)
    if (!num.mod(size).isZero()) {
      throw new Error('Decimals not supported yet')
    }
    return num.div(size)
  }
  throw new Error('Unsupported or invalid type: ' + parsedType.name)
}

// Parse the given type
// @returns: {} containing the type itself, memory usage and (including size and subArray if applicable)
function parseType (type) {
  var size
  var ret
  if (isArray(type)) {
    size = parseTypeArray(type)
    var subArray = type.slice(0, type.lastIndexOf('['))
    subArray = parseType(subArray)
    ret = {
      isArray: true,
      name: type,
      size: size,
      memoryUsage: size === 'dynamic' ? 32 : subArray.memoryUsage * size,
      subArray: subArray
    }
    return ret
  } else {
    var rawType
    switch (type) {
      case 'address':
        rawType = 'uint160'
        break
      case 'bool':
        rawType = 'uint8'
        break
      case 'string':
        rawType = 'bytes'
        break
    }
    ret = {
      rawType: rawType,
      name: type,
      memoryUsage: 32
    }

    if ((type.startsWith('bytes') && type !== 'bytes') || type.startsWith('uint') || type.startsWith('int')) {
      ret.size = parseTypeN(type)
    } else if (type.startsWith('ufixed') || type.startsWith('fixed')) {
      ret.size = parseTypeNxM(type)
    }

    if (type.startsWith('bytes') && type !== 'bytes' && (ret.size < 1 || ret.size > 32)) {
      throw new Error('Invalid bytes<N> width: ' + ret.size)
    }
    if ((type.startsWith('uint') || type.startsWith('int')) && (ret.size % 8 || ret.size < 8 || ret.size > 256)) {
      throw new Error('Invalid int/uint<N> width: ' + ret.size)
    }
    return ret
  }
}

// Is a type dynamic?
function isDynamic (type) {
  // FIXME: handle all types? I don't think anything is missing now
  return (type === 'string') || (type === 'bytes') || (parseTypeArray(type) === 'dynamic')
}

// Is a type an array?
function isArray (type) {
  return type.lastIndexOf(']') === type.length - 1
}

// Encode a method/event with arguments
// @types an array of string type names
// @args  an array of the appropriate values
ABI.rawEncode = function (types, values) {
  var output = []
  var data = []

  var headLength = 0

  types.forEach(function (type) {
    if (isArray(type)) {
      var size = parseTypeArray(type)

      if (size !== 'dynamic') {
        headLength += 32 * size
      } else {
        headLength += 32
      }
    } else {
      headLength += 32
    }
  })

  for (var i = 0; i < types.length; i++) {
    var type = elementaryName(types[i])
    var value = values[i]
    var cur = encodeSingle(type, value)

    // Use the head/tail method for storing dynamic data
    if (isDynamic(type)) {
      output.push(encodeSingle('uint256', headLength))
      data.push(cur)
      headLength += cur.length
    } else {
      output.push(cur)
    }
  }

  return Buffer.concat(output.concat(data))
}

ABI.rawDecode = function (types, data) {
  var ret = []
  data = Buffer.from(data)
  var offset = 0
  for (var i = 0; i < types.length; i++) {
    var type = elementaryName(types[i])
    var parsed = parseType(type, data, offset)
    var decoded = decodeSingle(parsed, data, offset)
    offset += parsed.memoryUsage
    ret.push(decoded)
  }
  return ret
}

ABI.simpleEncode = function (method) {
  var args = Array.prototype.slice.call(arguments).slice(1)
  var sig = parseSignature(method)

  // FIXME: validate/convert arguments
  if (args.length !== sig.args.length) {
    throw new Error('Argument count mismatch')
  }

  return Buffer.concat([ ABI.methodID(sig.method, sig.args), ABI.rawEncode(sig.args, args) ])
}

ABI.simpleDecode = function (method, data) {
  var sig = parseSignature(method)

  // FIXME: validate/convert arguments
  if (!sig.retargs) {
    throw new Error('No return values in method')
  }

  return ABI.rawDecode(sig.retargs, data)
}

function stringify (type, value) {
  if (type.startsWith('address') || type.startsWith('bytes')) {
    return '0x' + value.toString('hex')
  } else {
    return value.toString()
  }
}

ABI.stringify = function (types, values) {
  var ret = []

  for (var i in types) {
    var type = types[i]
    var value = values[i]

    // if it is an array type, concat the items
    if (/^[^\[]+\[.*\]$/.test(type)) {
      value = value.map(function (item) {
        return stringify(type, item)
      }).join(', ')
    } else {
      value = stringify(type, value)
    }

    ret.push(value)
  }

  return ret
}

ABI.solidityPack = function (types, values) {
  if (types.length !== values.length) {
    throw new Error('Number of types are not matching the values')
  }

  var size, num
  var ret = []

  for (var i = 0; i < types.length; i++) {
    var type = elementaryName(types[i])
    var value = values[i]

    if (type === 'bytes') {
      ret.push(value)
    } else if (type === 'string') {
      ret.push(Buffer.from(value, 'utf8'))
    } else if (type === 'bool') {
      ret.push(Buffer.from(value ? '01' : '00', 'hex'))
    } else if (type === 'address') {
      ret.push(utils.setLengthLeft(value, 20))
    } else if (type.startsWith('bytes')) {
      size = parseTypeN(type)
      if (size < 1 || size > 32) {
        throw new Error('Invalid bytes<N> width: ' + size)
      }

      ret.push(utils.setLengthRight(value, size))
    } else if (type.startsWith('uint')) {
      size = parseTypeN(type)
      if ((size % 8) || (size < 8) || (size > 256)) {
        throw new Error('Invalid uint<N> width: ' + size)
      }

      num = parseNumber(value)
      if (num.bitLength() > size) {
        throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength())
      }

      ret.push(num.toArrayLike(Buffer, 'be', size / 8))
    } else if (type.startsWith('int')) {
      size = parseTypeN(type)
      if ((size % 8) || (size < 8) || (size > 256)) {
        throw new Error('Invalid int<N> width: ' + size)
      }

      num = parseNumber(value)
      if (num.bitLength() > size) {
        throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength())
      }

      ret.push(num.toTwos(size).toArrayLike(Buffer, 'be', size / 8))
    } else {
      // FIXME: support all other types
      throw new Error('Unsupported or invalid type: ' + type)
    }
  }

  return Buffer.concat(ret)
}

ABI.soliditySHA3 = function (types, values) {
  return utils.keccak256(ABI.solidityPack(types, values))
}

ABI.soliditySHA256 = function (types, values) {
  return utils.sha256(ABI.solidityPack(types, values))
}

ABI.solidityRIPEMD160 = function (types, values) {
  return utils.ripemd160(ABI.solidityPack(types, values), true)
}

// Serpent's users are familiar with this encoding
// - s: string
// - b: bytes
// - b<N>: bytes<N>
// - i: int256
// - a: int256[]

function isNumeric (c) {
  // FIXME: is this correct? Seems to work
  return (c >= '0') && (c <= '9')
}

// For a "documentation" refer to https://github.com/ethereum/serpent/blob/develop/preprocess.cpp
ABI.fromSerpent = function (sig) {
  var ret = []
  for (var i = 0; i < sig.length; i++) {
    var type = sig[i]
    if (type === 's') {
      ret.push('bytes')
    } else if (type === 'b') {
      var tmp = 'bytes'
      var j = i + 1
      while ((j < sig.length) && isNumeric(sig[j])) {
        tmp += sig[j] - '0'
        j++
      }
      i = j - 1
      ret.push(tmp)
    } else if (type === 'i') {
      ret.push('int256')
    } else if (type === 'a') {
      ret.push('int256[]')
    } else {
      throw new Error('Unsupported or invalid type: ' + type)
    }
  }
  return ret
}

ABI.toSerpent = function (types) {
  var ret = []
  for (var i = 0; i < types.length; i++) {
    var type = types[i]
    if (type === 'bytes') {
      ret.push('s')
    } else if (type.startsWith('bytes')) {
      ret.push('b' + parseTypeN(type))
    } else if (type === 'int256') {
      ret.push('i')
    } else if (type === 'int256[]') {
      ret.push('a')
    } else {
      throw new Error('Unsupported or invalid type: ' + type)
    }
  }
  return ret.join('')
}

module.exports = ABI

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-abi",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/node_modules/bech32/dist/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/node_modules/bech32/dist/index.js
      return function (require, module, exports) {
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.bech32m = exports.bech32 = void 0;
const ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
const ALPHABET_MAP = {};
for (let z = 0; z < ALPHABET.length; z++) {
    const x = ALPHABET.charAt(z);
    ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
    const b = pre >> 25;
    return (((pre & 0x1ffffff) << 5) ^
        (-((b >> 0) & 1) & 0x3b6a57b2) ^
        (-((b >> 1) & 1) & 0x26508e6d) ^
        (-((b >> 2) & 1) & 0x1ea119fa) ^
        (-((b >> 3) & 1) & 0x3d4233dd) ^
        (-((b >> 4) & 1) & 0x2a1462b3));
}
function prefixChk(prefix) {
    let chk = 1;
    for (let i = 0; i < prefix.length; ++i) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
            return 'Invalid prefix (' + prefix + ')';
        chk = polymodStep(chk) ^ (c >> 5);
    }
    chk = polymodStep(chk);
    for (let i = 0; i < prefix.length; ++i) {
        const v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ (v & 0x1f);
    }
    return chk;
}
function convert(data, inBits, outBits, pad) {
    let value = 0;
    let bits = 0;
    const maxV = (1 << outBits) - 1;
    const result = [];
    for (let i = 0; i < data.length; ++i) {
        value = (value << inBits) | data[i];
        bits += inBits;
        while (bits >= outBits) {
            bits -= outBits;
            result.push((value >> bits) & maxV);
        }
    }
    if (pad) {
        if (bits > 0) {
            result.push((value << (outBits - bits)) & maxV);
        }
    }
    else {
        if (bits >= inBits)
            return 'Excess padding';
        if ((value << (outBits - bits)) & maxV)
            return 'Non-zero padding';
    }
    return result;
}
function toWords(bytes) {
    return convert(bytes, 8, 5, true);
}
function fromWordsUnsafe(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
        return res;
}
function fromWords(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
        return res;
    throw new Error(res);
}
function getLibraryFromEncoding(encoding) {
    let ENCODING_CONST;
    if (encoding === 'bech32') {
        ENCODING_CONST = 1;
    }
    else {
        ENCODING_CONST = 0x2bc830a3;
    }
    function encode(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT)
            throw new TypeError('Exceeds length limit');
        prefix = prefix.toLowerCase();
        // determine chk mod
        let chk = prefixChk(prefix);
        if (typeof chk === 'string')
            throw new Error(chk);
        let result = prefix + '1';
        for (let i = 0; i < words.length; ++i) {
            const x = words[i];
            if (x >> 5 !== 0)
                throw new Error('Non 5-bit word');
            chk = polymodStep(chk) ^ x;
            result += ALPHABET.charAt(x);
        }
        for (let i = 0; i < 6; ++i) {
            chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for (let i = 0; i < 6; ++i) {
            const v = (chk >> ((5 - i) * 5)) & 0x1f;
            result += ALPHABET.charAt(v);
        }
        return result;
    }
    function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
            return str + ' too short';
        if (str.length > LIMIT)
            return 'Exceeds length limit';
        // don't allow mixed case
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
            return 'Mixed-case string ' + str;
        str = lowered;
        const split = str.lastIndexOf('1');
        if (split === -1)
            return 'No separator character for ' + str;
        if (split === 0)
            return 'Missing prefix for ' + str;
        const prefix = str.slice(0, split);
        const wordChars = str.slice(split + 1);
        if (wordChars.length < 6)
            return 'Data too short';
        let chk = prefixChk(prefix);
        if (typeof chk === 'string')
            return chk;
        const words = [];
        for (let i = 0; i < wordChars.length; ++i) {
            const c = wordChars.charAt(i);
            const v = ALPHABET_MAP[c];
            if (v === undefined)
                return 'Unknown character ' + c;
            chk = polymodStep(chk) ^ v;
            // not in the checksum?
            if (i + 6 >= wordChars.length)
                continue;
            words.push(v);
        }
        if (chk !== ENCODING_CONST)
            return 'Invalid checksum for ' + str;
        return { prefix, words };
    }
    function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object')
            return res;
    }
    function decode(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object')
            return res;
        throw new Error(res);
    }
    return {
        decodeUnsafe,
        decode,
        encode,
        toWords,
        fromWordsUnsafe,
        fromWords,
    };
}
exports.bech32 = getLibraryFromEncoding('bech32');
exports.bech32m = getLibraryFromEncoding('bech32m');

      };
    };
  }
}, {package:"bech32",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/node_modules/bech32/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/is-object.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/is-object.js
      return function (require, module, exports) {
'use strict';

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null !== obj && 'object' === typeof obj;
}

module.exports = isObject;

      };
    };
  }
}, {package:"superagent",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/is-object.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/agent-base.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/agent-base.js
      return function (require, module, exports) {
function Agent() {
  this._defaults = [];
}

["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects",
 "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(function(fn) {
  /** Default setting for all requests from this agent */
  Agent.prototype[fn] = function(/*varargs*/) {
    this._defaults.push({fn:fn, arguments:arguments});
    return this;
  }
});

Agent.prototype._setDefaults = function(req) {
    this._defaults.forEach(function(def) {
      req[def.fn].apply(req, def.arguments);
    });
};

module.exports = Agent;

      };
    };
  }
}, {package:"superagent",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/agent-base.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/component-emitter/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/component-emitter/index.js
      return function (require, module, exports) {

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

      };
    };
  }
}, {package:"component-emitter",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/component-emitter/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/request-base.js", {"./is-object":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/is-object.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/request-base.js
      return function (require, module, exports) {
'use strict';

/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = require('./is-object');

/**
 * Expose `RequestBase`.
 */

module.exports = RequestBase;

/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }
  return obj;
}

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.clearTimeout = function _clearTimeout(){
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.serialize = function serialize(fn){
  this._serializer = fn;
  return this;
};

/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.timeout = function timeout(options){
  if (!options || 'object' !== typeof options) {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for(var option in options) {
    switch(option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;
      case 'response':
        this._responseTimeout = options.response;
        break;
      default:
        console.warn("Unknown timeout option", option);
    }
  }
  return this;
};

/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.retry = function retry(count, fn){
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

var ERROR_CODES = [
  'ECONNRESET',
  'ETIMEDOUT',
  'EADDRINFO',
  'ESOCKETTIMEDOUT'
];

/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */
RequestBase.prototype._shouldRetry = function(err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }
  if (this._retryCallback) {
    try {
      var override = this._retryCallback(err, res);
      if (override === true) return true;
      if (override === false) return false;
      // undefined falls back to defaults
    } catch(e) {
      console.error(e);
    }
  }
  if (res && res.status && res.status >= 500 && res.status != 501) return true;
  if (err) {
    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;
    // Superagent timeout
    if (err.timeout && err.code == 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }
  return false;
};

/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */

RequestBase.prototype._retry = function() {

  this.clearTimeout();

  // node
  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;

  return this._end();
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */

RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;
    if (this._endCalled) {
      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
    }
    this._fullfilledPromise = new Promise(function(innerResolve, innerReject) {
      self.end(function(err, res) {
        if (err) innerReject(err);
        else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype['catch'] = function(cb) {
  return this.then(undefined, cb);
};

/**
 * Allow for extension
 */

RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function(cb) {
  if ('function' !== typeof cb) throw Error("Callback required");
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function(res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};

/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

RequestBase.prototype.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

RequestBase.prototype.getHeader = RequestBase.prototype.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
RequestBase.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
RequestBase.prototype.field = function(name, val) {
  // name should be either a string or an object.
  if (null === name || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (var key in name) {
      this.field(key, name[key]);
    }
    return this;
  }

  if (Array.isArray(val)) {
    for (var i in val) {
      this.field(name, val[i]);
    }
    return this;
  }

  // val should be defined now
  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }
  if ('boolean' === typeof val) {
    val = '' + val;
  }
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
RequestBase.prototype.abort = function(){
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function(user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', 'Basic ' + base64Encoder(user + ':' + pass));
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', 'Bearer ' + user);
      break;
  }
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

RequestBase.prototype.withCredentials = function(on) {
  // This is browser-only functionality. Node side is no-op.
  if (on == undefined) on = true;
  this._withCredentials = on;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.redirects = function(n){
  this._maxRedirects = n;
  return this;
};

/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n
 * @return {Request} for chaining
 */
RequestBase.prototype.maxResponseSize = function(n){
  if ('number' !== typeof n) {
    throw TypeError("Invalid argument");
  }
  this._maxResponseSize = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

RequestBase.prototype.toJSON = function() {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header,
  };
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.send = function(data){
  var isObj = isObject(data);
  var type = this._header['content-type'];

  if (this._formData) {
    console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw Error("Can't merge these send calls");
  }

  // merge
  if (isObj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  }

  // default to json
  if (!type) this.type('json');
  return this;
};

/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.sortQuery = function(sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */
RequestBase.prototype._finalizeQueryString = function(){
  var query = this._query.join('&');
  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }
  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    var index = this.url.indexOf('?');
    if (index >= 0) {
      var queryArr = this.url.substring(index + 1).split('&');
      if ('function' === typeof this._sort) {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }
      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
};

// For backwards compat only
RequestBase.prototype._appendQueryString = function() {console.trace("Unsupported");}

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

RequestBase.prototype._timeoutError = function(reason, timeout, errno){
  if (this._aborted) {
    return;
  }
  var err = new Error(reason + timeout + 'ms exceeded');
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function() {
  var self = this;

  // deadline
  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  }
  // response timeout
  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function(){
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};

      };
    };
  }
}, {package:"superagent",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/request-base.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/response-base.js", {"./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/response-base.js
      return function (require, module, exports) {
'use strict';

/**
 * Module dependencies.
 */

var utils = require('./utils');

/**
 * Expose `ResponseBase`.
 */

module.exports = ResponseBase;

/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }
  return obj;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

ResponseBase.prototype.get = function(field) {
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

ResponseBase.prototype._setHeaderProperties = function(header){
    // TODO: moar!
    // TODO: make this a util

    // content-type
    var ct = header['content-type'] || '';
    this.type = utils.type(ct);

    // params
    var params = utils.params(ct);
    for (var key in params) this[key] = params[key];

    this.links = {};

    // links
    try {
        if (header.link) {
            this.links = utils.parseLinks(header.link);
        }
    } catch (err) {
        // ignore
    }
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

ResponseBase.prototype._setStatusProperties = function(status){
    var type = status / 100 | 0;

    // status / class
    this.status = this.statusCode = status;
    this.statusType = type;

    // basics
    this.info = 1 == type;
    this.ok = 2 == type;
    this.redirect = 3 == type;
    this.clientError = 4 == type;
    this.serverError = 5 == type;
    this.error = (4 == type || 5 == type)
        ? this.toError()
        : false;

    // sugar
    this.created = 201 == status;
    this.accepted = 202 == status;
    this.noContent = 204 == status;
    this.badRequest = 400 == status;
    this.unauthorized = 401 == status;
    this.notAcceptable = 406 == status;
    this.forbidden = 403 == status;
    this.notFound = 404 == status;
    this.unprocessableEntity = 422 == status;
};

      };
    };
  }
}, {package:"superagent",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/response-base.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/index.js", {"./and":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/and.js","./circular-shift-left":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/circular-shift-left.js","./circular-shift-right":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/circular-shift-right.js","./nand":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/nand.js","./nor":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/nor.js","./not":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/not.js","./or":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/or.js","./reduce-and":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-and.js","./reduce-nand":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-nand.js","./reduce-nor":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-nor.js","./reduce-or":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-or.js","./reduce-xnor":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-xnor.js","./reduce-xor":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-xor.js","./to-boolean":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/to-boolean.js","./to-string":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/to-string.js","./xnor":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/xnor.js","./xor":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/xor.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xor = exports.xnor = exports.toString = exports.toBoolean = exports.reduceXor = exports.reduceXnor = exports.reduceOr = exports.reduceNor = exports.reduceNand = exports.reduceAnd = exports.or = exports.not = exports.nor = exports.nand = exports.circularShiftRight = exports.circularShiftLeft = exports.and = void 0;
var and_1 = require("./and");
exports.and = and_1.default;
var circular_shift_left_1 = require("./circular-shift-left");
exports.circularShiftLeft = circular_shift_left_1.default;
var circular_shift_right_1 = require("./circular-shift-right");
exports.circularShiftRight = circular_shift_right_1.default;
var nand_1 = require("./nand");
exports.nand = nand_1.default;
var nor_1 = require("./nor");
exports.nor = nor_1.default;
var not_1 = require("./not");
exports.not = not_1.default;
var or_1 = require("./or");
exports.or = or_1.default;
var reduce_and_1 = require("./reduce-and");
exports.reduceAnd = reduce_and_1.default;
var reduce_nand_1 = require("./reduce-nand");
exports.reduceNand = reduce_nand_1.default;
var reduce_nor_1 = require("./reduce-nor");
exports.reduceNor = reduce_nor_1.default;
var reduce_or_1 = require("./reduce-or");
exports.reduceOr = reduce_or_1.default;
var reduce_xnor_1 = require("./reduce-xnor");
exports.reduceXnor = reduce_xnor_1.default;
var reduce_xor_1 = require("./reduce-xor");
exports.reduceXor = reduce_xor_1.default;
var to_boolean_1 = require("./to-boolean");
exports.toBoolean = to_boolean_1.default;
var to_string_1 = require("./to-string");
exports.toString = to_string_1.default;
var xnor_1 = require("./xnor");
exports.xnor = xnor_1.default;
var xor_1 = require("./xor");
exports.xor = xor_1.default;
exports.default = {
    and: and_1.default,
    circularShiftLeft: circular_shift_left_1.default,
    circularShiftRight: circular_shift_right_1.default,
    nand: nand_1.default,
    nor: nor_1.default,
    not: not_1.default,
    or: or_1.default,
    reduceAnd: reduce_and_1.default,
    reduceNand: reduce_nand_1.default,
    reduceNor: reduce_nor_1.default,
    reduceOr: reduce_or_1.default,
    reduceXnor: reduce_xnor_1.default,
    reduceXor: reduce_xor_1.default,
    toBoolean: to_boolean_1.default,
    toString: to_string_1.default,
    xnor: xnor_1.default,
    xor: xor_1.default,
};

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/integer/index.js", {"./get-bit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/integer/get-bit.js","./set-bit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/integer/set-bit.js","./toggle-bit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/integer/toggle-bit.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/integer/index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toggleBit = exports.setBit = exports.getBit = void 0;
var get_bit_1 = require("./get-bit");
exports.getBit = get_bit_1.default;
var set_bit_1 = require("./set-bit");
exports.setBit = set_bit_1.default;
var toggle_bit_1 = require("./toggle-bit");
exports.toggleBit = toggle_bit_1.default;
exports.default = { getBit: get_bit_1.default, setBit: set_bit_1.default, toggleBit: toggle_bit_1.default };

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/integer/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/byte/index.js", {"./read":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/byte/read.js","./write":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/byte/write.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/byte/index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.write = exports.read = void 0;
var read_1 = require("./read");
exports.read = read_1.default;
var write_1 = require("./write");
exports.write = write_1.default;
exports.default = { read: read_1.default, write: write_1.default };

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/byte/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/string/index.js", {"./to-bits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/string/to-bits.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/string/index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toBits = void 0;
var to_bits_1 = require("./to-bits");
exports.toBits = to_bits_1.default;
exports.default = { toBits: to_bits_1.default };

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/string/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/nibble/index.js", {"./read":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/nibble/read.js","./write":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/nibble/write.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/nibble/index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.write = exports.read = void 0;
var read_1 = require("./read");
exports.read = read_1.default;
var write_1 = require("./write");
exports.write = write_1.default;
exports.default = { read: read_1.default, write: write_1.default };

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/nibble/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/index.js", {"./and":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/and.js","./create":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/create.js","./modify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/modify.js","./nand":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/nand.js","./nor":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/nor.js","./not":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/not.js","./or":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/or.js","./read":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/read.js","./read-int":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/read-int.js","./read-u-int":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/read-u-int.js","./xnor":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/xnor.js","./xor":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/xor.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xor = exports.xnor = exports.readUInt = exports.readInt = exports.read = exports.or = exports.not = exports.nor = exports.nand = exports.modify = exports.create = exports.and = void 0;
var and_1 = require("./and");
exports.and = and_1.default;
var create_1 = require("./create");
exports.create = create_1.default;
var modify_1 = require("./modify");
exports.modify = modify_1.default;
var nand_1 = require("./nand");
exports.nand = nand_1.default;
var nor_1 = require("./nor");
exports.nor = nor_1.default;
var not_1 = require("./not");
exports.not = not_1.default;
var or_1 = require("./or");
exports.or = or_1.default;
var read_1 = require("./read");
exports.read = read_1.default;
var read_int_1 = require("./read-int");
exports.readInt = read_int_1.default;
var read_u_int_1 = require("./read-u-int");
exports.readUInt = read_u_int_1.default;
var xnor_1 = require("./xnor");
exports.xnor = xnor_1.default;
var xor_1 = require("./xor");
exports.xor = xor_1.default;
exports.default = {
    and: and_1.default,
    create: create_1.default,
    modify: modify_1.default,
    nand: nand_1.default,
    nor: nor_1.default,
    not: not_1.default,
    or: or_1.default,
    read: read_1.default,
    readInt: read_int_1.default,
    readUInt: read_u_int_1.default,
    xnor: xnor_1.default,
    xor: xor_1.default,
};

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/node_modules/bignumber.js/bignumber.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/node_modules/bignumber.js/bignumber.js
      return function (require, module, exports) {
;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.0.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                    // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',      // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on ±Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and ±Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to ±Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = ±Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return ±0, else return ±Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, ±Infinity or ±0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return ±Infinity if either is ±Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return ±0 if either is ±0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return ±Infinity if either ±Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) -- > 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () { return BigNumber; });

  // Node.js and other environments that support module.exports.
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = BigNumber;

  // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }

    globalObject.BigNumber = BigNumber;
  }
})(this);

      };
    };
  }
}, {package:"bignumber.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/node_modules/bignumber.js/bignumber.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/rlp-browser/index.js", {"assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","buffer/":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/rlp-browser/index.js
      return function (require, module, exports) {
const assert = require('assert')
const Buffer = require('buffer/').Buffer
/**
 * RLP Encoding based on: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP
 * This function takes in a data, convert it to buffer if not, and a length for recursion
 *
 * @param {Buffer,String,Integer,Array} data - will be converted to buffer
 * @returns {Buffer} - returns buffer of encoded data
 **/
exports.encode = function (input) {
  if (input instanceof Array) {
    var output = []
    for (var i = 0; i < input.length; i++) {
      output.push(exports.encode(input[i]))
    }
    var buf = Buffer.concat(output)
    return Buffer.concat([encodeLength(buf.length, 192), buf])
  } else {
    input = toBuffer(input)
    if (input.length === 1 && input[0] < 128) {
      return input
    } else {
      return Buffer.concat([encodeLength(input.length, 128), input])
    }
  }
}

function safeParseInt (v, base) {
  if (v.slice(0, 2) === '00') {
    throw (new Error('invalid RLP: extra zeros'))
  }

  return parseInt(v, base)
}

function encodeLength (len, offset) {
  if (len < 56) {
    return new Buffer([len + offset])
  } else {
    var hexLength = intToHex(len)
    var lLength = hexLength.length / 2
    var firstByte = intToHex(offset + 55 + lLength)
    return new Buffer(firstByte + hexLength, 'hex')
  }
}

/**
 * RLP Decoding based on: {@link https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP|RLP}
 * @param {Buffer,String,Integer,Array} data - will be converted to buffer
 * @returns {Array} - returns decode Array of Buffers containg the original message
 **/
exports.decode = function (input, stream) {
  if (!input || input.length === 0) {
    return new Buffer([])
  }

  input = toBuffer(input)
  var decoded = _decode(input)

  if (stream) {
    return decoded
  }

  assert.equal(decoded.remainder.length, 0, 'invalid remainder')
  return decoded.data
}

exports.getLength = function (input) {
  if (!input || input.length === 0) {
    return new Buffer([])
  }

  input = toBuffer(input)
  var firstByte = input[0]
  if (firstByte <= 0x7f) {
    return input.length
  } else if (firstByte <= 0xb7) {
    return firstByte - 0x7f
  } else if (firstByte <= 0xbf) {
    return firstByte - 0xb6
  } else if (firstByte <= 0xf7) {
    // a list between  0-55 bytes long
    return firstByte - 0xbf
  } else {
    // a list  over 55 bytes long
    var llength = firstByte - 0xf6
    var length = safeParseInt(input.slice(1, llength).toString('hex'), 16)
    return llength + length
  }
}

function _decode (input) {
  var length, llength, data, innerRemainder, d
  var decoded = []
  var firstByte = input[0]

  if (firstByte <= 0x7f) {
    // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
    return {
      data: input.slice(0, 1),
      remainder: input.slice(1)
    }
  } else if (firstByte <= 0xb7) {
    // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
    // The range of the first byte is [0x80, 0xb7]
    length = firstByte - 0x7f

    // set 0x80 null to 0
    if (firstByte === 0x80) {
      data = new Buffer([])
    } else {
      data = input.slice(1, length)
    }

    if (length === 2 && data[0] < 0x80) {
      throw new Error('invalid rlp encoding: byte must be less 0x80')
    }

    return {
      data: data,
      remainder: input.slice(length)
    }
  } else if (firstByte <= 0xbf) {
    llength = firstByte - 0xb6
    length = safeParseInt(input.slice(1, llength).toString('hex'), 16)
    data = input.slice(llength, length + llength)
    if (data.length < length) {
      throw (new Error('invalid RLP'))
    }

    return {
      data: data,
      remainder: input.slice(length + llength)
    }
  } else if (firstByte <= 0xf7) {
    // a list between  0-55 bytes long
    length = firstByte - 0xbf
    innerRemainder = input.slice(1, length)
    while (innerRemainder.length) {
      d = _decode(innerRemainder)
      decoded.push(d.data)
      innerRemainder = d.remainder
    }

    return {
      data: decoded,
      remainder: input.slice(length)
    }
  } else {
    // a list  over 55 bytes long
    llength = firstByte - 0xf6
    length = safeParseInt(input.slice(1, llength).toString('hex'), 16)
    var totalLength = llength + length
    if (totalLength > input.length) {
      throw new Error('invalid rlp: total length is larger than the data')
    }

    innerRemainder = input.slice(llength, totalLength)
    if (innerRemainder.length === 0) {
      throw new Error('invalid rlp, List has a invalid length')
    }

    while (innerRemainder.length) {
      d = _decode(innerRemainder)
      decoded.push(d.data)
      innerRemainder = d.remainder
    }
    return {
      data: decoded,
      remainder: input.slice(totalLength)
    }
  }
}

function isHexPrefixed (str) {
  return str.slice(0, 2) === '0x'
}

// Removes 0x from a given String
function stripHexPrefix (str) {
  if (typeof str !== 'string') {
    return str
  }
  return isHexPrefixed(str) ? str.slice(2) : str
}

function intToHex (i) {
  var hex = i.toString(16)
  if (hex.length % 2) {
    hex = '0' + hex
  }

  return hex
}

function padToEven (a) {
  if (a.length % 2) a = '0' + a
  return a
}

function intToBuffer (i) {
  var hex = intToHex(i)
  return new Buffer(hex, 'hex')
}

function toBuffer (v) {
  if (!Buffer.isBuffer(v)) {
    if (typeof v === 'string') {
      if (isHexPrefixed(v)) {
        v = new Buffer(padToEven(stripHexPrefix(v)), 'hex')
      } else {
        v = new Buffer(v)
      }
    } else if (typeof v === 'number') {
      if (!v) {
        v = new Buffer([])
      } else {
        v = intToBuffer(v)
      }
    } else if (v === null || v === undefined) {
      v = new Buffer([])
    } else if (v.toArray) {
      // converts a BN to a Buffer
      v = new Buffer(v.toArray())
    } else {
      throw new Error('invalid type')
    }
  }
  return v
}

      };
    };
  }
}, {package:"rlp-browser",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/rlp-browser/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethers-eip712/dist/index.js", {"ethers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethers/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ethers-eip712/dist/index.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ethers = require('ethers');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var TypedDataUtils = {
    encodeDigest: function (typedData) {
        var eip191Header = ethers.ethers.utils.arrayify('0x1901');
        var domainHash = TypedDataUtils.hashStruct(typedData, 'EIP712Domain', typedData.domain);
        var messageHash = TypedDataUtils.hashStruct(typedData, typedData.primaryType, typedData.message);
        var pack = ethers.ethers.utils.solidityPack(['bytes', 'bytes32', 'bytes32'], [eip191Header, zeroPad(domainHash, 32), zeroPad(messageHash, 32)]);
        var hashPack = ethers.ethers.utils.keccak256(pack);
        return ethers.ethers.utils.arrayify(hashPack);
    },
    encodeData: function (typedData, primaryType, data) {
        var types = typedData.types;
        var args = types[primaryType];
        if (!args || args.length === 0) {
            throw new Error("TypedDataUtils: " + typedData.primaryType + " type is not unknown");
        }
        var abiCoder = new ethers.ethers.utils.AbiCoder();
        var abiTypes = [];
        var abiValues = [];
        var typeHash = TypedDataUtils.typeHash(typedData.types, primaryType);
        abiTypes.push('bytes32');
        abiValues.push(zeroPad(typeHash, 32));
        var encodeField = function (name, type, value) {
            if (types[type] !== undefined) {
                return ['bytes32', ethers.ethers.utils.arrayify(ethers.ethers.utils.keccak256(TypedDataUtils.encodeData(typedData, type, value)))];
            }
            if (type === 'bytes' || type === 'string') {
                var v = void 0;
                if (type === 'string') {
                    v = ethers.ethers.utils.toUtf8Bytes(value);
                }
                else {
                    v = ethers.ethers.utils.arrayify(value);
                }
                return ['bytes32', ethers.ethers.utils.arrayify(ethers.ethers.utils.hexZeroPad(ethers.ethers.utils.keccak256(v), 32))];
            }
            else if (type.lastIndexOf('[') > 0) {
                var t_1 = type.slice(0, type.lastIndexOf('['));
                var v = value.map(function (item) { return encodeField(name, t_1, item); });
                return ['bytes32', ethers.ethers.utils.arrayify(ethers.ethers.utils.keccak256(ethers.ethers.utils.arrayify(abiCoder.encode(v.map(function (_a) {
                        var tt = _a[0];
                        return tt;
                    }), v.map(function (_a) {
                        var vv = _a[1];
                        return vv;
                    })))))
                ];
            }
            else {
                return [type, value];
            }
        };
        for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {
            var field = args_1[_i];
            var _a = encodeField(field.name, field.type, data[field.name]), type = _a[0], value = _a[1];
            abiTypes.push(type);
            abiValues.push(value);
        }
        return ethers.ethers.utils.arrayify(abiCoder.encode(abiTypes, abiValues));
    },
    hashStruct: function (typedData, primaryType, data) {
        return ethers.ethers.utils.arrayify(ethers.ethers.utils.keccak256(TypedDataUtils.encodeData(typedData, primaryType, data)));
    },
    typeHash: function (typedDataTypes, primaryType) {
        return ethers.ethers.utils.arrayify(ethers.ethers.utils.keccak256(ethers.ethers.utils.toUtf8Bytes(TypedDataUtils.encodeType(typedDataTypes, primaryType))));
    },
    encodeType: function (typedDataTypes, primaryType) {
        var args = typedDataTypes[primaryType];
        if (!args || args.length === 0) {
            throw new Error("TypedDataUtils: " + primaryType + " type is not defined");
        }
        var subTypes = [];
        var s = primaryType + '(';
        for (var i = 0; i < args.length; i++) {
            var arg = args[i];
            var arrayArg = arg.type.indexOf('[');
            var argType = arrayArg < 0 ? arg.type : arg.type.slice(0, arrayArg);
            if (typedDataTypes[argType] && typedDataTypes[argType].length > 0) {
                var set = false;
                for (var x = 0; x < subTypes.length; x++) {
                    if (subTypes[x] === argType) {
                        set = true;
                    }
                }
                if (!set) {
                    subTypes.push(argType);
                }
            }
            s += arg.type + ' ' + arg.name;
            if (i < args.length - 1) {
                s += ',';
            }
        }
        s += ')';
        subTypes.sort();
        for (var i = 0; i < subTypes.length; i++) {
            var subEncodeType = TypedDataUtils.encodeType(typedDataTypes, subTypes[i]);
            s += subEncodeType;
        }
        return s;
    },
    domainType: function (domain) {
        var type = [];
        if (domain.name) {
            type.push({ name: 'name', type: 'string' });
        }
        if (domain.version) {
            type.push({ name: 'version', type: 'string' });
        }
        if (domain.chainId) {
            type.push({ name: 'chainId', type: 'uint256' });
        }
        if (domain.verifyingContract) {
            type.push({ name: 'verifyingContract', type: 'address' });
        }
        if (domain.salt) {
            type.push({ name: 'salt', type: 'bytes32' });
        }
        return type;
    },
    buildTypedData: function (domain, messageTypes, primaryType, message) {
        var domainType = TypedDataUtils.domainType(domain);
        var typedData = {
            domain: domain,
            types: __assign({ 'EIP712Domain': domainType }, messageTypes),
            primaryType: primaryType,
            message: message
        };
        return typedData;
    }
};
var encodeTypedDataDigest = function (typedData) {
    return TypedDataUtils.encodeDigest(typedData);
};
var buildTypedData = function (domain, messageTypes, primaryType, message) {
    return TypedDataUtils.buildTypedData(domain, messageTypes, primaryType, message);
};
var domainType = function (domain) {
    return TypedDataUtils.domainType(domain);
};
// zeroPad is implemented as a compat layer between ethers v4 and ethers v5
var zeroPad = function (value, length) {
    return ethers.ethers.utils.arrayify(ethers.ethers.utils.hexZeroPad(ethers.ethers.utils.hexlify(value), length));
};

exports.TypedDataUtils = TypedDataUtils;
exports.buildTypedData = buildTypedData;
exports.domainType = domainType;
exports.encodeTypedDataDigest = encodeTypedDataDigest;

      };
    };
  }
}, {package:"ethers-eip712",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethers-eip712/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/node_modules/secp256k1/elliptic.js", {"./lib":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/node_modules/secp256k1/lib/index.js","./lib/elliptic":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/node_modules/secp256k1/lib/elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/node_modules/secp256k1/elliptic.js
      return function (require, module, exports) {
module.exports = require('./lib')(require('./lib/elliptic'))

      };
    };
  }
}, {package:"secp256k1",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/node_modules/secp256k1/elliptic.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/index.js", {"./decoder":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/decoder.js","./diagnose":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/diagnose.js","./encoder":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/encoder.js","./simple":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/simple.js","./tagged":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/tagged.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/index.js
      return function (require, module, exports) {
'use strict'

// exports.Commented = require('./commented')
exports.Diagnose = require('./diagnose')
exports.Decoder = require('./decoder')
exports.Encoder = require('./encoder')
exports.Simple = require('./simple')
exports.Tagged = require('./tagged')

// exports.comment = exports.Commented.comment
exports.decodeAll = exports.Decoder.decodeAll
exports.decodeFirst = exports.Decoder.decodeFirst
exports.diagnose = exports.Diagnose.diagnose
exports.encode = exports.Encoder.encode
exports.decode = exports.Decoder.decode

exports.leveldb = {
  decode: exports.Decoder.decodeAll,
  encode: exports.Encoder.encode,
  buffer: true,
  name: 'cbor'
}

      };
    };
  }
}, {package:"borc",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseController.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseController = void 0;
/**
 * Controller class that provides configuration, state management, and subscriptions
 */
class BaseController {
    /**
     * Creates a BaseController instance. Both initial state and initial
     * configuration options are merged with defaults upon initialization.
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config = {}, state = {}) {
        /**
         * Default options used to configure this controller
         */
        this.defaultConfig = {};
        /**
         * Default state set on this controller
         */
        this.defaultState = {};
        /**
         * Determines if listeners are notified of state changes
         */
        this.disabled = false;
        /**
         * Name of this controller used during composition
         */
        this.name = 'BaseController';
        this.internalConfig = this.defaultConfig;
        this.internalState = this.defaultState;
        this.internalListeners = [];
        // Use assign since generics can't be spread: https://git.io/vpRhY
        this.initialState = state;
        this.initialConfig = config;
    }
    /**
     * Enables the controller. This sets each config option as a member
     * variable on this instance and triggers any defined setters. This
     * also sets initial state and triggers any listeners.
     *
     * @returns - This controller instance
     */
    initialize() {
        this.internalState = this.defaultState;
        this.internalConfig = this.defaultConfig;
        this.configure(this.initialConfig);
        this.update(this.initialState);
        return this;
    }
    /**
     * Retrieves current controller configuration options
     *
     * @returns - Current configuration
     */
    get config() {
        return this.internalConfig;
    }
    /**
     * Retrieves current controller state
     *
     * @returns - Current state
     */
    get state() {
        return this.internalState;
    }
    /**
     * Updates controller configuration
     *
     * @param config - New configuration options
     * @param overwrite - Overwrite config instead of merging
     * @param fullUpdate - Boolean that defines if the update is partial or not
     */
    configure(config, overwrite = false, fullUpdate = true) {
        if (fullUpdate) {
            this.internalConfig = overwrite
                ? config
                : Object.assign(this.internalConfig, config);
            for (const key in this.internalConfig) {
                if (typeof this.internalConfig[key] !== 'undefined') {
                    this[key] = this.internalConfig[key];
                }
            }
        }
        else {
            for (const key in config) {
                /* istanbul ignore else */
                if (typeof this.internalConfig[key] !== 'undefined') {
                    this.internalConfig[key] = config[key];
                    this[key] = config[key];
                }
            }
        }
    }
    /**
     * Notifies all subscribed listeners of current state
     */
    notify() {
        if (this.disabled) {
            return;
        }
        this.internalListeners.forEach((listener) => {
            listener(this.internalState);
        });
    }
    /**
     * Adds new listener to be notified of state changes
     *
     * @param listener - Callback triggered when state changes
     */
    subscribe(listener) {
        this.internalListeners.push(listener);
    }
    /**
     * Removes existing listener from receiving state changes
     *
     * @param listener - Callback to remove
     * @returns - True if a listener is found and unsubscribed
     */
    unsubscribe(listener) {
        const index = this.internalListeners.findIndex((cb) => listener === cb);
        index > -1 && this.internalListeners.splice(index, 1);
        return index > -1;
    }
    /**
     * Updates controller state
     *
     * @param state - New state
     * @param overwrite - Overwrite state instead of merging
     */
    update(state, overwrite = false) {
        this.internalState = overwrite
            ? Object.assign({}, state)
            : Object.assign({}, this.internalState, state);
        this.notify();
    }
}
exports.BaseController = BaseController;
exports.default = BaseController;
//# sourceMappingURL=BaseController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/ControllerMessenger.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/ControllerMessenger.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ControllerMessenger = exports.RestrictedControllerMessenger = void 0;
/**
 * A restricted controller messenger.
 *
 * This acts as a wrapper around the controller messenger instance that restricts access to actions
 * and events.
 *
 * @template N - The namespace for this messenger. Typically this is the name of the controller or
 *   module that this messenger has been created for. The authority to publish events and register
 *   actions under this namespace is granted to this restricted messenger instance.
 * @template Action - A type union of all Action types.
 * @template Event - A type union of all Event types.
 * @template AllowedAction - A type union of the 'type' string for any allowed actions.
 * @template AllowedEvent - A type union of the 'type' string for any allowed events.
 */
class RestrictedControllerMessenger {
    /**
     * Constructs a restricted controller messenger
     *
     * The provided allowlists grant the ability to call the listed actions and subscribe to the
     * listed events. The "name" provided grants ownership of any actions and events under that
     * namespace. Ownership allows registering actions and publishing events, as well as
     * unregistering actions and clearing event subscriptions.
     *
     * @param options
     * @param options.controllerMessenger - The controller messenger instance that is being wrapped.
     * @param options.name - The name of the thing this messenger will be handed to (e.g. the
     *   controller name). This grants "ownership" of actions and events under this namespace to the
     *   restricted controller messenger returned.
     * @param options.allowedActions - The list of actions that this restricted controller messenger
     *   should be alowed to call.
     * @param options.allowedEvents - The list of events that this restricted controller messenger
     *   should be allowed to subscribe to.
     */
    constructor({ controllerMessenger, name, allowedActions, allowedEvents, }) {
        this.controllerMessenger = controllerMessenger;
        this.controllerName = name;
        this.allowedActions = allowedActions || null;
        this.allowedEvents = allowedEvents || null;
    }
    /**
     * Register an action handler.
     *
     * This will make the registered function available to call via the `call` method.
     *
     * The action type this handler is registered under *must* be in the current namespace.
     *
     * @param actionType - The action type. This is a unqiue identifier for this action.
     * @param handler- The action handler. This function gets called when the `call` method is
     *   invoked with the given action type.
     * @throws Will throw when a handler has been registered for this action type already.
     * @template T - A type union of Action type strings that are namespaced by N.
     */
    registerActionHandler(action, handler) {
        /* istanbul ignore if */ // Branch unreachable with valid types
        if (!action.startsWith(`${this.controllerName}:`)) {
            throw new Error(`Only allowed registering action handlers prefixed by '${this.controllerName}:'`);
        }
        return this.controllerMessenger.registerActionHandler(action, handler);
    }
    /**
     * Unregister an action handler.
     *
     * This will prevent this action from being called.
     *
     * The action type being unregistered *must* be in the current namespace.
     *
     * @param actionType - The action type. This is a unqiue identifier for this action.
     * @template T - A type union of Action type strings that are namespaced by N.
     */
    unregisterActionHandler(action) {
        /* istanbul ignore if */ // Branch unreachable with valid types
        if (!action.startsWith(`${this.controllerName}:`)) {
            throw new Error(`Only allowed unregistering action handlers prefixed by '${this.controllerName}:'`);
        }
        return this.controllerMessenger.unregisterActionHandler(action);
    }
    /**
     * Call an action.
     *
     * This function will call the action handler corresponding to the given action type, passing
     * along any parameters given.
     *
     * The action type being called must be on the action allowlist.
     *
     * @param actionType - The action type. This is a unqiue identifier for this action.
     * @param params - The action parameters. These must match the type of the parameters of the
     *   registered action handler.
     * @throws Will throw when no handler has been registered for the given type.
     * @template T - A type union of allowed Action type strings.
     */
    call(action, ...params) {
        /* istanbul ignore next */ // Branches unreachable with valid types
        if (this.allowedActions === null) {
            throw new Error('No actions allowed');
        }
        else if (!this.allowedActions.includes(action)) {
            throw new Error(`Action missing from allow list: ${action}`);
        }
        return this.controllerMessenger.call(action, ...params);
    }
    /**
     * Publish an event.
     *
     * Publishes the given payload to all subscribers of the given event type.
     *
     * The event type being published *must* be in the current namespace.
     *
     * @param eventType - The event type. This is a unique identifier for this event.
     * @param payload - The event payload. The type of the parameters for each event handler must
     *   match the type of this payload.
     * @template E - A type union of Event type strings that are namespaced by N.
     */
    publish(event, ...payload) {
        /* istanbul ignore if */ // Branch unreachable with valid types
        if (!event.startsWith(`${this.controllerName}:`)) {
            throw new Error(`Only allowed publishing events prefixed by '${this.controllerName}:'`);
        }
        return this.controllerMessenger.publish(event, ...payload);
    }
    subscribe(event, handler, selector) {
        /* istanbul ignore next */ // Branches unreachable with valid types
        if (this.allowedEvents === null) {
            throw new Error('No events allowed');
        }
        else if (!this.allowedEvents.includes(event)) {
            throw new Error(`Event missing from allow list: ${event}`);
        }
        if (selector) {
            return this.controllerMessenger.subscribe(event, handler, selector);
        }
        return this.controllerMessenger.subscribe(event, handler);
    }
    /**
     * Unsubscribe from an event.
     *
     * Unregisters the given function as an event handler for the given event.
     *
     * The event type being unsubscribed to must be on the event allowlist.
     *
     * @param eventType - The event type. This is a unique identifier for this event.
     * @param handler - The event handler to unregister.
     * @throws Will throw when the given event handler is not registered for this event.
     * @template T - A type union of allowed Event type strings.
     */
    unsubscribe(event, handler) {
        /* istanbul ignore next */ // Branches unreachable with valid types
        if (this.allowedEvents === null) {
            throw new Error('No events allowed');
        }
        else if (!this.allowedEvents.includes(event)) {
            throw new Error(`Event missing from allow list: ${event}`);
        }
        return this.controllerMessenger.unsubscribe(event, handler);
    }
    /**
     * Clear subscriptions for a specific event.
     *
     * This will remove all subscribed handlers for this event.
     *
     * The event type being cleared *must* be in the current namespace.
     *
     * @param eventType - The event type. This is a unique identifier for this event.
     * @template E - A type union of Event type strings that are namespaced by N.
     */
    clearEventSubscriptions(event) {
        /* istanbul ignore if */ // Branch unreachable with valid types
        if (!event.startsWith(`${this.controllerName}:`)) {
            throw new Error(`Only allowed clearing events prefixed by '${this.controllerName}:'`);
        }
        return this.controllerMessenger.clearEventSubscriptions(event);
    }
}
exports.RestrictedControllerMessenger = RestrictedControllerMessenger;
/**
 * A messaging system for controllers.
 *
 * The controller messenger allows registering functions as 'actions' that can be called elsewhere,
 * and it allows publishing and subscribing to events. Both actions and events are identified by
 * unique strings.
 *
 * @template Action - A type union of all Action types.
 * @template Event - A type union of all Event types.
 */
class ControllerMessenger {
    constructor() {
        this.actions = new Map();
        this.events = new Map();
        /**
         * A cache of selector return values for their respective handlers.
         */
        this.eventPayloadCache = new Map();
    }
    /**
     * Register an action handler.
     *
     * This will make the registered function available to call via the `call` method.
     *
     * @param actionType - The action type. This is a unqiue identifier for this action.
     * @param handler- The action handler. This function gets called when the `call` method is
     *   invoked with the given action type.
     * @throws Will throw when a handler has been registered for this action type already.
     * @template T - A type union of Action type strings.
     */
    registerActionHandler(actionType, handler) {
        if (this.actions.has(actionType)) {
            throw new Error(`A handler for ${actionType} has already been registered`);
        }
        this.actions.set(actionType, handler);
    }
    /**
     * Unregister an action handler.
     *
     * This will prevent this action from being called.
     *
     * @param actionType - The action type. This is a unqiue identifier for this action.
     * @template T - A type union of Action type strings.
     */
    unregisterActionHandler(actionType) {
        this.actions.delete(actionType);
    }
    /**
     * Unregister all action handlers.
     *
     * This prevents all actions from being called.
     */
    clearActions() {
        this.actions.clear();
    }
    /**
     * Call an action.
     *
     * This function will call the action handler corresponding to the given action type, passing
     * along any parameters given.
     *
     * @param actionType - The action type. This is a unqiue identifier for this action.
     * @param params - The action parameters. These must match the type of the parameters of the
     *   registered action handler.
     * @throws Will throw when no handler has been registered for the given type.
     * @template T - A type union of Action type strings.
     */
    call(actionType, ...params) {
        const handler = this.actions.get(actionType);
        if (!handler) {
            throw new Error(`A handler for ${actionType} has not been registered`);
        }
        return handler(...params);
    }
    /**
     * Publish an event.
     *
     * Publishes the given payload to all subscribers of the given event type.
     *
     * @param eventType - The event type. This is a unique identifier for this event.
     * @param payload - The event payload. The type of the parameters for each event handler must
     *   match the type of this payload.
     * @template E - A type union of Event type strings.
     */
    publish(eventType, ...payload) {
        const subscribers = this.events.get(eventType);
        if (subscribers) {
            for (const [handler, selector] of subscribers.entries()) {
                if (selector) {
                    const previousValue = this.eventPayloadCache.get(handler);
                    const newValue = selector(...payload);
                    if (newValue !== previousValue) {
                        this.eventPayloadCache.set(handler, newValue);
                        handler(newValue, previousValue);
                    }
                }
                else {
                    handler(...payload);
                }
            }
        }
    }
    subscribe(eventType, handler, selector) {
        let subscribers = this.events.get(eventType);
        if (!subscribers) {
            subscribers = new Map();
            this.events.set(eventType, subscribers);
        }
        subscribers.set(handler, selector);
    }
    /**
     * Unsubscribe from an event.
     *
     * Unregisters the given function as an event handler for the given event.
     *
     * @param eventType - The event type. This is a unique identifier for this event.
     * @param handler - The event handler to unregister.
     * @throws Will throw when the given event handler is not registered for this event.
     * @template E - A type union of Event type strings.
     */
    unsubscribe(eventType, handler) {
        const subscribers = this.events.get(eventType);
        if (!subscribers || !subscribers.has(handler)) {
            throw new Error(`Subscription not found for event: ${eventType}`);
        }
        const selector = subscribers.get(handler);
        if (selector) {
            this.eventPayloadCache.delete(handler);
        }
        subscribers.delete(handler);
    }
    /**
     * Clear subscriptions for a specific event.
     *
     * This will remove all subscribed handlers for this event.
     *
     * @param eventType - The event type. This is a unique identifier for this event.
     * @template E - A type union of Event type strings.
     */
    clearEventSubscriptions(eventType) {
        this.events.delete(eventType);
    }
    /**
     * Clear all subscriptions.
     *
     * This will remove all subscribed handlers for all events.
     */
    clearSubscriptions() {
        this.events.clear();
    }
    /**
     * Get a restricted controller messenger
     *
     * Returns a wrapper around the controller messenger instance that restricts access to actions
     * and events. The provided allowlists grant the ability to call the listed actions and subscribe
     * to the listed events. The "name" provided grants ownership of any actions and events under
     * that namespace. Ownership allows registering actions and publishing events, as well as
     * unregistering actions and clearing event subscriptions.
     *
     * @param options
     * @param options.name - The name of the thing this messenger will be handed to (e.g. the
     *   controller name). This grants "ownership" of actions and events under this namespace to the
     *   restricted controller messenger returned.
     * @param options.allowedActions - The list of actions that this restricted controller messenger
     *   should be alowed to call.
     * @param options.allowedEvents - The list of events that this restricted controller messenger
     *   should be allowed to subscribe to.
     * @template N - The namespace for this messenger. Typically this is the name of the controller or
     *   module that this messenger has been created for. The authority to publish events and register
     *   actions under this namespace is granted to this restricted messenger instance.
     * @template AllowedAction - A type union of the 'type' string for any allowed actions.
     * @template AllowedEvent - A type union of the 'type' string for any allowed events.
     */
    getRestricted({ name, allowedActions, allowedEvents, }) {
        return new RestrictedControllerMessenger({
            controllerMessenger: this,
            name,
            allowedActions,
            allowedEvents,
        });
    }
}
exports.ControllerMessenger = ControllerMessenger;
//# sourceMappingURL=ControllerMessenger.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/ControllerMessenger.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/ComposableController.js", {"./BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseController.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/ComposableController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposableController = void 0;
const BaseController_1 = require("./BaseController");
/**
 * Controller that can be used to compose multiple controllers together
 */
class ComposableController extends BaseController_1.BaseController {
    /**
     * Creates a ComposableController instance
     *
     * @param controllers - Map of names to controller instances
     * @param messenger - The controller messaging system, used for communicating with BaseControllerV2 controllers
     */
    constructor(controllers, messenger) {
        super(undefined, controllers.reduce((state, controller) => {
            state[controller.name] = controller.state;
            return state;
        }, {}));
        this.controllers = [];
        /**
         * Name of this controller used during composition
         */
        this.name = 'ComposableController';
        this.initialize();
        this.controllers = controllers;
        this.messagingSystem = messenger;
        this.controllers.forEach((controller) => {
            const { name } = controller;
            if (controller.subscribe !== undefined) {
                controller.subscribe((state) => {
                    this.update({ [name]: state });
                });
            }
            else if (this.messagingSystem) {
                this.messagingSystem.subscribe(`${name}:stateChange`, (state) => {
                    this.update({ [name]: state });
                });
            }
            else {
                throw new Error(`Messaging system required if any BaseControllerV2 controllers are used`);
            }
        });
    }
    /**
     * Flat state representation, one that isn't keyed
     * of controller name. Instead, all child controller state is merged
     * together into a single, flat object.
     *
     * @returns - Merged state representation of all child controllers
     */
    get flatState() {
        let flatState = {};
        for (const controller of this.controllers) {
            flatState = Object.assign(Object.assign({}, flatState), controller.state);
        }
        return flatState;
    }
}
exports.ComposableController = ComposableController;
exports.default = ComposableController;
//# sourceMappingURL=ComposableController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/ComposableController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/user/AddressBookController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseController.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/user/AddressBookController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressBookController = void 0;
const util_1 = require("../util");
const BaseController_1 = require("../BaseController");
/**
 * Controller that manages a list of recipient addresses associated with nicknames
 */
class AddressBookController extends BaseController_1.BaseController {
    /**
     * Creates an AddressBookController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'AddressBookController';
        this.defaultState = { addressBook: {} };
        this.initialize();
    }
    /**
     * Remove all contract entries
     */
    clear() {
        this.update({ addressBook: {} });
    }
    /**
     * Remove a contract entry by address
     *
     * @param chainId - Chain id identifies the current chain
     * @param address - Recipient address to delete
     */
    delete(chainId, address) {
        address = util_1.toChecksumHexAddress(address);
        if (!util_1.isValidHexAddress(address) ||
            !this.state.addressBook[chainId] ||
            !this.state.addressBook[chainId][address]) {
            return false;
        }
        const addressBook = Object.assign({}, this.state.addressBook);
        delete addressBook[chainId][address];
        if (Object.keys(addressBook[chainId]).length === 0) {
            delete addressBook[chainId];
        }
        this.update({ addressBook });
        return true;
    }
    /**
     * Add or update a contact entry by address
     *
     * @param address - Recipient address to add or update
     * @param name - Nickname to associate with this address
     * @param chainId - Chain id identifies the current chain
     * @param memo - User's note about address
     * @returns - Boolean indicating if the address was successfully set
     */
    set(address, name, chainId = '1', memo = '') {
        address = util_1.toChecksumHexAddress(address);
        if (!util_1.isValidHexAddress(address)) {
            return false;
        }
        const entry = {
            address,
            chainId,
            isEns: false,
            memo,
            name,
        };
        const ensName = util_1.normalizeEnsName(name);
        if (ensName) {
            entry.name = ensName;
            entry.isEns = true;
        }
        this.update({
            addressBook: Object.assign(Object.assign({}, this.state.addressBook), { [chainId]: Object.assign(Object.assign({}, this.state.addressBook[chainId]), { [address]: entry }) }),
        });
        return true;
    }
}
exports.AddressBookController = AddressBookController;
exports.default = AddressBookController;
//# sourceMappingURL=AddressBookController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/user/AddressBookController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/AssetsDetectionController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseController.js","../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/constants.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/AssetsDetectionController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssetsDetectionController = void 0;
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
const DEFAULT_INTERVAL = 180000;
/**
 * Controller that passively polls on a set interval for assets auto detection
 */
class AssetsDetectionController extends BaseController_1.BaseController {
    /**
     * Creates a AssetsDetectionController instance
     *
     * @param options
     * @param options.onCollectiblesStateChange - Allows subscribing to assets controller state changes
     * @param options.onTokensStateChange - Allows subscribing to tokens controller state changes
     * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes
     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes
     * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set
     * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address
     * @param options.addTokens - Add a list of tokens
     * @param options.addCollectible - Add a collectible
     * @param options.getCollectiblesState - Gets the current state of the Assets controller
     * @param options.getTokenListState - Gets the current state of the TokenList controller
     * @param options.getTokensState - Gets the current state of the Tokens controller
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor({ onTokensStateChange, onPreferencesStateChange, onNetworkStateChange, getOpenSeaApiKey, getBalancesInSingleCall, addTokens, addCollectible, getCollectiblesState, getTokenListState, getTokensState, }, config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'AssetsDetectionController';
        this.defaultConfig = {
            interval: DEFAULT_INTERVAL,
            networkType: constants_1.MAINNET,
            selectedAddress: '',
            tokens: [],
        };
        this.initialize();
        this.getCollectiblesState = getCollectiblesState;
        this.getTokensState = getTokensState;
        this.getTokenListState = getTokenListState;
        this.addTokens = addTokens;
        onTokensStateChange(({ tokens }) => {
            this.configure({ tokens });
        });
        onPreferencesStateChange(({ selectedAddress }) => {
            const actualSelectedAddress = this.config.selectedAddress;
            if (selectedAddress !== actualSelectedAddress) {
                this.configure({ selectedAddress });
                this.detectAssets();
            }
        });
        onNetworkStateChange(({ provider }) => {
            this.configure({ networkType: provider.type });
        });
        this.getOpenSeaApiKey = getOpenSeaApiKey;
        this.getBalancesInSingleCall = getBalancesInSingleCall;
        this.addCollectible = addCollectible;
        this.poll();
    }
    getOwnerCollectiblesApi(address, offset) {
        return `https://api.opensea.io/api/v1/assets?owner=${address}&offset=${offset}&limit=50`;
    }
    getOwnerCollectibles() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { selectedAddress } = this.config;
            let response;
            let collectibles = [];
            const openSeaApiKey = this.getOpenSeaApiKey();
            try {
                let offset = 0;
                let pagingFinish = false;
                /* istanbul ignore if */
                do {
                    const api = this.getOwnerCollectiblesApi(selectedAddress, offset);
                    response = yield util_1.timeoutFetch(api, openSeaApiKey ? { headers: { 'X-API-KEY': openSeaApiKey } } : {}, 15000);
                    const collectiblesArray = yield response.json();
                    ((_a = collectiblesArray.assets) === null || _a === void 0 ? void 0 : _a.length) !== 0
                        ? (collectibles = [...collectibles, ...collectiblesArray.assets])
                        : (pagingFinish = true);
                    offset += 50;
                } while (!pagingFinish);
            }
            catch (e) {
                /* istanbul ignore next */
                return [];
            }
            return collectibles;
        });
    }
    /**
     * Starts a new polling interval
     *
     * @param interval - Polling interval used to auto detect assets
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield this.detectAssets();
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Checks whether network is mainnet or not
     *
     * @returns - Whether current network is mainnet
     */
    isMainnet() {
        if (this.config.networkType !== constants_1.MAINNET || this.disabled) {
            return false;
        }
        return true;
    }
    /**
     * Detect assets owned by current account on mainnet
     */
    detectAssets() {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            if (!this.isMainnet()) {
                return;
            }
            this.detectTokens();
            this.detectCollectibles();
        });
    }
    /**
     * Triggers asset ERC20 token auto detection for each contract address in contract metadata on mainnet
     */
    detectTokens() {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            if (!this.isMainnet()) {
                return;
            }
            const tokensAddresses = this.config.tokens.map(
            /* istanbul ignore next*/ (token) => token.address.toLowerCase());
            const { tokenList } = this.getTokenListState();
            const tokensToDetect = [];
            for (const address in tokenList) {
                if (!tokensAddresses.includes(address)) {
                    tokensToDetect.push(address);
                }
            }
            const sliceOfTokensToDetect = [];
            sliceOfTokensToDetect[0] = tokensToDetect.slice(0, 1000);
            sliceOfTokensToDetect[1] = tokensToDetect.slice(1000, tokensToDetect.length - 1);
            const { selectedAddress } = this.config;
            /* istanbul ignore else */
            if (!selectedAddress) {
                return;
            }
            for (const tokensSlice of sliceOfTokensToDetect) {
                if (tokensSlice.length === 0) {
                    break;
                }
                yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                    const balances = yield this.getBalancesInSingleCall(selectedAddress, tokensSlice);
                    const tokensToAdd = [];
                    for (const tokenAddress in balances) {
                        let ignored;
                        /* istanbul ignore else */
                        const { ignoredTokens } = this.getTokensState();
                        if (ignoredTokens.length) {
                            ignored = ignoredTokens.find((ignoredTokenAddress) => ignoredTokenAddress === util_1.toChecksumHexAddress(tokenAddress));
                        }
                        const caseInsensitiveTokenKey = Object.keys(tokenList).find((i) => i.toLowerCase() === tokenAddress.toLowerCase()) || '';
                        if (ignored === undefined) {
                            tokensToAdd.push({
                                address: tokenAddress,
                                decimals: tokenList[caseInsensitiveTokenKey].decimals,
                                symbol: tokenList[caseInsensitiveTokenKey].symbol,
                            });
                        }
                    }
                    if (tokensToAdd.length) {
                        yield this.addTokens(tokensToAdd);
                    }
                }));
            }
        });
    }
    /**
     * Triggers asset ERC721 token auto detection on mainnet
     * adding new collectibles and removing not owned collectibles
     */
    detectCollectibles() {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            if (!this.isMainnet()) {
                return;
            }
            const requestedSelectedAddress = this.config.selectedAddress;
            /* istanbul ignore else */
            if (!requestedSelectedAddress) {
                return;
            }
            yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                const apiCollectibles = yield this.getOwnerCollectibles();
                const addCollectiblesPromises = apiCollectibles.map((collectible) => __awaiter(this, void 0, void 0, function* () {
                    const { token_id, num_sales, background_color, image_url, image_preview_url, image_thumbnail_url, image_original_url, animation_url, animation_original_url, name, description, external_link, creator, asset_contract: { address }, last_sale, } = collectible;
                    let ignored;
                    /* istanbul ignore else */
                    const { ignoredCollectibles } = this.getCollectiblesState();
                    if (ignoredCollectibles.length) {
                        ignored = ignoredCollectibles.find((c) => {
                            /* istanbul ignore next */
                            return (c.address === util_1.toChecksumHexAddress(address) &&
                                c.tokenId === Number(token_id));
                        });
                    }
                    /* istanbul ignore else */
                    if (!ignored &&
                        requestedSelectedAddress === this.config.selectedAddress) {
                        /* istanbul ignore next */
                        const collectibleMetadata = Object.assign({}, { name }, creator && { creator }, description && { description }, image_url && { image: image_url }, num_sales && { numberOfSales: num_sales }, background_color && { backgroundColor: background_color }, image_preview_url && { imagePreview: image_preview_url }, image_thumbnail_url && { imageThumbnail: image_thumbnail_url }, image_original_url && { imageOriginal: image_original_url }, animation_url && { animation: animation_url }, animation_original_url && {
                            animationOriginal: animation_original_url,
                        }, external_link && { externalLink: external_link }, last_sale && { lastSale: last_sale });
                        yield this.addCollectible(address, Number(token_id), collectibleMetadata, true);
                    }
                }));
                yield Promise.all(addCollectiblesPromises);
            }));
        });
    }
}
exports.AssetsDetectionController = AssetsDetectionController;
exports.default = AssetsDetectionController;
//# sourceMappingURL=AssetsDetectionController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/AssetsDetectionController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/user/PreferencesController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseController.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/user/PreferencesController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreferencesController = void 0;
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
/**
 * Controller that stores shared settings and exposes convenience methods
 */
class PreferencesController extends BaseController_1.BaseController {
    /**
     * Creates a PreferencesController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'PreferencesController';
        this.defaultState = {
            featureFlags: {},
            frequentRpcList: [],
            identities: {},
            ipfsGateway: 'https://ipfs.io/ipfs/',
            lostIdentities: {},
            selectedAddress: '',
            useStaticTokenList: false,
        };
        this.initialize();
    }
    /**
     * Adds identities to state
     *
     * @param addresses - List of addresses to use to generate new identities
     */
    addIdentities(addresses) {
        const { identities } = this.state;
        addresses.forEach((address) => {
            address = util_1.toChecksumHexAddress(address);
            if (identities[address]) {
                return;
            }
            const identityCount = Object.keys(identities).length;
            identities[address] = {
                name: `Account ${identityCount + 1}`,
                address,
                importTime: Date.now(),
            };
        });
        this.update({ identities: Object.assign({}, identities) });
    }
    /**
     * Removes an identity from state
     *
     * @param address - Address of the identity to remove
     */
    removeIdentity(address) {
        address = util_1.toChecksumHexAddress(address);
        const { identities } = this.state;
        if (!identities[address]) {
            return;
        }
        delete identities[address];
        this.update({ identities: Object.assign({}, identities) });
        if (address === this.state.selectedAddress) {
            this.update({ selectedAddress: Object.keys(identities)[0] });
        }
    }
    /**
     * Associates a new label with an identity
     *
     * @param address - Address of the identity to associate
     * @param label - New label to assign
     */
    setAccountLabel(address, label) {
        address = util_1.toChecksumHexAddress(address);
        const { identities } = this.state;
        identities[address] = identities[address] || {};
        identities[address].name = label;
        this.update({ identities: Object.assign({}, identities) });
    }
    /**
     * Enable or disable a specific feature flag
     *
     * @param feature - Feature to toggle
     * @param activated - Value to assign
     */
    setFeatureFlag(feature, activated) {
        const oldFeatureFlags = this.state.featureFlags;
        const featureFlags = Object.assign(Object.assign({}, oldFeatureFlags), { [feature]: activated });
        this.update({ featureFlags: Object.assign({}, featureFlags) });
    }
    /**
     * Synchronizes the current identity list with new identities
     *
     * @param addresses - List of addresses corresponding to identities to sync
     * @returns - Newly-selected address after syncing
     */
    syncIdentities(addresses) {
        addresses = addresses.map((address) => util_1.toChecksumHexAddress(address));
        const { identities, lostIdentities } = this.state;
        const newlyLost = {};
        for (const identity in identities) {
            if (addresses.indexOf(identity) === -1) {
                newlyLost[identity] = identities[identity];
                delete identities[identity];
            }
        }
        if (Object.keys(newlyLost).length > 0) {
            for (const key in newlyLost) {
                lostIdentities[key] = newlyLost[key];
            }
        }
        this.update({
            identities: Object.assign({}, identities),
            lostIdentities: Object.assign({}, lostIdentities),
        });
        this.addIdentities(addresses);
        if (addresses.indexOf(this.state.selectedAddress) === -1) {
            this.update({ selectedAddress: addresses[0] });
        }
        return this.state.selectedAddress;
    }
    /**
     * Generates and stores a new list of stored identities based on address. If the selected address
     * is unset, or if it refers to an identity that was removed, it will be set to the first
     * identity.
     *
     * @param addresses - List of addresses to use as a basis for each identity
     */
    updateIdentities(addresses) {
        addresses = addresses.map((address) => util_1.toChecksumHexAddress(address));
        const oldIdentities = this.state.identities;
        const identities = addresses.reduce((ids, address, index) => {
            ids[address] = oldIdentities[address] || {
                address,
                name: `Account ${index + 1}`,
                importTime: Date.now(),
            };
            return ids;
        }, {});
        let { selectedAddress } = this.state;
        if (!Object.keys(identities).includes(selectedAddress)) {
            selectedAddress = Object.keys(identities)[0];
        }
        this.update({ identities: Object.assign({}, identities), selectedAddress });
    }
    /**
     * Adds custom RPC URL to state
     *
     * @param url - Custom RPC URL
     * @param chainId? - Network ID as per EIP-155
     * @param ticker? - Currency ticker
     * @param nickname? - Personalized network name
     * @param rpcPrefs? - Personalized preferences
     *
     */
    addToFrequentRpcList(url, chainId, ticker, nickname, rpcPrefs) {
        const { frequentRpcList } = this.state;
        const index = frequentRpcList.findIndex(({ rpcUrl }) => {
            return rpcUrl === url;
        });
        if (index !== -1) {
            frequentRpcList.splice(index, 1);
        }
        const newFrequestRpc = {
            rpcUrl: url,
            chainId,
            ticker,
            nickname,
            rpcPrefs,
        };
        frequentRpcList.push(newFrequestRpc);
        this.update({ frequentRpcList: [...frequentRpcList] });
    }
    /**
     * Removes custom RPC URL from state
     *
     * @param url - Custom RPC URL
     */
    removeFromFrequentRpcList(url) {
        const { frequentRpcList } = this.state;
        const index = frequentRpcList.findIndex(({ rpcUrl }) => {
            return rpcUrl === url;
        });
        if (index !== -1) {
            frequentRpcList.splice(index, 1);
        }
        this.update({ frequentRpcList: [...frequentRpcList] });
    }
    /**
     * Sets selected address
     *
     * @param selectedAddress - Ethereum address
     */
    setSelectedAddress(selectedAddress) {
        this.update({ selectedAddress: util_1.toChecksumHexAddress(selectedAddress) });
    }
    /**
     * Sets new IPFS gateway
     *
     * @param ipfsGateway - IPFS gateway string
     */
    setIpfsGateway(ipfsGateway) {
        this.update({ ipfsGateway });
    }
    /**
     * Toggle the token detection setting to use dynamic token list
     *
     * @param useStaticTokenList - IPFS gateway string
     */
    setUseStaticTokenList(useStaticTokenList) {
        this.update({ useStaticTokenList });
    }
}
exports.PreferencesController = PreferencesController;
exports.default = PreferencesController;
//# sourceMappingURL=PreferencesController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/user/PreferencesController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/notification/NotificationController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseController.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/notification/NotificationController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NotificationController = void 0;
const BaseController_1 = require("../BaseController");
const defaultState = {
    notifications: {},
};
/**
 * Controller for managing in-app announcement notifications.
 */
class NotificationController extends BaseController_1.BaseController {
    /**
     * Creates a NotificationController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state || defaultState);
        this.initialize();
        this._addNotifications();
    }
    /**
     * Compares the notifications in state with the notifications from file
     * to check if there are any new notifications/announcements
     * if yes, the new notification will be added to the state with a flag indicating
     * that the notification is not seen by the user.
     *
     *  @param allNotifications
     */
    _addNotifications() {
        const newNotifications = {};
        const { allNotifications } = this.config;
        Object.values(allNotifications).forEach((notification) => {
            newNotifications[notification.id] = this.state.notifications[notification.id]
                ? this.state.notifications[notification.id]
                : Object.assign(Object.assign({}, notification), { isShown: false });
        });
        this.update({ notifications: newNotifications });
    }
    /**
     * Updates the status of the status of the specified notifications
     * once it is read by the user.
     *
     * @param viewedIds
     */
    updateViewed(viewedIds) {
        const stateNotifications = this.state.notifications;
        for (const id of Object.keys(viewedIds).map(Number)) {
            stateNotifications[id].isShown = viewedIds[id];
        }
        this.update({ notifications: stateNotifications }, true);
    }
}
exports.NotificationController = NotificationController;
//# sourceMappingURL=NotificationController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/notification/NotificationController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/TokenRatesController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseController.js","../apis/crypto-compare":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/apis/crypto-compare.js","../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/constants.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/TokenRatesController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenRatesController = void 0;
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
const crypto_compare_1 = require("../apis/crypto-compare");
const CoinGeckoApi = {
    BASE_URL: 'https://api.coingecko.com/api/v3',
    getTokenPriceURL(chainSlug, query) {
        return `${this.BASE_URL}/simple/token_price/${chainSlug}?${query}`;
    },
    getPlatformsURL() {
        return `${this.BASE_URL}/asset_platforms`;
    },
    getSupportedVsCurrencies() {
        return `${this.BASE_URL}/simple/supported_vs_currencies`;
    },
};
/**
 * Finds the chain slug in the data array given a chainId
 *
 * @param chainId current chainId
 * @param data Array of supported platforms from CoinGecko API
 * @returns Slug of chainId
 */
function findChainSlug(chainId, data) {
    var _a;
    if (!data) {
        return null;
    }
    const chain = (_a = data.find(({ chain_identifier }) => chain_identifier !== null && String(chain_identifier) === chainId)) !== null && _a !== void 0 ? _a : null;
    return (chain === null || chain === void 0 ? void 0 : chain.id) || null;
}
/**
 * Controller that passively polls on a set interval for token-to-fiat exchange rates
 * for tokens stored in the TokensController
 */
class TokenRatesController extends BaseController_1.BaseController {
    /**
     * Creates a TokenRatesController instance
     *
     * @param options
     * @param options.onAssetsStateChange - Allows subscribing to assets controller state changes
     * @param options.onCurrencyRateStateChange - Allows subscribing to currency rate controller state changes
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor({ onTokensStateChange, onCurrencyRateStateChange, onNetworkStateChange, }, config, state) {
        super(config, state);
        this.tokenList = [];
        this.supportedChains = {
            timestamp: 0,
            data: null,
        };
        this.supportedVsCurrencies = {
            timestamp: 0,
            data: [],
        };
        /**
         * Name of this controller used during composition
         */
        this.name = 'TokenRatesController';
        this.defaultConfig = {
            disabled: true,
            interval: 3 * 60 * 1000,
            nativeCurrency: 'eth',
            chainId: '',
            tokens: [],
            threshold: 6 * 60 * 60 * 1000,
        };
        this.defaultState = {
            contractExchangeRates: {},
        };
        this.initialize();
        this.configure({ disabled: false }, false, false);
        onTokensStateChange((tokensState) => {
            this.configure({ tokens: tokensState.tokens });
        });
        onCurrencyRateStateChange((currencyRateState) => {
            this.configure({ nativeCurrency: currencyRateState.nativeCurrency });
        });
        onNetworkStateChange(({ provider }) => {
            const { chainId } = provider;
            this.update({ contractExchangeRates: {} });
            this.configure({ chainId });
        });
        this.poll();
    }
    /**
     * Sets a new polling interval
     *
     * @param interval - Polling interval used to fetch new token rates
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield util_1.safelyExecute(() => this.updateExchangeRates());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Sets a new chainId
     *
     * TODO: Replace this with a method
     *
     * @param chainId current chainId
     */
    set chainId(_chainId) {
        !this.disabled && util_1.safelyExecute(() => this.updateExchangeRates());
    }
    get chainId() {
        throw new Error('Property only used for setting');
    }
    /**
     * Sets a new token list to track prices
     *
     * TODO: Replace this with a method
     *
     * @param tokens - List of tokens to track exchange rates for
     */
    set tokens(tokens) {
        this.tokenList = tokens;
        !this.disabled && util_1.safelyExecute(() => this.updateExchangeRates());
    }
    get tokens() {
        throw new Error('Property only used for setting');
    }
    /**
     * Fetches a pairs of token address and native currency
     *
     * @param chainSlug - Chain string identifier
     * @param vsCurrency - the vsCurrency used to query token exchange rates against.
     * @returns - Promise resolving to exchange rates for given pairs
     */
    fetchExchangeRate(chainSlug, vsCurrency) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenPairs = this.tokenList.map((token) => token.address).join(',');
            const query = `contract_addresses=${tokenPairs}&vs_currencies=${vsCurrency.toLowerCase()}`;
            return util_1.handleFetch(CoinGeckoApi.getTokenPriceURL(chainSlug, query));
        });
    }
    /**
     * Checks if the current native currency is a supported vs currency to use
     * to query for token exchange rates
     *
     * @param nativeCurrency - the native currency of the currently active network
     * @returns - Promise resolving to a boolean indicating whether it's a supported vsCurrency
     */
    checkIsSupportedVsCurrency(nativeCurrency) {
        return __awaiter(this, void 0, void 0, function* () {
            const { threshold } = this.config;
            const { timestamp, data } = this.supportedVsCurrencies;
            const now = Date.now();
            if (now - timestamp > threshold) {
                const currencies = yield util_1.handleFetch(CoinGeckoApi.getSupportedVsCurrencies());
                this.supportedVsCurrencies = {
                    data: currencies,
                    timestamp: Date.now(),
                };
                return currencies.includes(nativeCurrency.toLowerCase());
            }
            return data.includes(nativeCurrency.toLowerCase());
        });
    }
    /**
     * Gets current chainId slug from cached supported platforms CoinGecko API response.
     * If cached supported platforms response is stale, fetches and updates it.
     *
     * @returns current chainId
     */
    getChainSlug() {
        return __awaiter(this, void 0, void 0, function* () {
            const { threshold, chainId } = this.config;
            const { data, timestamp } = this.supportedChains;
            const now = Date.now();
            if (now - timestamp > threshold) {
                const platforms = yield util_1.handleFetch(CoinGeckoApi.getPlatformsURL());
                this.supportedChains = {
                    data: platforms,
                    timestamp: Date.now(),
                };
                return findChainSlug(chainId, platforms);
            }
            return findChainSlug(chainId, data);
        });
    }
    /**
     * Updates exchange rates for all tokens
     *
     * @returns Promise resolving when this operation completes
     */
    updateExchangeRates() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.tokenList.length === 0 || this.disabled) {
                return;
            }
            const slug = yield this.getChainSlug();
            let newContractExchangeRates = {};
            if (!slug) {
                this.tokenList.forEach((token) => {
                    const address = util_1.toChecksumHexAddress(token.address);
                    newContractExchangeRates[address] = undefined;
                });
            }
            else {
                const { nativeCurrency } = this.config;
                newContractExchangeRates = yield this.fetchAndMapExchangeRates(nativeCurrency, slug);
            }
            this.update({ contractExchangeRates: newContractExchangeRates });
        });
    }
    /**
     * Checks if the active network's native currency is supported by the coingecko API
     * If supported. fetches and maps contractExchange rates in format to be consumed by UI
     * If not supported fetches contractExchange rates and maps from from token/fallback-currency to token/nativeCurrency
     *
     * @param nativeCurrency - the native currency of the currently active network
     * @param slug - the unique slug used to id the chain by the coingecko api
     * should be used to query token exchange rates
     * @returns An object with conversion rates for each token
     * related to the network's native currency
     */
    fetchAndMapExchangeRates(nativeCurrency, slug) {
        return __awaiter(this, void 0, void 0, function* () {
            const contractExchangeRates = {};
            // check if native currency is supported as a vs_currency by the API
            const nativeCurrencySupported = yield this.checkIsSupportedVsCurrency(nativeCurrency);
            if (nativeCurrencySupported) {
                // If it is we can do a simple fetch against the CoinGecko API
                const prices = yield this.fetchExchangeRate(slug, nativeCurrency);
                this.tokenList.forEach((token) => {
                    const price = prices[token.address.toLowerCase()];
                    contractExchangeRates[util_1.toChecksumHexAddress(token.address)] = price
                        ? price[nativeCurrency.toLowerCase()]
                        : 0;
                });
            }
            else {
                // if native currency is not supported we need to use a fallback vsCurrency, get the exchange rates
                // in token/fallback-currency format and convert them to expected token/nativeCurrency format.
                let tokenExchangeRates;
                let vsCurrencyToNativeCurrencyConversionRate = 0;
                try {
                    [
                        tokenExchangeRates,
                        { conversionRate: vsCurrencyToNativeCurrencyConversionRate },
                    ] = yield Promise.all([
                        this.fetchExchangeRate(slug, constants_1.FALL_BACK_VS_CURRENCY),
                        crypto_compare_1.fetchExchangeRate(nativeCurrency, constants_1.FALL_BACK_VS_CURRENCY, false),
                    ]);
                }
                catch (error) {
                    if (error.message.includes('market does not exist for this coin pair')) {
                        return {};
                    }
                    throw error;
                }
                for (const [tokenAddress, conversion] of Object.entries(tokenExchangeRates)) {
                    const tokenToVsCurrencyConversionRate = conversion[constants_1.FALL_BACK_VS_CURRENCY.toLowerCase()];
                    contractExchangeRates[util_1.toChecksumHexAddress(tokenAddress)] =
                        tokenToVsCurrencyConversionRate *
                            vsCurrencyToNativeCurrencyConversionRate;
                }
            }
            return contractExchangeRates;
        });
    }
}
exports.TokenRatesController = TokenRatesController;
exports.default = TokenRatesController;
//# sourceMappingURL=TokenRatesController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/TokenRatesController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseControllerV2.js", {"immer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/immer/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseControllerV2.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPersistentState = exports.getAnonymizedState = exports.BaseController = void 0;
const immer_1 = require("immer");
immer_1.enablePatches();
/**
 * Controller class that provides state management, subscriptions, and state metadata
 */
class BaseController {
    /**
     * Creates a BaseController instance.
     *
     * @param options
     * @param options.messenger - Controller messaging system
     * @param options.metadata - State metadata, describing how to "anonymize" the state, and which
     *   parts should be persisted.
     * @param options.name - The name of the controller, used as a namespace for events and actions
     * @param options.state - Initial controller state
     */
    constructor({ messenger, metadata, name, state, }) {
        this.messagingSystem = messenger;
        this.name = name;
        this.internalState = state;
        this.metadata = metadata;
        this.messagingSystem.registerActionHandler(`${name}:getState`, () => this.state);
    }
    /**
     * Retrieves current controller state
     *
     * @returns - Current state
     */
    get state() {
        return this.internalState;
    }
    set state(_) {
        throw new Error(`Controller state cannot be directly mutated; use 'update' method instead.`);
    }
    /**
     * Updates controller state. Accepts a callback that is passed a draft copy
     * of the controller state. If a value is returned, it is set as the new
     * state. Otherwise, any changes made within that callback to the draft are
     * applied to the controller state.
     *
     * @param callback - Callback for updating state, passed a draft state
     *   object. Return a new state object or mutate the draft to update state.
     */
    update(callback) {
        // We run into ts2589, "infinite type depth", if we don't cast
        // produceWithPatches here.
        // The final, omitted member of the returned tuple are the inverse patches.
        const [nextState, patches] = immer_1.produceWithPatches(this.internalState, callback);
        this.internalState = nextState;
        this.messagingSystem.publish(`${this.name}:stateChange`, nextState, patches);
    }
    /**
     * Prepares the controller for garbage collection. This should be extended
     * by any subclasses to clean up any additional connections or events.
     *
     * The only cleanup performed here is to remove listeners. While technically
     * this is not required to ensure this instance is garbage collected, it at
     * least ensures this instance won't be responsible for preventing the
     * listeners from being garbage collected.
     */
    destroy() {
        this.messagingSystem.clearEventSubscriptions(`${this.name}:stateChange`);
    }
}
exports.BaseController = BaseController;
/**
 * Returns an anonymized representation of the controller state.
 *
 * By "anonymized" we mean that it should not contain any information that could be personally
 * identifiable.
 *
 * @param state - The controller state
 * @param metadata - The controller state metadata, which describes how to derive the
 *   anonymized state
 * @returns The anonymized controller state
 */
function getAnonymizedState(state, metadata) {
    return deriveStateFromMetadata(state, metadata, 'anonymous');
}
exports.getAnonymizedState = getAnonymizedState;
/**
 * Returns the subset of state that should be persisted
 *
 * @param state - The controller state
 * @param metadata - The controller state metadata, which describes which pieces of state should be persisted
 * @returns The subset of controller state that should be persisted
 */
function getPersistentState(state, metadata) {
    return deriveStateFromMetadata(state, metadata, 'persist');
}
exports.getPersistentState = getPersistentState;
function deriveStateFromMetadata(state, metadata, metadataProperty) {
    return Object.keys(state).reduce((persistedState, key) => {
        const propertyMetadata = metadata[key][metadataProperty];
        const stateProperty = state[key];
        if (typeof propertyMetadata === 'function') {
            persistedState[key] = propertyMetadata(stateProperty);
        }
        else if (propertyMetadata) {
            persistedState[key] = stateProperty;
        }
        return persistedState;
    }, {});
}
//# sourceMappingURL=BaseControllerV2.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseControllerV2.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/AssetsContractController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseController.js","human-standard-collectible-abi":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/human-standard-collectible-abi/index.js","human-standard-token-abi":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/human-standard-token-abi/index.js","single-call-balance-checker-abi":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/single-call-balance-checker-abi/index.js","web3":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/web3/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/AssetsContractController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssetsContractController = void 0;
const web3_1 = __importDefault(require("web3"));
const human_standard_token_abi_1 = __importDefault(require("human-standard-token-abi"));
const human_standard_collectible_abi_1 = __importDefault(require("human-standard-collectible-abi"));
const single_call_balance_checker_abi_1 = __importDefault(require("single-call-balance-checker-abi"));
const BaseController_1 = require("../BaseController");
const ERC721METADATA_INTERFACE_ID = '0x5b5e139f';
const ERC721ENUMERABLE_INTERFACE_ID = '0x780e9d63';
const SINGLE_CALL_BALANCES_ADDRESS = '0xb1f8e55c7f64d203c1400b9d8555d050f94adf39';
/**
 * Controller that interacts with contracts on mainnet through web3
 */
class AssetsContractController extends BaseController_1.BaseController {
    /**
     * Creates a AssetsContractController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'AssetsContractController';
        this.defaultConfig = {
            provider: undefined,
        };
        this.initialize();
    }
    /**
     *
     * Query if a contract implements an interface
     *
     * @param address - Asset contract address
     * @param interfaceId - Interface identifier
     * @returns - Promise resolving to whether the contract implements `interfaceID`
     */
    contractSupportsInterface(address, interfaceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(human_standard_collectible_abi_1.default).at(address);
            return new Promise((resolve, reject) => {
                contract.supportsInterface(interfaceId, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Sets a new provider
     *
     * TODO: Replace this wth a method
     *
     * @property provider - Provider used to create a new underlying Web3 instance
     */
    set provider(provider) {
        this.web3 = new web3_1.default(provider);
    }
    get provider() {
        throw new Error('Property only used for setting');
    }
    /**
     * Query if contract implements ERC721Metadata interface
     *
     * @param address - ERC721 asset contract address
     * @returns - Promise resolving to whether the contract implements ERC721Metadata interface
     */
    contractSupportsMetadataInterface(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.contractSupportsInterface(address, ERC721METADATA_INTERFACE_ID);
        });
    }
    /**
     * Query if contract implements ERC721Enumerable interface
     *
     * @param address - ERC721 asset contract address
     * @returns - Promise resolving to whether the contract implements ERC721Enumerable interface
     */
    contractSupportsEnumerableInterface(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.contractSupportsInterface(address, ERC721ENUMERABLE_INTERFACE_ID);
        });
    }
    /**
     * Get balance or count for current account on specific asset contract
     *
     * @param address - Asset contract address
     * @param selectedAddress - Current account public address
     * @returns - Promise resolving to BN object containing balance for current account on specific asset contract
     */
    getBalanceOf(address, selectedAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(human_standard_token_abi_1.default).at(address);
            return new Promise((resolve, reject) => {
                contract.balanceOf(selectedAddress, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Enumerate assets assigned to an owner
     *
     * @param address - ERC721 asset contract address
     * @param selectedAddress - Current account public address
     * @param index - A collectible counter less than `balanceOf(selectedAddress)`
     * @returns - Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'
     */
    getCollectibleTokenId(address, selectedAddress, index) {
        const contract = this.web3.eth.contract(human_standard_collectible_abi_1.default).at(address);
        return new Promise((resolve, reject) => {
            contract.tokenOfOwnerByIndex(selectedAddress, index, (error, result) => {
                /* istanbul ignore if */
                if (error) {
                    reject(error);
                    return;
                }
                resolve(result.toNumber());
            });
        });
    }
    /**
     * Query for tokenURI for a given asset
     *
     * @param address - ERC721 asset contract address
     * @param tokenId - ERC721 asset identifier
     * @returns - Promise resolving to the 'tokenURI'
     */
    getCollectibleTokenURI(address, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const supportsMetadata = yield this.contractSupportsMetadataInterface(address);
            if (!supportsMetadata) {
                return '';
            }
            const contract = this.web3.eth.contract(human_standard_collectible_abi_1.default).at(address);
            return new Promise((resolve, reject) => {
                contract.tokenURI(tokenId, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Query for name for a given ERC20 asset
     *
     * @param address - ERC20 asset contract address
     * @returns - Promise resolving to the 'decimals'
     */
    getTokenDecimals(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(human_standard_token_abi_1.default).at(address);
            return new Promise((resolve, reject) => {
                contract.decimals((error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Query for name for a given asset
     *
     * @param address - ERC721 or ERC20 asset contract address
     * @returns - Promise resolving to the 'name'
     */
    getAssetName(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(human_standard_collectible_abi_1.default).at(address);
            return new Promise((resolve, reject) => {
                contract.name((error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Query for symbol for a given asset
     *
     * @param address - ERC721 or ERC20 asset contract address
     * @returns - Promise resolving to the 'symbol'
     */
    getAssetSymbol(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(human_standard_collectible_abi_1.default).at(address);
            return new Promise((resolve, reject) => {
                contract.symbol((error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Query for owner for a given ERC721 asset
     *
     * @param address - ERC721 asset contract address
     * @param tokenId - ERC721 asset identifier
     * @returns - Promise resolving to the owner address
     */
    getOwnerOf(address, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(human_standard_collectible_abi_1.default).at(address);
            return new Promise((resolve, reject) => {
                contract.ownerOf(tokenId, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Returns contract instance of
     *
     * @returns - Promise resolving to the 'tokenURI'
     */
    getBalancesInSingleCall(selectedAddress, tokensToDetect) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth
                .contract(single_call_balance_checker_abi_1.default)
                .at(SINGLE_CALL_BALANCES_ADDRESS);
            return new Promise((resolve, reject) => {
                contract.balances([selectedAddress], tokensToDetect, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    const nonZeroBalances = {};
                    /* istanbul ignore else */
                    if (result.length > 0) {
                        tokensToDetect.forEach((tokenAddress, index) => {
                            const balance = result[index];
                            /* istanbul ignore else */
                            if (!balance.isZero()) {
                                nonZeroBalances[tokenAddress] = balance;
                            }
                        });
                    }
                    resolve(nonZeroBalances);
                });
            });
        });
    }
}
exports.AssetsContractController = AssetsContractController;
exports.default = AssetsContractController;
//# sourceMappingURL=AssetsContractController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/AssetsContractController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/AccountTrackerController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseController.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js","async-mutex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-mutex/lib/index.js","eth-query":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-query/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/AccountTrackerController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountTrackerController = void 0;
const eth_query_1 = __importDefault(require("eth-query"));
const async_mutex_1 = require("async-mutex");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
/**
 * Controller that tracks information for all accounts in the current keychain
 */
class AccountTrackerController extends BaseController_1.BaseController {
    /**
     * Creates an AccountTracker instance
     *
     * @param options
     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes
     * @param options.getIdentities - Gets the identities from the Preferences store
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor({ onPreferencesStateChange, getIdentities, }, config, state) {
        super(config, state);
        this.mutex = new async_mutex_1.Mutex();
        /**
         * Name of this controller used during composition
         */
        this.name = 'AccountTrackerController';
        /**
         * Refreshes all accounts in the current keychain
         */
        this.refresh = () => __awaiter(this, void 0, void 0, function* () {
            this.syncAccounts();
            const { accounts } = this.state;
            for (const address in accounts) {
                yield util_1.safelyExecuteWithTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    const balance = yield util_1.query(this.ethQuery, 'getBalance', [address]);
                    accounts[address] = { balance: util_1.BNToHex(balance) };
                    this.update({ accounts: Object.assign({}, accounts) });
                }));
            }
        });
        this.defaultConfig = {
            interval: 10000,
        };
        this.defaultState = { accounts: {} };
        this.initialize();
        this.getIdentities = getIdentities;
        onPreferencesStateChange(() => {
            this.refresh();
        });
        this.poll();
    }
    syncAccounts() {
        const { accounts } = this.state;
        const addresses = Object.keys(this.getIdentities());
        const existing = Object.keys(accounts);
        const newAddresses = addresses.filter((address) => existing.indexOf(address) === -1);
        const oldAddresses = existing.filter((address) => addresses.indexOf(address) === -1);
        newAddresses.forEach((address) => {
            accounts[address] = { balance: '0x0' };
        });
        oldAddresses.forEach((address) => {
            delete accounts[address];
        });
        this.update({ accounts: Object.assign({}, accounts) });
    }
    /**
     * Sets a new provider
     *
     * TODO: Replace this wth a method
     *
     * @param provider - Provider used to create a new underlying EthQuery instance
     */
    set provider(provider) {
        this.ethQuery = new eth_query_1.default(provider);
    }
    get provider() {
        throw new Error('Property only used for setting');
    }
    /**
     * Starts a new polling interval
     *
     * @param interval - Polling interval trigger a 'refresh'
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield this.refresh();
            this.handle = setTimeout(() => {
                releaseLock();
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
}
exports.AccountTrackerController = AccountTrackerController;
exports.default = AccountTrackerController;
//# sourceMappingURL=AccountTrackerController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/AccountTrackerController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/approval/ApprovalController.js", {"../BaseControllerV2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseControllerV2.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","nanoid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/nanoid/index.browser.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/approval/ApprovalController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApprovalController = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const nanoid_1 = require("nanoid");
const BaseControllerV2_1 = require("../BaseControllerV2");
const controllerName = 'ApprovalController';
const stateMetadata = {
    pendingApprovals: { persist: false, anonymous: true },
    pendingApprovalCount: { persist: false, anonymous: false },
};
const getAlreadyPendingMessage = (origin, type) => `Request of type '${type}' already pending for origin ${origin}. Please wait.`;
const getDefaultState = () => {
    return {
        pendingApprovals: {},
        pendingApprovalCount: 0,
    };
};
/**
 * Controller for managing requests that require user approval.
 *
 * Enables limiting the number of pending requests by origin and type, counting
 * pending requests, and more.
 *
 * Adding a request returns a promise that resolves or rejects when the request
 * is approved or denied, respectively.
 */
class ApprovalController extends BaseControllerV2_1.BaseController {
    /**
     * @param opts - Options bag
     * @param opts.showApprovalRequest - Function for opening the UI such that
     * the request can be displayed to the user.
     */
    constructor({ messenger, showApprovalRequest, state = {}, }) {
        super({
            name: controllerName,
            metadata: stateMetadata,
            messenger,
            state: Object.assign(Object.assign({}, getDefaultState()), state),
        });
        this._approvals = new Map();
        this._origins = new Map();
        this._showApprovalRequest = showApprovalRequest;
        this.registerMessageHandlers();
    }
    /**
     * Constructor helper for registering this controller's messaging system
     * actions.
     */
    registerMessageHandlers() {
        this.messagingSystem.registerActionHandler(`${controllerName}:clearRequests`, this.clear.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:addRequest`, (opts, shouldShowRequest) => {
            if (shouldShowRequest) {
                return this.addAndShowApprovalRequest(opts);
            }
            return this.add(opts);
        });
        this.messagingSystem.registerActionHandler(`${controllerName}:hasRequest`, this.has.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:acceptRequest`, this.accept.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:rejectRequest`, this.reject.bind(this));
    }
    /**
     * Adds an approval request per the given arguments, calls the show approval
     * request function, and returns the associated approval promise.
     *
     * There can only be one approval per origin and type. An error is thrown if
     * attempting to add an invalid or duplicate request.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval request. A random id will be
     * generated if none is provided.
     * @param opts.origin - The origin of the approval request.
     * @param opts.type - The type associated with the approval request.
     * @param opts.requestData - Additional data associated with the request,
     * if any.
     * @returns The approval promise.
     */
    addAndShowApprovalRequest(opts) {
        const promise = this._add(opts.origin, opts.type, opts.id, opts.requestData);
        this._showApprovalRequest();
        return promise;
    }
    /**
     * Adds an approval request per the given arguments and returns the approval
     * promise.
     *
     * There can only be one approval per origin and type. An error is thrown if
     * attempting to add an invalid or duplicate request.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval request. A random id will be
     * generated if none is provided.
     * @param opts.origin - The origin of the approval request.
     * @param opts.type - The type associated with the approval request.
     * @param opts.requestData - Additional data associated with the request,
     * if any.
     * @returns The approval promise.
     */
    add(opts) {
        return this._add(opts.origin, opts.type, opts.id, opts.requestData);
    }
    /**
     * Gets the info for the approval request with the given id.
     *
     * @param id - The id of the approval request.
     * @returns The approval request data associated with the id.
     */
    get(id) {
        return this.state.pendingApprovals[id];
    }
    /**
     * Gets the number of pending approvals, by origin and/or type.
     *
     * If only `origin` is specified, all approvals for that origin will be
     * counted, regardless of type.
     * If only `type` is specified, all approvals for that type will be counted,
     * regardless of origin.
     * If both `origin` and `type` are specified, 0 or 1 will be returned.
     *
     * @param opts.origin - An approval origin.
     * @param opts.type - The type of the approval request.
     * @returns The current approval request count for the given origin and/or
     * type.
     */
    getApprovalCount(opts = {}) {
        var _a, _b;
        if (!opts.origin && !opts.type) {
            throw new Error('Must specify origin, type, or both.');
        }
        const { origin, type: _type } = opts;
        if (origin && _type) {
            return Number(Boolean((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.has(_type)));
        }
        if (origin) {
            return ((_b = this._origins.get(origin)) === null || _b === void 0 ? void 0 : _b.size) || 0;
        }
        // Only "type" was specified
        let count = 0;
        for (const approval of Object.values(this.state.pendingApprovals)) {
            if (approval.type === _type) {
                count += 1;
            }
        }
        return count;
    }
    /**
     * @returns The current total approval request count, for all types and
     * origins.
     */
    getTotalApprovalCount() {
        return this.state.pendingApprovalCount;
    }
    /* eslint-enable @typescript-eslint/unified-signatures */
    /**
     * Checks if there's a pending approval request per the given parameters.
     * At least one parameter must be specified. An error will be thrown if the
     * parameters are invalid.
     *
     * If `id` is specified, all other parameters will be ignored.
     * If `id` is not specified, the method will check for requests that match
     * all of the specified parameters.
     *
     * @param opts - Options bag.
     * @param opts.id - The ID to check for.
     * @param opts.origin - The origin to check for.
     * @param opts.type - The type to check for.
     * @returns `true` if a matching approval is found, and `false` otherwise.
     */
    has(opts = {}) {
        var _a;
        const { id, origin, type: _type } = opts;
        if (id) {
            if (typeof id !== 'string') {
                throw new Error('May not specify non-string id.');
            }
            return this._approvals.has(id);
        }
        if (_type && typeof _type !== 'string') {
            throw new Error('May not specify non-string type.');
        }
        if (origin) {
            if (typeof origin !== 'string') {
                throw new Error('May not specify non-string origin.');
            }
            // Check origin and type pair if type also specified
            if (_type) {
                return Boolean((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.has(_type));
            }
            return this._origins.has(origin);
        }
        if (_type) {
            for (const approval of Object.values(this.state.pendingApprovals)) {
                if (approval.type === _type) {
                    return true;
                }
            }
            return false;
        }
        throw new Error('Must specify a valid combination of id, origin, and type.');
    }
    /**
     * Resolves the promise of the approval with the given id, and deletes the
     * approval. Throws an error if no such approval exists.
     *
     * @param id - The id of the approval request.
     * @param value - The value to resolve the approval promise with.
     */
    accept(id, value) {
        this._deleteApprovalAndGetCallbacks(id).resolve(value);
    }
    /**
     * Rejects the promise of the approval with the given id, and deletes the
     * approval. Throws an error if no such approval exists.
     *
     * @param id - The id of the approval request.
     * @param error - The error to reject the approval promise with.
     */
    reject(id, error) {
        this._deleteApprovalAndGetCallbacks(id).reject(error);
    }
    /**
     * Rejects and deletes all approval requests.
     */
    clear() {
        const rejectionError = eth_rpc_errors_1.ethErrors.rpc.resourceUnavailable('The request was rejected; please try again.');
        for (const id of this._approvals.keys()) {
            this.reject(id, rejectionError);
        }
        this._origins.clear();
        this.update(() => getDefaultState());
    }
    /**
     * Implementation of add operation.
     *
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param id - The id of the approval request.
     * @param requestData - The request data associated with the approval request.
     * @returns The approval promise.
     */
    _add(origin, type, id = nanoid_1.nanoid(), requestData) {
        var _a;
        this._validateAddParams(id, origin, type, requestData);
        if ((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.has(type)) {
            throw eth_rpc_errors_1.ethErrors.rpc.resourceUnavailable(getAlreadyPendingMessage(origin, type));
        }
        // add pending approval
        return new Promise((resolve, reject) => {
            this._approvals.set(id, { resolve, reject });
            this._addPendingApprovalOrigin(origin, type);
            this._addToStore(id, origin, type, requestData);
        });
    }
    /**
     * Validates parameters to the add method.
     *
     * @param id - The id of the approval request.
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param requestData - The request data associated with the approval request.
     */
    _validateAddParams(id, origin, type, requestData) {
        let errorMessage = null;
        if (!id || typeof id !== 'string') {
            errorMessage = 'Must specify non-empty string id.';
        }
        else if (this._approvals.has(id)) {
            errorMessage = `Approval request with id '${id}' already exists.`;
        }
        else if (!origin || typeof origin !== 'string') {
            errorMessage = 'Must specify non-empty string origin.';
        }
        else if (!type || typeof type !== 'string') {
            errorMessage = 'Must specify non-empty string type.';
        }
        else if (requestData &&
            (typeof requestData !== 'object' || Array.isArray(requestData))) {
            errorMessage = 'Request data must be a plain object if specified.';
        }
        if (errorMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.internal(errorMessage);
        }
    }
    /**
     * Adds an entry to _origins.
     * Performs no validation.
     *
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     */
    _addPendingApprovalOrigin(origin, type) {
        const originSet = this._origins.get(origin) || new Set();
        originSet.add(type);
        if (!this._origins.has(origin)) {
            this._origins.set(origin, originSet);
        }
    }
    /**
     * Adds an entry to the store.
     * Performs no validation.
     *
     * @param id - The id of the approval request.
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param requestData - The request data associated with the approval request.
     */
    _addToStore(id, origin, type, requestData) {
        const approval = {
            id,
            origin,
            type,
            time: Date.now(),
            requestData: requestData || null,
        };
        this.update((draftState) => {
            // Typecast: ts(2589)
            draftState.pendingApprovals[id] = approval;
            draftState.pendingApprovalCount = Object.keys(draftState.pendingApprovals).length;
        });
    }
    /**
     * Deletes the approval with the given id. The approval promise must be
     * resolved or reject before this method is called.
     * Deletion is an internal operation because approval state is solely
     * managed by this controller.
     *
     * @param id - The id of the approval request to be deleted.
     */
    _delete(id) {
        this._approvals.delete(id);
        // This method is only called after verifying that the approval with the
        // specified id exists.
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const { origin, type } = this.state.pendingApprovals[id];
        this._origins.get(origin).delete(type);
        if (this._isEmptyOrigin(origin)) {
            this._origins.delete(origin);
        }
        this.update((draftState) => {
            delete draftState.pendingApprovals[id];
            draftState.pendingApprovalCount = Object.keys(draftState.pendingApprovals).length;
        });
    }
    /**
     * Gets the approval callbacks for the given id, deletes the entry, and then
     * returns the callbacks for promise resolution.
     * Throws an error if no approval is found for the given id.
     *
     * @param id - The id of the approval request.
     * @returns The promise callbacks associated with the approval request.
     */
    _deleteApprovalAndGetCallbacks(id) {
        const callbacks = this._approvals.get(id);
        if (!callbacks) {
            throw new Error(`Approval request with id '${id}' not found.`);
        }
        this._delete(id);
        return callbacks;
    }
    /**
     * Checks whether there are any approvals associated with the given
     * origin.
     *
     * @param origin - The origin to check.
     * @returns True if the origin has no approvals, false otherwise.
     */
    _isEmptyOrigin(origin) {
        var _a;
        return !((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.size);
    }
}
exports.ApprovalController = ApprovalController;
exports.default = ApprovalController;
//# sourceMappingURL=ApprovalController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/approval/ApprovalController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/CurrencyRateController.js", {"../BaseControllerV2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseControllerV2.js","../apis/crypto-compare":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/apis/crypto-compare.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js","async-mutex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-mutex/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/CurrencyRateController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CurrencyRateController = void 0;
const async_mutex_1 = require("async-mutex");
const BaseControllerV2_1 = require("../BaseControllerV2");
const util_1 = require("../util");
const crypto_compare_1 = require("../apis/crypto-compare");
const name = 'CurrencyRateController';
const metadata = {
    conversionDate: { persist: true, anonymous: true },
    conversionRate: { persist: true, anonymous: true },
    currentCurrency: { persist: true, anonymous: true },
    nativeCurrency: { persist: true, anonymous: true },
    pendingCurrentCurrency: { persist: false, anonymous: true },
    pendingNativeCurrency: { persist: false, anonymous: true },
    usdConversionRate: { persist: true, anonymous: true },
};
const defaultState = {
    conversionDate: 0,
    conversionRate: 0,
    currentCurrency: 'usd',
    nativeCurrency: 'ETH',
    pendingCurrentCurrency: null,
    pendingNativeCurrency: null,
    usdConversionRate: null,
};
/**
 * Controller that passively polls on a set interval for an exchange rate from the current base
 * asset to the current currency
 */
class CurrencyRateController extends BaseControllerV2_1.BaseController {
    /**
     * Creates a CurrencyRateController instance
     *
     * @param options - Constructor options
     * @param options.includeUsdRate - Keep track of the USD rate in addition to the current currency rate
     * @param options.interval - The polling interval, in milliseconds
     * @param options.messenger - A reference to the messaging system
     * @param options.state - Initial state to set on this controller
     * @param options.fetchExchangeRate - Fetches the exchange rate from an external API. This option is primarily meant for use in unit tests.
     */
    constructor({ includeUsdRate = false, interval = 180000, messenger, state, fetchExchangeRate = crypto_compare_1.fetchExchangeRate, }) {
        super({
            name,
            metadata,
            messenger,
            state: Object.assign(Object.assign({}, defaultState), state),
        });
        this.mutex = new async_mutex_1.Mutex();
        this.includeUsdRate = includeUsdRate;
        this.intervalDelay = interval;
        this.fetchExchangeRate = fetchExchangeRate;
    }
    /**
     * Start polling for the currency rate
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.startPolling();
        });
    }
    /**
     * Stop polling for the currency rate
     */
    stop() {
        this.stopPolling();
    }
    /**
     * Prepare to discard this controller.
     *
     * This stops any active polling.
     */
    destroy() {
        super.destroy();
        this.stopPolling();
    }
    /**
     * Sets a currency to track
     *
     * @param currentCurrency - ISO 4217 currency code
     */
    setCurrentCurrency(currentCurrency) {
        return __awaiter(this, void 0, void 0, function* () {
            this.update((state) => {
                state.pendingCurrentCurrency = currentCurrency;
            });
            yield this.updateExchangeRate();
        });
    }
    /**
     * Sets a new native currency
     *
     * @param symbol - Symbol for the base asset
     */
    setNativeCurrency(symbol) {
        return __awaiter(this, void 0, void 0, function* () {
            this.update((state) => {
                state.pendingNativeCurrency = symbol;
            });
            yield this.updateExchangeRate();
        });
    }
    stopPolling() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
    }
    /**
     * Starts a new polling interval
     */
    startPolling() {
        return __awaiter(this, void 0, void 0, function* () {
            this.stopPolling();
            // TODO: Expose polling currency rate update errors
            yield util_1.safelyExecute(() => this.updateExchangeRate());
            this.intervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                yield util_1.safelyExecute(() => this.updateExchangeRate());
            }), this.intervalDelay);
        });
    }
    /**
     * Updates exchange rate for the current currency
     */
    updateExchangeRate() {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            const { currentCurrency: stateCurrentCurrency, nativeCurrency: stateNativeCurrency, pendingCurrentCurrency, pendingNativeCurrency, } = this.state;
            const conversionDate = Date.now() / 1000;
            let conversionRate = null;
            let usdConversionRate = null;
            const currentCurrency = pendingCurrentCurrency !== null && pendingCurrentCurrency !== void 0 ? pendingCurrentCurrency : stateCurrentCurrency;
            const nativeCurrency = pendingNativeCurrency !== null && pendingNativeCurrency !== void 0 ? pendingNativeCurrency : stateNativeCurrency;
            try {
                if (currentCurrency &&
                    nativeCurrency &&
                    // if either currency is an empty string we can skip the comparison
                    // because it will result in an error from the api and ultimately
                    // a null conversionRate either way.
                    currentCurrency !== '' &&
                    nativeCurrency !== '') {
                    ({ conversionRate, usdConversionRate } = yield this.fetchExchangeRate(currentCurrency, nativeCurrency, this.includeUsdRate));
                }
            }
            catch (error) {
                if (!error.message.includes('market does not exist for this coin pair')) {
                    throw error;
                }
            }
            finally {
                try {
                    this.update(() => {
                        return {
                            conversionDate,
                            conversionRate,
                            // we currently allow and handle an empty string as a valid nativeCurrency
                            // in cases where a user has not entered a native ticker symbol for a custom network
                            // currentCurrency is not from user input but this protects us from unexpected changes.
                            nativeCurrency,
                            currentCurrency,
                            pendingCurrentCurrency: null,
                            pendingNativeCurrency: null,
                            usdConversionRate,
                        };
                    });
                }
                finally {
                    releaseLock();
                }
            }
            return this.state;
        });
    }
}
exports.CurrencyRateController = CurrencyRateController;
exports.default = CurrencyRateController;
//# sourceMappingURL=CurrencyRateController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/CurrencyRateController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/message-manager/MessageManager.js", {"../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js","./AbstractMessageManager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/message-manager/AbstractMessageManager.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/message-manager/MessageManager.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageManager = void 0;
const uuid_1 = require("uuid");
const util_1 = require("../util");
const AbstractMessageManager_1 = require("./AbstractMessageManager");
/**
 * Controller in charge of managing - storing, adding, removing, updating - Messages.
 */
class MessageManager extends AbstractMessageManager_1.AbstractMessageManager {
    constructor() {
        super(...arguments);
        /**
         * Name of this controller used during composition
         */
        this.name = 'MessageManager';
    }
    /**
     * Creates a new Message with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.
     *
     * @param messageParams - The params for the eth_sign call to be made after the message is approved
     * @param req? - The original request object possibly containing the origin
     * @returns - Promise resolving to the raw data of the signature request
     */
    addUnapprovedMessageAsync(messageParams, req) {
        return new Promise((resolve, reject) => {
            util_1.validateSignMessageData(messageParams);
            const messageId = this.addUnapprovedMessage(messageParams, req);
            this.hub.once(`${messageId}:finished`, (data) => {
                switch (data.status) {
                    case 'signed':
                        return resolve(data.rawSig);
                    case 'rejected':
                        return reject(new Error('MetaMask Message Signature: User denied message signature.'));
                    default:
                        return reject(new Error(`MetaMask Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
                }
            });
        });
    }
    /**
     * Creates a new Message with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new Message to this.messages, and to save the
     * unapproved Messages.
     *
     * @param messageParams - The params for the eth_sign call to be made after the message
     * is approved
     * @param req? - The original request object possibly containing the origin
     * @returns - The id of the newly created message
     */
    addUnapprovedMessage(messageParams, req) {
        if (req) {
            messageParams.origin = req.origin;
        }
        messageParams.data = util_1.normalizeMessageData(messageParams.data);
        const messageId = uuid_1.v1();
        const messageData = {
            id: messageId,
            messageParams,
            status: 'unapproved',
            time: Date.now(),
            type: 'eth_sign',
        };
        this.addMessage(messageData);
        this.hub.emit(`unapprovedMessage`, Object.assign(Object.assign({}, messageParams), { metamaskId: messageId }));
        return messageId;
    }
    /**
     * Removes the metamaskId property from passed messageParams and returns a promise which
     * resolves the updated messageParams
     *
     * @param messageParams - The messageParams to modify
     * @returns - Promise resolving to the messageParams with the metamaskId property removed
     */
    prepMessageForSigning(messageParams) {
        delete messageParams.metamaskId;
        return Promise.resolve(messageParams);
    }
}
exports.MessageManager = MessageManager;
exports.default = MessageManager;
//# sourceMappingURL=MessageManager.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/message-manager/MessageManager.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/TokenBalancesController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseController.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/TokenBalancesController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenBalancesController = exports.BN = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
Object.defineProperty(exports, "BN", { enumerable: true, get: function () { return ethereumjs_util_1.BN; } });
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
/**
 * Controller that passively polls on a set interval token balances
 * for tokens stored in the TokensController
 */
class TokenBalancesController extends BaseController_1.BaseController {
    /**
     * Creates a TokenBalancesController instance
     *
     * @param options
     * @param options.onTokensStateChange - Allows subscribing to assets controller state changes
     * @param options.getSelectedAddress - Gets the current selected address
     * @param options.getBalanceOf - Gets the balance of the given account at the given contract address
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor({ onTokensStateChange, getSelectedAddress, getBalanceOf, }, config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'TokenBalancesController';
        this.defaultConfig = {
            interval: 180000,
            tokens: [],
        };
        this.defaultState = { contractBalances: {} };
        this.initialize();
        onTokensStateChange(({ tokens }) => {
            this.configure({ tokens });
            this.updateBalances();
        });
        this.getSelectedAddress = getSelectedAddress;
        this.getBalanceOf = getBalanceOf;
        this.poll();
    }
    /**
     * Starts a new polling interval
     *
     * @param interval - Polling interval used to fetch new token balances
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield util_1.safelyExecute(() => this.updateBalances());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Updates balances for all tokens
     *
     * @returns Promise resolving when this operation completes
     */
    updateBalances() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.disabled) {
                return;
            }
            const { tokens } = this.config;
            const newContractBalances = {};
            for (const i in tokens) {
                const { address } = tokens[i];
                try {
                    newContractBalances[address] = yield this.getBalanceOf(address, this.getSelectedAddress());
                    tokens[i].balanceError = null;
                }
                catch (error) {
                    newContractBalances[address] = new ethereumjs_util_1.BN(0);
                    tokens[i].balanceError = error;
                }
            }
            this.update({ contractBalances: newContractBalances });
        });
    }
}
exports.TokenBalancesController = TokenBalancesController;
exports.default = TokenBalancesController;
//# sourceMappingURL=TokenBalancesController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/TokenBalancesController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/message-manager/PersonalMessageManager.js", {"../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js","./AbstractMessageManager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/message-manager/AbstractMessageManager.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/message-manager/PersonalMessageManager.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PersonalMessageManager = void 0;
const uuid_1 = require("uuid");
const util_1 = require("../util");
const AbstractMessageManager_1 = require("./AbstractMessageManager");
/**
 * Controller in charge of managing - storing, adding, removing, updating - Messages.
 */
class PersonalMessageManager extends AbstractMessageManager_1.AbstractMessageManager {
    constructor() {
        super(...arguments);
        /**
         * Name of this controller used during composition
         */
        this.name = 'PersonalMessageManager';
    }
    /**
     * Creates a new Message with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.
     *
     * @param messageParams - The params for the personal_sign call to be made after the message is approved
     * @param req? - The original request object possibly containing the origin
     * @returns - Promise resolving to the raw data of the signature request
     */
    addUnapprovedMessageAsync(messageParams, req) {
        return new Promise((resolve, reject) => {
            util_1.validateSignMessageData(messageParams);
            const messageId = this.addUnapprovedMessage(messageParams, req);
            this.hub.once(`${messageId}:finished`, (data) => {
                switch (data.status) {
                    case 'signed':
                        return resolve(data.rawSig);
                    case 'rejected':
                        return reject(new Error('MetaMask Personal Message Signature: User denied message signature.'));
                    default:
                        return reject(new Error(`MetaMask Personal Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
                }
            });
        });
    }
    /**
     * Creates a new Message with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new Message to this.messages, and to save the
     * unapproved Messages.
     *
     * @param messageParams - The params for the personal_sign call to be made after the message
     * is approved
     * @param req? - The original request object possibly containing the origin
     * @returns - The id of the newly created message
     */
    addUnapprovedMessage(messageParams, req) {
        if (req) {
            messageParams.origin = req.origin;
        }
        messageParams.data = util_1.normalizeMessageData(messageParams.data);
        const messageId = uuid_1.v1();
        const messageData = {
            id: messageId,
            messageParams,
            status: 'unapproved',
            time: Date.now(),
            type: 'personal_sign',
        };
        this.addMessage(messageData);
        this.hub.emit(`unapprovedMessage`, Object.assign(Object.assign({}, messageParams), { metamaskId: messageId }));
        return messageId;
    }
    /**
     * Removes the metamaskId property from passed messageParams and returns a promise which
     * resolves the updated messageParams
     *
     * @param messageParams - The messageParams to modify
     * @returns - Promise resolving to the messageParams with the metamaskId property removed
     */
    prepMessageForSigning(messageParams) {
        delete messageParams.metamaskId;
        return Promise.resolve(messageParams);
    }
}
exports.PersonalMessageManager = PersonalMessageManager;
exports.default = PersonalMessageManager;
//# sourceMappingURL=PersonalMessageManager.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/message-manager/PersonalMessageManager.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/message-manager/TypedMessageManager.js", {"../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js","./AbstractMessageManager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/message-manager/AbstractMessageManager.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/message-manager/TypedMessageManager.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypedMessageManager = void 0;
const uuid_1 = require("uuid");
const util_1 = require("../util");
const AbstractMessageManager_1 = require("./AbstractMessageManager");
/**
 * Controller in charge of managing - storing, adding, removing, updating - TypedMessages.
 */
class TypedMessageManager extends AbstractMessageManager_1.AbstractMessageManager {
    constructor() {
        super(...arguments);
        /**
         * Name of this controller used during composition
         */
        this.name = 'TypedMessageManager';
    }
    /**
     * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new TypedMessage to this.messages, and to save the unapproved TypedMessages.
     *
     * @param messageParams - The params for the eth_signTypedData call to be made after the message is approved
     * @param version - Compatibility version EIP712
     * @param req? - The original request object possibly containing the origin
     * @returns - Promise resolving to the raw data of the signature request
     */
    addUnapprovedMessageAsync(messageParams, version, req) {
        return new Promise((resolve, reject) => {
            if (version === 'V1') {
                util_1.validateTypedSignMessageDataV1(messageParams);
            }
            if (version === 'V3') {
                util_1.validateTypedSignMessageDataV3(messageParams);
            }
            const messageId = this.addUnapprovedMessage(messageParams, version, req);
            this.hub.once(`${messageId}:finished`, (data) => {
                switch (data.status) {
                    case 'signed':
                        return resolve(data.rawSig);
                    case 'rejected':
                        return reject(new Error('MetaMask Typed Message Signature: User denied message signature.'));
                    case 'errored':
                        return reject(new Error(`MetaMask Typed Message Signature: ${data.error}`));
                    default:
                        return reject(new Error(`MetaMask Typed Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
                }
            });
        });
    }
    /**
     * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new TypedMessage to this.messages, and to save the
     * unapproved TypedMessages.
     *
     * @param messageParams - The params for the 'eth_signTypedData' call to be made after the message
     * is approved
     * @param version - Compatibility version EIP712
     * @param req? - The original request object possibly containing the origin
     * @returns - The id of the newly created TypedMessage
     */
    addUnapprovedMessage(messageParams, version, req) {
        const messageId = uuid_1.v1();
        const messageParamsMetamask = Object.assign(Object.assign({}, messageParams), { metamaskId: messageId, version });
        if (req) {
            messageParams.origin = req.origin;
        }
        const messageData = {
            id: messageId,
            messageParams,
            status: 'unapproved',
            time: Date.now(),
            type: 'eth_signTypedData',
        };
        this.addMessage(messageData);
        this.hub.emit(`unapprovedMessage`, messageParamsMetamask);
        return messageId;
    }
    /**
     * Sets a TypedMessage status to 'errored' via a call to this.setMessageStatus.
     *
     * @param messageId - The id of the TypedMessage to error
     * @param error - The error to be included in TypedMessage
     */
    setMessageStatusErrored(messageId, error) {
        const message = this.getMessage(messageId);
        /* istanbul ignore if */
        if (!message) {
            return;
        }
        message.error = error;
        this.updateMessage(message);
        this.setMessageStatus(messageId, 'errored');
    }
    /**
     * Removes the metamaskId and version properties from passed messageParams and returns a promise which
     * resolves the updated messageParams
     *
     * @param messageParams - The messageParams to modify
     * @returns - Promise resolving to the messageParams with the metamaskId and version properties removed
     */
    prepMessageForSigning(messageParams) {
        delete messageParams.metamaskId;
        delete messageParams.version;
        return Promise.resolve(messageParams);
    }
}
exports.TypedMessageManager = TypedMessageManager;
exports.default = TypedMessageManager;
//# sourceMappingURL=TypedMessageManager.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/message-manager/TypedMessageManager.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/CollectiblesController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseController.js","../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/constants.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js","./assetsUtil":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/assetsUtil.js","async-mutex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-mutex/lib/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/CollectiblesController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectiblesController = void 0;
const events_1 = require("events");
const async_mutex_1 = require("async-mutex");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
const assetsUtil_1 = require("./assetsUtil");
/**
 * Controller that stores assets and exposes convenience methods
 */
class CollectiblesController extends BaseController_1.BaseController {
    /**
     * Creates a CollectiblesController instance
     *
     * @param options
     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes
     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes
     * @param options.getAssetName - Gets the name of the asset at the given address
     * @param options.getAssetSymbol - Gets the symbol of the asset at the given address
     * @param options.getCollectibleTokenURI - Gets the URI of the NFT at the given address, with the given ID
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor({ onPreferencesStateChange, onNetworkStateChange, getAssetName, getAssetSymbol, getCollectibleTokenURI, }, config, state) {
        super(config, state);
        this.mutex = new async_mutex_1.Mutex();
        /**
         * EventEmitter instance used to listen to specific EIP747 events
         */
        this.hub = new events_1.EventEmitter();
        /**
         * Name of this controller used during composition
         */
        this.name = 'CollectiblesController';
        this.defaultConfig = {
            networkType: constants_1.MAINNET,
            selectedAddress: '',
            chainId: '',
        };
        this.defaultState = {
            allCollectibleContracts: {},
            allCollectibles: {},
            collectibleContracts: [],
            collectibles: [],
            ignoredCollectibles: [],
        };
        this.initialize();
        this.getAssetName = getAssetName;
        this.getAssetSymbol = getAssetSymbol;
        this.getCollectibleTokenURI = getCollectibleTokenURI;
        onPreferencesStateChange(({ selectedAddress }) => {
            var _a, _b;
            const { allCollectibleContracts, allCollectibles } = this.state;
            const { chainId } = this.config;
            this.configure({ selectedAddress });
            this.update({
                collectibleContracts: ((_a = allCollectibleContracts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [],
                collectibles: ((_b = allCollectibles[selectedAddress]) === null || _b === void 0 ? void 0 : _b[chainId]) || [],
            });
        });
        onNetworkStateChange(({ provider }) => {
            var _a, _b;
            const { allCollectibleContracts, allCollectibles } = this.state;
            const { selectedAddress } = this.config;
            const { chainId } = provider;
            this.configure({ chainId });
            this.update({
                collectibleContracts: ((_a = allCollectibleContracts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [],
                collectibles: ((_b = allCollectibles[selectedAddress]) === null || _b === void 0 ? void 0 : _b[chainId]) || [],
            });
        });
    }
    getCollectibleApi(contractAddress, tokenId) {
        return `https://api.opensea.io/api/v1/asset/${contractAddress}/${tokenId}`;
    }
    getCollectibleContractInformationApi(contractAddress) {
        return `https://api.opensea.io/api/v1/asset_contract/${contractAddress}`;
    }
    /**
     * Request individual collectible information from OpenSea api
     *
     * @param contractAddress - Hex address of the collectible contract
     * @param tokenId - The collectible identifier
     * @returns - Promise resolving to the current collectible name and image
     */
    getCollectibleInformationFromApi(contractAddress, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenURI = this.getCollectibleApi(contractAddress, tokenId);
            let collectibleInformation;
            /* istanbul ignore if */
            if (this.openSeaApiKey) {
                collectibleInformation = yield util_1.handleFetch(tokenURI, {
                    headers: { 'X-API-KEY': this.openSeaApiKey },
                });
            }
            else {
                collectibleInformation = yield util_1.handleFetch(tokenURI);
            }
            const { num_sales, background_color, image_url, image_preview_url, image_thumbnail_url, image_original_url, animation_url, animation_original_url, name, description, external_link, creator, last_sale, } = collectibleInformation;
            /* istanbul ignore next */
            const collectibleMetadata = Object.assign({}, { name }, creator && { creator }, description && { description }, image_url && { image: image_url }, num_sales && { numberOfSales: num_sales }, background_color && { backgroundColor: background_color }, image_preview_url && { imagePreview: image_preview_url }, image_thumbnail_url && { imageThumbnail: image_thumbnail_url }, image_original_url && { imageOriginal: image_original_url }, animation_url && { animation: animation_url }, animation_original_url && {
                animationOriginal: animation_original_url,
            }, external_link && { externalLink: external_link }, last_sale && { lastSale: last_sale });
            return collectibleMetadata;
        });
    }
    /**
     * Request individual collectible information from contracts that follows Metadata Interface
     *
     * @param contractAddress - Hex address of the collectible contract
     * @param tokenId - The collectible identifier
     * @returns - Promise resolving to the current collectible name and image
     */
    getCollectibleInformationFromTokenURI(contractAddress, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenURI = yield this.getCollectibleTokenURI(contractAddress, tokenId);
            const object = yield util_1.handleFetch(tokenURI);
            const image = Object.prototype.hasOwnProperty.call(object, 'image')
                ? 'image'
                : /* istanbul ignore next */ 'image_url';
            return { image: object[image], name: object.name };
        });
    }
    /**
     * Request individual collectible information (name, image url and description)
     *
     * @param contractAddress - Hex address of the collectible contract
     * @param tokenId - The collectible identifier
     * @returns - Promise resolving to the current collectible name and image
     */
    getCollectibleInformation(contractAddress, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            let information;
            // First try with OpenSea
            information = yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                return yield this.getCollectibleInformationFromApi(contractAddress, tokenId);
            }));
            if (information) {
                return information;
            }
            // Then following ERC721 standard
            information = yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                return yield this.getCollectibleInformationFromTokenURI(contractAddress, tokenId);
            }));
            /* istanbul ignore next */
            if (information) {
                return information;
            }
            /* istanbul ignore next */
            return {};
        });
    }
    /**
     * Request collectible contract information from OpenSea api
     *
     * @param contractAddress - Hex address of the collectible contract
     * @returns - Promise resolving to the current collectible name and image
     */
    getCollectibleContractInformationFromApi(contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const api = this.getCollectibleContractInformationApi(contractAddress);
            let apiCollectibleContractObject;
            /* istanbul ignore if */
            if (this.openSeaApiKey) {
                apiCollectibleContractObject = yield util_1.handleFetch(api, {
                    headers: { 'X-API-KEY': this.openSeaApiKey },
                });
            }
            else {
                apiCollectibleContractObject = yield util_1.handleFetch(api);
            }
            return apiCollectibleContractObject;
        });
    }
    /**
     * Request collectible contract information from the contract itself
     *
     * @param contractAddress - Hex address of the collectible contract
     * @returns - Promise resolving to the current collectible name and image
     */
    getCollectibleContractInformationFromContract(contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const name = yield this.getAssetName(contractAddress);
            const symbol = yield this.getAssetSymbol(contractAddress);
            return {
                name,
                symbol,
                address: contractAddress,
                asset_contract_type: null,
                created_date: null,
                schema_name: null,
                total_supply: null,
                description: null,
                external_link: null,
                image_url: null,
            };
        });
    }
    /**
     * Request collectible contract information from OpenSea api
     *
     * @param contractAddress - Hex address of the collectible contract
     * @returns - Promise resolving to the collectible contract name, image and description
     */
    getCollectibleContractInformation(contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            let information;
            // First try with OpenSea
            information = yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                return yield this.getCollectibleContractInformationFromApi(contractAddress);
            }));
            if (information) {
                return information;
            }
            // Then following ERC721 standard
            information = yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                return yield this.getCollectibleContractInformationFromContract(contractAddress);
            }));
            if (information) {
                return information;
            }
            /* istanbul ignore next */
            return {
                address: contractAddress,
                asset_contract_type: null,
                created_date: null,
                name: null,
                schema_name: null,
                symbol: null,
                total_supply: null,
                description: null,
                external_link: null,
                image_url: null,
            };
        });
    }
    /**
     * Adds an individual collectible to the stored collectible list
     *
     * @param address - Hex address of the collectible contract
     * @param tokenId - The collectible identifier
     * @param opts - Collectible optional information (name, image and description)
     * @returns - Promise resolving to the current collectible list
     */
    addIndividualCollectible(address, tokenId, collectibleMetadata) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                address = util_1.toChecksumHexAddress(address);
                const { allCollectibles, collectibles } = this.state;
                const { chainId, selectedAddress } = this.config;
                const existingEntry = collectibles.find((collectible) => collectible.address.toLowerCase() === address.toLowerCase() &&
                    collectible.tokenId === tokenId);
                /* istanbul ignore next */
                collectibleMetadata =
                    collectibleMetadata ||
                        (yield this.getCollectibleInformation(address, tokenId));
                if (existingEntry) {
                    const differentMetadata = assetsUtil_1.compareCollectiblesMetadata(collectibleMetadata, existingEntry);
                    if (differentMetadata) {
                        const indexToRemove = collectibles.findIndex((collectible) => collectible.address.toLowerCase() === address.toLowerCase() &&
                            collectible.tokenId === tokenId);
                        /* istanbul ignore next */
                        if (indexToRemove !== -1) {
                            collectibles.splice(indexToRemove, 1);
                        }
                    }
                    else {
                        return collectibles;
                    }
                }
                const newEntry = Object.assign({ address,
                    tokenId }, collectibleMetadata);
                const newCollectibles = [...collectibles, newEntry];
                const addressCollectibles = allCollectibles[selectedAddress];
                const newAddressCollectibles = Object.assign(Object.assign({}, addressCollectibles), { [chainId]: newCollectibles });
                const newAllCollectibles = Object.assign(Object.assign({}, allCollectibles), { [selectedAddress]: newAddressCollectibles });
                this.update({
                    allCollectibles: newAllCollectibles,
                    collectibles: newCollectibles,
                });
                return newCollectibles;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Adds a collectible contract to the stored collectible contracts list
     *
     * @param address - Hex address of the collectible contract
     * @param detection? - Whether the collectible is manually added or auto-detected
     * @returns - Promise resolving to the current collectible contracts list
     */
    addCollectibleContract(address, detection) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                address = util_1.toChecksumHexAddress(address);
                const { allCollectibleContracts, collectibleContracts } = this.state;
                const { chainId, selectedAddress } = this.config;
                const existingEntry = collectibleContracts.find((collectibleContract) => collectibleContract.address.toLowerCase() === address.toLowerCase());
                if (existingEntry) {
                    return collectibleContracts;
                }
                const contractInformation = yield this.getCollectibleContractInformation(address);
                const { asset_contract_type, created_date, name, schema_name, symbol, total_supply, description, external_link, image_url, } = contractInformation;
                // If being auto-detected opensea information is expected
                // Oherwise at least name and symbol from contract is needed
                if ((detection && !image_url) ||
                    Object.keys(contractInformation).length === 0) {
                    return collectibleContracts;
                }
                /* istanbul ignore next */
                const newEntry = Object.assign({}, { address }, description && { description }, name && { name }, image_url && { logo: image_url }, symbol && { symbol }, total_supply !== null && { totalSupply: total_supply }, asset_contract_type && { assetContractType: asset_contract_type }, created_date && { createdDate: created_date }, schema_name && { schemaName: schema_name }, external_link && { externalLink: external_link });
                const newCollectibleContracts = [...collectibleContracts, newEntry];
                const addressCollectibleContracts = allCollectibleContracts[selectedAddress];
                const newAddressCollectibleContracts = Object.assign(Object.assign({}, addressCollectibleContracts), { [chainId]: newCollectibleContracts });
                const newAllCollectibleContracts = Object.assign(Object.assign({}, allCollectibleContracts), { [selectedAddress]: newAddressCollectibleContracts });
                this.update({
                    allCollectibleContracts: newAllCollectibleContracts,
                    collectibleContracts: newCollectibleContracts,
                });
                return newCollectibleContracts;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Removes an individual collectible from the stored token list and saves it in ignored collectibles list
     *
     * @param address - Hex address of the collectible contract
     * @param tokenId - Token identifier of the collectible
     */
    removeAndIgnoreIndividualCollectible(address, tokenId) {
        address = util_1.toChecksumHexAddress(address);
        const { allCollectibles, collectibles, ignoredCollectibles } = this.state;
        const { chainId, selectedAddress } = this.config;
        const newIgnoredCollectibles = [...ignoredCollectibles];
        const newCollectibles = collectibles.filter((collectible) => {
            if (collectible.address.toLowerCase() === address.toLowerCase() &&
                collectible.tokenId === tokenId) {
                const alreadyIgnored = newIgnoredCollectibles.find((c) => c.address === address && c.tokenId === tokenId);
                !alreadyIgnored && newIgnoredCollectibles.push(collectible);
                return false;
            }
            return true;
        });
        const addressCollectibles = allCollectibles[selectedAddress];
        const newAddressCollectibles = Object.assign(Object.assign({}, addressCollectibles), { [chainId]: newCollectibles });
        const newAllCollectibles = Object.assign(Object.assign({}, allCollectibles), { [selectedAddress]: newAddressCollectibles });
        this.update({
            allCollectibles: newAllCollectibles,
            collectibles: newCollectibles,
            ignoredCollectibles: newIgnoredCollectibles,
        });
    }
    /**
     * Removes an individual collectible from the stored token list
     *
     * @param address - Hex address of the collectible contract
     * @param tokenId - Token identifier of the collectible
     */
    removeIndividualCollectible(address, tokenId) {
        address = util_1.toChecksumHexAddress(address);
        const { allCollectibles, collectibles } = this.state;
        const { chainId, selectedAddress } = this.config;
        const newCollectibles = collectibles.filter((collectible) => !(collectible.address.toLowerCase() === address.toLowerCase() &&
            collectible.tokenId === tokenId));
        const addressCollectibles = allCollectibles[selectedAddress];
        const newAddressCollectibles = Object.assign(Object.assign({}, addressCollectibles), { [chainId]: newCollectibles });
        const newAllCollectibles = Object.assign(Object.assign({}, allCollectibles), { [selectedAddress]: newAddressCollectibles });
        this.update({
            allCollectibles: newAllCollectibles,
            collectibles: newCollectibles,
        });
    }
    /**
     * Removes a collectible contract to the stored collectible contracts list
     *
     * @param address - Hex address of the collectible contract
     * @returns - Promise resolving to the current collectible contracts list
     */
    removeCollectibleContract(address) {
        address = util_1.toChecksumHexAddress(address);
        const { allCollectibleContracts, collectibleContracts } = this.state;
        const { chainId, selectedAddress } = this.config;
        const newCollectibleContracts = collectibleContracts.filter((collectibleContract) => !(collectibleContract.address.toLowerCase() === address.toLowerCase()));
        const addressCollectibleContracts = allCollectibleContracts[selectedAddress];
        const newAddressCollectibleContracts = Object.assign(Object.assign({}, addressCollectibleContracts), { [chainId]: newCollectibleContracts });
        const newAllCollectibleContracts = Object.assign(Object.assign({}, allCollectibleContracts), { [selectedAddress]: newAddressCollectibleContracts });
        this.update({
            allCollectibleContracts: newAllCollectibleContracts,
            collectibleContracts: newCollectibleContracts,
        });
        return newCollectibleContracts;
    }
    /**
     * Sets an OpenSea API key to retrieve collectible information
     *
     * @param openSeaApiKey - OpenSea API key
     */
    setApiKey(openSeaApiKey) {
        this.openSeaApiKey = openSeaApiKey;
    }
    /**
     * Adds a collectible and respective collectible contract to the stored collectible and collectible contracts lists
     *
     * @param address - Hex address of the collectible contract
     * @param tokenId - The collectible identifier
     * @param collectibleMetadata - Collectible optional metadata
     * @param detection? - Whether the collectible is manually added or autodetected
     * @returns - Promise resolving to the current collectible list
     */
    addCollectible(address, tokenId, collectibleMetadata, detection) {
        return __awaiter(this, void 0, void 0, function* () {
            address = util_1.toChecksumHexAddress(address);
            const newCollectibleContracts = yield this.addCollectibleContract(address, detection);
            collectibleMetadata =
                collectibleMetadata ||
                    (yield this.getCollectibleInformation(address, tokenId));
            // If collectible contract was not added, do not add individual collectible
            const collectibleContract = newCollectibleContracts.find((contract) => contract.address.toLowerCase() === address.toLowerCase());
            // If collectible contract information, add individual collectible
            if (collectibleContract) {
                yield this.addIndividualCollectible(address, tokenId, collectibleMetadata);
            }
        });
    }
    /**
     * Removes a collectible from the stored token list
     *
     * @param address - Hex address of the collectible contract
     * @param tokenId - Token identifier of the collectible
     */
    removeCollectible(address, tokenId) {
        address = util_1.toChecksumHexAddress(address);
        this.removeIndividualCollectible(address, tokenId);
        const { collectibles } = this.state;
        const remainingCollectible = collectibles.find((collectible) => collectible.address.toLowerCase() === address.toLowerCase());
        if (!remainingCollectible) {
            this.removeCollectibleContract(address);
        }
    }
    /**
     * Removes a collectible from the stored token list and saves it in ignored collectibles list
     *
     * @param address - Hex address of the collectible contract
     * @param tokenId - Token identifier of the collectible
     */
    removeAndIgnoreCollectible(address, tokenId) {
        address = util_1.toChecksumHexAddress(address);
        this.removeAndIgnoreIndividualCollectible(address, tokenId);
        const { collectibles } = this.state;
        const remainingCollectible = collectibles.find((collectible) => collectible.address.toLowerCase() === address.toLowerCase());
        if (!remainingCollectible) {
            this.removeCollectibleContract(address);
        }
    }
    /**
     * Removes all collectibles from the ignored list
     */
    clearIgnoredCollectibles() {
        this.update({ ignoredCollectibles: [] });
    }
}
exports.CollectiblesController = CollectiblesController;
exports.default = CollectiblesController;
//# sourceMappingURL=CollectiblesController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/CollectiblesController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/gas/GasFeeController.js", {"../BaseControllerV2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseControllerV2.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js","./gas-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/gas/gas-util.js","eth-query":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-query/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/gas/GasFeeController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GasFeeController = exports.GAS_ESTIMATE_TYPES = exports.LEGACY_GAS_PRICES_API_URL = void 0;
const eth_query_1 = __importDefault(require("eth-query"));
const uuid_1 = require("uuid");
const ethereumjs_util_1 = require("ethereumjs-util");
const BaseControllerV2_1 = require("../BaseControllerV2");
const util_1 = require("../util");
const gas_util_1 = require("./gas-util");
const GAS_FEE_API = 'https://mock-gas-server.herokuapp.com/';
exports.LEGACY_GAS_PRICES_API_URL = `https://api.metaswap.codefi.network/gasPrices`;
/**
 * Indicates which type of gasEstimate the controller is currently returning.
 * This is useful as a way of asserting that the shape of gasEstimates matches
 * expectations. NONE is a special case indicating that no previous gasEstimate
 * has been fetched.
 */
exports.GAS_ESTIMATE_TYPES = {
    FEE_MARKET: 'fee-market',
    LEGACY: 'legacy',
    ETH_GASPRICE: 'eth_gasPrice',
    NONE: 'none',
};
const metadata = {
    gasFeeEstimates: { persist: true, anonymous: false },
    estimatedGasFeeTimeBounds: { persist: true, anonymous: false },
    gasEstimateType: { persist: true, anonymous: false },
};
const name = 'GasFeeController';
const defaultState = {
    gasFeeEstimates: {},
    estimatedGasFeeTimeBounds: {},
    gasEstimateType: exports.GAS_ESTIMATE_TYPES.NONE,
};
/**
 * Controller that retrieves gas fee estimate data and polls for updated data on a set interval
 */
class GasFeeController extends BaseControllerV2_1.BaseController {
    /**
     * Creates a GasFeeController instance
     *
     */
    constructor({ interval = 15000, messenger, state, fetchGasEstimates = gas_util_1.fetchGasEstimates, fetchEthGasPriceEstimate = gas_util_1.fetchEthGasPriceEstimate, fetchLegacyGasPriceEstimates = gas_util_1.fetchLegacyGasPriceEstimates, getCurrentNetworkEIP1559Compatibility, getCurrentAccountEIP1559Compatibility, getChainId, getCurrentNetworkLegacyGasAPICompatibility, getProvider, onNetworkStateChange, legacyAPIEndpoint = exports.LEGACY_GAS_PRICES_API_URL, EIP1559APIEndpoint = GAS_FEE_API, clientId, }) {
        super({
            name,
            metadata,
            messenger,
            state: Object.assign(Object.assign({}, defaultState), state),
        });
        this.intervalDelay = interval;
        this.fetchGasEstimates = fetchGasEstimates;
        this.fetchEthGasPriceEstimate = fetchEthGasPriceEstimate;
        this.fetchLegacyGasPriceEstimates = fetchLegacyGasPriceEstimates;
        this.pollTokens = new Set();
        this.getCurrentNetworkEIP1559Compatibility = getCurrentNetworkEIP1559Compatibility;
        this.getCurrentNetworkLegacyGasAPICompatibility = getCurrentNetworkLegacyGasAPICompatibility;
        this.getCurrentAccountEIP1559Compatibility = getCurrentAccountEIP1559Compatibility;
        this.EIP1559APIEndpoint = EIP1559APIEndpoint;
        this.legacyAPIEndpoint = legacyAPIEndpoint;
        this.getChainId = getChainId;
        this.currentChainId = this.getChainId();
        const provider = getProvider();
        this.ethQuery = new eth_query_1.default(provider);
        this.clientId = clientId;
        onNetworkStateChange(() => __awaiter(this, void 0, void 0, function* () {
            const newProvider = getProvider();
            const newChainId = this.getChainId();
            this.ethQuery = new eth_query_1.default(newProvider);
            if (this.currentChainId !== newChainId) {
                this.currentChainId = newChainId;
                yield this.resetPolling();
            }
        }));
    }
    resetPolling() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pollTokens.size !== 0) {
                const tokens = Array.from(this.pollTokens);
                this.stopPolling();
                yield this.getGasFeeEstimatesAndStartPolling(tokens[0]);
                tokens.slice(1).forEach((token) => {
                    this.pollTokens.add(token);
                });
            }
        });
    }
    fetchGasFeeEstimates(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._fetchGasFeeEstimateData(options);
        });
    }
    getGasFeeEstimatesAndStartPolling(pollToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const _pollToken = pollToken || uuid_1.v1();
            this.pollTokens.add(_pollToken);
            if (this.pollTokens.size === 1) {
                yield this._fetchGasFeeEstimateData();
                this._poll();
            }
            return _pollToken;
        });
    }
    /**
     * Gets and sets gasFeeEstimates in state
     *
     * @returns GasFeeEstimates
     */
    _fetchGasFeeEstimateData(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { shouldUpdateState = true } = options;
            let isEIP1559Compatible;
            const isLegacyGasAPICompatible = this.getCurrentNetworkLegacyGasAPICompatibility();
            let chainId = this.getChainId();
            if (typeof chainId === 'string' && ethereumjs_util_1.isHexString(chainId)) {
                chainId = parseInt(chainId, 16);
            }
            try {
                isEIP1559Compatible = yield this.getEIP1559Compatibility();
            }
            catch (e) {
                console.error(e);
                isEIP1559Compatible = false;
            }
            let newState = {
                gasFeeEstimates: {},
                estimatedGasFeeTimeBounds: {},
                gasEstimateType: exports.GAS_ESTIMATE_TYPES.NONE,
            };
            try {
                if (isEIP1559Compatible) {
                    const estimates = yield this.fetchGasEstimates(this.EIP1559APIEndpoint.replace('<chain_id>', `${chainId}`), this.clientId);
                    const { suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas, } = estimates.medium;
                    const estimatedGasFeeTimeBounds = this.getTimeEstimate(suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas);
                    newState = {
                        gasFeeEstimates: estimates,
                        estimatedGasFeeTimeBounds,
                        gasEstimateType: exports.GAS_ESTIMATE_TYPES.FEE_MARKET,
                    };
                }
                else if (isLegacyGasAPICompatible) {
                    const estimates = yield this.fetchLegacyGasPriceEstimates(this.legacyAPIEndpoint.replace('<chain_id>', `${chainId}`), this.clientId);
                    newState = {
                        gasFeeEstimates: estimates,
                        estimatedGasFeeTimeBounds: {},
                        gasEstimateType: exports.GAS_ESTIMATE_TYPES.LEGACY,
                    };
                }
                else {
                    throw new Error('Main gas fee/price estimation failed. Use fallback');
                }
            }
            catch (_a) {
                try {
                    const estimates = yield this.fetchEthGasPriceEstimate(this.ethQuery);
                    newState = {
                        gasFeeEstimates: estimates,
                        estimatedGasFeeTimeBounds: {},
                        gasEstimateType: exports.GAS_ESTIMATE_TYPES.ETH_GASPRICE,
                    };
                }
                catch (error) {
                    throw new Error(`Gas fee/price estimation failed. Message: ${error.message}`);
                }
            }
            if (shouldUpdateState) {
                this.update(() => {
                    return newState;
                });
            }
            return newState;
        });
    }
    /**
     * Remove the poll token, and stop polling if the set of poll tokens is empty
     */
    disconnectPoller(pollToken) {
        this.pollTokens.delete(pollToken);
        if (this.pollTokens.size === 0) {
            this.stopPolling();
        }
    }
    stopPolling() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
        this.pollTokens.clear();
        this.resetState();
    }
    /**
     * Prepare to discard this controller.
     *
     * This stops any active polling.
     */
    destroy() {
        super.destroy();
        this.stopPolling();
    }
    _poll() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
        this.intervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {
            yield util_1.safelyExecute(() => this._fetchGasFeeEstimateData());
        }), this.intervalDelay);
    }
    resetState() {
        this.update(() => {
            return defaultState;
        });
    }
    getEIP1559Compatibility() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const currentNetworkIsEIP1559Compatible = yield this.getCurrentNetworkEIP1559Compatibility();
            const currentAccountIsEIP1559Compatible = (_b = (_a = this.getCurrentAccountEIP1559Compatibility) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : true;
            return (currentNetworkIsEIP1559Compatible && currentAccountIsEIP1559Compatible);
        });
    }
    getTimeEstimate(maxPriorityFeePerGas, maxFeePerGas) {
        if (!this.state.gasFeeEstimates ||
            this.state.gasEstimateType !== exports.GAS_ESTIMATE_TYPES.FEE_MARKET) {
            return {};
        }
        return gas_util_1.calculateTimeEstimate(maxPriorityFeePerGas, maxFeePerGas, this.state.gasFeeEstimates);
    }
}
exports.GasFeeController = GasFeeController;
exports.default = GasFeeController;
//# sourceMappingURL=GasFeeController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/gas/GasFeeController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/constants.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","eth-ens-namehash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-ens-namehash/index.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","eth-sig-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-sig-util/dist/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","ethjs-unit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethjs-unit/lib/index.js","ethjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-util/lib/index.js","jsonschema":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/jsonschema/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateMinimumIncrease = exports.isGasPriceValue = exports.isFeeMarketEIP1559Values = exports.validateGasValues = exports.getIncreasedPriceFromExisting = exports.getIncreasedPriceHex = exports.convertPriceToDecimal = exports.isEIP1559Transaction = exports.query = exports.normalizeEnsName = exports.timeoutFetch = exports.handleFetch = exports.successfulFetch = exports.isSmartContractCode = exports.validateTokenToWatch = exports.validateTypedSignMessageDataV3 = exports.validateTypedSignMessageDataV1 = exports.validateSignMessageData = exports.normalizeMessageData = exports.validateTransaction = exports.isValidHexAddress = exports.toChecksumHexAddress = exports.safelyExecuteWithTimeout = exports.safelyExecute = exports.normalizeTransaction = exports.hexToText = exports.hexToBN = exports.handleTransactionFetch = exports.getEtherscanApiUrl = exports.getBuyURL = exports.weiHexToGweiDec = exports.gweiDecToWEIBN = exports.fractionBN = exports.BNToHex = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const ethjs_util_1 = require("ethjs-util");
const ethjs_unit_1 = require("ethjs-unit");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const eth_ens_namehash_1 = __importDefault(require("eth-ens-namehash"));
const eth_sig_util_1 = require("eth-sig-util");
const jsonschema_1 = require("jsonschema");
const constants_1 = require("./constants");
const hexRe = /^[0-9A-Fa-f]+$/gu;
const NORMALIZERS = {
    data: (data) => ethereumjs_util_1.addHexPrefix(data),
    from: (from) => ethereumjs_util_1.addHexPrefix(from).toLowerCase(),
    gas: (gas) => ethereumjs_util_1.addHexPrefix(gas),
    gasPrice: (gasPrice) => ethereumjs_util_1.addHexPrefix(gasPrice),
    nonce: (nonce) => ethereumjs_util_1.addHexPrefix(nonce),
    to: (to) => ethereumjs_util_1.addHexPrefix(to).toLowerCase(),
    value: (value) => ethereumjs_util_1.addHexPrefix(value),
    maxFeePerGas: (maxFeePerGas) => ethereumjs_util_1.addHexPrefix(maxFeePerGas),
    maxPriorityFeePerGas: (maxPriorityFeePerGas) => ethereumjs_util_1.addHexPrefix(maxPriorityFeePerGas),
    estimatedBaseFee: (maxPriorityFeePerGas) => ethereumjs_util_1.addHexPrefix(maxPriorityFeePerGas),
};
/**
 * Converts a BN object to a hex string with a '0x' prefix
 *
 * @param inputBn - BN instance to convert to a hex string
 * @returns - '0x'-prefixed hex string
 *
 */
function BNToHex(inputBn) {
    return ethereumjs_util_1.addHexPrefix(inputBn.toString(16));
}
exports.BNToHex = BNToHex;
/**
 * Used to multiply a BN by a fraction
 *
 * @param targetBN - Number to multiply by a fraction
 * @param numerator - Numerator of the fraction multiplier
 * @param denominator - Denominator of the fraction multiplier
 * @returns - Product of the multiplication
 */
function fractionBN(targetBN, numerator, denominator) {
    const numBN = new ethereumjs_util_1.BN(numerator);
    const denomBN = new ethereumjs_util_1.BN(denominator);
    return targetBN.mul(numBN).div(denomBN);
}
exports.fractionBN = fractionBN;
/**
 * Used to convert a base-10 number from GWEI to WEI. Can handle numbers with decimal parts
 *
 * @param n - The base 10 number to convert to WEI
 * @returns - The number in WEI, as a BN
 */
function gweiDecToWEIBN(n) {
    if (Number.isNaN(n)) {
        return new ethereumjs_util_1.BN(0);
    }
    const parts = n.toString().split('.');
    const wholePart = parts[0] || '0';
    let decimalPart = parts[1] || '';
    if (!decimalPart) {
        return ethjs_unit_1.toWei(wholePart, 'gwei');
    }
    if (decimalPart.length <= 9) {
        return ethjs_unit_1.toWei(`${wholePart}.${decimalPart}`, 'gwei');
    }
    const decimalPartToRemove = decimalPart.slice(9);
    const decimalRoundingDigit = decimalPartToRemove[0];
    decimalPart = decimalPart.slice(0, 9);
    let wei = ethjs_unit_1.toWei(`${wholePart}.${decimalPart}`, 'gwei');
    if (Number(decimalRoundingDigit) >= 5) {
        wei = wei.add(new ethereumjs_util_1.BN(1));
    }
    return wei;
}
exports.gweiDecToWEIBN = gweiDecToWEIBN;
/**
 * Used to convert values from wei hex format to dec gwei format
 * @param hex - value in hex wei
 * @returns - value in dec gwei as string
 */
function weiHexToGweiDec(hex) {
    const hexWei = new ethereumjs_util_1.BN(ethjs_util_1.stripHexPrefix(hex), 16);
    return ethjs_unit_1.fromWei(hexWei, 'gwei').toString(10);
}
exports.weiHexToGweiDec = weiHexToGweiDec;
/**
 * Return a URL that can be used to obtain ETH for a given network
 *
 * @param networkCode - Network code of desired network
 * @param address - Address to deposit obtained ETH
 * @param amount - How much ETH is desired
 * @returns - URL to buy ETH based on network
 */
function getBuyURL(networkCode = '1', address, amount = 5) {
    switch (networkCode) {
        case '1':
            return `https://buy.coinbase.com/?code=9ec56d01-7e81-5017-930c-513daa27bb6a&amount=${amount}&address=${address}&crypto_currency=ETH`;
        case '3':
            return 'https://faucet.metamask.io/';
        case '4':
            return 'https://www.rinkeby.io/';
        case '5':
            return 'https://goerli-faucet.slock.it/';
        case '42':
            return 'https://github.com/kovan-testnet/faucet';
        default:
            return undefined;
    }
}
exports.getBuyURL = getBuyURL;
/**
 * Return a URL that can be used to fetch ETH transactions
 *
 * @param networkType - Network type of desired network
 * @param urlParams - Parameters used to construct the URL
 * @returns - URL to fetch the access the endpoint
 */
function getEtherscanApiUrl(networkType, urlParams) {
    let etherscanSubdomain = 'api';
    if (networkType !== constants_1.MAINNET) {
        etherscanSubdomain = `api-${networkType}`;
    }
    const apiUrl = `https://${etherscanSubdomain}.etherscan.io`;
    let url = `${apiUrl}/api?`;
    for (const paramKey in urlParams) {
        if (urlParams[paramKey]) {
            url += `${paramKey}=${urlParams[paramKey]}&`;
        }
    }
    url += 'tag=latest&page=1';
    return url;
}
exports.getEtherscanApiUrl = getEtherscanApiUrl;
/**
 * Handles the fetch of incoming transactions
 *
 * @param networkType - Network type of desired network
 * @param address - Address to get the transactions from
 * @param opt? - Object that can contain fromBlock and Etherscan service API key
 * @returns - Responses for both ETH and ERC20 token transactions
 */
function handleTransactionFetch(networkType, address, txHistoryLimit, opt) {
    return __awaiter(this, void 0, void 0, function* () {
        // transactions
        const urlParams = {
            module: 'account',
            address,
            startBlock: opt === null || opt === void 0 ? void 0 : opt.fromBlock,
            apikey: opt === null || opt === void 0 ? void 0 : opt.etherscanApiKey,
            offset: txHistoryLimit.toString(),
            order: 'desc',
        };
        const etherscanTxUrl = getEtherscanApiUrl(networkType, Object.assign(Object.assign({}, urlParams), { action: 'txlist' }));
        const etherscanTxResponsePromise = handleFetch(etherscanTxUrl);
        // tokens
        const etherscanTokenUrl = getEtherscanApiUrl(networkType, Object.assign(Object.assign({}, urlParams), { action: 'tokentx' }));
        const etherscanTokenResponsePromise = handleFetch(etherscanTokenUrl);
        let [etherscanTxResponse, etherscanTokenResponse] = yield Promise.all([
            etherscanTxResponsePromise,
            etherscanTokenResponsePromise,
        ]);
        if (etherscanTxResponse.status === '0' ||
            etherscanTxResponse.result.length <= 0) {
            etherscanTxResponse = { status: etherscanTxResponse.status, result: [] };
        }
        if (etherscanTokenResponse.status === '0' ||
            etherscanTokenResponse.result.length <= 0) {
            etherscanTokenResponse = {
                status: etherscanTokenResponse.status,
                result: [],
            };
        }
        return [etherscanTxResponse, etherscanTokenResponse];
    });
}
exports.handleTransactionFetch = handleTransactionFetch;
/**
 * Converts a hex string to a BN object
 *
 * @param inputHex - Number represented as a hex string
 * @returns - A BN instance
 *
 */
function hexToBN(inputHex) {
    return new ethereumjs_util_1.BN(ethjs_util_1.stripHexPrefix(inputHex), 16);
}
exports.hexToBN = hexToBN;
/**
 * A helper function that converts hex data to human readable string
 *
 * @param hex - The hex string to convert to string
 * @returns - A human readable string conversion
 *
 */
function hexToText(hex) {
    try {
        const stripped = ethjs_util_1.stripHexPrefix(hex);
        const buff = Buffer.from(stripped, 'hex');
        return buff.toString('utf8');
    }
    catch (e) {
        /* istanbul ignore next */
        return hex;
    }
}
exports.hexToText = hexToText;
/**
 * Normalizes properties on a Transaction object
 *
 * @param transaction - Transaction object to normalize
 * @returns - Normalized Transaction object
 */
function normalizeTransaction(transaction) {
    const normalizedTransaction = { from: '' };
    let key;
    for (key in NORMALIZERS) {
        if (transaction[key]) {
            normalizedTransaction[key] = NORMALIZERS[key](transaction[key]);
        }
    }
    return normalizedTransaction;
}
exports.normalizeTransaction = normalizeTransaction;
/**
 * Execute and return an asynchronous operation without throwing errors
 *
 * @param operation - Function returning a Promise
 * @param logError - Determines if the error should be logged
 * @param retry - Function called if an error is caught
 * @returns - Promise resolving to the result of the async operation
 */
function safelyExecute(operation, logError = false, retry) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield operation();
        }
        catch (error) {
            /* istanbul ignore next */
            if (logError) {
                console.error(error);
            }
            retry === null || retry === void 0 ? void 0 : retry(error);
            return undefined;
        }
    });
}
exports.safelyExecute = safelyExecute;
/**
 * Execute and return an asynchronous operation with a timeout
 *
 * @param operation - Function returning a Promise
 * @param logError - Determines if the error should be logged
 * @param retry - Function called if an error is caught
 * @param timeout - Timeout to fail the operation
 * @returns - Promise resolving to the result of the async operation
 */
function safelyExecuteWithTimeout(operation, logError = false, timeout = 500) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield Promise.race([
                operation(),
                new Promise((_, reject) => setTimeout(() => {
                    reject(new Error('timeout'));
                }, timeout)),
            ]);
        }
        catch (error) {
            /* istanbul ignore next */
            if (logError) {
                console.error(error);
            }
            return undefined;
        }
    });
}
exports.safelyExecuteWithTimeout = safelyExecuteWithTimeout;
function toChecksumHexAddress(address) {
    const hexPrefixed = ethereumjs_util_1.addHexPrefix(address);
    if (!ethereumjs_util_1.isHexString(hexPrefixed)) {
        // Version 5.1 of ethereumjs-utils would have returned '0xY' for input 'y'
        // but we shouldn't waste effort trying to change case on a clearly invalid
        // string. Instead just return the hex prefixed original string which most
        // closely mimics the original behavior.
        return hexPrefixed;
    }
    return ethereumjs_util_1.toChecksumAddress(hexPrefixed);
}
exports.toChecksumHexAddress = toChecksumHexAddress;
/**
 * Validates that the input is a hex address. This utility method is a thin
 * wrapper around ethereumjs-util.isValidAddress, with the exception that it
 * does not throw an error when provided values that are not hex strings. In
 * addition, and by default, this method will return true for hex strings that
 * meet the length requirement of a hex address, but are not prefixed with `0x`
 * Finally, if the mixedCaseUseChecksum flag is true and a mixed case string is
 * provided this method will validate it has the proper checksum formatting.
 * @param {string} possibleAddress - Input parameter to check against
 * @param {Object} [options] - options bag
 * @param {boolean} [options.allowNonPrefixed] - If true will first ensure '0x'
 *  is prepended to the string
 * @returns {boolean} whether or not the input is a valid hex address
 */
function isValidHexAddress(possibleAddress, { allowNonPrefixed = true } = {}) {
    const addressToCheck = allowNonPrefixed
        ? ethereumjs_util_1.addHexPrefix(possibleAddress)
        : possibleAddress;
    if (!ethereumjs_util_1.isHexString(addressToCheck)) {
        return false;
    }
    return ethereumjs_util_1.isValidAddress(addressToCheck);
}
exports.isValidHexAddress = isValidHexAddress;
/**
 * Validates a Transaction object for required properties and throws in
 * the event of any validation error.
 *
 * @param transaction - Transaction object to validate
 */
function validateTransaction(transaction) {
    if (!transaction.from ||
        typeof transaction.from !== 'string' ||
        !isValidHexAddress(transaction.from)) {
        throw new Error(`Invalid "from" address: ${transaction.from} must be a valid string.`);
    }
    if (transaction.to === '0x' || transaction.to === undefined) {
        if (transaction.data) {
            delete transaction.to;
        }
        else {
            throw new Error(`Invalid "to" address: ${transaction.to} must be a valid string.`);
        }
    }
    else if (transaction.to !== undefined &&
        !isValidHexAddress(transaction.to)) {
        throw new Error(`Invalid "to" address: ${transaction.to} must be a valid string.`);
    }
    if (transaction.value !== undefined) {
        const value = transaction.value.toString();
        if (value.includes('-')) {
            throw new Error(`Invalid "value": ${value} is not a positive number.`);
        }
        if (value.includes('.')) {
            throw new Error(`Invalid "value": ${value} number must be denominated in wei.`);
        }
        const intValue = parseInt(transaction.value, 10);
        const isValid = Number.isFinite(intValue) &&
            !Number.isNaN(intValue) &&
            !isNaN(Number(value)) &&
            Number.isSafeInteger(intValue);
        if (!isValid) {
            throw new Error(`Invalid "value": ${value} number must be a valid number.`);
        }
    }
}
exports.validateTransaction = validateTransaction;
/**
 * A helper function that converts rawmessageData buffer data to a hex, or just returns the data if
 * it is already formatted as a hex.
 *
 * @param data - The buffer data to convert to a hex
 * @returns - A hex string conversion of the buffer data
 *
 */
function normalizeMessageData(data) {
    try {
        const stripped = ethjs_util_1.stripHexPrefix(data);
        if (stripped.match(hexRe)) {
            return ethereumjs_util_1.addHexPrefix(stripped);
        }
    }
    catch (e) {
        /* istanbul ignore next */
    }
    return ethereumjs_util_1.bufferToHex(Buffer.from(data, 'utf8'));
}
exports.normalizeMessageData = normalizeMessageData;
/**
 * Validates a PersonalMessageParams and MessageParams objects for required properties and throws in
 * the event of any validation error.
 *
 * @param messageData - PersonalMessageParams object to validate
 */
function validateSignMessageData(messageData) {
    const { from, data } = messageData;
    if (!from || typeof from !== 'string' || !isValidHexAddress(from)) {
        throw new Error(`Invalid "from" address: ${from} must be a valid string.`);
    }
    if (!data || typeof data !== 'string') {
        throw new Error(`Invalid message "data": ${data} must be a valid string.`);
    }
}
exports.validateSignMessageData = validateSignMessageData;
/**
 * Validates a TypedMessageParams object for required properties and throws in
 * the event of any validation error for eth_signTypedMessage_V1.
 *
 * @param messageData - TypedMessageParams object to validate
 * @param activeChainId - Active chain id
 */
function validateTypedSignMessageDataV1(messageData) {
    if (!messageData.from ||
        typeof messageData.from !== 'string' ||
        !isValidHexAddress(messageData.from)) {
        throw new Error(`Invalid "from" address: ${messageData.from} must be a valid string.`);
    }
    if (!messageData.data || !Array.isArray(messageData.data)) {
        throw new Error(`Invalid message "data": ${messageData.data} must be a valid array.`);
    }
    try {
        // typedSignatureHash will throw if the data is invalid.
        eth_sig_util_1.typedSignatureHash(messageData.data);
    }
    catch (e) {
        throw new Error(`Expected EIP712 typed data.`);
    }
}
exports.validateTypedSignMessageDataV1 = validateTypedSignMessageDataV1;
/**
 * Validates a TypedMessageParams object for required properties and throws in
 * the event of any validation error for eth_signTypedMessage_V3.
 *
 * @param messageData - TypedMessageParams object to validate
 */
function validateTypedSignMessageDataV3(messageData) {
    if (!messageData.from ||
        typeof messageData.from !== 'string' ||
        !isValidHexAddress(messageData.from)) {
        throw new Error(`Invalid "from" address: ${messageData.from} must be a valid string.`);
    }
    if (!messageData.data || typeof messageData.data !== 'string') {
        throw new Error(`Invalid message "data": ${messageData.data} must be a valid array.`);
    }
    let data;
    try {
        data = JSON.parse(messageData.data);
    }
    catch (e) {
        throw new Error('Data must be passed as a valid JSON string.');
    }
    const validation = jsonschema_1.validate(data, eth_sig_util_1.TYPED_MESSAGE_SCHEMA);
    if (validation.errors.length > 0) {
        throw new Error('Data must conform to EIP-712 schema. See https://git.io/fNtcx.');
    }
}
exports.validateTypedSignMessageDataV3 = validateTypedSignMessageDataV3;
/**
 * Validates a ERC20 token to be added with EIP747.
 *
 * @param token - Token object to validate
 */
function validateTokenToWatch(token) {
    const { address, symbol, decimals } = token;
    if (!address || !symbol || typeof decimals === 'undefined') {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Must specify address, symbol, and decimals.`);
    }
    if (typeof symbol !== 'string') {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid symbol: not a string.`);
    }
    if (symbol.length > 11) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid symbol "${symbol}": longer than 11 characters.`);
    }
    const numDecimals = parseInt(decimals, 10);
    if (isNaN(numDecimals) || numDecimals > 36 || numDecimals < 0) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid decimals "${decimals}": must be 0 <= 36.`);
    }
    if (!isValidHexAddress(address)) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid address "${address}".`);
    }
}
exports.validateTokenToWatch = validateTokenToWatch;
/**
 * Returns wether the given code corresponds to a smart contract
 *
 * @returns {string} - Corresponding code to review
 */
function isSmartContractCode(code) {
    /* istanbul ignore if */
    if (!code) {
        return false;
    }
    // Geth will return '0x', and ganache-core v2.2.1 will return '0x0'
    const smartContractCode = code !== '0x' && code !== '0x0';
    return smartContractCode;
}
exports.isSmartContractCode = isSmartContractCode;
/**
 * Execute fetch and verify that the response was successful
 *
 * @param request - Request information
 * @param options - Options
 * @returns - Promise resolving to the fetch response
 */
function successfulFetch(request, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield fetch(request, options);
        if (!response.ok) {
            throw new Error(`Fetch failed with status '${response.status}' for request '${request}'`);
        }
        return response;
    });
}
exports.successfulFetch = successfulFetch;
/**
 * Execute fetch and return object response
 *
 * @param request - Request information
 * @param options - Options
 * @returns - Promise resolving to the result object of fetch
 */
function handleFetch(request, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield successfulFetch(request, options);
        const object = yield response.json();
        return object;
    });
}
exports.handleFetch = handleFetch;
/**
 * Fetch that fails after timeout
 *
 * @param url - Url to fetch
 * @param options - Options to send with the request
 * @param timeout - Timeout to fail request
 *
 * @returns - Promise resolving the request
 */
function timeoutFetch(url, options, timeout = 500) {
    return __awaiter(this, void 0, void 0, function* () {
        return Promise.race([
            successfulFetch(url, options),
            new Promise((_, reject) => setTimeout(() => {
                reject(new Error('timeout'));
            }, timeout)),
        ]);
    });
}
exports.timeoutFetch = timeoutFetch;
/**
 * Normalizes the given ENS name.
 *
 * @param {string} ensName - The ENS name
 *
 * @returns - the normalized ENS name string
 */
function normalizeEnsName(ensName) {
    if (ensName && typeof ensName === 'string') {
        try {
            const normalized = eth_ens_namehash_1.default.normalize(ensName.trim());
            // this regex is only sufficient with the above call to ensNamehash.normalize
            // TODO: change 7 in regex to 3 when shorter ENS domains are live
            if (normalized.match(/^(([\w\d-]+)\.)*[\w\d-]{7,}\.(eth|test)$/u)) {
                return normalized;
            }
        }
        catch (_) {
            // do nothing
        }
    }
    return null;
}
exports.normalizeEnsName = normalizeEnsName;
/**
 * Wrapper method to handle EthQuery requests
 *
 * @param ethQuery - EthQuery object initialized with a provider
 * @param method - Method to request
 * @param args - Arguments to send
 *
 * @returns - Promise resolving the request
 */
function query(ethQuery, method, args = []) {
    return new Promise((resolve, reject) => {
        ethQuery[method](...args, (error, result) => {
            if (error) {
                reject(error);
                return;
            }
            resolve(result);
        });
    });
}
exports.query = query;
/**
 * Checks if a transaction is EIP-1559 by checking for the existence of
 * maxFeePerGas and maxPriorityFeePerGas within its parameters
 *
 * @param transaction - Transaction object to add
 * @returns - Boolean that is true if the transaction is EIP-1559 (has maxFeePerGas and maxPriorityFeePerGas), otherwise returns false
 */
const isEIP1559Transaction = (transaction) => {
    const hasOwnProp = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
    return (hasOwnProp(transaction, 'maxFeePerGas') &&
        hasOwnProp(transaction, 'maxPriorityFeePerGas'));
};
exports.isEIP1559Transaction = isEIP1559Transaction;
const convertPriceToDecimal = (value) => parseInt(value === undefined ? '0x0' : value, 16);
exports.convertPriceToDecimal = convertPriceToDecimal;
const getIncreasedPriceHex = (value, rate) => ethereumjs_util_1.addHexPrefix(`${parseInt(`${value * rate}`, 10).toString(16)}`);
exports.getIncreasedPriceHex = getIncreasedPriceHex;
const getIncreasedPriceFromExisting = (value, rate) => {
    return exports.getIncreasedPriceHex(exports.convertPriceToDecimal(value), rate);
};
exports.getIncreasedPriceFromExisting = getIncreasedPriceFromExisting;
const validateGasValues = (gasValues) => {
    Object.keys(gasValues).forEach((key) => {
        const value = gasValues[key];
        if (typeof value !== 'string' || !ethereumjs_util_1.isHexString(value)) {
            throw new TypeError(`expected hex string for ${key} but received: ${value}`);
        }
    });
};
exports.validateGasValues = validateGasValues;
const isFeeMarketEIP1559Values = (gasValues) => {
    var _a, _b;
    return ((_a = gasValues) === null || _a === void 0 ? void 0 : _a.maxFeePerGas) !== undefined ||
        ((_b = gasValues) === null || _b === void 0 ? void 0 : _b.maxPriorityFeePerGas) !== undefined;
};
exports.isFeeMarketEIP1559Values = isFeeMarketEIP1559Values;
const isGasPriceValue = (gasValues) => { var _a; return ((_a = gasValues) === null || _a === void 0 ? void 0 : _a.gasPrice) !== undefined; };
exports.isGasPriceValue = isGasPriceValue;
function validateMinimumIncrease(proposed, min) {
    const proposedDecimal = exports.convertPriceToDecimal(proposed);
    const minDecimal = exports.convertPriceToDecimal(min);
    if (proposedDecimal >= minDecimal) {
        return proposed;
    }
    const errorMsg = `The proposed value: ${proposedDecimal} should meet or exceed the minimum value: ${minDecimal}`;
    throw new Error(errorMsg);
}
exports.validateMinimumIncrease = validateMinimumIncrease;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/TokenListController.js", {"../BaseControllerV2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseControllerV2.js","../apis/token-service":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/apis/token-service.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js","@metamask/contract-metadata":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/contract-metadata/index.js","abort-controller":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/abort-controller/browser.js","async-mutex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-mutex/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/TokenListController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenListController = void 0;
const contract_metadata_1 = __importDefault(require("@metamask/contract-metadata"));
const async_mutex_1 = require("async-mutex");
// eslint-disable-next-line import/no-named-as-default
const abort_controller_1 = __importDefault(require("abort-controller"));
const BaseControllerV2_1 = require("../BaseControllerV2");
const util_1 = require("../util");
const token_service_1 = require("../apis/token-service");
const DEFAULT_INTERVAL = 60 * 60 * 1000;
const DEFAULT_THRESHOLD = 60 * 30 * 1000;
const name = 'TokenListController';
const metadata = {
    tokenList: { persist: true, anonymous: true },
    tokensChainsCache: { persist: true, anonymous: true },
};
const defaultState = {
    tokenList: {},
    tokensChainsCache: {},
};
/**
 * Controller that passively polls on a set interval for the list of tokens from metaswaps api
 */
class TokenListController extends BaseControllerV2_1.BaseController {
    // private abortSignal: AbortSignal;
    /**
     * Creates a TokenListController instance
     *
     * @param options - Constructor options
     * @param options.interval - The polling interval, in milliseconds
     * @param options.messenger - A reference to the messaging system
     * @param options.state - Initial state to set on this controller
     */
    constructor({ chainId, useStaticTokenList, onNetworkStateChange, onPreferencesStateChange, interval = DEFAULT_INTERVAL, cacheRefreshThreshold = DEFAULT_THRESHOLD, messenger, state, }) {
        super({
            name,
            metadata,
            messenger,
            state: Object.assign(Object.assign({}, defaultState), state),
        });
        this.mutex = new async_mutex_1.Mutex();
        this.intervalDelay = interval;
        this.cacheRefreshThreshold = cacheRefreshThreshold;
        this.chainId = chainId;
        this.useStaticTokenList = useStaticTokenList;
        this.abortController = new abort_controller_1.default();
        onNetworkStateChange((networkState) => __awaiter(this, void 0, void 0, function* () {
            if (this.chainId !== networkState.provider.chainId) {
                this.abortController.abort();
                this.abortController = new abort_controller_1.default();
                this.chainId = networkState.provider.chainId;
                yield this.restart();
            }
        }));
        onPreferencesStateChange((preferencesState) => __awaiter(this, void 0, void 0, function* () {
            if (this.useStaticTokenList !== preferencesState.useStaticTokenList) {
                this.abortController.abort();
                this.abortController = new abort_controller_1.default();
                this.useStaticTokenList = preferencesState.useStaticTokenList;
                yield this.restart();
            }
        }));
    }
    /**
     * Start polling for the token list
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.startPolling();
        });
    }
    /**
     * Restart polling for the token list
     */
    restart() {
        return __awaiter(this, void 0, void 0, function* () {
            this.stopPolling();
            yield this.startPolling();
        });
    }
    /**
     * Stop polling for the token list
     */
    stop() {
        this.stopPolling();
    }
    /**
     * Prepare to discard this controller.
     *
     * This stops any active polling.
     */
    destroy() {
        super.destroy();
        this.stopPolling();
    }
    stopPolling() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
    }
    /**
     * Starts a new polling interval
     */
    startPolling() {
        return __awaiter(this, void 0, void 0, function* () {
            yield util_1.safelyExecute(() => this.fetchTokenList());
            this.intervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                yield util_1.safelyExecute(() => this.fetchTokenList());
            }), this.intervalDelay);
        });
    }
    /**
     * Fetching token list
     */
    fetchTokenList() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.useStaticTokenList) {
                yield this.fetchFromStaticTokenList();
            }
            else {
                yield this.fetchFromDynamicTokenList();
            }
        });
    }
    /**
     * Fetching token list from the contract-metadata as a fallback
     */
    fetchFromStaticTokenList() {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenList = {};
            for (const tokenAddress in contract_metadata_1.default) {
                const _a = contract_metadata_1.default[tokenAddress], { erc20, logo: filePath } = _a, token = __rest(_a, ["erc20", "logo"]);
                if (erc20) {
                    tokenList[tokenAddress] = Object.assign(Object.assign({}, token), { address: tokenAddress, iconUrl: filePath, occurrences: null });
                }
            }
            this.update(() => {
                return {
                    tokenList,
                    tokensChainsCache: {},
                };
            });
        });
    }
    /**
     * Fetching token list from the Token Service API
     */
    fetchFromDynamicTokenList() {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                const cachedTokens = yield util_1.safelyExecute(() => this.fetchFromCache());
                const _a = this.state, { tokensChainsCache } = _a, tokensData = __rest(_a, ["tokensChainsCache"]);
                const tokenList = {};
                if (cachedTokens) {
                    for (const token of cachedTokens) {
                        tokenList[token.address] = token;
                    }
                }
                else {
                    const tokensFromAPI = yield util_1.safelyExecute(() => token_service_1.fetchTokenList(this.chainId, this.abortController.signal));
                    if (!tokensFromAPI) {
                        const backupTokenList = tokensChainsCache[this.chainId]
                            ? tokensChainsCache[this.chainId].data
                            : [];
                        for (const token of backupTokenList) {
                            tokenList[token.address] = token;
                        }
                        this.update(() => {
                            return Object.assign(Object.assign({}, tokensData), { tokenList,
                                tokensChainsCache });
                        });
                        return;
                    }
                    // filtering out tokens with less than 2 occurrences
                    const filteredTokenList = tokensFromAPI.filter((token) => token.occurrences && token.occurrences >= 2);
                    // removing the tokens with symbol conflicts
                    const symbolsList = filteredTokenList.map((token) => token.symbol);
                    const duplicateSymbols = [
                        ...new Set(symbolsList.filter((symbol, index) => symbolsList.indexOf(symbol) !== index)),
                    ];
                    const uniqueTokenList = filteredTokenList.filter((token) => !duplicateSymbols.includes(token.symbol));
                    for (const token of uniqueTokenList) {
                        tokenList[token.address] = token;
                    }
                }
                const updatedTokensChainsCache = Object.assign(Object.assign({}, tokensChainsCache), { [this.chainId]: {
                        timestamp: Date.now(),
                        data: Object.values(tokenList),
                    } });
                this.update(() => {
                    return Object.assign(Object.assign({}, tokensData), { tokenList, tokensChainsCache: updatedTokensChainsCache });
                });
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Checks if the Cache timestamp is valid,
     *  if yes data in cache will be returned
     *  otherwise null will be returned.
     * @returns Promise that resolves into TokenListToken[] or null
     */
    fetchFromCache() {
        return __awaiter(this, void 0, void 0, function* () {
            const { tokensChainsCache } = this.state;
            const dataCache = tokensChainsCache[this.chainId];
            const now = Date.now();
            if ((dataCache === null || dataCache === void 0 ? void 0 : dataCache.data) &&
                now - (dataCache === null || dataCache === void 0 ? void 0 : dataCache.timestamp) < this.cacheRefreshThreshold) {
                return dataCache.data;
            }
            return null;
        });
    }
    /**
     * Fetch metadata for a token whose address is send to the API
     * @param tokenAddress
     * @returns Promise that resolves to Token Metadata
     */
    fetchTokenMetadata(tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                const token = (yield token_service_1.fetchTokenMetadata(this.chainId, tokenAddress, this.abortController.signal));
                return token;
            }
            finally {
                releaseLock();
            }
        });
    }
}
exports.TokenListController = TokenListController;
exports.default = TokenListController;
//# sourceMappingURL=TokenListController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/TokenListController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/TokensController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseController.js","../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/constants.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js","@metamask/contract-metadata":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/contract-metadata/index.js","async-mutex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-mutex/lib/index.js","ethers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethers/lib/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","human-standard-collectible-abi":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/human-standard-collectible-abi/index.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/TokensController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokensController = void 0;
const events_1 = require("events");
const contract_metadata_1 = __importDefault(require("@metamask/contract-metadata"));
const human_standard_collectible_abi_1 = __importDefault(require("human-standard-collectible-abi"));
const uuid_1 = require("uuid");
const async_mutex_1 = require("async-mutex");
const ethers_1 = require("ethers");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
const ERC721_INTERFACE_ID = '0x80ac58cd';
var SuggestedAssetStatus;
(function (SuggestedAssetStatus) {
    SuggestedAssetStatus["accepted"] = "accepted";
    SuggestedAssetStatus["failed"] = "failed";
    SuggestedAssetStatus["pending"] = "pending";
    SuggestedAssetStatus["rejected"] = "rejected";
})(SuggestedAssetStatus || (SuggestedAssetStatus = {}));
/**
 * Controller that stores assets and exposes convenience methods
 */
class TokensController extends BaseController_1.BaseController {
    /**
     * Creates a TokensController instance
     *
     * @param options
     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes
     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor({ onPreferencesStateChange, onNetworkStateChange, config, state, }) {
        super(config, state);
        this.mutex = new async_mutex_1.Mutex();
        /**
         * EventEmitter instance used to listen to specific EIP747 events
         */
        this.hub = new events_1.EventEmitter();
        /**
         * Name of this controller used during composition
         */
        this.name = 'TokensController';
        this.defaultConfig = Object.assign({ networkType: constants_1.MAINNET, selectedAddress: '', chainId: '', provider: undefined }, config);
        this.defaultState = Object.assign({ allTokens: {}, allIgnoredTokens: {}, ignoredTokens: [], suggestedAssets: [], tokens: [] }, state);
        this.initialize();
        onPreferencesStateChange(({ selectedAddress }) => {
            var _a, _b;
            const { allTokens, allIgnoredTokens } = this.state;
            const { chainId } = this.config;
            this.configure({ selectedAddress });
            this.update({
                tokens: ((_a = allTokens[chainId]) === null || _a === void 0 ? void 0 : _a[selectedAddress]) || [],
                ignoredTokens: ((_b = allIgnoredTokens[chainId]) === null || _b === void 0 ? void 0 : _b[selectedAddress]) || [],
            });
        });
        onNetworkStateChange(({ provider }) => {
            var _a, _b;
            const { allTokens, allIgnoredTokens } = this.state;
            const { selectedAddress } = this.config;
            const { chainId } = provider;
            this.configure({ chainId });
            this.ethersProvider = this._instantiateNewEthersProvider();
            this.update({
                tokens: ((_a = allTokens[chainId]) === null || _a === void 0 ? void 0 : _a[selectedAddress]) || [],
                ignoredTokens: ((_b = allIgnoredTokens[chainId]) === null || _b === void 0 ? void 0 : _b[selectedAddress]) || [],
            });
        });
    }
    failSuggestedAsset(suggestedAssetMeta, error) {
        const failedSuggestedAssetMeta = Object.assign(Object.assign({}, suggestedAssetMeta), { status: SuggestedAssetStatus.failed, error });
        this.hub.emit(`${suggestedAssetMeta.id}:finished`, failedSuggestedAssetMeta);
    }
    _instantiateNewEthersProvider() {
        var _a;
        return new ethers_1.ethers.providers.Web3Provider((_a = this.config) === null || _a === void 0 ? void 0 : _a.provider);
    }
    /**
     * Adds a token to the stored token list
     *
     * @param address - Hex address of the token contract
     * @param symbol - Symbol of the token
     * @param decimals - Number of decimals the token uses
     * @param image - Image of the token
     * @returns - Current token list
     */
    addToken(address, symbol, decimals, image) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                address = util_1.toChecksumHexAddress(address);
                const { tokens, ignoredTokens } = this.state;
                const isERC721 = yield this._detectIsERC721(address);
                const newEntry = { address, symbol, decimals, image, isERC721 };
                const previousEntry = tokens.find((token) => token.address.toLowerCase() === address.toLowerCase());
                if (previousEntry) {
                    const previousIndex = tokens.indexOf(previousEntry);
                    tokens[previousIndex] = newEntry;
                }
                else {
                    tokens.push(newEntry);
                }
                const newIgnoredTokens = ignoredTokens.filter((tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase());
                const { newAllTokens, newAllIgnoredTokens } = this._getNewAllTokensState(tokens, newIgnoredTokens);
                this.update({
                    allTokens: newAllTokens,
                    tokens,
                    allIgnoredTokens: newAllIgnoredTokens,
                    ignoredTokens: newIgnoredTokens,
                });
                return tokens;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Adds a batch of tokens to the stored token list
     *
     * @param tokens - Array of Tokens to be added or updated
     * @returns - Current token list
     */
    addTokens(tokensToAdd) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            const { tokens, ignoredTokens } = this.state;
            try {
                tokensToAdd = yield Promise.all(tokensToAdd.map((token) => __awaiter(this, void 0, void 0, function* () {
                    token.isERC721 = yield this._detectIsERC721(token.address);
                    return token;
                })));
                let newIgnoredTokens = ignoredTokens;
                tokensToAdd.forEach((tokenToAdd) => {
                    const { address, symbol, decimals, image, isERC721 } = tokenToAdd;
                    const checksumAddress = util_1.toChecksumHexAddress(address);
                    const newEntry = {
                        address: checksumAddress,
                        symbol,
                        decimals,
                        image,
                        isERC721,
                    };
                    const previousEntry = tokens.find((token) => token.address.toLowerCase() === checksumAddress.toLowerCase());
                    if (previousEntry) {
                        const previousIndex = tokens.indexOf(previousEntry);
                        tokens[previousIndex] = newEntry;
                    }
                    else {
                        tokens.push(newEntry);
                    }
                    newIgnoredTokens = newIgnoredTokens.filter((tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase());
                });
                const { newAllTokens, newAllIgnoredTokens } = this._getNewAllTokensState(tokens, newIgnoredTokens);
                this.update({
                    tokens,
                    allTokens: newAllTokens,
                    allIgnoredTokens: newAllIgnoredTokens,
                    ignoredTokens: newIgnoredTokens,
                });
                return tokens;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Adds isERC721 field to token object
     * (Called when a user attempts to add tokens that were previously added which do not yet had isERC721 field)
     *
     * @param {string} tokenAddress - The contract address of the token requiring the isERC721 field added.
     * @returns The new token object with the added isERC721 field.
     *
     */
    updateTokenType(tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const isERC721 = yield this._detectIsERC721(tokenAddress);
            const { tokens } = this.state;
            const tokenIndex = tokens.findIndex((token) => {
                return token.address.toLowerCase() === tokenAddress.toLowerCase();
            });
            tokens[tokenIndex].isERC721 = isERC721;
            this.update({ tokens });
            return tokens[tokenIndex];
        });
    }
    /**
     * Detects whether or not a token is ERC-721 compatible.
     *
     * @param {string} tokensAddress - the token contract address.
     * @returns boolean indicating whether the token address passed in supports the EIP-721 interface.
     *
     */
    _detectIsERC721(tokenAddress) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const checksumAddress = util_1.toChecksumHexAddress(tokenAddress);
            // if this token is already in our contract metadata map we don't need
            // to check against the contract
            if (((_a = contract_metadata_1.default[checksumAddress]) === null || _a === void 0 ? void 0 : _a.erc721) === true) {
                return Promise.resolve(true);
            }
            else if (((_b = contract_metadata_1.default[checksumAddress]) === null || _b === void 0 ? void 0 : _b.erc20) === true) {
                return Promise.resolve(false);
            }
            const tokenContract = yield this._createEthersContract(tokenAddress, human_standard_collectible_abi_1.default, this.ethersProvider);
            try {
                return yield tokenContract.supportsInterface(ERC721_INTERFACE_ID);
            }
            catch (error) {
                // currently we see a variety of errors across different networks when
                // token contracts are not ERC721 compatible. We need to figure out a better
                // way of differentiating token interface types but for now if we get an error
                // we have to assume the token is not ERC721 compatible.
                return false;
            }
        });
    }
    _createEthersContract(tokenAddress, abi, ethersProvider) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenContract = yield new ethers_1.ethers.Contract(tokenAddress, abi, ethersProvider);
            return tokenContract;
        });
    }
    _generateRandomId() {
        return uuid_1.v1();
    }
    /**
     * Adds a new suggestedAsset to state. Parameters will be validated according to
     * asset type being watched. A `<suggestedAssetMeta.id>:pending` hub event will be emitted once added.
     *
     * @param asset - Asset to be watched. For now only ERC20 tokens are accepted.
     * @param type - Asset type
     * @returns - Object containing a promise resolving to the suggestedAsset address if accepted
     */
    watchAsset(asset, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const suggestedAssetMeta = {
                asset,
                id: this._generateRandomId(),
                status: SuggestedAssetStatus.pending,
                time: Date.now(),
                type,
            };
            try {
                switch (type) {
                    case 'ERC20':
                        util_1.validateTokenToWatch(asset);
                        break;
                    default:
                        throw new Error(`Asset of type ${type} not supported`);
                }
            }
            catch (error) {
                this.failSuggestedAsset(suggestedAssetMeta, error);
                return Promise.reject(error);
            }
            const result = new Promise((resolve, reject) => {
                this.hub.once(`${suggestedAssetMeta.id}:finished`, (meta) => {
                    switch (meta.status) {
                        case SuggestedAssetStatus.accepted:
                            return resolve(meta.asset.address);
                        case SuggestedAssetStatus.rejected:
                            return reject(new Error('User rejected to watch the asset.'));
                        case SuggestedAssetStatus.failed:
                            return reject(new Error(meta.error.message));
                        /* istanbul ignore next */
                        default:
                            return reject(new Error(`Unknown status: ${meta.status}`));
                    }
                });
            });
            const { suggestedAssets } = this.state;
            suggestedAssets.push(suggestedAssetMeta);
            this.update({ suggestedAssets: [...suggestedAssets] });
            this.hub.emit('pendingSuggestedAsset', suggestedAssetMeta);
            return { result, suggestedAssetMeta };
        });
    }
    /**
     * Accepts to watch an asset and updates it's status and deletes the suggestedAsset from state,
     * adding the asset to corresponding asset state. In this case ERC20 tokens.
     * A `<suggestedAssetMeta.id>:finished` hub event is fired after accepted or failure.
     *
     * @param suggestedAssetID - ID of the suggestedAsset to accept
     * @returns - Promise resolving when this operation completes
     */
    acceptWatchAsset(suggestedAssetID) {
        return __awaiter(this, void 0, void 0, function* () {
            const { suggestedAssets } = this.state;
            const index = suggestedAssets.findIndex(({ id }) => suggestedAssetID === id);
            const suggestedAssetMeta = suggestedAssets[index];
            try {
                switch (suggestedAssetMeta.type) {
                    case 'ERC20':
                        const { address, symbol, decimals, image } = suggestedAssetMeta.asset;
                        yield this.addToken(address, symbol, decimals, image);
                        suggestedAssetMeta.status = SuggestedAssetStatus.accepted;
                        this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);
                        break;
                    default:
                        throw new Error(`Asset of type ${suggestedAssetMeta.type} not supported`);
                }
            }
            catch (error) {
                this.failSuggestedAsset(suggestedAssetMeta, error);
            }
            const newSuggestedAssets = suggestedAssets.filter(({ id }) => id !== suggestedAssetID);
            this.update({ suggestedAssets: [...newSuggestedAssets] });
        });
    }
    /**
     * Rejects a watchAsset request based on its ID by setting its status to "rejected"
     * and emitting a `<suggestedAssetMeta.id>:finished` hub event.
     *
     * @param suggestedAssetID - ID of the suggestedAsset to accept
     */
    rejectWatchAsset(suggestedAssetID) {
        const { suggestedAssets } = this.state;
        const index = suggestedAssets.findIndex(({ id }) => suggestedAssetID === id);
        const suggestedAssetMeta = suggestedAssets[index];
        if (!suggestedAssetMeta) {
            return;
        }
        suggestedAssetMeta.status = SuggestedAssetStatus.rejected;
        this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);
        const newSuggestedAssets = suggestedAssets.filter(({ id }) => id !== suggestedAssetID);
        this.update({ suggestedAssets: [...newSuggestedAssets] });
    }
    /**
     * Removes a token from the stored token list and saves it in ignored tokens list
     *
     * @param address - Hex address of the token contract
     */
    removeAndIgnoreToken(address) {
        address = util_1.toChecksumHexAddress(address);
        const { tokens, ignoredTokens } = this.state;
        const alreadyIgnored = ignoredTokens.find((tokenAddress) => tokenAddress.toLowerCase() === address.toLowerCase());
        const newTokens = tokens.filter((token) => {
            if (token.address.toLowerCase() === address.toLowerCase()) {
                !alreadyIgnored && ignoredTokens.push(address);
                return false;
            }
            return true;
        });
        const { newAllTokens, newAllIgnoredTokens } = this._getNewAllTokensState(newTokens, ignoredTokens);
        this.update({
            allTokens: newAllTokens,
            tokens: newTokens,
            allIgnoredTokens: newAllIgnoredTokens,
            ignoredTokens,
        });
    }
    /**
     * Takes a new tokens and ignoredTokens array for the current network/account combination
     * and returns new allTokens and allIgnoredTokens state to update to.
     *
     * @param newTokens - The new tokens to set for the current network and selected account.
     * @param newIgnoredTokens - The new ignored tokens to set for the current network and selected account.
     * @returns The updated `allTokens` and `allIgnoredTokens` state.
     */
    _getNewAllTokensState(newTokens, newIgnoredTokens) {
        const { allTokens, allIgnoredTokens } = this.state;
        const { chainId, selectedAddress } = this.config;
        const networkTokens = allTokens[chainId];
        const networkIgnoredTokens = allIgnoredTokens[chainId];
        const newNetworkTokens = Object.assign(Object.assign({}, networkTokens), { [selectedAddress]: newTokens });
        const newIgnoredNetworkTokens = Object.assign(Object.assign({}, networkIgnoredTokens), { [selectedAddress]: newIgnoredTokens });
        const newAllTokens = Object.assign(Object.assign({}, allTokens), { [chainId]: newNetworkTokens });
        const newAllIgnoredTokens = Object.assign(Object.assign({}, allIgnoredTokens), { [chainId]: newIgnoredNetworkTokens });
        return { newAllTokens, newAllIgnoredTokens };
    }
    /**
     * Removes all tokens from the ignored list
     */
    clearIgnoredTokens() {
        this.update({ ignoredTokens: [], allIgnoredTokens: {} });
    }
}
exports.TokensController = TokensController;
exports.default = TokensController;
//# sourceMappingURL=TokensController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/TokensController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/third-party/PhishingController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseController.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js","eth-phishing-detect/src/config.json":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-phishing-detect/src/config.json","eth-phishing-detect/src/detector":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-phishing-detect/src/detector.js","punycode/":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/punycode/punycode.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/third-party/PhishingController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PhishingController = void 0;
const punycode_1 = require("punycode/");
const config_json_1 = __importDefault(require("eth-phishing-detect/src/config.json"));
const detector_1 = __importDefault(require("eth-phishing-detect/src/detector"));
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
/**
 * Controller that passively polls on a set interval for approved and unapproved website origins
 */
class PhishingController extends BaseController_1.BaseController {
    /**
     * Creates a PhishingController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        this.configUrl = 'https://cdn.jsdelivr.net/gh/MetaMask/eth-phishing-detect@master/src/config.json';
        /**
         * Name of this controller used during composition
         */
        this.name = 'PhishingController';
        this.defaultConfig = { interval: 60 * 60 * 1000 };
        this.defaultState = {
            phishing: config_json_1.default,
            whitelist: [],
        };
        this.detector = new detector_1.default(this.defaultState.phishing);
        this.initialize();
        this.poll();
    }
    /**
     * Starts a new polling interval
     *
     * @param interval - Polling interval used to fetch new approval lists
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield util_1.safelyExecute(() => this.updatePhishingLists());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Determines if a given origin is unapproved
     *
     * @param origin - Domain origin of a website
     * @returns - True if the origin is an unapproved origin
     */
    test(origin) {
        const punycodeOrigin = punycode_1.toASCII(origin);
        if (this.state.whitelist.indexOf(punycodeOrigin) !== -1) {
            return false;
        }
        return this.detector.check(punycodeOrigin).result;
    }
    /**
     * Temporarily marks a given origin as approved
     */
    bypass(origin) {
        const punycodeOrigin = punycode_1.toASCII(origin);
        const { whitelist } = this.state;
        if (whitelist.indexOf(punycodeOrigin) !== -1) {
            return;
        }
        this.update({ whitelist: [...whitelist, punycodeOrigin] });
    }
    /**
     * Updates lists of approved and unapproved website origins
     *
     * @returns Promise resolving when this operation completes
     */
    updatePhishingLists() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.disabled) {
                return;
            }
            const phishingOpts = yield this.queryConfig(this.configUrl);
            if (phishingOpts) {
                this.detector = new detector_1.default(phishingOpts);
                this.update({
                    phishing: phishingOpts,
                });
            }
        });
    }
    queryConfig(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(input, { cache: 'no-cache' });
            switch (response.status) {
                case 200: {
                    return yield response.json();
                }
                case 304:
                case 403: {
                    return null;
                }
                default: {
                    throw new Error(`Fetch failed with status '${response.status}' for request '${input}'`);
                }
            }
        });
    }
}
exports.PhishingController = PhishingController;
exports.default = PhishingController;
//# sourceMappingURL=PhishingController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/third-party/PhishingController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/network/NetworkController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseController.js","../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/constants.js","async-mutex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-mutex/lib/index.js","eth-json-rpc-infura/src/createProvider":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-infura/src/createProvider.js","eth-query":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-query/index.js","web3-provider-engine/subproviders/provider":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/web3-provider-engine/subproviders/provider.js","web3-provider-engine/zero":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/web3-provider-engine/zero.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/network/NetworkController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkController = exports.NetworksChainId = void 0;
const eth_query_1 = __importDefault(require("eth-query"));
const provider_1 = __importDefault(require("web3-provider-engine/subproviders/provider"));
const createProvider_1 = __importDefault(require("eth-json-rpc-infura/src/createProvider"));
const zero_1 = __importDefault(require("web3-provider-engine/zero"));
const async_mutex_1 = require("async-mutex");
const BaseController_1 = require("../BaseController");
const constants_1 = require("../constants");
var NetworksChainId;
(function (NetworksChainId) {
    NetworksChainId["mainnet"] = "1";
    NetworksChainId["kovan"] = "42";
    NetworksChainId["rinkeby"] = "4";
    NetworksChainId["goerli"] = "5";
    NetworksChainId["ropsten"] = "3";
    NetworksChainId["localhost"] = "";
    NetworksChainId["rpc"] = "";
    NetworksChainId["optimism"] = "10";
    NetworksChainId["optimismTest"] = "69";
})(NetworksChainId = exports.NetworksChainId || (exports.NetworksChainId = {}));
const LOCALHOST_RPC_URL = 'http://localhost:8545';
/**
 * Controller that creates and manages an Ethereum network provider
 */
class NetworkController extends BaseController_1.BaseController {
    /**
     * Creates a NetworkController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        this.internalProviderConfig = {};
        this.mutex = new async_mutex_1.Mutex();
        /**
         * Name of this controller used during composition
         */
        this.name = 'NetworkController';
        this.defaultState = {
            network: 'loading',
            isCustomNetwork: false,
            provider: { type: constants_1.MAINNET, chainId: NetworksChainId.mainnet },
            properties: { isEIP1559Compatible: false },
        };
        this.initialize();
        this.getEIP1559Compatibility();
    }
    initializeProvider(type, rpcTarget, chainId, ticker, nickname) {
        this.update({ isCustomNetwork: this.getIsCustomNetwork(chainId) });
        switch (type) {
            case 'kovan':
            case constants_1.MAINNET:
            case 'rinkeby':
            case 'goerli':
            case 'optimism':
            case 'optimismTest':
            case 'ropsten':
                this.setupInfuraProvider(type);
                break;
            case 'localhost':
                this.setupStandardProvider(LOCALHOST_RPC_URL);
                break;
            case constants_1.RPC:
                rpcTarget &&
                    this.setupStandardProvider(rpcTarget, chainId, ticker, nickname);
                break;
            default:
                throw new Error(`Unrecognized network type: '${type}'`);
        }
    }
    refreshNetwork() {
        this.update({ network: 'loading', properties: {} });
        const { rpcTarget, type, chainId, ticker } = this.state.provider;
        this.initializeProvider(type, rpcTarget, chainId, ticker);
        this.lookupNetwork();
    }
    registerProvider() {
        this.provider.on('error', this.verifyNetwork.bind(this));
        this.ethQuery = new eth_query_1.default(this.provider);
    }
    setupInfuraProvider(type) {
        const infuraProvider = createProvider_1.default({
            network: type,
            projectId: this.config.infuraProjectId,
        });
        const infuraSubprovider = new provider_1.default(infuraProvider);
        const config = Object.assign(Object.assign({}, this.internalProviderConfig), {
            dataSubprovider: infuraSubprovider,
            engineParams: {
                blockTrackerProvider: infuraProvider,
                pollingInterval: 12000,
            },
        });
        this.updateProvider(zero_1.default(config));
    }
    getIsCustomNetwork(chainId) {
        return (chainId !== NetworksChainId.mainnet &&
            chainId !== NetworksChainId.kovan &&
            chainId !== NetworksChainId.rinkeby &&
            chainId !== NetworksChainId.goerli &&
            chainId !== NetworksChainId.ropsten &&
            chainId !== NetworksChainId.localhost);
    }
    setupStandardProvider(rpcTarget, chainId, ticker, nickname) {
        const config = Object.assign(Object.assign({}, this.internalProviderConfig), {
            chainId,
            engineParams: { pollingInterval: 12000 },
            nickname,
            rpcUrl: rpcTarget,
            ticker,
        });
        this.updateProvider(zero_1.default(config));
    }
    updateProvider(provider) {
        this.safelyStopProvider(this.provider);
        this.provider = provider;
        this.registerProvider();
    }
    safelyStopProvider(provider) {
        setTimeout(() => {
            provider === null || provider === void 0 ? void 0 : provider.stop();
        }, 500);
    }
    verifyNetwork() {
        this.state.network === 'loading' && this.lookupNetwork();
    }
    /**
     * Sets a new configuration for web3-provider-engine
     *
     * TODO: Replace this wth a method
     *
     * @param providerConfig - web3-provider-engine configuration
     */
    set providerConfig(providerConfig) {
        this.internalProviderConfig = providerConfig;
        const { type, rpcTarget, chainId, ticker, nickname } = this.state.provider;
        this.initializeProvider(type, rpcTarget, chainId, ticker, nickname);
        this.registerProvider();
        this.lookupNetwork();
    }
    get providerConfig() {
        throw new Error('Property only used for setting');
    }
    /**
     * Refreshes the current network code
     */
    lookupNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            if (!this.ethQuery || !this.ethQuery.sendAsync) {
                return;
            }
            const releaseLock = yield this.mutex.acquire();
            this.ethQuery.sendAsync({ method: 'net_version' }, (error, network) => {
                this.update({
                    network: error ? /* istanbul ignore next*/ 'loading' : network,
                });
                releaseLock();
            });
        });
    }
    /**
     * Convenience method to update provider network type settings
     *
     * @param type - Human readable network name
     */
    setProviderType(type) {
        const _a = this.state.provider, { rpcTarget, chainId, nickname } = _a, providerState = __rest(_a, ["rpcTarget", "chainId", "nickname"]);
        this.update({
            provider: Object.assign(Object.assign({}, providerState), { type, ticker: 'ETH', chainId: NetworksChainId[type] }),
        });
        this.refreshNetwork();
    }
    /**
     * Convenience method to update provider RPC settings
     *
     * @param rpcTarget - RPC endpoint URL
     * @param chainId - Network ID as per EIP-155
     * @param ticker? - Currency ticker
     * @param nickname? - Personalized network name
     */
    setRpcTarget(rpcTarget, chainId, ticker, nickname) {
        this.update({
            provider: Object.assign(Object.assign({}, this.state.provider), { type: constants_1.RPC, ticker, rpcTarget, chainId, nickname }),
        });
        this.refreshNetwork();
    }
    getEIP1559Compatibility() {
        var _a;
        const { properties = {} } = this.state;
        if (!properties.isEIP1559Compatible) {
            if (typeof ((_a = this.ethQuery) === null || _a === void 0 ? void 0 : _a.sendAsync) !== 'function') {
                return Promise.resolve(true);
            }
            return new Promise((resolve, reject) => {
                this.ethQuery.sendAsync({ method: 'eth_getBlockByNumber', params: ['latest', false] }, (error, block) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        const isEIP1559Compatible = typeof block.baseFeePerGas !== 'undefined';
                        if (properties.isEIP1559Compatible !== isEIP1559Compatible) {
                            this.update({
                                properties: {
                                    isEIP1559Compatible,
                                },
                            });
                        }
                        resolve(isEIP1559Compatible);
                    }
                });
            });
        }
        return Promise.resolve(true);
    }
}
exports.NetworkController = NetworkController;
exports.default = NetworkController;
//# sourceMappingURL=NetworkController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/network/NetworkController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/keyring/KeyringController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseController.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js","async-mutex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-mutex/lib/index.js","eth-keyring-controller":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-keyring-controller/index.js","eth-sig-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-sig-util/dist/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","ethereumjs-wallet":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethereumjs-wallet/dist/index.js","ethjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-util/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/keyring/KeyringController.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyringController = exports.SignTypedDataVersion = exports.AccountImportStrategy = exports.KeyringTypes = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const ethjs_util_1 = require("ethjs-util");
const eth_sig_util_1 = require("eth-sig-util");
const ethereumjs_wallet_1 = __importStar(require("ethereumjs-wallet"));
const eth_keyring_controller_1 = __importDefault(require("eth-keyring-controller"));
const async_mutex_1 = require("async-mutex");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const privates = new WeakMap();
/**
 * Available keyring types
 */
var KeyringTypes;
(function (KeyringTypes) {
    KeyringTypes["simple"] = "Simple Key Pair";
    KeyringTypes["hd"] = "HD Key Tree";
})(KeyringTypes = exports.KeyringTypes || (exports.KeyringTypes = {}));
/**
 * A strategy for importing an account
 */
var AccountImportStrategy;
(function (AccountImportStrategy) {
    AccountImportStrategy["privateKey"] = "privateKey";
    AccountImportStrategy["json"] = "json";
})(AccountImportStrategy = exports.AccountImportStrategy || (exports.AccountImportStrategy = {}));
/**
 * The `signTypedMessage` version
 * @see https://docs.metamask.io/guide/signing-data.html
 */
var SignTypedDataVersion;
(function (SignTypedDataVersion) {
    SignTypedDataVersion["V1"] = "V1";
    SignTypedDataVersion["V3"] = "V3";
    SignTypedDataVersion["V4"] = "V4";
})(SignTypedDataVersion = exports.SignTypedDataVersion || (exports.SignTypedDataVersion = {}));
/**
 * Controller responsible for establishing and managing user identity
 */
class KeyringController extends BaseController_1.BaseController {
    /**
     * Creates a KeyringController instance
     *
     * @param options
     * @param options.removeIdentity - Remove the identity with the given address
     * @param options.syncIdentities - Sync identities with the given list of addresses
     * @param options.updateIdentities - Generate an identity for each address given that doesn't already have an identity
     * @param options.setSelectedAddress - Set the selected address
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor({ removeIdentity, syncIdentities, updateIdentities, setSelectedAddress, }, config, state) {
        super(config, state);
        this.mutex = new async_mutex_1.Mutex();
        /**
         * Name of this controller used during composition
         */
        this.name = 'KeyringController';
        privates.set(this, {
            keyring: new eth_keyring_controller_1.default(Object.assign({ initState: state }, config)),
        });
        this.defaultState = Object.assign(Object.assign({}, privates.get(this).keyring.store.getState()), { keyrings: [] });
        this.removeIdentity = removeIdentity;
        this.syncIdentities = syncIdentities;
        this.updateIdentities = updateIdentities;
        this.setSelectedAddress = setSelectedAddress;
        this.initialize();
        this.fullUpdate();
    }
    /**
     * Adds a new account to the default (first) HD seed phrase keyring
     *
     * @returns - Promise resolving to current state when the account is added
     */
    addNewAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyring = privates
                .get(this)
                .keyring.getKeyringsByType('HD Key Tree')[0];
            /* istanbul ignore if */
            if (!primaryKeyring) {
                throw new Error('No HD keyring found');
            }
            const oldAccounts = yield privates.get(this).keyring.getAccounts();
            yield privates.get(this).keyring.addNewAccount(primaryKeyring);
            const newAccounts = yield privates.get(this).keyring.getAccounts();
            yield this.verifySeedPhrase();
            this.updateIdentities(newAccounts);
            newAccounts.forEach((selectedAddress) => {
                if (!oldAccounts.includes(selectedAddress)) {
                    this.setSelectedAddress(selectedAddress);
                }
            });
            return this.fullUpdate();
        });
    }
    /**
     * Adds a new account to the default (first) HD seed phrase keyring without updating identities in preferences
     *
     * @returns - Promise resolving to current state when the account is added
     */
    addNewAccountWithoutUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyring = privates
                .get(this)
                .keyring.getKeyringsByType('HD Key Tree')[0];
            /* istanbul ignore if */
            if (!primaryKeyring) {
                throw new Error('No HD keyring found');
            }
            yield privates.get(this).keyring.addNewAccount(primaryKeyring);
            yield this.verifySeedPhrase();
            return this.fullUpdate();
        });
    }
    /**
     * Effectively the same as creating a new keychain then populating it
     * using the given seed phrase
     *
     * @param password - Password to unlock keychain
     * @param seed - Seed phrase to restore keychain
     * @returns - Promise resolving to th restored keychain object
     */
    createNewVaultAndRestore(password, seed) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                this.updateIdentities([]);
                const vault = yield privates
                    .get(this)
                    .keyring.createNewVaultAndRestore(password, seed);
                this.updateIdentities(yield privates.get(this).keyring.getAccounts());
                this.fullUpdate();
                return vault;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Create a new primary keychain and wipe any previous keychains
     *
     * @param password - Password to unlock the new vault
     * @returns - Newly-created keychain object
     */
    createNewVaultAndKeychain(password) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                const vault = yield privates
                    .get(this)
                    .keyring.createNewVaultAndKeychain(password);
                this.updateIdentities(yield privates.get(this).keyring.getAccounts());
                this.fullUpdate();
                return vault;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Returns the status of the vault
     *
     * @returns - Boolean returning true if the vault is unlocked
     */
    isUnlocked() {
        return privates.get(this).keyring.memStore.getState().isUnlocked;
    }
    /**
     * Gets the seed phrase of the HD keyring
     *
     * @param password - Password of the keyring
     * @returns - Promise resolving to the seed phrase
     */
    exportSeedPhrase(password) {
        if (privates.get(this).keyring.password === password) {
            return privates.get(this).keyring.keyrings[0].mnemonic;
        }
        throw new Error('Invalid password');
    }
    /**
     * Gets the private key from the keyring controlling an address
     *
     * @param password - Password of the keyring
     * @param address - Address to export
     * @returns - Promise resolving to the private key for an address
     */
    exportAccount(password, address) {
        if (privates.get(this).keyring.password === password) {
            return privates.get(this).keyring.exportAccount(address);
        }
        throw new Error('Invalid password');
    }
    /**
     * Returns the public addresses of all accounts for the current keyring
     *
     * @returns - A promise resolving to an array of addresses
     */
    getAccounts() {
        return privates.get(this).keyring.getAccounts();
    }
    /**
     * Imports an account with the specified import strategy
     *
     * @param strategy - Import strategy name
     * @param args - Array of arguments to pass to the underlying stategy
     * @throws Will throw when passed an unrecognized strategy
     * @returns - Promise resolving to current state when the import is complete
     */
    importAccountWithStrategy(strategy, args) {
        return __awaiter(this, void 0, void 0, function* () {
            let privateKey;
            switch (strategy) {
                case 'privateKey':
                    const [importedKey] = args;
                    if (!importedKey) {
                        throw new Error('Cannot import an empty key.');
                    }
                    const prefixed = ethereumjs_util_1.addHexPrefix(importedKey);
                    /* istanbul ignore if */
                    if (!ethereumjs_util_1.isValidPrivate(ethereumjs_util_1.toBuffer(prefixed))) {
                        throw new Error('Cannot import invalid private key.');
                    }
                    privateKey = ethjs_util_1.stripHexPrefix(prefixed);
                    break;
                case 'json':
                    let wallet;
                    const [input, password] = args;
                    try {
                        wallet = ethereumjs_wallet_1.thirdparty.fromEtherWallet(input, password);
                    }
                    catch (e) {
                        wallet = wallet || (yield ethereumjs_wallet_1.default.fromV3(input, password, true));
                    }
                    privateKey = ethereumjs_util_1.bufferToHex(wallet.getPrivateKey());
                    break;
                default:
                    throw new Error(`Unexpected import strategy: '${strategy}'`);
            }
            const newKeyring = yield privates
                .get(this)
                .keyring.addNewKeyring(KeyringTypes.simple, [privateKey]);
            const accounts = yield newKeyring.getAccounts();
            const allAccounts = yield privates.get(this).keyring.getAccounts();
            this.updateIdentities(allAccounts);
            this.setSelectedAddress(accounts[0]);
            return this.fullUpdate();
        });
    }
    /**
     * Removes an account from keyring state
     *
     * @param address - Address of the account to remove
     * @returns - Promise resolving current state when this account removal completes
     */
    removeAccount(address) {
        return __awaiter(this, void 0, void 0, function* () {
            this.removeIdentity(address);
            yield privates.get(this).keyring.removeAccount(address);
            return this.fullUpdate();
        });
    }
    /**
     * Deallocates all secrets and locks the wallet
     *
     * @returns - Promise resolving to current state
     */
    setLocked() {
        return privates.get(this).keyring.setLocked();
    }
    /**
     * Signs message by calling down into a specific keyring
     *
     * @param messageParams - PersonalMessageParams object to sign
     * @returns - Promise resolving to a signed message string
     */
    signMessage(messageParams) {
        return privates.get(this).keyring.signMessage(messageParams);
    }
    /**
     * Signs personal message by calling down into a specific keyring
     *
     * @param messageParams - PersonalMessageParams object to sign
     * @returns - Promise resolving to a signed message string
     */
    signPersonalMessage(messageParams) {
        return privates.get(this).keyring.signPersonalMessage(messageParams);
    }
    /**
     * Signs typed message by calling down into a specific keyring
     *
     * @param messageParams - TypedMessageParams object to sign
     * @param version - Compatibility version EIP712
     * @throws Will throw when passed an unrecognized version
     * @returns - Promise resolving to a signed message string or an error if any
     */
    signTypedMessage(messageParams, version) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const address = eth_sig_util_1.normalize(messageParams.from);
                const { password } = privates.get(this).keyring;
                const privateKey = yield this.exportAccount(password, address);
                const privateKeyBuffer = ethereumjs_util_1.toBuffer(ethereumjs_util_1.addHexPrefix(privateKey));
                switch (version) {
                    case SignTypedDataVersion.V1:
                        // signTypedDataLegacy will throw if the data is invalid.
                        return eth_sig_util_1.signTypedDataLegacy(privateKeyBuffer, {
                            data: messageParams.data,
                        });
                    case SignTypedDataVersion.V3:
                        return eth_sig_util_1.signTypedData(privateKeyBuffer, {
                            data: JSON.parse(messageParams.data),
                        });
                    case SignTypedDataVersion.V4:
                        return eth_sig_util_1.signTypedData_v4(privateKeyBuffer, {
                            data: JSON.parse(messageParams.data),
                        });
                    default:
                        throw new Error(`Unexpected signTypedMessage version: '${version}'`);
                }
            }
            catch (error) {
                throw new Error(`Keyring Controller signTypedMessage: ${error}`);
            }
        });
    }
    /**
     * Signs a transaction by calling down into a specific keyring
     *
     * @param transaction - Transaction object to sign. Must be a `ethereumjs-tx` transaction instance.
     * @param from - Address to sign from, should be in keychain
     * @returns - Promise resolving to a signed transaction string
     */
    signTransaction(transaction, from) {
        return privates.get(this).keyring.signTransaction(transaction, from);
    }
    /**
     * Attempts to decrypt the current vault and load its keyrings
     *
     * @param password - Password to unlock the keychain
     * @returns - Promise resolving to the current state
     */
    submitPassword(password) {
        return __awaiter(this, void 0, void 0, function* () {
            yield privates.get(this).keyring.submitPassword(password);
            const accounts = yield privates.get(this).keyring.getAccounts();
            yield this.syncIdentities(accounts);
            return this.fullUpdate();
        });
    }
    /**
     * Adds new listener to be notified of state changes
     *
     * @param listener - Callback triggered when state changes
     */
    subscribe(listener) {
        privates.get(this).keyring.store.subscribe(listener);
    }
    /**
     * Removes existing listener from receiving state changes
     *
     * @param listener - Callback to remove
     * @returns - True if a listener is found and unsubscribed
     */
    unsubscribe(listener) {
        return privates.get(this).keyring.store.unsubscribe(listener);
    }
    /**
     * Adds new listener to be notified when the wallet is locked
     *
     * @param listener - Callback triggered when wallet is locked
     * @returns - EventEmitter if listener added
     */
    onLock(listener) {
        return privates.get(this).keyring.on('lock', listener);
    }
    /**
     * Adds new listener to be notified when the wallet is unlocked
     *
     * @param listener - Callback triggered when wallet is unlocked
     * @returns - EventEmitter if listener added
     */
    onUnlock(listener) {
        return privates.get(this).keyring.on('unlock', listener);
    }
    /**
     * Verifies the that the seed phrase restores the current keychain's accounts
     *
     * @returns - Promise resolving if the verification succeeds
     */
    verifySeedPhrase() {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyring = privates
                .get(this)
                .keyring.getKeyringsByType(KeyringTypes.hd)[0];
            /* istanbul ignore if */
            if (!primaryKeyring) {
                throw new Error('No HD keyring found.');
            }
            const seedWords = (yield primaryKeyring.serialize()).mnemonic;
            const accounts = yield primaryKeyring.getAccounts();
            /* istanbul ignore if */
            if (accounts.length === 0) {
                throw new Error('Cannot verify an empty keyring.');
            }
            const TestKeyringClass = privates
                .get(this)
                .keyring.getKeyringClassForType(KeyringTypes.hd);
            const testKeyring = new TestKeyringClass({
                mnemonic: seedWords,
                numberOfAccounts: accounts.length,
            });
            const testAccounts = yield testKeyring.getAccounts();
            /* istanbul ignore if */
            if (testAccounts.length !== accounts.length) {
                throw new Error('Seed phrase imported incorrect number of accounts.');
            }
            testAccounts.forEach((account, i) => {
                /* istanbul ignore if */
                if (account.toLowerCase() !== accounts[i].toLowerCase()) {
                    throw new Error('Seed phrase imported different accounts.');
                }
            });
            return seedWords;
        });
    }
    /**
     * Update keyrings in state and calls KeyringController fullUpdate method returning current state
     *
     * @returns - Promise resolving to current state
     */
    fullUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            const keyrings = yield Promise.all(privates.get(this).keyring.keyrings.map((keyring, index) => __awaiter(this, void 0, void 0, function* () {
                const keyringAccounts = yield keyring.getAccounts();
                const accounts = Array.isArray(keyringAccounts)
                    ? keyringAccounts.map((address) => util_1.toChecksumHexAddress(address))
                    : /* istanbul ignore next */ [];
                return {
                    accounts,
                    index,
                    type: keyring.type,
                };
            })));
            this.update({ keyrings: [...keyrings] });
            return privates.get(this).keyring.fullUpdate();
        });
    }
}
exports.KeyringController = KeyringController;
exports.default = KeyringController;
//# sourceMappingURL=KeyringController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/keyring/KeyringController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/transaction/TransactionController.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseController.js","../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/constants.js","../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js","@ethereumjs/common":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ethereumjs/common/dist.browser/index.js","@ethereumjs/tx":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ethereumjs/tx/dist.browser/index.js","async-mutex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-mutex/lib/index.js","eth-method-registry":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/eth-method-registry/index.js","eth-query":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-query/index.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/transaction/TransactionController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionController = exports.SPEED_UP_RATE = exports.CANCEL_RATE = exports.WalletDevice = exports.TransactionStatus = void 0;
const events_1 = require("events");
const ethereumjs_util_1 = require("ethereumjs-util");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const eth_method_registry_1 = __importDefault(require("eth-method-registry"));
const eth_query_1 = __importDefault(require("eth-query"));
const common_1 = __importDefault(require("@ethereumjs/common"));
const tx_1 = require("@ethereumjs/tx");
const uuid_1 = require("uuid");
const async_mutex_1 = require("async-mutex");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
const HARDFORK = 'london';
/**
 * The status of the transaction. Each status represents the state of the transaction internally
 * in the wallet. Some of these correspond with the state of the transaction on the network, but
 * some are wallet-specific.
 */
var TransactionStatus;
(function (TransactionStatus) {
    TransactionStatus["approved"] = "approved";
    TransactionStatus["cancelled"] = "cancelled";
    TransactionStatus["confirmed"] = "confirmed";
    TransactionStatus["failed"] = "failed";
    TransactionStatus["rejected"] = "rejected";
    TransactionStatus["signed"] = "signed";
    TransactionStatus["submitted"] = "submitted";
    TransactionStatus["unapproved"] = "unapproved";
})(TransactionStatus = exports.TransactionStatus || (exports.TransactionStatus = {}));
/**
 * Options for wallet device.
 */
var WalletDevice;
(function (WalletDevice) {
    WalletDevice["MM_MOBILE"] = "metamask_mobile";
    WalletDevice["MM_EXTENSION"] = "metamask_extension";
    WalletDevice["OTHER"] = "other_device";
})(WalletDevice = exports.WalletDevice || (exports.WalletDevice = {}));
/**
 * Multiplier used to determine a transaction's increased gas fee during cancellation
 */
exports.CANCEL_RATE = 1.5;
/**
 * Multiplier used to determine a transaction's increased gas fee during speed up
 */
exports.SPEED_UP_RATE = 1.1;
/**
 * Controller responsible for submitting and managing transactions
 */
class TransactionController extends BaseController_1.BaseController {
    /**
     * Creates a TransactionController instance
     *
     * @param options
     * @param options.getNetworkState - Gets the state of the network controller
     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes
     * @param options.getProvider - Returns a provider for the current network
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor({ getNetworkState, onNetworkStateChange, getProvider, }, config, state) {
        super(config, state);
        this.mutex = new async_mutex_1.Mutex();
        this.normalizeTokenTx = (txMeta, currentNetworkID, currentChainId) => {
            const time = parseInt(txMeta.timeStamp, 10) * 1000;
            const { to, from, gas, gasPrice, gasUsed, hash, contractAddress, tokenDecimal, tokenSymbol, value, } = txMeta;
            return {
                id: uuid_1.v1({ msecs: time }),
                isTransfer: true,
                networkID: currentNetworkID,
                chainId: currentChainId,
                status: TransactionStatus.confirmed,
                time,
                transaction: {
                    chainId: 1,
                    from,
                    gas,
                    gasPrice,
                    gasUsed,
                    to,
                    value,
                },
                transactionHash: hash,
                transferInformation: {
                    contractAddress,
                    decimals: Number(tokenDecimal),
                    symbol: tokenSymbol,
                },
                verifiedOnBlockchain: false,
            };
        };
        /**
         * EventEmitter instance used to listen to specific transactional events
         */
        this.hub = new events_1.EventEmitter();
        /**
         * Name of this controller used during composition
         */
        this.name = 'TransactionController';
        this.defaultConfig = {
            interval: 15000,
            txHistoryLimit: 40,
        };
        this.defaultState = {
            methodData: {},
            transactions: [],
        };
        this.initialize();
        const provider = getProvider();
        this.getNetworkState = getNetworkState;
        this.ethQuery = new eth_query_1.default(provider);
        this.registry = new eth_method_registry_1.default({ provider });
        onNetworkStateChange(() => {
            const newProvider = getProvider();
            this.ethQuery = new eth_query_1.default(newProvider);
            this.registry = new eth_method_registry_1.default({ provider: newProvider });
        });
        this.poll();
    }
    failTransaction(transactionMeta, error) {
        const newTransactionMeta = Object.assign(Object.assign({}, transactionMeta), { error, status: TransactionStatus.failed });
        this.updateTransaction(newTransactionMeta);
        this.hub.emit(`${transactionMeta.id}:finished`, newTransactionMeta);
    }
    registryLookup(fourBytePrefix) {
        return __awaiter(this, void 0, void 0, function* () {
            const registryMethod = yield this.registry.lookup(fourBytePrefix);
            const parsedRegistryMethod = this.registry.parse(registryMethod);
            return { registryMethod, parsedRegistryMethod };
        });
    }
    /**
     * Normalizes the transaction information from etherscan
     * to be compatible with the TransactionMeta interface
     *
     * @param txMeta - Object containing the transaction information
     * @param currentNetworkID - string representing the current network id
     * @param currentChainId - string representing the current chain id
     * @returns - TransactionMeta
     */
    normalizeTx(txMeta, currentNetworkID, currentChainId) {
        const time = parseInt(txMeta.timeStamp, 10) * 1000;
        const normalizedTransactionBase = {
            blockNumber: txMeta.blockNumber,
            id: uuid_1.v1({ msecs: time }),
            networkID: currentNetworkID,
            chainId: currentChainId,
            time,
            transaction: {
                data: txMeta.input,
                from: txMeta.from,
                gas: util_1.BNToHex(new ethereumjs_util_1.BN(txMeta.gas)),
                gasPrice: util_1.BNToHex(new ethereumjs_util_1.BN(txMeta.gasPrice)),
                gasUsed: util_1.BNToHex(new ethereumjs_util_1.BN(txMeta.gasUsed)),
                nonce: util_1.BNToHex(new ethereumjs_util_1.BN(txMeta.nonce)),
                to: txMeta.to,
                value: util_1.BNToHex(new ethereumjs_util_1.BN(txMeta.value)),
            },
            transactionHash: txMeta.hash,
            verifiedOnBlockchain: false,
        };
        /* istanbul ignore else */
        if (txMeta.isError === '0') {
            return Object.assign(Object.assign({}, normalizedTransactionBase), { status: TransactionStatus.confirmed });
        }
        /* istanbul ignore next */
        return Object.assign(Object.assign({}, normalizedTransactionBase), { error: new Error('Transaction failed'), status: TransactionStatus.failed });
    }
    /**
     * Starts a new polling interval
     *
     * @param interval - Polling interval used to fetch new transaction statuses
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield util_1.safelyExecute(() => this.queryTransactionStatuses());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Handle new method data request
     *
     * @param fourBytePrefix - String corresponding to method prefix
     * @returns - Promise resolving to method data object corresponding to signature prefix
     */
    handleMethodData(fourBytePrefix) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                const { methodData } = this.state;
                const knownMethod = Object.keys(methodData).find((knownFourBytePrefix) => fourBytePrefix === knownFourBytePrefix);
                if (knownMethod) {
                    return methodData[fourBytePrefix];
                }
                const registry = yield this.registryLookup(fourBytePrefix);
                this.update({
                    methodData: Object.assign(Object.assign({}, methodData), { [fourBytePrefix]: registry }),
                });
                return registry;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Add a new unapproved transaction to state. Parameters will be validated, a
     * unique transaction id will be generated, and gas and gasPrice will be calculated
     * if not provided. If A `<tx.id>:unapproved` hub event will be emitted once added.
     *
     * @param transaction - Transaction object to add
     * @param origin - Domain origin to append to the generated TransactionMeta
     * @param deviceConfirmedOn - enum to indicate what device the transaction was confirmed to append to the generated TransactionMeta
     * @returns - Object containing a promise resolving to the transaction hash if approved
     */
    addTransaction(transaction, origin, deviceConfirmedOn) {
        return __awaiter(this, void 0, void 0, function* () {
            const { provider, network } = this.getNetworkState();
            const { transactions } = this.state;
            transaction = util_1.normalizeTransaction(transaction);
            util_1.validateTransaction(transaction);
            const transactionMeta = {
                id: uuid_1.v1(),
                networkID: network,
                chainId: provider.chainId,
                origin,
                status: TransactionStatus.unapproved,
                time: Date.now(),
                transaction,
                deviceConfirmedOn,
                verifiedOnBlockchain: false,
            };
            try {
                const { gas } = yield this.estimateGas(transaction);
                transaction.gas = gas;
            }
            catch (error) {
                this.failTransaction(transactionMeta, error);
                return Promise.reject(error);
            }
            const result = new Promise((resolve, reject) => {
                this.hub.once(`${transactionMeta.id}:finished`, (meta) => {
                    switch (meta.status) {
                        case TransactionStatus.submitted:
                            return resolve(meta.transactionHash);
                        case TransactionStatus.rejected:
                            return reject(eth_rpc_errors_1.ethErrors.provider.userRejectedRequest('User rejected the transaction'));
                        case TransactionStatus.cancelled:
                            return reject(eth_rpc_errors_1.ethErrors.rpc.internal('User cancelled the transaction'));
                        case TransactionStatus.failed:
                            return reject(eth_rpc_errors_1.ethErrors.rpc.internal(meta.error.message));
                        /* istanbul ignore next */
                        default:
                            return reject(eth_rpc_errors_1.ethErrors.rpc.internal(`MetaMask Tx Signature: Unknown problem: ${JSON.stringify(meta)}`));
                    }
                });
            });
            transactions.push(transactionMeta);
            this.update({ transactions: this.trimTransactionsForState(transactions) });
            this.hub.emit(`unapprovedTransaction`, transactionMeta);
            return { result, transactionMeta };
        });
    }
    prepareUnsignedEthTx(txParams) {
        return tx_1.TransactionFactory.fromTxData(txParams, {
            common: this.getCommonConfiguration(),
            freeze: false,
        });
    }
    /**
     * @ethereumjs/tx uses @ethereumjs/common as a configuration tool for
     * specifying which chain, network, hardfork and EIPs to support for
     * a transaction. By referencing this configuration, and analyzing the fields
     * specified in txParams, @ethereumjs/tx is able to determine which EIP-2718
     * transaction type to use.
     * @returns {Common} common configuration object
     */
    getCommonConfiguration() {
        const { network: networkId, provider: { type: chain, chainId, nickname: name }, } = this.getNetworkState();
        if (chain !== constants_1.RPC) {
            return new common_1.default({ chain, hardfork: HARDFORK });
        }
        const customChainParams = {
            name,
            chainId: parseInt(chainId, undefined),
            networkId: parseInt(networkId, undefined),
        };
        return common_1.default.forCustomChain(constants_1.MAINNET, customChainParams, HARDFORK);
    }
    /**
     * Approves a transaction and updates it's status in state. If this is not a
     * retry transaction, a nonce will be generated. The transaction is signed
     * using the sign configuration property, then published to the blockchain.
     * A `<tx.id>:finished` hub event is fired after success or failure.
     *
     * @param transactionID - ID of the transaction to approve
     * @returns - Promise resolving when this operation completes
     */
    approveTransaction(transactionID) {
        return __awaiter(this, void 0, void 0, function* () {
            const { transactions } = this.state;
            const releaseLock = yield this.mutex.acquire();
            const { provider } = this.getNetworkState();
            const { chainId: currentChainId } = provider;
            const index = transactions.findIndex(({ id }) => transactionID === id);
            const transactionMeta = transactions[index];
            const { nonce } = transactionMeta.transaction;
            try {
                const { from } = transactionMeta.transaction;
                if (!this.sign) {
                    releaseLock();
                    this.failTransaction(transactionMeta, new Error('No sign method defined.'));
                    return;
                }
                else if (!currentChainId) {
                    releaseLock();
                    this.failTransaction(transactionMeta, new Error('No chainId defined.'));
                    return;
                }
                const chainId = parseInt(currentChainId, undefined);
                const { approved: status } = TransactionStatus;
                const txNonce = nonce ||
                    (yield util_1.query(this.ethQuery, 'getTransactionCount', [from, 'pending']));
                transactionMeta.status = status;
                transactionMeta.transaction.nonce = txNonce;
                transactionMeta.transaction.chainId = chainId;
                const baseTxParams = Object.assign(Object.assign({}, transactionMeta.transaction), { gasLimit: transactionMeta.transaction.gas, chainId, nonce: txNonce, status });
                const isEIP1559 = util_1.isEIP1559Transaction(transactionMeta.transaction);
                const txParams = isEIP1559
                    ? Object.assign(Object.assign({}, baseTxParams), { maxFeePerGas: transactionMeta.transaction.maxFeePerGas, maxPriorityFeePerGas: transactionMeta.transaction.maxPriorityFeePerGas, estimatedBaseFee: transactionMeta.transaction.estimatedBaseFee, 
                        // specify type 2 if maxFeePerGas and maxPriorityFeePerGas are set
                        type: 2 }) : baseTxParams;
                // delete gasPrice if maxFeePerGas and maxPriorityFeePerGas are set
                if (isEIP1559) {
                    delete txParams.gasPrice;
                }
                const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
                const signedTx = yield this.sign(unsignedEthTx, from);
                transactionMeta.status = TransactionStatus.signed;
                this.updateTransaction(transactionMeta);
                const rawTransaction = ethereumjs_util_1.bufferToHex(signedTx.serialize());
                transactionMeta.rawTransaction = rawTransaction;
                this.updateTransaction(transactionMeta);
                const transactionHash = yield util_1.query(this.ethQuery, 'sendRawTransaction', [
                    rawTransaction,
                ]);
                transactionMeta.transactionHash = transactionHash;
                transactionMeta.status = TransactionStatus.submitted;
                this.updateTransaction(transactionMeta);
                this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
            }
            catch (error) {
                this.failTransaction(transactionMeta, error);
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Cancels a transaction based on its ID by setting its status to "rejected"
     * and emitting a `<tx.id>:finished` hub event.
     *
     * @param transactionID - ID of the transaction to cancel
     */
    cancelTransaction(transactionID) {
        const transactionMeta = this.state.transactions.find(({ id }) => id === transactionID);
        if (!transactionMeta) {
            return;
        }
        transactionMeta.status = TransactionStatus.rejected;
        this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
        const transactions = this.state.transactions.filter(({ id }) => id !== transactionID);
        this.update({ transactions: this.trimTransactionsForState(transactions) });
    }
    /**
     * Attempts to cancel a transaction based on its ID by setting its status to "rejected"
     * and emitting a `<tx.id>:finished` hub event.
     *
     * @param transactionID - ID of the transaction to cancel
     */
    stopTransaction(transactionID, gasValues) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (gasValues) {
                util_1.validateGasValues(gasValues);
            }
            const transactionMeta = this.state.transactions.find(({ id }) => id === transactionID);
            if (!transactionMeta) {
                return;
            }
            if (!this.sign) {
                throw new Error('No sign method defined.');
            }
            // gasPrice (legacy non EIP1559)
            const minGasPrice = util_1.getIncreasedPriceFromExisting(transactionMeta.transaction.gasPrice, exports.CANCEL_RATE);
            const gasPriceFromValues = util_1.isGasPriceValue(gasValues) && gasValues.gasPrice;
            const newGasPrice = (gasPriceFromValues &&
                util_1.validateMinimumIncrease(gasPriceFromValues, minGasPrice)) ||
                minGasPrice;
            // maxFeePerGas (EIP1559)
            const existingMaxFeePerGas = (_a = transactionMeta.transaction) === null || _a === void 0 ? void 0 : _a.maxFeePerGas;
            const minMaxFeePerGas = util_1.getIncreasedPriceFromExisting(existingMaxFeePerGas, exports.CANCEL_RATE);
            const maxFeePerGasValues = util_1.isFeeMarketEIP1559Values(gasValues) && gasValues.maxFeePerGas;
            const newMaxFeePerGas = (maxFeePerGasValues &&
                util_1.validateMinimumIncrease(maxFeePerGasValues, minMaxFeePerGas)) ||
                (existingMaxFeePerGas && minMaxFeePerGas);
            // maxPriorityFeePerGas (EIP1559)
            const existingMaxPriorityFeePerGas = (_b = transactionMeta.transaction) === null || _b === void 0 ? void 0 : _b.maxPriorityFeePerGas;
            const minMaxPriorityFeePerGas = util_1.getIncreasedPriceFromExisting(existingMaxPriorityFeePerGas, exports.CANCEL_RATE);
            const maxPriorityFeePerGasValues = util_1.isFeeMarketEIP1559Values(gasValues) && gasValues.maxPriorityFeePerGas;
            const newMaxPriorityFeePerGas = (maxPriorityFeePerGasValues &&
                util_1.validateMinimumIncrease(maxPriorityFeePerGasValues, minMaxPriorityFeePerGas)) ||
                (existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas);
            const txParams = newMaxFeePerGas && newMaxPriorityFeePerGas
                ? {
                    from: transactionMeta.transaction.from,
                    gasLimit: transactionMeta.transaction.gas,
                    maxFeePerGas: newMaxFeePerGas,
                    maxPriorityFeePerGas: newMaxPriorityFeePerGas,
                    type: 2,
                    nonce: transactionMeta.transaction.nonce,
                    to: transactionMeta.transaction.from,
                    value: '0x0',
                }
                : {
                    from: transactionMeta.transaction.from,
                    gasLimit: transactionMeta.transaction.gas,
                    gasPrice: newGasPrice,
                    nonce: transactionMeta.transaction.nonce,
                    to: transactionMeta.transaction.from,
                    value: '0x0',
                };
            const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
            const signedTx = yield this.sign(unsignedEthTx, transactionMeta.transaction.from);
            const rawTransaction = ethereumjs_util_1.bufferToHex(signedTx.serialize());
            yield util_1.query(this.ethQuery, 'sendRawTransaction', [rawTransaction]);
            transactionMeta.status = TransactionStatus.cancelled;
            this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
        });
    }
    /**
     * Attemps to speed up a transaction increasing transaction gasPrice by ten percent
     *
     * @param transactionID - ID of the transaction to speed up
     */
    speedUpTransaction(transactionID, gasValues) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (gasValues) {
                util_1.validateGasValues(gasValues);
            }
            const transactionMeta = this.state.transactions.find(({ id }) => id === transactionID);
            /* istanbul ignore next */
            if (!transactionMeta) {
                return;
            }
            /* istanbul ignore next */
            if (!this.sign) {
                throw new Error('No sign method defined.');
            }
            const { transactions } = this.state;
            // gasPrice (legacy non EIP1559)
            const minGasPrice = util_1.getIncreasedPriceFromExisting(transactionMeta.transaction.gasPrice, exports.SPEED_UP_RATE);
            const gasPriceFromValues = util_1.isGasPriceValue(gasValues) && gasValues.gasPrice;
            const newGasPrice = (gasPriceFromValues &&
                util_1.validateMinimumIncrease(gasPriceFromValues, minGasPrice)) ||
                minGasPrice;
            // maxFeePerGas (EIP1559)
            const existingMaxFeePerGas = (_a = transactionMeta.transaction) === null || _a === void 0 ? void 0 : _a.maxFeePerGas;
            const minMaxFeePerGas = util_1.getIncreasedPriceFromExisting(existingMaxFeePerGas, exports.SPEED_UP_RATE);
            const maxFeePerGasValues = util_1.isFeeMarketEIP1559Values(gasValues) && gasValues.maxFeePerGas;
            const newMaxFeePerGas = (maxFeePerGasValues &&
                util_1.validateMinimumIncrease(maxFeePerGasValues, minMaxFeePerGas)) ||
                (existingMaxFeePerGas && minMaxFeePerGas);
            // maxPriorityFeePerGas (EIP1559)
            const existingMaxPriorityFeePerGas = (_b = transactionMeta.transaction) === null || _b === void 0 ? void 0 : _b.maxPriorityFeePerGas;
            const minMaxPriorityFeePerGas = util_1.getIncreasedPriceFromExisting(existingMaxPriorityFeePerGas, exports.SPEED_UP_RATE);
            const maxPriorityFeePerGasValues = util_1.isFeeMarketEIP1559Values(gasValues) && gasValues.maxPriorityFeePerGas;
            const newMaxPriorityFeePerGas = (maxPriorityFeePerGasValues &&
                util_1.validateMinimumIncrease(maxPriorityFeePerGasValues, minMaxPriorityFeePerGas)) ||
                (existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas);
            const txParams = newMaxFeePerGas && newMaxPriorityFeePerGas
                ? Object.assign(Object.assign({}, transactionMeta.transaction), { gasLimit: transactionMeta.transaction.gas, maxFeePerGas: newMaxFeePerGas, maxPriorityFeePerGas: newMaxPriorityFeePerGas, type: 2 }) : Object.assign(Object.assign({}, transactionMeta.transaction), { gasLimit: transactionMeta.transaction.gas, gasPrice: newGasPrice });
            const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
            const signedTx = yield this.sign(unsignedEthTx, transactionMeta.transaction.from);
            const rawTransaction = ethereumjs_util_1.bufferToHex(signedTx.serialize());
            const transactionHash = yield util_1.query(this.ethQuery, 'sendRawTransaction', [
                rawTransaction,
            ]);
            const baseTransactionMeta = Object.assign(Object.assign({}, transactionMeta), { id: uuid_1.v1(), time: Date.now(), transactionHash });
            const newTransactionMeta = newMaxFeePerGas && newMaxPriorityFeePerGas
                ? Object.assign(Object.assign({}, baseTransactionMeta), { transaction: Object.assign(Object.assign({}, transactionMeta.transaction), { maxFeePerGas: newMaxFeePerGas, maxPriorityFeePerGas: newMaxPriorityFeePerGas }) }) : Object.assign(Object.assign({}, baseTransactionMeta), { transaction: Object.assign(Object.assign({}, transactionMeta.transaction), { gasPrice: newGasPrice }) });
            transactions.push(newTransactionMeta);
            this.update({ transactions: this.trimTransactionsForState(transactions) });
            this.hub.emit(`${transactionMeta.id}:speedup`, newTransactionMeta);
        });
    }
    /**
     * Estimates required gas for a given transaction
     *
     * @param transaction - Transaction object to estimate gas for
     * @returns - Promise resolving to an object containing gas and gasPrice
     */
    estimateGas(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const estimatedTransaction = Object.assign({}, transaction);
            const { gas, gasPrice: providedGasPrice, to, value, data, } = estimatedTransaction;
            const gasPrice = typeof providedGasPrice === 'undefined'
                ? yield util_1.query(this.ethQuery, 'gasPrice')
                : providedGasPrice;
            const { isCustomNetwork } = this.getNetworkState();
            // 1. If gas is already defined on the transaction, use it
            if (typeof gas !== 'undefined') {
                return { gas, gasPrice };
            }
            const { gasLimit } = yield util_1.query(this.ethQuery, 'getBlockByNumber', [
                'latest',
                false,
            ]);
            // 2. If to is not defined or this is not a contract address, and there is no data use 0x5208 / 21000.
            // If the newtwork is a custom network then bypass this check and fetch 'estimateGas'.
            /* istanbul ignore next */
            const code = to ? yield util_1.query(this.ethQuery, 'getCode', [to]) : undefined;
            /* istanbul ignore next */
            if (!isCustomNetwork &&
                (!to || (to && !data && (!code || code === '0x')))) {
                return { gas: '0x5208', gasPrice };
            }
            // if data, should be hex string format
            estimatedTransaction.data = !data
                ? data
                : /* istanbul ignore next */ ethereumjs_util_1.addHexPrefix(data);
            // 3. If this is a contract address, safely estimate gas using RPC
            estimatedTransaction.value =
                typeof value === 'undefined' ? '0x0' : /* istanbul ignore next */ value;
            const gasLimitBN = util_1.hexToBN(gasLimit);
            estimatedTransaction.gas = util_1.BNToHex(util_1.fractionBN(gasLimitBN, 19, 20));
            const gasHex = yield util_1.query(this.ethQuery, 'estimateGas', [
                estimatedTransaction,
            ]);
            // 4. Pad estimated gas without exceeding the most recent block gasLimit. If the network is a
            // a custom network then return the eth_estimateGas value.
            const gasBN = util_1.hexToBN(gasHex);
            const maxGasBN = gasLimitBN.muln(0.9);
            const paddedGasBN = gasBN.muln(1.5);
            /* istanbul ignore next */
            if (gasBN.gt(maxGasBN) || isCustomNetwork) {
                return { gas: ethereumjs_util_1.addHexPrefix(gasHex), gasPrice };
            }
            /* istanbul ignore next */
            if (paddedGasBN.lt(maxGasBN)) {
                return { gas: ethereumjs_util_1.addHexPrefix(util_1.BNToHex(paddedGasBN)), gasPrice };
            }
            return { gas: ethereumjs_util_1.addHexPrefix(util_1.BNToHex(maxGasBN)), gasPrice };
        });
    }
    /**
     * Resiliently checks all submitted transactions on the blockchain
     * and verifies that it has been included in a block
     * when that happens, the tx status is updated to confirmed
     *
     * @returns - Promise resolving when this operation completes
     */
    queryTransactionStatuses() {
        return __awaiter(this, void 0, void 0, function* () {
            const { transactions } = this.state;
            const { provider, network: currentNetworkID } = this.getNetworkState();
            const { chainId: currentChainId } = provider;
            let gotUpdates = false;
            yield util_1.safelyExecute(() => Promise.all(transactions.map((meta, index) => __awaiter(this, void 0, void 0, function* () {
                // Using fallback to networkID only when there is no chainId present.
                // Should be removed when networkID is completely removed.
                const txBelongsToCurrentChain = meta.chainId === currentChainId ||
                    (!meta.chainId && meta.networkID === currentNetworkID);
                if (!meta.verifiedOnBlockchain && txBelongsToCurrentChain) {
                    const [reconciledTx, updateRequired,] = yield this.blockchainTransactionStateReconciler(meta);
                    if (updateRequired) {
                        transactions[index] = reconciledTx;
                        gotUpdates = updateRequired;
                    }
                }
            }))));
            /* istanbul ignore else */
            if (gotUpdates) {
                this.update({
                    transactions: this.trimTransactionsForState(transactions),
                });
            }
        });
    }
    /**
     * Updates an existing transaction in state
     *
     * @param transactionMeta - New transaction meta to store in state
     */
    updateTransaction(transactionMeta) {
        const { transactions } = this.state;
        transactionMeta.transaction = util_1.normalizeTransaction(transactionMeta.transaction);
        util_1.validateTransaction(transactionMeta.transaction);
        const index = transactions.findIndex(({ id }) => transactionMeta.id === id);
        transactions[index] = transactionMeta;
        this.update({ transactions: this.trimTransactionsForState(transactions) });
    }
    /**
     * Removes all transactions from state, optionally based on the current network
     *
     * @param ignoreNetwork - Ignores network
     */
    wipeTransactions(ignoreNetwork) {
        /* istanbul ignore next */
        if (ignoreNetwork) {
            this.update({ transactions: [] });
            return;
        }
        const { provider, network: currentNetworkID } = this.getNetworkState();
        const { chainId: currentChainId } = provider;
        const newTransactions = this.state.transactions.filter(({ networkID, chainId }) => {
            // Using fallback to networkID only when there is no chainId present. Should be removed when networkID is completely removed.
            const isCurrentNetwork = chainId === currentChainId ||
                (!chainId && networkID === currentNetworkID);
            return !isCurrentNetwork;
        });
        this.update({
            transactions: this.trimTransactionsForState(newTransactions),
        });
    }
    /**
     * Gets all transactions from etherscan for a specific address
     * optionally starting from a specific block
     *
     * @param address - string representing the address to fetch the transactions from
     * @param opt - Object containing optional data, fromBlock and Alethio API key
     * @returns - Promise resolving to an string containing the block number of the latest incoming transaction.
     */
    fetchAll(address, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            const { provider, network: currentNetworkID } = this.getNetworkState();
            const { chainId: currentChainId, type: networkType } = provider;
            const { transactions } = this.state;
            const supportedNetworkIds = ['1', '3', '4', '42'];
            /* istanbul ignore next */
            if (supportedNetworkIds.indexOf(currentNetworkID) === -1) {
                return undefined;
            }
            const [etherscanTxResponse, etherscanTokenResponse,] = yield util_1.handleTransactionFetch(networkType, address, this.config.txHistoryLimit, opt);
            const normalizedTxs = etherscanTxResponse.result.map((tx) => this.normalizeTx(tx, currentNetworkID, currentChainId));
            const normalizedTokenTxs = etherscanTokenResponse.result.map((tx) => this.normalizeTokenTx(tx, currentNetworkID, currentChainId));
            const [updateRequired, allTxs] = this.etherscanTransactionStateReconciler([...normalizedTxs, ...normalizedTokenTxs], transactions);
            allTxs.sort((a, b) => (a.time < b.time ? -1 : 1));
            let latestIncomingTxBlockNumber;
            allTxs.forEach((tx) => __awaiter(this, void 0, void 0, function* () {
                /* istanbul ignore next */
                if (
                // Using fallback to networkID only when there is no chainId present. Should be removed when networkID is completely removed.
                (tx.chainId === currentChainId ||
                    (!tx.chainId && tx.networkID === currentNetworkID)) &&
                    tx.transaction.to &&
                    tx.transaction.to.toLowerCase() === address.toLowerCase()) {
                    if (tx.blockNumber &&
                        (!latestIncomingTxBlockNumber ||
                            parseInt(latestIncomingTxBlockNumber, 10) <
                                parseInt(tx.blockNumber, 10))) {
                        latestIncomingTxBlockNumber = tx.blockNumber;
                    }
                }
                /* istanbul ignore else */
                if (tx.toSmartContract === undefined) {
                    // If not `to` is a contract deploy, if not `data` is send eth
                    if (tx.transaction.to &&
                        (!tx.transaction.data || tx.transaction.data !== '0x')) {
                        const code = yield util_1.query(this.ethQuery, 'getCode', [
                            tx.transaction.to,
                        ]);
                        tx.toSmartContract = util_1.isSmartContractCode(code);
                    }
                    else {
                        tx.toSmartContract = false;
                    }
                }
            }));
            // Update state only if new transactions were fetched or
            // the status or gas data of a transaction has changed
            if (updateRequired) {
                this.update({ transactions: this.trimTransactionsForState(allTxs) });
            }
            return latestIncomingTxBlockNumber;
        });
    }
    /**
     * Trim the amount of transactions that are set on the state. Checks
     * if the length of the tx history is longer then desired persistence
     * limit and then if it is removes the oldest confirmed or rejected tx.
     * Pending or unapproved transactions will not be removed by this
     * operation. For safety of presenting a fully functional transaction UI
     * representation, this function will not break apart transactions with the
     * same nonce, created on the same day, per network. Not accounting for transactions of the same
     * nonce, same day and network combo can result in confusing or broken experiences
     * in the UI. The transactions are then updated using the BaseController update.
     * @param transactions - array of transactions to be applied to the state
     * @returns Array of TransactionMeta with the desired length.
     */
    trimTransactionsForState(transactions) {
        const nonceNetworkSet = new Set();
        const txsToKeep = transactions.reverse().filter((tx) => {
            const { chainId, networkID, status, transaction, time } = tx;
            if (transaction) {
                const key = `${transaction.nonce}-${chainId !== null && chainId !== void 0 ? chainId : networkID}-${new Date(time).toDateString()}`;
                if (nonceNetworkSet.has(key)) {
                    return true;
                }
                else if (nonceNetworkSet.size < this.config.txHistoryLimit ||
                    !this.isFinalState(status)) {
                    nonceNetworkSet.add(key);
                    return true;
                }
            }
            return false;
        });
        txsToKeep.reverse();
        return txsToKeep;
    }
    /**
     * Method to determine if the transaction is in a final state
     * @param status - Transaction status
     * @returns boolean if the transaction is in a final state
     */
    isFinalState(status) {
        return (status === TransactionStatus.rejected ||
            status === TransactionStatus.confirmed ||
            status === TransactionStatus.failed ||
            status === TransactionStatus.cancelled);
    }
    /**
     * Method to verify the state of a transaction using the Blockchain as a source of truth
     * @param meta Local transaction to verify data in blockchain
     * @returns Promise with [TransactionMeta, boolean]
     */
    blockchainTransactionStateReconciler(meta) {
        return __awaiter(this, void 0, void 0, function* () {
            const { status, transactionHash } = meta;
            switch (status) {
                case TransactionStatus.confirmed:
                    const txReceipt = yield util_1.query(this.ethQuery, 'getTransactionReceipt', [
                        transactionHash,
                    ]);
                    if (!txReceipt) {
                        return [meta, false];
                    }
                    meta.verifiedOnBlockchain = true;
                    meta.transaction.gasUsed = txReceipt.gasUsed;
                    // According to the Web3 docs:
                    // TRUE if the transaction was successful, FALSE if the EVM reverted the transaction.
                    if (Number(txReceipt.status) === 0) {
                        const error = new Error('Transaction failed. The transaction was reversed');
                        this.failTransaction(meta, error);
                        return [meta, false];
                    }
                    return [meta, true];
                case TransactionStatus.submitted:
                    const txObj = yield util_1.query(this.ethQuery, 'getTransactionByHash', [
                        transactionHash,
                    ]);
                    if (!txObj) {
                        const receiptShowsFailedStatus = yield this.checkTxReceiptStatusIsFailed(transactionHash);
                        // Case the txObj is evaluated as false, a second check will
                        // determine if the tx failed or it is pending or confirmed
                        if (receiptShowsFailedStatus) {
                            const error = new Error('Transaction failed. The transaction was dropped or replaced by a new one');
                            this.failTransaction(meta, error);
                        }
                    }
                    /* istanbul ignore next */
                    if (txObj === null || txObj === void 0 ? void 0 : txObj.blockNumber) {
                        meta.status = TransactionStatus.confirmed;
                        this.hub.emit(`${meta.id}:confirmed`, meta);
                        return [meta, true];
                    }
                    return [meta, false];
                default:
                    return [meta, false];
            }
        });
    }
    /**
     * Method to check if a tx has failed according to their receipt
     * According to the Web3 docs:
     * TRUE if the transaction was successful, FALSE if the EVM reverted the transaction.
     * The receipt is not available for pending transactions and returns null.
     * @param txHash Transaction hash
     * @returns Promise<boolean> indicating if the transaction have failed
     */
    checkTxReceiptStatusIsFailed(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const txReceipt = yield util_1.query(this.ethQuery, 'getTransactionReceipt', [
                txHash,
            ]);
            if (!txReceipt) {
                // Transaction is pending
                return false;
            }
            return Number(txReceipt.status) === 0;
        });
    }
    /**
     * Method to verify the state of transactions using Etherscan as a source of truth
     * @param remoteTxs Array of transactions from remote source
     * @param localTxs Array of transactions stored locally
     * @returns [boolean, TransactionMeta[]]
     */
    etherscanTransactionStateReconciler(remoteTxs, localTxs) {
        const updatedTxs = this.getUpdatedTransactions(remoteTxs, localTxs);
        const newTxs = this.getNewTransactions(remoteTxs, localTxs);
        const updatedLocalTxs = localTxs.map((tx) => {
            const txIdx = updatedTxs.findIndex(({ transactionHash }) => transactionHash === tx.transactionHash);
            return txIdx === -1 ? tx : updatedTxs[txIdx];
        });
        const updateRequired = newTxs.length > 0 || updatedLocalTxs.length > 0;
        return [updateRequired, [...newTxs, ...updatedLocalTxs]];
    }
    /**
     * Get all transactions that are in the remote transactions array
     * but not in the local transactions array
     * @param remoteTxs - Array of transactions from remote source
     * @param localTxs - Array of transactions stored locally
     * @returns TransactionMeta array
     */
    getNewTransactions(remoteTxs, localTxs) {
        return remoteTxs.filter((tx) => {
            const alreadyInTransactions = localTxs.find(({ transactionHash }) => transactionHash === tx.transactionHash);
            return !alreadyInTransactions;
        });
    }
    /**
     * Get all the transactions that are locally outdated with respect
     * to a remote source (etherscan or blockchain). The returned array
     * contains the transactions with the updated data.
     * @param remoteTxs - Array of transactions from remote source
     * @param localTxs - Array of transactions stored locally
     * @returns TransactionMeta array
     */
    getUpdatedTransactions(remoteTxs, localTxs) {
        return remoteTxs.filter((remoteTx) => {
            const isTxOutdated = localTxs.find((localTx) => {
                return (remoteTx.transactionHash === localTx.transactionHash &&
                    this.isTransactionOutdated(remoteTx, localTx));
            });
            return isTxOutdated;
        });
    }
    /**
     * Verifies if a local transaction is outdated with respect to the remote transaction
     * @param remoteTx - Remote transaction from Etherscan
     * @param localTx - Local transaction
     * @returns boolean
     */
    isTransactionOutdated(remoteTx, localTx) {
        const statusOutdated = this.isStatusOutdated(remoteTx.transactionHash, localTx.transactionHash, remoteTx.status, localTx.status);
        const gasDataOutdated = this.isGasDataOutdated(remoteTx.transaction.gasUsed, localTx.transaction.gasUsed);
        return statusOutdated || gasDataOutdated;
    }
    /**
     * Verifies if the status of a local transaction is outdated with respect to the remote transaction
     * @param remoteTxHash - Remote transaction hash
     * @param localTxHash - Local transaction hash
     * @param remoteTxStatus - Remote transaction status
     * @param localTxStatus - Local transaction status
     * @returns boolean
     */
    isStatusOutdated(remoteTxHash, localTxHash, remoteTxStatus, localTxStatus) {
        return remoteTxHash === localTxHash && remoteTxStatus !== localTxStatus;
    }
    /**
     * Verifies if the gas data of a local transaction is outdated with respect to the remote transaction
     * @param remoteGasUsed - Remote gas used in the transaction
     * @param localGasUsed - Local gas used in the transaction
     * @returns boolean
     */
    isGasDataOutdated(remoteGasUsed, localGasUsed) {
        return remoteGasUsed !== localGasUsed;
    }
}
exports.TransactionController = TransactionController;
exports.default = TransactionController;
//# sourceMappingURL=TransactionController.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/transaction/TransactionController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-deep-equal/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-deep-equal/index.js
      return function (require, module, exports) {
'use strict';

// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};

      };
    };
  }
}, {package:"fast-deep-equal",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-deep-equal/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/nanoid/url-alphabet/index.cjs", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/nanoid/url-alphabet/index.cjs
      return function (require, module, exports) {
let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'
module.exports = { urlAlphabet }

      };
    };
  }
}, {package:"nanoid",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/nanoid/url-alphabet/index.cjs",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/asStream.js", {"stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/stream-browserify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/asStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeAsStream = void 0;
const stream_1 = require("stream");
class ObservableStoreStream extends stream_1.Duplex {
    constructor(obsStore) {
        super({
            // pass values, not serializations
            objectMode: true,
        });
        // dont buffer outgoing updates
        this.resume();
        // save handler so we can unsubscribe later
        this.handler = (state) => this.push(state);
        // subscribe to obsStore changes
        this.obsStore = obsStore;
        this.obsStore.subscribe(this.handler);
    }
    // emit current state on new destination
    pipe(dest, options) {
        const result = super.pipe(dest, options);
        dest.write(this.obsStore.getState());
        return result;
    }
    // write from incoming stream to state
    _write(chunk, _encoding, callback) {
        this.obsStore.putState(chunk);
        callback();
    }
    // noop - outgoing stream is asking us if we have data we arent giving it
    _read(_size) {
        return undefined;
    }
    // unsubscribe from event emitter
    _destroy(err, callback) {
        this.obsStore.unsubscribe(this.handler);
        super._destroy(err, callback);
    }
}
function storeAsStream(obsStore) {
    return new ObservableStoreStream(obsStore);
}
exports.storeAsStream = storeAsStream;
//# sourceMappingURL=asStream.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/asStream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/ComposedStore.js", {"./ObservableStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/ComposedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class ComposedStore extends ObservableStore_1.ObservableStore {
    constructor(children) {
        // Typecast: Preserve existing behavior
        super({});
        // subscribe to children
        this._children = children || {};
        Object.keys(this._children).forEach((childKey) => {
            const child = this._children[childKey];
            this._addChild(childKey, child);
        });
    }
    _addChild(childKey, child) {
        const updateFromChild = (childValue) => {
            const state = this.getState();
            state[childKey] = childValue;
            this.putState(state);
        };
        child.subscribe(updateFromChild);
        updateFromChild(child.getState());
    }
}
exports.ComposedStore = ComposedStore;
//# sourceMappingURL=ComposedStore.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/ComposedStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/MergedStore.js", {"./ObservableStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/MergedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class MergedStore extends ObservableStore_1.ObservableStore {
    constructor(children = []) {
        // Typecast: Preserve existing behavior
        super({});
        this._children = children;
        // subscribe to children
        children.forEach((child) => this._addChild(child));
        this._updateWholeState();
    }
    _addChild(child) {
        child.subscribe(() => this._updateWholeState());
    }
    _updateWholeState() {
        const childStates = this._children.map((child) => child.getState());
        // apply shallow merge over states
        const state = Object.assign({}, ...childStates);
        this.putState(state);
    }
}
exports.MergedStore = MergedStore;
//# sourceMappingURL=MergedStore.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/MergedStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/ObservableStore.js", {"@metamask/safe-event-emitter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/safe-event-emitter/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/ObservableStore.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableStore = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
class ObservableStore extends safe_event_emitter_1.default {
    constructor(initState) {
        super();
        if (initState) {
            this._state = initState;
        }
        else {
            // Typecast/default state: Preserve existing behavior
            this._state = {};
        }
    }
    // wrapper around internal getState
    getState() {
        return this._getState();
    }
    // wrapper around internal putState
    putState(newState) {
        this._putState(newState);
        this.emit('update', newState);
    }
    updateState(partialState) {
        // if non-null object, merge
        if (partialState && typeof partialState === 'object') {
            const state = this.getState();
            this.putState(Object.assign(Object.assign({}, state), partialState));
            // if not object, use new value
        }
        else {
            this.putState(partialState);
        }
    }
    // subscribe to changes
    subscribe(handler) {
        this.on('update', handler);
    }
    // unsubscribe to changes
    unsubscribe(handler) {
        this.removeListener('update', handler);
    }
    //
    // private
    //
    // read from persistence
    _getState() {
        return this._state;
    }
    // write to persistence
    _putState(newState) {
        this._state = newState;
    }
}
exports.ObservableStore = ObservableStore;
//# sourceMappingURL=ObservableStore.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/ObservableStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/transform.js", {"through2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/through2/through2.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/transform.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeTransformStream = void 0;
const through2_1 = require("through2");
function storeTransformStream(syncTransformFn) {
    return through2_1.obj((state, _encoding, cb) => {
        try {
            const newState = syncTransformFn(state);
            cb(null, newState);
            return undefined;
        }
        catch (err) {
            cb(err);
            return undefined;
        }
    });
}
exports.storeTransformStream = storeTransformStream;
//# sourceMappingURL=transform.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/transform.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-workers/dist/enums.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-workers/dist/enums.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.STREAM_NAMES = void 0;
// I have no idea why this rule fires but you do you eslint
// eslint-disable-next-line no-shadow
var STREAM_NAMES;
(function (STREAM_NAMES) {
    STREAM_NAMES["JSON_RPC"] = "jsonRpc";
    STREAM_NAMES["COMMAND"] = "command";
})(STREAM_NAMES = exports.STREAM_NAMES || (exports.STREAM_NAMES = {}));
//# sourceMappingURL=enums.js.map
      };
    };
  }
}, {package:"@metamask/snap-workers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-workers/dist/enums.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/json-rpc-middleware-stream/dist/createEngineStream.js", {"readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/readable-stream/readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/json-rpc-middleware-stream/dist/createEngineStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const readable_stream_1 = require("readable-stream");
/**
 * Takes a JsonRpcEngine and returns a Duplex stream wrapping it.
 *
 * @param opts - Options bag.
 * @param opts.engine - The JsonRpcEngine to wrap in a stream.
 * @returns The stream wrapping the engine.
 */
function createEngineStream(opts) {
    if (!opts || !opts.engine) {
        throw new Error('Missing engine parameter!');
    }
    const { engine } = opts;
    const stream = new readable_stream_1.Duplex({ objectMode: true, read, write });
    // forward notifications
    if (engine.on) {
        engine.on('notification', (message) => {
            stream.push(message);
        });
    }
    return stream;
    function read() {
        return undefined;
    }
    function write(req, _encoding, cb) {
        engine.handle(req, (_err, res) => {
            stream.push(res);
        });
        cb();
    }
}
exports.default = createEngineStream;
//# sourceMappingURL=createEngineStream.js.map
      };
    };
  }
}, {package:"json-rpc-middleware-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/json-rpc-middleware-stream/dist/createEngineStream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/json-rpc-middleware-stream/dist/createStreamMiddleware.js", {"@metamask/safe-event-emitter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/safe-event-emitter/index.js","readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/readable-stream/readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/json-rpc-middleware-stream/dist/createStreamMiddleware.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
const readable_stream_1 = require("readable-stream");
/**
 * Creates a JsonRpcEngine middleware with an associated Duplex stream and
 * EventEmitter. The middleware, and by extension stream, assume that middleware
 * parameters are properly formatted. No runtime type checking or validation is
 * performed.
 *
 * @returns The event emitter, middleware, and stream.
 */
function createStreamMiddleware() {
    const idMap = {};
    const stream = new readable_stream_1.Duplex({
        objectMode: true,
        read: readNoop,
        write: processMessage,
    });
    const events = new safe_event_emitter_1.default();
    const middleware = (req, res, next, end) => {
        // write req to stream
        stream.push(req);
        // register request on id map
        idMap[req.id] = { req, res, next, end };
    };
    return { events, middleware, stream };
    function readNoop() {
        return false;
    }
    function processMessage(res, _encoding, cb) {
        let err;
        try {
            const isNotification = !res.id;
            if (isNotification) {
                processNotification(res);
            }
            else {
                processResponse(res);
            }
        }
        catch (_err) {
            err = _err;
        }
        // continue processing stream
        cb(err);
    }
    function processResponse(res) {
        const context = idMap[res.id];
        if (!context) {
            throw new Error(`StreamMiddleware - Unknown response id "${res.id}"`);
        }
        delete idMap[res.id];
        // copy whole res onto original res
        Object.assign(context.res, res);
        // run callback on empty stack,
        // prevent internal stream-handler from catching errors
        setTimeout(context.end);
    }
    function processNotification(res) {
        events.emit('notification', res);
    }
}
exports.default = createStreamMiddleware;
//# sourceMappingURL=createStreamMiddleware.js.map
      };
    };
  }
}, {package:"json-rpc-middleware-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/json-rpc-middleware-stream/dist/createStreamMiddleware.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/object-multiplex/dist/ObjectMultiplex.js", {"./Substream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/object-multiplex/dist/Substream.js","end-of-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/end-of-stream/index.js","once":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/once/once.js","readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/readable-stream/readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/object-multiplex/dist/ObjectMultiplex.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectMultiplex = void 0;
const readable_stream_1 = require("readable-stream");
const end_of_stream_1 = __importDefault(require("end-of-stream"));
const once_1 = __importDefault(require("once"));
const Substream_1 = require("./Substream");
const IGNORE_SUBSTREAM = Symbol('IGNORE_SUBSTREAM');
class ObjectMultiplex extends readable_stream_1.Duplex {
    constructor(opts = {}) {
        super(Object.assign(Object.assign({}, opts), { objectMode: true }));
        this._substreams = {};
    }
    createStream(name) {
        // validate name
        if (!name) {
            throw new Error('ObjectMultiplex - name must not be empty');
        }
        if (this._substreams[name]) {
            throw new Error(`ObjectMultiplex - Substream for name "${name}" already exists`);
        }
        // create substream
        const substream = new Substream_1.Substream({ parent: this, name });
        this._substreams[name] = substream;
        // listen for parent stream to end
        anyStreamEnd(this, (_error) => {
            return substream.destroy(_error || undefined);
        });
        return substream;
    }
    // ignore streams (dont display orphaned data warning)
    ignoreStream(name) {
        // validate name
        if (!name) {
            throw new Error('ObjectMultiplex - name must not be empty');
        }
        if (this._substreams[name]) {
            throw new Error(`ObjectMultiplex - Substream for name "${name}" already exists`);
        }
        // set
        this._substreams[name] = IGNORE_SUBSTREAM;
    }
    _read() {
        return undefined;
    }
    _write(chunk, _encoding, callback) {
        const { name, data } = chunk;
        if (!name) {
            console.warn(`ObjectMultiplex - malformed chunk without name "${chunk}"`);
            return callback();
        }
        // get corresponding substream
        const substream = this._substreams[name];
        if (!substream) {
            console.warn(`ObjectMultiplex - orphaned data for stream "${name}"`);
            return callback();
        }
        // push data into substream
        if (substream !== IGNORE_SUBSTREAM) {
            substream.push(data);
        }
        return callback();
    }
}
exports.ObjectMultiplex = ObjectMultiplex;
// util
function anyStreamEnd(stream, _cb) {
    const cb = once_1.default(_cb);
    end_of_stream_1.default(stream, { readable: false }, cb);
    end_of_stream_1.default(stream, { writable: false }, cb);
}
//# sourceMappingURL=ObjectMultiplex.js.map
      };
    };
  }
}, {package:"@metamask/object-multiplex",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/object-multiplex/dist/ObjectMultiplex.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/WorkerParentPostMessageStream.js", {"./BasePostMessageStream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/BasePostMessageStream.js","./enums":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/enums.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/WorkerParentPostMessageStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerParentPostMessageStream = void 0;
const BasePostMessageStream_1 = require("./BasePostMessageStream");
const enums_1 = require("./enums");
/**
 * Parent-side dedicated web worker `postMessage` stream.
 */
class WorkerParentPostMessageStream extends BasePostMessageStream_1.BasePostMessageStream {
    /**
     * Creates a stream for communicating with a dedicated web worker.
     *
     * @param args.worker - The Web Worker to exchange messages with. The worker
     * must instantiate a WorkerPostMessageStream.
     */
    constructor({ worker }) {
        if (!worker) {
            throw new Error('Invalid input.');
        }
        super();
        this._target = enums_1.DEDICATED_WORKER_NAME;
        this._worker = worker;
        this._worker.onmessage = this._onMessage.bind(this);
        this._handshake();
    }
    _postMessage(data) {
        this._worker.postMessage({
            target: this._target,
            data,
        });
    }
    _onMessage(event) {
        const message = event.data;
        // validate message
        if (typeof message !== 'object' || !message.data) {
            return;
        }
        this._onData(message.data);
    }
    _destroy() {
        this._worker.onmessage = null;
        this._worker = null;
    }
}
exports.WorkerParentPostMessageStream = WorkerParentPostMessageStream;
//# sourceMappingURL=WorkerParentPostMessageStream.js.map
      };
    };
  }
}, {package:"@metamask/post-message-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/WorkerParentPostMessageStream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/WorkerPostMessageStream.js", {"./BasePostMessageStream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/BasePostMessageStream.js","./enums":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/enums.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/WorkerPostMessageStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerPostMessageStream = void 0;
/* istanbul ignore file */
// We ignore coverage for the entire file due to limits on our instrumentation,
// but it is in fact covered by our tests.
const BasePostMessageStream_1 = require("./BasePostMessageStream");
const enums_1 = require("./enums");
/**
 * Worker-side dedicated web worker `postMessage` stream.
 */
class WorkerPostMessageStream extends BasePostMessageStream_1.BasePostMessageStream {
    /**
     * Note: Designed for use in web workers only.
     *
     * Creates a stream for communicating with the window that created this web
     * worker.
     */
    constructor() {
        super();
        this._name = enums_1.DEDICATED_WORKER_NAME;
        self.onmessage = this._onMessage.bind(this);
        this._handshake();
    }
    _postMessage(data) {
        // Cast of self.postMessage due to usage of DOM lib
        self.postMessage({ data });
    }
    _onMessage(event) {
        const message = event.data;
        // validate message
        if (typeof message !== 'object' ||
            message.target !== this._name ||
            !message.data) {
            return;
        }
        this._onData(message.data);
    }
    // worker stream lifecycle assumed to be coterminous with global scope
    _destroy() {
        return undefined;
    }
}
exports.WorkerPostMessageStream = WorkerPostMessageStream;
//# sourceMappingURL=WorkerPostMessageStream.js.map
      };
    };
  }
}, {package:"@metamask/post-message-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/WorkerPostMessageStream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/WindowPostMessageStream.js", {"./BasePostMessageStream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/BasePostMessageStream.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/WindowPostMessageStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WindowPostMessageStream = void 0;
const BasePostMessageStream_1 = require("./BasePostMessageStream");
/**
 * Window.postMessage stream.
 */
class WindowPostMessageStream extends BasePostMessageStream_1.BasePostMessageStream {
    /**
     * Creates a stream for communicating with other streams across the same or
     * different window objects.
     *
     * @param args.name - The name of the stream. Used to differentiate between
     * multiple streams sharing the same window object.
     * @param args.target - The name of the stream to exchange messages with.
     * @param args.targetWindow - The window object of the target stream. Defaults
     * to `window`.
     */
    constructor({ name, target, targetWindow }) {
        if (!name || !target) {
            throw new Error('Invalid input.');
        }
        super();
        this._name = name;
        this._target = target;
        this._targetOrigin = targetWindow ? '*' : location.origin;
        this._targetWindow = targetWindow || window;
        this._onMessage = this._onMessage.bind(this);
        window.addEventListener('message', this._onMessage, false);
        this._handshake();
    }
    _postMessage(data) {
        this._targetWindow.postMessage({
            target: this._target,
            data,
        }, this._targetOrigin);
    }
    _onMessage(event) {
        const message = event.data;
        // validate message
        if ((this._targetOrigin !== '*' && event.origin !== this._targetOrigin) ||
            event.source !== this._targetWindow ||
            typeof message !== 'object' ||
            message.target !== this._name ||
            !message.data) {
            return;
        }
        this._onData(message.data);
    }
    _destroy() {
        window.removeEventListener('message', this._onMessage, false);
    }
}
exports.WindowPostMessageStream = WindowPostMessageStream;
//# sourceMappingURL=WindowPostMessageStream.js.map
      };
    };
  }
}, {package:"@metamask/post-message-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/WindowPostMessageStream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/through2/through2.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/readable-stream/readable-browser.js","util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/util/util.js","xtend":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/xtend/immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/through2/through2.js
      return function (require, module, exports) {
(function (process){(function (){
var Transform = require('readable-stream').Transform
  , inherits  = require('util').inherits
  , xtend     = require('xtend')

function DestroyableTransform(opts) {
  Transform.call(this, opts)
  this._destroyed = false
}

inherits(DestroyableTransform, Transform)

DestroyableTransform.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true
  
  var self = this
  process.nextTick(function() {
    if (err)
      self.emit('error', err)
    self.emit('close')
  })
}

// a noop _transform function
function noop (chunk, enc, callback) {
  callback(null, chunk)
}


// create a new export function, used by both the main export and
// the .ctor export, contains common logic for dealing with arguments
function through2 (construct) {
  return function (options, transform, flush) {
    if (typeof options == 'function') {
      flush     = transform
      transform = options
      options   = {}
    }

    if (typeof transform != 'function')
      transform = noop

    if (typeof flush != 'function')
      flush = null

    return construct(options, transform, flush)
  }
}


// main export, just make me a transform stream!
module.exports = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(options)

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})


// make me a reusable prototype that I can `new`, or implicitly `new`
// with a constructor call
module.exports.ctor = through2(function (options, transform, flush) {
  function Through2 (override) {
    if (!(this instanceof Through2))
      return new Through2(override)

    this.options = xtend(options, override)

    DestroyableTransform.call(this, this.options)
  }

  inherits(Through2, DestroyableTransform)

  Through2.prototype._transform = transform

  if (flush)
    Through2.prototype._flush = flush

  return Through2
})


module.exports.obj = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"through2",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/through2/through2.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@ethereumjs/tx/dist.browser/index.js", {"./transaction":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@ethereumjs/tx/dist.browser/transaction.js","./types":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@ethereumjs/tx/dist.browser/types.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@ethereumjs/tx/dist.browser/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
var transaction_1 = require("./transaction");
Object.defineProperty(exports, "Transaction", { enumerable: true, get: function () { return transaction_1.default; } });
__exportStar(require("./types"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@ethereumjs/tx",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@ethereumjs/tx/dist.browser/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/index.js", {"./bc-ur-registry-eth.cjs.development.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/bc-ur-registry-eth.cjs.development.js","./bc-ur-registry-eth.cjs.production.min.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/bc-ur-registry-eth.cjs.production.min.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/index.js
      return function (require, module, exports) {

'use strict'

if ("development" === 'production') {
  module.exports = require('./bc-ur-registry-eth.cjs.production.min.js')
} else {
  module.exports = require('./bc-ur-registry-eth.cjs.development.js')
}

      };
    };
  }
}, {package:"@keystonehq/bc-ur-registry-eth",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/superPropBase.js", {"./getPrototypeOf.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/getPrototypeOf.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/superPropBase.js
      return function (require, module, exports) {
var getPrototypeOf = require("./getPrototypeOf.js");

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;
module.exports["default"] = module.exports, module.exports.__esModule = true;
      };
    };
  }
}, {package:"@babel/runtime",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/superPropBase.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/src/util.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/store/src/util.js
      return function (require, module, exports) {
var assign = make_assign()
var create = make_create()
var trim = make_trim()
var Global = (typeof window !== 'undefined' ? window : global)

module.exports = {
	assign: assign,
	create: create,
	trim: trim,
	bind: bind,
	slice: slice,
	each: each,
	map: map,
	pluck: pluck,
	isList: isList,
	isFunction: isFunction,
	isObject: isObject,
	Global: Global
}

function make_assign() {
	if (Object.assign) {
		return Object.assign
	} else {
		return function shimAssign(obj, props1, props2, etc) {
			for (var i = 1; i < arguments.length; i++) {
				each(Object(arguments[i]), function(val, key) {
					obj[key] = val
				})
			}			
			return obj
		}
	}
}

function make_create() {
	if (Object.create) {
		return function create(obj, assignProps1, assignProps2, etc) {
			var assignArgsList = slice(arguments, 1)
			return assign.apply(this, [Object.create(obj)].concat(assignArgsList))
		}
	} else {
		function F() {} // eslint-disable-line no-inner-declarations
		return function create(obj, assignProps1, assignProps2, etc) {
			var assignArgsList = slice(arguments, 1)
			F.prototype = obj
			return assign.apply(this, [new F()].concat(assignArgsList))
		}
	}
}

function make_trim() {
	if (String.prototype.trim) {
		return function trim(str) {
			return String.prototype.trim.call(str)
		}
	} else {
		return function trim(str) {
			return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
		}
	}
}

function bind(obj, fn) {
	return function() {
		return fn.apply(obj, Array.prototype.slice.call(arguments, 0))
	}
}

function slice(arr, index) {
	return Array.prototype.slice.call(arr, index || 0)
}

function each(obj, fn) {
	pluck(obj, function(val, key) {
		fn(val, key)
		return false
	})
}

function map(obj, fn) {
	var res = (isList(obj) ? [] : {})
	pluck(obj, function(v, k) {
		res[k] = fn(v, k)
		return false
	})
	return res
}

function pluck(obj, fn) {
	if (isList(obj)) {
		for (var i=0; i<obj.length; i++) {
			if (fn(obj[i], i)) {
				return obj[i]
			}
		}
	} else {
		for (var key in obj) {
			if (obj.hasOwnProperty(key)) {
				if (fn(obj[key], key)) {
					return obj[key]
				}
			}
		}
	}
}

function isList(val) {
	return (val != null && typeof val != 'function' && typeof val.length == 'number')
}

function isFunction(val) {
	return val && {}.toString.call(val) === '[object Function]'
}

function isObject(val) {
	return val && {}.toString.call(val) === '[object Object]'
}

      };
    };
  }
}, {package:"store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/src/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/plugins/lib/json2.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/store/plugins/lib/json2.js
      return function (require, module, exports) {
/* eslint-disable */

//  json2.js
//  2016-10-28
//  Public Domain.
//  NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
//  See http://www.JSON.org/js.html
//  This code should be minified before deployment.
//  See http://javascript.crockford.com/jsmin.html

//  USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
//  NOT CONTROL.

//  This file creates a global JSON object containing two methods: stringify
//  and parse. This file provides the ES5 JSON capability to ES3 systems.
//  If a project might run on IE8 or earlier, then this file should be included.
//  This file does nothing on ES5 systems.

//      JSON.stringify(value, replacer, space)
//          value       any JavaScript value, usually an object or array.
//          replacer    an optional parameter that determines how object
//                      values are stringified for objects. It can be a
//                      function or an array of strings.
//          space       an optional parameter that specifies the indentation
//                      of nested structures. If it is omitted, the text will
//                      be packed without extra whitespace. If it is a number,
//                      it will specify the number of spaces to indent at each
//                      level. If it is a string (such as "\t" or "&nbsp;"),
//                      it contains the characters used to indent at each level.
//          This method produces a JSON text from a JavaScript value.
//          When an object value is found, if the object contains a toJSON
//          method, its toJSON method will be called and the result will be
//          stringified. A toJSON method does not serialize: it returns the
//          value represented by the name/value pair that should be serialized,
//          or undefined if nothing should be serialized. The toJSON method
//          will be passed the key associated with the value, and this will be
//          bound to the value.

//          For example, this would serialize Dates as ISO strings.

//              Date.prototype.toJSON = function (key) {
//                  function f(n) {
//                      // Format integers to have at least two digits.
//                      return (n < 10)
//                          ? "0" + n
//                          : n;
//                  }
//                  return this.getUTCFullYear()   + "-" +
//                       f(this.getUTCMonth() + 1) + "-" +
//                       f(this.getUTCDate())      + "T" +
//                       f(this.getUTCHours())     + ":" +
//                       f(this.getUTCMinutes())   + ":" +
//                       f(this.getUTCSeconds())   + "Z";
//              };

//          You can provide an optional replacer method. It will be passed the
//          key and value of each member, with this bound to the containing
//          object. The value that is returned from your method will be
//          serialized. If your method returns undefined, then the member will
//          be excluded from the serialization.

//          If the replacer parameter is an array of strings, then it will be
//          used to select the members to be serialized. It filters the results
//          such that only members with keys listed in the replacer array are
//          stringified.

//          Values that do not have JSON representations, such as undefined or
//          functions, will not be serialized. Such values in objects will be
//          dropped; in arrays they will be replaced with null. You can use
//          a replacer function to replace those with JSON values.

//          JSON.stringify(undefined) returns undefined.

//          The optional space parameter produces a stringification of the
//          value that is filled with line breaks and indentation to make it
//          easier to read.

//          If the space parameter is a non-empty string, then that string will
//          be used for indentation. If the space parameter is a number, then
//          the indentation will be that many spaces.

//          Example:

//          text = JSON.stringify(["e", {pluribus: "unum"}]);
//          // text is '["e",{"pluribus":"unum"}]'

//          text = JSON.stringify(["e", {pluribus: "unum"}], null, "\t");
//          // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

//          text = JSON.stringify([new Date()], function (key, value) {
//              return this[key] instanceof Date
//                  ? "Date(" + this[key] + ")"
//                  : value;
//          });
//          // text is '["Date(---current time---)"]'

//      JSON.parse(text, reviver)
//          This method parses a JSON text to produce an object or array.
//          It can throw a SyntaxError exception.

//          The optional reviver parameter is a function that can filter and
//          transform the results. It receives each of the keys and values,
//          and its return value is used instead of the original value.
//          If it returns what it received, then the structure is not modified.
//          If it returns undefined then the member is deleted.

//          Example:

//          // Parse the text. Values that look like ISO date strings will
//          // be converted to Date objects.

//          myData = JSON.parse(text, function (key, value) {
//              var a;
//              if (typeof value === "string") {
//                  a =
//   /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
//                  if (a) {
//                      return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
//                          +a[5], +a[6]));
//                  }
//              }
//              return value;
//          });

//          myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
//              var d;
//              if (typeof value === "string" &&
//                      value.slice(0, 5) === "Date(" &&
//                      value.slice(-1) === ")") {
//                  d = new Date(value.slice(5, -1));
//                  if (d) {
//                      return d;
//                  }
//              }
//              return value;
//          });

//  This is a reference implementation. You are free to copy, modify, or
//  redistribute.

/*jslint
    eval, for, this
*/

/*property
    JSON, apply, call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (typeof JSON !== "object") {
    JSON = {};
}

(function () {
    "use strict";

    var rx_one = /^[\],:{}\s]*$/;
    var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
    var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
    var rx_four = /(?:^|:|,)(?:\s*\[)+/g;
    var rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10
            ? "0" + n
            : n;
    }

    function this_value() {
        return this.valueOf();
    }

    if (typeof Date.prototype.toJSON !== "function") {

        Date.prototype.toJSON = function () {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear() + "-" +
                        f(this.getUTCMonth() + 1) + "-" +
                        f(this.getUTCDate()) + "T" +
                        f(this.getUTCHours()) + ":" +
                        f(this.getUTCMinutes()) + ":" +
                        f(this.getUTCSeconds()) + "Z"
                : null;
        };

        Boolean.prototype.toJSON = this_value;
        Number.prototype.toJSON = this_value;
        String.prototype.toJSON = this_value;
    }

    var gap;
    var indent;
    var meta;
    var rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        rx_escapable.lastIndex = 0;
        return rx_escapable.test(string)
            ? "\"" + string.replace(rx_escapable, function (a) {
                var c = meta[a];
                return typeof c === "string"
                    ? c
                    : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
            }) + "\""
            : "\"" + string + "\"";
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i;          // The loop counter.
        var k;          // The member key.
        var v;          // The member value.
        var length;
        var mind = gap;
        var partial;
        var value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === "object" &&
                typeof value.toJSON === "function") {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === "function") {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case "string":
            return quote(value);

        case "number":

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value)
                ? String(value)
                : "null";

        case "boolean":
        case "null":

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce "null". The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is "object", we might be dealing with an object or an array or
// null.

        case "object":

// Due to a specification blunder in ECMAScript, typeof null is "object",
// so watch out for that case.

            if (!value) {
                return "null";
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === "[object Array]") {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || "null";
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? "[]"
                    : gap
                        ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]"
                        : "[" + partial.join(",") + "]";
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === "object") {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === "string") {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (
                                gap
                                    ? ": "
                                    : ":"
                            ) + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (
                                gap
                                    ? ": "
                                    : ":"
                            ) + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? "{}"
                : gap
                    ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}"
                    : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== "function") {
        meta = {    // table of character substitutions
            "\b": "\\b",
            "\t": "\\t",
            "\n": "\\n",
            "\f": "\\f",
            "\r": "\\r",
            "\"": "\\\"",
            "\\": "\\\\"
        };
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = "";
            indent = "";

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === "number") {
                for (i = 0; i < space; i += 1) {
                    indent += " ";
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === "string") {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== "function" &&
                    (typeof replacer !== "object" ||
                    typeof replacer.length !== "number")) {
                throw new Error("JSON.stringify");
            }

// Make a fake root object containing our value under the key of "".
// Return the result of stringifying the value.

            return str("", {"": value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== "function") {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k;
                var v;
                var value = holder[key];
                if (value && typeof value === "object") {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            rx_dangerous.lastIndex = 0;
            if (rx_dangerous.test(text)) {
                text = text.replace(rx_dangerous, function (a) {
                    return "\\u" +
                            ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with "()" and "new"
// because they can cause invocation, and "=" because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with "@" (a non-JSON character). Second, we
// replace all simple value tokens with "]" characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or "]" or
// "," or ":" or "{" or "}". If that is so, then the text is safe for eval.

            if (
                rx_one.test(
                    text
                        .replace(rx_two, "@")
                        .replace(rx_three, "]")
                        .replace(rx_four, "")
                )
            ) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The "{" operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = (0,eval)("(" + text + ")");

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return (typeof reviver === "function")
                    ? walk({"": j}, "")
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError("JSON.parse");
        };
    }
}());
      };
    };
  }
}, {package:"store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/plugins/lib/json2.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/memoryStorage.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/memoryStorage.js
      return function (require, module, exports) {
// memoryStorage is a useful last fallback to ensure that the store
// is functions (meaning store.get(), store.set(), etc will all function).
// However, stored values will not persist when the browser navigates to
// a new page or reloads the current page.

module.exports = {
	name: 'memoryStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var memoryStorage = {}

function read(key) {
	return memoryStorage[key]
}

function write(key, data) {
	memoryStorage[key] = data
}

function each(callback) {
	for (var key in memoryStorage) {
		if (memoryStorage.hasOwnProperty(key)) {
			callback(memoryStorage[key], key)
		}
	}
}

function remove(key) {
	delete memoryStorage[key]
}

function clearAll(key) {
	memoryStorage = {}
}

      };
    };
  }
}, {package:"store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/memoryStorage.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/oldFF-globalStorage.js", {"../src/util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/src/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/oldFF-globalStorage.js
      return function (require, module, exports) {
// oldFF-globalStorage provides storage for Firefox
// versions 6 and 7, where no localStorage, etc
// is available.

var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'oldFF-globalStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var globalStorage = Global.globalStorage

function read(key) {
	return globalStorage[key]
}

function write(key, data) {
	globalStorage[key] = data
}

function each(fn) {
	for (var i = globalStorage.length - 1; i >= 0; i--) {
		var key = globalStorage.key(i)
		fn(globalStorage[key], key)
	}
}

function remove(key) {
	return globalStorage.removeItem(key)
}

function clearAll() {
	each(function(key, _) {
		delete globalStorage[key]
	})
}

      };
    };
  }
}, {package:"store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/oldFF-globalStorage.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/oldIE-userDataStorage.js", {"../src/util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/src/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/oldIE-userDataStorage.js
      return function (require, module, exports) {
// oldIE-userDataStorage provides storage for Internet Explorer
// versions 6 and 7, where no localStorage, sessionStorage, etc
// is available.

var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'oldIE-userDataStorage',
	write: write,
	read: read,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var storageName = 'storejs'
var doc = Global.document
var _withStorageEl = _makeIEStorageElFunction()
var disable = (Global.navigator ? Global.navigator.userAgent : '').match(/ (MSIE 8|MSIE 9|MSIE 10)\./) // MSIE 9.x, MSIE 10.x

function write(unfixedKey, data) {
	if (disable) { return }
	var fixedKey = fixKey(unfixedKey)
	_withStorageEl(function(storageEl) {
		storageEl.setAttribute(fixedKey, data)
		storageEl.save(storageName)
	})
}

function read(unfixedKey) {
	if (disable) { return }
	var fixedKey = fixKey(unfixedKey)
	var res = null
	_withStorageEl(function(storageEl) {
		res = storageEl.getAttribute(fixedKey)
	})
	return res
}

function each(callback) {
	_withStorageEl(function(storageEl) {
		var attributes = storageEl.XMLDocument.documentElement.attributes
		for (var i=attributes.length-1; i>=0; i--) {
			var attr = attributes[i]
			callback(storageEl.getAttribute(attr.name), attr.name)
		}
	})
}

function remove(unfixedKey) {
	var fixedKey = fixKey(unfixedKey)
	_withStorageEl(function(storageEl) {
		storageEl.removeAttribute(fixedKey)
		storageEl.save(storageName)
	})
}

function clearAll() {
	_withStorageEl(function(storageEl) {
		var attributes = storageEl.XMLDocument.documentElement.attributes
		storageEl.load(storageName)
		for (var i=attributes.length-1; i>=0; i--) {
			storageEl.removeAttribute(attributes[i].name)
		}
		storageEl.save(storageName)
	})
}

// Helpers
//////////

// In IE7, keys cannot start with a digit or contain certain chars.
// See https://github.com/marcuswestin/store.js/issues/40
// See https://github.com/marcuswestin/store.js/issues/83
var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g")
function fixKey(key) {
	return key.replace(/^\d/, '___$&').replace(forbiddenCharsRegex, '___')
}

function _makeIEStorageElFunction() {
	if (!doc || !doc.documentElement || !doc.documentElement.addBehavior) {
		return null
	}
	var scriptTag = 'script',
		storageOwner,
		storageContainer,
		storageEl

	// Since #userData storage applies only to specific paths, we need to
	// somehow link our data to a specific path.  We choose /favicon.ico
	// as a pretty safe option, since all browsers already make a request to
	// this URL anyway and being a 404 will not hurt us here.  We wrap an
	// iframe pointing to the favicon in an ActiveXObject(htmlfile) object
	// (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
	// since the iframe access rules appear to allow direct access and
	// manipulation of the document element, even for a 404 page.  This
	// document can be used instead of the current document (which would
	// have been limited to the current path) to perform #userData storage.
	try {
		/* global ActiveXObject */
		storageContainer = new ActiveXObject('htmlfile')
		storageContainer.open()
		storageContainer.write('<'+scriptTag+'>document.w=window</'+scriptTag+'><iframe src="/favicon.ico"></iframe>')
		storageContainer.close()
		storageOwner = storageContainer.w.frames[0].document
		storageEl = storageOwner.createElement('div')
	} catch(e) {
		// somehow ActiveXObject instantiation failed (perhaps some special
		// security settings or otherwse), fall back to per-path storage
		storageEl = doc.createElement('div')
		storageOwner = doc.body
	}

	return function(storeFunction) {
		var args = [].slice.call(arguments, 0)
		args.unshift(storageEl)
		// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
		// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
		storageOwner.appendChild(storageEl)
		storageEl.addBehavior('#default#userData')
		storageEl.load(storageName)
		storeFunction.apply(this, args)
		storageOwner.removeChild(storageEl)
		return
	}
}

      };
    };
  }
}, {package:"store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/oldIE-userDataStorage.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/localStorage.js", {"../src/util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/src/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/localStorage.js
      return function (require, module, exports) {
var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'localStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

function localStorage() {
	return Global.localStorage
}

function read(key) {
	return localStorage().getItem(key)
}

function write(key, data) {
	return localStorage().setItem(key, data)
}

function each(fn) {
	for (var i = localStorage().length - 1; i >= 0; i--) {
		var key = localStorage().key(i)
		fn(read(key), key)
	}
}

function remove(key) {
	return localStorage().removeItem(key)
}

function clearAll() {
	return localStorage().clear()
}

      };
    };
  }
}, {package:"store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/localStorage.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/cookieStorage.js", {"../src/util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/src/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/cookieStorage.js
      return function (require, module, exports) {
// cookieStorage is useful Safari private browser mode, where localStorage
// doesn't work but cookies do. This implementation is adopted from
// https://developer.mozilla.org/en-US/docs/Web/API/Storage/LocalStorage

var util = require('../src/util')
var Global = util.Global
var trim = util.trim

module.exports = {
	name: 'cookieStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var doc = Global.document

function read(key) {
	if (!key || !_has(key)) { return null }
	var regexpStr = "(?:^|.*;\\s*)" +
		escape(key).replace(/[\-\.\+\*]/g, "\\$&") +
		"\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*"
	return unescape(doc.cookie.replace(new RegExp(regexpStr), "$1"))
}

function each(callback) {
	var cookies = doc.cookie.split(/; ?/g)
	for (var i = cookies.length - 1; i >= 0; i--) {
		if (!trim(cookies[i])) {
			continue
		}
		var kvp = cookies[i].split('=')
		var key = unescape(kvp[0])
		var val = unescape(kvp[1])
		callback(val, key)
	}
}

function write(key, data) {
	if(!key) { return }
	doc.cookie = escape(key) + "=" + escape(data) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/"
}

function remove(key) {
	if (!key || !_has(key)) {
		return
	}
	doc.cookie = escape(key) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/"
}

function clearAll() {
	each(function(_, key) {
		remove(key)
	})
}

function _has(key) {
	return (new RegExp("(?:^|;\\s*)" + escape(key).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(doc.cookie)
}

      };
    };
  }
}, {package:"store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/cookieStorage.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/sessionStorage.js", {"../src/util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/src/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/sessionStorage.js
      return function (require, module, exports) {
var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'sessionStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll
}

function sessionStorage() {
	return Global.sessionStorage
}

function read(key) {
	return sessionStorage().getItem(key)
}

function write(key, data) {
	return sessionStorage().setItem(key, data)
}

function each(fn) {
	for (var i = sessionStorage().length - 1; i >= 0; i--) {
		var key = sessionStorage().key(i)
		fn(read(key), key)
	}
}

function remove(key) {
	return sessionStorage().removeItem(key)
}

function clearAll() {
	return sessionStorage().clear()
}

      };
    };
  }
}, {package:"store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/sessionStorage.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/https-did-resolver/lib/register.js", {"did-resolver":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-resolver/lib/resolver.js","xmlhttprequest":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/https-did-resolver/lib/register.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var did_resolver_1 = require("did-resolver");
var DOC_PATH = '/.well-known/did.json';
function get(url) {
    return new Promise(function (resolve, reject) {
        // declare XMLHttpRequest in here so it can be mocked for tests
        var XMLHttpRequest = typeof window !== 'undefined'
            ? window.XMLHttpRequest
            : require('xmlhttprequest').XMLHttpRequest;
        var request = new XMLHttpRequest();
        request.open('GET', url);
        request.onreadystatechange = function () {
            if (!request || request.readyState !== 4)
                return;
            if (request.status === 200) {
                resolve(request.responseText);
            }
            else {
                reject(new Error(("Invalid http response status " + request.status + " " + request.responseText).trim()));
            }
        };
        request.setRequestHeader('accept', 'application/json');
        request.send();
    });
}
function register() {
    function resolve(did, parsed) {
        return __awaiter(this, void 0, void 0, function () {
            var url, response, error_1, data, hasContext, docIdMatchesDid, docHasPublicKey;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = "https://" + parsed.id + DOC_PATH;
                        response = null;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, get(url)];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        throw new Error("DID must resolve to a valid https URL: " + error_1.message);
                    case 4:
                        data = null;
                        try {
                            data = JSON.parse(response);
                        }
                        catch (error) {
                            throw new Error('DID must resolve to a JSON document');
                        }
                        hasContext = data['@context'] === 'https://w3id.org/did/v1';
                        if (!hasContext)
                            throw new Error('DID document missing context');
                        docIdMatchesDid = data.id === did;
                        if (!docIdMatchesDid)
                            throw new Error('DID document id does not match requested did');
                        docHasPublicKey = Array.isArray(data.publicKey) && data.publicKey.length > 0;
                        if (!docHasPublicKey)
                            throw new Error('DID document has no public keys');
                        return [2 /*return*/, data];
                }
            });
        });
    }
    did_resolver_1.registerMethod('https', resolve);
}
exports.default = register;
//# sourceMappingURL=register.js.map
      };
    };
  }
}, {package:"https-did-resolver",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/https-did-resolver/lib/register.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/muport-did-resolver/lib/register.js", {"@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js","did-resolver":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-resolver/lib/resolver.js","node-fetch":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-fetch/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/muport-did-resolver/lib/register.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _didResolver = require("did-resolver");

var _nodeFetch = _interopRequireDefault(require("node-fetch"));

var INFURA = 'https://ipfs.infura.io/ipfs/';

function register(ipfs) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  function resolve(_x, _x2) {
    return _resolve.apply(this, arguments);
  }

  function _resolve() {
    _resolve = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee(did, parsed) {
      var doc;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return fetchMuPortDoc(ipfs, parsed.id);

            case 2:
              doc = _context.sent;
              return _context.abrupt("return", wrapDocument(did, doc));

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _resolve.apply(this, arguments);
  }

  (0, _didResolver.registerMethod)('muport', resolve);
}

function fetchMuPortDoc(_x3, _x4) {
  return _fetchMuPortDoc.apply(this, arguments);
}

function _fetchMuPortDoc() {
  _fetchMuPortDoc = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee2(ipfs, ipfsHash) {
    var doc;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;

            if (!ipfs) {
              _context2.next = 9;
              break;
            }

            _context2.t1 = JSON;
            _context2.next = 5;
            return ipfs.cat(ipfsHash);

          case 5:
            _context2.t2 = _context2.sent;
            _context2.t0 = _context2.t1.parse.call(_context2.t1, _context2.t2);
            _context2.next = 12;
            break;

          case 9:
            _context2.next = 11;
            return httpFetch(ipfsHash);

          case 11:
            _context2.t0 = _context2.sent;

          case 12:
            doc = _context2.t0;
            _context2.next = 17;
            break;

          case 15:
            _context2.prev = 15;
            _context2.t3 = _context2["catch"](0);

          case 17:
            if (!(!doc || doc.version !== 1 || !doc.signingKey || !doc.managementKey || !doc.asymEncryptionKey)) {
              _context2.next = 20;
              break;
            }

            try {
              if (ipfs) ipfs.pin.rm(ipfsHash);
            } catch (e) {}

            throw new Error('Invalid muport did');

          case 20:
            return _context2.abrupt("return", doc);

          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[0, 15]]);
  }));
  return _fetchMuPortDoc.apply(this, arguments);
}

function httpFetch(_x5) {
  return _httpFetch.apply(this, arguments);
}

function _httpFetch() {
  _httpFetch = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee3(cid) {
    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return (0, _nodeFetch["default"])(INFURA + cid);

          case 2:
            return _context3.abrupt("return", _context3.sent.json());

          case 3:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _httpFetch.apply(this, arguments);
}

function wrapDocument(did, muportDocument) {
  var doc = {
    "@context": "https://w3id.org/did/v1",
    "id": did,
    "publicKey": [{
      "id": did + "#signingKey",
      "type": "Secp256k1VerificationKey2018",
      "owner": did,
      "publicKeyHex": muportDocument.signingKey
    }, {
      "id": did + "#managementKey",
      "type": "Secp256k1VerificationKey2018",
      "owner": did
    }, {
      "id": did + "#encryptionKey",
      "type": "Curve25519EncryptionPublicKey",
      "owner": did,
      "publicKeyBase64": muportDocument.asymEncryptionKey
    }],
    "authentication": [{
      "type": "Secp256k1SignatureAuthentication2018",
      "publicKey": did + "#signingKey"
    }],
    "muportData": {}
  };

  if (muportDocument.managementKey.length === 42) {
    doc.publicKey[1].ethereumAddress = muportDocument.managementKey;
  } else {
    doc.publicKey[1].publicKeyHex = muportDocument.managementKey;
  }

  if (muportDocument.publicProfile) doc.uportProfile = muportDocument.publicProfile;
  if (muportDocument.symEncryptedData) doc.muportData.symEncryptedData = muportDocument.symEncryptedData;
  if (muportDocument.recoveryNetwork) doc.muportData.recoveryNetwork = muportDocument.recoveryNetwork;
  return doc;
}

module.exports = register;
      };
    };
  }
}, {package:"muport-did-resolver",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/muport-did-resolver/lib/register.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/graphql-request/dist/src/types.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/graphql-request/dist/src/types.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ClientError = /** @class */ (function (_super) {
    __extends(ClientError, _super);
    function ClientError(response, request) {
        var _this = this;
        var message = ClientError.extractMessage(response) + ": " + JSON.stringify({ response: response, request: request });
        _this = _super.call(this, message) || this;
        _this.response = response;
        _this.request = request;
        // this is needed as Safari doesn't support .captureStackTrace
        /* tslint:disable-next-line */
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(_this, ClientError);
        }
        return _this;
    }
    ClientError.extractMessage = function (response) {
        try {
            return response.errors[0].message;
        }
        catch (e) {
            return "GraphQL Error (Code: " + response.status + ")";
        }
    };
    return ClientError;
}(Error));
exports.ClientError = ClientError;
//# sourceMappingURL=types.js.map
      };
    };
  }
}, {package:"graphql-request",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/graphql-request/dist/src/types.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/graphql-request/node_modules/cross-fetch/dist/browser-polyfill.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/graphql-request/node_modules/cross-fetch/dist/browser-polyfill.js
      return function (require, module, exports) {
(function(self) {

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob();
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    };

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue+','+value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) { items.push(name); });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) { items.push(value); });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) { items.push([name, value]); });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'omit';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  };

  function decode(body) {
    var form = new FormData();
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);
      var xhr = new XMLHttpRequest();

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  };
  self.fetch.polyfill = true;
})(typeof self !== 'undefined' ? self : this);

      };
    };
  }
}, {package:"cross-fetch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/graphql-request/node_modules/cross-fetch/dist/browser-polyfill.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/constants.js
      return function (require, module, exports) {
/* eslint quote-props: off */
/* eslint key-spacing: off */
'use strict'

exports.names = Object.freeze({
  'identity':   0x0,
  'sha1':       0x11,
  'sha2-256':   0x12,
  'sha2-512':   0x13,
  'dbl-sha2-256': 0x56,
  'sha3-224':   0x17,
  'sha3-256':   0x16,
  'sha3-384':   0x15,
  'sha3-512':   0x14,
  'shake-128':  0x18,
  'shake-256':  0x19,
  'keccak-224': 0x1A,
  'keccak-256': 0x1B,
  'keccak-384': 0x1C,
  'keccak-512': 0x1D,
  'murmur3-128': 0x22,
  'murmur3-32':  0x23,
  'blake2b-8':   0xb201,
  'blake2b-16':  0xb202,
  'blake2b-24':  0xb203,
  'blake2b-32':  0xb204,
  'blake2b-40':  0xb205,
  'blake2b-48':  0xb206,
  'blake2b-56':  0xb207,
  'blake2b-64':  0xb208,
  'blake2b-72':  0xb209,
  'blake2b-80':  0xb20a,
  'blake2b-88':  0xb20b,
  'blake2b-96':  0xb20c,
  'blake2b-104': 0xb20d,
  'blake2b-112': 0xb20e,
  'blake2b-120': 0xb20f,
  'blake2b-128': 0xb210,
  'blake2b-136': 0xb211,
  'blake2b-144': 0xb212,
  'blake2b-152': 0xb213,
  'blake2b-160': 0xb214,
  'blake2b-168': 0xb215,
  'blake2b-176': 0xb216,
  'blake2b-184': 0xb217,
  'blake2b-192': 0xb218,
  'blake2b-200': 0xb219,
  'blake2b-208': 0xb21a,
  'blake2b-216': 0xb21b,
  'blake2b-224': 0xb21c,
  'blake2b-232': 0xb21d,
  'blake2b-240': 0xb21e,
  'blake2b-248': 0xb21f,
  'blake2b-256': 0xb220,
  'blake2b-264': 0xb221,
  'blake2b-272': 0xb222,
  'blake2b-280': 0xb223,
  'blake2b-288': 0xb224,
  'blake2b-296': 0xb225,
  'blake2b-304': 0xb226,
  'blake2b-312': 0xb227,
  'blake2b-320': 0xb228,
  'blake2b-328': 0xb229,
  'blake2b-336': 0xb22a,
  'blake2b-344': 0xb22b,
  'blake2b-352': 0xb22c,
  'blake2b-360': 0xb22d,
  'blake2b-368': 0xb22e,
  'blake2b-376': 0xb22f,
  'blake2b-384': 0xb230,
  'blake2b-392': 0xb231,
  'blake2b-400': 0xb232,
  'blake2b-408': 0xb233,
  'blake2b-416': 0xb234,
  'blake2b-424': 0xb235,
  'blake2b-432': 0xb236,
  'blake2b-440': 0xb237,
  'blake2b-448': 0xb238,
  'blake2b-456': 0xb239,
  'blake2b-464': 0xb23a,
  'blake2b-472': 0xb23b,
  'blake2b-480': 0xb23c,
  'blake2b-488': 0xb23d,
  'blake2b-496': 0xb23e,
  'blake2b-504': 0xb23f,
  'blake2b-512': 0xb240,
  'blake2s-8':   0xb241,
  'blake2s-16':  0xb242,
  'blake2s-24':  0xb243,
  'blake2s-32':  0xb244,
  'blake2s-40':  0xb245,
  'blake2s-48':  0xb246,
  'blake2s-56':  0xb247,
  'blake2s-64':  0xb248,
  'blake2s-72':  0xb249,
  'blake2s-80':  0xb24a,
  'blake2s-88':  0xb24b,
  'blake2s-96':  0xb24c,
  'blake2s-104': 0xb24d,
  'blake2s-112': 0xb24e,
  'blake2s-120': 0xb24f,
  'blake2s-128': 0xb250,
  'blake2s-136': 0xb251,
  'blake2s-144': 0xb252,
  'blake2s-152': 0xb253,
  'blake2s-160': 0xb254,
  'blake2s-168': 0xb255,
  'blake2s-176': 0xb256,
  'blake2s-184': 0xb257,
  'blake2s-192': 0xb258,
  'blake2s-200': 0xb259,
  'blake2s-208': 0xb25a,
  'blake2s-216': 0xb25b,
  'blake2s-224': 0xb25c,
  'blake2s-232': 0xb25d,
  'blake2s-240': 0xb25e,
  'blake2s-248': 0xb25f,
  'blake2s-256': 0xb260,
  'Skein256-8': 0xb301,
  'Skein256-16': 0xb302,
  'Skein256-24': 0xb303,
  'Skein256-32': 0xb304,
  'Skein256-40': 0xb305,
  'Skein256-48': 0xb306,
  'Skein256-56': 0xb307,
  'Skein256-64': 0xb308,
  'Skein256-72': 0xb309,
  'Skein256-80': 0xb30a,
  'Skein256-88': 0xb30b,
  'Skein256-96': 0xb30c,
  'Skein256-104': 0xb30d,
  'Skein256-112': 0xb30e,
  'Skein256-120': 0xb30f,
  'Skein256-128': 0xb310,
  'Skein256-136': 0xb311,
  'Skein256-144': 0xb312,
  'Skein256-152': 0xb313,
  'Skein256-160': 0xb314,
  'Skein256-168': 0xb315,
  'Skein256-176': 0xb316,
  'Skein256-184': 0xb317,
  'Skein256-192': 0xb318,
  'Skein256-200': 0xb319,
  'Skein256-208': 0xb31a,
  'Skein256-216': 0xb31b,
  'Skein256-224': 0xb31c,
  'Skein256-232': 0xb31d,
  'Skein256-240': 0xb31e,
  'Skein256-248': 0xb31f,
  'Skein256-256': 0xb320,
  'Skein512-8': 0xb321,
  'Skein512-16': 0xb322,
  'Skein512-24': 0xb323,
  'Skein512-32': 0xb324,
  'Skein512-40': 0xb325,
  'Skein512-48': 0xb326,
  'Skein512-56': 0xb327,
  'Skein512-64': 0xb328,
  'Skein512-72': 0xb329,
  'Skein512-80': 0xb32a,
  'Skein512-88': 0xb32b,
  'Skein512-96': 0xb32c,
  'Skein512-104': 0xb32d,
  'Skein512-112': 0xb32e,
  'Skein512-120': 0xb32f,
  'Skein512-128': 0xb330,
  'Skein512-136': 0xb331,
  'Skein512-144': 0xb332,
  'Skein512-152': 0xb333,
  'Skein512-160': 0xb334,
  'Skein512-168': 0xb335,
  'Skein512-176': 0xb336,
  'Skein512-184': 0xb337,
  'Skein512-192': 0xb338,
  'Skein512-200': 0xb339,
  'Skein512-208': 0xb33a,
  'Skein512-216': 0xb33b,
  'Skein512-224': 0xb33c,
  'Skein512-232': 0xb33d,
  'Skein512-240': 0xb33e,
  'Skein512-248': 0xb33f,
  'Skein512-256': 0xb340,
  'Skein512-264': 0xb341,
  'Skein512-272': 0xb342,
  'Skein512-280': 0xb343,
  'Skein512-288': 0xb344,
  'Skein512-296': 0xb345,
  'Skein512-304': 0xb346,
  'Skein512-312': 0xb347,
  'Skein512-320': 0xb348,
  'Skein512-328': 0xb349,
  'Skein512-336': 0xb34a,
  'Skein512-344': 0xb34b,
  'Skein512-352': 0xb34c,
  'Skein512-360': 0xb34d,
  'Skein512-368': 0xb34e,
  'Skein512-376': 0xb34f,
  'Skein512-384': 0xb350,
  'Skein512-392': 0xb351,
  'Skein512-400': 0xb352,
  'Skein512-408': 0xb353,
  'Skein512-416': 0xb354,
  'Skein512-424': 0xb355,
  'Skein512-432': 0xb356,
  'Skein512-440': 0xb357,
  'Skein512-448': 0xb358,
  'Skein512-456': 0xb359,
  'Skein512-464': 0xb35a,
  'Skein512-472': 0xb35b,
  'Skein512-480': 0xb35c,
  'Skein512-488': 0xb35d,
  'Skein512-496': 0xb35e,
  'Skein512-504': 0xb35f,
  'Skein512-512': 0xb360,
  'Skein1024-8': 0xb361,
  'Skein1024-16': 0xb362,
  'Skein1024-24': 0xb363,
  'Skein1024-32': 0xb364,
  'Skein1024-40': 0xb365,
  'Skein1024-48': 0xb366,
  'Skein1024-56': 0xb367,
  'Skein1024-64': 0xb368,
  'Skein1024-72': 0xb369,
  'Skein1024-80': 0xb36a,
  'Skein1024-88': 0xb36b,
  'Skein1024-96': 0xb36c,
  'Skein1024-104': 0xb36d,
  'Skein1024-112': 0xb36e,
  'Skein1024-120': 0xb36f,
  'Skein1024-128': 0xb370,
  'Skein1024-136': 0xb371,
  'Skein1024-144': 0xb372,
  'Skein1024-152': 0xb373,
  'Skein1024-160': 0xb374,
  'Skein1024-168': 0xb375,
  'Skein1024-176': 0xb376,
  'Skein1024-184': 0xb377,
  'Skein1024-192': 0xb378,
  'Skein1024-200': 0xb379,
  'Skein1024-208': 0xb37a,
  'Skein1024-216': 0xb37b,
  'Skein1024-224': 0xb37c,
  'Skein1024-232': 0xb37d,
  'Skein1024-240': 0xb37e,
  'Skein1024-248': 0xb37f,
  'Skein1024-256': 0xb380,
  'Skein1024-264': 0xb381,
  'Skein1024-272': 0xb382,
  'Skein1024-280': 0xb383,
  'Skein1024-288': 0xb384,
  'Skein1024-296': 0xb385,
  'Skein1024-304': 0xb386,
  'Skein1024-312': 0xb387,
  'Skein1024-320': 0xb388,
  'Skein1024-328': 0xb389,
  'Skein1024-336': 0xb38a,
  'Skein1024-344': 0xb38b,
  'Skein1024-352': 0xb38c,
  'Skein1024-360': 0xb38d,
  'Skein1024-368': 0xb38e,
  'Skein1024-376': 0xb38f,
  'Skein1024-384': 0xb390,
  'Skein1024-392': 0xb391,
  'Skein1024-400': 0xb392,
  'Skein1024-408': 0xb393,
  'Skein1024-416': 0xb394,
  'Skein1024-424': 0xb395,
  'Skein1024-432': 0xb396,
  'Skein1024-440': 0xb397,
  'Skein1024-448': 0xb398,
  'Skein1024-456': 0xb399,
  'Skein1024-464': 0xb39a,
  'Skein1024-472': 0xb39b,
  'Skein1024-480': 0xb39c,
  'Skein1024-488': 0xb39d,
  'Skein1024-496': 0xb39e,
  'Skein1024-504': 0xb39f,
  'Skein1024-512': 0xb3a0,
  'Skein1024-520': 0xb3a1,
  'Skein1024-528': 0xb3a2,
  'Skein1024-536': 0xb3a3,
  'Skein1024-544': 0xb3a4,
  'Skein1024-552': 0xb3a5,
  'Skein1024-560': 0xb3a6,
  'Skein1024-568': 0xb3a7,
  'Skein1024-576': 0xb3a8,
  'Skein1024-584': 0xb3a9,
  'Skein1024-592': 0xb3aa,
  'Skein1024-600': 0xb3ab,
  'Skein1024-608': 0xb3ac,
  'Skein1024-616': 0xb3ad,
  'Skein1024-624': 0xb3ae,
  'Skein1024-632': 0xb3af,
  'Skein1024-640': 0xb3b0,
  'Skein1024-648': 0xb3b1,
  'Skein1024-656': 0xb3b2,
  'Skein1024-664': 0xb3b3,
  'Skein1024-672': 0xb3b4,
  'Skein1024-680': 0xb3b5,
  'Skein1024-688': 0xb3b6,
  'Skein1024-696': 0xb3b7,
  'Skein1024-704': 0xb3b8,
  'Skein1024-712': 0xb3b9,
  'Skein1024-720': 0xb3ba,
  'Skein1024-728': 0xb3bb,
  'Skein1024-736': 0xb3bc,
  'Skein1024-744': 0xb3bd,
  'Skein1024-752': 0xb3be,
  'Skein1024-760': 0xb3bf,
  'Skein1024-768': 0xb3c0,
  'Skein1024-776': 0xb3c1,
  'Skein1024-784': 0xb3c2,
  'Skein1024-792': 0xb3c3,
  'Skein1024-800': 0xb3c4,
  'Skein1024-808': 0xb3c5,
  'Skein1024-816': 0xb3c6,
  'Skein1024-824': 0xb3c7,
  'Skein1024-832': 0xb3c8,
  'Skein1024-840': 0xb3c9,
  'Skein1024-848': 0xb3ca,
  'Skein1024-856': 0xb3cb,
  'Skein1024-864': 0xb3cc,
  'Skein1024-872': 0xb3cd,
  'Skein1024-880': 0xb3ce,
  'Skein1024-888': 0xb3cf,
  'Skein1024-896': 0xb3d0,
  'Skein1024-904': 0xb3d1,
  'Skein1024-912': 0xb3d2,
  'Skein1024-920': 0xb3d3,
  'Skein1024-928': 0xb3d4,
  'Skein1024-936': 0xb3d5,
  'Skein1024-944': 0xb3d6,
  'Skein1024-952': 0xb3d7,
  'Skein1024-960': 0xb3d8,
  'Skein1024-968': 0xb3d9,
  'Skein1024-976': 0xb3da,
  'Skein1024-984': 0xb3db,
  'Skein1024-992': 0xb3dc,
  'Skein1024-1000': 0xb3dd,
  'Skein1024-1008': 0xb3de,
  'Skein1024-1016': 0xb3df,
  'Skein1024-1024': 0xb3e0
})

exports.codes = Object.freeze({
  0x0: 'identity',

  // sha family
  0x11: 'sha1',
  0x12: 'sha2-256',
  0x13: 'sha2-512',
  0x56: 'dbl-sha2-256',
  0x17: 'sha3-224',
  0x16: 'sha3-256',
  0x15: 'sha3-384',
  0x14: 'sha3-512',
  0x18: 'shake-128',
  0x19: 'shake-256',
  0x1A: 'keccak-224',
  0x1B: 'keccak-256',
  0x1C: 'keccak-384',
  0x1D: 'keccak-512',

  0x22: 'murmur3-128',
  0x23: 'murmur3-32',

  // blake2
  0xb201: 'blake2b-8',
  0xb202: 'blake2b-16',
  0xb203: 'blake2b-24',
  0xb204: 'blake2b-32',
  0xb205: 'blake2b-40',
  0xb206: 'blake2b-48',
  0xb207: 'blake2b-56',
  0xb208: 'blake2b-64',
  0xb209: 'blake2b-72',
  0xb20a: 'blake2b-80',
  0xb20b: 'blake2b-88',
  0xb20c: 'blake2b-96',
  0xb20d: 'blake2b-104',
  0xb20e: 'blake2b-112',
  0xb20f: 'blake2b-120',
  0xb210: 'blake2b-128',
  0xb211: 'blake2b-136',
  0xb212: 'blake2b-144',
  0xb213: 'blake2b-152',
  0xb214: 'blake2b-160',
  0xb215: 'blake2b-168',
  0xb216: 'blake2b-176',
  0xb217: 'blake2b-184',
  0xb218: 'blake2b-192',
  0xb219: 'blake2b-200',
  0xb21a: 'blake2b-208',
  0xb21b: 'blake2b-216',
  0xb21c: 'blake2b-224',
  0xb21d: 'blake2b-232',
  0xb21e: 'blake2b-240',
  0xb21f: 'blake2b-248',
  0xb220: 'blake2b-256',
  0xb221: 'blake2b-264',
  0xb222: 'blake2b-272',
  0xb223: 'blake2b-280',
  0xb224: 'blake2b-288',
  0xb225: 'blake2b-296',
  0xb226: 'blake2b-304',
  0xb227: 'blake2b-312',
  0xb228: 'blake2b-320',
  0xb229: 'blake2b-328',
  0xb22a: 'blake2b-336',
  0xb22b: 'blake2b-344',
  0xb22c: 'blake2b-352',
  0xb22d: 'blake2b-360',
  0xb22e: 'blake2b-368',
  0xb22f: 'blake2b-376',
  0xb230: 'blake2b-384',
  0xb231: 'blake2b-392',
  0xb232: 'blake2b-400',
  0xb233: 'blake2b-408',
  0xb234: 'blake2b-416',
  0xb235: 'blake2b-424',
  0xb236: 'blake2b-432',
  0xb237: 'blake2b-440',
  0xb238: 'blake2b-448',
  0xb239: 'blake2b-456',
  0xb23a: 'blake2b-464',
  0xb23b: 'blake2b-472',
  0xb23c: 'blake2b-480',
  0xb23d: 'blake2b-488',
  0xb23e: 'blake2b-496',
  0xb23f: 'blake2b-504',
  0xb240: 'blake2b-512',
  0xb241: 'blake2s-8',
  0xb242: 'blake2s-16',
  0xb243: 'blake2s-24',
  0xb244: 'blake2s-32',
  0xb245: 'blake2s-40',
  0xb246: 'blake2s-48',
  0xb247: 'blake2s-56',
  0xb248: 'blake2s-64',
  0xb249: 'blake2s-72',
  0xb24a: 'blake2s-80',
  0xb24b: 'blake2s-88',
  0xb24c: 'blake2s-96',
  0xb24d: 'blake2s-104',
  0xb24e: 'blake2s-112',
  0xb24f: 'blake2s-120',
  0xb250: 'blake2s-128',
  0xb251: 'blake2s-136',
  0xb252: 'blake2s-144',
  0xb253: 'blake2s-152',
  0xb254: 'blake2s-160',
  0xb255: 'blake2s-168',
  0xb256: 'blake2s-176',
  0xb257: 'blake2s-184',
  0xb258: 'blake2s-192',
  0xb259: 'blake2s-200',
  0xb25a: 'blake2s-208',
  0xb25b: 'blake2s-216',
  0xb25c: 'blake2s-224',
  0xb25d: 'blake2s-232',
  0xb25e: 'blake2s-240',
  0xb25f: 'blake2s-248',
  0xb260: 'blake2s-256',

  // skein
  0xb301: 'Skein256-8',
  0xb302: 'Skein256-16',
  0xb303: 'Skein256-24',
  0xb304: 'Skein256-32',
  0xb305: 'Skein256-40',
  0xb306: 'Skein256-48',
  0xb307: 'Skein256-56',
  0xb308: 'Skein256-64',
  0xb309: 'Skein256-72',
  0xb30a: 'Skein256-80',
  0xb30b: 'Skein256-88',
  0xb30c: 'Skein256-96',
  0xb30d: 'Skein256-104',
  0xb30e: 'Skein256-112',
  0xb30f: 'Skein256-120',
  0xb310: 'Skein256-128',
  0xb311: 'Skein256-136',
  0xb312: 'Skein256-144',
  0xb313: 'Skein256-152',
  0xb314: 'Skein256-160',
  0xb315: 'Skein256-168',
  0xb316: 'Skein256-176',
  0xb317: 'Skein256-184',
  0xb318: 'Skein256-192',
  0xb319: 'Skein256-200',
  0xb31a: 'Skein256-208',
  0xb31b: 'Skein256-216',
  0xb31c: 'Skein256-224',
  0xb31d: 'Skein256-232',
  0xb31e: 'Skein256-240',
  0xb31f: 'Skein256-248',
  0xb320: 'Skein256-256',
  0xb321: 'Skein512-8',
  0xb322: 'Skein512-16',
  0xb323: 'Skein512-24',
  0xb324: 'Skein512-32',
  0xb325: 'Skein512-40',
  0xb326: 'Skein512-48',
  0xb327: 'Skein512-56',
  0xb328: 'Skein512-64',
  0xb329: 'Skein512-72',
  0xb32a: 'Skein512-80',
  0xb32b: 'Skein512-88',
  0xb32c: 'Skein512-96',
  0xb32d: 'Skein512-104',
  0xb32e: 'Skein512-112',
  0xb32f: 'Skein512-120',
  0xb330: 'Skein512-128',
  0xb331: 'Skein512-136',
  0xb332: 'Skein512-144',
  0xb333: 'Skein512-152',
  0xb334: 'Skein512-160',
  0xb335: 'Skein512-168',
  0xb336: 'Skein512-176',
  0xb337: 'Skein512-184',
  0xb338: 'Skein512-192',
  0xb339: 'Skein512-200',
  0xb33a: 'Skein512-208',
  0xb33b: 'Skein512-216',
  0xb33c: 'Skein512-224',
  0xb33d: 'Skein512-232',
  0xb33e: 'Skein512-240',
  0xb33f: 'Skein512-248',
  0xb340: 'Skein512-256',
  0xb341: 'Skein512-264',
  0xb342: 'Skein512-272',
  0xb343: 'Skein512-280',
  0xb344: 'Skein512-288',
  0xb345: 'Skein512-296',
  0xb346: 'Skein512-304',
  0xb347: 'Skein512-312',
  0xb348: 'Skein512-320',
  0xb349: 'Skein512-328',
  0xb34a: 'Skein512-336',
  0xb34b: 'Skein512-344',
  0xb34c: 'Skein512-352',
  0xb34d: 'Skein512-360',
  0xb34e: 'Skein512-368',
  0xb34f: 'Skein512-376',
  0xb350: 'Skein512-384',
  0xb351: 'Skein512-392',
  0xb352: 'Skein512-400',
  0xb353: 'Skein512-408',
  0xb354: 'Skein512-416',
  0xb355: 'Skein512-424',
  0xb356: 'Skein512-432',
  0xb357: 'Skein512-440',
  0xb358: 'Skein512-448',
  0xb359: 'Skein512-456',
  0xb35a: 'Skein512-464',
  0xb35b: 'Skein512-472',
  0xb35c: 'Skein512-480',
  0xb35d: 'Skein512-488',
  0xb35e: 'Skein512-496',
  0xb35f: 'Skein512-504',
  0xb360: 'Skein512-512',
  0xb361: 'Skein1024-8',
  0xb362: 'Skein1024-16',
  0xb363: 'Skein1024-24',
  0xb364: 'Skein1024-32',
  0xb365: 'Skein1024-40',
  0xb366: 'Skein1024-48',
  0xb367: 'Skein1024-56',
  0xb368: 'Skein1024-64',
  0xb369: 'Skein1024-72',
  0xb36a: 'Skein1024-80',
  0xb36b: 'Skein1024-88',
  0xb36c: 'Skein1024-96',
  0xb36d: 'Skein1024-104',
  0xb36e: 'Skein1024-112',
  0xb36f: 'Skein1024-120',
  0xb370: 'Skein1024-128',
  0xb371: 'Skein1024-136',
  0xb372: 'Skein1024-144',
  0xb373: 'Skein1024-152',
  0xb374: 'Skein1024-160',
  0xb375: 'Skein1024-168',
  0xb376: 'Skein1024-176',
  0xb377: 'Skein1024-184',
  0xb378: 'Skein1024-192',
  0xb379: 'Skein1024-200',
  0xb37a: 'Skein1024-208',
  0xb37b: 'Skein1024-216',
  0xb37c: 'Skein1024-224',
  0xb37d: 'Skein1024-232',
  0xb37e: 'Skein1024-240',
  0xb37f: 'Skein1024-248',
  0xb380: 'Skein1024-256',
  0xb381: 'Skein1024-264',
  0xb382: 'Skein1024-272',
  0xb383: 'Skein1024-280',
  0xb384: 'Skein1024-288',
  0xb385: 'Skein1024-296',
  0xb386: 'Skein1024-304',
  0xb387: 'Skein1024-312',
  0xb388: 'Skein1024-320',
  0xb389: 'Skein1024-328',
  0xb38a: 'Skein1024-336',
  0xb38b: 'Skein1024-344',
  0xb38c: 'Skein1024-352',
  0xb38d: 'Skein1024-360',
  0xb38e: 'Skein1024-368',
  0xb38f: 'Skein1024-376',
  0xb390: 'Skein1024-384',
  0xb391: 'Skein1024-392',
  0xb392: 'Skein1024-400',
  0xb393: 'Skein1024-408',
  0xb394: 'Skein1024-416',
  0xb395: 'Skein1024-424',
  0xb396: 'Skein1024-432',
  0xb397: 'Skein1024-440',
  0xb398: 'Skein1024-448',
  0xb399: 'Skein1024-456',
  0xb39a: 'Skein1024-464',
  0xb39b: 'Skein1024-472',
  0xb39c: 'Skein1024-480',
  0xb39d: 'Skein1024-488',
  0xb39e: 'Skein1024-496',
  0xb39f: 'Skein1024-504',
  0xb3a0: 'Skein1024-512',
  0xb3a1: 'Skein1024-520',
  0xb3a2: 'Skein1024-528',
  0xb3a3: 'Skein1024-536',
  0xb3a4: 'Skein1024-544',
  0xb3a5: 'Skein1024-552',
  0xb3a6: 'Skein1024-560',
  0xb3a7: 'Skein1024-568',
  0xb3a8: 'Skein1024-576',
  0xb3a9: 'Skein1024-584',
  0xb3aa: 'Skein1024-592',
  0xb3ab: 'Skein1024-600',
  0xb3ac: 'Skein1024-608',
  0xb3ad: 'Skein1024-616',
  0xb3ae: 'Skein1024-624',
  0xb3af: 'Skein1024-632',
  0xb3b0: 'Skein1024-640',
  0xb3b1: 'Skein1024-648',
  0xb3b2: 'Skein1024-656',
  0xb3b3: 'Skein1024-664',
  0xb3b4: 'Skein1024-672',
  0xb3b5: 'Skein1024-680',
  0xb3b6: 'Skein1024-688',
  0xb3b7: 'Skein1024-696',
  0xb3b8: 'Skein1024-704',
  0xb3b9: 'Skein1024-712',
  0xb3ba: 'Skein1024-720',
  0xb3bb: 'Skein1024-728',
  0xb3bc: 'Skein1024-736',
  0xb3bd: 'Skein1024-744',
  0xb3be: 'Skein1024-752',
  0xb3bf: 'Skein1024-760',
  0xb3c0: 'Skein1024-768',
  0xb3c1: 'Skein1024-776',
  0xb3c2: 'Skein1024-784',
  0xb3c3: 'Skein1024-792',
  0xb3c4: 'Skein1024-800',
  0xb3c5: 'Skein1024-808',
  0xb3c6: 'Skein1024-816',
  0xb3c7: 'Skein1024-824',
  0xb3c8: 'Skein1024-832',
  0xb3c9: 'Skein1024-840',
  0xb3ca: 'Skein1024-848',
  0xb3cb: 'Skein1024-856',
  0xb3cc: 'Skein1024-864',
  0xb3cd: 'Skein1024-872',
  0xb3ce: 'Skein1024-880',
  0xb3cf: 'Skein1024-888',
  0xb3d0: 'Skein1024-896',
  0xb3d1: 'Skein1024-904',
  0xb3d2: 'Skein1024-912',
  0xb3d3: 'Skein1024-920',
  0xb3d4: 'Skein1024-928',
  0xb3d5: 'Skein1024-936',
  0xb3d6: 'Skein1024-944',
  0xb3d7: 'Skein1024-952',
  0xb3d8: 'Skein1024-960',
  0xb3d9: 'Skein1024-968',
  0xb3da: 'Skein1024-976',
  0xb3db: 'Skein1024-984',
  0xb3dc: 'Skein1024-992',
  0xb3dd: 'Skein1024-1000',
  0xb3de: 'Skein1024-1008',
  0xb3df: 'Skein1024-1016',
  0xb3e0: 'Skein1024-1024'
})

exports.defaultLengths = Object.freeze({
  0x11: 20,
  0x12: 32,
  0x13: 64,
  0x56: 32,
  0x17: 28,
  0x16: 32,
  0x15: 48,
  0x14: 64,
  0x18: 32,
  0x19: 64,
  0x1A: 28,
  0x1B: 32,
  0x1C: 48,
  0x1D: 64,
  0x22: 32,

  0xb201: 0x01,
  0xb202: 0x02,
  0xb203: 0x03,
  0xb204: 0x04,
  0xb205: 0x05,
  0xb206: 0x06,
  0xb207: 0x07,
  0xb208: 0x08,
  0xb209: 0x09,
  0xb20a: 0x0a,
  0xb20b: 0x0b,
  0xb20c: 0x0c,
  0xb20d: 0x0d,
  0xb20e: 0x0e,
  0xb20f: 0x0f,
  0xb210: 0x10,
  0xb211: 0x11,
  0xb212: 0x12,
  0xb213: 0x13,
  0xb214: 0x14,
  0xb215: 0x15,
  0xb216: 0x16,
  0xb217: 0x17,
  0xb218: 0x18,
  0xb219: 0x19,
  0xb21a: 0x1a,
  0xb21b: 0x1b,
  0xb21c: 0x1c,
  0xb21d: 0x1d,
  0xb21e: 0x1e,
  0xb21f: 0x1f,
  0xb220: 0x20,
  0xb221: 0x21,
  0xb222: 0x22,
  0xb223: 0x23,
  0xb224: 0x24,
  0xb225: 0x25,
  0xb226: 0x26,
  0xb227: 0x27,
  0xb228: 0x28,
  0xb229: 0x29,
  0xb22a: 0x2a,
  0xb22b: 0x2b,
  0xb22c: 0x2c,
  0xb22d: 0x2d,
  0xb22e: 0x2e,
  0xb22f: 0x2f,
  0xb230: 0x30,
  0xb231: 0x31,
  0xb232: 0x32,
  0xb233: 0x33,
  0xb234: 0x34,
  0xb235: 0x35,
  0xb236: 0x36,
  0xb237: 0x37,
  0xb238: 0x38,
  0xb239: 0x39,
  0xb23a: 0x3a,
  0xb23b: 0x3b,
  0xb23c: 0x3c,
  0xb23d: 0x3d,
  0xb23e: 0x3e,
  0xb23f: 0x3f,
  0xb240: 0x40,
  0xb241: 0x01,
  0xb242: 0x02,
  0xb243: 0x03,
  0xb244: 0x04,
  0xb245: 0x05,
  0xb246: 0x06,
  0xb247: 0x07,
  0xb248: 0x08,
  0xb249: 0x09,
  0xb24a: 0x0a,
  0xb24b: 0x0b,
  0xb24c: 0x0c,
  0xb24d: 0x0d,
  0xb24e: 0x0e,
  0xb24f: 0x0f,
  0xb250: 0x10,
  0xb251: 0x11,
  0xb252: 0x12,
  0xb253: 0x13,
  0xb254: 0x14,
  0xb255: 0x15,
  0xb256: 0x16,
  0xb257: 0x17,
  0xb258: 0x18,
  0xb259: 0x19,
  0xb25a: 0x1a,
  0xb25b: 0x1b,
  0xb25c: 0x1c,
  0xb25d: 0x1d,
  0xb25e: 0x1e,
  0xb25f: 0x1f,
  0xb260: 0x20,
  0xb301: 0x01,
  0xb302: 0x02,
  0xb303: 0x03,
  0xb304: 0x04,
  0xb305: 0x05,
  0xb306: 0x06,
  0xb307: 0x07,
  0xb308: 0x08,
  0xb309: 0x09,
  0xb30a: 0x0a,
  0xb30b: 0x0b,
  0xb30c: 0x0c,
  0xb30d: 0x0d,
  0xb30e: 0x0e,
  0xb30f: 0x0f,
  0xb310: 0x10,
  0xb311: 0x11,
  0xb312: 0x12,
  0xb313: 0x13,
  0xb314: 0x14,
  0xb315: 0x15,
  0xb316: 0x16,
  0xb317: 0x17,
  0xb318: 0x18,
  0xb319: 0x19,
  0xb31a: 0x1a,
  0xb31b: 0x1b,
  0xb31c: 0x1c,
  0xb31d: 0x1d,
  0xb31e: 0x1e,
  0xb31f: 0x1f,
  0xb320: 0x20,
  0xb321: 0x01,
  0xb322: 0x02,
  0xb323: 0x03,
  0xb324: 0x04,
  0xb325: 0x05,
  0xb326: 0x06,
  0xb327: 0x07,
  0xb328: 0x08,
  0xb329: 0x09,
  0xb32a: 0x0a,
  0xb32b: 0x0b,
  0xb32c: 0x0c,
  0xb32d: 0x0d,
  0xb32e: 0x0e,
  0xb32f: 0x0f,
  0xb330: 0x10,
  0xb331: 0x11,
  0xb332: 0x12,
  0xb333: 0x13,
  0xb334: 0x14,
  0xb335: 0x15,
  0xb336: 0x16,
  0xb337: 0x17,
  0xb338: 0x18,
  0xb339: 0x19,
  0xb33a: 0x1a,
  0xb33b: 0x1b,
  0xb33c: 0x1c,
  0xb33d: 0x1d,
  0xb33e: 0x1e,
  0xb33f: 0x1f,
  0xb340: 0x20,
  0xb341: 0x21,
  0xb342: 0x22,
  0xb343: 0x23,
  0xb344: 0x24,
  0xb345: 0x25,
  0xb346: 0x26,
  0xb347: 0x27,
  0xb348: 0x28,
  0xb349: 0x29,
  0xb34a: 0x2a,
  0xb34b: 0x2b,
  0xb34c: 0x2c,
  0xb34d: 0x2d,
  0xb34e: 0x2e,
  0xb34f: 0x2f,
  0xb350: 0x30,
  0xb351: 0x31,
  0xb352: 0x32,
  0xb353: 0x33,
  0xb354: 0x34,
  0xb355: 0x35,
  0xb356: 0x36,
  0xb357: 0x37,
  0xb358: 0x38,
  0xb359: 0x39,
  0xb35a: 0x3a,
  0xb35b: 0x3b,
  0xb35c: 0x3c,
  0xb35d: 0x3d,
  0xb35e: 0x3e,
  0xb35f: 0x3f,
  0xb360: 0x40,
  0xb361: 0x01,
  0xb362: 0x02,
  0xb363: 0x03,
  0xb364: 0x04,
  0xb365: 0x05,
  0xb366: 0x06,
  0xb367: 0x07,
  0xb368: 0x08,
  0xb369: 0x09,
  0xb36a: 0x0a,
  0xb36b: 0x0b,
  0xb36c: 0x0c,
  0xb36d: 0x0d,
  0xb36e: 0x0e,
  0xb36f: 0x0f,
  0xb370: 0x10,
  0xb371: 0x11,
  0xb372: 0x12,
  0xb373: 0x13,
  0xb374: 0x14,
  0xb375: 0x15,
  0xb376: 0x16,
  0xb377: 0x17,
  0xb378: 0x18,
  0xb379: 0x19,
  0xb37a: 0x1a,
  0xb37b: 0x1b,
  0xb37c: 0x1c,
  0xb37d: 0x1d,
  0xb37e: 0x1e,
  0xb37f: 0x1f,
  0xb380: 0x20,
  0xb381: 0x21,
  0xb382: 0x22,
  0xb383: 0x23,
  0xb384: 0x24,
  0xb385: 0x25,
  0xb386: 0x26,
  0xb387: 0x27,
  0xb388: 0x28,
  0xb389: 0x29,
  0xb38a: 0x2a,
  0xb38b: 0x2b,
  0xb38c: 0x2c,
  0xb38d: 0x2d,
  0xb38e: 0x2e,
  0xb38f: 0x2f,
  0xb390: 0x30,
  0xb391: 0x31,
  0xb392: 0x32,
  0xb393: 0x33,
  0xb394: 0x34,
  0xb395: 0x35,
  0xb396: 0x36,
  0xb397: 0x37,
  0xb398: 0x38,
  0xb399: 0x39,
  0xb39a: 0x3a,
  0xb39b: 0x3b,
  0xb39c: 0x3c,
  0xb39d: 0x3d,
  0xb39e: 0x3e,
  0xb39f: 0x3f,
  0xb3a0: 0x40,
  0xb3a1: 0x41,
  0xb3a2: 0x42,
  0xb3a3: 0x43,
  0xb3a4: 0x44,
  0xb3a5: 0x45,
  0xb3a6: 0x46,
  0xb3a7: 0x47,
  0xb3a8: 0x48,
  0xb3a9: 0x49,
  0xb3aa: 0x4a,
  0xb3ab: 0x4b,
  0xb3ac: 0x4c,
  0xb3ad: 0x4d,
  0xb3ae: 0x4e,
  0xb3af: 0x4f,
  0xb3b0: 0x50,
  0xb3b1: 0x51,
  0xb3b2: 0x52,
  0xb3b3: 0x53,
  0xb3b4: 0x54,
  0xb3b5: 0x55,
  0xb3b6: 0x56,
  0xb3b7: 0x57,
  0xb3b8: 0x58,
  0xb3b9: 0x59,
  0xb3ba: 0x5a,
  0xb3bb: 0x5b,
  0xb3bc: 0x5c,
  0xb3bd: 0x5d,
  0xb3be: 0x5e,
  0xb3bf: 0x5f,
  0xb3c0: 0x60,
  0xb3c1: 0x61,
  0xb3c2: 0x62,
  0xb3c3: 0x63,
  0xb3c4: 0x64,
  0xb3c5: 0x65,
  0xb3c6: 0x66,
  0xb3c7: 0x67,
  0xb3c8: 0x68,
  0xb3c9: 0x69,
  0xb3ca: 0x6a,
  0xb3cb: 0x6b,
  0xb3cc: 0x6c,
  0xb3cd: 0x6d,
  0xb3ce: 0x6e,
  0xb3cf: 0x6f,
  0xb3d0: 0x70,
  0xb3d1: 0x71,
  0xb3d2: 0x72,
  0xb3d3: 0x73,
  0xb3d4: 0x74,
  0xb3d5: 0x75,
  0xb3d6: 0x76,
  0xb3d7: 0x77,
  0xb3d8: 0x78,
  0xb3d9: 0x79,
  0xb3da: 0x7a,
  0xb3db: 0x7b,
  0xb3dc: 0x7c,
  0xb3dd: 0x7d,
  0xb3de: 0x7e,
  0xb3df: 0x7f,
  0xb3e0: 0x80
})

      };
    };
  }
}, {package:"multihashes",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-peer-monitor/src/ipfs-pubsub-peer-monitor.js", {"./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-peer-monitor/src/utils.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-peer-monitor/src/ipfs-pubsub-peer-monitor.js
      return function (require, module, exports) {
'use strict'

const { difference} = require('./utils')
const EventEmitter = require('events')

const DEFAULT_OPTIONS = {
  start: true,
  pollInterval: 1000,
}

class IpfsPubsubPeerMonitor extends EventEmitter {
  constructor (ipfsPubsub, topic, options) {
    super()
    this._pubsub = ipfsPubsub
    this._topic = topic
    this._options = Object.assign({}, DEFAULT_OPTIONS, options)
    this._peers = []
    this._interval = null

    if (this._options.start)
      this.start()
  }

  get started () { return this._interval !== null }
  set started (val) { throw new Error("'started' is read-only") }

  start () {
    if (this._interval)
      this.stop()

    this._interval = setInterval(
      this._pollPeers.bind(this), 
      this._options.pollInterval
    )
  }

  stop () {
    clearInterval(this._interval)
    this._interval = null
    this.removeAllListeners('error')
    this.removeAllListeners('join')
    this.removeAllListeners('leave')
  }

  async getPeers () {
    this._peers = await this._pubsub.peers(this._topic)
    return this._peers.slice()
  }

  hasPeer (peer) {
    return this._peers.includes(peer)
  }

  async _pollPeers () {
    try {
      const peers = await this._pubsub.peers(this._topic)
      IpfsPubsubPeerMonitor._emitJoinsAndLeaves(new Set(this._peers), new Set(peers), this)
      this._peers = peers
    } catch (err) {
      clearInterval(this._interval)
      this.emit('error', err)
    }
  }

  static _emitJoinsAndLeaves (oldValues, newValues, events) {
    const emitJoin = addedPeer => events.emit('join', addedPeer)
    const emitLeave = removedPeer => events.emit('leave', removedPeer)
    difference(newValues, oldValues).forEach(emitJoin)
    difference(oldValues, newValues).forEach(emitLeave)
  }
}

module.exports = IpfsPubsubPeerMonitor

      };
    };
  }
}, {package:"ipfs-pubsub-peer-monitor",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-peer-monitor/src/ipfs-pubsub-peer-monitor.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-series/index.js", {"@sindresorhus/is":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-series/node_modules/@sindresorhus/is/dist/index.js","p-reduce":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-reduce/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/p-series/index.js
      return function (require, module, exports) {
'use strict';
const pReduce = require('p-reduce');
const is = require('@sindresorhus/is');

module.exports = iterable => {
	const ret = [];

	for (const task of iterable) {
		const type = is(task);

		if (type !== 'Function') {
			return Promise.reject(new TypeError(`Expected task to be a \`Function\`, received \`${type}\``));
		}
	}

	return pReduce(iterable, (_, fn) => {
		return Promise.resolve().then(fn).then(val => {
			ret.push(val);
		});
	}).then(() => ret);
};

      };
    };
  }
}, {package:"p-series",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-series/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/g-set.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/g-set.js
      return function (require, module, exports) {
'use strict'

/**
 * Interface for G-Set CRDT
 *
 * From:
 * "A comprehensive study of Convergent and Commutative Replicated Data Types"
 * https://hal.inria.fr/inria-00555588
 */
class GSet {
  constructor (values) {} // eslint-disable-line
  append (value) {}
  merge (set) {}
  get (value) {}
  has (value) {}
  get values () {}
  get length () {}
}

module.exports = GSet

      };
    };
  }
}, {package:"ipfs-log",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/g-set.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/log-errors.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/log-errors.js
      return function (require, module, exports) {
'use strict'

const IPFSNotDefinedError = () => new Error('IPFS instance not defined')
const LogNotDefinedError = () => new Error('Log instance not defined')
const NotALogError = () => new Error('Given argument is not an instance of Log')
const CannotJoinWithDifferentId = () => new Error('Can\'t join logs with different IDs')
const LtOrLteMustBeStringOrArray = () => new Error('lt or lte must be a string or array of Entries')

module.exports = {
  IPFSNotDefinedError: IPFSNotDefinedError,
  LogNotDefinedError: LogNotDefinedError,
  NotALogError: NotALogError,
  CannotJoinWithDifferentId: CannotJoinWithDifferentId,
  LtOrLteMustBeStringOrArray: LtOrLteMustBeStringOrArray
}

      };
    };
  }
}, {package:"ipfs-log",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/log-errors.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/lamport-clock.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/lamport-clock.js
      return function (require, module, exports) {
'use strict'

class LamportClock {
  constructor (id, time) {
    this.id = id
    this.time = time || 0
  }

  tick () {
    return new LamportClock(this.id, ++this.time)
  }

  merge (clock) {
    this.time = Math.max(this.time, clock.time)
    return new LamportClock(this.id, this.time)
  }

  clone () {
    return new LamportClock(this.id, this.time)
  }

  static compare (a, b) {
    // Calculate the "distance" based on the clock, ie. lower or greater
    var dist = a.time - b.time

    // If the sequence number is the same (concurrent events),
    // and the IDs are different, take the one with a "lower" id
    if (dist === 0 && a.id !== b.id) return a.id < b.id ? -1 : 1

    return dist
  }
}

module.exports = LamportClock

      };
    };
  }
}, {package:"ipfs-log",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/lamport-clock.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/default-access-controller.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/default-access-controller.js
      return function (require, module, exports) {
'use strict'

class AccessController {
  async canAppend (entry, identityProvider) {
    return true
  }
}

module.exports = AccessController

      };
    };
  }
}, {package:"ipfs-log",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/default-access-controller.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/entry-index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/entry-index.js
      return function (require, module, exports) {
'use strict'

class EntryIndex {
  constructor (entries = {}) {
    this._cache = entries
  }

  set (k, v) {
    this._cache[k] = v
  }

  get (k) {
    return this._cache[k]
  }

  delete (k) {
    return delete this._cache[k]
  }

  add (newItems) {
    this._cache = Object.assign(this._cache, newItems)
  }

  get length () {
    return Object.values(this._cache).length
  }
}

module.exports = EntryIndex

      };
    };
  }
}, {package:"ipfs-log",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/entry-index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/log-sorting.js", {"./lamport-clock":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/lamport-clock.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/log-sorting.js
      return function (require, module, exports) {
'use strict'

const Clock = require('./lamport-clock')

/**
 * Sort two entries as Last-Write-Wins (LWW).
 *
 * Last Write Wins is a conflict resolution strategy for sorting elements
 * where the element with a greater clock (latest) is chosen as the winner.
 *
 * @param {Entry} a First entry
 * @param {Entry} b Second entry
 * @returns {number} 1 if a is latest, -1 if b is latest
 */
function LastWriteWins (a, b) {
  // Ultimate conflict resolution (take the first/left arg)
  const First = (a, b) => a
  // Sort two entries by their clock id, if the same always take the first
  const sortById = (a, b) => SortByClockId(a, b, First)
  // Sort two entries by their clock time, if concurrent,
  // determine sorting using provided conflict resolution function
  const sortByEntryClocks = (a, b) => SortByClocks(a, b, sortById)
  // Sort entries by clock time as the primary sort criteria
  return sortByEntryClocks(a, b)
}

/**
 * Sort two entries by their hash.
 *
 * @param {Entry} a First entry
 * @param {Entry} b Second entry
 * @returns {number} 1 if a is latest, -1 if b is latest
 */
function SortByEntryHash (a, b) {
  // Ultimate conflict resolution (compare hashes)
  const compareHash = (a, b) => a.hash < b.hash ? -1 : 1
  // Sort two entries by their clock id, if the same then compare hashes
  const sortById = (a, b) => SortByClockId(a, b, compareHash)
  // Sort two entries by their clock time, if concurrent,
  // determine sorting using provided conflict resolution function
  const sortByEntryClocks = (a, b) => SortByClocks(a, b, sortById)
  // Sort entries by clock time as the primary sort criteria
  return sortByEntryClocks(a, b)
}

/**
 * Sort two entries by their clock time.
 * @param {Entry} a First entry to compare
 * @param {Entry} b Second entry to compare
 * @param {function(a, b)} resolveConflict A function to call if entries are concurrent (happened at the same time). The function should take in two entries and return 1 if the first entry should be chosen and -1 if the second entry should be chosen.
 * @returns {number} 1 if a is greater, -1 if b is greater
 */
function SortByClocks (a, b, resolveConflict) {
  // Compare the clocks
  const diff = Clock.compare(a.clock, b.clock)
  // If the clocks are concurrent, use the provided
  // conflict resolution function to determine which comes first
  return diff === 0 ? resolveConflict(a, b) : diff
}

/**
 * Sort two entries by their clock id.
 * @param {Entry} a First entry to compare
 * @param {Entry} b Second entry to compare
 * @param {function(a, b)} resolveConflict A function to call if the clocks ids are the same. The function should take in two entries and return 1 if the first entry should be chosen and -1 if the second entry should be chosen.
 * @returns {number} 1 if a is greater, -1 if b is greater
 */
function SortByClockId (a, b, resolveConflict) {
  // Sort by ID if clocks are concurrent,
  // take the entry with a "greater" clock id
  return a.clock.id === b.clock.id
    ? resolveConflict(a, b)
    : a.clock.id < b.clock.id ? -1 : 1
}

/**
 * A wrapper function to throw an error if the results of a passed function return zero
 * @param {function(a, b)} [tiebreaker] The tiebreaker function to validate.
 * @returns {function(a, b)} 1 if a is greater, -1 if b is greater
 * @throws {Error} if func ever returns 0
 */
function NoZeroes (func) {
  const msg = `Your log's tiebreaker function, ${func.name}, has returned zero and therefore cannot be`

  const comparator = (a, b) => {
    // Validate by calling the function
    const result = func(a, b)
    if (result === 0) { throw Error(msg) }
    return result
  }

  return comparator
}

exports.SortByClocks = SortByClocks
exports.SortByClockId = SortByClockId
exports.LastWriteWins = LastWriteWins
exports.SortByEntryHash = SortByEntryHash
exports.NoZeroes = NoZeroes

      };
    };
  }
}, {package:"ipfs-log",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/log-sorting.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-each-series/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/p-each-series/index.js
      return function (require, module, exports) {
'use strict';

const pEachSeries = async (iterable, iterator) => {
	let index = 0;

	for (const value of iterable) {
		// eslint-disable-next-line no-await-in-loop
		await iterator(await value, index++);
	}

	return iterable;
};

module.exports = pEachSeries;
// TODO: Remove this for the next major release
module.exports.default = pEachSeries;

      };
    };
  }
}, {package:"p-each-series",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-each-series/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/utils/index.js", {"./difference":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/utils/difference.js","./find-uniques":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/utils/find-uniques.js","./is-defined":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/utils/is-defined.js","orbit-db-io":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-io/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/utils/index.js
      return function (require, module, exports) {
'use strict'

const difference = require('./difference')
const findUniques = require('./find-uniques')
const isDefined = require('./is-defined')
const io = require('orbit-db-io')

module.exports = {
  difference,
  findUniques,
  isDefined,
  io
}

      };
    };
  }
}, {package:"ipfs-log",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/utils/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/log-io.js", {"./entry":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/entry.js","./entry-io":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/entry-io.js","./lamport-clock":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/lamport-clock.js","./log-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/log-errors.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/utils/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/log-io.js
      return function (require, module, exports) {
'use strict'

const Entry = require('./entry')
const EntryIO = require('./entry-io')
const Clock = require('./lamport-clock')
const LogError = require('./log-errors')
const { isDefined, findUniques, difference, io } = require('./utils')

const IPLD_LINKS = ['heads']
const last = (arr, n) => arr.slice(arr.length - n, arr.length)

class LogIO {
  //
  /**
   * Get the multihash of a Log.
   * @param {IPFS} ipfs An IPFS instance
   * @param {Log} log Log to get a multihash for
   * @returns {Promise<string>}
   * @deprecated
   */
  static async toMultihash (ipfs, log, { format } = {}) {
    if (!isDefined(ipfs)) throw LogError.IPFSNotDefinedError()
    if (!isDefined(log)) throw LogError.LogNotDefinedError()
    if (!isDefined(format)) format = 'dag-cbor'
    if (log.values.length < 1) throw new Error(`Can't serialize an empty log`)

    return io.write(ipfs, format, log.toJSON(), { links: IPLD_LINKS })
  }

  /**
   * Create a log from a hashes.
   * @param {IPFS} ipfs An IPFS instance
   * @param {string} hash The hash of the log
   * @param {Object} options
   * @param {number} options.length How many items to include in the log
   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)
   * @param {function(hash, entry, parent, depth)} options.onProgressCallback
   */
  static async fromMultihash (ipfs, hash, { length = -1, exclude, onProgressCallback, timeout } = {}) {
    if (!isDefined(ipfs)) throw LogError.IPFSNotDefinedError()
    if (!isDefined(hash)) throw new Error(`Invalid hash: ${hash}`)

    const logData = await io.read(ipfs, hash, { links: IPLD_LINKS })
    if (!logData.heads || !logData.id) throw LogError.NotALogError()

    const entries = await EntryIO.fetchAll(ipfs, logData.heads,
      { length, exclude, onProgressCallback, timeout })

    // Find latest clock
    const clock = entries.reduce((clock, entry) => {
      if (entry.clock.time > clock.time) {
        return new Clock(entry.clock.id, entry.clock.time)
      }
      return clock
    }, new Clock(logData.id))

    const finalEntries = entries.slice().sort(Entry.compare)
    const heads = finalEntries.filter(e => logData.heads.includes(e.hash))
    return {
      id: logData.id,
      values: finalEntries,
      heads: heads,
      clock: clock
    }
  }

  /**
   * Create a log from an entry hash.
   * @param {IPFS} ipfs An IPFS instance
   * @param {string} hash The hash of the entry
   * @param {Object} options
   * @param {number} options.length How many items to include in the log
   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)
   * @param {function(hash, entry, parent, depth)} options.onProgressCallback
   * @param {number} options.timeout Timeout for fetching a log entry from IPFS
   */
  static async fromEntryHash (ipfs, hash, { length = -1, exclude, onProgressCallback, timeout }) {
    if (!isDefined(ipfs)) throw LogError.IpfsNotDefinedError()
    if (!isDefined(hash)) throw new Error("'hash' must be defined")
    // Convert input hash(s) to an array
    const hashes = Array.isArray(hash) ? hash : [hash]
    // Fetch given length, return size at least the given input entries
    length = length > -1 ? Math.max(length, 1) : length

    const entries = await EntryIO.fetchParallel(ipfs, hashes,
      { length, exclude, onProgressCallback, timeout })
    // Cap the result at the right size by taking the last n entries,
    // or if given length is -1, then take all
    const sliced = length > -1 ? last(entries, length) : entries
    return {
      values: sliced
    }
  }

  /**
   * Creates a log data from a JSON object, to be passed to a Log constructor
   *
   * @param {IPFS} ipfs An IPFS instance
   * @param {json} json A json object containing valid log data
   * @param {Object} options
   * @param {number} options.length How many entries to include
   * @param {number} options.timeout Maximum time to wait for each fetch operation, in ms
   * @param {function(hash, entry, parent, depth)} options.onProgressCallback
   **/
  static async fromJSON (ipfs, json, { length = -1, timeout, onProgressCallback }) {
    if (!isDefined(ipfs)) throw LogError.IPFSNotDefinedError()
    const headHashes = json.heads.map(e => e.hash)
    const entries = await EntryIO.fetchParallel(ipfs, headHashes,
      { length, exclude: [], concurrency: 16, timeout, onProgressCallback })
    const finalEntries = entries.slice().sort(Entry.compare)
    return {
      id: json.id,
      values: finalEntries,
      heads: json.heads
    }
  }

  /**
   * Create a new log starting from an entry.
   * @param {IPFS} ipfs An IPFS instance
   * @param {Entry|Array<Entry>} sourceEntries An entry or an array of entries to fetch a log from
   * @param {Object} options
   * @param {number} options.length How many entries to include
   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)
   * @param {function(hash, entry, parent, depth)} options.onProgressCallback
   */
  static async fromEntry (ipfs, sourceEntries, { length = -1, exclude, onProgressCallback, timeout }) {
    if (!isDefined(ipfs)) throw LogError.IPFSNotDefinedError()
    if (!isDefined(sourceEntries)) throw new Error("'sourceEntries' must be defined")

    // Make sure we only have Entry objects as input
    if (!Array.isArray(sourceEntries) && !Entry.isEntry(sourceEntries)) {
      throw new Error(`'sourceEntries' argument must be an array of Entry instances or a single Entry`)
    }

    if (!Array.isArray(sourceEntries)) {
      sourceEntries = [sourceEntries]
    }

    // Fetch given length, return size at least the given input entries
    length = length > -1 ? Math.max(length, sourceEntries.length) : length

    // Make sure we pass hashes instead of objects to the fetcher function
    const hashes = sourceEntries.map(e => e.hash)

    // Fetch the entries
    const entries = await EntryIO.fetchParallel(ipfs, hashes,
      { length, exclude, onProgressCallback, timeout })

    // Combine the fetches with the source entries and take only uniques
    const combined = sourceEntries.concat(entries)
    const uniques = findUniques(combined, 'hash').sort(Entry.compare)

    // Cap the result at the right size by taking the last n entries
    const sliced = uniques.slice(length > -1 ? -length : -uniques.length)

    // Make sure that the given input entries are present in the result
    // in order to not lose references
    const missingSourceEntries = difference(sliced, sourceEntries, 'hash')

    const replaceInFront = (a, withEntries) => {
      var sliced = a.slice(withEntries.length, a.length)
      return withEntries.concat(sliced)
    }

    // Add the input entries at the beginning of the array and remove
    // as many elements from the array before inserting the original entries
    const result = replaceInFront(sliced, missingSourceEntries)
    return {
      id: result[result.length - 1].id,
      values: result
    }
  }
}

module.exports = LogIO

      };
    };
  }
}, {package:"ipfs-log",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/log-io.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/entry.js", {"./lamport-clock":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/lamport-clock.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/utils/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","json-stringify-deterministic":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-stringify-deterministic/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/entry.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const Clock = require('./lamport-clock')
const { isDefined, io } = require('./utils')
const stringify = require('json-stringify-deterministic')
const IPLD_LINKS = ['next']
const IpfsNotDefinedError = () => new Error('Ipfs instance not defined')
const writeFormats = {
  0: 'dag-pb',
  1: 'dag-cbor'
}

class Entry {
  /**
   * Create an Entry
   * @param {IPFS} ipfs An IPFS instance
   * @param {Identity} identity The identity instance
   * @param {string} logId The unique identifier for this log
   * @param {*} data Data of the entry to be added. Can be any JSON.stringifyable data
   * @param {Array<string|Entry>} [next=[]] Parent hashes or entries
   * @param {LamportClock} [clock] The lamport clock
   * @returns {Promise<Entry>}
   * @example
   * const entry = await Entry.create(ipfs, identity, 'hello')
   * console.log(entry)
   * // { hash: null, payload: "hello", next: [] }
   */
  static async create (ipfs, identity, logId, data, next = [], clock) {
    if (!isDefined(ipfs)) throw IpfsNotDefinedError()
    if (!isDefined(identity)) throw new Error('Identity is required, cannot create entry')
    if (!isDefined(logId)) throw new Error('Entry requires an id')
    if (!isDefined(data)) throw new Error('Entry requires data')
    if (!isDefined(next) || !Array.isArray(next)) throw new Error("'next' argument is not an array")

    // Clean the next objects and convert to hashes
    const toEntry = (e) => e.hash ? e.hash : e
    const nexts = next.filter(isDefined).map(toEntry)

    const entry = {
      hash: null, // "zd...Foo", we'll set the hash after persisting the entry
      id: logId, // For determining a unique chain
      payload: data, // Can be any JSON.stringifyable data
      next: nexts, // Array of hashes
      v: 1, // To tag the version of this data structure
      clock: clock || new Clock(identity.publicKey)
    }

    const signature = await identity.provider.sign(identity, Entry.toBuffer(entry))

    entry.key = identity.publicKey
    entry.identity = identity.toJSON()
    entry.sig = signature
    entry.hash = await Entry.toMultihash(ipfs, entry)

    return entry
  }

  /**
   * Verifies an entry signature.
   *
   * @param {IdentityProvider} identityProvider The identity provider to use
   * @param {Entry} entry The entry being verified
   * @return {Promise} A promise that resolves to a boolean value indicating if the signature is valid
   */
  static async verify (identityProvider, entry) {
    if (!identityProvider) throw new Error('Identity-provider is required, cannot verify entry')
    if (!Entry.isEntry(entry)) throw new Error('Invalid Log entry')
    if (!entry.key) throw new Error("Entry doesn't have a key")
    if (!entry.sig) throw new Error("Entry doesn't have a signature")

    const e = {
      hash: null,
      id: entry.id,
      payload: entry.payload,
      next: entry.next,
      v: entry.v,
      clock: entry.clock
    }

    return identityProvider.verify(entry.sig, entry.key, Entry.toBuffer(e), 'v' + entry.v)
  }

  /**
   * Transforms an entry into a Buffer.
   * @param {Entry} entry The entry
   * @return {Buffer} The buffer
   */
  static toBuffer (entry) {
    const stringifiedEntry = entry.v === 0 ? JSON.stringify(entry) : stringify(entry)
    return Buffer.from(stringifiedEntry)
  }

  /**
   * Get the multihash of an Entry.
   * @param {IPFS} ipfs An IPFS instance
   * @param {Entry} entry Entry to get a multihash for
   * @returns {Promise<string>}
   * @example
   * const multihash = await Entry.toMultihash(ipfs, entry)
   * console.log(multihash)
   * // "Qm...Foo"
   * @deprecated
   */
  static async toMultihash (ipfs, entry) {
    if (!ipfs) throw IpfsNotDefinedError()
    if (!Entry.isEntry(entry)) throw new Error('Invalid object format, cannot generate entry hash')

    // Ensure `entry` follows the correct format
    const e = {
      hash: null,
      id: entry.id,
      payload: entry.payload,
      next: entry.next,
      v: entry.v,
      clock: entry.clock
    }

    if (entry.key) Object.assign(e, { key: entry.key })
    if (entry.identity) Object.assign(e, { identity: entry.identity })
    if (entry.sig) Object.assign(e, { sig: entry.sig })

    return io.write(ipfs, writeFormats[e.v], e, { links: IPLD_LINKS })
  }

  /**
   * Create an Entry from a hash.
   * @param {IPFS} ipfs An IPFS instance
   * @param {string} hash The hash to create an Entry from
   * @returns {Promise<Entry>}
   * @example
   * const entry = await Entry.fromMultihash(ipfs, "zd...Foo")
   * console.log(entry)
   * // { hash: "Zd...Foo", payload: "hello", next: [] }
   */
  static async fromMultihash (ipfs, hash) {
    if (!ipfs) throw IpfsNotDefinedError()
    if (!hash) throw new Error(`Invalid hash: ${hash}`)

    const e = await io.read(ipfs, hash, { links: IPLD_LINKS })

    let entry = {
      hash: hash,
      id: e.id,
      payload: e.payload,
      next: e.next,
      v: e.v,
      clock: new Clock(e.clock.id, e.clock.time)
    }

    if (e.key) Object.assign(entry, { key: e.key })
    if (e.identity) Object.assign(entry, { identity: e.identity })
    if (e.sig) Object.assign(entry, { sig: e.sig })

    return entry
  }

  /**
   * Check if an object is an Entry.
   * @param {Entry} obj
   * @returns {boolean}
   */
  static isEntry (obj) {
    return obj && obj.id !== undefined &&
      obj.next !== undefined &&
      obj.payload !== undefined &&
      obj.v !== undefined &&
      obj.hash !== undefined &&
      obj.clock !== undefined
  }

  /**
   * Compares two entries.
   * @param {Entry} a
   * @param {Entry} b
   * @returns {number} 1 if a is greater, -1 is b is greater
   */
  static compare (a, b) {
    var distance = Clock.compare(a.clock, b.clock)
    if (distance === 0) return a.clock.id < b.clock.id ? -1 : 1
    return distance
  }

  /**
   * Check if an entry equals another entry.
   * @param {Entry} a
   * @param {Entry} b
   * @returns {boolean}
   */
  static isEqual (a, b) {
    return a.hash === b.hash
  }

  /**
   * Check if an entry is a parent to another entry.
   * @param {Entry} entry1 Entry to check
   * @param {Entry} entry2 The parent Entry
   * @returns {boolean}
   */
  static isParent (entry1, entry2) {
    return entry2.next.indexOf(entry1.hash) > -1
  }

  /**
   * Find entry's children from an Array of entries.
   * Returns entry's children as an Array up to the last know child.
   * @param {Entry} entry Entry for which to find the parents
   * @param {Array<Entry>} values Entries to search parents from
   * @returns {Array<Entry>}
   */
  static findChildren (entry, values) {
    var stack = []
    var parent = values.find((e) => Entry.isParent(entry, e))
    var prev = entry
    while (parent) {
      stack.push(parent)
      prev = parent
      parent = values.find((e) => Entry.isParent(prev, e))
    }
    stack = stack.sort((a, b) => a.clock.time > b.clock.time)
    return stack
  }
}

module.exports = Entry

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs-log",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/entry.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/node_modules/did-jwt/node_modules/js-sha3/src/sha3.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/node_modules/did-jwt/node_modules/js-sha3/src/sha3.js
      return function (require, module, exports) {
(function (process){(function (){
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var INPUT_ERROR = 'input is invalid type';
  var FINALIZE_ERROR = 'finalize already called';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_SHA3_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === 'object' && module.exports;
  var AMD = typeof define === 'function' && define.amd;
  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
  var KECCAK_PADDING = [1, 256, 65536, 16777216];
  var PADDING = [6, 1536, 393216, 100663296];
  var SHIFT = [0, 8, 16, 24];
  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  var BITS = [224, 256, 384, 512];
  var SHAKE_BITS = [128, 256];
  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
  var CSHAKE_BYTEPAD = {
    '128': 168,
    '256': 136
  };

  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (bits, padding, outputType) {
    return function (message) {
      return new Keccak(bits, padding, bits).update(message)[outputType]();
    };
  };

  var createShakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits) {
      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
    };
  };

  var createCshakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits, n, s) {
      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
    };
  };

  var createKmacOutputMethod = function (bits, padding, outputType) {
    return function (key, message, outputBits, s) {
      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
    };
  };

  var createOutputMethods = function (method, createMethod, bits, padding) {
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createMethod(bits, padding, type);
    }
    return method;
  };

  var createMethod = function (bits, padding) {
    var method = createOutputMethod(bits, padding, 'hex');
    method.create = function () {
      return new Keccak(bits, padding, bits);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    return createOutputMethods(method, createOutputMethod, bits, padding);
  };

  var createShakeMethod = function (bits, padding) {
    var method = createShakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits) {
      return new Keccak(bits, padding, outputBits);
    };
    method.update = function (message, outputBits) {
      return method.create(outputBits).update(message);
    };
    return createOutputMethods(method, createShakeOutputMethod, bits, padding);
  };

  var createCshakeMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createCshakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits, n, s) {
      if (!n && !s) {
        return methods['shake' + bits].create(outputBits);
      } else {
        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
      }
    };
    method.update = function (message, outputBits, n, s) {
      return method.create(outputBits, n, s).update(message);
    };
    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
  };

  var createKmacMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createKmacOutputMethod(bits, padding, 'hex');
    method.create = function (key, outputBits, s) {
      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
    };
    method.update = function (key, message, outputBits, s) {
      return method.create(key, outputBits, s).update(message);
    };
    return createOutputMethods(method, createKmacOutputMethod, bits, padding);
  };

  var algorithms = [
    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
  ];

  var methods = {}, methodNames = [];

  for (var i = 0; i < algorithms.length; ++i) {
    var algorithm = algorithms[i];
    var bits = algorithm.bits;
    for (var j = 0; j < bits.length; ++j) {
      var methodName = algorithm.name + '_' + bits[j];
      methodNames.push(methodName);
      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
      if (algorithm.name !== 'sha3') {
        var newMethodName = algorithm.name + bits[j];
        methodNames.push(newMethodName);
        methods[newMethodName] = methods[methodName];
      }
    }
  }

  function Keccak(bits, padding, outputBits) {
    this.blocks = [];
    this.s = [];
    this.padding = padding;
    this.outputBits = outputBits;
    this.reset = true;
    this.finalized = false;
    this.block = 0;
    this.start = 0;
    this.blockCount = (1600 - (bits << 1)) >> 5;
    this.byteCount = this.blockCount << 2;
    this.outputBlocks = outputBits >> 5;
    this.extraBytes = (outputBits & 31) >> 3;

    for (var i = 0; i < 50; ++i) {
      this.s[i] = 0;
    }
  }

  Keccak.prototype.update = function (message) {
    if (this.finalized) {
      throw new Error(FINALIZE_ERROR);
    }
    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,
      blockCount = this.blockCount, index = 0, s = this.s, i, code;

    while (index < length) {
      if (this.reset) {
        this.reset = false;
        blocks[0] = this.block;
        for (i = 1; i < blockCount + 1; ++i) {
          blocks[i] = 0;
        }
      }
      if (notString) {
        for (i = this.start; index < length && i < byteCount; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < byteCount; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }
      this.lastByteIndex = i;
      if (i >= byteCount) {
        this.start = i - byteCount;
        this.block = blocks[blockCount];
        for (i = 0; i < blockCount; ++i) {
          s[i] ^= blocks[i];
        }
        f(s);
        this.reset = true;
      } else {
        this.start = i;
      }
    }
    return this;
  };

  Keccak.prototype.encode = function (x, right) {
    var o = x & 255, n = 1;
    var bytes = [o];
    x = x >> 8;
    o = x & 255;
    while (o > 0) {
      bytes.unshift(o);
      x = x >> 8;
      o = x & 255;
      ++n;
    }
    if (right) {
      bytes.push(n);
    } else {
      bytes.unshift(n);
    }
    this.update(bytes);
    return bytes.length;
  };

  Keccak.prototype.encodeString = function (str) {
    var notString, type = typeof str;
    if (type !== 'string') {
      if (type === 'object') {
        if (str === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
          str = new Uint8Array(str);
        } else if (!Array.isArray(str)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var bytes = 0, length = str.length;
    if (notString) {
      bytes = length;
    } else {
      for (var i = 0; i < str.length; ++i) {
        var code = str.charCodeAt(i);
        if (code < 0x80) {
          bytes += 1;
        } else if (code < 0x800) {
          bytes += 2;
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes += 3;
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
          bytes += 4;
        }
      }
    }
    bytes += this.encode(bytes * 8);
    this.update(str);
    return bytes;
  };

  Keccak.prototype.bytepad = function (strs, w) {
    var bytes = this.encode(w);
    for (var i = 0; i < strs.length; ++i) {
      bytes += this.encodeString(strs[i]);
    }
    var paddingBytes = w - bytes % w;
    var zeros = [];
    zeros.length = paddingBytes;
    this.update(zeros);
    return this;
  };

  Keccak.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
    blocks[i >> 2] |= this.padding[i & 3];
    if (this.lastByteIndex === this.byteCount) {
      blocks[0] = blocks[blockCount];
      for (i = 1; i < blockCount + 1; ++i) {
        blocks[i] = 0;
      }
    }
    blocks[blockCount - 1] |= 0x80000000;
    for (i = 0; i < blockCount; ++i) {
      s[i] ^= blocks[i];
    }
    f(s);
  };

  Keccak.prototype.toString = Keccak.prototype.hex = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var hex = '', block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        block = s[i];
        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
      }
      if (j % blockCount === 0) {
        f(s);
        i = 0;
      }
    }
    if (extraBytes) {
      block = s[i];
      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
      if (extraBytes > 1) {
        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
      }
      if (extraBytes > 2) {
        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
      }
    }
    return hex;
  };

  Keccak.prototype.arrayBuffer = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var bytes = this.outputBits >> 3;
    var buffer;
    if (extraBytes) {
      buffer = new ArrayBuffer((outputBlocks + 1) << 2);
    } else {
      buffer = new ArrayBuffer(bytes);
    }
    var array = new Uint32Array(buffer);
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        array[j] = s[i];
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      array[i] = s[i];
      buffer = buffer.slice(0, bytes);
    }
    return buffer;
  };

  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

  Keccak.prototype.digest = Keccak.prototype.array = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var array = [], offset, block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        offset = j << 2;
        block = s[i];
        array[offset] = block & 0xFF;
        array[offset + 1] = (block >> 8) & 0xFF;
        array[offset + 2] = (block >> 16) & 0xFF;
        array[offset + 3] = (block >> 24) & 0xFF;
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      offset = j << 2;
      block = s[i];
      array[offset] = block & 0xFF;
      if (extraBytes > 1) {
        array[offset + 1] = (block >> 8) & 0xFF;
      }
      if (extraBytes > 2) {
        array[offset + 2] = (block >> 16) & 0xFF;
      }
    }
    return array;
  };

  function Kmac(bits, padding, outputBits) {
    Keccak.call(this, bits, padding, outputBits);
  }

  Kmac.prototype = new Keccak();

  Kmac.prototype.finalize = function () {
    this.encode(this.outputBits, true);
    return Keccak.prototype.finalize.call(this);
  };

  var f = function (s) {
    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
    for (n = 0; n < 48; n += 2) {
      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
      s[0] ^= h;
      s[1] ^= l;
      s[10] ^= h;
      s[11] ^= l;
      s[20] ^= h;
      s[21] ^= l;
      s[30] ^= h;
      s[31] ^= l;
      s[40] ^= h;
      s[41] ^= l;
      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
      s[2] ^= h;
      s[3] ^= l;
      s[12] ^= h;
      s[13] ^= l;
      s[22] ^= h;
      s[23] ^= l;
      s[32] ^= h;
      s[33] ^= l;
      s[42] ^= h;
      s[43] ^= l;
      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
      s[4] ^= h;
      s[5] ^= l;
      s[14] ^= h;
      s[15] ^= l;
      s[24] ^= h;
      s[25] ^= l;
      s[34] ^= h;
      s[35] ^= l;
      s[44] ^= h;
      s[45] ^= l;
      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
      s[6] ^= h;
      s[7] ^= l;
      s[16] ^= h;
      s[17] ^= l;
      s[26] ^= h;
      s[27] ^= l;
      s[36] ^= h;
      s[37] ^= l;
      s[46] ^= h;
      s[47] ^= l;
      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
      s[8] ^= h;
      s[9] ^= l;
      s[18] ^= h;
      s[19] ^= l;
      s[28] ^= h;
      s[29] ^= l;
      s[38] ^= h;
      s[39] ^= l;
      s[48] ^= h;
      s[49] ^= l;

      b0 = s[0];
      b1 = s[1];
      b32 = (s[11] << 4) | (s[10] >>> 28);
      b33 = (s[10] << 4) | (s[11] >>> 28);
      b14 = (s[20] << 3) | (s[21] >>> 29);
      b15 = (s[21] << 3) | (s[20] >>> 29);
      b46 = (s[31] << 9) | (s[30] >>> 23);
      b47 = (s[30] << 9) | (s[31] >>> 23);
      b28 = (s[40] << 18) | (s[41] >>> 14);
      b29 = (s[41] << 18) | (s[40] >>> 14);
      b20 = (s[2] << 1) | (s[3] >>> 31);
      b21 = (s[3] << 1) | (s[2] >>> 31);
      b2 = (s[13] << 12) | (s[12] >>> 20);
      b3 = (s[12] << 12) | (s[13] >>> 20);
      b34 = (s[22] << 10) | (s[23] >>> 22);
      b35 = (s[23] << 10) | (s[22] >>> 22);
      b16 = (s[33] << 13) | (s[32] >>> 19);
      b17 = (s[32] << 13) | (s[33] >>> 19);
      b48 = (s[42] << 2) | (s[43] >>> 30);
      b49 = (s[43] << 2) | (s[42] >>> 30);
      b40 = (s[5] << 30) | (s[4] >>> 2);
      b41 = (s[4] << 30) | (s[5] >>> 2);
      b22 = (s[14] << 6) | (s[15] >>> 26);
      b23 = (s[15] << 6) | (s[14] >>> 26);
      b4 = (s[25] << 11) | (s[24] >>> 21);
      b5 = (s[24] << 11) | (s[25] >>> 21);
      b36 = (s[34] << 15) | (s[35] >>> 17);
      b37 = (s[35] << 15) | (s[34] >>> 17);
      b18 = (s[45] << 29) | (s[44] >>> 3);
      b19 = (s[44] << 29) | (s[45] >>> 3);
      b10 = (s[6] << 28) | (s[7] >>> 4);
      b11 = (s[7] << 28) | (s[6] >>> 4);
      b42 = (s[17] << 23) | (s[16] >>> 9);
      b43 = (s[16] << 23) | (s[17] >>> 9);
      b24 = (s[26] << 25) | (s[27] >>> 7);
      b25 = (s[27] << 25) | (s[26] >>> 7);
      b6 = (s[36] << 21) | (s[37] >>> 11);
      b7 = (s[37] << 21) | (s[36] >>> 11);
      b38 = (s[47] << 24) | (s[46] >>> 8);
      b39 = (s[46] << 24) | (s[47] >>> 8);
      b30 = (s[8] << 27) | (s[9] >>> 5);
      b31 = (s[9] << 27) | (s[8] >>> 5);
      b12 = (s[18] << 20) | (s[19] >>> 12);
      b13 = (s[19] << 20) | (s[18] >>> 12);
      b44 = (s[29] << 7) | (s[28] >>> 25);
      b45 = (s[28] << 7) | (s[29] >>> 25);
      b26 = (s[38] << 8) | (s[39] >>> 24);
      b27 = (s[39] << 8) | (s[38] >>> 24);
      b8 = (s[48] << 14) | (s[49] >>> 18);
      b9 = (s[49] << 14) | (s[48] >>> 18);

      s[0] = b0 ^ (~b2 & b4);
      s[1] = b1 ^ (~b3 & b5);
      s[10] = b10 ^ (~b12 & b14);
      s[11] = b11 ^ (~b13 & b15);
      s[20] = b20 ^ (~b22 & b24);
      s[21] = b21 ^ (~b23 & b25);
      s[30] = b30 ^ (~b32 & b34);
      s[31] = b31 ^ (~b33 & b35);
      s[40] = b40 ^ (~b42 & b44);
      s[41] = b41 ^ (~b43 & b45);
      s[2] = b2 ^ (~b4 & b6);
      s[3] = b3 ^ (~b5 & b7);
      s[12] = b12 ^ (~b14 & b16);
      s[13] = b13 ^ (~b15 & b17);
      s[22] = b22 ^ (~b24 & b26);
      s[23] = b23 ^ (~b25 & b27);
      s[32] = b32 ^ (~b34 & b36);
      s[33] = b33 ^ (~b35 & b37);
      s[42] = b42 ^ (~b44 & b46);
      s[43] = b43 ^ (~b45 & b47);
      s[4] = b4 ^ (~b6 & b8);
      s[5] = b5 ^ (~b7 & b9);
      s[14] = b14 ^ (~b16 & b18);
      s[15] = b15 ^ (~b17 & b19);
      s[24] = b24 ^ (~b26 & b28);
      s[25] = b25 ^ (~b27 & b29);
      s[34] = b34 ^ (~b36 & b38);
      s[35] = b35 ^ (~b37 & b39);
      s[44] = b44 ^ (~b46 & b48);
      s[45] = b45 ^ (~b47 & b49);
      s[6] = b6 ^ (~b8 & b0);
      s[7] = b7 ^ (~b9 & b1);
      s[16] = b16 ^ (~b18 & b10);
      s[17] = b17 ^ (~b19 & b11);
      s[26] = b26 ^ (~b28 & b20);
      s[27] = b27 ^ (~b29 & b21);
      s[36] = b36 ^ (~b38 & b30);
      s[37] = b37 ^ (~b39 & b31);
      s[46] = b46 ^ (~b48 & b40);
      s[47] = b47 ^ (~b49 & b41);
      s[8] = b8 ^ (~b0 & b2);
      s[9] = b9 ^ (~b1 & b3);
      s[18] = b18 ^ (~b10 & b12);
      s[19] = b19 ^ (~b11 & b13);
      s[28] = b28 ^ (~b20 & b22);
      s[29] = b29 ^ (~b21 & b23);
      s[38] = b38 ^ (~b30 & b32);
      s[39] = b39 ^ (~b31 & b33);
      s[48] = b48 ^ (~b40 & b42);
      s[49] = b49 ^ (~b41 & b43);

      s[0] ^= RC[n];
      s[1] ^= RC[n + 1];
    }
  };

  if (COMMON_JS) {
    module.exports = methods;
  } else {
    for (i = 0; i < methodNames.length; ++i) {
      root[methodNames[i]] = methods[methodNames[i]];
    }
    if (AMD) {
      define(function () {
        return methods;
      });
    }
  }
})();

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"js-sha3",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/node_modules/did-jwt/node_modules/js-sha3/src/sha3.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-resolver/lib/resolver.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/did-resolver/lib/resolver.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var globalObject;
var REGISTRY;
if (typeof window === 'object') {
    globalObject = window;
}
else if (typeof global === 'object') {
    globalObject = global;
}
else {
    globalObject = {
        DID_REGISTRY: {}
    };
}
if (globalObject.DID_REGISTRY) {
    REGISTRY = globalObject.DID_REGISTRY;
}
else {
    REGISTRY = globalObject.DID_REGISTRY = {};
}
function registerMethod(method, resolver) {
    REGISTRY[method] = resolver;
}
exports.registerMethod = registerMethod;
function parse(did) {
    if (did === '')
        throw new Error('Missing DID');
    var sections = did.match(/^did:([a-zA-Z0-9_]+):([[a-zA-Z0-9_.-]+)(\/[^#]*)?(#.*)?$/);
    if (sections) {
        var parts = { did: sections[0], method: sections[1], id: sections[2] };
        if (sections[3])
            parts.path = sections[3];
        if (sections[4])
            parts.fragment = sections[4].slice(1);
        return parts;
    }
    throw new Error("Invalid DID " + did);
}
exports.parse = parse;
function resolve(did) {
    return __awaiter(this, void 0, void 0, function () {
        var parsed, resolver;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    parsed = parse(did);
                    resolver = REGISTRY[parsed.method];
                    if (!resolver) return [3 /*break*/, 2];
                    return [4 /*yield*/, resolver(did, parsed)];
                case 1: return [2 /*return*/, _a.sent()];
                case 2: throw new Error("Unsupported DID method: '" + parsed.method + "'");
            }
        });
    });
}
exports.default = resolve;
//# sourceMappingURL=resolver.js.map
      };
    };
  }
}, {package:"did-resolver",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-resolver/lib/resolver.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@stablelib/utf8/lib/utf8.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@stablelib/utf8/lib/utf8.js
      return function (require, module, exports) {
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
var INVALID_UTF16 = "utf8: invalid string";
var INVALID_UTF8 = "utf8: invalid source encoding";
/**
 * Encodes the given string into UTF-8 byte array.
 * Throws if the source string has invalid UTF-16 encoding.
 */
function encode(s) {
    // Calculate result length and allocate output array.
    // encodedLength() also validates string and throws errors,
    // so we don't need repeat validation here.
    var arr = new Uint8Array(encodedLength(s));
    var pos = 0;
    for (var i = 0; i < s.length; i++) {
        var c = s.charCodeAt(i);
        if (c < 0x80) {
            arr[pos++] = c;
        }
        else if (c < 0x800) {
            arr[pos++] = 0xc0 | c >> 6;
            arr[pos++] = 0x80 | c & 0x3f;
        }
        else if (c < 0xd800) {
            arr[pos++] = 0xe0 | c >> 12;
            arr[pos++] = 0x80 | (c >> 6) & 0x3f;
            arr[pos++] = 0x80 | c & 0x3f;
        }
        else {
            i++; // get one more character
            c = (c & 0x3ff) << 10;
            c |= s.charCodeAt(i) & 0x3ff;
            c += 0x10000;
            arr[pos++] = 0xf0 | c >> 18;
            arr[pos++] = 0x80 | (c >> 12) & 0x3f;
            arr[pos++] = 0x80 | (c >> 6) & 0x3f;
            arr[pos++] = 0x80 | c & 0x3f;
        }
    }
    return arr;
}
exports.encode = encode;
/**
 * Returns the number of bytes required to encode the given string into UTF-8.
 * Throws if the source string has invalid UTF-16 encoding.
 */
function encodedLength(s) {
    var result = 0;
    for (var i = 0; i < s.length; i++) {
        var c = s.charCodeAt(i);
        if (c < 0x80) {
            result += 1;
        }
        else if (c < 0x800) {
            result += 2;
        }
        else if (c < 0xd800) {
            result += 3;
        }
        else if (c <= 0xdfff) {
            if (i >= s.length - 1) {
                throw new Error(INVALID_UTF16);
            }
            i++; // "eat" next character
            result += 4;
        }
        else {
            throw new Error(INVALID_UTF16);
        }
    }
    return result;
}
exports.encodedLength = encodedLength;
/**
 * Decodes the given byte array from UTF-8 into a string.
 * Throws if encoding is invalid.
 */
function decode(arr) {
    var chars = [];
    for (var i = 0; i < arr.length; i++) {
        var b = arr[i];
        if (b & 0x80) {
            var min = void 0;
            if (b < 0xe0) {
                // Need 1 more byte.
                if (i >= arr.length) {
                    throw new Error(INVALID_UTF8);
                }
                var n1 = arr[++i];
                if ((n1 & 0xc0) !== 0x80) {
                    throw new Error(INVALID_UTF8);
                }
                b = (b & 0x1f) << 6 | (n1 & 0x3f);
                min = 0x80;
            }
            else if (b < 0xf0) {
                // Need 2 more bytes.
                if (i >= arr.length - 1) {
                    throw new Error(INVALID_UTF8);
                }
                var n1 = arr[++i];
                var n2 = arr[++i];
                if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80) {
                    throw new Error(INVALID_UTF8);
                }
                b = (b & 0x0f) << 12 | (n1 & 0x3f) << 6 | (n2 & 0x3f);
                min = 0x800;
            }
            else if (b < 0xf8) {
                // Need 3 more bytes.
                if (i >= arr.length - 2) {
                    throw new Error(INVALID_UTF8);
                }
                var n1 = arr[++i];
                var n2 = arr[++i];
                var n3 = arr[++i];
                if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80 || (n3 & 0xc0) !== 0x80) {
                    throw new Error(INVALID_UTF8);
                }
                b = (b & 0x0f) << 18 | (n1 & 0x3f) << 12 | (n2 & 0x3f) << 6 | (n3 & 0x3f);
                min = 0x10000;
            }
            else {
                throw new Error(INVALID_UTF8);
            }
            if (b < min || (b >= 0xd800 && b <= 0xdfff)) {
                throw new Error(INVALID_UTF8);
            }
            if (b >= 0x10000) {
                // Surrogate pair.
                if (b > 0x10ffff) {
                    throw new Error(INVALID_UTF8);
                }
                b -= 0x10000;
                chars.push(String.fromCharCode(0xd800 | (b >> 10)));
                b = 0xdc00 | (b & 0x3ff);
            }
        }
        chars.push(String.fromCharCode(b));
    }
    return chars.join("");
}
exports.decode = decode;
//# sourceMappingURL=utf8.js.map
      };
    };
  }
}, {package:"@stablelib/utf8",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@stablelib/utf8/lib/utf8.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/uport-base64url/index.js", {"./dist/base64url":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uport-base64url/dist/base64url.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/uport-base64url/index.js
      return function (require, module, exports) {
module.exports = require('./dist/base64url').default;
module.exports.default = module.exports;

      };
    };
  }
}, {package:"uport-base64url",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uport-base64url/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/src/identities.js", {"./identity":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/src/identity.js","./orbit-db-identity-provider":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/src/orbit-db-identity-provider.js","orbit-db-keystore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/index-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/src/identities.js
      return function (require, module, exports) {
'use strict'
const Identity = require('./identity')
const OrbitDBIdentityProvider = require('./orbit-db-identity-provider')
const Keystore = require('orbit-db-keystore')
const type = 'orbitdb'
const identityKeysPath = './orbitdb/identity/identitykeys'
const supportedTypes = {
  orbitdb: OrbitDBIdentityProvider
}

const getHandlerFor = (type) => {
  if (!Identities.isSupported(type)) {
    throw new Error(`IdentityProvider type '${type}' is not supported`)
  }
  return supportedTypes[type]
}

class Identities {
  constructor (keystore) {
    this._keystore = keystore
  }

  async sign (identity, data) {
    const signingKey = await this._keystore.getKey(identity.id)
    if (!signingKey) {
      throw new Error(`Private signing key not found from Keystore`)
    }
    const sig = await this._keystore.sign(signingKey, data)
    return sig
  }

  async verify (signature, publicKey, data, verifier = 'v1') {
    return this._keystore.verify(signature, publicKey, data, verifier)
  }

  async createIdentity (options = {}) {
    const IdentityProvider = getHandlerFor(options.type)
    const identityProvider = new IdentityProvider(options)
    const id = await identityProvider.getId(options)
    if (options.migrate) {
      await options.migrate({ targetPath: this._keystore.path, targetId: id })
    }
    const { publicKey, idSignature } = await this.signId(id)
    const pubKeyIdSignature = await identityProvider.signIdentity(publicKey + idSignature, options)
    return new Identity(id, publicKey, idSignature, pubKeyIdSignature, IdentityProvider.type, this)
  }

  async signId (id) {
    const keystore = this._keystore
    const key = await keystore.getKey(id) || await keystore.createKey(id)
    const publicKey = keystore.getPublic(key)
    const idSignature = await keystore.sign(key, id)
    return { publicKey, idSignature }
  }

  async verifyIdentity (identity) {
    const verified = await this._keystore.verify(
      identity.signatures.id,
      identity.publicKey,
      identity.id
    )
    return verified && Identities.verifyIdentity(identity)
  }

  static async verifyIdentity (identity) {
    const IdentityProvider = getHandlerFor(identity.type)
    return IdentityProvider.verifyIdentity(identity)
  }

  static async createIdentity (options = {}) {
    const keystore = options.keystore || Keystore.create(options.identityKeysPath || identityKeysPath)
    options = Object.assign({}, { type }, options)
    const identities = new Identities(keystore)
    return identities.createIdentity(options)
  }

  static isSupported (type) {
    return Object.keys(supportedTypes).includes(type)
  }

  static addIdentityProvider (IdentityProvider) {
    if (!IdentityProvider) {
      throw new Error('IdentityProvider class needs to be given as an option')
    }

    if (!IdentityProvider.type ||
      typeof IdentityProvider.type !== 'string') {
      throw new Error('Given IdentityProvider class needs to implement: static get type() { /* return a string */}.')
    }

    supportedTypes[IdentityProvider.type] = IdentityProvider
  }

  static removeIdentityProvider (type) {
    delete supportedTypes[type]
  }
}

module.exports = Identities

      };
    };
  }
}, {package:"orbit-db-identity-provider",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/src/identities.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mini/src/lib/XMLHttpRequest-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mini/src/lib/XMLHttpRequest-browser.js
      return function (require, module, exports) {
const XMLHttpRequest = window.XMLHttpRequest; // eslint-disable-line

module.exports = XMLHttpRequest;

      };
    };
  }
}, {package:"ipfs-mini",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mini/src/lib/XMLHttpRequest-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/base64url/index.js", {"./dist/base64url":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/base64url/dist/base64url.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/base64url/index.js
      return function (require, module, exports) {
module.exports = require('./dist/base64url').default;
module.exports.default = module.exports;

      };
    };
  }
}, {package:"base64url",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/base64url/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/index.js", {"./JWT":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/JWT.js","./NaclSigner":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/NaclSigner.js","./SimpleSigner":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/SimpleSigner.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/index.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _SimpleSigner = _interopRequireDefault(require("./SimpleSigner"));

var _NaclSigner = _interopRequireDefault(require("./NaclSigner"));

var _JWT = require("./JWT");

module.exports = {
  SimpleSigner: _SimpleSigner.default,
  NaclSigner: _NaclSigner.default,
  verifyJWT: _JWT.verifyJWT,
  createJWT: _JWT.createJWT,
  decodeJWT: _JWT.decodeJWT
};
      };
    };
  }
}, {package:"did-jwt",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/did-jwt/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/access-controller-manifest.js", {"orbit-db-io":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-io/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/access-controller-manifest.js
      return function (require, module, exports) {
'use strict'
const io = require('orbit-db-io')

class AccessControllerManifest {
  constructor (type, params = {}) {
    this.type = type
    this.params = params
  }

  static async resolve (ipfs, manifestHash, options = {}) {
    if (options.skipManifest) {
      if (!options.type) {
        throw new Error(`No manifest, access-controller type required`)
      }
      return new AccessControllerManifest(options.type, { address: manifestHash })
    } else {
      // TODO: ensure this is a valid multihash
      if (manifestHash.indexOf('/ipfs') === 0) { manifestHash = manifestHash.split('/')[2] }
      const { type, params } = await io.read(ipfs, manifestHash)
      return new AccessControllerManifest(type, params)
    }
  }

  static async create (ipfs, type, params) {
    if (params.skipManifest) {
      return params.address
    }
    const manifest = {
      type: type,
      params: params
    }
    return io.write(ipfs, 'dag-cbor', manifest)
  }
}

module.exports = AccessControllerManifest

      };
    };
  }
}, {package:"orbit-db-access-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/access-controller-manifest.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/legacy-ipfs-access-controller.js", {"./access-controller-interface":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/access-controller-interface.js","orbit-db-io":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-io/index.js","safe-buffer/":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/legacy-ipfs-access-controller.js
      return function (require, module, exports) {
'use strict'
const io = require('orbit-db-io')
const Buffer = require('safe-buffer/').Buffer
const AccessController = require('./access-controller-interface')
const type = 'legacy-ipfs'

class LegacyIPFSAccessController extends AccessController {
  constructor (ipfs, options) {
    super()
    this._ipfs = ipfs
    this._write = Array.from(options.write || [])
  }

  // Returns the type of the access controller
  static get type () { return type }

  // Return a Set of keys that have `access` capability
  get write () {
    return this._write
  }

  async canAppend (entry, identityProvider) {
    // Allow if access list contain the writer's publicKey or is '*'
    const publicKey = entry.key
    if (this.write.includes(publicKey) ||
      this.write.includes('*')) {
      return true
    }
    return false
  }

  async load (address) {
    // Transform '/ipfs/QmPFtHi3cmfZerxtH9ySLdzpg1yFhocYDZgEZywdUXHxFU'
    // to 'QmPFtHi3cmfZerxtH9ySLdzpg1yFhocYDZgEZywdUXHxFU'
    if (address.indexOf('/ipfs') === 0) { address = address.split('/')[2] }

    try {
      const access = await io.read(this._ipfs, address)
      this._write = access.write
    } catch (e) {
      console.log('LegacyIPFSAccessController.load ERROR:', e)
    }
  }

  async save (options) {
    let cid
    const access = { admin: [], write: this.write, read: [] }
    try {
      cid = await io.write(this._ipfs, 'raw', Buffer.from(JSON.stringify(access, null, 2)), { format: 'dag-pb'})

    } catch (e) {
      console.log('LegacyIPFSAccessController.save ERROR:', e)
    }
    // return the manifest data
    return { address: cid, skipManifest: true }
  }

  static async create (orbitdb, options = {}) {
    options = { ...options, ...{ write: options.write || [orbitdb.identity.publicKey] } }
    return new LegacyIPFSAccessController(orbitdb._ipfs, options)
  }
}

module.exports = LegacyIPFSAccessController

      };
    };
  }
}, {package:"orbit-db-access-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/legacy-ipfs-access-controller.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/orbitdb-access-controller.js", {"./access-controller-interface":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/access-controller-interface.js","./utils/ensure-ac-address":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/utils/ensure-ac-address.js","p-map-series":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/p-map-series/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/orbitdb-access-controller.js
      return function (require, module, exports) {
'use strict'

const pMapSeries = require('p-map-series')
const AccessController = require('./access-controller-interface')
const ensureAddress = require('./utils/ensure-ac-address')

const type = 'orbitdb'

class OrbitDBAccessController extends AccessController {
  constructor (orbitdb, options) {
    super()
    this._orbitdb = orbitdb
    this._db = null
    this._options = options || {}
  }

  // Returns the type of the access controller
  static get type () { return type }

  // Returns the address of the OrbitDB used as the AC
  get address () {
    return this._db.address
  }

  // Return true if entry is allowed to be added to the database
  async canAppend (entry, identityProvider) {
    // Write keys and admins keys are allowed
    const access = new Set([...this.get('write'), ...this.get('admin')])
    // If the ACL contains the writer's public key or it contains '*'
    if (access.has(entry.identity.id) || access.has('*')) {
      const verifiedIdentity = await identityProvider.verifyIdentity(entry.identity)
      // Allow access if identity verifies
      return verifiedIdentity
    }

    return false
  }

  get capabilities () {
    if (this._db) {
      let capabilities = this._db.index

      const toSet = (e) => {
        const key = e[0]
        capabilities[key] = new Set([...(capabilities[key] || []), ...e[1]])
      }

      // Merge with the access controller of the database
      // and make sure all values are Sets
      Object.entries({
        ...capabilities,
        // Add the root access controller's 'write' access list
        // as admins on this controller
        ...{ admin: new Set([...(capabilities.admin || []), ...this._db.access.write])
        }
      }).forEach(toSet)

      return capabilities
    }
    return {}
  }

  get (capability) {
    return this.capabilities[capability] || new Set([])
  }

  async close () {
    await this._db.close()
  }

  async load (address) {
    if (this._db) { await this._db.close() }

    // Force '<address>/_access' naming for the database
    this._db = await this._orbitdb.keyvalue(ensureAddress(address), {
      // use ipfs controller as a immutable "root controller"
      accessController: {
        type: 'ipfs',
        write: this._options.admin || [this._orbitdb.identity.id]
      },
      sync: true
    })

    this._db.events.on('ready', this._onUpdate.bind(this))
    this._db.events.on('write', this._onUpdate.bind(this))
    this._db.events.on('replicated', this._onUpdate.bind(this))

    await this._db.load()
  }

  async save () {
    // return the manifest data
    return {
      address: this._db.address.toString()
    }
  }

  async grant (capability, key) {
    // Merge current keys with the new key
    const capabilities = new Set([...(this._db.get(capability) || []), ...[key]])
    await this._db.put(capability, Array.from(capabilities.values()))
  }

  async revoke (capability, key) {
    let capabilities = new Set(this._db.get(capability) || [])
    capabilities.delete(key)
    if (capabilities.size > 0) {
      await this._db.put(capability, Array.from(capabilities.values()))
    } else {
      await this._db.del(capability)
    }
  }

  /* Private methods */
  _onUpdate () {
    this.emit('updated')
  }

  /* Factory */
  static async create (orbitdb, options = {}) {
    const ac = new OrbitDBAccessController(orbitdb, options)
    await ac.load(options.address || options.name || 'default-access-controller')

    // Add write access from options
    if (options.write && !options.address) {
      await pMapSeries(options.write, async (e) => ac.grant('write', e))
    }

    return ac
  }
}

module.exports = OrbitDBAccessController

      };
    };
  }
}, {package:"orbit-db-access-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/orbitdb-access-controller.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/ipfs-access-controller.js", {"./access-controller-interface":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/access-controller-interface.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/utils/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/ipfs-access-controller.js
      return function (require, module, exports) {
'use strict'
const { io } = require('./utils')
const AccessController = require('./access-controller-interface')
const type = 'ipfs'

class IPFSAccessController extends AccessController {
  constructor (ipfs, options) {
    super()
    this._ipfs = ipfs
    this._write = Array.from(options.write || [])
  }

  // Returns the type of the access controller
  static get type () { return type }

  // Return a Set of keys that have `access` capability
  get write () {
    return this._write
  }

  async canAppend (entry, identityProvider) {
    // Allow if access list contain the writer's publicKey or is '*'
    const key = entry.identity.id
    if (this.write.includes(key) || this.write.includes('*')) {
      //check identity is valid
      return identityProvider.verifyIdentity(entry.identity)
    }
    return false
  }


  async load (address) {
    // Transform '/ipfs/QmPFtHi3cmfZerxtH9ySLdzpg1yFhocYDZgEZywdUXHxFU'
    // to 'QmPFtHi3cmfZerxtH9ySLdzpg1yFhocYDZgEZywdUXHxFU'
    if (address.indexOf('/ipfs') === 0) { address = address.split('/')[2] }

    try {
      this._write = await io.read(this._ipfs, address)
    } catch (e) {
      console.log('IPFSAccessController.load ERROR:', e)
    }
  }

  async save () {
    let cid
    try {

      cid = await io.write(this._ipfs, 'dag-cbor', { write: JSON.stringify(this.write, null, 2) })

    } catch (e) {
      console.log('IPFSAccessController.save ERROR:', e)
    }
    // return the manifest data
    return { address: cid }
  }

  static async create (orbitdb, options = {}) {
    options = { ...options, ...{ write: options.write || [orbitdb.identity.id] } }
    return new IPFSAccessController(orbitdb._ipfs, options)
  }
}

module.exports = IPFSAccessController

      };
    };
  }
}, {package:"orbit-db-access-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/ipfs-access-controller.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-io/index.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","ipld-dag-pb":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-io/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const CID = require('cids')
const dagPB = require('ipld-dag-pb')
const defaultBase = 'base58btc'

const cidifyString = (str) => {
  if (!str) {
    return str
  }

  if (Array.isArray(str)) {
    return str.map(cidifyString)
  }

  return new CID(str)
}

const stringifyCid = (cid, options) => {
  if (!cid) {
    return cid
  }

  if (Array.isArray(cid)) {
    return cid.map(stringifyCid)
  }
  
  if (cid['/']) {
    return cid['/']
  }

  const base = options.base || defaultBase
  return cid.toBaseEncodedString(base)
}

const writePb = async (ipfs, obj) => {
  const buffer = Buffer.from(JSON.stringify(obj))
  const dagNode = dagPB.DAGNode.create(buffer)
  const cid = await ipfs.dag.put(dagNode, {
    format: 'dag-pb',
    hashAlg: 'sha2-256'
  })

  return cid.toV0().toBaseEncodedString()
}

const readPb = async (ipfs, cid) => {
  const result = await ipfs.dag.get(cid)
  const dagNode = result.value

  return JSON.parse(dagNode.toJSON().data)
}

const writeCbor = async (ipfs, obj, options) => {
  const dagNode = Object.assign({}, obj)
  const links = options.links || []
  links.forEach((prop) => {
    dagNode[prop] = cidifyString(dagNode[prop])
  })

  const base = options.base || defaultBase
  const onlyHash = options.onlyHash || false
  const cid = await ipfs.dag.put(dagNode, { onlyHash })
  return cid.toBaseEncodedString(base)
}

const readCbor = async (ipfs, cid, options) => {
  const result = await ipfs.dag.get(cid)
  const obj = result.value
  const links = options.links || []
  links.forEach((prop) => {
    obj[prop] = stringifyCid(obj[prop], options)
  })

  return obj
}

const writeObj = async (ipfs, obj, options) => {
  const onlyHash = options.onlyHash || false
  const base = options.base || defaultBase
  const opts = Object.assign({}, { onlyHash: onlyHash }, options.format ? { format: options.format, hashAlg: 'sha2-256' } : {})
  if (opts.format === 'dag-pb') {
    obj = dagPB.DAGNode.create(obj)
  }

  const cid = await ipfs.dag.put(obj, opts)
  return cid.toBaseEncodedString(base)
}

const formats = {
  'dag-pb': { read: readPb, write: writePb },
  'dag-cbor': { write: writeCbor, read: readCbor },
  'raw': { write: writeObj }
}

const write = (ipfs, codec, obj, options = {}) => {
  const format = formats[codec]
  if (!format) throw new Error('Unsupported codec')

  return format.write(ipfs, obj, options)
}

const read = (ipfs, cid, options = {}) => {
  cid = new CID(cid)
  const format = formats[cid.codec]

  if (!format) throw new Error('Unsupported codec')

  return format.read(ipfs, cid, options)
}

module.exports = {
  read,
  write
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"orbit-db-io",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-io/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/utils/ensure-ac-address.js", {"path":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/path-browserify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/utils/ensure-ac-address.js
      return function (require, module, exports) {
'use strict'
const path = require('path')
// Make sure the given address has '/_access' as the last part
const ensureAddress = address => {
  const suffix = address.toString().split('/').pop()
  return suffix === '_access'
    ? address
    : path.join(address, '/_access')
}
module.exports = ensureAddress

      };
    };
  }
}, {package:"orbit-db-access-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/utils/ensure-ac-address.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-feedstore/src/FeedIndex.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-feedstore/src/FeedIndex.js
      return function (require, module, exports) {
'use strict'

class FeedIndex {
  constructor() {
    this._index = {}
  }

  get() {
    return Object.keys(this._index).map((f) => this._index[f])
  }

  updateIndex(oplog) {
    this._index = {}
    oplog.values.reduce((handled, item) => {
      if(!handled.includes(item.hash)) {
        handled.push(item.hash)
        if(item.payload.op === 'ADD') {
          this._index[item.hash] = item
        } else if(item.payload.op === 'DEL') {
          delete this._index[item.payload.value]
        }
      }
      return handled
    }, [])
  }
}

module.exports = FeedIndex

      };
    };
  }
}, {package:"orbit-db-feedstore",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-feedstore/src/FeedIndex.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-kvstore/src/KeyValueIndex.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-kvstore/src/KeyValueIndex.js
      return function (require, module, exports) {
'use strict'

class KeyValueIndex {
  constructor() {
    this._index = {}
  }

  get(key) {
    return this._index[key]
  }

  updateIndex(oplog) {
    oplog.values
      .slice()
      .reverse()
      .reduce((handled, item) => {
        if(!handled.includes(item.payload.key)) {
          handled.push(item.payload.key)
          if(item.payload.op === 'PUT') {
            this._index[item.payload.key] = item.payload.value
          } else if(item.payload.op === 'DEL') {
            delete this._index[item.payload.key]
          }
        }
        return handled
      }, [])
  }
}

module.exports = KeyValueIndex

      };
    };
  }
}, {package:"orbit-db-kvstore",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-kvstore/src/KeyValueIndex.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/src/Store.js", {"./Index":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/src/Index.js","./Replicator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/src/Replicator.js","./replication-info":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/src/replication-info.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","ipfs-log":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/log.js","logplease":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/logplease/src/index.js","orbit-db-io":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-io/index.js","p-each-series":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/node_modules/p-each-series/index.js","readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/readable-stream/readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/src/Store.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const EventEmitter = require('events').EventEmitter
const Readable = require('readable-stream')
const mapSeries = require('p-each-series')
const Log = require('ipfs-log')
const Index = require('./Index')
const Replicator = require('./Replicator')
const ReplicationInfo = require('./replication-info')

const Logger = require('logplease')
const logger = Logger.create('orbit-db.store', { color: Logger.Colors.Blue })
Logger.setLogLevel('ERROR')
const dagNode = require('orbit-db-io')

const DefaultOptions = {
  Index: Index,
  maxHistory: -1,
  directory: './orbitdb',
  fetchEntryTimeout: null,
  replicate: true,
  referenceCount: 64,
  replicationConcurrency: 128,
  syncLocal: false,
  sortFn: undefined
}

class Store {
  constructor (ipfs, identity, address, options) {
    if (!identity) {
      throw new Error('Identity required')
    }

    // Set the options
    let opts = Object.assign({}, DefaultOptions)
    Object.assign(opts, options)
    this.options = opts

    // Default type
    this._type = 'store'

    // Create IDs, names and paths
    this.id = address.toString()
    this.identity = identity
    this.address = address
    this.dbname = address.path || ''
    this.events = new EventEmitter()

    // External dependencies
    this._ipfs = ipfs
    this._cache = options.cache

    // Access mapping
    const defaultAccess = {
      canAppend: (entry) => (entry.identity.publicKey === identity.publicKey)
    }
    this.access = options.accessController || defaultAccess

    // Create the operations log
    this._oplog = new Log(this._ipfs, this.identity, { logId: this.id, access: this.access, sortFn: this.options.sortFn })

    // Create the index
    this._index = new this.options.Index(this.address.root)

    // Replication progress info
    this._replicationStatus = new ReplicationInfo()

    // Statistics
    this._stats = {
      snapshot: {
        bytesLoaded: -1
      },
      syncRequestsReceieved: 0
    }

    try {
      this._replicator = new Replicator(this, this.options.replicationConcurrency)
      // For internal backwards compatibility,
      // to be removed in future releases
      this._loader = this._replicator
      this._replicator.on('load.added', (entry) => {
        // Update the latest entry state (latest is the entry with largest clock time)
        this._replicationStatus.queued++
        this._recalculateReplicationMax(entry.clock ? entry.clock.time : 0)
        // logger.debug(`<replicate>`)
        this.events.emit('replicate', this.address.toString(), entry)
      })
      this._replicator.on('load.progress', (id, hash, entry, have, bufferedLength) => {
        if (this._replicationStatus.buffered > bufferedLength) {
          this._recalculateReplicationProgress(this.replicationStatus.progress + bufferedLength)
        } else {
          this._recalculateReplicationProgress(this._oplog.length + bufferedLength)
        }
        this._replicationStatus.buffered = bufferedLength
        this._recalculateReplicationMax(this.replicationStatus.progress)
        // logger.debug(`<replicate.progress>`)
        this.events.emit('replicate.progress', this.address.toString(), hash, entry, this.replicationStatus.progress, this.replicationStatus.max)
      })

      const onLoadCompleted = async (logs, have) => {
        try {
          for (let log of logs) {
            await this._oplog.join(log)
          }
          this._replicationStatus.queued -= logs.length
          this._replicationStatus.buffered = this._replicator._buffer.length
          await this._updateIndex()

          // only store heads that has been verified and merges
          const heads = this._oplog.heads
          await this._cache.set('_remoteHeads', heads)
          logger.debug(`Saved heads ${heads.length} [${heads.map(e => e.hash).join(', ')}]`)

          // logger.debug(`<replicated>`)
          this.events.emit('replicated', this.address.toString(), logs.length)
        } catch (e) {
          console.error(e)
        }
      }
      this._replicator.on('load.end', onLoadCompleted)
    } catch (e) {
      console.error('Store Error:', e)
    }
  }

  get all () {
    return Array.isArray(this._index._index)
      ? this._index._index
      : Object.keys(this._index._index).map(e => this._index._index[e])
  }

  get index () {
    return this._index._index
  }

  get type () {
    return this._type
  }

  get key () {
    return this._key
  }

  /**
   * Returns the database's current replication status information
   * @return {[Object]} [description]
   */
  get replicationStatus () {
    return this._replicationStatus
  }

  setIdentity (identity) {
    this.identity = identity
    this._oplog.setIdentity(identity)
  }

  async close () {
    if (this.options.onClose) {
      await this.options.onClose(this.address.toString())
    }

    // Replicator teardown logic
    this._replicator.stop()

    // Reset replication statistics
    this._replicationStatus.reset()

    // Reset database statistics
    this._stats = {
      snapshot: {
        bytesLoaded: -1
      },
      syncRequestsReceieved: 0
    }

    // Remove all event listeners
    this.events.removeAllListeners('load')
    this.events.removeAllListeners('load.progress')
    this.events.removeAllListeners('replicate')
    this.events.removeAllListeners('replicate.progress')
    this.events.removeAllListeners('replicated')
    this.events.removeAllListeners('ready')
    this.events.removeAllListeners('write')

    // Close cache
    await this._cache.close()

    // Database is now closed
    // TODO: afaik we don't use 'closed' event anymore,
    // to be removed in future releases
    this.events.emit('closed', this.address.toString())
    return Promise.resolve()
  }

  /**
   * Drops a database and removes local data
   * @return {[None]}
   */
  async drop () {
    await this.close()
    await this._cache.destroy()
    // Reset
    this._index = new this.options.Index(this.address.root)
    this._oplog = new Log(this._ipfs, this.identity, { logId: this.id, access: this.access, sortFn: this.options.sortFn })
    this._cache = this.options.cache
  }

  async load (amount, { fetchEntryTimeout } = {}) {
    amount = amount || this.options.maxHistory
    fetchEntryTimeout = fetchEntryTimeout || this.options.fetchEntryTimeout;

    const localHeads = await this._cache.get('_localHeads') || []
    const remoteHeads = await this._cache.get('_remoteHeads') || []
    const heads = localHeads.concat(remoteHeads)

    if (heads.length > 0) {
      this.events.emit('load', this.address.toString(), heads)
    }

    await mapSeries(heads, async (head) => {
      this._recalculateReplicationMax(head.clock.time)
      const log = await Log.fromEntryHash(this._ipfs, this.identity, head.hash, { logId: this._oplog.id, access: this.access, sortFn: this.options.sortFn, length: amount, exclude: this._oplog.values, onProgressCallback:  this._onLoadProgress.bind(this), timeout: fetchEntryTimeout })
      await this._oplog.join(log, amount)
    })

    // Update the index
    if (heads.length > 0) {
      await this._updateIndex()
    }

    this.events.emit('ready', this.address.toString(), this._oplog.heads)
  }

  sync (heads) {
    this._stats.syncRequestsReceieved += 1
    logger.debug(`Sync request #${this._stats.syncRequestsReceieved} ${heads.length}`)
    if (heads.length === 0) {
      return
    }

    // To simulate network latency, uncomment this line
    // and comment out the rest of the function
    // That way the object (received as head message from pubsub)
    // doesn't get written to IPFS and so when the Replicator is fetching
    // the log, it'll fetch it from the network instead from the disk.
    // return this._replicator.load(heads)

    const saveToIpfs = async (head) => {
      if (!head) {
        console.warn("Warning: Given input entry was 'null'.")
        return Promise.resolve(null)
      }

      const identityProvider = this.identity.provider
      if (!identityProvider) throw new Error('Identity-provider is required, cannot verify entry')

      const canAppend = await this.access.canAppend(head, identityProvider)
      if (!canAppend) {
        console.warn('Warning: Given input entry is not allowed in this log and was discarded (no write access).')
        return Promise.resolve(null)
      }

      const logEntry = Object.assign({}, head)
      logEntry.hash = null
      const codec = logEntry.v === 0 ? 'dag-pb' : 'dag-cbor'
      const hash = await dagNode.write(this._ipfs, codec, logEntry, { links: ['next'], onlyHash: true })

      if (hash !== head.hash) {
        console.warn('"WARNING! Head hash didn\'t match the contents')
      }

      return head
    }

    return mapSeries(heads, saveToIpfs)
      .then(async (saved) => {
        return this._replicator.load(saved.filter(e => e !== null))
      })
  }

  loadMoreFrom (amount, entries) {
    this._replicator.load(entries)
  }

  async saveSnapshot () {
    const unfinished = this._replicator.getQueue()

    let snapshotData = this._oplog.toSnapshot()
    let header = Buffer.from(JSON.stringify({
      id: snapshotData.id,
      heads: snapshotData.heads,
      size: snapshotData.values.length,
      type: this.type
    }))
    const rs = new Readable()
    let size = new Uint16Array([header.length])
    let bytes = Buffer.from(size.buffer)
    rs.push(bytes)
    rs.push(header)

    const addToStream = (val) => {
      let str = Buffer.from(JSON.stringify(val))
      let size = new Uint16Array([str.length])
      rs.push(Buffer.from(size.buffer))
      rs.push(str)
    }

    snapshotData.values.forEach(addToStream)
    rs.push(null) // tell the stream we're finished

    const snapshot = this._ipfs.files.add ? await this._ipfs.files.add(rs) : await this._ipfs.add(rs)

    await this._cache.set('snapshot', snapshot[snapshot.length - 1])
    await this._cache.set('queue', unfinished)

    logger.debug(`Saved snapshot: ${snapshot[snapshot.length - 1].hash}, queue length: ${unfinished.length}`)

    return snapshot
  }

  async loadFromSnapshot (onProgressCallback) {
    this.events.emit('load', this.address.toString())

    const maxClock = (res, val) => Math.max(res, val.clock.time)

    const queue = await this._cache.get('queue')
    this.sync(queue || [])

    const snapshot = await this._cache.get('snapshot')

    if (snapshot) {
      const res = this._ipfs.files.catReadableStream ? await this._ipfs.files.catReadableStream(snapshot.hash) : await this._ipfs.catReadableStream(snapshot.hash)
      const loadSnapshotData = () => {
        return new Promise((resolve, reject) => {
          let buf = Buffer.alloc(0)
          let q = []

          const bufferData = (d) => {
            this._byteSize += d.length
            if (q.length < 20000) {
              q.push(d)
            } else {
              const a = Buffer.concat(q)
              buf = Buffer.concat([buf, a])
              q = []
            }
          }

          const done = () => {
            if (q.length > 0) {
              const a = Buffer.concat(q)
              buf = Buffer.concat([buf, a])
            }

            function toArrayBuffer (buf) {
              var ab = new ArrayBuffer(buf.length)
              var view = new Uint8Array(ab)
              for (var i = 0; i < buf.length; ++i) {
                view[i] = buf[i]
              }
              return ab
            }

            const headerSize = parseInt(new Uint16Array(toArrayBuffer(buf.slice(0, 2))))
            let header

            try {
              header = JSON.parse(buf.slice(2, headerSize + 2))
            } catch (e) {
              // TODO
            }

            let values = []
            let a = 2 + headerSize
            while (a < buf.length) {
              const s = parseInt(new Uint16Array(toArrayBuffer(buf.slice(a, a + 2))))
              a += 2
              const data = buf.slice(a, a + s)
              try {
                const d = JSON.parse(data)
                values.push(d)
              } catch (e) {
              }
              a += s
            }

            if (header) {
              this._type = header.type
              resolve({ values: values, id: header.id, heads: header.heads, type: header.type })
            } else {
              resolve({ values: values, id: null, heads: null, type: null })
            }
          }
          res.on('data', bufferData)
          res.on('end', done)
        })
      }

      const onProgress = (hash, entry, count, total) => {
        this._recalculateReplicationStatus(count, entry.clock.time)
        this._onLoadProgress(hash, entry)
      }

      // Fetch the entries
      // Timeout 1 sec to only load entries that are already fetched (in order to not get stuck at loading)
      const snapshotData = await loadSnapshotData()
      this._recalculateReplicationMax(snapshotData.values.reduce(maxClock, 0))
      if (snapshotData) {
        const log = await Log.fromJSON(this._ipfs, this.identity, snapshotData, { access: this.access, sortFn: this.options.sortFn, length: -1, timeout: 1000, onProgressCallback: onProgress })
        await this._oplog.join(log)
        await this._updateIndex()
        this.events.emit('replicated', this.address.toString())
      }
      this.events.emit('ready', this.address.toString(), this._oplog.heads)
    } else {
      throw new Error(`Snapshot for ${this.address} not found!`)
    }

    return this
  }

  async _updateIndex () {
    this._recalculateReplicationMax()
    await this._index.updateIndex(this._oplog)
    this._recalculateReplicationProgress()
  }

  async syncLocal () {
    const localHeads = await this._cache.get('_localHeads') || []
    const remoteHeads = await this._cache.get('_remoteHeads') || []
    const heads = localHeads.concat(remoteHeads)
    for (let i = 0; i < heads.length; i++) {
      const head = heads[i]
      if (!this._oplog.heads.includes(head)) {
        await this.load()
        break
      }
    }
  }

  async _addOperation (data, batchOperation, lastOperation, onProgressCallback) {
    if (this._oplog) {
      // check local cache?
      if (this.options.syncLocal) {
        await this.syncLocal()
      }

      const entry = await this._oplog.append(data, this.options.referenceCount)
      this._recalculateReplicationStatus(this.replicationStatus.progress + 1, entry.clock.time)
      await this._cache.set('_localHeads', [entry])
      await this._updateIndex()
      this.events.emit('write', this.address.toString(), entry, this._oplog.heads)
      if (onProgressCallback) onProgressCallback(entry)
      return entry.hash
    }
  }

  _addOperationBatch (data, batchOperation, lastOperation, onProgressCallback) {
    throw new Error('Not implemented!')
  }

  _onLoadProgress (hash, entry, progress, total) {
    this._recalculateReplicationStatus(progress, total)
    this.events.emit('load.progress', this.address.toString(), hash, entry, this.replicationStatus.progress, this.replicationStatus.max)
  }

  /* Replication Status state updates */

  _recalculateReplicationProgress (max) {
    this._replicationStatus.progress = Math.max.apply(null, [
      this._replicationStatus.progress,
      this._oplog.length,
      max || 0
    ])
    this._recalculateReplicationMax(this.replicationStatus.progress)
  }

  _recalculateReplicationMax (max) {
    this._replicationStatus.max = Math.max.apply(null, [
      this._replicationStatus.max,
      this._oplog.length,
      max || 0
    ])
  }

  _recalculateReplicationStatus (maxProgress, maxTotal) {
    this._recalculateReplicationProgress(maxProgress)
    this._recalculateReplicationMax(maxTotal)
  }
}

module.exports = Store

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"orbit-db-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-store/src/Store.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-docstore/src/DocumentIndex.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-docstore/src/DocumentIndex.js
      return function (require, module, exports) {
'use strict'

class DocumentIndex {
  constructor () {
    this._index = {}
  }

  get (key, fullOp = false) {
    return fullOp
      ? this._index[key]
      : this._index[key] ? this._index[key].payload.value : null
  }

  updateIndex (oplog, onProgressCallback) {
    const reducer = (handled, item, idx) => {
      if (handled[item.payload.key] !== true) {
        handled[item.payload.key] = true
        if(item.payload.op === 'PUT') {
          this._index[item.payload.key] = item
        } else if (item.payload.op === 'DEL') {
          delete this._index[item.payload.key]
        }
      }
      if (onProgressCallback) onProgressCallback(item, idx)
      return handled
    }

    oplog.values
      .slice()
      .reverse()
      .reduce(reducer, {})
  }
}

module.exports = DocumentIndex

      };
    };
  }
}, {package:"orbit-db-docstore",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-docstore/src/DocumentIndex.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-docstore/node_modules/p-map/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-docstore/node_modules/p-map/index.js
      return function (require, module, exports) {
'use strict';
module.exports = (iterable, mapper, opts) => new Promise((resolve, reject) => {
	opts = Object.assign({
		concurrency: Infinity
	}, opts);

	const concurrency = opts.concurrency;

	if (concurrency < 1) {
		throw new TypeError('Expected `concurrency` to be a number from 1 and up');
	}

	const ret = [];
	const iterator = iterable[Symbol.iterator]();
	let isRejected = false;
	let iterableDone = false;
	let resolvingCount = 0;
	let currentIdx = 0;

	const next = () => {
		if (isRejected) {
			return;
		}

		const nextItem = iterator.next();
		const i = currentIdx;
		currentIdx++;

		if (nextItem.done) {
			iterableDone = true;

			if (resolvingCount === 0) {
				resolve(ret);
			}

			return;
		}

		resolvingCount++;

		Promise.resolve(nextItem.value)
			.then(el => mapper(el, i))
			.then(
				val => {
					ret[i] = val;
					resolvingCount--;
					next();
				},
				err => {
					isRejected = true;
					reject(err);
				}
			);
	};

	for (let i = 0; i < concurrency; i++) {
		next();

		if (iterableDone) {
			break;
		}
	}
});

      };
    };
  }
}, {package:"p-map",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-docstore/node_modules/p-map/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/utils/is-defined.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/utils/is-defined.js
      return function (require, module, exports) {
'use strict'

const isDefined = (arg) => arg !== undefined && arg !== null

module.exports = isDefined

      };
    };
  }
}, {package:"orbit-db",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/utils/is-defined.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-counterstore/src/CounterIndex.js", {"crdts/src/G-Counter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/crdts/src/G-Counter.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-counterstore/src/CounterIndex.js
      return function (require, module, exports) {
'use strict'

const Counter = require('crdts/src/G-Counter')

class CounterIndex {
  constructor(id) {
    this._index = new Counter(id)
  }

  get() {
    return this._index
  }

  updateIndex(oplog) {
    if(this._index) {
      const createCounter = e => Counter.from(e.payload.value)
      const mergeToIndex = e => this._index.merge(e)
      oplog.values.filter(e => e && e.payload.op === 'COUNTER')
        .map(createCounter)
        .forEach(mergeToIndex)
    }
  }
}

module.exports = CounterIndex

      };
    };
  }
}, {package:"orbit-db-counterstore",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-counterstore/src/CounterIndex.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/crdts/src/G-Counter.js", {"./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/crdts/src/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/crdts/src/G-Counter.js
      return function (require, module, exports) {
'use strict'

const { deepEqual } = require('./utils')
const sum = (acc, val) => acc + val

/**
 * G-Counter
 *
 * Operation-based Increment-Only Counter CRDT
 *
 * Sources: 
 * "A comprehensive study of Convergent and Commutative Replicated Data Types"
 * http://hal.upmc.fr/inria-00555588/document, "3.1.1 Op-based counter and 3.1.2  State-based increment-only Counter (G-Counter)"
 */

class GCounter {
  constructor (id, counter) {
    this.id = id
    this._counters = counter ? counter : {}
    this._counters[this.id] = this._counters[this.id] ? this._counters[this.id] : 0
  }

  get value () {
    return Object.values(this._counters).reduce(sum, 0)
  }

  increment (amount) {
    if (amount && amount < 1) 
      return

    if (amount === undefined || amount === null)
      amount = 1

    this._counters[this.id] = this._counters[this.id] + amount
  }

  merge (other) {
    // Go through each counter in the other counter
    Object.entries(other._counters).forEach(([id, value]) => {
      // Take the maximum of the counter value we have or the counter value they have
      this._counters[id] = Math.max(this._counters[id] || 0, value)
    })
  }

  toJSON () {
    return { 
      id: this.id, 
      counters: this._counters 
    }
  }

  isEqual (other) {
    return GCounter.isEqual(this, other)
  }

  static from (json) {
    return new GCounter(json.id, json.counters)
  }

  static isEqual (a, b) {
    if(a.id !== b.id)
      return false

    return deepEqual(a._counters, b._counters)
  }
}

module.exports = GCounter

      };
    };
  }
}, {package:"crdts",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/crdts/src/G-Counter.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/src/direct-channel.js", {"./encoding":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/src/encoding.js","./get-peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/src/get-peer-id.js","./protocol":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/src/protocol.js","./wait-for-peers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/src/wait-for-peers.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","path":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/path-browserify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/src/direct-channel.js
      return function (require, module, exports) {
'use strict'

const path = require('path')
const EventEmitter = require('events')
const PROTOCOL = require('./protocol')
const encode = require('./encoding')
const waitForPeers = require('./wait-for-peers')
const getPeerID = require('./get-peer-id')

/**
 * Communication channel over Pubsub between two IPFS nodes
 */
class DirectChannel extends EventEmitter {
  constructor (ipfs, receiverID) {
    super()

    // IPFS instance to use internally
    this._ipfs = ipfs

    if (!ipfs.pubsub) {
      throw new Error('This IPFS node does not support pubsub.')
    }

    this._receiverID = receiverID

    if (!this._receiverID) {
      throw new Error('Receiver ID was undefined')
    }
    // See _setup() for more state initialization
  }

  /**
   * Channel ID
   * @return {[String]} Channel's ID
   */
  get id () {
    return this._id
  }

  /**
   * Peers participating in this channel
   * @return {[Array]} Array of peer IDs participating in this channel
   */
  get peers () {
    return this._peers
  }

  async connect () {
    await waitForPeers(this._ipfs, [this._receiverID], this._id)
  }

  /**
   * Send a message to the other peer
   * @param  {[Any]} message Payload
   */
  async send (message) {
    let m = encode(message)
    await this._ipfs.pubsub.publish(this._id, m)
  }

  /**
   * Close the channel
   */
  close () {
    this.removeAllListeners('message')
    this._ipfs.pubsub.unsubscribe(this._id, this._messageHandler)
  }

  async _setup () {
    this._senderID = await getPeerID(this._ipfs)

    // Channel's participants
    this._peers = Array.from([this._senderID, this._receiverID]).sort()

    // ID of the channel is "<peer1 id>/<peer 2 id>""
    this._id = '/' + '' + PROTOCOL + '/' + this._peers.join('/')

    // Function to use to handle incoming messages
    this._messageHandler = message => {
      // Make sure the message is coming from the correct peer
      const isValid = message && message.from === this._receiverID
      // Filter out all messages that didn't come from the second peer
      if (isValid) {
        this.emit('message', message)
      }
    }
  }

  async _openChannel () {
    await this._setup()
    await this._ipfs.pubsub.subscribe(this._id, this._messageHandler)
  }

  static async open (ipfs, receiverID) {
    const channel = new DirectChannel(ipfs, receiverID)
    await channel._openChannel()
    return channel
  }
}

module.exports = DirectChannel

      };
    };
  }
}, {package:"ipfs-pubsub-1on1",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-pubsub-1on1/src/direct-channel.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-eventstore/src/EventIndex.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-eventstore/src/EventIndex.js
      return function (require, module, exports) {
'use strict'

class EventIndex {
  constructor () {
    this._index = null
  }

  get () {
    return this._index ? this._index.values : []
  }

  updateIndex (oplog) {
    this._index = oplog
  }
}

module.exports = EventIndex

      };
    };
  }
}, {package:"orbit-db-eventstore",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-eventstore/src/EventIndex.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-cache/Cache.js", {"logplease":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/logplease/src/index.js","path":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/path-browserify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-cache/Cache.js
      return function (require, module, exports) {
'use strict'

const path = require('path')

const Logger = require('logplease')
const logger = Logger.create('cache', { color: Logger.Colors.Magenta })
Logger.setLogLevel('ERROR')

let caches = {}

class Cache {
  constructor (storage, directory) {
    this.path = directory || './orbitdb'
    this._storage = storage
    this._store = null
  }

  // Setup storage backend
  async open () {
    logger.debug('open', this.path)

    if (this.store) {
      return Promise.resolve()
    }

    return new Promise((resolve, reject) => {
      const store = this._storage(this.path)
      store.open((err) => {
        if (err) {
          return reject(err)
        }
        this._store = store
        resolve()
      })
    })
  }

  async close () {
    logger.debug('close', this.path)

    if (!this._store) {
      return Promise.resolve()
    }

    return new Promise((resolve, reject) => {
      this._store.close((err) => {
        if (err) {
          return reject(err)
        }
        this._store = null
        delete caches[this.path]
        resolve()
      })
    })
  }

  async destroy () {
    logger.debug('destroy', this.path)

    return new Promise((resolve, reject) => {
      this._storage.destroy(this.path, (err) => {
        if (err) {
          return reject(err)
        }
        resolve()
      })
    })
  }

  async get (key) {
    if (!this._store) {
      await this.open()
    }

    if (this._store.status && this._store.status !== 'open') {
      return Promise.resolve(null)
    }

    return new Promise((resolve, reject) => {
      this._store.get(key, (err, value) => {
        if (err) {
          // Ignore error if key was not found
          if (err.toString().indexOf('NotFoundError: Key not found in database') === -1 &&
            err.toString().indexOf('NotFound') === -1) {
            return reject(err)
          }
        }
        resolve(value ? JSON.parse(value) : null)
      })
    })
  }

  // Set value in the cache and return the new value
  async set (key, value) {
    if (!this._store) {
      await this.open()
    }

    if (this._store.status && this._store.status !== 'open') {
      return Promise.resolve()
    }

    return new Promise((resolve, reject) => {
      this._store.put(key, JSON.stringify(value), (err) => {
        if (err) {
          // Ignore error if key was not found
          if (err.toString().indexOf('NotFoundError: Key not found in database') === -1 &&
            err.toString().indexOf('NotFound') === -1) {
            return reject(err)
          }
        }
        resolve()
      })
    })
  }

  // Remove a value and key from the cache
  async del (key) {
    if (!this._store) {
      await this.open()
    }

    return new Promise((resolve, reject) => {
      this._store.del(key, (err) => {
        if (err) {
          // Ignore error if key was not found
          if (err.toString().indexOf('NotFoundError: Key not found in database') === -1 &&
            err.toString().indexOf('NotFound') === -1) {
            return reject(err)
          }
        }
        resolve()
      })
    })
  }
}

module.exports = (storage, mkdir) => {
  return {
    load: async (directory, dbAddress) => {
      logger.debug('load, database:', dbAddress.toString())

      const dbPath = path.join(dbAddress.root, dbAddress.path)
      const dataPath = path.join(directory, dbPath)
      let cache = caches[dataPath]
      if (!cache) {
        if (mkdir && mkdir.sync) {
          mkdir.sync(dataPath)
        }
        cache = new Cache(storage, dataPath)
        await cache.open()
        caches[dataPath] = cache
      }
      return cache
    },
    close: async () => {
      logger.debug('close all')

      await Promise.all(Object.values(caches), cache => cache.close())
      caches = {}
    }
  }
}

      };
    };
  }
}, {package:"orbit-db-cache",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-cache/Cache.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/index.js", {"../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","./iterator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/iterator.js","./util/immediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/util/immediate-browser.js","./util/mixed-to-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/util/mixed-to-buffer.js","./util/support":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/util/support.js","abstract-leveldown":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/abstract-leveldown/index.js","inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/* global indexedDB */

'use strict'

module.exports = Level

var AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN
var inherits = require('inherits')
var Iterator = require('./iterator')
var mixedToBuffer = require('./util/mixed-to-buffer')
var setImmediate = require('./util/immediate')
var support = require('./util/support')

var DEFAULT_PREFIX = 'level-js-'

function Level (location, opts) {
  if (!(this instanceof Level)) return new Level(location, opts)
  AbstractLevelDOWN.call(this)
  opts = opts || {}

  if (typeof location !== 'string') {
    throw new Error('constructor requires a location string argument')
  }

  this.location = location
  this.prefix = opts.prefix || DEFAULT_PREFIX
  this.version = parseInt(opts.version || 1, 10)
}

inherits(Level, AbstractLevelDOWN)

// Detect binary and array key support (IndexedDB Second Edition)
Level.binaryKeys = support.binaryKeys(indexedDB)
Level.arrayKeys = support.arrayKeys(indexedDB)

Level.prototype._open = function (options, callback) {
  var req = indexedDB.open(this.prefix + this.location, this.version)
  var self = this

  req.onerror = function () {
    callback(req.error || new Error('unknown error'))
  }

  req.onsuccess = function () {
    self.db = req.result
    callback()
  }

  req.onupgradeneeded = function (ev) {
    var db = ev.target.result

    if (!db.objectStoreNames.contains(self.location)) {
      db.createObjectStore(self.location)
    }
  }
}

Level.prototype.store = function (mode) {
  var transaction = this.db.transaction([this.location], mode)
  return transaction.objectStore(this.location)
}

Level.prototype.await = function (request, callback) {
  var transaction = request.transaction

  // Take advantage of the fact that a non-canceled request error aborts
  // the transaction. I.e. no need to listen for "request.onerror".
  transaction.onabort = function () {
    callback(transaction.error || new Error('aborted by user'))
  }

  transaction.oncomplete = function () {
    callback(null, request.result)
  }
}

Level.prototype._get = function (key, options, callback) {
  var store = this.store('readonly')

  try {
    var req = store.get(key)
  } catch (err) {
    return setImmediate(function () {
      callback(err)
    })
  }

  this.await(req, function (err, value) {
    if (err) return callback(err)

    if (value === undefined) {
      // 'NotFound' error, consistent with LevelDOWN API
      return callback(new Error('NotFound'))
    }

    if (options.asBuffer) {
      value = mixedToBuffer(value)
    }

    callback(null, value)
  })
}

Level.prototype._del = function (key, options, callback) {
  var store = this.store('readwrite')

  try {
    var req = store.delete(key)
  } catch (err) {
    return setImmediate(function () {
      callback(err)
    })
  }

  this.await(req, callback)
}

Level.prototype._put = function (key, value, options, callback) {
  var store = this.store('readwrite')

  try {
    // Will throw a DataError or DataCloneError if the environment
    // does not support serializing the key or value respectively.
    var req = store.put(value, key)
  } catch (err) {
    return setImmediate(function () {
      callback(err)
    })
  }

  this.await(req, callback)
}

// Valid key types in IndexedDB Second Edition:
//
// - Number, except NaN. Includes Infinity and -Infinity
// - Date, except invalid (NaN)
// - String
// - ArrayBuffer or a view thereof (typed arrays). In level-js we also support
//   Buffer (which is an Uint8Array) (and the primary binary type of Level).
// - Array, except cyclical and empty (e.g. Array(10)). Elements must be valid
//   types themselves.
Level.prototype._serializeKey = function (key) {
  if (Buffer.isBuffer(key)) {
    return Level.binaryKeys ? key : key.toString()
  } else if (Array.isArray(key)) {
    return Level.arrayKeys ? key.map(this._serializeKey, this) : String(key)
  } else {
    return key
  }
}

Level.prototype._serializeValue = function (value) {
  return value
}

Level.prototype._iterator = function (options) {
  return new Iterator(this, this.location, options)
}

Level.prototype._batch = function (operations, options, callback) {
  if (operations.length === 0) return setImmediate(callback)

  var store = this.store('readwrite')
  var transaction = store.transaction
  var index = 0
  var error

  transaction.onabort = function () {
    callback(error || transaction.error || new Error('aborted by user'))
  }

  transaction.oncomplete = function () {
    callback()
  }

  // Wait for a request to complete before making the next, saving CPU.
  function loop () {
    var op = operations[index++]
    var key = op.key

    try {
      var req = op.type === 'del' ? store.delete(key) : store.put(op.value, key)
    } catch (err) {
      error = err
      transaction.abort()
      return
    }

    if (index < operations.length) {
      req.onsuccess = loop
    }
  }

  loop()
}

Level.prototype._close = function (callback) {
  this.db.close()
  setImmediate(callback)
}

Level.destroy = function (location, prefix, callback) {
  if (typeof prefix === 'function') {
    callback = prefix
    prefix = DEFAULT_PREFIX
  }
  var request = indexedDB.deleteDatabase(prefix + location)
  request.onsuccess = function () {
    callback()
  }
  request.onerror = function (err) {
    callback(err)
  }
}

}).call(this)}).call(this,{"isBuffer":require("../is-buffer/index.js")})

      };
    };
  }
}, {package:"level-js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/level-js/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/src/keystore.js", {"./verifiers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/src/verifiers/index.js","levelup":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/node_modules/levelup/lib/levelup.js","libp2p-crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/index.js","lru":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lru/index.js","safe-buffer/":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js","secp256k1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/src/keystore.js
      return function (require, module, exports) {
'use strict'
const levelup = require('levelup')
const crypto = require('libp2p-crypto')
const secp256k1 = require('secp256k1')
const LRU = require('lru')
const Buffer = require('safe-buffer/').Buffer
const { verifier } = require('./verifiers')

class Keystore {
  constructor (storage, directory) {
    this.path = directory || './orbitdb'
    this._storage = storage
    this._store = null
    this._cache = new LRU(100)
  }

  async open () {
    if (this.store) {
      return Promise.resolve()
    }

    return new Promise((resolve, reject) => {
      const store = levelup(this._storage(this.path))
      store.open((err) => {
        if (err) {
          return reject(err)
        }
        this._store = store
        resolve()
      })
    })
  }

  async close () {
    if (!this._store) {
      return Promise.resolve()
    }

    return new Promise((resolve, reject) => {
      this._store.close((err) => {
        if (err) {
          return reject(err)
        }
        this._store = null
        resolve()
      })
    })
  }

  async destroy () {
    return new Promise((resolve, reject) => {
      this._storage.destroy(this.path, (err) => {
        if (err) {
          return reject(err)
        }
        resolve()
      })
    })
  }

  async hasKey (id) {
    if (!id) {
      throw new Error('id needed to check a key')
    }
    if (!this._store) {
      await this.open()
    }
    if (this._store.status && this._store.status !== 'open') {
      return Promise.resolve(null)
    }

    let hasKey = false
    try {
      let storedKey = this._cache.get(id) || await this._store.get(id)
      hasKey = storedKey !== undefined && storedKey !== null
    } catch (e) {
      // Catches 'Error: ENOENT: no such file or directory, open <path>'
      console.error('Error: ENOENT: no such file or directory')
    }
    await this.close()

    return hasKey
  }

  async createKey (id) {
    if (!id) {
      throw new Error('id needed to create a key')
    }
    if (!this._store) {
      await this.open()
    }
    if (this._store.status && this._store.status !== 'open') {
      return Promise.resolve(null)
    }

    const genKeyPair = () => new Promise((resolve, reject) => {
      crypto.keys.generateKeyPair('secp256k1', 256, (err, key) => {
        if (!err) {
          resolve(key)
        }
        reject(err)
      })
    })

    const keys = await genKeyPair()
    const decompressedKey = secp256k1.publicKeyConvert(keys.public.marshal(), false)
    const key = {
      publicKey: decompressedKey.toString('hex'),
      privateKey: keys.marshal().toString('hex')
    }

    try {
      await this._store.put(id, JSON.stringify(key))
    } catch (e) {
      console.log(e)
    }
    await this.close()
    this._cache.set(id, key)

    return keys
  }

  async getKey (id) {
    if (!id) {
      throw new Error('id needed to get a key')
    }
    if (!this._store) {
      await this.open()
    }
    if (this._store.status && this._store.status !== 'open') {
      return Promise.resolve(null)
    }

    const cachedKey = this._cache.get(id)
    let storedKey
    try {
      storedKey = cachedKey || await this._store.get(id)
    } catch (e) {
      // ignore ENOENT error
    }
    await this.close()

    if (!storedKey) {
      return
    }

    const deserializedKey = cachedKey || JSON.parse(storedKey)
    if (!deserializedKey) {
      return
    }

    if (!cachedKey) {
      this._cache.set(id, deserializedKey)
    }


    const genPrivKey = (pk) => new Promise((resolve, reject) => {
      crypto.keys.supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(pk, (err, key) => {
        if (!err) {
          resolve(key)
        }
        reject(err)
      })
    })

    return genPrivKey(Buffer.from(deserializedKey.privateKey, 'hex'))
  }

  async sign (key, data) {
    if (!key) {
      throw new Error('No signing key given')
    }

    if (!data) {
      throw new Error('Given input data was undefined')
    }

    if (!Buffer.isBuffer(data)) {
      data = Buffer.from(data)
    }

    return new Promise((resolve, reject) => {
      key.sign(data, (err, signature) => {
        if (!err) {
          resolve(signature.toString('hex'))
        }
        reject(err)
      })
    })
  }

  getPublic(keys, options = {}) {
    const formats = ['hex', 'buffer']
    const decompress = options.decompress || true
    const format = formats[options.format || 'hex']
    let pubKey = keys.public.marshal()
    if (decompress) {
      pubKey = secp256k1.publicKeyConvert(pubKey, false)
    }
    return format === 'buffer' ? pubKey : pubKey.toString('hex')
  }

  async verify (signature, publicKey, data, v = 'v1') {
    return Keystore.verify(signature, publicKey, data, v)
  }

  static async verify (signature, publicKey, data, v = 'v1') {
    return verifier(v).verify(signature, publicKey, data)
  }
}

module.exports = (storage, mkdir) => {
  return {
    create: (directory = './keystore') => {
      // If we're in Node.js, mkdir module is expected to passed
      // and we need to make sure the directory exists
      if (mkdir && mkdir.sync) {
        mkdir.sync(directory)
      }

      return new Keystore(storage, directory)
    },
    verify: Keystore.verify
  }
}

      };
    };
  }
}, {package:"orbit-db-keystore",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/src/keystore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/mafmt/src/index.js", {"multiaddr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/mafmt/src/index.js
      return function (require, module, exports) {
'use strict'

const multiaddr = require('multiaddr')

/*
 * Valid combinations
 */
const DNS4 = base('dns4')
const DNS6 = base('dns6')
const _DNS = or(
  base('dnsaddr'),
  DNS4,
  DNS6
)

const IP = or(base('ip4'), base('ip6'))
const TCP = or(
  and(IP, base('tcp')),
  and(_DNS, base('tcp'))
)
const UDP = and(IP, base('udp'))
const UTP = and(UDP, base('utp'))

const DNS = or(
  and(_DNS, base('tcp')),
  _DNS
)

const WebSockets = or(
  and(TCP, base('ws')),
  and(DNS, base('ws'))
)

const WebSocketsSecure = or(
  and(TCP, base('wss')),
  and(DNS, base('wss'))
)

const HTTP = or(
  and(TCP, base('http')),
  and(IP, base('http')),
  and(DNS, base('http')),
  and(DNS)
)

const HTTPS = or(
  and(TCP, base('https')),
  and(IP, base('https')),
  and(DNS, base('https'))
)

const WebRTCStar = or(
  and(WebSockets, base('p2p-webrtc-star'), base('ipfs')),
  and(WebSocketsSecure, base('p2p-webrtc-star'), base('ipfs'))
)

const WebSocketStar = or(
  and(WebSockets, base('p2p-websocket-star'), base('ipfs')),
  and(WebSocketsSecure, base('p2p-websocket-star'), base('ipfs')),
  and(WebSockets, base('p2p-websocket-star')),
  and(WebSocketsSecure, base('p2p-websocket-star'))
)

const WebRTCDirect = or(
  and(HTTP, base('p2p-webrtc-direct')),
  and(HTTPS, base('p2p-webrtc-direct'))
)

const Reliable = or(
  WebSockets,
  WebSocketsSecure,
  HTTP,
  HTTPS,
  WebRTCStar,
  WebRTCDirect,
  TCP,
  UTP
)

// Unlike ws-star, stardust can run over any transport thus removing the requirement for websockets (but don't even think about running a stardust server over webrtc-star ;) )
const Stardust = or(
  and(Reliable, base('p2p-stardust'), base('ipfs')),
  and(Reliable, base('p2p-stardust'))
)

let _IPFS = or(
  and(Reliable, base('ipfs')),
  WebRTCStar,
  base('ipfs')
)

const _Circuit = or(
  and(_IPFS, base('p2p-circuit'), _IPFS),
  and(_IPFS, base('p2p-circuit')),
  and(base('p2p-circuit'), _IPFS),
  and(Reliable, base('p2p-circuit')),
  and(base('p2p-circuit'), Reliable),
  base('p2p-circuit')
)

const CircuitRecursive = () => or(
  and(_Circuit, CircuitRecursive),
  _Circuit
)

const Circuit = CircuitRecursive()

const IPFS = or(
  and(Circuit, _IPFS, Circuit),
  and(_IPFS, Circuit),
  and(Circuit, _IPFS),
  Circuit,
  _IPFS
)

exports.DNS = DNS
exports.DNS4 = DNS4
exports.DNS6 = DNS6
exports.IP = IP
exports.TCP = TCP
exports.UDP = UDP
exports.UTP = UTP
exports.HTTP = HTTP
exports.HTTPS = HTTPS
exports.WebSockets = WebSockets
exports.WebSocketsSecure = WebSocketsSecure
exports.WebSocketStar = WebSocketStar
exports.WebRTCStar = WebRTCStar
exports.WebRTCDirect = WebRTCDirect
exports.Reliable = Reliable
exports.Stardust = Stardust
exports.Circuit = Circuit
exports.IPFS = IPFS

/*
 * Validation funcs
 */

function makeMatchesFunction (partialMatch) {
  return function matches (a) {
    if (!multiaddr.isMultiaddr(a)) {
      try {
        a = multiaddr(a)
      } catch (err) { // catch error
        return false // also if it's invalid it's propably not matching as well so return false
      }
    }
    let out = partialMatch(a.protoNames())
    if (out === null) {
      return false
    }
    return out.length === 0
  }
}

function and () {
  const args = Array.from(arguments)
  function partialMatch (a) {
    if (a.length < args.length) {
      return null
    }
    args.some((arg) => {
      a = typeof arg === 'function'
        ? arg().partialMatch(a)
        : arg.partialMatch(a)

      if (a === null) {
        return true
      }
    })

    return a
  }

  return {
    toString: function () { return '{ ' + args.join(' ') + ' }' },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch: partialMatch
  }
}

function or () {
  const args = Array.from(arguments)

  function partialMatch (a) {
    let out = null
    args.some((arg) => {
      const res = typeof arg === 'function'
        ? arg().partialMatch(a)
        : arg.partialMatch(a)
      if (res) {
        out = res
        return true
      }
    })

    return out
  }

  const result = {
    toString: function () { return '{ ' + args.join(' ') + ' }' },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch: partialMatch
  }

  return result
}

function base (n) {
  const name = n

  function matches (a) {
    if (typeof a === 'string') {
      try {
        a = multiaddr(a)
      } catch (err) { // catch error
        return false // also if it's invalid it's propably not matching as well so return false
      }
    }

    const pnames = a.protoNames()
    if (pnames.length === 1 && pnames[0] === name) {
      return true
    }
    return false
  }

  function partialMatch (protos) {
    if (protos.length === 0) {
      return null
    }

    if (protos[0] === name) {
      return protos.slice(1)
    }
    return null
  }

  return {
    toString: function () { return name },
    matches: matches,
    partialMatch: partialMatch
  }
}

      };
    };
  }
}, {package:"mafmt",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/mafmt/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-plain-obj/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/is-plain-obj/index.js
      return function (require, module, exports) {
'use strict';
var toString = Object.prototype.toString;

module.exports = function (x) {
	var prototype;
	return toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
};

      };
    };
  }
}, {package:"is-plain-obj",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-plain-obj/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/index.js", {"./api-addr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/api-addr.js","./backends":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/backends.js","./blockstore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/blockstore.js","./config":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/config.js","./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/constants.js","./default-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/default-datastore.js","./default-options":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/default-options-browser.js","./errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/errors/index.js","./lock":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/lock-memory.js","./lock-memory":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/lock-memory.js","./spec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/spec.js","./version":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/version.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","async/each":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/each.js","async/parallel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/parallel.js","async/series":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/series.js","async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js","bignumber.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/node_modules/bignumber.js/bignumber.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","dlv":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/dlv/dist/dlv.umd.js","path":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/path-browserify/index.js","pull-stream/pull":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js","pull-stream/sinks/reduce":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/sinks/reduce.js","timers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/timers-browserify/main.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/index.js
      return function (require, module, exports) {
(function (setImmediate){(function (){
'use strict'

const waterfall = require('async/waterfall')
const series = require('async/series')
const parallel = require('async/parallel')
const each = require('async/each')
const _get = require('dlv')
const assert = require('assert')
const path = require('path')
const debug = require('debug')
const Big = require('bignumber.js')
const pull = require('pull-stream/pull')
const reduce = require('pull-stream/sinks/reduce')

const backends = require('./backends')
const version = require('./version')
const config = require('./config')
const spec = require('./spec')
const apiAddr = require('./api-addr')
const blockstore = require('./blockstore')
const defaultOptions = require('./default-options')
const defaultDatastore = require('./default-datastore')
const ERRORS = require('./errors')

const log = debug('repo')

const noLimit = Number.MAX_SAFE_INTEGER

const lockers = {
  memory: require('./lock-memory'),
  fs: require('./lock')
}

const repoVersion = require('./constants').repoVersion

/**
 * IpfsRepo implements all required functionality to read and write to an ipfs repo.
 *
 */
class IpfsRepo {
  /**
   * @param {string} repoPath - path where the repo is stored
   * @param {object} options - Configuration
   */
  constructor (repoPath, options) {
    assert.strictEqual(typeof repoPath, 'string', 'missing repoPath')

    this.options = buildOptions(options)
    this.closed = true
    this.path = repoPath

    this._locker = this._getLocker()

    this.root = backends.create('root', this.path, this.options)
    this.version = version(this.root)
    this.config = config(this.root)
    this.spec = spec(this.root)
    this.apiAddr = apiAddr(this.root)
  }

  /**
   * Initialize a new repo.
   *
   * @param {Object} config - config to write into `config`.
   * @param {function(Error)} callback
   * @returns {void}
   */
  init (config, callback) {
    log('initializing at: %s', this.path)

    series([
      (cb) => this.root.open(ignoringAlreadyOpened(cb)),
      (cb) => this.config.set(buildConfig(config), cb),
      (cb) => this.spec.set(buildDatastoreSpec(config), cb),
      (cb) => this.version.set(repoVersion, cb)
    ], callback)
  }

  /**
   * Open the repo. If the repo is already open no action will be taken.
   * If the repo is not initialized it will return an error.
   *
   * @param {function(Error)} callback
   * @returns {void}
   */
  open (callback) {
    if (!this.closed) {
      setImmediate(() => callback(new Error('repo is already open')))
      return // early
    }
    log('opening at: %s', this.path)

    // check if the repo is already initialized
    waterfall([
      (cb) => this.root.open(ignoringAlreadyOpened(cb)),
      (cb) => this._isInitialized(cb),
      (cb) => this._openLock(this.path, cb),
      (lck, cb) => {
        log('aquired repo.lock')
        this.lockfile = lck
        cb()
      },
      (cb) => {
        log('creating datastore')
        this.datastore = backends.create('datastore', path.join(this.path, 'datastore'), this.options)
        log('creating blocks')
        const blocksBaseStore = backends.create('blocks', path.join(this.path, 'blocks'), this.options)
        blockstore(
          blocksBaseStore,
          this.options.storageBackendOptions.blocks,
          cb)
      },
      (blocks, cb) => {
        this.blocks = blocks
        cb()
      },
      (cb) => {
        log('creating keystore')
        this.keys = backends.create('keys', path.join(this.path, 'keys'), this.options)
        cb()
      },

      (cb) => {
        this.closed = false
        log('all opened')
        cb()
      }
    ], (err) => {
      if (err && this.lockfile) {
        this._closeLock((err2) => {
          if (!err2) {
            this.lockfile = null
          } else {
            log('error removing lock', err2)
          }
          callback(err)
        })
      } else {
        callback(err)
      }
    })
  }

  /**
   * Returns the repo locker to be used. Null will be returned if no locker is requested
   *
   * @private
   * @returns {Locker}
   */
  _getLocker () {
    if (typeof this.options.lock === 'string') {
      assert(lockers[this.options.lock], 'Unknown lock type: ' + this.options.lock)
      return lockers[this.options.lock]
    }

    assert(this.options.lock, 'No lock provided')
    return this.options.lock
  }

  /**
   * Creates a lock on the repo if a locker is specified. The lockfile object will
   * be returned in the callback if one has been created.
   *
   * @param {string} path
   * @param {function(Error, lockfile)} callback
   * @returns {void}
   */
  _openLock (path, callback) {
    this._locker.lock(path, (err, lockfile) => {
      if (err) {
        return callback(err, null)
      }

      assert.strictEqual(typeof lockfile.close, 'function', 'Locks must have a close method')
      callback(null, lockfile)
    })
  }

  /**
   * Closes the lock on the repo
   *
   * @param {function(Error)} callback
   * @returns {void}
   */
  _closeLock (callback) {
    if (this.lockfile) {
      return this.lockfile.close(callback)
    }
    callback()
  }

  /**
   * Check if the repo is already initialized.
   *
   * @private
   * @param {function(Error)} callback
   * @returns {void}
   */
  _isInitialized (callback) {
    log('init check')
    parallel(
      {
        config: (cb) => this.config.exists(cb),
        spec: (cb) => this.spec.exists(cb),
        version: (cb) => this.version.check(repoVersion, cb)
      },
      (err, res) => {
        log('init', err, res)
        if (err && !res.config) {
          return callback(Object.assign(new Error('repo is not initialized yet'),
            {
              code: ERRORS.ERR_REPO_NOT_INITIALIZED,
              path: this.path
            }))
        }
        callback(err)
      }
    )
  }

  /**
   * Close the repo and cleanup.
   *
   * @param {function(Error)} callback
   * @returns {void}
   */
  close (callback) {
    if (this.closed) {
      return callback(new Error('repo is already closed'))
    }

    log('closing at: %s', this.path)
    series([
      (cb) => this.apiAddr.delete(ignoringNotFound(cb)),
      (cb) => {
        each(
          [this.blocks, this.keys, this.datastore],
          (store, callback) => store.close(callback),
          cb)
      },
      (cb) => {
        log('unlocking')
        this.closed = true
        this._closeLock(cb)
      },
      (cb) => {
        this.lockfile = null
        cb()
      }
    ], (err) => callback(err))
  }

  /**
   * Check if a repo exists.
   *
   * @param {function(Error, bool)} callback
   * @returns {void}
   */
  exists (callback) {
    this.version.exists(callback)
  }

  /**
   * Get repo status.
   *
   * @param {Object}  options
   * @param {Boolean} options.human
   * @param {function(Error, Object)} callback
   * @return {void}
   */
  stat (options, callback) {
    if (typeof options === 'function') {
      callback = options
      options = {}
    }

    options = Object.assign({}, { human: false }, options)

    parallel({
      storageMax: (cb) => this.config.get('Datastore.StorageMax', (err, max) => {
        if (err) {
          cb(null, new Big(noLimit))
        } else {
          cb(null, new Big(max))
        }
      }),
      version: (cb) => this.version.get(cb),
      blocks: (cb) => this.blocks.query({}, (err, list) => {
        list = list || []

        const count = new Big(list.length)
        let size = new Big(0)

        list.forEach(block => {
          size = size
            .plus(block.value.byteLength)
            .plus(block.key._buf.byteLength)
        })

        cb(err, {
          count: count,
          size: size
        })
      }),
      datastore: (cb) => getSize(this.datastore, cb),
      keys: (cb) => getSize(this.keys, cb)
    }, (err, results) => {
      if (err) return callback(err)

      let size = results.blocks.size
        .plus(results.datastore)
        .plus(results.keys)

      if (options.human) {
        size = size.div(1048576)
      }

      callback(null, {
        repoPath: this.path,
        storageMax: results.storageMax,
        version: results.version,
        numObjects: results.blocks.count,
        repoSize: size
      })
    })
  }
}

function getSize (queryFn, callback) {
  pull(
    queryFn.query({}),
    reduce((sum, block) => {
      return sum
        .plus(block.value.byteLength)
        .plus(block.key._buf.byteLength)
    }, new Big(0), callback))
}

module.exports = IpfsRepo
module.exports.repoVersion = repoVersion
module.exports.errors = ERRORS

function ignoringIf (cond, cb) {
  return (err) => {
    cb(err && !cond(err) ? err : null)
  }
}
function ignoringAlreadyOpened (cb) {
  return ignoringIf((err) => err.message === 'Already open', cb)
}

function ignoringNotFound (cb) {
  return ignoringIf((err) => {
    return err && (err.code === ERRORS.ERR_REPO_NOT_INITIALIZED || err.message.startsWith('ENOENT'))
  }, cb)
}

function buildOptions (_options) {
  const options = Object.assign({}, defaultOptions, _options)

  options.storageBackends = Object.assign(
    {},
    defaultOptions.storageBackends,
    options.storageBackends)

  options.storageBackendOptions = Object.assign(
    {},
    defaultOptions.storageBackendOptions,
    options.storageBackendOptions)

  return options
}

// TODO this should come from js-ipfs instead
function buildConfig (_config) {
  _config.datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore', {}))

  return _config
}

function buildDatastoreSpec (_config) {
  const spec = Object.assign({}, defaultDatastore.Spec, _get(_config, 'datastore.Spec', {}))

  return {
    type: spec.type,
    mounts: spec.mounts.map((mounting) => ({
      mountpoint: mounting.mountpoint,
      type: mounting.child.type,
      path: mounting.child.path,
      shardFunc: mounting.child.shardFunc
    }))
  }
}

}).call(this)}).call(this,require("timers").setImmediate)

      };
    };
  }
}, {package:"ipfs-repo",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js", {"./internal/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/setImmediate.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _setImmediate = require('./internal/setImmediate');

var _setImmediate2 = _interopRequireDefault(_setImmediate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Calls `callback` on a later loop around the event loop. In Node.js this just
 * calls `setImmediate`.  In the browser it will use `setImmediate` if
 * available, otherwise `setTimeout(callback, 0)`, which means other higher
 * priority events may precede the execution of `callback`.
 *
 * This is used internally for browser-compatibility purposes.
 *
 * @name setImmediate
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.nextTick]{@link module:Utils.nextTick}
 * @category Util
 * @param {Function} callback - The function to call on a later loop around
 * the event loop. Invoked with (args...).
 * @param {...*} args... - any number of additional arguments to pass to the
 * callback on the next tick.
 * @example
 *
 * var call_order = [];
 * async.nextTick(function() {
 *     call_order.push('two');
 *     // call_order now equals ['one','two']
 * });
 * call_order.push('one');
 *
 * async.setImmediate(function (a, b, c) {
 *     // a, b, and c equal 1, 2, and 3
 * }, 1, 2, 3);
 */
exports.default = _setImmediate2.default;
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/fsm-event/index.js", {"assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","fsm":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fsm/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/fsm-event/index.js
      return function (require, module, exports) {
const EventEmitter = require('events').EventEmitter
const assert = require('assert')
const fsm = require('fsm')

module.exports = fsmEvent

// create an fsmEvent instance
// obj -> fn
function fsmEvent (start, events) {
  if (typeof start === 'object') {
    events = start
    start = 'START'
  }
  assert.equal(typeof start, 'string')
  assert.equal(typeof events, 'object')
  assert.ok(events[start], 'invalid starting state ' + start)
  assert.ok(fsm.validate(events))

  const emitter = new EventEmitter()
  emit._graph = fsm.reachable(events)
  emit._emitter = emitter
  emit._events = events
  emit._state = start
  emit.emit = emit
  emit.on = on

  return emit

  // set a state listener
  // str, fn -> null
  function on (event, cb) {
    emitter.on(event, cb)
  }

  // change the state
  // str -> null
  function emit (str) {
    const nwState = emit._events[emit._state][str]
    if (!reach(emit._state, nwState, emit._graph)) {
      const err = 'invalid transition: ' + emit._state + ' -> ' + str
      return emitter.emit('error', err)
    }

    const leaveEv = emit._state + ':leave'
    const enterEv = nwState + ':enter'

    if (!emit._state) return enter()
    return leave()

    function leave () {
      if (!emitter._events[leaveEv]) enter()
      else emitter.emit(leaveEv, enter)
    }

    function enter () {
      if (!emitter._events[enterEv]) done()
      else emitter.emit(enterEv, done)
    }

    function done () {
      emit._state = nwState
      emitter.emit(nwState)
      emitter.emit('done')
    }
  }
}

// check if state can reach in reach
// str, str, obj -> bool
function reach (curr, next, reachable) {
  if (!next) return false
  if (!curr) return true

  const here = reachable[curr]
  if (!here || !here[next]) return false
  return here[next].length === 1
}

      };
    };
  }
}, {package:"fsm-event",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fsm-event/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/constants.js
      return function (require, module, exports) {
// THIS FILE IS GENERATED, DO NO EDIT MANUALLY
// For more information see the README.md
/* eslint-disable dot-notation */
'use strict'
module.exports = Object.freeze({

  // serialization
  PROTOBUF: 0x50,
  CBOR: 0x51,
  RLP: 0x60,
  BENCODE: 0x63,
  JSON: 0x0200,
  MESSAGEPACK: 0x0201,

  // multiformat
  MULTICODEC: 0x30,
  MULTIHASH: 0x31,
  MULTIADDR: 0x32,
  MULTIBASE: 0x33,

  // multihash
  IDENTITY: 0x00,
  SHA1: 0x11,
  SHA2_256: 0x12,
  SHA2_512: 0x13,
  SHA3_512: 0x14,
  SHA3_384: 0x15,
  SHA3_256: 0x16,
  SHA3_224: 0x17,
  SHAKE_128: 0x18,
  SHAKE_256: 0x19,
  KECCAK_224: 0x1a,
  KECCAK_256: 0x1b,
  KECCAK_384: 0x1c,
  KECCAK_512: 0x1d,
  MURMUR3_128: 0x22,
  MURMUR3_32: 0x23,
  DBL_SHA2_256: 0x56,
  MD4: 0xd4,
  MD5: 0xd5,
  BMT: 0xd6,
  X11: 0x1100,
  BLAKE2B_8: 0xb201,
  BLAKE2B_16: 0xb202,
  BLAKE2B_24: 0xb203,
  BLAKE2B_32: 0xb204,
  BLAKE2B_40: 0xb205,
  BLAKE2B_48: 0xb206,
  BLAKE2B_56: 0xb207,
  BLAKE2B_64: 0xb208,
  BLAKE2B_72: 0xb209,
  BLAKE2B_80: 0xb20a,
  BLAKE2B_88: 0xb20b,
  BLAKE2B_96: 0xb20c,
  BLAKE2B_104: 0xb20d,
  BLAKE2B_112: 0xb20e,
  BLAKE2B_120: 0xb20f,
  BLAKE2B_128: 0xb210,
  BLAKE2B_136: 0xb211,
  BLAKE2B_144: 0xb212,
  BLAKE2B_152: 0xb213,
  BLAKE2B_160: 0xb214,
  BLAKE2B_168: 0xb215,
  BLAKE2B_176: 0xb216,
  BLAKE2B_184: 0xb217,
  BLAKE2B_192: 0xb218,
  BLAKE2B_200: 0xb219,
  BLAKE2B_208: 0xb21a,
  BLAKE2B_216: 0xb21b,
  BLAKE2B_224: 0xb21c,
  BLAKE2B_232: 0xb21d,
  BLAKE2B_240: 0xb21e,
  BLAKE2B_248: 0xb21f,
  BLAKE2B_256: 0xb220,
  BLAKE2B_264: 0xb221,
  BLAKE2B_272: 0xb222,
  BLAKE2B_280: 0xb223,
  BLAKE2B_288: 0xb224,
  BLAKE2B_296: 0xb225,
  BLAKE2B_304: 0xb226,
  BLAKE2B_312: 0xb227,
  BLAKE2B_320: 0xb228,
  BLAKE2B_328: 0xb229,
  BLAKE2B_336: 0xb22a,
  BLAKE2B_344: 0xb22b,
  BLAKE2B_352: 0xb22c,
  BLAKE2B_360: 0xb22d,
  BLAKE2B_368: 0xb22e,
  BLAKE2B_376: 0xb22f,
  BLAKE2B_384: 0xb230,
  BLAKE2B_392: 0xb231,
  BLAKE2B_400: 0xb232,
  BLAKE2B_408: 0xb233,
  BLAKE2B_416: 0xb234,
  BLAKE2B_424: 0xb235,
  BLAKE2B_432: 0xb236,
  BLAKE2B_440: 0xb237,
  BLAKE2B_448: 0xb238,
  BLAKE2B_456: 0xb239,
  BLAKE2B_464: 0xb23a,
  BLAKE2B_472: 0xb23b,
  BLAKE2B_480: 0xb23c,
  BLAKE2B_488: 0xb23d,
  BLAKE2B_496: 0xb23e,
  BLAKE2B_504: 0xb23f,
  BLAKE2B_512: 0xb240,
  BLAKE2S_8: 0xb241,
  BLAKE2S_16: 0xb242,
  BLAKE2S_24: 0xb243,
  BLAKE2S_32: 0xb244,
  BLAKE2S_40: 0xb245,
  BLAKE2S_48: 0xb246,
  BLAKE2S_56: 0xb247,
  BLAKE2S_64: 0xb248,
  BLAKE2S_72: 0xb249,
  BLAKE2S_80: 0xb24a,
  BLAKE2S_88: 0xb24b,
  BLAKE2S_96: 0xb24c,
  BLAKE2S_104: 0xb24d,
  BLAKE2S_112: 0xb24e,
  BLAKE2S_120: 0xb24f,
  BLAKE2S_128: 0xb250,
  BLAKE2S_136: 0xb251,
  BLAKE2S_144: 0xb252,
  BLAKE2S_152: 0xb253,
  BLAKE2S_160: 0xb254,
  BLAKE2S_168: 0xb255,
  BLAKE2S_176: 0xb256,
  BLAKE2S_184: 0xb257,
  BLAKE2S_192: 0xb258,
  BLAKE2S_200: 0xb259,
  BLAKE2S_208: 0xb25a,
  BLAKE2S_216: 0xb25b,
  BLAKE2S_224: 0xb25c,
  BLAKE2S_232: 0xb25d,
  BLAKE2S_240: 0xb25e,
  BLAKE2S_248: 0xb25f,
  BLAKE2S_256: 0xb260,
  SKEIN256_8: 0xb301,
  SKEIN256_16: 0xb302,
  SKEIN256_24: 0xb303,
  SKEIN256_32: 0xb304,
  SKEIN256_40: 0xb305,
  SKEIN256_48: 0xb306,
  SKEIN256_56: 0xb307,
  SKEIN256_64: 0xb308,
  SKEIN256_72: 0xb309,
  SKEIN256_80: 0xb30a,
  SKEIN256_88: 0xb30b,
  SKEIN256_96: 0xb30c,
  SKEIN256_104: 0xb30d,
  SKEIN256_112: 0xb30e,
  SKEIN256_120: 0xb30f,
  SKEIN256_128: 0xb310,
  SKEIN256_136: 0xb311,
  SKEIN256_144: 0xb312,
  SKEIN256_152: 0xb313,
  SKEIN256_160: 0xb314,
  SKEIN256_168: 0xb315,
  SKEIN256_176: 0xb316,
  SKEIN256_184: 0xb317,
  SKEIN256_192: 0xb318,
  SKEIN256_200: 0xb319,
  SKEIN256_208: 0xb31a,
  SKEIN256_216: 0xb31b,
  SKEIN256_224: 0xb31c,
  SKEIN256_232: 0xb31d,
  SKEIN256_240: 0xb31e,
  SKEIN256_248: 0xb31f,
  SKEIN256_256: 0xb320,
  SKEIN512_8: 0xb321,
  SKEIN512_16: 0xb322,
  SKEIN512_24: 0xb323,
  SKEIN512_32: 0xb324,
  SKEIN512_40: 0xb325,
  SKEIN512_48: 0xb326,
  SKEIN512_56: 0xb327,
  SKEIN512_64: 0xb328,
  SKEIN512_72: 0xb329,
  SKEIN512_80: 0xb32a,
  SKEIN512_88: 0xb32b,
  SKEIN512_96: 0xb32c,
  SKEIN512_104: 0xb32d,
  SKEIN512_112: 0xb32e,
  SKEIN512_120: 0xb32f,
  SKEIN512_128: 0xb330,
  SKEIN512_136: 0xb331,
  SKEIN512_144: 0xb332,
  SKEIN512_152: 0xb333,
  SKEIN512_160: 0xb334,
  SKEIN512_168: 0xb335,
  SKEIN512_176: 0xb336,
  SKEIN512_184: 0xb337,
  SKEIN512_192: 0xb338,
  SKEIN512_200: 0xb339,
  SKEIN512_208: 0xb33a,
  SKEIN512_216: 0xb33b,
  SKEIN512_224: 0xb33c,
  SKEIN512_232: 0xb33d,
  SKEIN512_240: 0xb33e,
  SKEIN512_248: 0xb33f,
  SKEIN512_256: 0xb340,
  SKEIN512_264: 0xb341,
  SKEIN512_272: 0xb342,
  SKEIN512_280: 0xb343,
  SKEIN512_288: 0xb344,
  SKEIN512_296: 0xb345,
  SKEIN512_304: 0xb346,
  SKEIN512_312: 0xb347,
  SKEIN512_320: 0xb348,
  SKEIN512_328: 0xb349,
  SKEIN512_336: 0xb34a,
  SKEIN512_344: 0xb34b,
  SKEIN512_352: 0xb34c,
  SKEIN512_360: 0xb34d,
  SKEIN512_368: 0xb34e,
  SKEIN512_376: 0xb34f,
  SKEIN512_384: 0xb350,
  SKEIN512_392: 0xb351,
  SKEIN512_400: 0xb352,
  SKEIN512_408: 0xb353,
  SKEIN512_416: 0xb354,
  SKEIN512_424: 0xb355,
  SKEIN512_432: 0xb356,
  SKEIN512_440: 0xb357,
  SKEIN512_448: 0xb358,
  SKEIN512_456: 0xb359,
  SKEIN512_464: 0xb35a,
  SKEIN512_472: 0xb35b,
  SKEIN512_480: 0xb35c,
  SKEIN512_488: 0xb35d,
  SKEIN512_496: 0xb35e,
  SKEIN512_504: 0xb35f,
  SKEIN512_512: 0xb360,
  SKEIN1024_8: 0xb361,
  SKEIN1024_16: 0xb362,
  SKEIN1024_24: 0xb363,
  SKEIN1024_32: 0xb364,
  SKEIN1024_40: 0xb365,
  SKEIN1024_48: 0xb366,
  SKEIN1024_56: 0xb367,
  SKEIN1024_64: 0xb368,
  SKEIN1024_72: 0xb369,
  SKEIN1024_80: 0xb36a,
  SKEIN1024_88: 0xb36b,
  SKEIN1024_96: 0xb36c,
  SKEIN1024_104: 0xb36d,
  SKEIN1024_112: 0xb36e,
  SKEIN1024_120: 0xb36f,
  SKEIN1024_128: 0xb370,
  SKEIN1024_136: 0xb371,
  SKEIN1024_144: 0xb372,
  SKEIN1024_152: 0xb373,
  SKEIN1024_160: 0xb374,
  SKEIN1024_168: 0xb375,
  SKEIN1024_176: 0xb376,
  SKEIN1024_184: 0xb377,
  SKEIN1024_192: 0xb378,
  SKEIN1024_200: 0xb379,
  SKEIN1024_208: 0xb37a,
  SKEIN1024_216: 0xb37b,
  SKEIN1024_224: 0xb37c,
  SKEIN1024_232: 0xb37d,
  SKEIN1024_240: 0xb37e,
  SKEIN1024_248: 0xb37f,
  SKEIN1024_256: 0xb380,
  SKEIN1024_264: 0xb381,
  SKEIN1024_272: 0xb382,
  SKEIN1024_280: 0xb383,
  SKEIN1024_288: 0xb384,
  SKEIN1024_296: 0xb385,
  SKEIN1024_304: 0xb386,
  SKEIN1024_312: 0xb387,
  SKEIN1024_320: 0xb388,
  SKEIN1024_328: 0xb389,
  SKEIN1024_336: 0xb38a,
  SKEIN1024_344: 0xb38b,
  SKEIN1024_352: 0xb38c,
  SKEIN1024_360: 0xb38d,
  SKEIN1024_368: 0xb38e,
  SKEIN1024_376: 0xb38f,
  SKEIN1024_384: 0xb390,
  SKEIN1024_392: 0xb391,
  SKEIN1024_400: 0xb392,
  SKEIN1024_408: 0xb393,
  SKEIN1024_416: 0xb394,
  SKEIN1024_424: 0xb395,
  SKEIN1024_432: 0xb396,
  SKEIN1024_440: 0xb397,
  SKEIN1024_448: 0xb398,
  SKEIN1024_456: 0xb399,
  SKEIN1024_464: 0xb39a,
  SKEIN1024_472: 0xb39b,
  SKEIN1024_480: 0xb39c,
  SKEIN1024_488: 0xb39d,
  SKEIN1024_496: 0xb39e,
  SKEIN1024_504: 0xb39f,
  SKEIN1024_512: 0xb3a0,
  SKEIN1024_520: 0xb3a1,
  SKEIN1024_528: 0xb3a2,
  SKEIN1024_536: 0xb3a3,
  SKEIN1024_544: 0xb3a4,
  SKEIN1024_552: 0xb3a5,
  SKEIN1024_560: 0xb3a6,
  SKEIN1024_568: 0xb3a7,
  SKEIN1024_576: 0xb3a8,
  SKEIN1024_584: 0xb3a9,
  SKEIN1024_592: 0xb3aa,
  SKEIN1024_600: 0xb3ab,
  SKEIN1024_608: 0xb3ac,
  SKEIN1024_616: 0xb3ad,
  SKEIN1024_624: 0xb3ae,
  SKEIN1024_632: 0xb3af,
  SKEIN1024_640: 0xb3b0,
  SKEIN1024_648: 0xb3b1,
  SKEIN1024_656: 0xb3b2,
  SKEIN1024_664: 0xb3b3,
  SKEIN1024_672: 0xb3b4,
  SKEIN1024_680: 0xb3b5,
  SKEIN1024_688: 0xb3b6,
  SKEIN1024_696: 0xb3b7,
  SKEIN1024_704: 0xb3b8,
  SKEIN1024_712: 0xb3b9,
  SKEIN1024_720: 0xb3ba,
  SKEIN1024_728: 0xb3bb,
  SKEIN1024_736: 0xb3bc,
  SKEIN1024_744: 0xb3bd,
  SKEIN1024_752: 0xb3be,
  SKEIN1024_760: 0xb3bf,
  SKEIN1024_768: 0xb3c0,
  SKEIN1024_776: 0xb3c1,
  SKEIN1024_784: 0xb3c2,
  SKEIN1024_792: 0xb3c3,
  SKEIN1024_800: 0xb3c4,
  SKEIN1024_808: 0xb3c5,
  SKEIN1024_816: 0xb3c6,
  SKEIN1024_824: 0xb3c7,
  SKEIN1024_832: 0xb3c8,
  SKEIN1024_840: 0xb3c9,
  SKEIN1024_848: 0xb3ca,
  SKEIN1024_856: 0xb3cb,
  SKEIN1024_864: 0xb3cc,
  SKEIN1024_872: 0xb3cd,
  SKEIN1024_880: 0xb3ce,
  SKEIN1024_888: 0xb3cf,
  SKEIN1024_896: 0xb3d0,
  SKEIN1024_904: 0xb3d1,
  SKEIN1024_912: 0xb3d2,
  SKEIN1024_920: 0xb3d3,
  SKEIN1024_928: 0xb3d4,
  SKEIN1024_936: 0xb3d5,
  SKEIN1024_944: 0xb3d6,
  SKEIN1024_952: 0xb3d7,
  SKEIN1024_960: 0xb3d8,
  SKEIN1024_968: 0xb3d9,
  SKEIN1024_976: 0xb3da,
  SKEIN1024_984: 0xb3db,
  SKEIN1024_992: 0xb3dc,
  SKEIN1024_1000: 0xb3dd,
  SKEIN1024_1008: 0xb3de,
  SKEIN1024_1016: 0xb3df,
  SKEIN1024_1024: 0xb3e0,

  // multiaddr
  IP4: 0x04,
  TCP: 0x06,
  DCCP: 0x21,
  IP6: 0x29,
  IP6ZONE: 0x2a,
  DNS: 0x35,
  DNS4: 0x36,
  DNS6: 0x37,
  DNSADDR: 0x38,
  SCTP: 0x84,
  UDP: 0x0111,
  P2P_WEBRTC_STAR: 0x0113,
  P2P_WEBRTC_DIRECT: 0x0114,
  P2P_STARDUST: 0x0115,
  P2P_CIRCUIT: 0x0122,
  UDT: 0x012d,
  UTP: 0x012e,
  UNIX: 0x0190,
  P2P: 0x01a5,
  IPFS: 0x01a5,
  HTTPS: 0x01bb,
  ONION: 0x01bc,
  ONION3: 0x01bd,
  GARLIC64: 0x01be,
  GARLIC32: 0x01bf,
  QUIC: 0x01cc,
  WS: 0x01dd,
  WSS: 0x01de,
  P2P_WEBSOCKET_STAR: 0x01df,
  HTTP: 0x01e0,

  // ipld
  RAW: 0x55,
  DAG_PB: 0x70,
  DAG_CBOR: 0x71,
  LIBP2P_KEY: 0x72,
  GIT_RAW: 0x78,
  TORRENT_INFO: 0x7b,
  TORRENT_FILE: 0x7c,
  LEOFCOIN_BLOCK: 0x81,
  LEOFCOIN_TX: 0x82,
  LEOFCOIN_PR: 0x83,
  ETH_BLOCK: 0x90,
  ETH_BLOCK_LIST: 0x91,
  ETH_TX_TRIE: 0x92,
  ETH_TX: 0x93,
  ETH_TX_RECEIPT_TRIE: 0x94,
  ETH_TX_RECEIPT: 0x95,
  ETH_STATE_TRIE: 0x96,
  ETH_ACCOUNT_SNAPSHOT: 0x97,
  ETH_STORAGE_TRIE: 0x98,
  BITCOIN_BLOCK: 0xb0,
  BITCOIN_TX: 0xb1,
  ZCASH_BLOCK: 0xc0,
  ZCASH_TX: 0xc1,
  STELLAR_BLOCK: 0xd0,
  STELLAR_TX: 0xd1,
  DECRED_BLOCK: 0xe0,
  DECRED_TX: 0xe1,
  DASH_BLOCK: 0xf0,
  DASH_TX: 0xf1,
  SWARM_MANIFEST: 0xfa,
  SWARM_FEED: 0xfb,
  DAG_JSON: 0x0129,

  // namespace
  PATH: 0x2f,
  IPLD_NS: 0xe2,
  IPFS_NS: 0xe3,
  SWARM_NS: 0xe4,
  IPNS_NS: 0xe5,
  ZERONET: 0xe6,

  // key
  ED25519_PUB: 0xed,

  // holochain
  HOLOCHAIN_ADR_V0: 0x807124,
  HOLOCHAIN_ADR_V1: 0x817124,
  HOLOCHAIN_KEY_V0: 0x947124,
  HOLOCHAIN_KEY_V1: 0x957124,
  HOLOCHAIN_SIG_V0: 0xa27124,
  HOLOCHAIN_SIG_V1: 0xa37124
})

      };
    };
  }
}, {package:"multicodec",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/print.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/print.js
      return function (require, module, exports) {
// THIS FILE IS GENERATED, DO NO EDIT MANUALLY
// For more information see the README.md
/* eslint-disable dot-notation */
'use strict'
module.exports = Object.freeze({

  // serialization
  0x50: 'protobuf',
  0x51: 'cbor',
  0x60: 'rlp',
  0x63: 'bencode',
  0x0200: 'json',
  0x0201: 'messagepack',

  // multiformat
  0x30: 'multicodec',
  0x31: 'multihash',
  0x32: 'multiaddr',
  0x33: 'multibase',

  // multihash
  0x00: 'identity',
  0x11: 'sha1',
  0x12: 'sha2-256',
  0x13: 'sha2-512',
  0x14: 'sha3-512',
  0x15: 'sha3-384',
  0x16: 'sha3-256',
  0x17: 'sha3-224',
  0x18: 'shake-128',
  0x19: 'shake-256',
  0x1a: 'keccak-224',
  0x1b: 'keccak-256',
  0x1c: 'keccak-384',
  0x1d: 'keccak-512',
  0x22: 'murmur3-128',
  0x23: 'murmur3-32',
  0x56: 'dbl-sha2-256',
  0xd4: 'md4',
  0xd5: 'md5',
  0xd6: 'bmt',
  0x1100: 'x11',
  0xb201: 'blake2b-8',
  0xb202: 'blake2b-16',
  0xb203: 'blake2b-24',
  0xb204: 'blake2b-32',
  0xb205: 'blake2b-40',
  0xb206: 'blake2b-48',
  0xb207: 'blake2b-56',
  0xb208: 'blake2b-64',
  0xb209: 'blake2b-72',
  0xb20a: 'blake2b-80',
  0xb20b: 'blake2b-88',
  0xb20c: 'blake2b-96',
  0xb20d: 'blake2b-104',
  0xb20e: 'blake2b-112',
  0xb20f: 'blake2b-120',
  0xb210: 'blake2b-128',
  0xb211: 'blake2b-136',
  0xb212: 'blake2b-144',
  0xb213: 'blake2b-152',
  0xb214: 'blake2b-160',
  0xb215: 'blake2b-168',
  0xb216: 'blake2b-176',
  0xb217: 'blake2b-184',
  0xb218: 'blake2b-192',
  0xb219: 'blake2b-200',
  0xb21a: 'blake2b-208',
  0xb21b: 'blake2b-216',
  0xb21c: 'blake2b-224',
  0xb21d: 'blake2b-232',
  0xb21e: 'blake2b-240',
  0xb21f: 'blake2b-248',
  0xb220: 'blake2b-256',
  0xb221: 'blake2b-264',
  0xb222: 'blake2b-272',
  0xb223: 'blake2b-280',
  0xb224: 'blake2b-288',
  0xb225: 'blake2b-296',
  0xb226: 'blake2b-304',
  0xb227: 'blake2b-312',
  0xb228: 'blake2b-320',
  0xb229: 'blake2b-328',
  0xb22a: 'blake2b-336',
  0xb22b: 'blake2b-344',
  0xb22c: 'blake2b-352',
  0xb22d: 'blake2b-360',
  0xb22e: 'blake2b-368',
  0xb22f: 'blake2b-376',
  0xb230: 'blake2b-384',
  0xb231: 'blake2b-392',
  0xb232: 'blake2b-400',
  0xb233: 'blake2b-408',
  0xb234: 'blake2b-416',
  0xb235: 'blake2b-424',
  0xb236: 'blake2b-432',
  0xb237: 'blake2b-440',
  0xb238: 'blake2b-448',
  0xb239: 'blake2b-456',
  0xb23a: 'blake2b-464',
  0xb23b: 'blake2b-472',
  0xb23c: 'blake2b-480',
  0xb23d: 'blake2b-488',
  0xb23e: 'blake2b-496',
  0xb23f: 'blake2b-504',
  0xb240: 'blake2b-512',
  0xb241: 'blake2s-8',
  0xb242: 'blake2s-16',
  0xb243: 'blake2s-24',
  0xb244: 'blake2s-32',
  0xb245: 'blake2s-40',
  0xb246: 'blake2s-48',
  0xb247: 'blake2s-56',
  0xb248: 'blake2s-64',
  0xb249: 'blake2s-72',
  0xb24a: 'blake2s-80',
  0xb24b: 'blake2s-88',
  0xb24c: 'blake2s-96',
  0xb24d: 'blake2s-104',
  0xb24e: 'blake2s-112',
  0xb24f: 'blake2s-120',
  0xb250: 'blake2s-128',
  0xb251: 'blake2s-136',
  0xb252: 'blake2s-144',
  0xb253: 'blake2s-152',
  0xb254: 'blake2s-160',
  0xb255: 'blake2s-168',
  0xb256: 'blake2s-176',
  0xb257: 'blake2s-184',
  0xb258: 'blake2s-192',
  0xb259: 'blake2s-200',
  0xb25a: 'blake2s-208',
  0xb25b: 'blake2s-216',
  0xb25c: 'blake2s-224',
  0xb25d: 'blake2s-232',
  0xb25e: 'blake2s-240',
  0xb25f: 'blake2s-248',
  0xb260: 'blake2s-256',
  0xb301: 'skein256-8',
  0xb302: 'skein256-16',
  0xb303: 'skein256-24',
  0xb304: 'skein256-32',
  0xb305: 'skein256-40',
  0xb306: 'skein256-48',
  0xb307: 'skein256-56',
  0xb308: 'skein256-64',
  0xb309: 'skein256-72',
  0xb30a: 'skein256-80',
  0xb30b: 'skein256-88',
  0xb30c: 'skein256-96',
  0xb30d: 'skein256-104',
  0xb30e: 'skein256-112',
  0xb30f: 'skein256-120',
  0xb310: 'skein256-128',
  0xb311: 'skein256-136',
  0xb312: 'skein256-144',
  0xb313: 'skein256-152',
  0xb314: 'skein256-160',
  0xb315: 'skein256-168',
  0xb316: 'skein256-176',
  0xb317: 'skein256-184',
  0xb318: 'skein256-192',
  0xb319: 'skein256-200',
  0xb31a: 'skein256-208',
  0xb31b: 'skein256-216',
  0xb31c: 'skein256-224',
  0xb31d: 'skein256-232',
  0xb31e: 'skein256-240',
  0xb31f: 'skein256-248',
  0xb320: 'skein256-256',
  0xb321: 'skein512-8',
  0xb322: 'skein512-16',
  0xb323: 'skein512-24',
  0xb324: 'skein512-32',
  0xb325: 'skein512-40',
  0xb326: 'skein512-48',
  0xb327: 'skein512-56',
  0xb328: 'skein512-64',
  0xb329: 'skein512-72',
  0xb32a: 'skein512-80',
  0xb32b: 'skein512-88',
  0xb32c: 'skein512-96',
  0xb32d: 'skein512-104',
  0xb32e: 'skein512-112',
  0xb32f: 'skein512-120',
  0xb330: 'skein512-128',
  0xb331: 'skein512-136',
  0xb332: 'skein512-144',
  0xb333: 'skein512-152',
  0xb334: 'skein512-160',
  0xb335: 'skein512-168',
  0xb336: 'skein512-176',
  0xb337: 'skein512-184',
  0xb338: 'skein512-192',
  0xb339: 'skein512-200',
  0xb33a: 'skein512-208',
  0xb33b: 'skein512-216',
  0xb33c: 'skein512-224',
  0xb33d: 'skein512-232',
  0xb33e: 'skein512-240',
  0xb33f: 'skein512-248',
  0xb340: 'skein512-256',
  0xb341: 'skein512-264',
  0xb342: 'skein512-272',
  0xb343: 'skein512-280',
  0xb344: 'skein512-288',
  0xb345: 'skein512-296',
  0xb346: 'skein512-304',
  0xb347: 'skein512-312',
  0xb348: 'skein512-320',
  0xb349: 'skein512-328',
  0xb34a: 'skein512-336',
  0xb34b: 'skein512-344',
  0xb34c: 'skein512-352',
  0xb34d: 'skein512-360',
  0xb34e: 'skein512-368',
  0xb34f: 'skein512-376',
  0xb350: 'skein512-384',
  0xb351: 'skein512-392',
  0xb352: 'skein512-400',
  0xb353: 'skein512-408',
  0xb354: 'skein512-416',
  0xb355: 'skein512-424',
  0xb356: 'skein512-432',
  0xb357: 'skein512-440',
  0xb358: 'skein512-448',
  0xb359: 'skein512-456',
  0xb35a: 'skein512-464',
  0xb35b: 'skein512-472',
  0xb35c: 'skein512-480',
  0xb35d: 'skein512-488',
  0xb35e: 'skein512-496',
  0xb35f: 'skein512-504',
  0xb360: 'skein512-512',
  0xb361: 'skein1024-8',
  0xb362: 'skein1024-16',
  0xb363: 'skein1024-24',
  0xb364: 'skein1024-32',
  0xb365: 'skein1024-40',
  0xb366: 'skein1024-48',
  0xb367: 'skein1024-56',
  0xb368: 'skein1024-64',
  0xb369: 'skein1024-72',
  0xb36a: 'skein1024-80',
  0xb36b: 'skein1024-88',
  0xb36c: 'skein1024-96',
  0xb36d: 'skein1024-104',
  0xb36e: 'skein1024-112',
  0xb36f: 'skein1024-120',
  0xb370: 'skein1024-128',
  0xb371: 'skein1024-136',
  0xb372: 'skein1024-144',
  0xb373: 'skein1024-152',
  0xb374: 'skein1024-160',
  0xb375: 'skein1024-168',
  0xb376: 'skein1024-176',
  0xb377: 'skein1024-184',
  0xb378: 'skein1024-192',
  0xb379: 'skein1024-200',
  0xb37a: 'skein1024-208',
  0xb37b: 'skein1024-216',
  0xb37c: 'skein1024-224',
  0xb37d: 'skein1024-232',
  0xb37e: 'skein1024-240',
  0xb37f: 'skein1024-248',
  0xb380: 'skein1024-256',
  0xb381: 'skein1024-264',
  0xb382: 'skein1024-272',
  0xb383: 'skein1024-280',
  0xb384: 'skein1024-288',
  0xb385: 'skein1024-296',
  0xb386: 'skein1024-304',
  0xb387: 'skein1024-312',
  0xb388: 'skein1024-320',
  0xb389: 'skein1024-328',
  0xb38a: 'skein1024-336',
  0xb38b: 'skein1024-344',
  0xb38c: 'skein1024-352',
  0xb38d: 'skein1024-360',
  0xb38e: 'skein1024-368',
  0xb38f: 'skein1024-376',
  0xb390: 'skein1024-384',
  0xb391: 'skein1024-392',
  0xb392: 'skein1024-400',
  0xb393: 'skein1024-408',
  0xb394: 'skein1024-416',
  0xb395: 'skein1024-424',
  0xb396: 'skein1024-432',
  0xb397: 'skein1024-440',
  0xb398: 'skein1024-448',
  0xb399: 'skein1024-456',
  0xb39a: 'skein1024-464',
  0xb39b: 'skein1024-472',
  0xb39c: 'skein1024-480',
  0xb39d: 'skein1024-488',
  0xb39e: 'skein1024-496',
  0xb39f: 'skein1024-504',
  0xb3a0: 'skein1024-512',
  0xb3a1: 'skein1024-520',
  0xb3a2: 'skein1024-528',
  0xb3a3: 'skein1024-536',
  0xb3a4: 'skein1024-544',
  0xb3a5: 'skein1024-552',
  0xb3a6: 'skein1024-560',
  0xb3a7: 'skein1024-568',
  0xb3a8: 'skein1024-576',
  0xb3a9: 'skein1024-584',
  0xb3aa: 'skein1024-592',
  0xb3ab: 'skein1024-600',
  0xb3ac: 'skein1024-608',
  0xb3ad: 'skein1024-616',
  0xb3ae: 'skein1024-624',
  0xb3af: 'skein1024-632',
  0xb3b0: 'skein1024-640',
  0xb3b1: 'skein1024-648',
  0xb3b2: 'skein1024-656',
  0xb3b3: 'skein1024-664',
  0xb3b4: 'skein1024-672',
  0xb3b5: 'skein1024-680',
  0xb3b6: 'skein1024-688',
  0xb3b7: 'skein1024-696',
  0xb3b8: 'skein1024-704',
  0xb3b9: 'skein1024-712',
  0xb3ba: 'skein1024-720',
  0xb3bb: 'skein1024-728',
  0xb3bc: 'skein1024-736',
  0xb3bd: 'skein1024-744',
  0xb3be: 'skein1024-752',
  0xb3bf: 'skein1024-760',
  0xb3c0: 'skein1024-768',
  0xb3c1: 'skein1024-776',
  0xb3c2: 'skein1024-784',
  0xb3c3: 'skein1024-792',
  0xb3c4: 'skein1024-800',
  0xb3c5: 'skein1024-808',
  0xb3c6: 'skein1024-816',
  0xb3c7: 'skein1024-824',
  0xb3c8: 'skein1024-832',
  0xb3c9: 'skein1024-840',
  0xb3ca: 'skein1024-848',
  0xb3cb: 'skein1024-856',
  0xb3cc: 'skein1024-864',
  0xb3cd: 'skein1024-872',
  0xb3ce: 'skein1024-880',
  0xb3cf: 'skein1024-888',
  0xb3d0: 'skein1024-896',
  0xb3d1: 'skein1024-904',
  0xb3d2: 'skein1024-912',
  0xb3d3: 'skein1024-920',
  0xb3d4: 'skein1024-928',
  0xb3d5: 'skein1024-936',
  0xb3d6: 'skein1024-944',
  0xb3d7: 'skein1024-952',
  0xb3d8: 'skein1024-960',
  0xb3d9: 'skein1024-968',
  0xb3da: 'skein1024-976',
  0xb3db: 'skein1024-984',
  0xb3dc: 'skein1024-992',
  0xb3dd: 'skein1024-1000',
  0xb3de: 'skein1024-1008',
  0xb3df: 'skein1024-1016',
  0xb3e0: 'skein1024-1024',

  // multiaddr
  0x04: 'ip4',
  0x06: 'tcp',
  0x21: 'dccp',
  0x29: 'ip6',
  0x2a: 'ip6zone',
  0x35: 'dns',
  0x36: 'dns4',
  0x37: 'dns6',
  0x38: 'dnsaddr',
  0x84: 'sctp',
  0x0111: 'udp',
  0x0113: 'p2p-webrtc-star',
  0x0114: 'p2p-webrtc-direct',
  0x0115: 'p2p-stardust',
  0x0122: 'p2p-circuit',
  0x012d: 'udt',
  0x012e: 'utp',
  0x0190: 'unix',
  0x01a5: 'p2p',
  0x01bb: 'https',
  0x01bc: 'onion',
  0x01bd: 'onion3',
  0x01be: 'garlic64',
  0x01bf: 'garlic32',
  0x01cc: 'quic',
  0x01dd: 'ws',
  0x01de: 'wss',
  0x01df: 'p2p-websocket-star',
  0x01e0: 'http',

  // ipld
  0x55: 'raw',
  0x70: 'dag-pb',
  0x71: 'dag-cbor',
  0x72: 'libp2p-key',
  0x78: 'git-raw',
  0x7b: 'torrent-info',
  0x7c: 'torrent-file',
  0x81: 'leofcoin-block',
  0x82: 'leofcoin-tx',
  0x83: 'leofcoin-pr',
  0x90: 'eth-block',
  0x91: 'eth-block-list',
  0x92: 'eth-tx-trie',
  0x93: 'eth-tx',
  0x94: 'eth-tx-receipt-trie',
  0x95: 'eth-tx-receipt',
  0x96: 'eth-state-trie',
  0x97: 'eth-account-snapshot',
  0x98: 'eth-storage-trie',
  0xb0: 'bitcoin-block',
  0xb1: 'bitcoin-tx',
  0xc0: 'zcash-block',
  0xc1: 'zcash-tx',
  0xd0: 'stellar-block',
  0xd1: 'stellar-tx',
  0xe0: 'decred-block',
  0xe1: 'decred-tx',
  0xf0: 'dash-block',
  0xf1: 'dash-tx',
  0xfa: 'swarm-manifest',
  0xfb: 'swarm-feed',
  0x0129: 'dag-json',

  // namespace
  0x2f: 'path',
  0xe2: 'ipld-ns',
  0xe3: 'ipfs-ns',
  0xe4: 'swarm-ns',
  0xe5: 'ipns-ns',
  0xe6: 'zeronet',

  // key
  0xed: 'ed25519-pub',

  // holochain
  0x807124: 'holochain-adr-v0',
  0x817124: 'holochain-adr-v1',
  0x947124: 'holochain-key-v0',
  0x957124: 'holochain-key-v1',
  0xa27124: 'holochain-sig-v0',
  0xa37124: 'holochain-sig-v1'
})

      };
    };
  }
}, {package:"multicodec",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/print.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/name-table.js", {"./base-table":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/base-table.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/name-table.js
      return function (require, module, exports) {
'use strict'
const baseTable = require('./base-table')

// this creates a map for code as hexString -> codecName

const nameTable = {}
module.exports = nameTable

for (let encodingName in baseTable) {
  let code = baseTable[encodingName]
  nameTable[code.toString('hex')] = encodingName
}

      };
    };
  }
}, {package:"multicodec",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/name-table.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/varint-table.js", {"./base-table":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/base-table.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/varint-table.js
      return function (require, module, exports) {
'use strict'
const baseTable = require('./base-table')
const varintBufferEncode = require('./util').varintBufferEncode

// this creates a map for codecName -> codeVarintBuffer

const varintTable = {}
module.exports = varintTable

for (let encodingName in baseTable) {
  let code = baseTable[encodingName]
  varintTable[encodingName] = varintBufferEncode(code)
}

      };
    };
  }
}, {package:"multicodec",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/varint-table.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/util.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/util.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'
const varint = require('varint')

module.exports = {
  numberToBuffer,
  bufferToNumber,
  varintBufferEncode,
  varintBufferDecode
}

function bufferToNumber (buf) {
  return parseInt(buf.toString('hex'), 16)
}

function numberToBuffer (num) {
  let hexString = num.toString(16)
  if (hexString.length % 2 === 1) {
    hexString = '0' + hexString
  }
  return Buffer.from(hexString, 'hex')
}

function varintBufferEncode (input) {
  return Buffer.from(varint.encode(bufferToNumber(input)))
}

function varintBufferDecode (input) {
  return numberToBuffer(varint.decode(input))
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multicodec",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/class-is/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/class-is/index.js
      return function (require, module, exports) {
'use strict';

function withIs(Class, { className, symbolName }) {
    const symbol = Symbol.for(symbolName);

    const ClassIsWrapper = {
        // The code below assigns the class wrapper to an object to trick
        // JavaScript engines to show the name of the extended class when
        // logging an instances.
        // We are assigning an anonymous class (class wrapper) to the object
        // with key `className` to keep the correct name.
        // If this is not supported it falls back to logging `ClassIsWrapper`.
        [className]: class extends Class {
            constructor(...args) {
                super(...args);
                Object.defineProperty(this, symbol, { value: true });
            }

            get [Symbol.toStringTag]() {
                return className;
            }
        },
    }[className];

    ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);

    return ClassIsWrapper;
}

function withIsProto(Class, { className, symbolName, withoutNew }) {
    const symbol = Symbol.for(symbolName);

    /* eslint-disable object-shorthand */
    const ClassIsWrapper = {
        [className]: function (...args) {
            if (withoutNew && !(this instanceof ClassIsWrapper)) {
                return new ClassIsWrapper(...args);
            }

            const _this = Class.call(this, ...args) || this;

            if (_this && !_this[symbol]) {
                Object.defineProperty(_this, symbol, { value: true });
            }

            return _this;
        },
    }[className];
    /* eslint-enable object-shorthand */

    ClassIsWrapper.prototype = Object.create(Class.prototype);
    ClassIsWrapper.prototype.constructor = ClassIsWrapper;

    Object.defineProperty(ClassIsWrapper.prototype, Symbol.toStringTag, {
        get() {
            return className;
        },
    });

    ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);

    return ClassIsWrapper;
}

module.exports = withIs;
module.exports.proto = withIsProto;

      };
    };
  }
}, {package:"class-is",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/class-is/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/base-table.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/base-table.js
      return function (require, module, exports) {
(function (Buffer){(function (){
// THIS FILE IS GENERATED, DO NO EDIT MANUALLY
// For more information see the README.md
/* eslint-disable dot-notation */
'use strict'

// serialization
exports['protobuf'] = Buffer.from('50', 'hex')
exports['cbor'] = Buffer.from('51', 'hex')
exports['rlp'] = Buffer.from('60', 'hex')
exports['bencode'] = Buffer.from('63', 'hex')
exports['json'] = Buffer.from('0200', 'hex')
exports['messagepack'] = Buffer.from('0201', 'hex')

// multiformat
exports['multicodec'] = Buffer.from('30', 'hex')
exports['multihash'] = Buffer.from('31', 'hex')
exports['multiaddr'] = Buffer.from('32', 'hex')
exports['multibase'] = Buffer.from('33', 'hex')

// multihash
exports['identity'] = Buffer.from('00', 'hex')
exports['sha1'] = Buffer.from('11', 'hex')
exports['sha2-256'] = Buffer.from('12', 'hex')
exports['sha2-512'] = Buffer.from('13', 'hex')
exports['sha3-512'] = Buffer.from('14', 'hex')
exports['sha3-384'] = Buffer.from('15', 'hex')
exports['sha3-256'] = Buffer.from('16', 'hex')
exports['sha3-224'] = Buffer.from('17', 'hex')
exports['shake-128'] = Buffer.from('18', 'hex')
exports['shake-256'] = Buffer.from('19', 'hex')
exports['keccak-224'] = Buffer.from('1a', 'hex')
exports['keccak-256'] = Buffer.from('1b', 'hex')
exports['keccak-384'] = Buffer.from('1c', 'hex')
exports['keccak-512'] = Buffer.from('1d', 'hex')
exports['murmur3-128'] = Buffer.from('22', 'hex')
exports['murmur3-32'] = Buffer.from('23', 'hex')
exports['dbl-sha2-256'] = Buffer.from('56', 'hex')
exports['md4'] = Buffer.from('d4', 'hex')
exports['md5'] = Buffer.from('d5', 'hex')
exports['bmt'] = Buffer.from('d6', 'hex')
exports['x11'] = Buffer.from('1100', 'hex')
exports['blake2b-8'] = Buffer.from('b201', 'hex')
exports['blake2b-16'] = Buffer.from('b202', 'hex')
exports['blake2b-24'] = Buffer.from('b203', 'hex')
exports['blake2b-32'] = Buffer.from('b204', 'hex')
exports['blake2b-40'] = Buffer.from('b205', 'hex')
exports['blake2b-48'] = Buffer.from('b206', 'hex')
exports['blake2b-56'] = Buffer.from('b207', 'hex')
exports['blake2b-64'] = Buffer.from('b208', 'hex')
exports['blake2b-72'] = Buffer.from('b209', 'hex')
exports['blake2b-80'] = Buffer.from('b20a', 'hex')
exports['blake2b-88'] = Buffer.from('b20b', 'hex')
exports['blake2b-96'] = Buffer.from('b20c', 'hex')
exports['blake2b-104'] = Buffer.from('b20d', 'hex')
exports['blake2b-112'] = Buffer.from('b20e', 'hex')
exports['blake2b-120'] = Buffer.from('b20f', 'hex')
exports['blake2b-128'] = Buffer.from('b210', 'hex')
exports['blake2b-136'] = Buffer.from('b211', 'hex')
exports['blake2b-144'] = Buffer.from('b212', 'hex')
exports['blake2b-152'] = Buffer.from('b213', 'hex')
exports['blake2b-160'] = Buffer.from('b214', 'hex')
exports['blake2b-168'] = Buffer.from('b215', 'hex')
exports['blake2b-176'] = Buffer.from('b216', 'hex')
exports['blake2b-184'] = Buffer.from('b217', 'hex')
exports['blake2b-192'] = Buffer.from('b218', 'hex')
exports['blake2b-200'] = Buffer.from('b219', 'hex')
exports['blake2b-208'] = Buffer.from('b21a', 'hex')
exports['blake2b-216'] = Buffer.from('b21b', 'hex')
exports['blake2b-224'] = Buffer.from('b21c', 'hex')
exports['blake2b-232'] = Buffer.from('b21d', 'hex')
exports['blake2b-240'] = Buffer.from('b21e', 'hex')
exports['blake2b-248'] = Buffer.from('b21f', 'hex')
exports['blake2b-256'] = Buffer.from('b220', 'hex')
exports['blake2b-264'] = Buffer.from('b221', 'hex')
exports['blake2b-272'] = Buffer.from('b222', 'hex')
exports['blake2b-280'] = Buffer.from('b223', 'hex')
exports['blake2b-288'] = Buffer.from('b224', 'hex')
exports['blake2b-296'] = Buffer.from('b225', 'hex')
exports['blake2b-304'] = Buffer.from('b226', 'hex')
exports['blake2b-312'] = Buffer.from('b227', 'hex')
exports['blake2b-320'] = Buffer.from('b228', 'hex')
exports['blake2b-328'] = Buffer.from('b229', 'hex')
exports['blake2b-336'] = Buffer.from('b22a', 'hex')
exports['blake2b-344'] = Buffer.from('b22b', 'hex')
exports['blake2b-352'] = Buffer.from('b22c', 'hex')
exports['blake2b-360'] = Buffer.from('b22d', 'hex')
exports['blake2b-368'] = Buffer.from('b22e', 'hex')
exports['blake2b-376'] = Buffer.from('b22f', 'hex')
exports['blake2b-384'] = Buffer.from('b230', 'hex')
exports['blake2b-392'] = Buffer.from('b231', 'hex')
exports['blake2b-400'] = Buffer.from('b232', 'hex')
exports['blake2b-408'] = Buffer.from('b233', 'hex')
exports['blake2b-416'] = Buffer.from('b234', 'hex')
exports['blake2b-424'] = Buffer.from('b235', 'hex')
exports['blake2b-432'] = Buffer.from('b236', 'hex')
exports['blake2b-440'] = Buffer.from('b237', 'hex')
exports['blake2b-448'] = Buffer.from('b238', 'hex')
exports['blake2b-456'] = Buffer.from('b239', 'hex')
exports['blake2b-464'] = Buffer.from('b23a', 'hex')
exports['blake2b-472'] = Buffer.from('b23b', 'hex')
exports['blake2b-480'] = Buffer.from('b23c', 'hex')
exports['blake2b-488'] = Buffer.from('b23d', 'hex')
exports['blake2b-496'] = Buffer.from('b23e', 'hex')
exports['blake2b-504'] = Buffer.from('b23f', 'hex')
exports['blake2b-512'] = Buffer.from('b240', 'hex')
exports['blake2s-8'] = Buffer.from('b241', 'hex')
exports['blake2s-16'] = Buffer.from('b242', 'hex')
exports['blake2s-24'] = Buffer.from('b243', 'hex')
exports['blake2s-32'] = Buffer.from('b244', 'hex')
exports['blake2s-40'] = Buffer.from('b245', 'hex')
exports['blake2s-48'] = Buffer.from('b246', 'hex')
exports['blake2s-56'] = Buffer.from('b247', 'hex')
exports['blake2s-64'] = Buffer.from('b248', 'hex')
exports['blake2s-72'] = Buffer.from('b249', 'hex')
exports['blake2s-80'] = Buffer.from('b24a', 'hex')
exports['blake2s-88'] = Buffer.from('b24b', 'hex')
exports['blake2s-96'] = Buffer.from('b24c', 'hex')
exports['blake2s-104'] = Buffer.from('b24d', 'hex')
exports['blake2s-112'] = Buffer.from('b24e', 'hex')
exports['blake2s-120'] = Buffer.from('b24f', 'hex')
exports['blake2s-128'] = Buffer.from('b250', 'hex')
exports['blake2s-136'] = Buffer.from('b251', 'hex')
exports['blake2s-144'] = Buffer.from('b252', 'hex')
exports['blake2s-152'] = Buffer.from('b253', 'hex')
exports['blake2s-160'] = Buffer.from('b254', 'hex')
exports['blake2s-168'] = Buffer.from('b255', 'hex')
exports['blake2s-176'] = Buffer.from('b256', 'hex')
exports['blake2s-184'] = Buffer.from('b257', 'hex')
exports['blake2s-192'] = Buffer.from('b258', 'hex')
exports['blake2s-200'] = Buffer.from('b259', 'hex')
exports['blake2s-208'] = Buffer.from('b25a', 'hex')
exports['blake2s-216'] = Buffer.from('b25b', 'hex')
exports['blake2s-224'] = Buffer.from('b25c', 'hex')
exports['blake2s-232'] = Buffer.from('b25d', 'hex')
exports['blake2s-240'] = Buffer.from('b25e', 'hex')
exports['blake2s-248'] = Buffer.from('b25f', 'hex')
exports['blake2s-256'] = Buffer.from('b260', 'hex')
exports['skein256-8'] = Buffer.from('b301', 'hex')
exports['skein256-16'] = Buffer.from('b302', 'hex')
exports['skein256-24'] = Buffer.from('b303', 'hex')
exports['skein256-32'] = Buffer.from('b304', 'hex')
exports['skein256-40'] = Buffer.from('b305', 'hex')
exports['skein256-48'] = Buffer.from('b306', 'hex')
exports['skein256-56'] = Buffer.from('b307', 'hex')
exports['skein256-64'] = Buffer.from('b308', 'hex')
exports['skein256-72'] = Buffer.from('b309', 'hex')
exports['skein256-80'] = Buffer.from('b30a', 'hex')
exports['skein256-88'] = Buffer.from('b30b', 'hex')
exports['skein256-96'] = Buffer.from('b30c', 'hex')
exports['skein256-104'] = Buffer.from('b30d', 'hex')
exports['skein256-112'] = Buffer.from('b30e', 'hex')
exports['skein256-120'] = Buffer.from('b30f', 'hex')
exports['skein256-128'] = Buffer.from('b310', 'hex')
exports['skein256-136'] = Buffer.from('b311', 'hex')
exports['skein256-144'] = Buffer.from('b312', 'hex')
exports['skein256-152'] = Buffer.from('b313', 'hex')
exports['skein256-160'] = Buffer.from('b314', 'hex')
exports['skein256-168'] = Buffer.from('b315', 'hex')
exports['skein256-176'] = Buffer.from('b316', 'hex')
exports['skein256-184'] = Buffer.from('b317', 'hex')
exports['skein256-192'] = Buffer.from('b318', 'hex')
exports['skein256-200'] = Buffer.from('b319', 'hex')
exports['skein256-208'] = Buffer.from('b31a', 'hex')
exports['skein256-216'] = Buffer.from('b31b', 'hex')
exports['skein256-224'] = Buffer.from('b31c', 'hex')
exports['skein256-232'] = Buffer.from('b31d', 'hex')
exports['skein256-240'] = Buffer.from('b31e', 'hex')
exports['skein256-248'] = Buffer.from('b31f', 'hex')
exports['skein256-256'] = Buffer.from('b320', 'hex')
exports['skein512-8'] = Buffer.from('b321', 'hex')
exports['skein512-16'] = Buffer.from('b322', 'hex')
exports['skein512-24'] = Buffer.from('b323', 'hex')
exports['skein512-32'] = Buffer.from('b324', 'hex')
exports['skein512-40'] = Buffer.from('b325', 'hex')
exports['skein512-48'] = Buffer.from('b326', 'hex')
exports['skein512-56'] = Buffer.from('b327', 'hex')
exports['skein512-64'] = Buffer.from('b328', 'hex')
exports['skein512-72'] = Buffer.from('b329', 'hex')
exports['skein512-80'] = Buffer.from('b32a', 'hex')
exports['skein512-88'] = Buffer.from('b32b', 'hex')
exports['skein512-96'] = Buffer.from('b32c', 'hex')
exports['skein512-104'] = Buffer.from('b32d', 'hex')
exports['skein512-112'] = Buffer.from('b32e', 'hex')
exports['skein512-120'] = Buffer.from('b32f', 'hex')
exports['skein512-128'] = Buffer.from('b330', 'hex')
exports['skein512-136'] = Buffer.from('b331', 'hex')
exports['skein512-144'] = Buffer.from('b332', 'hex')
exports['skein512-152'] = Buffer.from('b333', 'hex')
exports['skein512-160'] = Buffer.from('b334', 'hex')
exports['skein512-168'] = Buffer.from('b335', 'hex')
exports['skein512-176'] = Buffer.from('b336', 'hex')
exports['skein512-184'] = Buffer.from('b337', 'hex')
exports['skein512-192'] = Buffer.from('b338', 'hex')
exports['skein512-200'] = Buffer.from('b339', 'hex')
exports['skein512-208'] = Buffer.from('b33a', 'hex')
exports['skein512-216'] = Buffer.from('b33b', 'hex')
exports['skein512-224'] = Buffer.from('b33c', 'hex')
exports['skein512-232'] = Buffer.from('b33d', 'hex')
exports['skein512-240'] = Buffer.from('b33e', 'hex')
exports['skein512-248'] = Buffer.from('b33f', 'hex')
exports['skein512-256'] = Buffer.from('b340', 'hex')
exports['skein512-264'] = Buffer.from('b341', 'hex')
exports['skein512-272'] = Buffer.from('b342', 'hex')
exports['skein512-280'] = Buffer.from('b343', 'hex')
exports['skein512-288'] = Buffer.from('b344', 'hex')
exports['skein512-296'] = Buffer.from('b345', 'hex')
exports['skein512-304'] = Buffer.from('b346', 'hex')
exports['skein512-312'] = Buffer.from('b347', 'hex')
exports['skein512-320'] = Buffer.from('b348', 'hex')
exports['skein512-328'] = Buffer.from('b349', 'hex')
exports['skein512-336'] = Buffer.from('b34a', 'hex')
exports['skein512-344'] = Buffer.from('b34b', 'hex')
exports['skein512-352'] = Buffer.from('b34c', 'hex')
exports['skein512-360'] = Buffer.from('b34d', 'hex')
exports['skein512-368'] = Buffer.from('b34e', 'hex')
exports['skein512-376'] = Buffer.from('b34f', 'hex')
exports['skein512-384'] = Buffer.from('b350', 'hex')
exports['skein512-392'] = Buffer.from('b351', 'hex')
exports['skein512-400'] = Buffer.from('b352', 'hex')
exports['skein512-408'] = Buffer.from('b353', 'hex')
exports['skein512-416'] = Buffer.from('b354', 'hex')
exports['skein512-424'] = Buffer.from('b355', 'hex')
exports['skein512-432'] = Buffer.from('b356', 'hex')
exports['skein512-440'] = Buffer.from('b357', 'hex')
exports['skein512-448'] = Buffer.from('b358', 'hex')
exports['skein512-456'] = Buffer.from('b359', 'hex')
exports['skein512-464'] = Buffer.from('b35a', 'hex')
exports['skein512-472'] = Buffer.from('b35b', 'hex')
exports['skein512-480'] = Buffer.from('b35c', 'hex')
exports['skein512-488'] = Buffer.from('b35d', 'hex')
exports['skein512-496'] = Buffer.from('b35e', 'hex')
exports['skein512-504'] = Buffer.from('b35f', 'hex')
exports['skein512-512'] = Buffer.from('b360', 'hex')
exports['skein1024-8'] = Buffer.from('b361', 'hex')
exports['skein1024-16'] = Buffer.from('b362', 'hex')
exports['skein1024-24'] = Buffer.from('b363', 'hex')
exports['skein1024-32'] = Buffer.from('b364', 'hex')
exports['skein1024-40'] = Buffer.from('b365', 'hex')
exports['skein1024-48'] = Buffer.from('b366', 'hex')
exports['skein1024-56'] = Buffer.from('b367', 'hex')
exports['skein1024-64'] = Buffer.from('b368', 'hex')
exports['skein1024-72'] = Buffer.from('b369', 'hex')
exports['skein1024-80'] = Buffer.from('b36a', 'hex')
exports['skein1024-88'] = Buffer.from('b36b', 'hex')
exports['skein1024-96'] = Buffer.from('b36c', 'hex')
exports['skein1024-104'] = Buffer.from('b36d', 'hex')
exports['skein1024-112'] = Buffer.from('b36e', 'hex')
exports['skein1024-120'] = Buffer.from('b36f', 'hex')
exports['skein1024-128'] = Buffer.from('b370', 'hex')
exports['skein1024-136'] = Buffer.from('b371', 'hex')
exports['skein1024-144'] = Buffer.from('b372', 'hex')
exports['skein1024-152'] = Buffer.from('b373', 'hex')
exports['skein1024-160'] = Buffer.from('b374', 'hex')
exports['skein1024-168'] = Buffer.from('b375', 'hex')
exports['skein1024-176'] = Buffer.from('b376', 'hex')
exports['skein1024-184'] = Buffer.from('b377', 'hex')
exports['skein1024-192'] = Buffer.from('b378', 'hex')
exports['skein1024-200'] = Buffer.from('b379', 'hex')
exports['skein1024-208'] = Buffer.from('b37a', 'hex')
exports['skein1024-216'] = Buffer.from('b37b', 'hex')
exports['skein1024-224'] = Buffer.from('b37c', 'hex')
exports['skein1024-232'] = Buffer.from('b37d', 'hex')
exports['skein1024-240'] = Buffer.from('b37e', 'hex')
exports['skein1024-248'] = Buffer.from('b37f', 'hex')
exports['skein1024-256'] = Buffer.from('b380', 'hex')
exports['skein1024-264'] = Buffer.from('b381', 'hex')
exports['skein1024-272'] = Buffer.from('b382', 'hex')
exports['skein1024-280'] = Buffer.from('b383', 'hex')
exports['skein1024-288'] = Buffer.from('b384', 'hex')
exports['skein1024-296'] = Buffer.from('b385', 'hex')
exports['skein1024-304'] = Buffer.from('b386', 'hex')
exports['skein1024-312'] = Buffer.from('b387', 'hex')
exports['skein1024-320'] = Buffer.from('b388', 'hex')
exports['skein1024-328'] = Buffer.from('b389', 'hex')
exports['skein1024-336'] = Buffer.from('b38a', 'hex')
exports['skein1024-344'] = Buffer.from('b38b', 'hex')
exports['skein1024-352'] = Buffer.from('b38c', 'hex')
exports['skein1024-360'] = Buffer.from('b38d', 'hex')
exports['skein1024-368'] = Buffer.from('b38e', 'hex')
exports['skein1024-376'] = Buffer.from('b38f', 'hex')
exports['skein1024-384'] = Buffer.from('b390', 'hex')
exports['skein1024-392'] = Buffer.from('b391', 'hex')
exports['skein1024-400'] = Buffer.from('b392', 'hex')
exports['skein1024-408'] = Buffer.from('b393', 'hex')
exports['skein1024-416'] = Buffer.from('b394', 'hex')
exports['skein1024-424'] = Buffer.from('b395', 'hex')
exports['skein1024-432'] = Buffer.from('b396', 'hex')
exports['skein1024-440'] = Buffer.from('b397', 'hex')
exports['skein1024-448'] = Buffer.from('b398', 'hex')
exports['skein1024-456'] = Buffer.from('b399', 'hex')
exports['skein1024-464'] = Buffer.from('b39a', 'hex')
exports['skein1024-472'] = Buffer.from('b39b', 'hex')
exports['skein1024-480'] = Buffer.from('b39c', 'hex')
exports['skein1024-488'] = Buffer.from('b39d', 'hex')
exports['skein1024-496'] = Buffer.from('b39e', 'hex')
exports['skein1024-504'] = Buffer.from('b39f', 'hex')
exports['skein1024-512'] = Buffer.from('b3a0', 'hex')
exports['skein1024-520'] = Buffer.from('b3a1', 'hex')
exports['skein1024-528'] = Buffer.from('b3a2', 'hex')
exports['skein1024-536'] = Buffer.from('b3a3', 'hex')
exports['skein1024-544'] = Buffer.from('b3a4', 'hex')
exports['skein1024-552'] = Buffer.from('b3a5', 'hex')
exports['skein1024-560'] = Buffer.from('b3a6', 'hex')
exports['skein1024-568'] = Buffer.from('b3a7', 'hex')
exports['skein1024-576'] = Buffer.from('b3a8', 'hex')
exports['skein1024-584'] = Buffer.from('b3a9', 'hex')
exports['skein1024-592'] = Buffer.from('b3aa', 'hex')
exports['skein1024-600'] = Buffer.from('b3ab', 'hex')
exports['skein1024-608'] = Buffer.from('b3ac', 'hex')
exports['skein1024-616'] = Buffer.from('b3ad', 'hex')
exports['skein1024-624'] = Buffer.from('b3ae', 'hex')
exports['skein1024-632'] = Buffer.from('b3af', 'hex')
exports['skein1024-640'] = Buffer.from('b3b0', 'hex')
exports['skein1024-648'] = Buffer.from('b3b1', 'hex')
exports['skein1024-656'] = Buffer.from('b3b2', 'hex')
exports['skein1024-664'] = Buffer.from('b3b3', 'hex')
exports['skein1024-672'] = Buffer.from('b3b4', 'hex')
exports['skein1024-680'] = Buffer.from('b3b5', 'hex')
exports['skein1024-688'] = Buffer.from('b3b6', 'hex')
exports['skein1024-696'] = Buffer.from('b3b7', 'hex')
exports['skein1024-704'] = Buffer.from('b3b8', 'hex')
exports['skein1024-712'] = Buffer.from('b3b9', 'hex')
exports['skein1024-720'] = Buffer.from('b3ba', 'hex')
exports['skein1024-728'] = Buffer.from('b3bb', 'hex')
exports['skein1024-736'] = Buffer.from('b3bc', 'hex')
exports['skein1024-744'] = Buffer.from('b3bd', 'hex')
exports['skein1024-752'] = Buffer.from('b3be', 'hex')
exports['skein1024-760'] = Buffer.from('b3bf', 'hex')
exports['skein1024-768'] = Buffer.from('b3c0', 'hex')
exports['skein1024-776'] = Buffer.from('b3c1', 'hex')
exports['skein1024-784'] = Buffer.from('b3c2', 'hex')
exports['skein1024-792'] = Buffer.from('b3c3', 'hex')
exports['skein1024-800'] = Buffer.from('b3c4', 'hex')
exports['skein1024-808'] = Buffer.from('b3c5', 'hex')
exports['skein1024-816'] = Buffer.from('b3c6', 'hex')
exports['skein1024-824'] = Buffer.from('b3c7', 'hex')
exports['skein1024-832'] = Buffer.from('b3c8', 'hex')
exports['skein1024-840'] = Buffer.from('b3c9', 'hex')
exports['skein1024-848'] = Buffer.from('b3ca', 'hex')
exports['skein1024-856'] = Buffer.from('b3cb', 'hex')
exports['skein1024-864'] = Buffer.from('b3cc', 'hex')
exports['skein1024-872'] = Buffer.from('b3cd', 'hex')
exports['skein1024-880'] = Buffer.from('b3ce', 'hex')
exports['skein1024-888'] = Buffer.from('b3cf', 'hex')
exports['skein1024-896'] = Buffer.from('b3d0', 'hex')
exports['skein1024-904'] = Buffer.from('b3d1', 'hex')
exports['skein1024-912'] = Buffer.from('b3d2', 'hex')
exports['skein1024-920'] = Buffer.from('b3d3', 'hex')
exports['skein1024-928'] = Buffer.from('b3d4', 'hex')
exports['skein1024-936'] = Buffer.from('b3d5', 'hex')
exports['skein1024-944'] = Buffer.from('b3d6', 'hex')
exports['skein1024-952'] = Buffer.from('b3d7', 'hex')
exports['skein1024-960'] = Buffer.from('b3d8', 'hex')
exports['skein1024-968'] = Buffer.from('b3d9', 'hex')
exports['skein1024-976'] = Buffer.from('b3da', 'hex')
exports['skein1024-984'] = Buffer.from('b3db', 'hex')
exports['skein1024-992'] = Buffer.from('b3dc', 'hex')
exports['skein1024-1000'] = Buffer.from('b3dd', 'hex')
exports['skein1024-1008'] = Buffer.from('b3de', 'hex')
exports['skein1024-1016'] = Buffer.from('b3df', 'hex')
exports['skein1024-1024'] = Buffer.from('b3e0', 'hex')

// multiaddr
exports['ip4'] = Buffer.from('04', 'hex')
exports['tcp'] = Buffer.from('06', 'hex')
exports['dccp'] = Buffer.from('21', 'hex')
exports['ip6'] = Buffer.from('29', 'hex')
exports['ip6zone'] = Buffer.from('2a', 'hex')
exports['dns'] = Buffer.from('35', 'hex')
exports['dns4'] = Buffer.from('36', 'hex')
exports['dns6'] = Buffer.from('37', 'hex')
exports['dnsaddr'] = Buffer.from('38', 'hex')
exports['sctp'] = Buffer.from('84', 'hex')
exports['udp'] = Buffer.from('0111', 'hex')
exports['p2p-webrtc-star'] = Buffer.from('0113', 'hex')
exports['p2p-webrtc-direct'] = Buffer.from('0114', 'hex')
exports['p2p-stardust'] = Buffer.from('0115', 'hex')
exports['p2p-circuit'] = Buffer.from('0122', 'hex')
exports['udt'] = Buffer.from('012d', 'hex')
exports['utp'] = Buffer.from('012e', 'hex')
exports['unix'] = Buffer.from('0190', 'hex')
exports['p2p'] = Buffer.from('01a5', 'hex')
exports['ipfs'] = Buffer.from('01a5', 'hex')
exports['https'] = Buffer.from('01bb', 'hex')
exports['onion'] = Buffer.from('01bc', 'hex')
exports['onion3'] = Buffer.from('01bd', 'hex')
exports['garlic64'] = Buffer.from('01be', 'hex')
exports['garlic32'] = Buffer.from('01bf', 'hex')
exports['quic'] = Buffer.from('01cc', 'hex')
exports['ws'] = Buffer.from('01dd', 'hex')
exports['wss'] = Buffer.from('01de', 'hex')
exports['p2p-websocket-star'] = Buffer.from('01df', 'hex')
exports['http'] = Buffer.from('01e0', 'hex')

// ipld
exports['raw'] = Buffer.from('55', 'hex')
exports['dag-pb'] = Buffer.from('70', 'hex')
exports['dag-cbor'] = Buffer.from('71', 'hex')
exports['libp2p-key'] = Buffer.from('72', 'hex')
exports['git-raw'] = Buffer.from('78', 'hex')
exports['torrent-info'] = Buffer.from('7b', 'hex')
exports['torrent-file'] = Buffer.from('7c', 'hex')
exports['leofcoin-block'] = Buffer.from('81', 'hex')
exports['leofcoin-tx'] = Buffer.from('82', 'hex')
exports['leofcoin-pr'] = Buffer.from('83', 'hex')
exports['eth-block'] = Buffer.from('90', 'hex')
exports['eth-block-list'] = Buffer.from('91', 'hex')
exports['eth-tx-trie'] = Buffer.from('92', 'hex')
exports['eth-tx'] = Buffer.from('93', 'hex')
exports['eth-tx-receipt-trie'] = Buffer.from('94', 'hex')
exports['eth-tx-receipt'] = Buffer.from('95', 'hex')
exports['eth-state-trie'] = Buffer.from('96', 'hex')
exports['eth-account-snapshot'] = Buffer.from('97', 'hex')
exports['eth-storage-trie'] = Buffer.from('98', 'hex')
exports['bitcoin-block'] = Buffer.from('b0', 'hex')
exports['bitcoin-tx'] = Buffer.from('b1', 'hex')
exports['zcash-block'] = Buffer.from('c0', 'hex')
exports['zcash-tx'] = Buffer.from('c1', 'hex')
exports['stellar-block'] = Buffer.from('d0', 'hex')
exports['stellar-tx'] = Buffer.from('d1', 'hex')
exports['decred-block'] = Buffer.from('e0', 'hex')
exports['decred-tx'] = Buffer.from('e1', 'hex')
exports['dash-block'] = Buffer.from('f0', 'hex')
exports['dash-tx'] = Buffer.from('f1', 'hex')
exports['swarm-manifest'] = Buffer.from('fa', 'hex')
exports['swarm-feed'] = Buffer.from('fb', 'hex')
exports['dag-json'] = Buffer.from('0129', 'hex')

// namespace
exports['path'] = Buffer.from('2f', 'hex')
exports['ipld-ns'] = Buffer.from('e2', 'hex')
exports['ipfs-ns'] = Buffer.from('e3', 'hex')
exports['swarm-ns'] = Buffer.from('e4', 'hex')
exports['ipns-ns'] = Buffer.from('e5', 'hex')
exports['zeronet'] = Buffer.from('e6', 'hex')

// key
exports['ed25519-pub'] = Buffer.from('ed', 'hex')

// holochain
exports['holochain-adr-v0'] = Buffer.from('807124', 'hex')
exports['holochain-adr-v1'] = Buffer.from('817124', 'hex')
exports['holochain-key-v0'] = Buffer.from('947124', 'hex')
exports['holochain-key-v1'] = Buffer.from('957124', 'hex')
exports['holochain-sig-v0'] = Buffer.from('a27124', 'hex')
exports['holochain-sig-v1'] = Buffer.from('a37124', 'hex')

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multicodec",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/base-table.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/cid-util.js", {"../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/cid-util.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const mh = require('multihashes')

var CIDUtil = {
  /**
   * Test if the given input is a valid CID object.
   * Returns an error message if it is not.
   * Returns undefined if it is a valid CID.
   *
   * @param {any} other
   * @returns {string}
   */
  checkCIDComponents: function (other) {
    if (other == null) {
      return 'null values are not valid CIDs'
    }

    if (!(other.version === 0 || other.version === 1)) {
      return 'Invalid version, must be a number equal to 1 or 0'
    }

    if (typeof other.codec !== 'string') {
      return 'codec must be string'
    }

    if (other.version === 0) {
      if (other.codec !== 'dag-pb') {
        return `codec must be 'dag-pb' for CIDv0`
      }
      if (other.multibaseName !== 'base58btc') {
        return `multibaseName must be 'base58btc' for CIDv0`
      }
    }

    if (!Buffer.isBuffer(other.multihash)) {
      return 'multihash must be a Buffer'
    }

    try {
      mh.validate(other.multihash)
    } catch (err) {
      let errorMsg = err.message
      if (!errorMsg) { // Just in case mh.validate() throws an error with empty error message
        errorMsg = 'Multihash validation failed'
      }
      return errorMsg
    }
  }
}

module.exports = CIDUtil

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

      };
    };
  }
}, {package:"cids",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/cid-util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/utils.js", {"multiaddr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/utils.js
      return function (require, module, exports) {
'use strict'

const multiaddr = require('multiaddr')

function ensureMultiaddr (ma) {
  if (multiaddr.isMultiaddr(ma)) {
    return ma
  }

  return multiaddr(ma)
}

module.exports = {
  ensureMultiaddr: ensureMultiaddr
}

      };
    };
  }
}, {package:"peer-info",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/multiaddr-set.js", {"./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/utils.js","unique-by":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/unique-by/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/multiaddr-set.js
      return function (require, module, exports) {
'use strict'

const { ensureMultiaddr } = require('./utils')
const uniqBy = require('unique-by')

// Because JavaScript doesn't let you overload the compare in Set()..
class MultiaddrSet {
  constructor (multiaddrs) {
    this._multiaddrs = multiaddrs || []
    this._observedMultiaddrs = []
  }

  add (ma) {
    ma = ensureMultiaddr(ma)

    if (!this.has(ma)) {
      this._multiaddrs.push(ma)
    }
  }

  // addSafe - prevent multiaddr explosion™
  // Multiaddr explosion is when you dial to a bunch of nodes and every node
  // gives you a different observed address and you start storing them all to
  // share with other peers. This seems like a good idea until you realize that
  // most of those addresses are unique to the subnet that peer is in and so,
  // they are completely worthless for all the other peers. This method is
  // exclusively used by identify.
  addSafe (ma) {
    ma = ensureMultiaddr(ma)

    const check = this._observedMultiaddrs.some((m, i) => {
      if (m.equals(ma)) {
        this.add(ma)
        this._observedMultiaddrs.splice(i, 1)
        return true
      }
    })
    if (!check) {
      this._observedMultiaddrs.push(ma)
    }
  }

  toArray () {
    return this._multiaddrs.slice()
  }

  get size () {
    return this._multiaddrs.length
  }

  forEach (fn) {
    return this._multiaddrs.forEach(fn)
  }

  filterBy (maFmt) {
    if (typeof maFmt !== 'object' ||
      typeof maFmt.matches !== 'function' ||
      typeof maFmt.partialMatch !== 'function' ||
      typeof maFmt.toString !== 'function') return []

    return this._multiaddrs.filter((ma) => maFmt.matches(ma))
  }

  has (ma) {
    ma = ensureMultiaddr(ma)
    return this._multiaddrs.some((m) => m.equals(ma))
  }

  delete (ma) {
    ma = ensureMultiaddr(ma)

    this._multiaddrs.some((m, i) => {
      if (m.equals(ma)) {
        this._multiaddrs.splice(i, 1)
        return true
      }
    })
  }

  // replaces selected existing multiaddrs with new ones
  replace (existing, fresh) {
    if (!Array.isArray(existing)) {
      existing = [existing]
    }
    if (!Array.isArray(fresh)) {
      fresh = [fresh]
    }
    existing.forEach((m) => this.delete(m))
    fresh.forEach((m) => this.add(m))
  }

  clear () {
    this._multiaddrs = []
  }

  // this only really helps make ip6 and ip4 multiaddrs distinct if they are
  // different
  // TODO this is not an ideal solution, probably this code should just be
  // in libp2p-tcp
  distinct () {
    return uniqBy(this._multiaddrs, (ma) => {
      return [ma.toOptions().port, ma.toOptions().transport].join()
    })
  }
}

module.exports = MultiaddrSet

      };
    };
  }
}, {package:"peer-info",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/multiaddr-set.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/superstruct/lib/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/superstruct/lib/index.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * Define a struct error.
 *
 * @type {StructError}
 */

class StructError extends TypeError {
  static format(attrs) {
    const { type, path, value } = attrs;
    const message = `Expected a value of type \`${type}\`${path.length ? ` for \`${path.join('.')}\`` : ''} but received \`${JSON.stringify(value)}\`.`;
    return message;
  }

  constructor(attrs) {
    const message = StructError.format(attrs);
    super(message);

    const { data, path, value, reason, type, errors = [] } = attrs;
    this.data = data;
    this.path = path;
    this.value = value;
    this.reason = reason;
    this.type = type;
    this.errors = errors;

    if (!errors.length) {
      errors.push(this);
    }

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
  }
}

var toString = Object.prototype.toString;

var kindOf = function kindOf(val) {
  if (val === void 0) return 'undefined';
  if (val === null) return 'null';

  var type = typeof val;
  if (type === 'boolean') return 'boolean';
  if (type === 'string') return 'string';
  if (type === 'number') return 'number';
  if (type === 'symbol') return 'symbol';
  if (type === 'function') {
    return isGeneratorFn(val) ? 'generatorfunction' : 'function';
  }

  if (isArray(val)) return 'array';
  if (isBuffer(val)) return 'buffer';
  if (isArguments(val)) return 'arguments';
  if (isDate(val)) return 'date';
  if (isError(val)) return 'error';
  if (isRegexp(val)) return 'regexp';

  switch (ctorName(val)) {
    case 'Symbol': return 'symbol';
    case 'Promise': return 'promise';

    // Set, Map, WeakSet, WeakMap
    case 'WeakMap': return 'weakmap';
    case 'WeakSet': return 'weakset';
    case 'Map': return 'map';
    case 'Set': return 'set';

    // 8-bit typed arrays
    case 'Int8Array': return 'int8array';
    case 'Uint8Array': return 'uint8array';
    case 'Uint8ClampedArray': return 'uint8clampedarray';

    // 16-bit typed arrays
    case 'Int16Array': return 'int16array';
    case 'Uint16Array': return 'uint16array';

    // 32-bit typed arrays
    case 'Int32Array': return 'int32array';
    case 'Uint32Array': return 'uint32array';
    case 'Float32Array': return 'float32array';
    case 'Float64Array': return 'float64array';
  }

  if (isGeneratorObj(val)) {
    return 'generator';
  }

  // Non-plain objects
  type = toString.call(val);
  switch (type) {
    case '[object Object]': return 'object';
    // iterators
    case '[object Map Iterator]': return 'mapiterator';
    case '[object Set Iterator]': return 'setiterator';
    case '[object String Iterator]': return 'stringiterator';
    case '[object Array Iterator]': return 'arrayiterator';
  }

  // other
  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
};

function ctorName(val) {
  return val.constructor ? val.constructor.name : null;
}

function isArray(val) {
  if (Array.isArray) return Array.isArray(val);
  return val instanceof Array;
}

function isError(val) {
  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');
}

function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === 'function'
    && typeof val.getDate === 'function'
    && typeof val.setDate === 'function';
}

function isRegexp(val) {
  if (val instanceof RegExp) return true;
  return typeof val.flags === 'string'
    && typeof val.ignoreCase === 'boolean'
    && typeof val.multiline === 'boolean'
    && typeof val.global === 'boolean';
}

function isGeneratorFn(name, val) {
  return ctorName(name) === 'GeneratorFunction';
}

function isGeneratorObj(val) {
  return typeof val.throw === 'function'
    && typeof val.return === 'function'
    && typeof val.next === 'function';
}

function isArguments(val) {
  try {
    if (typeof val.length === 'number' && typeof val.callee === 'function') {
      return true;
    }
  } catch (err) {
    if (err.message.indexOf('callee') !== -1) {
      return true;
    }
  }
  return false;
}

/**
 * If you need to support Safari 5-7 (8-10 yr-old browser),
 * take a look at https://github.com/feross/is-buffer
 */

function isBuffer(val) {
  if (val.constructor && typeof val.constructor.isBuffer === 'function') {
    return val.constructor.isBuffer(val);
  }
  return false;
}

/**
 * A private string to identify structs by.
 *
 * @type {String}
 */

const IS_STRUCT = '@@__STRUCT__@@';

/**
 * A private string to refer to a struct's kind.
 *
 * @type {String}
 */

const KIND = '@@__KIND__@@';

/**
 * Check if a `value` is a struct.
 *
 * @param {Any} value
 * @return {Boolean}
 */

function isStruct(value) {
  return !!(value && value[IS_STRUCT]);
}

/**
 * Resolve `defaults`, for an optional `value`.
 *
 * @param {Function|Any} defaults
 * @param {Any} value
 * @return {Any}
 */

function resolveDefaults(defaults, value) {
  return typeof defaults === 'function' ? defaults(value) : defaults;
}

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Kind.
 *
 * @type {Kind}
 */

class Kind {
  constructor(name, type, validate) {
    this.name = name;
    this.type = type;
    this.validate = validate;
  }
}

/**
 * Any.
 *
 * @param {Array|Function|Object|String} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function any(schema, defaults$$1, options) {
  if (isStruct(schema)) {
    return schema[KIND];
  }

  if (schema instanceof Kind) {
    return schema;
  }

  switch (kindOf(schema)) {
    case 'array':
      {
        return schema.length > 1 ? tuple(schema, defaults$$1, options) : list(schema, defaults$$1, options);
      }

    case 'function':
      {
        return func(schema, defaults$$1, options);
      }

    case 'object':
      {
        return object(schema, defaults$$1, options);
      }

    case 'string':
      {
        let required = true;
        let type;

        if (schema.endsWith('?')) {
          required = false;
          schema = schema.slice(0, -1);
        }

        if (schema.includes('|')) {
          const scalars = schema.split(/\s*\|\s*/g);
          type = union(scalars, defaults$$1, options);
        } else if (schema.includes('&')) {
          const scalars = schema.split(/\s*&\s*/g);
          type = intersection(scalars, defaults$$1, options);
        } else {
          type = scalar(schema, defaults$$1, options);
        }

        if (!required) {
          type = optional(type, undefined, options);
        }

        return type;
      }
  }

  if ("development" !== 'production') {
    throw new Error(`A schema definition must be an object, array, string or function, but you passed: ${schema}`);
  } else {
    throw new Error(`Invalid schema: ${schema}`);
  }
}

/**
 * Dict.
 *
 * @param {Array} schema
 * @param {Object} defaults
 * @param {Object} options
 */

function dict(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'array' || schema.length !== 2) {
    if ("development" !== 'production') {
      throw new Error(`Dict structs must be defined as an array with two elements, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const obj = scalar('object', undefined, options);
  const keys = any(schema[0], undefined, options);
  const values = any(schema[1], undefined, options);
  const name = 'dict';
  const type = `dict<${keys.type},${values.type}>`;
  const validate = value => {
    const resolved = resolveDefaults(defaults$$1);
    value = resolved ? _extends({}, resolved, value) : value;
    const [error] = obj.validate(value);

    if (error) {
      error.type = type;
      return [error];
    }

    const ret = {};
    const errors = [];

    for (let k in value) {
      const v = value[k];
      const [e, r] = keys.validate(k);

      if (e) {
        const allE = e.errors || [e];
        allE.forEach(singleE => {
          singleE.path = [k].concat(singleE.path);
          singleE.data = value;
          errors.push(singleE);
        });
        continue;
      }

      k = r;
      const [e2, r2] = values.validate(v);

      if (e2) {
        const allE2 = e2.errors || [e2];
        allE2.forEach(singleE => {
          singleE.path = [k].concat(singleE.path);
          singleE.data = value;
          errors.push(singleE);
        });
        continue;
      }

      ret[k] = r2;
    }

    if (errors.length) {
      const first = errors[0];
      first.errors = errors;
      return [first];
    }

    return [undefined, ret];
  };

  return new Kind(name, type, validate);
}

/**
 * Enum.
 *
 * @param {Array} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function en(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'array') {
    if ("development" !== 'production') {
      throw new Error(`Enum structs must be defined as an array, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const name = 'enum';
  const type = schema.map(s => {
    try {
      return JSON.stringify(s);
    } catch (e) {
      return String(s);
    }
  }).join(' | ');

  const validate = (value = resolveDefaults(defaults$$1)) => {
    return schema.includes(value) ? [undefined, value] : [{ data: value, path: [], value, type }];
  };

  return new Kind(name, type, validate);
}

/**
 * Enums.
 *
 * @param {Array} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function enums(schema, defaults$$1, options) {
  const e = en(schema, undefined, options);
  const l = list([e], defaults$$1, options);
  return l;
}

/**
 * Function.
 *
 * @param {Function} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function func(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'function') {
    if ("development" !== 'production') {
      throw new Error(`Function structs must be defined as a function, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const name = 'function';
  const type = '<function>';
  const validate = (value = resolveDefaults(defaults$$1), data) => {
    const result = schema(value, data);
    let failure = { path: [], reason: null };
    let isValid;

    switch (kindOf(result)) {
      case 'boolean':
        {
          isValid = result;
          break;
        }
      case 'string':
        {
          isValid = false;
          failure.reason = result;
          break;
        }
      case 'object':
        {
          isValid = false;
          failure = _extends({}, failure, result);
          break;
        }
      default:
        {
          if ("development" !== 'production') {
            throw new Error(`Validator functions must return a boolean, an error reason string or an error reason object, but you passed: ${schema}`);
          } else {
            throw new Error(`Invalid result: ${result}`);
          }
        }
    }

    return isValid ? [undefined, value] : [_extends({ type, value, data: value }, failure)];
  };

  return new Kind(name, type, validate);
}

/**
 * Instance.
 *
 * @param {Array} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function instance(schema, defaults$$1, options) {
  const name = 'instance';
  const type = `instance<${schema.name}>`;
  const validate = (value = resolveDefaults(defaults$$1)) => {
    return value instanceof schema ? [undefined, value] : [{ data: value, path: [], value, type }];
  };

  return new Kind(name, type, validate);
}

/**
 * Interface.
 *
 * @param {Object} schema
 * @param {Object} defaults
 * @param {Object} options
 */

function inter(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'object') {
    if ("development" !== 'production') {
      throw new Error(`Interface structs must be defined as an object, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const ks = [];
  const properties = {};

  for (const key in schema) {
    ks.push(key);
    const s = schema[key];
    const kind = any(s, undefined, options);
    properties[key] = kind;
  }

  const name = 'interface';
  const type = `{${ks.join()}}`;
  const validate = value => {
    const resolved = resolveDefaults(defaults$$1);
    value = resolved ? _extends({}, resolved, value) : value;
    const errors = [];
    const ret = value;

    for (const key in properties) {
      let v = value[key];
      const kind = properties[key];

      if (v === undefined) {
        const d = defaults$$1 && defaults$$1[key];
        v = resolveDefaults(d, value);
      }

      const [e, r] = kind.validate(v, value);

      if (e) {
        const allE = e.errors || [e];
        allE.forEach(singleE => {
          singleE.path = [key].concat(singleE.path);
          singleE.data = value;
          errors.push(singleE);
        });
        continue;
      }

      if (key in value || r !== undefined) {
        ret[key] = r;
      }
    }

    if (errors.length) {
      const first = errors[0];
      first.errors = errors;
      return [first];
    }

    return [undefined, ret];
  };

  return new Kind(name, type, validate);
}

/**
 * Lazy.
 *
 * @param {Function} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function lazy(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'function') {
    if ("development" !== 'production') {
      throw new Error(`Lazy structs must be defined as an function that returns a schema, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  let kind;
  let struct;
  const name = 'lazy';
  const type = `lazy...`;
  const compile = value => {
    struct = schema();
    kind.name = struct.kind;
    kind.type = struct.type;
    kind.validate = struct.validate;
    return kind.validate(value);
  };

  kind = new Kind(name, type, compile);
  return kind;
}

/**
 * Dynamic.
 *
 * @param {Function} createSchema
 * @param {Any} defaults
 * @param {Object} options
 */

function dynamic(createSchema, defaults$$1, options) {
  if (kindOf(createSchema) !== 'function') {
    if ("development" !== 'production') {
      throw new Error(`Dynamic structs must be defined as a function, but you passed: ${createSchema}`);
    } else {
      throw new Error(`Invalid schema: ${createSchema}`);
    }
  }

  const name = 'dynamic';
  const type = 'dynamic...';
  const validate = (value = resolveDefaults(defaults$$1), data) => {
    const schema = createSchema(value, data);

    if (kindOf(schema) !== 'function') {
      if ("development" !== 'production') {
        throw new Error(`Dynamic structs must return a schema, but you passed: ${schema}`);
      } else {
        throw new Error(`Invalid schema: ${schema}`);
      }
    }

    const [error, result] = schema.validate(value);

    if (error) {
      return [error];
    }

    return [undefined, result];
  };

  return new Kind(name, type, validate);
}

/**
 * List.
 *
 * @param {Array} schema
 * @param {Array} defaults
 * @param {Object} options
 */

function list(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'array' || schema.length !== 1) {
    if ("development" !== 'production') {
      throw new Error(`List structs must be defined as an array with a single element, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const array = scalar('array', undefined, options);
  const element = any(schema[0], undefined, options);
  const name = 'list';
  const type = `[${element.type}]`;
  const validate = (value = resolveDefaults(defaults$$1)) => {
    const [error, result] = array.validate(value);

    if (error) {
      error.type = type;
      return [error];
    }

    value = result;
    const errors = [];
    const ret = [];

    for (let i = 0; i < value.length; i++) {
      const v = value[i];
      const [e, r] = element.validate(v);

      if (e) {
        const allE = e.errors || [e];
        allE.forEach(singleE => {
          singleE.path = [i].concat(singleE.path);
          singleE.data = value;
          errors.push(singleE);
        });
        continue;
      }

      ret[i] = r;
    }

    if (errors.length) {
      const first = errors[0];
      first.errors = errors;
      return [first];
    }

    return [undefined, ret];
  };

  return new Kind(name, type, validate);
}

/**
 * Literal.
 *
 * @param {Array} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function literal(schema, defaults$$1, options) {
  const name = 'literal';
  const type = `literal: ${JSON.stringify(schema)}`;
  const validate = (value = resolveDefaults(defaults$$1)) => {
    return value === schema ? [undefined, value] : [{ data: value, path: [], value, type }];
  };

  return new Kind(name, type, validate);
}

/**
 * Object.
 *
 * @param {Object} schema
 * @param {Object} defaults
 * @param {Object} options
 */

function object(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'object') {
    if ("development" !== 'production') {
      throw new Error(`Object structs must be defined as an object, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const obj = scalar('object', undefined, options);
  const ks = [];
  const properties = {};

  for (const key in schema) {
    ks.push(key);
    const s = schema[key];
    const kind = any(s, undefined, options);
    properties[key] = kind;
  }

  const name = 'object';
  const type = `{${ks.join()}}`;
  const validate = (value = resolveDefaults(defaults$$1)) => {
    const [error] = obj.validate(value);

    if (error) {
      error.type = type;
      return [error];
    }

    const errors = [];
    const ret = {};
    const valueKeys = Object.keys(value);
    const propertiesKeys = Object.keys(properties);
    const keys = new Set(valueKeys.concat(propertiesKeys));

    keys.forEach(key => {
      let v = value[key];
      const kind = properties[key];

      if (v === undefined) {
        const d = defaults$$1 && defaults$$1[key];
        v = resolveDefaults(d, value);
      }

      if (!kind) {
        const e = { data: value, path: [key], value: v };
        errors.push(e);
        return;
      }

      const [e, r] = kind.validate(v, value);

      if (e) {
        const allE = e.errors || [e];
        allE.forEach(singleE => {
          singleE.path = [key].concat(singleE.path);
          singleE.data = value;
          errors.push(singleE);
        });
        return;
      }

      if (key in value || r !== undefined) {
        ret[key] = r;
      }
    });

    if (errors.length) {
      const first = errors[0];
      first.errors = errors;
      return [first];
    }

    return [undefined, ret];
  };

  return new Kind(name, type, validate);
}

/**
 * Optional.
 *
 * @param {Any} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function optional(schema, defaults$$1, options) {
  return union([schema, 'undefined'], defaults$$1, options);
}

/**
 * Partial.
 *
 * @param {Object} schema
 * @param {Object} defaults
 * @param {Object} options
 */

function partial(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'object') {
    if ("development" !== 'production') {
      throw new Error(`Partial structs must be defined as an object, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const obj = scalar('object', undefined, options);
  const ks = [];
  const properties = {};

  for (const key in schema) {
    ks.push(key);
    const s = schema[key];
    const kind = any(s, undefined, options);
    properties[key] = kind;
  }

  const name = 'partial';
  const type = `{${ks.join()},...}`;
  const validate = (value = resolveDefaults(defaults$$1)) => {
    const [error] = obj.validate(value);

    if (error) {
      error.type = type;
      return [error];
    }

    const errors = [];
    const ret = {};

    for (const key in properties) {
      let v = value[key];
      const kind = properties[key];

      if (v === undefined) {
        const d = defaults$$1 && defaults$$1[key];
        v = resolveDefaults(d, value);
      }

      const [e, r] = kind.validate(v, value);

      if (e) {
        const allE = e.errors || [e];
        allE.forEach(singleE => {
          singleE.path = [key].concat(singleE.path);
          singleE.data = value;
          errors.push(singleE);
        });
        continue;
      }

      if (key in value || r !== undefined) {
        ret[key] = r;
      }
    }

    if (errors.length) {
      const first = errors[0];
      first.errors = errors;
      return [first];
    }

    return [undefined, ret];
  };

  return new Kind(name, type, validate);
}

/**
 * Scalar.
 *
 * @param {String} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function scalar(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'string') {
    if ("development" !== 'production') {
      throw new Error(`Scalar structs must be defined as a string, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const { types } = options;
  const fn = types[schema];

  if (kindOf(fn) !== 'function') {
    if ("development" !== 'production') {
      throw new Error(`No struct validator function found for type "${schema}".`);
    } else {
      throw new Error(`Invalid type: ${schema}`);
    }
  }

  const kind = func(fn, defaults$$1, options);
  const name = 'scalar';
  const type = schema;
  const validate = value => {
    const [error, result] = kind.validate(value);

    if (error) {
      error.type = type;
      return [error];
    }

    return [undefined, result];
  };

  return new Kind(name, type, validate);
}

/**
 * Tuple.
 *
 * @param {Array} schema
 * @param {Array} defaults
 * @param {Object} options
 */

function tuple(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'array') {
    if ("development" !== 'production') {
      throw new Error(`Tuple structs must be defined as an array, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const kinds = schema.map(s => any(s, undefined, options));
  const array = scalar('array', undefined, options);
  const name = 'tuple';
  const type = `[${kinds.map(k => k.type).join()}]`;
  const validate = (value = resolveDefaults(defaults$$1)) => {
    const [error] = array.validate(value);

    if (error) {
      error.type = type;
      return [error];
    }

    const ret = [];
    const errors = [];
    const length = Math.max(value.length, kinds.length);

    for (let i = 0; i < length; i++) {
      const kind = kinds[i];
      const v = value[i];

      if (!kind) {
        const e = { data: value, path: [i], value: v };
        errors.push(e);
        continue;
      }

      const [e, r] = kind.validate(v);

      if (e) {
        const allE = e.errors || [e];
        allE.forEach(singleE => {
          singleE.path = [i].concat(singleE.path);
          singleE.data = value;
          errors.push(singleE);
        });
        continue;
      }

      ret[i] = r;
    }

    if (errors.length) {
      const first = errors[0];
      first.errors = errors;
      return [first];
    }

    return [undefined, ret];
  };

  return new Kind(name, type, validate);
}

/**
 * Union.
 *
 * @param {Array} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function union(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'array') {
    if ("development" !== 'production') {
      throw new Error(`Union structs must be defined as an array, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const kinds = schema.map(s => any(s, undefined, options));
  const name = 'union';
  const type = kinds.map(k => k.type).join(' | ');
  const validate = (value = resolveDefaults(defaults$$1)) => {
    const errors = [];

    for (const k of kinds) {
      const [e, r] = k.validate(value);

      if (!e) {
        return [undefined, r];
      }

      errors.push(e);
    }
    errors[0].type = type;
    return errors;
  };

  return new Kind(name, type, validate);
}

/**
 * Intersection.
 *
 * @param {Array} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function intersection(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'array') {
    if ("development" !== 'production') {
      throw new Error(`Intersection structs must be defined as an array, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const types = schema.map(s => any(s, undefined, options));
  const name = 'intersection';
  const type = types.map(t => t.type).join(' & ');
  const validate = (value = resolveDefaults(defaults$$1)) => {
    let v = value;

    for (const t of types) {
      const [e, r] = t.validate(v);

      if (e) {
        e.type = type;
        return [e];
      }

      v = r;
    }

    return [undefined, v];
  };

  return new Kind(name, type, validate);
}

/**
 * Kinds.
 *
 * @type {Object}
 */

const Kinds = {
  any,
  dict,
  enum: en,
  enums,
  function: func,
  instance,
  interface: inter,
  lazy,
  list,
  literal,
  object,
  optional,
  partial,
  scalar,
  tuple,
  union,
  intersection,
  dynamic

  /**
   * Export.
   *
   * @type {Object}
   */

};

/**
 * The types that `kind-of` supports.
 *
 * @type {Array}
 */

const TYPES = ['arguments', 'array', 'boolean', 'buffer', 'error', 'float32array', 'float64array', 'function', 'generatorfunction', 'int16array', 'int32array', 'int8array', 'map', 'null', 'number', 'object', 'promise', 'regexp', 'set', 'string', 'symbol', 'uint16array', 'uint32array', 'uint8array', 'uint8clampedarray', 'undefined', 'weakmap', 'weakset'];

/**
 * The default types that Superstruct ships with.
 *
 * @type {Object}
 */

const Types = {
  any: value => value !== undefined
};

TYPES.forEach(type => {
  Types[type] = value => kindOf(value) === type;
});

/**
 * Handle the 'date' case specially, to throw out invalid `Date` objects.
 *
 * @param {Mixed} value
 * @return {Boolean}
 */

Types.date = value => kindOf(value) === 'date' && !isNaN(value);

/**
 * Create a struct factory with a `config`.
 *
 * @param {Object} config
 * @return {Function}
 */

function superstruct(config = {}) {
  const types = _extends({}, Types, config.types || {});

  /**
   * Create a `kind` struct with `schema`, `defaults` and `options`.
   *
   * @param {Any} schema
   * @param {Any} defaults
   * @param {Object} options
   * @return {Function}
   */

  function struct(schema, defaults$$1, options = {}) {
    if (isStruct(schema)) {
      schema = schema.schema;
    }

    const kind = Kinds.any(schema, defaults$$1, _extends({}, options, { types }));

    function Struct(data) {
      if (this instanceof Struct) {
        if ("development" !== 'production') {
          throw new Error('The `Struct` creation function should not be used with the `new` keyword.');
        } else {
          throw new Error('Invalid `new` keyword!');
        }
      }

      return Struct.assert(data);
    }

    Object.defineProperty(Struct, IS_STRUCT, { value: true });
    Object.defineProperty(Struct, KIND, { value: kind });

    Struct.kind = kind.name;
    Struct.type = kind.type;
    Struct.schema = schema;
    Struct.defaults = defaults$$1;
    Struct.options = options;

    Struct.assert = value => {
      const [error, result] = kind.validate(value);

      if (error) {
        throw new StructError(error);
      }

      return result;
    };

    Struct.test = value => {
      const [error] = kind.validate(value);
      return !error;
    };

    Struct.validate = value => {
      const [error, result] = kind.validate(value);

      if (error) {
        return [new StructError(error)];
      }

      return [undefined, result];
    };

    return Struct;
  }

  /**
   * Mix in a factory for each specific kind of struct.
   */

  Object.keys(Kinds).forEach(name => {
    const kind = Kinds[name];

    struct[name] = (schema, defaults$$1, options) => {
      const type = kind(schema, defaults$$1, _extends({}, options, { types }));
      const s = struct(type, defaults$$1, options);
      return s;
    };
  });

  /**
   * Return the struct factory.
   */

  return struct;
}

/**
 * Create a convenience `struct` factory for the default types.
 *
 * @type {Function}
 */

const struct = superstruct();

exports.struct = struct;
exports.superstruct = superstruct;
exports.isStruct = isStruct;
exports.StructError = StructError;
//# sourceMappingURL=index.js.map

      };
    };
  }
}, {package:"superstruct",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/superstruct/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/index.js", {"../random-bytes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/random-bytes.js","./ed25519-class":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/ed25519-class.js","./ephemeral-keys":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/ephemeral-keys.js","./key-stretcher":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/key-stretcher.js","./keys.proto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/keys.proto.js","./rsa-class":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/rsa-class.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","libp2p-crypto-secp256k1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/node_modules/libp2p-crypto-secp256k1/src/index.js","node-forge/lib/asn1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/asn1.js","node-forge/lib/forge":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/forge.js","node-forge/lib/pbe":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pbe.js","node-forge/lib/rsa":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/rsa.js","protons":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/protons/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const protobuf = require('protons')
const keysPBM = protobuf(require('./keys.proto'))
require('node-forge/lib/asn1')
require('node-forge/lib/rsa')
require('node-forge/lib/pbe')
const forge = require('node-forge/lib/forge')

exports = module.exports

const supportedKeys = {
  rsa: require('./rsa-class'),
  ed25519: require('./ed25519-class'),
  secp256k1: require('libp2p-crypto-secp256k1')(keysPBM, require('../random-bytes'))
}

exports.supportedKeys = supportedKeys
exports.keysPBM = keysPBM

function isValidKeyType (keyType) {
  const key = supportedKeys[keyType.toLowerCase()]
  return key !== undefined
}

exports.keyStretcher = require('./key-stretcher')
exports.generateEphemeralKeyPair = require('./ephemeral-keys')

// Generates a keypair of the given type and bitsize
exports.generateKeyPair = (type, bits, cb) => {
  let key = supportedKeys[type.toLowerCase()]

  if (!key) {
    return cb(new Error('invalid or unsupported key type'))
  }

  key.generateKeyPair(bits, cb)
}

// Generates a keypair of the given type and bitsize
// seed is a 32 byte uint8array
exports.generateKeyPairFromSeed = (type, seed, bits, cb) => {
  let key = supportedKeys[type.toLowerCase()]
  if (!key) {
    return cb(new Error('invalid or unsupported key type'))
  }
  if (type.toLowerCase() !== 'ed25519') {
    return cb(new Error('Seed key derivation is unimplemented for RSA or secp256k1'))
  }
  key.generateKeyPairFromSeed(seed, bits, cb)
}

// Converts a protobuf serialized public key into its
// representative object
exports.unmarshalPublicKey = (buf) => {
  const decoded = keysPBM.PublicKey.decode(buf)
  const data = decoded.Data

  switch (decoded.Type) {
    case keysPBM.KeyType.RSA:
      return supportedKeys.rsa.unmarshalRsaPublicKey(data)
    case keysPBM.KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data)
    case keysPBM.KeyType.Secp256k1:
      if (supportedKeys.secp256k1) {
        return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data)
      } else {
        throw new Error('secp256k1 support requires libp2p-crypto-secp256k1 package')
      }
    default:
      throw new Error('invalid or unsupported key type')
  }
}

// Converts a public key object into a protobuf serialized public key
exports.marshalPublicKey = (key, type) => {
  type = (type || 'rsa').toLowerCase()
  if (!isValidKeyType(type)) {
    throw new Error('invalid or unsupported key type')
  }

  return key.bytes
}

// Converts a protobuf serialized private key into its
// representative object
exports.unmarshalPrivateKey = (buf, callback) => {
  let decoded
  try {
    decoded = keysPBM.PrivateKey.decode(buf)
  } catch (err) {
    return callback(err)
  }

  const data = decoded.Data

  switch (decoded.Type) {
    case keysPBM.KeyType.RSA:
      return supportedKeys.rsa.unmarshalRsaPrivateKey(data, callback)
    case keysPBM.KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data, callback)
    case keysPBM.KeyType.Secp256k1:
      if (supportedKeys.secp256k1) {
        return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data, callback)
      } else {
        return callback(new Error('secp256k1 support requires libp2p-crypto-secp256k1 package'))
      }
    default:
      callback(new Error('invalid or unsupported key type'))
  }
}

// Converts a private key object into a protobuf serialized private key
exports.marshalPrivateKey = (key, type) => {
  type = (type || 'rsa').toLowerCase()
  if (!isValidKeyType(type)) {
    throw new Error('invalid or unsupported key type')
  }

  return key.bytes
}

exports.import = (pem, password, callback) => {
  try {
    const key = forge.pki.decryptRsaPrivateKey(pem, password)
    if (key === null) {
      throw new Error('Cannot read the key, most likely the password is wrong or not a RSA key')
    }
    let der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key))
    der = Buffer.from(der.getBytes(), 'binary')
    return supportedKeys.rsa.unmarshalRsaPrivateKey(der, callback)
  } catch (err) {
    callback(err)
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-crypto",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/keys/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr-to-uri/index.js", {"multiaddr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr-to-uri/index.js
      return function (require, module, exports) {
const Multiaddr = require('multiaddr')
const reduceValue = (_, v) => v

const Reducers = {
  ip4: reduceValue,
  ip6: (str, content, i, parts) => (
    parts.length === 1 && parts[0].protocol === 'ip6'
      ? content
      : `[${content}]`
  ),
  tcp: (str, content, i, parts) => (
    parts.some(p => ['http', 'https', 'ws', 'wss'].includes(p.protocol))
      ? `${str}:${content}`
      : `tcp://${str}:${content}`
  ),
  udp: (str, content) => `udp://${str}:${content}`,
  dnsaddr: reduceValue,
  dns4: reduceValue,
  dns6: reduceValue,
  ipfs: (str, content) => `${str}/ipfs/${content}`,
  p2p: (str, content) => `${str}/p2p/${content}`,
  http: str => `http://${str}`,
  https: str => `https://${str}`,
  ws: str => `ws://${str}`,
  wss: str => `wss://${str}`,
  'p2p-websocket-star': str => `${str}/p2p-websocket-star`,
  'p2p-webrtc-star': str => `${str}/p2p-webrtc-star`,
  'p2p-webrtc-direct': str => `${str}/p2p-webrtc-direct`
}

module.exports = (multiaddr) => (
  Multiaddr(multiaddr)
    .stringTuples()
    .map(tuple => ({
      protocol: Multiaddr.protocols.codes[tuple[0]].name,
      content: tuple[1]
    }))
    .reduce((str, part, i, parts) => {
      const reduce = Reducers[part.protocol]
      if (!reduce) throw new Error(`Unsupported protocol ${part.protocol}`)
      return reduce(str, part.content, i, parts)
    }, '')
)

      };
    };
  }
}, {package:"multiaddr-to-uri",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr-to-uri/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/preload-browser.js", {"debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/preload-browser.js
      return function (require, module, exports) {
/* eslint-env browser */
'use strict'

const debug = require('debug')

const log = debug('ipfs:preload')
log.error = debug('ipfs:preload:error')

module.exports = function preload (url, callback) {
  log(url)

  const controller = new AbortController()
  const signal = controller.signal

  fetch(url, { signal })
    .then(res => {
      if (!res.ok) {
        log.error('failed to preload', url, res.status, res.statusText)
        throw new Error(`failed to preload ${url}`)
      }
      return res.text()
    })
    .then(() => callback())
    .catch(callback)

  return {
    cancel: () => controller.abort()
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/preload-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/retry.js", {"./internal/wrapAsync":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/internal/wrapAsync.js","lodash/constant":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/constant.js","lodash/noop":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/noop.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/async/retry.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = retry;

var _noop = require('lodash/noop');

var _noop2 = _interopRequireDefault(_noop);

var _constant = require('lodash/constant');

var _constant2 = _interopRequireDefault(_constant);

var _wrapAsync = require('./internal/wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Attempts to get a successful response from `task` no more than `times` times
 * before returning an error. If the task is successful, the `callback` will be
 * passed the result of the successful task. If all attempts fail, the callback
 * will be passed the error and result (if any) of the final attempt.
 *
 * @name retry
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @see [async.retryable]{@link module:ControlFlow.retryable}
 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an
 * object with `times` and `interval` or a number.
 * * `times` - The number of attempts to make before giving up.  The default
 *   is `5`.
 * * `interval` - The time to wait between retries, in milliseconds.  The
 *   default is `0`. The interval may also be specified as a function of the
 *   retry count (see example).
 * * `errorFilter` - An optional synchronous function that is invoked on
 *   erroneous result. If it returns `true` the retry attempts will continue;
 *   if the function returns `false` the retry flow is aborted with the current
 *   attempt's error and result being returned to the final callback.
 *   Invoked with (err).
 * * If `opts` is a number, the number specifies the number of times to retry,
 *   with the default interval of `0`.
 * @param {AsyncFunction} task - An async function to retry.
 * Invoked with (callback).
 * @param {Function} [callback] - An optional callback which is called when the
 * task has succeeded, or after the final failed attempt. It receives the `err`
 * and `result` arguments of the last attempt at completing the `task`. Invoked
 * with (err, results).
 *
 * @example
 *
 * // The `retry` function can be used as a stand-alone control flow by passing
 * // a callback, as shown below:
 *
 * // try calling apiMethod 3 times
 * async.retry(3, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod 3 times, waiting 200 ms between each retry
 * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod 10 times with exponential backoff
 * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)
 * async.retry({
 *   times: 10,
 *   interval: function(retryCount) {
 *     return 50 * Math.pow(2, retryCount);
 *   }
 * }, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod the default 5 times no delay between each retry
 * async.retry(apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod only when error condition satisfies, all other
 * // errors will abort the retry control flow and return to final callback
 * async.retry({
 *   errorFilter: function(err) {
 *     return err.message === 'Temporary error'; // only retry on a specific error
 *   }
 * }, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // to retry individual methods that are not as reliable within other
 * // control flow functions, use the `retryable` wrapper:
 * async.auto({
 *     users: api.getUsers.bind(api),
 *     payments: async.retryable(3, api.getPayments.bind(api))
 * }, function(err, results) {
 *     // do something with the results
 * });
 *
 */
function retry(opts, task, callback) {
    var DEFAULT_TIMES = 5;
    var DEFAULT_INTERVAL = 0;

    var options = {
        times: DEFAULT_TIMES,
        intervalFunc: (0, _constant2.default)(DEFAULT_INTERVAL)
    };

    function parseTimes(acc, t) {
        if (typeof t === 'object') {
            acc.times = +t.times || DEFAULT_TIMES;

            acc.intervalFunc = typeof t.interval === 'function' ? t.interval : (0, _constant2.default)(+t.interval || DEFAULT_INTERVAL);

            acc.errorFilter = t.errorFilter;
        } else if (typeof t === 'number' || typeof t === 'string') {
            acc.times = +t || DEFAULT_TIMES;
        } else {
            throw new Error("Invalid arguments for async.retry");
        }
    }

    if (arguments.length < 3 && typeof opts === 'function') {
        callback = task || _noop2.default;
        task = opts;
    } else {
        parseTimes(options, opts);
        callback = callback || _noop2.default;
    }

    if (typeof task !== 'function') {
        throw new Error("Invalid arguments for async.retry");
    }

    var _task = (0, _wrapAsync2.default)(task);

    var attempt = 1;
    function retryAttempt() {
        _task(function (err) {
            if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) {
                setTimeout(retryAttempt, options.intervalFunc(attempt));
            } else {
                callback.apply(null, arguments);
            }
        });
    }

    retryAttempt();
}
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/retry.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld/src/util.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld/src/util.js
      return function (require, module, exports) {
'use strict'

exports.first = async (iterator) => {
  for await (const value of iterator) {
    return value
  }
}

exports.last = async (iterator) => {
  let value
  for await (value of iterator) {
    // Intentionally empty
  }
  return value
}

exports.all = async (iterator) => {
  const values = []
  for await (const value of iterator) {
    values.push(value)
  }
  return values
}

exports.extendIterator = (iterator) => {
  iterator.first = () => exports.first(iterator)
  iterator.last = () => exports.last(iterator)
  iterator.all = () => exports.all(iterator)
  return iterator
}

      };
    };
  }
}, {package:"ipld",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld/src/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-cbor/src/index.js", {"./resolver.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-cbor/src/resolver.js","./util.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-cbor/src/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-cbor/src/index.js
      return function (require, module, exports) {
'use strict'

exports.util = require('./util.js')
exports.resolver = require('./resolver.js')
exports.codec = exports.util.codec
exports.defaultHashAlg = exports.util.defaultHashAlg

      };
    };
  }
}, {package:"ipld-dag-cbor",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-cbor/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/index.js", {"./dag-link":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-link/index.js","./dag-node":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/dag-node/index.js","./resolver":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/resolver.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/index.js
      return function (require, module, exports) {
'use strict'

exports.DAGNode = require('./dag-node')
exports.DAGLink = require('./dag-link')

/*
 * Functions to fulfil IPLD Format interface
 * https://github.com/ipld/interface-ipld-format
 */
exports.resolver = require('./resolver')
exports.util = require('./util')
exports.codec = exports.util.codec
exports.defaultHashAlg = exports.util.defaultHashAlg

      };
    };
  }
}, {package:"ipld-dag-pb",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-raw/src/index.js", {"cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","multicodec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/index.js","multihashing-async":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashing-async/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-raw/src/index.js
      return function (require, module, exports) {
'use strict'
const CID = require('cids')
const multihashing = require('multihashing-async')
const multicodec = require('multicodec')

// binary resolver
module.exports = {
  codec: multicodec.RAW,
  defaultHashAlg: multicodec.SHA2_256,
  resolver: {
    /**
     * Resolves a path within a Raw block.
     *
     * Always returns the raw data as value without any remainderPath.
     *
     * @param {Buffer} binaryBlob - Binary representation of a PB block
     * @param {string} [path='/'] - Path that should be resolved (that value is ignored)
     * @returns {Object} result - Result of the path it it was resolved successfully
     * @returns {*} result.value - The raw data
     * @returns {string} result.remainderPath - An empty string
     */
    resolve: (binaryBlob, path) => {
      return {
        value: binaryBlob,
        remainderPath: ''
      }
    },
    /**
     * Return all available paths of a block.
     *
     * @generator
     * @param {Buffer} binaryBlob - The raw data
     * @returns {Object} - Finished generator with `done: true`
     */
    tree: (binaryBlob) => {
      return {
        done: true
      }
    }
  },
  util: {
    deserialize: (data) => {
      return data
    },
    serialize: (data) => {
      return data
    },
    /**
     * Calculate the CID of the binary blob.
     *
     * @param {Object} binaryBlob - Encoded IPLD Node
     * @param {Object} [userOptions] - Options to create the CID
     * @param {number} [userOptions.cidVersion=1] - CID version number
     * @param {string} [UserOptions.hashAlg] - Defaults to the defaultHashAlg of the format
     * @returns {Promise.<CID>}
     */
    cid: async (binaryBlob, userOptions) => {
      const defaultOptions = { cidVersion: 1, hashAlg: module.exports.defaultHashAlg }
      const options = Object.assign(defaultOptions, userOptions)

      const multihash = await multihashing(binaryBlob, options.hashAlg)
      const codecName = multicodec.print[module.exports.codec]
      const cid = new CID(options.cidVersion, codecName, multihash)

      return cid
    }
  }
}

      };
    };
  }
}, {package:"ipld-raw",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-raw/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js
      return function (require, module, exports) {
/** PROMISIFY CALLBACK-STYLE FUNCTIONS TO ES6 PROMISES
*
* EXAMPLE:
* const fn = promisify( (callback) => callback(null, "Hello world!") );
* fn((err, str) => console.log(str));
* fn().then((str) => console.log(str));
* //Both functions, will log 'Hello world!'
*
* Note: The function you pass, may have any arguments you want, but the latest
* have to be the callback, which you will call with: next(err, value)
*
* @param method: Function/Array/Map = The function(s) to promisify
* @param options: Map =
*  "context" (default is function): The context which to apply the called function
*  "replace" (default is falsy): When passed an array/map, if to replace the original object
*
* @return: A promise if passed a function, otherwise the object with the promises
*
* @license: MIT
* @version: 1.0.3
* @author: Manuel Di Iorio
**/

var createCallback = function (method, context) {
    return function () {
        var args = Array.prototype.slice.call(arguments);
        var lastIndex = args.length - 1;
        var lastArg = args && args.length > 0 ? args[lastIndex] : null;
        var cb = typeof lastArg === 'function' ? lastArg : null;

        if (cb) {
            return method.apply(context, args);
        }

        return new Promise(function (resolve, reject) {
            args.push(function (err, val) {
                if (err) return reject(err);
                resolve(val);
            });

            method.apply(context, args);
        });
    };
};

if (typeof module === "undefined") module = {}; // Browserify this module

module.exports = function (methods, options) {
    options = options || {};
    var type = Object.prototype.toString.call(methods);

    if (type === "[object Object]" || type === "[object Array]") {
        var obj = options.replace ? methods : {};

        for (var key in methods) {
            if (methods.hasOwnProperty(key)) obj[key] = createCallback(methods[key]);
        }return obj;
    }

    return createCallback(methods, options.context || methods);
};

// Browserify this module
if (typeof exports === "undefined") {
    this["promisify"] = module.exports;
}

      };
    };
  }
}, {package:"promisify-es6",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/typical/dist/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/typical/dist/index.js
      return function (require, module, exports) {
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.typical = {}));
}(this, function (exports) { 'use strict';

  /**
   * For type-checking Javascript values.
   * @module typical
   * @typicalname t
   * @example
   * const t = require('typical')
   */

  /**
   * Returns true if input is a number
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   * @example
   * > t.isNumber(0)
   * true
   * > t.isNumber(1)
   * true
   * > t.isNumber(1.1)
   * true
   * > t.isNumber(0xff)
   * true
   * > t.isNumber(0644)
   * true
   * > t.isNumber(6.2e5)
   * true
   * > t.isNumber(NaN)
   * false
   * > t.isNumber(Infinity)
   * false
   */
  function isNumber (n) {
    return !isNaN(parseFloat(n)) && isFinite(n)
  }

  /**
   * A plain object is a simple object literal, it is not an instance of a class. Returns true if the input `typeof` is `object` and directly decends from `Object`.
   *
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   * @example
   * > t.isPlainObject({ something: 'one' })
   * true
   * > t.isPlainObject(new Date())
   * false
   * > t.isPlainObject([ 0, 1 ])
   * false
   * > t.isPlainObject(/test/)
   * false
   * > t.isPlainObject(1)
   * false
   * > t.isPlainObject('one')
   * false
   * > t.isPlainObject(null)
   * false
   * > t.isPlainObject((function * () {})())
   * false
   * > t.isPlainObject(function * () {})
   * false
   */
  function isPlainObject (input) {
    return input !== null && typeof input === 'object' && input.constructor === Object
  }

  /**
   * An array-like value has all the properties of an array, but is not an array instance. Examples in the `arguments` object. Returns true if the input value is an object, not null and has a `length` property with a numeric value.
   *
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   * @example
   * function sum(x, y){
   *   console.log(t.isArrayLike(arguments))
   *   // prints `true`
   * }
   */
  function isArrayLike (input) {
    return isObject(input) && typeof input.length === 'number'
  }

  /**
   * Returns true if the typeof input is `'object'` but not null.
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   */
  function isObject (input) {
    return typeof input === 'object' && input !== null
  }

  /**
   * Returns true if the input value is defined.
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   */
  function isDefined (input) {
    return typeof input !== 'undefined'
  }

  /**
   * Returns true if the input value is an ES2015 `class`.
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   */
  function isClass (input) {
    if (typeof input === 'function') {
      return /^class /.test(Function.prototype.toString.call(input))
    } else {
      return false
    }
  }

  /**
   * Returns true if the input is a string, number, symbol, boolean, null or undefined value.
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   */
  function isPrimitive (input) {
    if (input === null) return true
    switch (typeof input) {
      case 'string':
      case 'number':
      case 'symbol':
      case 'undefined':
      case 'boolean':
        return true
      default:
        return false
    }
  }

  /**
   * Returns true if the input is a Promise.
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   */
  function isPromise (input) {
    if (input) {
      const isPromise = isDefined(Promise) && input instanceof Promise;
      const isThenable = input.then && typeof input.then === 'function';
      return !!(isPromise || isThenable)
    } else {
      return false
    }
  }

  /**
   * Returns true if the input is an iterable (`Map`, `Set`, `Array`, Generator etc.).
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   * @example
   * > t.isIterable('string')
   * true
   * > t.isIterable(new Map())
   * true
   * > t.isIterable([])
   * true
   * > t.isIterable((function * () {})())
   * true
   * > t.isIterable(Promise.resolve())
   * false
   * > t.isIterable(Promise)
   * false
   * > t.isIterable(true)
   * false
   * > t.isIterable({})
   * false
   * > t.isIterable(0)
   * false
   * > t.isIterable(1.1)
   * false
   * > t.isIterable(NaN)
   * false
   * > t.isIterable(Infinity)
   * false
   * > t.isIterable(function () {})
   * false
   * > t.isIterable(Date)
   * false
   * > t.isIterable()
   * false
   * > t.isIterable({ then: function () {} })
   * false
   */
  function isIterable (input) {
    if (input === null || !isDefined(input)) {
      return false
    } else {
      return (
        typeof input[Symbol.iterator] === 'function' ||
        typeof input[Symbol.asyncIterator] === 'function'
      )
    }
  }

  /**
   * Returns true if the input value is a string. The equivalent of `typeof input === 'string'`` for use in funcitonal contexts.
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   */
  function isString (input) {
    return typeof input === 'string'
  }

  /**
   * Returns true if the input value is a function. The equivalent of `typeof input === 'function'`` for use in funcitonal contexts.
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   */
  function isFunction (input) {
    return typeof input === 'function'
  }

  var index = {
    isNumber,
    isPlainObject,
    isArrayLike,
    isObject,
    isDefined,
    isClass,
    isPrimitive,
    isPromise,
    isIterable,
    isString,
    isFunction
  };

  exports.default = index;
  exports.isArrayLike = isArrayLike;
  exports.isClass = isClass;
  exports.isDefined = isDefined;
  exports.isFunction = isFunction;
  exports.isIterable = isIterable;
  exports.isNumber = isNumber;
  exports.isObject = isObject;
  exports.isPlainObject = isPlainObject;
  exports.isPrimitive = isPrimitive;
  exports.isPromise = isPromise;
  exports.isString = isString;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

      };
    };
  }
}, {package:"typical",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/typical/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-block/src/index.js", {"../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","class-is":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/class-is/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-block/src/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const CID = require('cids')
const withIs = require('class-is')

/**
 * Represents an immutable block of data that is uniquely referenced with a cid.
 *
 * @constructor
 * @param {Buffer} data - The data to be stored in the block as a buffer.
 * @param {CID} cid - The cid of the data
 *
 * @example
 * const block = new Block(new Buffer('a012d83b20f9371...'))
 */
class Block {
  constructor (data, cid) {
    if (!data || !Buffer.isBuffer(data)) {
      throw new Error('first argument  must be a buffer')
    }

    if (!cid || !CID.isCID(cid)) {
      throw new Error('second argument must be a CID')
    }

    this._data = data
    this._cid = cid
  }

  /**
   * The data of this block.
   *
   * @type {Buffer}
   */
  get data () {
    return this._data
  }

  set data (val) {
    throw new Error('Tried to change an immutable block')
  }

  /**
   * The cid of the data this block represents.
   *
   * @type {CID}
   */
  get cid () {
    return this._cid
  }

  set cid (val) {
    throw new Error('Tried to change an immutable block')
  }
}

module.exports = withIs(Block, { className: 'Block', symbolName: '@ipfs/js-ipfs-block/block' })

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

      };
    };
  }
}, {package:"ipfs-block",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-block/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/constants.js", {"./base.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/base.js","./base16":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/base16.js","./base32":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/base32.js","./base64":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/base64.js","base-x":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/node_modules/base-x/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/constants.js
      return function (require, module, exports) {
'use strict'

const Base = require('./base.js')
const baseX = require('base-x')
const base16 = require('./base16')
const base32 = require('./base32')
const base64 = require('./base64')

// name, code, implementation, alphabet
const constants = [
  ['base1', '1', '', '1'],
  ['base2', '0', baseX, '01'],
  ['base8', '7', baseX, '01234567'],
  ['base10', '9', baseX, '0123456789'],
  ['base16', 'f', base16, '0123456789abcdef'],
  ['base32', 'b', base32, 'abcdefghijklmnopqrstuvwxyz234567'],
  ['base32pad', 'c', base32, 'abcdefghijklmnopqrstuvwxyz234567='],
  ['base32hex', 'v', base32, '0123456789abcdefghijklmnopqrstuv'],
  ['base32hexpad', 't', base32, '0123456789abcdefghijklmnopqrstuv='],
  ['base32z', 'h', base32, 'ybndrfg8ejkmcpqxot1uwisza345h769'],
  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
  ['base64', 'm', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
  ['base64pad', 'M', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
  ['base64url', 'u', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
  ['base64urlpad', 'U', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
]

const names = constants.reduce((prev, tupple) => {
  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
  return prev
}, {})

const codes = constants.reduce((prev, tupple) => {
  prev[tupple[1]] = names[tupple[0]]
  return prev
}, {})

module.exports = {
  names: names,
  codes: codes
}

      };
    };
  }
}, {package:"multibase",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/protocols-table.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/protocols-table.js
      return function (require, module, exports) {
'use strict'

function Protocols (proto) {
  if (typeof (proto) === 'number') {
    if (Protocols.codes[proto]) {
      return Protocols.codes[proto]
    }

    throw new Error('no protocol with code: ' + proto)
  } else if (typeof (proto) === 'string' || proto instanceof String) {
    if (Protocols.names[proto]) {
      return Protocols.names[proto]
    }

    throw new Error('no protocol with name: ' + proto)
  }

  throw new Error('invalid protocol id type: ' + proto)
}

const V = -1
Protocols.lengthPrefixedVarSize = V
Protocols.V = V

Protocols.table = [
  [4, 32, 'ip4'],
  [6, 16, 'tcp'],
  [33, 16, 'dccp'],
  [41, 128, 'ip6'],
  [42, V, 'ip6zone'],
  [53, V, 'dns', 'resolvable'],
  [54, V, 'dns4', 'resolvable'],
  [55, V, 'dns6', 'resolvable'],
  [56, V, 'dnsaddr', 'resolvable'],
  [132, 16, 'sctp'],
  [273, 16, 'udp'],
  [275, 0, 'p2p-webrtc-star'],
  [276, 0, 'p2p-webrtc-direct'],
  [277, 0, 'p2p-stardust'],
  [290, 0, 'p2p-circuit'],
  [301, 0, 'udt'],
  [302, 0, 'utp'],
  [400, V, 'unix', false, 'path'],
  // `p2p` is the preferred name for 421
  [421, V, 'p2p'],
  // `ipfs` has been added after `p2p` so that it is used by default.
  // The reason for this is to provide better backwards support for
  // code bases that do not yet support the `p2p` proto name. Eventually
  // `p2p` should become the default.
  [421, V, 'ipfs'],
  [443, 0, 'https'],
  [444, 96, 'onion'],
  [445, 296, 'onion3'],
  [446, V, 'garlic64'],
  [460, 0, 'quic'],
  [477, 0, 'ws'],
  [478, 0, 'wss'],
  [479, 0, 'p2p-websocket-star'],
  [480, 0, 'http']
]

Protocols.names = {}
Protocols.codes = {}

// populate tables
Protocols.table.map(row => {
  const proto = p.apply(null, row)
  Protocols.codes[proto.code] = proto
  Protocols.names[proto.name] = proto
})

Protocols.object = p

function p (code, size, name, resolvable, path) {
  return {
    code: code,
    size: size,
    name: name,
    resolvable: Boolean(resolvable),
    path: Boolean(path)
  }
}

module.exports = Protocols

      };
    };
  }
}, {package:"multiaddr",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/protocols-table.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/codec.js", {"./convert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/convert.js","./protocols-table":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/protocols-table.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/codec.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const convert = require('./convert')
const protocols = require('./protocols-table')
const varint = require('varint')

// export codec
module.exports = {
  stringToStringTuples: stringToStringTuples,
  stringTuplesToString: stringTuplesToString,

  tuplesToStringTuples: tuplesToStringTuples,
  stringTuplesToTuples: stringTuplesToTuples,

  bufferToTuples: bufferToTuples,
  tuplesToBuffer: tuplesToBuffer,

  bufferToString: bufferToString,
  stringToBuffer: stringToBuffer,

  fromString: fromString,
  fromBuffer: fromBuffer,
  validateBuffer: validateBuffer,
  isValidBuffer: isValidBuffer,
  cleanPath: cleanPath,

  ParseError: ParseError,
  protoFromTuple: protoFromTuple,

  sizeForAddr: sizeForAddr
}

// string -> [[str name, str addr]... ]
function stringToStringTuples (str) {
  const tuples = []
  const parts = str.split('/').slice(1) // skip first empty elem
  if (parts.length === 1 && parts[0] === '') {
    return []
  }

  for (let p = 0; p < parts.length; p++) {
    const part = parts[p]
    const proto = protocols(part)

    if (proto.size === 0) {
      tuples.push([part])
      continue
    }

    p++ // advance addr part
    if (p >= parts.length) {
      throw ParseError('invalid address: ' + str)
    }

    // if it's a path proto, take the rest
    if (proto.path) {
      tuples.push([
        part,
        // TODO: should we need to check each path part to see if it's a proto?
        // This would allow for other protocols to be added after a unix path,
        // however it would have issues if the path had a protocol name in the path
        cleanPath(parts.slice(p).join('/'))
      ])
      break
    }

    tuples.push([part, parts[p]])
  }

  return tuples
}

// [[str name, str addr]... ] -> string
function stringTuplesToString (tuples) {
  const parts = []
  tuples.map(tup => {
    const proto = protoFromTuple(tup)
    parts.push(proto.name)
    if (tup.length > 1) {
      parts.push(tup[1])
    }
  })

  return cleanPath(parts.join('/'))
}

// [[str name, str addr]... ] -> [[int code, Buffer]... ]
function stringTuplesToTuples (tuples) {
  return tuples.map(tup => {
    if (!Array.isArray(tup)) {
      tup = [tup]
    }
    const proto = protoFromTuple(tup)
    if (tup.length > 1) {
      return [proto.code, convert.toBuffer(proto.code, tup[1])]
    }
    return [proto.code]
  })
}

// [[int code, Buffer]... ] -> [[str name, str addr]... ]
function tuplesToStringTuples (tuples) {
  return tuples.map(tup => {
    const proto = protoFromTuple(tup)
    if (tup.length > 1) {
      return [proto.code, convert.toString(proto.code, tup[1])]
    }
    return [proto.code]
  })
}

// [[int code, Buffer ]... ] -> Buffer
function tuplesToBuffer (tuples) {
  return fromBuffer(Buffer.concat(tuples.map(tup => {
    const proto = protoFromTuple(tup)
    let buf = Buffer.from(varint.encode(proto.code))

    if (tup.length > 1) {
      buf = Buffer.concat([buf, tup[1]]) // add address buffer
    }

    return buf
  })))
}

function sizeForAddr (p, addr) {
  if (p.size > 0) {
    return p.size / 8
  } else if (p.size === 0) {
    return 0
  } else {
    const size = varint.decode(addr)
    return size + varint.decode.bytes
  }
}

// Buffer -> [[int code, Buffer ]... ]
function bufferToTuples (buf) {
  const tuples = []
  let i = 0
  while (i < buf.length) {
    const code = varint.decode(buf, i)
    const n = varint.decode.bytes

    const p = protocols(code)

    const size = sizeForAddr(p, buf.slice(i + n))

    if (size === 0) {
      tuples.push([code])
      i += n
      continue
    }

    const addr = buf.slice(i + n, i + n + size)

    i += (size + n)

    if (i > buf.length) { // did not end _exactly_ at buffer.length
      throw ParseError('Invalid address buffer: ' + buf.toString('hex'))
    }

    // ok, tuple seems good.
    tuples.push([code, addr])
  }

  return tuples
}

// Buffer -> String
function bufferToString (buf) {
  const a = bufferToTuples(buf)
  const b = tuplesToStringTuples(a)
  return stringTuplesToString(b)
}

// String -> Buffer
function stringToBuffer (str) {
  str = cleanPath(str)
  const a = stringToStringTuples(str)
  const b = stringTuplesToTuples(a)

  return tuplesToBuffer(b)
}

// String -> Buffer
function fromString (str) {
  return stringToBuffer(str)
}

// Buffer -> Buffer
function fromBuffer (buf) {
  const err = validateBuffer(buf)
  if (err) throw err
  return Buffer.from(buf) // copy
}

function validateBuffer (buf) {
  try {
    bufferToTuples(buf) // try to parse. will throw if breaks
  } catch (err) {
    return err
  }
}

function isValidBuffer (buf) {
  return validateBuffer(buf) === undefined
}

function cleanPath (str) {
  return '/' + str.trim().split('/').filter(a => a).join('/')
}

function ParseError (str) {
  return new Error('Error parsing address: ' + str)
}

function protoFromTuple (tup) {
  const proto = protocols(tup[0])
  return proto
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multiaddr",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/codec.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/crypto.js", {"./blake":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/blake.js","./crypto-sha1-2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/crypto-sha1-2-browser.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/utils.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","js-sha3":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/js-sha3/src/sha3.js","murmurhash3js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/murmurhash3js/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/crypto.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const sha3 = require('js-sha3')
const murmur3 = require('murmurhash3js')

const utils = require('./utils')
const sha = require('./crypto-sha1-2')

const toCallback = utils.toCallback
const toBuf = utils.toBuf
const fromString = utils.fromString
const fromNumberTo32BitBuf = utils.fromNumberTo32BitBuf

const dblSha2256 = (buf, cb) => {
  sha.sha2256(buf, (err, firstHash) => {
    if (err) {
      cb(err)
    }
    sha.sha2256((Buffer.from(firstHash)), cb)
  })
}

module.exports = {
  sha1: sha.sha1,
  sha2256: sha.sha2256,
  sha2512: sha.sha2512,
  sha3512: toCallback(toBuf(sha3.sha3_512)),
  sha3384: toCallback(toBuf(sha3.sha3_384)),
  sha3256: toCallback(toBuf(sha3.sha3_256)),
  sha3224: toCallback(toBuf(sha3.sha3_224)),
  shake128: toCallback(toBuf(sha3.shake_128, 128)),
  shake256: toCallback(toBuf(sha3.shake_256, 256)),
  keccak224: toCallback(toBuf(sha3.keccak_224)),
  keccak256: toCallback(toBuf(sha3.keccak_256)),
  keccak384: toCallback(toBuf(sha3.keccak_384)),
  keccak512: toCallback(toBuf(sha3.keccak_512)),
  murmur3128: toCallback(toBuf(fromString(murmur3.x64.hash128))),
  murmur332: toCallback(fromNumberTo32BitBuf(fromString(murmur3.x86.hash32))),
  addBlake: require('./blake'),
  dblSha2256: dblSha2256
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/crypto.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/hmac/index-browser.js", {"../nodeify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/nodeify.js","../webcrypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/webcrypto.js","./lengths":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/hmac/lengths.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/hmac/index-browser.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const nodeify = require('../nodeify')

const crypto = require('../webcrypto')
const lengths = require('./lengths')

const hashTypes = {
  SHA1: 'SHA-1',
  SHA256: 'SHA-256',
  SHA512: 'SHA-512'
}

const sign = (key, data, cb) => {
  nodeify(crypto.subtle.sign({ name: 'HMAC' }, key, data)
    .then((raw) => Buffer.from(raw)), cb)
}

exports.create = function (hashType, secret, callback) {
  const hash = hashTypes[hashType]

  nodeify(crypto.subtle.importKey(
    'raw',
    secret,
    {
      name: 'HMAC',
      hash: { name: hash }
    },
    false,
    ['sign']
  ).then((key) => {
    return {
      digest (data, cb) {
        sign(key, data, cb)
      },
      length: lengths[hashType]
    }
  }), callback)
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-crypto",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/hmac/index-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/random-bytes.js", {"iso-random-stream/src/random":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/iso-random-stream/src/random.browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/random-bytes.js
      return function (require, module, exports) {
'use strict'
const randomBytes = require('iso-random-stream/src/random')

module.exports = function (number) {
  if (!number || typeof number !== 'number') {
    throw new Error('first argument must be a Number bigger than 0')
  }
  return randomBytes(number)
}

      };
    };
  }
}, {package:"libp2p-crypto",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/random-bytes.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/aes/index.js", {"./ciphers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/aes/ciphers-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/aes/index.js
      return function (require, module, exports) {
'use strict'

const ciphers = require('./ciphers')

const CIPHER_MODES = {
  16: 'aes-128-ctr',
  32: 'aes-256-ctr'
}

exports.create = function (key, iv, callback) {
  const mode = CIPHER_MODES[key.length]
  if (!mode) {
    return callback(new Error('Invalid key length'))
  }

  const cipher = ciphers.createCipheriv(mode, key, iv)
  const decipher = ciphers.createDecipheriv(mode, key, iv)

  const res = {
    encrypt (data, cb) {
      cb(null, cipher.update(data))
    },

    decrypt (data, cb) {
      cb(null, decipher.update(data))
    }
  }

  callback(null, res)
}

      };
    };
  }
}, {package:"libp2p-crypto",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/aes/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/pbkdf2.js", {"node-forge/lib/pbkdf2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/pbkdf2.js","node-forge/lib/util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-forge/lib/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/pbkdf2.js
      return function (require, module, exports) {
'use strict'

const forgePbkdf2 = require('node-forge/lib/pbkdf2')
const forgeUtil = require('node-forge/lib/util')

/**
 * Maps an IPFS hash name to its node-forge equivalent.
 *
 * See https://github.com/multiformats/multihash/blob/master/hashtable.csv
 *
 * @private
 */
const hashName = {
  sha1: 'sha1',
  'sha2-256': 'sha256',
  'sha2-512': 'sha512'
}

/**
 * Computes the Password-Based Key Derivation Function 2.
 *
 * @param {string} password
 * @param {string} salt
 * @param {number} iterations
 * @param {number} keySize (in bytes)
 * @param {string} hash - The hash name ('sha1', 'sha2-512, ...)
 * @returns {string} - A new password
 */
function pbkdf2 (password, salt, iterations, keySize, hash) {
  const hasher = hashName[hash]
  if (!hasher) {
    throw new Error(`Hash '${hash}' is unknown or not supported`)
  }
  const dek = forgePbkdf2(
    password,
    salt,
    iterations,
    keySize,
    hasher)
  return forgeUtil.encode64(dek)
}

module.exports = pbkdf2

      };
    };
  }
}, {package:"libp2p-crypto",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/pbkdf2.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/is-online.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/is-online.js
      return function (require, module, exports) {
'use strict'

module.exports = function isOnline (self) {
  return () => {
    return Boolean(self._bitswap && self.libp2p && self.libp2p.isStarted())
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/is-online.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/version.js", {"../../../package.json":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/package.json","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/version.js
      return function (require, module, exports) {
'use strict'

const pkg = require('../../../package.json')
const promisify = require('promisify-es6')

// TODO add the commit hash of the current ipfs version to the response.
module.exports = function version (self) {
  return promisify((opts, callback) => {
    if (typeof opts === 'function') {
      callback = opts
      opts = {}
    }

    self.repo.version((err, repoVersion) => {
      if (err) {
        return callback(err)
      }

      callback(null, {
        version: pkg.version,
        repo: repoVersion,
        commit: ''
      })
    })
  })
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/version.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/config.js", {"promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/config.js
      return function (require, module, exports) {
'use strict'

const promisify = require('promisify-es6')

module.exports = function config (self) {
  return {
    get: promisify((key, callback) => {
      if (typeof key === 'function') {
        callback = key
        key = undefined
      }

      return self._repo.config.get(key, callback)
    }),
    set: promisify((key, value, callback) => {
      self._repo.config.set(key, value, callback)
    }),
    replace: promisify((config, callback) => {
      self._repo.config.set(config, callback)
    })
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/config.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/dns.js", {"../runtime/dns-nodejs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/dns-browser.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/dns.js
      return function (require, module, exports) {
'use strict'

// dns-nodejs gets replaced by dns-browser when webpacked/browserified
const dns = require('../runtime/dns-nodejs')
const promisify = require('promisify-es6')

module.exports = () => {
  return promisify((domain, opts, callback) => {
    if (typeof domain !== 'string') {
      return callback(new Error('Invalid arguments, domain must be a string'))
    }

    if (typeof opts === 'function') {
      callback = opts
      opts = {}
    }

    opts = opts || {}

    dns(domain, opts, callback)
  })
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/dns.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/key.js", {"promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/key.js
      return function (require, module, exports) {
'use strict'

// See https://github.com/ipfs/specs/tree/master/keystore

const promisify = require('promisify-es6')

module.exports = function key (self) {
  return {
    gen: promisify((name, opts, callback) => {
      opts = opts || {}
      self._keychain.createKey(name, opts.type, opts.size, callback)
    }),

    info: promisify((name, callback) => {
      self._keychain.findKeyByName(name, callback)
    }),

    list: promisify((callback) => {
      self._keychain.listKeys(callback)
    }),

    rm: promisify((name, callback) => {
      self._keychain.removeKey(name, callback)
    }),

    rename: promisify((oldName, newName, callback) => {
      self._keychain.renameKey(oldName, newName, (err, key) => {
        if (err) return callback(err)
        const result = {
          was: oldName,
          now: key.name,
          id: key.id,
          overwrite: false
        }
        callback(null, result)
      })
    }),

    import: promisify((name, pem, password, callback) => {
      self._keychain.importKey(name, pem, password, callback)
    }),

    export: promisify((name, password, callback) => {
      self._keychain.exportKey(name, password, callback)
    })
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/key.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/repo.js", {"ipfs-repo":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-repo/src/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/repo.js
      return function (require, module, exports) {
'use strict'

const promisify = require('promisify-es6')
const repoVersion = require('ipfs-repo').repoVersion

module.exports = function repo (self) {
  return {
    init: (bits, empty, callback) => {
      // 1. check if repo already exists
    },

    /**
     * If the repo has been initialized, report the current version.
     * Otherwise report the version that would be initialized.
     *
     * @param {function(Error, Number)} [callback]
     * @returns {undefined}
     */
    version: promisify((callback) => {
      self._repo._isInitialized(err => {
        if (err) {
          // TODO: (dryajov) This is really hacky, there must be a better way
          const match = [
            /Key not found in database \[\/version\]/,
            /ENOENT/,
            /repo is not initialized yet/
          ].some((m) => {
            return m.test(err.message)
          })
          if (match) {
            // this repo has not been initialized
            return callback(null, repoVersion)
          }
          return callback(err)
        }

        self._repo.version.get(callback)
      })
    }),

    gc: promisify((options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      callback(new Error('Not implemented'))
    }),

    stat: promisify((options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      self._repo.stat(options, (err, stats) => {
        if (err) return callback(err)

        callback(null, {
          numObjects: stats.numObjects,
          repoSize: stats.repoSize,
          repoPath: stats.repoPath,
          version: stats.version.toString(),
          storageMax: stats.storageMax
        })
      })
    }),

    path: () => self._repo.path
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/repo.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/bootstrap.js", {"../runtime/config-nodejs.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/config-browser.js","mafmt":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/mafmt/src/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js","timers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/timers-browserify/main.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/bootstrap.js
      return function (require, module, exports) {
(function (setImmediate){(function (){
'use strict'

const defaultConfig = require('../runtime/config-nodejs.js')
const isMultiaddr = require('mafmt').IPFS.matches
const promisify = require('promisify-es6')

function isValidMultiaddr (ma) {
  try {
    return isMultiaddr(ma)
  } catch (err) {
    return false
  }
}

function invalidMultiaddrError (ma) {
  return new Error(`${ma} is not a valid Multiaddr`)
}

module.exports = function bootstrap (self) {
  return {
    list: promisify((callback) => {
      self._repo.config.get((err, config) => {
        if (err) {
          return callback(err)
        }
        callback(null, { Peers: config.Bootstrap })
      })
    }),
    add: promisify((multiaddr, args, callback) => {
      if (typeof args === 'function') {
        callback = args
        args = { default: false }
      }

      if (multiaddr && !isValidMultiaddr(multiaddr)) {
        return setImmediate(() => callback(invalidMultiaddrError(multiaddr)))
      }

      self._repo.config.get((err, config) => {
        if (err) {
          return callback(err)
        }
        if (args.default) {
          config.Bootstrap = defaultConfig().Bootstrap
        } else if (multiaddr && config.Bootstrap.indexOf(multiaddr) === -1) {
          config.Bootstrap.push(multiaddr)
        }
        self._repo.config.set(config, (err) => {
          if (err) {
            return callback(err)
          }

          callback(null, {
            Peers: args.default ? defaultConfig().Bootstrap : [multiaddr]
          })
        })
      })
    }),
    rm: promisify((multiaddr, args, callback) => {
      if (typeof args === 'function') {
        callback = args
        args = { all: false }
      }
      if (multiaddr && !isValidMultiaddr(multiaddr)) {
        return setImmediate(() => callback(invalidMultiaddrError(multiaddr)))
      }

      self._repo.config.get((err, config) => {
        if (err) {
          return callback(err)
        }
        if (args.all) {
          config.Bootstrap = []
        } else {
          config.Bootstrap = config.Bootstrap.filter((mh) => mh !== multiaddr)
        }

        self._repo.config.set(config, (err) => {
          if (err) {
            return callback(err)
          }

          const res = []
          if (!args.all && multiaddr) {
            res.push(multiaddr)
          }

          callback(null, { Peers: res })
        })
      })
    })
  }
}

}).call(this)}).call(this,require("timers").setImmediate)

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/bootstrap.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/ping-pull-stream.js", {"../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/utils.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","pull-pushable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-pushable/index.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/ping-pull-stream.js
      return function (require, module, exports) {
'use strict'

const debug = require('debug')
const OFFLINE_ERROR = require('../utils').OFFLINE_ERROR
const PeerId = require('peer-id')
const pull = require('pull-stream')
const Pushable = require('pull-pushable')

const log = debug('ipfs:pingPullStream')
log.error = debug('ipfs:pingPullStream:error')

module.exports = function pingPullStream (self) {
  return (peerId, opts) => {
    if (!self.isOnline()) {
      return pull.error(new Error(OFFLINE_ERROR))
    }

    opts = Object.assign({ count: 10 }, opts)

    const source = Pushable()

    getPeer(self.libp2p, source, peerId, (err, peer) => {
      if (err) {
        log.error(err)
        source.end(err)
        return
      }

      runPing(self.libp2p, source, opts.count, peer, (err) => {
        if (err) {
          log.error(err)
          source.push(getPacket({ success: false, text: err.toString() }))
          source.end()
        }
      })
    })

    return source
  }
}

function getPacket (msg) {
  // Default msg
  const basePacket = { success: true, time: 0, text: '' }
  return Object.assign(basePacket, msg)
}

function getPeer (libp2pNode, statusStream, peerIdStr, cb) {
  let peerId

  try {
    peerId = PeerId.createFromB58String(peerIdStr)
  } catch (err) {
    return cb(err)
  }

  let peerInfo

  try {
    peerInfo = libp2pNode.peerBook.get(peerId)
  } catch (err) {
    log('Peer not found in peer book, trying peer routing')

    // Share lookup status just as in the go implemmentation
    statusStream.push(getPacket({ text: `Looking up peer ${peerIdStr}` }))
    return libp2pNode.peerRouting.findPeer(peerId, cb)
  }

  cb(null, peerInfo)
}

function runPing (libp2pNode, statusStream, count, peer, cb) {
  libp2pNode.ping(peer, (err, p) => {
    if (err) { return cb(err) }

    let packetCount = 0
    let totalTime = 0
    statusStream.push(getPacket({ text: `PING ${peer.id.toB58String()}` }))

    p.on('ping', (time) => {
      statusStream.push(getPacket({ time }))
      totalTime += time
      packetCount++
      if (packetCount >= count) {
        const average = totalTime / count
        p.stop()
        statusStream.push(getPacket({ text: `Average latency: ${average}ms` }))
        statusStream.end()
      }
    })

    p.on('error', (err) => {
      log.error(err)
      p.stop()
      cb(err)
    })

    p.start()
  })
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/ping-pull-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/ping-readable-stream.js", {"pull-stream-to-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream-to-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/ping-readable-stream.js
      return function (require, module, exports) {
'use strict'

const toStream = require('pull-stream-to-stream')

module.exports = function pingReadableStream (self) {
  return (peerId, opts) => toStream.source(self.pingPullStream(peerId, opts))
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/ping-readable-stream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/stop.js", {"async/parallel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/parallel.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/stop.js
      return function (require, module, exports) {
'use strict'

const parallel = require('async/parallel')
const promisify = require('promisify-es6')

module.exports = (self) => {
  return promisify((callback) => {
    callback = callback || function noop () {}

    self.log('stop')

    if (self.state.state() === 'stopped') {
      return callback(new Error('Already stopped'))
    }

    if (self.state.state() !== 'running') {
      return callback(new Error('Not able to stop from state: ' + self.state.state()))
    }

    self.state.stop()
    self._blockService.unsetExchange()
    self._bitswap.stop()
    self._preload.stop()

    parallel([
      cb => self._ipns.republisher.stop(cb),
      cb => self._mfsPreload.stop(cb),
      cb => {
        const libp2p = self.libp2p
        self.libp2p = null
        libp2p.stop(cb)
      }
    ], err => {
      self._repo.close(closeErr => {
        if (err || closeErr) {
          self.emit('error', err || closeErr)
          return callback(err || closeErr)
        }

        self.state.stopped()
        self.emit('stop')
        callback()
      })
    })
  })
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/stop.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/id.js", {"../../../package.json":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/package.json","async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/id.js
      return function (require, module, exports) {
'use strict'

const promisify = require('promisify-es6')
const setImmediate = require('async/setImmediate')
const pkgversion = require('../../../package.json').version

module.exports = function id (self) {
  return promisify((opts, callback) => {
    if (typeof opts === 'function') {
      callback = opts
      opts = {}
    }

    setImmediate(() => callback(null, {
      id: self._peerInfo.id.toB58String(),
      publicKey: self._peerInfo.id.pubKey.bytes.toString('base64'),
      addresses: self._peerInfo.multiaddrs
        .toArray()
        .map((ma) => ma.toString())
        .filter((ma) => ma.indexOf('ipfs') >= 0)
        .sort(),
      agentVersion: `js-ipfs/${pkgversion}`,
      protocolVersion: '9000'
    }))
  })
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/id.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/block.js", {"async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","ipfs-block":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-block/src/index.js","multihashing-async":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/block.js
      return function (require, module, exports) {
'use strict'

const Block = require('ipfs-block')
const multihashing = require('multihashing-async')
const CID = require('cids')
const waterfall = require('async/waterfall')
const setImmediate = require('async/setImmediate')
const promisify = require('promisify-es6')
const errCode = require('err-code')

module.exports = function block (self) {
  return {
    get: promisify((cid, options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      options = options || {}

      try {
        cid = cleanCid(cid)
      } catch (err) {
        return setImmediate(() => callback(errCode(err, 'ERR_INVALID_CID')))
      }

      if (options.preload !== false) {
        self._preload(cid)
      }

      self._blockService.get(cid, callback)
    }),
    put: promisify((block, options, callback) => {
      callback = callback || function noop () {}

      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      options = options || {}

      if (Array.isArray(block)) {
        return callback(new Error('Array is not supported'))
      }

      waterfall([
        (cb) => {
          if (Block.isBlock(block)) {
            return cb(null, block)
          }

          if (options.cid && CID.isCID(options.cid)) {
            return cb(null, new Block(block, options.cid))
          }

          const mhtype = options.mhtype || 'sha2-256'
          const format = options.format || 'dag-pb'
          let cidVersion
          // const mhlen = options.mhlen || 0

          if (options.version == null) {
            // Pick appropriate CID version
            cidVersion = mhtype === 'sha2-256' && format === 'dag-pb' ? 0 : 1
          } else {
            cidVersion = options.version
          }

          multihashing(block, mhtype, (err, multihash) => {
            if (err) {
              return cb(err)
            }

            let cid
            try {
              cid = new CID(cidVersion, format, multihash)
            } catch (err) {
              return cb(err)
            }

            cb(null, new Block(block, cid))
          })
        },
        (block, cb) => self._blockService.put(block, (err) => {
          if (err) {
            return cb(err)
          }

          if (options.preload !== false) {
            self._preload(block.cid)
          }

          cb(null, block)
        })
      ], callback)
    }),
    rm: promisify((cid, callback) => {
      try {
        cid = cleanCid(cid)
      } catch (err) {
        return setImmediate(() => callback(errCode(err, 'ERR_INVALID_CID')))
      }
      self._blockService.delete(cid, callback)
    }),
    stat: promisify((cid, options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      options = options || {}

      try {
        cid = cleanCid(cid)
      } catch (err) {
        return setImmediate(() => callback(errCode(err, 'ERR_INVALID_CID')))
      }

      if (options.preload !== false) {
        self._preload(cid)
      }

      self._blockService.get(cid, (err, block) => {
        if (err) {
          return callback(err)
        }
        callback(null, {
          key: cid.toString(),
          size: block.data.length
        })
      })
    })
  }
}

function cleanCid (cid) {
  if (CID.isCID(cid)) {
    return cid
  }

  // CID constructor knows how to do the cleaning :)
  return new CID(cid)
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/block.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/object.js", {"async/parallel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/parallel.js","async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","ipfs-unixfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs/src/index.js","ipld-dag-pb":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/index.js","multicodec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/object.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const waterfall = require('async/waterfall')
const parallel = require('async/parallel')
const setImmediate = require('async/setImmediate')
const promisify = require('promisify-es6')
const dagPB = require('ipld-dag-pb')
const DAGNode = dagPB.DAGNode
const DAGLink = dagPB.DAGLink
const CID = require('cids')
const mh = require('multihashes')
const multicodec = require('multicodec')
const Unixfs = require('ipfs-unixfs')
const errCode = require('err-code')

function normalizeMultihash (multihash, enc) {
  if (typeof multihash === 'string') {
    if (enc === 'base58' || !enc) {
      return multihash
    }

    return Buffer.from(multihash, enc)
  } else if (Buffer.isBuffer(multihash)) {
    return multihash
  } else if (CID.isCID(multihash)) {
    return multihash.buffer
  } else {
    throw new Error('unsupported multihash')
  }
}

function parseBuffer (buf, encoding, callback) {
  switch (encoding) {
    case 'json':
      return parseJSONBuffer(buf, callback)
    case 'protobuf':
      return parseProtoBuffer(buf, callback)
    default:
      callback(new Error(`unkown encoding: ${encoding}`))
  }
}

function parseJSONBuffer (buf, callback) {
  let data
  let links

  try {
    const parsed = JSON.parse(buf.toString())

    links = (parsed.Links || []).map((link) => {
      return new DAGLink(
        link.Name || link.name,
        link.Size || link.size,
        mh.fromB58String(link.Hash || link.hash || link.multihash)
      )
    })
    data = Buffer.from(parsed.Data)
  } catch (err) {
    return callback(new Error('failed to parse JSON: ' + err))
  }

  try {
    callback(null, DAGNode.create(data, links))
  } catch (err) {
    callback(err)
  }
}

function parseProtoBuffer (buf, callback) {
  let obj
  try {
    obj = dagPB.util.deserialize(buf)
  } catch (err) {
    return callback(err)
  }
  callback(null, obj)
}

function findLinks (node, links = []) {
  for (let key in node) {
    const val = node[key]

    if (key === '/' && Object.keys(node).length === 1) {
      try {
        links.push(new DAGLink('', 0, new CID(val)))
        continue
      } catch (_) {
        // not a CID
      }
    }

    if (CID.isCID(val)) {
      links.push(new DAGLink('', 0, val))

      continue
    }

    if (Array.isArray(val)) {
      findLinks(val, links)
    }

    if (typeof val === 'object' && !(val instanceof String)) {
      findLinks(val, links)
    }
  }

  return links
}

module.exports = function object (self) {
  function editAndSave (edit) {
    return (multihash, options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      options = options || {}

      waterfall([
        (cb) => {
          self.object.get(multihash, options, cb)
        },
        (node, cb) => {
          // edit applies the edit func passed to
          // editAndSave
          edit(node, (err, node) => {
            if (err) {
              return cb(err)
            }

            self._ipld.put(node, multicodec.DAG_PB, {
              cidVersion: 0,
              hashAlg: multicodec.SHA2_256
            }).then(
              (cid) => {
                if (options.preload !== false) {
                  self._preload(cid)
                }

                cb(null, cid)
              },
              (error) => cb(error)
            )
          })
        }
      ], callback)
    }
  }

  return {
    new: promisify((template, options, callback) => {
      if (typeof template === 'function') {
        callback = template
        template = undefined
        options = {}
      }

      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      options = options || {}

      let data

      if (template) {
        if (template !== 'unixfs-dir') {
          return setImmediate(() => callback(new Error('unknown template')))
        }
        data = (new Unixfs('directory')).marshal()
      } else {
        data = Buffer.alloc(0)
      }

      let node

      try {
        node = DAGNode.create(data)
      } catch (err) {
        return callback(err)
      }

      self._ipld.put(node, multicodec.DAG_PB, {
        cidVersion: 0,
        hashAlg: multicodec.SHA2_256
      }).then(
        (cid) => {
          if (options.preload !== false) {
            self._preload(cid)
          }

          callback(null, cid)
        },
        (error) => callback(error)
      )
    }),
    put: promisify((obj, options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      options = options || {}

      const encoding = options.enc
      let node

      if (Buffer.isBuffer(obj)) {
        if (encoding) {
          parseBuffer(obj, encoding, (err, _node) => {
            if (err) {
              return callback(err)
            }
            node = _node
            next()
          })
        } else {
          try {
            node = DAGNode.create(obj)
          } catch (err) {
            return callback(err)
          }

          next()
        }
      } else if (DAGNode.isDAGNode(obj)) {
        // already a dag node
        node = obj
        next()
      } else if (typeof obj === 'object') {
        try {
          node = DAGNode.create(obj.Data, obj.Links)
        } catch (err) {
          return callback(err)
        }

        next()
      } else {
        return callback(new Error('obj not recognized'))
      }

      function next () {
        self._ipld.put(node, multicodec.DAG_PB, {
          cidVersion: 0,
          hashAlg: multicodec.SHA2_256
        }).then(
          (cid) => {
            if (options.preload !== false) {
              self._preload(cid)
            }

            callback(null, cid)
          },
          (error) => callback(error)
        )
      }
    }),

    get: promisify((multihash, options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      options = options || {}

      let mh, cid

      try {
        mh = normalizeMultihash(multihash, options.enc)
      } catch (err) {
        return setImmediate(() => callback(errCode(err, 'ERR_INVALID_MULTIHASH')))
      }

      try {
        cid = new CID(mh)
      } catch (err) {
        return setImmediate(() => callback(errCode(err, 'ERR_INVALID_CID')))
      }

      if (options.cidVersion === 1) {
        cid = cid.toV1()
      }

      if (options.preload !== false) {
        self._preload(cid)
      }

      self._ipld.get(cid).then(
        (node) => callback(null, node),
        (error) => callback(error)
      )
    }),

    data: promisify((multihash, options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      self.object.get(multihash, options, (err, node) => {
        if (err) {
          return callback(err)
        }

        callback(null, node.Data)
      })
    }),

    links: promisify((multihash, options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      const cid = new CID(multihash)

      self.dag.get(cid, options, (err, result) => {
        if (err) {
          return callback(err)
        }

        if (cid.codec === 'raw') {
          return callback(null, [])
        }

        if (cid.codec === 'dag-pb') {
          return callback(null, result.value.Links)
        }

        if (cid.codec === 'dag-cbor') {
          const links = findLinks(result)

          return callback(null, links)
        }

        callback(new Error(`Cannot resolve links from codec ${cid.codec}`))
      })
    }),

    stat: promisify((multihash, options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      options = options || {}

      waterfall([
        (cb) => self.object.get(multihash, options, cb),
        (node, cb) => {
          cb(null, {
            node,
            serialized: dagPB.util.serialize(node)
          })
        },
        ({ node, serialized }, cb) => {
          parallel({
            serialized: (next) => next(null, serialized),
            cid: (next) => dagPB.util.cid(serialized, {
              cidVersion: 0
            }).then((cid) => next(null, cid), next),
            node: (next) => next(null, node)
          }, cb)
        }
      ], (err, result) => {
        if (err) {
          return callback(err)
        }

        const blockSize = result.serialized.length
        const linkLength = result.node.Links.reduce((a, l) => a + l.Tsize, 0)

        callback(null, {
          Hash: result.cid.toBaseEncodedString(),
          NumLinks: result.node.Links.length,
          BlockSize: blockSize,
          LinksSize: blockSize - result.node.Data.length,
          DataSize: result.node.Data.length,
          CumulativeSize: blockSize + linkLength
        })
      })
    }),

    patch: promisify({
      addLink (multihash, link, options, callback) {
        editAndSave((node, cb) => {
          DAGNode.addLink(node, link).then((node) => {
            cb(null, node)
          }, cb)
        })(multihash, options, callback)
      },

      rmLink (multihash, linkRef, options, callback) {
        editAndSave((node, cb) => {
          linkRef = linkRef.Name || linkRef.name

          try {
            node = DAGNode.rmLink(node, linkRef)
          } catch (err) {
            return cb(err)
          }

          cb(null, node)
        })(multihash, options, callback)
      },

      appendData (multihash, data, options, callback) {
        editAndSave((node, cb) => {
          const newData = Buffer.concat([node.Data, data])

          try {
            node = DAGNode.create(newData, node.Links)
          } catch (err) {
            return cb(err)
          }

          cb(null, node)
        })(multihash, options, callback)
      },

      setData (multihash, data, options, callback) {
        editAndSave((node, cb) => {
          try {
            node = DAGNode.create(data, node.Links)
          } catch (err) {
            return cb(err)
          }

          cb(null, node)
        })(multihash, options, callback)
      }
    })
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/object.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/ping.js", {"promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js","pull-stream/pull":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/ping.js
      return function (require, module, exports) {
'use strict'

const promisify = require('promisify-es6')
const pull = require('pull-stream/pull')

module.exports = function ping (self) {
  return promisify((peerId, opts, callback) => {
    if (typeof opts === 'function') {
      callback = opts
      opts = {}
    }

    pull(
      self.pingPullStream(peerId, opts),
      pull.collect(callback)
    )
  })
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/ping.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/bitswap.js", {"../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/utils.js","async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","bignumber.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/bignumber.js/bignumber.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/bitswap.js
      return function (require, module, exports) {
'use strict'

const OFFLINE_ERROR = require('../utils').OFFLINE_ERROR
const promisify = require('promisify-es6')
const setImmediate = require('async/setImmediate')
const Big = require('bignumber.js')
const CID = require('cids')
const PeerId = require('peer-id')
const errCode = require('err-code')

function formatWantlist (list, cidBase) {
  return Array.from(list).map((e) => ({ '/': e[1].cid.toBaseEncodedString(cidBase) }))
}

module.exports = function bitswap (self) {
  return {
    wantlist: promisify((peerId, callback) => {
      if (typeof peerId === 'function') {
        callback = peerId
        peerId = null
      }

      if (!self.isOnline()) {
        return setImmediate(() => callback(new Error(OFFLINE_ERROR)))
      }

      let list
      if (peerId) {
        try {
          peerId = PeerId.createFromB58String(peerId)
        } catch (e) {
          peerId = null
        }
        if (!peerId) {
          return setImmediate(() => callback(new Error('Invalid peerId')))
        }
        list = self._bitswap.wantlistForPeer(peerId)
      } else {
        list = self._bitswap.getWantlist()
      }

      setImmediate(() => callback(null, { Keys: formatWantlist(list) }))
    }),

    stat: promisify((callback) => {
      if (!self.isOnline()) {
        return setImmediate(() => callback(new Error(OFFLINE_ERROR)))
      }

      const snapshot = self._bitswap.stat().snapshot

      setImmediate(() => {
        callback(null, {
          provideBufLen: parseInt(snapshot.providesBufferLength.toString()),
          blocksReceived: new Big(snapshot.blocksReceived),
          wantlist: formatWantlist(self._bitswap.getWantlist()),
          peers: self._bitswap.peers().map((id) => id.toB58String()),
          dupBlksReceived: new Big(snapshot.dupBlksReceived),
          dupDataReceived: new Big(snapshot.dupDataReceived),
          dataReceived: new Big(snapshot.dataReceived),
          blocksSent: new Big(snapshot.blocksSent),
          dataSent: new Big(snapshot.dataSent)
        })
      })
    }),

    unwant: promisify((keys, callback) => {
      if (!self.isOnline()) {
        return setImmediate(() => callback(new Error(OFFLINE_ERROR)))
      }

      if (!Array.isArray(keys)) {
        keys = [keys]
      }

      try {
        keys = keys.map((key) => {
          if (CID.isCID(key)) {
            return key
          }
          return new CID(key)
        })
      } catch (err) {
        return setImmediate(() => callback(errCode(err, 'ERR_INVALID_CID')))
      }

      setImmediate(() => callback(null, self._bitswap.unwant(keys)))
    })
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/bitswap.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/pubsub.js", {"async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/pubsub.js
      return function (require, module, exports) {
'use strict'

const promisify = require('promisify-es6')
const setImmediate = require('async/setImmediate')
const errCode = require('err-code')

const errPubsubDisabled = () => {
  return errCode(new Error('pubsub experiment is not enabled'), 'ERR_PUBSUB_DISABLED')
}

module.exports = function pubsub (self) {
  return {
    subscribe: (topic, handler, options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      if (!self._options.EXPERIMENTAL.pubsub) {
        return callback
          ? setImmediate(() => callback(errPubsubDisabled()))
          : Promise.reject(errPubsubDisabled())
      }

      if (!callback) {
        return new Promise((resolve, reject) => {
          self.libp2p.pubsub.subscribe(topic, options, handler, (err) => {
            if (err) {
              return reject(err)
            }
            resolve()
          })
        })
      }

      self.libp2p.pubsub.subscribe(topic, options, handler, callback)
    },

    unsubscribe: (topic, handler, callback) => {
      if (!self._options.EXPERIMENTAL.pubsub) {
        return callback
          ? setImmediate(() => callback(errPubsubDisabled()))
          : Promise.reject(errPubsubDisabled())
      }

      self.libp2p.pubsub.unsubscribe(topic, handler)

      if (!callback) {
        return Promise.resolve()
      }

      setImmediate(() => callback())
    },

    publish: promisify((topic, data, callback) => {
      if (!self._options.EXPERIMENTAL.pubsub) {
        return setImmediate(() => callback(errPubsubDisabled()))
      }
      self.libp2p.pubsub.publish(topic, data, callback)
    }),

    ls: promisify((callback) => {
      if (!self._options.EXPERIMENTAL.pubsub) {
        return setImmediate(() => callback(errPubsubDisabled()))
      }
      self.libp2p.pubsub.ls(callback)
    }),

    peers: promisify((topic, callback) => {
      if (!self._options.EXPERIMENTAL.pubsub) {
        return setImmediate(() => callback(errPubsubDisabled()))
      }
      self.libp2p.pubsub.peers(topic, callback)
    }),

    setMaxListeners (n) {
      if (!self._options.EXPERIMENTAL.pubsub) {
        throw errPubsubDisabled()
      }
      self.libp2p.pubsub.setMaxListeners(n)
    }
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/pubsub.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/resolve.js", {"../../utils/cid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/utils/cid.js","async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","is-ipfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-ipfs/src/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/resolve.js
      return function (require, module, exports) {
'use strict'

const promisify = require('promisify-es6')
const isIpfs = require('is-ipfs')
const setImmediate = require('async/setImmediate')
const CID = require('cids')
const { cidToString } = require('../../utils/cid')

module.exports = (self) => {
  return promisify(async (name, opts, cb) => {
    if (typeof opts === 'function') {
      cb = opts
      opts = {}
    }

    opts = opts || {}

    if (!isIpfs.path(name)) {
      return setImmediate(() => cb(new Error('invalid argument ' + name)))
    }

    // TODO remove this and update subsequent code when IPNS is implemented
    if (!isIpfs.ipfsPath(name)) {
      return setImmediate(() => cb(new Error('resolve non-IPFS names is not implemented')))
    }

    const split = name.split('/') // ['', 'ipfs', 'hash', ...path]
    const cid = new CID(split[2])

    if (split.length === 3) {
      return setImmediate(() => cb(null, `/ipfs/${cidToString(cid, { base: opts.cidBase })}`))
    }

    const path = split.slice(3).join('/')

    const results = self._ipld.resolve(cid, path)
    let value = cid
    let remainderPath = path
    try {
      for await (const result of results) {
        if (result.remainderPath === '') {
          // Use values from previous iteration if the value isn't a CID
          if (CID.isCID(result.value)) {
            value = result.value
            remainderPath = ''
          }

          if (result.value && CID.isCID(result.value.Hash)) {
            value = result.value.Hash
            remainderPath = ''
          }

          break
        }

        value = result.value
        remainderPath = result.remainderPath
      }
    } catch (error) {
      return cb(error)
    }
    return cb(null, `/ipfs/${cidToString(value, { base: opts.cidBase })}${remainderPath ? '/' + remainderPath : ''}`)
  })
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/resolve.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/swarm.js", {"../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/utils.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/swarm.js
      return function (require, module, exports) {
'use strict'

const promisify = require('promisify-es6')

const OFFLINE_ERROR = require('../utils').OFFLINE_ERROR

module.exports = function swarm (self) {
  return {
    peers: promisify((opts, callback) => {
      if (typeof opts === 'function') {
        callback = opts
        opts = {}
      }

      opts = opts || {}

      if (!self.isOnline()) {
        return callback(new Error(OFFLINE_ERROR))
      }

      const verbose = opts.v || opts.verbose
      // TODO: return latency and streams when verbose is set
      // we currently don't have this information

      const peers = []

      Object.values(self._peerInfoBook.getAll()).forEach((peer) => {
        const connectedAddr = peer.isConnected()

        if (!connectedAddr) { return }

        const tupple = {
          addr: connectedAddr,
          peer: peer.id
        }
        if (verbose) {
          tupple.latency = 'unknown'
        }

        peers.push(tupple)
      })

      callback(null, peers)
    }),

    // all the addrs we know
    addrs: promisify((callback) => {
      if (!self.isOnline()) {
        return callback(new Error(OFFLINE_ERROR))
      }

      const peers = Object.values(self._peerInfoBook.getAll())

      callback(null, peers)
    }),

    localAddrs: promisify((callback) => {
      if (!self.isOnline()) {
        return callback(new Error(OFFLINE_ERROR))
      }

      callback(null, self.libp2p.peerInfo.multiaddrs.toArray())
    }),

    connect: promisify((maddr, callback) => {
      if (!self.isOnline()) {
        return callback(new Error(OFFLINE_ERROR))
      }

      self.libp2p.dial(maddr, callback)
    }),

    disconnect: promisify((maddr, callback) => {
      if (!self.isOnline()) {
        return callback(new Error(OFFLINE_ERROR))
      }

      self.libp2p.hangUp(maddr, callback)
    }),

    filters: promisify((callback) => callback(new Error('Not implemented')))
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/swarm.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/stats.js", {"./bitswap":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/bitswap.js","./repo":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/repo.js","bignumber.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/bignumber.js/bignumber.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","human-to-milliseconds":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/human-to-milliseconds/src/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js","pull-pushable":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-pushable/index.js","pull-stream-to-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream-to-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/stats.js
      return function (require, module, exports) {
'use strict'

const promisify = require('promisify-es6')
const Big = require('bignumber.js')
const Pushable = require('pull-pushable')
const human = require('human-to-milliseconds')
const toStream = require('pull-stream-to-stream')
const errCode = require('err-code')

function bandwidthStats (self, opts) {
  return new Promise((resolve, reject) => {
    let stats

    if (opts.peer) {
      stats = self.libp2p.stats.forPeer(opts.peer)
    } else if (opts.proto) {
      stats = self.libp2p.stats.forProtocol(opts.proto)
    } else {
      stats = self.libp2p.stats.global
    }

    if (!stats) {
      resolve({
        totalIn: new Big(0),
        totalOut: new Big(0),
        rateIn: new Big(0),
        rateOut: new Big(0)
      })
      return
    }

    resolve({
      totalIn: stats.snapshot.dataReceived,
      totalOut: stats.snapshot.dataSent,
      rateIn: new Big(stats.movingAverages.dataReceived['60000'].movingAverage() / 60),
      rateOut: new Big(stats.movingAverages.dataSent['60000'].movingAverage() / 60)
    })
  })
}

module.exports = function stats (self) {
  const _bwPullStream = (opts) => {
    opts = opts || {}
    let interval = null
    let stream = Pushable(true, () => {
      if (interval) {
        clearInterval(interval)
      }
    })

    if (opts.poll) {
      human(opts.interval || '1s', (err, value) => {
        if (err) {
          return stream.end(errCode(err, 'ERR_INVALID_POLL_INTERVAL'))
        }

        interval = setInterval(() => {
          bandwidthStats(self, opts)
            .then((stats) => stream.push(stats))
            .catch((err) => stream.end(err))
        }, value)
      })
    } else {
      bandwidthStats(self, opts)
        .then((stats) => {
          stream.push(stats)
          stream.end()
        })
        .catch((err) => stream.end(err))
    }

    return stream.source
  }

  return {
    bitswap: require('./bitswap')(self).stat,
    repo: require('./repo')(self).stat,
    bw: promisify((opts, callback) => {
      if (typeof opts === 'function') {
        callback = opts
        opts = {}
      }

      opts = opts || {}

      bandwidthStats(self, opts)
        .then((stats) => callback(null, stats))
        .catch((err) => callback(err))
    }),
    bwReadableStream: (opts) => toStream.source(_bwPullStream(opts)),
    bwPullStream: _bwPullStream
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/stats.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/dht.js", {"../../../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","async/each":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/each.js","async/every":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/every.js","async/nextTick":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/nextTick.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","peer-info":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/dht.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const promisify = require('promisify-es6')
const every = require('async/every')
const PeerId = require('peer-id')
const PeerInfo = require('peer-info')
const CID = require('cids')
const each = require('async/each')
const nextTick = require('async/nextTick')

const errcode = require('err-code')

const debug = require('debug')
const log = debug('ipfs:dht')
log.error = debug('ipfs:dht:error')

module.exports = (self) => {
  return {
    /**
     * Given a key, query the DHT for its best value.
     *
     * @param {Buffer} key
     * @param {Object} options - get options
     * @param {number} options.timeout - optional timeout
     * @param {function(Error)} [callback]
     * @returns {Promise|void}
     */
    get: promisify((key, options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      options = options || {}

      if (!Buffer.isBuffer(key)) {
        try {
          key = (new CID(key)).buffer
        } catch (err) {
          log.error(err)

          return nextTick(() => callback(errcode(err, 'ERR_INVALID_CID')))
        }
      }

      self.libp2p.dht.get(key, options, callback)
    }),

    /**
     * Write a key/value pair to the DHT.
     *
     * Given a key of the form /foo/bar and a value of any
     * form, this will write that value to the DHT with
     * that key.
     *
     * @param {Buffer} key
     * @param {Buffer} value
     * @param {function(Error)} [callback]
     * @returns {Promise|void}
     */
    put: promisify((key, value, callback) => {
      if (!Buffer.isBuffer(key)) {
        try {
          key = (new CID(key)).buffer
        } catch (err) {
          log.error(err)

          return nextTick(() => callback(errcode(err, 'ERR_INVALID_CID')))
        }
      }

      self.libp2p.dht.put(key, value, callback)
    }),

    /**
     * Find peers in the DHT that can provide a specific value, given a key.
     *
     * @param {CID} key - They key to find providers for.
     * @param {Object} options - findProviders options
     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)
     * @param {number} options.maxNumProviders - maximum number of providers to find
     * @param {function(Error, Array<PeerInfo>)} [callback]
     * @returns {Promise<PeerInfo>|void}
     */
    findProvs: promisify((key, options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      options = options || {}

      if (typeof key === 'string') {
        try {
          key = new CID(key)
        } catch (err) {
          log.error(err)

          return nextTick(() => callback(errcode(err, 'ERR_INVALID_CID')))
        }
      }

      self.libp2p.contentRouting.findProviders(key, options, callback)
    }),

    /**
     * Query the DHT for all multiaddresses associated with a `PeerId`.
     *
     * @param {PeerId} peer - The id of the peer to search for.
     * @param {function(Error, PeerInfo)} [callback]
     * @returns {Promise<PeerInfo>|void}
     */
    findPeer: promisify((peer, callback) => {
      if (typeof peer === 'string') {
        peer = PeerId.createFromB58String(peer)
      }

      self.libp2p.peerRouting.findPeer(peer, callback)
    }),

    /**
     * Announce to the network that we are providing given values.
     *
     * @param {CID|Array<CID>} keys - The keys that should be announced.
     * @param {Object} options - provide options
     * @param {bool} [options.recursive=false] - Provide not only the given object but also all objects linked from it.
     * @param {function(Error)} [callback]
     * @returns {Promise|void}
     */
    provide: promisify((keys, options, callback) => {
      if (!Array.isArray(keys)) {
        keys = [keys]
      }
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      options = options || {}

      // ensure blocks are actually local
      every(keys, (key, cb) => {
        self._repo.blocks.has(key, cb)
      }, (err, has) => {
        if (err) {
          return callback(err)
        }

        if (!has) {
          const errMsg = 'block(s) not found locally, cannot provide'

          log.error(errMsg)
          return callback(errcode(errMsg, 'ERR_BLOCK_NOT_FOUND'))
        }

        if (options.recursive) {
          // TODO: Implement recursive providing
          return callback(errcode('not implemented yet', 'ERR_NOT_IMPLEMENTED_YET'))
        } else {
          each(keys, (cid, cb) => {
            self.libp2p.contentRouting.provide(cid, cb)
          }, callback)
        }
      })
    }),

    /**
     * Find the closest peers to a given `PeerId`, by querying the DHT.
     *
     * @param {PeerId} peer - The `PeerId` to run the query agains.
     * @param {function(Error, Array<PeerInfo>)} [callback]
     * @returns {Promise<Array<PeerInfo>>|void}
     */
    query: promisify((peerId, callback) => {
      if (typeof peerId === 'string') {
        try {
          peerId = PeerId.createFromB58String(peerId)
        } catch (err) {
          log.error(err)
          return callback(err)
        }
      }

      // TODO expose this method in peerRouting
      self.libp2p._dht.getClosestPeers(peerId.toBytes(), (err, peerIds) => {
        if (err) {
          log.error(err)
          return callback(err)
        }

        callback(null, peerIds.map((id) => new PeerInfo(id)))
      })
    })
  }
}

}).call(this)}).call(this,{"isBuffer":require("../../../../is-buffer/index.js")})

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/dht.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/dag.js", {"../../../../is-buffer/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js","async-iterator-to-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-pull-stream/index.js","async/map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/map.js","async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","just-flatten-it":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/just-flatten-it/index.js","multicodec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js","pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/dag.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const promisify = require('promisify-es6')
const CID = require('cids')
const pull = require('pull-stream')
const iterToPull = require('async-iterator-to-pull-stream')
const mapAsync = require('async/map')
const setImmediate = require('async/setImmediate')
const flattenDeep = require('just-flatten-it')
const errCode = require('err-code')
const multicodec = require('multicodec')

module.exports = function dag (self) {
  return {
    put: promisify((dagNode, options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      options = options || {}

      if (options.cid && (options.format || options.hashAlg)) {
        return callback(new Error('Can\'t put dag node. Please provide either `cid` OR `format` and `hashAlg` options.'))
      } else if (((options.format && !options.hashAlg) || (!options.format && options.hashAlg))) {
        return callback(new Error('Can\'t put dag node. Please provide `format` AND `hashAlg` options.'))
      }

      const optionDefaults = {
        format: multicodec.DAG_CBOR,
        hashAlg: multicodec.SHA2_256
      }

      // The IPLD expects the format and hashAlg as constants
      if (options.format && typeof options.format === 'string') {
        const constantName = options.format.toUpperCase().replace(/-/g, '_')
        options.format = multicodec[constantName]
      }
      if (options.hashAlg && typeof options.hashAlg === 'string') {
        const constantName = options.hashAlg.toUpperCase().replace(/-/g, '_')
        options.hashAlg = multicodec[constantName]
      }

      options = options.cid ? options : Object.assign({}, optionDefaults, options)

      // js-ipld defaults to verion 1 CIDs. Hence set version 0 explicitly for
      // dag-pb nodes
      if (options.version === undefined) {
        if (options.format === multicodec.DAG_PB && options.hashAlg === multicodec.SHA2_256) {
          options.version = 0
        } else {
          options.version = 1
        }
      }

      self._ipld.put(dagNode, options.format, {
        hashAlg: options.hashAlg,
        cidVersion: options.version
      }).then(
        (cid) => {
          if (options.preload !== false) {
            self._preload(cid)
          }
          return callback(null, cid)
        },
        (error) => callback(error)
      )
    }),

    get: promisify((cid, path, options, callback) => {
      if (typeof path === 'function') {
        callback = path
        path = undefined
      }

      if (typeof options === 'function') {
        callback = options

        // Allow options in path position
        if (typeof path !== 'string') {
          options = path
          path = undefined
        } else {
          options = {}
        }
      }

      options = options || {}

      if (typeof cid === 'string') {
        const split = cid.split('/')

        try {
          cid = new CID(split[0])
        } catch (err) {
          return setImmediate(() => callback(errCode(err, 'ERR_INVALID_CID')))
        }

        split.shift()

        if (split.length > 0) {
          path = split.join('/')
        } else {
          path = '/'
        }
      } else if (Buffer.isBuffer(cid)) {
        try {
          cid = new CID(cid)
        } catch (err) {
          return setImmediate(() => callback(errCode(err, 'ERR_INVALID_CID')))
        }
      }

      if (options.preload !== false) {
        self._preload(cid)
      }

      if (path === undefined || path === '/') {
        self._ipld.get(cid).then(
          (value) => {
            callback(null, {
              value,
              remainderPath: ''
            })
          },
          (error) => callback(error)
        )
      } else {
        const result = self._ipld.resolve(cid, path)
        const promisedValue = options.localResolve ? result.first() : result.last()
        promisedValue.then(
          (value) => callback(null, value),
          (error) => callback(error)
        )
      }
    }),

    tree: promisify((cid, path, options, callback) => {
      if (typeof path === 'object') {
        callback = options
        options = path
        path = undefined
      }

      if (typeof path === 'function') {
        callback = path
        path = undefined
      }

      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      options = options || {}

      if (typeof cid === 'string') {
        const split = cid.split('/')

        try {
          cid = new CID(split[0])
        } catch (err) {
          return setImmediate(() => callback(errCode(err, 'ERR_INVALID_CID')))
        }

        split.shift()

        if (split.length > 0) {
          path = split.join('/')
        } else {
          path = undefined
        }
      }

      if (options.preload !== false) {
        self._preload(cid)
      }

      pull(
        iterToPull(self._ipld.tree(cid, path, options)),
        pull.collect(callback)
      )
    }),

    // TODO - use IPLD selectors once they are implemented
    _getRecursive: promisify((multihash, options, callback) => {
      // gets flat array of all DAGNodes in tree given by multihash

      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      options = options || {}

      let cid

      try {
        cid = new CID(multihash)
      } catch (err) {
        return setImmediate(() => callback(errCode(err, 'ERR_INVALID_CID')))
      }

      self.dag.get(cid, '', options, (err, res) => {
        if (err) { return callback(err) }

        mapAsync(res.value.Links, (link, cb) => {
          self.dag._getRecursive(link.Hash, options, cb)
        }, (err, nodes) => {
          // console.log('nodes:', nodes)
          if (err) return callback(err)
          callback(null, flattenDeep([res.value, nodes]))
        })
      })
    })
  }
}

}).call(this)}).call(this,{"isBuffer":require("../../../../is-buffer/index.js")})

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/dag.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/pin.js", {"../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/utils.js","./pin-set":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/pin-set.js","async/detectLimit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/detectLimit.js","async/eachLimit":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/eachLimit.js","async/map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/map.js","async/mapSeries":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/mapSeries.js","async/parallel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/parallel.js","async/series":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/series.js","async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","interface-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/interface-datastore/src/index.js","ipld-dag-pb":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/index.js","multibase":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/index.js","multicodec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/pin.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/* eslint max-nested-callbacks: ["error", 8] */
'use strict'

const promisify = require('promisify-es6')
const { DAGNode, DAGLink, util } = require('ipld-dag-pb')
const CID = require('cids')
const map = require('async/map')
const mapSeries = require('async/mapSeries')
const series = require('async/series')
const parallel = require('async/parallel')
const eachLimit = require('async/eachLimit')
const waterfall = require('async/waterfall')
const detectLimit = require('async/detectLimit')
const setImmediate = require('async/setImmediate')
const { Key } = require('interface-datastore')
const errCode = require('err-code')
const multibase = require('multibase')
const multicodec = require('multicodec')

const createPinSet = require('./pin-set')
const { resolvePath } = require('../utils')

// arbitrary limit to the number of concurrent dag operations
const concurrencyLimit = 300
const pinDataStoreKey = new Key('/local/pins')

function toB58String (hash) {
  return new CID(hash).toBaseEncodedString()
}

function invalidPinTypeErr (type) {
  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`
  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE')
}

module.exports = (self) => {
  const repo = self._repo
  const dag = self.dag
  const pinset = createPinSet(dag)
  const types = {
    direct: 'direct',
    recursive: 'recursive',
    indirect: 'indirect',
    all: 'all'
  }

  let directPins = new Set()
  let recursivePins = new Set()

  const directKeys = () =>
    Array.from(directPins).map(key => new CID(key).buffer)
  const recursiveKeys = () =>
    Array.from(recursivePins).map(key => new CID(key).buffer)

  function getIndirectKeys (callback) {
    const indirectKeys = new Set()
    eachLimit(recursiveKeys(), concurrencyLimit, (multihash, cb) => {
      dag._getRecursive(multihash, (err, nodes) => {
        if (err) {
          return cb(err)
        }

        map(nodes, (node, cb) => util.cid(util.serialize(node), {
          cidVersion: 0
        }).then(cid => cb(null, cid), cb), (err, cids) => {
          if (err) {
            return cb(err)
          }

          cids
            .map(cid => cid.toString())
            // recursive pins pre-empt indirect pins
            .filter(key => !recursivePins.has(key))
            .forEach(key => indirectKeys.add(key))

          cb()
        })
      })
    }, (err) => {
      if (err) { return callback(err) }
      callback(null, Array.from(indirectKeys))
    })
  }

  // Encode and write pin key sets to the datastore:
  // a DAGLink for each of the recursive and direct pinsets
  // a DAGNode holding those as DAGLinks, a kind of root pin
  function flushPins (callback) {
    let dLink, rLink, root
    series([
      // create a DAGLink to the node with direct pins
      cb => waterfall([
        cb => pinset.storeSet(directKeys(), cb),
        ({ node, cid }, cb) => {
          try {
            cb(null, new DAGLink(types.direct, node.size, cid))
          } catch (err) {
            cb(err)
          }
        },
        (link, cb) => { dLink = link; cb(null) }
      ], cb),

      // create a DAGLink to the node with recursive pins
      cb => waterfall([
        cb => pinset.storeSet(recursiveKeys(), cb),
        ({ node, cid }, cb) => {
          try {
            cb(null, new DAGLink(types.recursive, node.size, cid))
          } catch (err) {
            cb(err)
          }
        },
        (link, cb) => { rLink = link; cb(null) }
      ], cb),

      // the pin-set nodes link to a special 'empty' node, so make sure it exists
      cb => {
        let empty

        try {
          empty = DAGNode.create(Buffer.alloc(0))
        } catch (err) {
          return cb(err)
        }

        dag.put(empty, {
          version: 0,
          format: multicodec.DAG_PB,
          hashAlg: multicodec.SHA2_256,
          preload: false
        }, cb)
      },

      // create a root node with DAGLinks to the direct and recursive DAGs
      cb => {
        let node

        try {
          node = DAGNode.create(Buffer.alloc(0), [dLink, rLink])
        } catch (err) {
          return cb(err)
        }

        root = node
        dag.put(root, {
          version: 0,
          format: multicodec.DAG_PB,
          hashAlg: multicodec.SHA2_256,
          preload: false
        }, (err, cid) => {
          if (!err) {
            root.multihash = cid.buffer
          }
          cb(err)
        })
      },

      // hack for CLI tests
      cb => repo.closed ? repo.open(cb) : cb(null, null),

      // save root to datastore under a consistent key
      cb => repo.datastore.put(pinDataStoreKey, root.multihash, cb)
    ], (err, res) => {
      if (err) { return callback(err) }
      self.log(`Flushed pins with root: ${root}`)
      return callback(null, root)
    })
  }

  const pin = {
    add: promisify((paths, options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      options = options || {}

      const recursive = options.recursive == null ? true : options.recursive

      resolvePath(self.object, paths, (err, mhs) => {
        if (err) { return callback(err) }

        // verify that each hash can be pinned
        map(mhs, (multihash, cb) => {
          const key = toB58String(multihash)
          if (recursive) {
            if (recursivePins.has(key)) {
              // it's already pinned recursively
              return cb(null, key)
            }

            // entire graph of nested links should be pinned,
            // so make sure we have all the objects
            dag._getRecursive(key, { preload: options.preload }, (err) => {
              if (err) { return cb(err) }
              // found all objects, we can add the pin
              return cb(null, key)
            })
          } else {
            if (recursivePins.has(key)) {
              // recursive supersedes direct, can't have both
              return cb(new Error(`${key} already pinned recursively`))
            }
            if (directPins.has(key)) {
              // already directly pinned
              return cb(null, key)
            }

            // make sure we have the object
            dag.get(new CID(multihash), { preload: options.preload }, (err) => {
              if (err) { return cb(err) }
              // found the object, we can add the pin
              return cb(null, key)
            })
          }
        }, (err, results) => {
          if (err) { return callback(err) }

          // update the pin sets in memory
          const pinset = recursive ? recursivePins : directPins
          results.forEach(key => pinset.add(key))

          // persist updated pin sets to datastore
          flushPins((err, root) => {
            if (err) { return callback(err) }
            callback(null, results.map(hash => ({ hash })))
          })
        })
      })
    }),

    rm: promisify((paths, options, callback) => {
      if (typeof options === 'function') {
        callback = options
      }

      options = options || {}

      const recursive = options.recursive == null ? true : options.recursive

      if (options.cidBase && !multibase.names.includes(options.cidBase)) {
        return setImmediate(() => {
          callback(errCode(new Error('invalid multibase'), 'ERR_INVALID_MULTIBASE'))
        })
      }

      resolvePath(self.object, paths, (err, mhs) => {
        if (err) { return callback(err) }

        // verify that each hash can be unpinned
        map(mhs, (multihash, cb) => {
          pin._isPinnedWithType(multihash, types.all, (err, res) => {
            if (err) { return cb(err) }
            const { pinned, reason } = res
            const key = toB58String(multihash)
            if (!pinned) {
              return cb(new Error(`${key} is not pinned`))
            }

            switch (reason) {
              case (types.recursive):
                if (recursive) {
                  return cb(null, key)
                } else {
                  return cb(new Error(`${key} is pinned recursively`))
                }
              case (types.direct):
                return cb(null, key)
              default:
                return cb(new Error(
                  `${key} is pinned indirectly under ${reason}`
                ))
            }
          })
        }, (err, results) => {
          if (err) { return callback(err) }

          // update the pin sets in memory
          results.forEach(key => {
            if (recursive && recursivePins.has(key)) {
              recursivePins.delete(key)
            } else {
              directPins.delete(key)
            }
          })

          // persist updated pin sets to datastore
          flushPins((err, root) => {
            if (err) { return callback(err) }
            self.log(`Removed pins: ${results}`)
            callback(null, results.map(hash => ({ hash })))
          })
        })
      })
    }),

    ls: promisify((paths, options, callback) => {
      let type = types.all
      if (typeof paths === 'function') {
        callback = paths
        options = {}
        paths = null
      }
      if (typeof options === 'function') {
        callback = options
      }
      if (paths && paths.type) {
        options = paths
        paths = null
      }

      options = options || {}

      if (options.type) {
        if (typeof options.type !== 'string') {
          return setImmediate(() => callback(invalidPinTypeErr(options.type)))
        }
        type = options.type.toLowerCase()
      }
      if (!Object.keys(types).includes(type)) {
        return setImmediate(() => callback(invalidPinTypeErr(type)))
      }

      if (paths) {
        // check the pinned state of specific hashes
        waterfall([
          (cb) => resolvePath(self.object, paths, cb),
          (hashes, cb) => mapSeries(hashes, (hash, done) => pin._isPinnedWithType(hash, types.all, done), cb),
          (results, cb) => {
            results = results
              .filter(result => result.pinned)
              .map(({ key, reason }) => {
                switch (reason) {
                  case types.direct:
                  case types.recursive:
                    return {
                      hash: key,
                      type: reason
                    }
                  default:
                    return {
                      hash: key,
                      type: `${types.indirect} through ${reason}`
                    }
                }
              })

            if (!results.length) {
              return cb(new Error(`Path is not pinned`))
            }

            cb(null, results)
          }
        ], callback)
      } else {
        // show all pinned items of type
        let pins = []
        if (type === types.direct || type === types.all) {
          pins = pins.concat(
            Array.from(directPins).map(hash => ({
              type: types.direct,
              hash
            }))
          )
        }
        if (type === types.recursive || type === types.all) {
          pins = pins.concat(
            Array.from(recursivePins).map(hash => ({
              type: types.recursive,
              hash
            }))
          )
        }
        if (type === types.indirect || type === types.all) {
          getIndirectKeys((err, indirects) => {
            if (err) { return callback(err) }
            pins = pins
              // if something is pinned both directly and indirectly,
              // report the indirect entry
              .filter(({ hash }) =>
                !indirects.includes(hash) ||
                (indirects.includes(hash) && !directPins.has(hash))
              )
              .concat(indirects.map(hash => ({
                type: types.indirect,
                hash
              })))
            return callback(null, pins)
          })
        } else {
          callback(null, pins)
        }
      }
    }),

    _isPinnedWithType: promisify((multihash, type, callback) => {
      const key = toB58String(multihash)
      const { recursive, direct, all } = types

      // recursive
      if ((type === recursive || type === all) && recursivePins.has(key)) {
        return callback(null, {
          key,
          pinned: true,
          reason: recursive
        })
      }

      if (type === recursive) {
        return callback(null, {
          key,
          pinned: false
        })
      }

      // direct
      if ((type === direct || type === all) && directPins.has(key)) {
        return callback(null, {
          key,
          pinned: true,
          reason: direct
        })
      }

      if (type === direct) {
        return callback(null, {
          key,
          pinned: false
        })
      }

      // indirect (default)
      // check each recursive key to see if multihash is under it
      // arbitrary limit, enables handling 1000s of pins.
      detectLimit(recursiveKeys().map(key => new CID(key)), concurrencyLimit, (cid, cb) => {
        waterfall([
          (done) => dag.get(cid, '', { preload: false }, done),
          (result, done) => done(null, result.value),
          (node, done) => pinset.hasDescendant(node, key, done)
        ], cb)
      }, (err, cid) => callback(err, {
        key,
        pinned: Boolean(cid),
        reason: cid
      }))
    }),

    _load: promisify(callback => {
      waterfall([
        // hack for CLI tests
        (cb) => repo.closed ? repo.datastore.open(cb) : cb(null, null),
        (_, cb) => repo.datastore.has(pinDataStoreKey, cb),
        (has, cb) => has ? cb() : cb(new Error('No pins to load')),
        (cb) => repo.datastore.get(pinDataStoreKey, cb),
        (mh, cb) => {
          dag.get(new CID(mh), '', { preload: false }, cb)
        }
      ], (err, pinRoot) => {
        if (err) {
          if (err.message === 'No pins to load') {
            self.log('No pins to load')
            return callback()
          } else {
            return callback(err)
          }
        }

        parallel([
          cb => pinset.loadSet(pinRoot.value, types.recursive, cb),
          cb => pinset.loadSet(pinRoot.value, types.direct, cb)
        ], (err, keys) => {
          if (err) { return callback(err) }
          const [ rKeys, dKeys ] = keys

          directPins = new Set(dKeys.map(toB58String))
          recursivePins = new Set(rKeys.map(toB58String))

          self.log('Loaded pins from the datastore')
          return callback(null)
        })
      })
    })
  }

  return pin
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/pin.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/name.js", {"../ipns/path":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/path.js","../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/utils.js","./name-pubsub":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/name-pubsub.js","async/parallel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/parallel.js","async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","err-code":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/err-code/index.js","human-to-milliseconds":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/human-to-milliseconds/src/index.js","libp2p-crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/name.js
      return function (require, module, exports) {
'use strict'

const debug = require('debug')
const promisify = require('promisify-es6')
const waterfall = require('async/waterfall')
const parallel = require('async/parallel')
const human = require('human-to-milliseconds')
const crypto = require('libp2p-crypto')
const errcode = require('err-code')

const log = debug('ipfs:name')
log.error = debug('ipfs:name:error')

const namePubsub = require('./name-pubsub')
const utils = require('../utils')
const path = require('../ipns/path')

const keyLookup = (ipfsNode, kname, callback) => {
  if (kname === 'self') {
    return callback(null, ipfsNode._peerInfo.id.privKey)
  }

  const pass = ipfsNode._options.pass

  waterfall([
    (cb) => ipfsNode._keychain.exportKey(kname, pass, cb),
    (pem, cb) => crypto.keys.__import__(pem, pass, cb)
  ], (err, privateKey) => {
    if (err) {
      log.error(err)
      return callback(errcode(err, 'ERR_CANNOT_GET_KEY'))
    }

    return callback(null, privateKey)
  })
}

module.exports = function name (self) {
  return {
    /**
     * IPNS is a PKI namespace, where names are the hashes of public keys, and
     * the private key enables publishing new (signed) values. In both publish
     * and resolve, the default name used is the node's own PeerID,
     * which is the hash of its public key.
     *
     * @param {String} value ipfs path of the object to be published.
     * @param {Object} options ipfs publish options.
     * @param {boolean} options.resolve resolve given path before publishing.
     * @param {String} options.lifetime time duration that the record will be valid for.
    This accepts durations such as "300s", "1.5h" or "2h45m". Valid time units are
    "ns", "ms", "s", "m", "h". Default is 24h.
     * @param {String} options.ttl time duration this record should be cached for (NOT IMPLEMENTED YET).
     * This accepts durations such as "300s", "1.5h" or "2h45m". Valid time units are
     "ns", "ms", "s", "m", "h" (caution: experimental).
     * @param {String} options.key name of the key to be used, as listed by 'ipfs key list -l'.
     * @param {function(Error)} [callback]
     * @returns {Promise|void}
     */
    publish: promisify((value, options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      options = options || {}
      const resolve = !(options.resolve === false)
      const lifetime = options.lifetime || '24h'
      const key = options.key || 'self'

      if (!self.isOnline()) {
        const errMsg = utils.OFFLINE_ERROR

        log.error(errMsg)
        return callback(errcode(errMsg, 'OFFLINE_ERROR'))
      }

      // TODO: params related logic should be in the core implementation

      // Normalize path value
      try {
        value = utils.normalizePath(value)
      } catch (err) {
        log.error(err)
        return callback(err)
      }

      parallel([
        (cb) => human(lifetime, cb),
        // (cb) => ttl ? human(ttl, cb) : cb(),
        (cb) => keyLookup(self, key, cb),
        // verify if the path exists, if not, an error will stop the execution
        (cb) => resolve.toString() === 'true' ? path.resolvePath(self, value, cb) : cb()
      ], (err, results) => {
        if (err) {
          log.error(err)
          return callback(err)
        }

        // Calculate lifetime with nanoseconds precision
        const pubLifetime = results[0].toFixed(6)
        const privateKey = results[1]

        // TODO IMPROVEMENT - Handle ttl for cache
        // const ttl = results[1]
        // const privateKey = results[2]

        // Start publishing process
        self._ipns.publish(privateKey, value, pubLifetime, callback)
      })
    }),

    /**
     * Given a key, query the DHT for its best value.
     *
     * @param {String} name ipns name to resolve. Defaults to your node's peerID.
     * @param {Object} options ipfs resolve options.
     * @param {boolean} options.nocache do not use cached entries.
     * @param {boolean} options.recursive resolve until the result is not an IPNS name.
     * @param {function(Error)} [callback]
     * @returns {Promise|void}
     */
    resolve: promisify((name, options, callback) => {
      if (typeof options === 'function') {
        callback = options
        options = {}
      }

      options = options || {}
      const nocache = options.nocache && options.nocache.toString() === 'true'
      const recursive = options.recursive && options.recursive.toString() === 'true'

      const offline = self._options.offline

      if (!self.isOnline() && !offline) {
        const errMsg = utils.OFFLINE_ERROR

        log.error(errMsg)
        return callback(errcode(errMsg, 'OFFLINE_ERROR'))
      }

      // TODO: params related logic should be in the core implementation

      if (offline && nocache) {
        const error = 'cannot specify both offline and nocache'

        log.error(error)
        return callback(errcode(new Error(error), 'ERR_NOCACHE_AND_OFFLINE'))
      }

      // Set node id as name for being resolved, if it is not received
      if (!name) {
        name = self._peerInfo.id.toB58String()
      }

      if (!name.startsWith('/ipns/')) {
        name = `/ipns/${name}`
      }

      const resolveOptions = {
        nocache,
        recursive
      }

      self._ipns.resolve(name, resolveOptions, callback)
    }),
    pubsub: namePubsub(self)
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/name.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/pre-start.js", {"./no-keychain":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/no-keychain.js","async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js","libp2p-keychain":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-keychain/src/index.js","merge-options":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/merge-options/index.js","multiaddr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","peer-info":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/pre-start.js
      return function (require, module, exports) {
'use strict'

const peerId = require('peer-id')
const PeerInfo = require('peer-info')
const multiaddr = require('multiaddr')
const waterfall = require('async/waterfall')
const Keychain = require('libp2p-keychain')
const mergeOptions = require('merge-options')
const NoKeychain = require('./no-keychain')
/*
 * Load stuff from Repo into memory
 */
module.exports = function preStart (self) {
  return (callback) => {
    self.log('pre-start')

    const pass = self._options.pass
    waterfall([
      (cb) => self._repo.config.get(cb),
      (config, cb) => {
        if (!self._options.config) {
          return cb(null, config)
        }

        config = mergeOptions(config, self._options.config)

        self.config.replace(config, (err) => {
          if (err) {
            return cb(err)
          }

          cb(null, config)
        })
      },
      (config, cb) => {
        // Create keychain configuration, if needed.
        if (config.Keychain) {
          return cb(null, config)
        }
        config.Keychain = Keychain.generateOptions()
        self.config.set('Keychain', config.Keychain, (err) => {
          self.log('using default keychain options')
          cb(err, config)
        })
      },
      (config, cb) => {
        // Construct the keychain
        if (self._keychain) {
          // most likely an init or upgrade has happened
        } else if (pass) {
          const keychainOptions = Object.assign({ passPhrase: pass }, config.Keychain)
          self._keychain = new Keychain(self._repo.keys, keychainOptions)
          self.log('keychain constructed')
        } else {
          self._keychain = new NoKeychain()
          self.log('no keychain, use --pass')
        }
        cb(null, config)
      },
      (config, cb) => {
        const privKey = config.Identity.PrivKey

        peerId.createFromPrivKey(privKey, (err, id) => {
          cb(err, config, id)
        })
      },
      (config, id, cb) => {
        // Import the private key as 'self', if needed.
        if (!pass) {
          return cb(null, config, id)
        }
        self._keychain.findKeyByName('self', (err) => {
          if (err) {
            self.log('Creating "self" key')
            return self._keychain.importPeer('self', id, (err) => cb(err, config, id))
          }
          cb(null, config, id)
        })
      },
      (config, id, cb) => {
        self.log('peer created')
        self._peerInfo = new PeerInfo(id)

        if (config.Addresses && config.Addresses.Swarm) {
          config.Addresses.Swarm.forEach((addr) => {
            let ma = multiaddr(addr)

            if (ma.getPeerId()) {
              ma = ma.encapsulate('/ipfs/' + self._peerInfo.id.toB58String())
            }

            self._peerInfo.multiaddrs.add(ma)
          })
        }

        cb()
      },
      (cb) => self.pin._load(cb)
    ], callback)
  }
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/pre-start.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/start.js", {"../ipns":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/index.js","../ipns/routing/config":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/routing/config.js","./libp2p":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/libp2p.js","async/series":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/series.js","async/setImmediate":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/setImmediate.js","ipfs-bitswap":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-bitswap/src/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/start.js
      return function (require, module, exports) {
'use strict'

const series = require('async/series')
const Bitswap = require('ipfs-bitswap')
const setImmediate = require('async/setImmediate')
const promisify = require('promisify-es6')

const IPNS = require('../ipns')
const routingConfig = require('../ipns/routing/config')
const createLibp2pBundle = require('./libp2p')

module.exports = (self) => {
  return promisify((callback) => {
    const done = (err) => {
      if (err) {
        setImmediate(() => self.emit('error', err))
        return callback(err)
      }

      self.state.started()
      setImmediate(() => self.emit('start'))
      callback()
    }

    if (self.state.state() !== 'stopped') {
      return done(new Error(`Not able to start from state: ${self.state.state()}`))
    }

    self.log('starting')
    self.state.start()

    series([
      (cb) => {
        // The repo may be closed if previously stopped
        self._repo.closed
          ? self._repo.open(cb)
          : cb()
      },
      (cb) => {
        self._repo.config.get((err, config) => {
          if (err) return cb(err)

          const libp2p = createLibp2pBundle(self, config)

          libp2p.start(err => {
            if (err) return cb(err)
            self.libp2p = libp2p
            cb()
          })
        })
      },
      (cb) => {
        const ipnsRouting = routingConfig(self)
        self._ipns = new IPNS(ipnsRouting, self._repo.datastore, self._peerInfo, self._keychain, self._options)

        self._bitswap = new Bitswap(
          self.libp2p,
          self._repo.blocks,
          { statsEnabled: true }
        )

        self._bitswap.start()
        self._blockService.setExchange(self._bitswap)

        self._preload.start()
        self._ipns.republisher.start()
        self._mfsPreload.start(cb)
      }
    ], done)
  })
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/start.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/init.js", {"../ipns":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/index.js","../ipns/routing/offline-datastore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/routing/offline-datastore.js","../runtime/config-nodejs.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/config-browser.js","./init-assets":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js","async/parallel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/parallel.js","async/waterfall":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async/waterfall.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ipfs-unixfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-unixfs/src/index.js","ipld-dag-pb":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld-dag-pb/src/index.js","libp2p-keychain":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-keychain/src/index.js","merge-options":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/merge-options/index.js","multicodec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","promisify-es6":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/promisify-es6/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/init.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const peerId = require('peer-id')
const mergeOptions = require('merge-options')
const waterfall = require('async/waterfall')
const parallel = require('async/parallel')
const promisify = require('promisify-es6')
const defaultConfig = require('../runtime/config-nodejs.js')
const Keychain = require('libp2p-keychain')
const {
  DAGNode
} = require('ipld-dag-pb')
const UnixFs = require('ipfs-unixfs')
const multicodec = require('multicodec')

const IPNS = require('../ipns')
const OfflineDatastore = require('../ipns/routing/offline-datastore')

const addDefaultAssets = require('./init-assets')

module.exports = function init (self) {
  return promisify((opts, callback) => {
    if (typeof opts === 'function') {
      callback = opts
      opts = {}
    }

    const done = (err, res) => {
      if (err) {
        self.emit('error', err)
        return callback(err)
      }

      self.preStart((err) => {
        if (err) {
          self.emit('error', err)
          return callback(err)
        }

        self.state.initialized()
        self.emit('init')
        callback(null, res)
      })
    }

    if (self.state.state() !== 'uninitialized') {
      return done(new Error('Not able to init from state: ' + self.state.state()))
    }

    self.state.init()
    self.log('init')

    // An initialized, open repo was passed, use this one!
    if (opts.repo) {
      self._repo = opts.repo
      return done(null, true)
    }

    opts.emptyRepo = opts.emptyRepo || false
    opts.bits = Number(opts.bits) || 2048
    opts.log = opts.log || function () {}

    const config = mergeOptions(defaultConfig(), self._options.config)
    let privateKey

    waterfall([
      // Verify repo does not yet exist.
      (cb) => self._repo.exists(cb),
      (exists, cb) => {
        self.log('repo exists?', exists)
        if (exists === true) {
          return cb(new Error('repo already exists'))
        }

        if (opts.privateKey) {
          self.log('using user-supplied private-key')
          if (typeof opts.privateKey === 'object') {
            cb(null, opts.privateKey)
          } else {
            peerId.createFromPrivKey(Buffer.from(opts.privateKey, 'base64'), cb)
          }
        } else {
          // Generate peer identity keypair + transform to desired format + add to config.
          opts.log(`generating ${opts.bits}-bit RSA keypair...`, false)
          self.log('generating peer id: %s bits', opts.bits)
          peerId.create({ bits: opts.bits }, cb)
        }
      },
      (peerId, cb) => {
        self.log('identity generated')
        config.Identity = {
          PeerID: peerId.toB58String(),
          PrivKey: peerId.privKey.bytes.toString('base64')
        }
        privateKey = peerId.privKey
        if (opts.pass) {
          config.Keychain = Keychain.generateOptions()
        }
        opts.log('done')
        opts.log('peer identity: ' + config.Identity.PeerID)

        self._repo.init(config, cb)
      },
      (_, cb) => self._repo.open(cb),
      (cb) => {
        self.log('repo opened')
        if (opts.pass) {
          self.log('creating keychain')
          const keychainOptions = Object.assign({ passPhrase: opts.pass }, config.Keychain)
          self._keychain = new Keychain(self._repo.keys, keychainOptions)
          self._keychain.importPeer('self', { privKey: privateKey }, cb)
        } else {
          cb(null, true)
        }
      },
      // Setup the offline routing for IPNS.
      // This is primarily used for offline ipns modifications, such as the initializeKeyspace feature.
      (_, cb) => {
        const offlineDatastore = new OfflineDatastore(self._repo)

        self._ipns = new IPNS(offlineDatastore, self._repo.datastore, self._peerInfo, self._keychain, self._options)
        cb(null, true)
      },
      // add empty unixfs dir object (go-ipfs assumes this exists)
      (_, cb) => {
        if (opts.emptyRepo) {
          return cb(null, true)
        }

        const tasks = [
          (cb) => {
            waterfall([
              (cb) => {
                try {
                  cb(null, DAGNode.create(new UnixFs('directory').marshal()))
                } catch (err) {
                  cb(err)
                }
              },
              (node, cb) => self.dag.put(node, {
                version: 0,
                format: multicodec.DAG_PB,
                hashAlg: multicodec.SHA2_256
              }).then(
                (cid) => cb(null, cid),
                (error) => cb(error)
              ),
              (cid, cb) => self._ipns.initializeKeyspace(privateKey, cid.toBaseEncodedString(), cb)
            ], cb)
          }
        ]

        if (typeof addDefaultAssets === 'function') {
          // addDefaultAssets is undefined on browsers.
          // See package.json browser config
          tasks.push((cb) => addDefaultAssets(self, opts.log, cb))
        }

        self.log('adding assets')
        parallel(tasks, (err) => {
          if (err) {
            cb(err)
          } else {
            cb(null, true)
          }
        })
      }
    ], done)
  })
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/init.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/libp2p.js", {"../ipns/routing/utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/ipns/routing/utils.js","../runtime/libp2p-nodejs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/libp2p-browser.js","dlv":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/dlv/dist/dlv.umd.js","merge-options":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/merge-options/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/libp2p.js
      return function (require, module, exports) {
'use strict'

const get = require('dlv')
const mergeOptions = require('merge-options')
const ipnsUtils = require('../ipns/routing/utils')

module.exports = function libp2p (self, config) {
  const options = self._options || {}
  config = config || {}

  // Always create libp2p via a bundle function
  const createBundle = typeof options.libp2p === 'function'
    ? options.libp2p
    : defaultBundle

  const { datastore } = self._repo
  const peerInfo = self._peerInfo
  const peerBook = self._peerInfoBook
  const libp2p = createBundle({ options, config, datastore, peerInfo, peerBook })

  libp2p.on('stop', () => {
    // Clear our addresses so we can start clean
    peerInfo.multiaddrs.clear()
  })

  libp2p.on('start', () => {
    peerInfo.multiaddrs.forEach((ma) => {
      self._print('Swarm listening on', ma.toString())
    })
  })

  libp2p.on('peer:connect', peerInfo => peerBook.put(peerInfo))

  return libp2p
}

function defaultBundle ({ datastore, peerInfo, peerBook, options, config }) {
  const libp2pDefaults = {
    datastore,
    peerInfo,
    peerBook,
    config: {
      peerDiscovery: {
        mdns: {
          enabled: get(options, 'config.Discovery.MDNS.Enabled',
            get(config, 'Discovery.MDNS.Enabled', true))
        },
        webRTCStar: {
          enabled: get(options, 'config.Discovery.webRTCStar.Enabled',
            get(config, 'Discovery.webRTCStar.Enabled', true))
        },
        bootstrap: {
          list: get(options, 'config.Bootstrap',
            get(config, 'Bootstrap', []))
        }
      },
      relay: {
        enabled: get(options, 'relay.enabled',
          get(config, 'relay.enabled', true)),
        hop: {
          enabled: get(options, 'relay.hop.enabled',
            get(config, 'relay.hop.enabled', false)),
          active: get(options, 'relay.hop.active',
            get(config, 'relay.hop.active', false))
        }
      },
      dht: {
        kBucketSize: get(options, 'dht.kBucketSize', 20),
        // enabled: !get(options, 'offline', false), // disable if offline, on by default
        enabled: false,
        randomWalk: {
          enabled: false // disabled waiting for https://github.com/libp2p/js-libp2p-kad-dht/issues/86
        },
        validators: {
          ipns: ipnsUtils.validator
        },
        selectors: {
          ipns: ipnsUtils.selector
        }
      },
      EXPERIMENTAL: {
        pubsub: get(options, 'EXPERIMENTAL.pubsub', false)
      }
    },
    connectionManager: get(options, 'connectionManager',
      {
        maxPeers: get(config, 'Swarm.ConnMgr.HighWater'),
        minPeers: get(config, 'Swarm.ConnMgr.LowWater')
      })
  }

  const libp2pOptions = mergeOptions(libp2pDefaults, get(options, 'libp2p', {}))
  // Required inline to reduce startup time
  // Note: libp2p-nodejs gets replaced by libp2p-browser when webpacked/browserified
  const Node = require('../runtime/libp2p-nodejs')
  return new Node(libp2pOptions)
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/libp2p.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/index.js", {"./add":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add.js","./add-from-fs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add-from-fs.js","./add-from-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add-from-stream.js","./add-from-url":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add-from-url.js","./add-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add-pull-stream.js","./add-readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/add-readable-stream.js","./cat":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/cat.js","./cat-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/cat-pull-stream.js","./cat-readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/cat-readable-stream.js","./get":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/get.js","./get-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/get-pull-stream.js","./get-readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/get-readable-stream.js","./ls":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/ls.js","./ls-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/ls-pull-stream.js","./ls-readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/ls-readable-stream.js","./refs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs.js","./refs-local":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs-local.js","./refs-local-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs-local-pull-stream.js","./refs-local-readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs-local-readable-stream.js","./refs-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs-pull-stream.js","./refs-readable-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/refs-readable-stream.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/index.js
      return function (require, module, exports) {
'use strict'

module.exports = (self) => {
  const filesRegular = {
    add: require('./add')(self),
    addFromFs: require('./add-from-fs')(self),
    addFromStream: require('./add-from-stream')(self),
    addFromURL: require('./add-from-url')(self),
    addPullStream: require('./add-pull-stream')(self),
    addReadableStream: require('./add-readable-stream')(self),
    cat: require('./cat')(self),
    catPullStream: require('./cat-pull-stream')(self),
    catReadableStream: require('./cat-readable-stream')(self),
    get: require('./get')(self),
    getPullStream: require('./get-pull-stream')(self),
    getReadableStream: require('./get-readable-stream')(self),
    ls: require('./ls')(self),
    lsPullStream: require('./ls-pull-stream')(self),
    lsReadableStream: require('./ls-readable-stream')(self),
    refs: require('./refs')(self),
    refsReadableStream: require('./refs-readable-stream')(self),
    refsPullStream: require('./refs-pull-stream')(self)
  }
  filesRegular.refs.local = require('./refs-local')(self)
  filesRegular.refs.localReadableStream = require('./refs-local-readable-stream')(self)
  filesRegular.refs.localPullStream = require('./refs-local-pull-stream')(self)
  return filesRegular
}

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-regular/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-mfs.js", {"async-iterator-all":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-all/index.js","async-iterator-to-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-pull-stream/index.js","async-iterator-to-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/async-iterator-to-stream/dist/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","callbackify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/callbackify/index.js","ipfs-mfs/core":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mfs/core.js","is-pull-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-pull-stream/index.js","pull-stream-to-async-iterator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream-to-async-iterator/index.js","pull-stream/pull":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/pull.js","pull-stream/throughs/map":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pull-stream/throughs/map.js","stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/readable-stream/readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-mfs.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const mfs = require('ipfs-mfs/core')
const isPullStream = require('is-pull-stream')
const toPullStream = require('async-iterator-to-pull-stream')
const toReadableStream = require('async-iterator-to-stream')
const pullStreamToAsyncIterator = require('pull-stream-to-async-iterator')
const all = require('async-iterator-all')
const callbackify = require('callbackify')
const PassThrough = require('stream').PassThrough
const pull = require('pull-stream/pull')
const map = require('pull-stream/throughs/map')

const mapLsFile = (options = {}) => {
  const long = options.long || options.l

  return (file) => {
    return {
      hash: long ? file.cid.toBaseEncodedString(options.cidBase) : '',
      name: file.name,
      type: long ? file.type : 0,
      size: long ? file.size || 0 : 0
    }
  }
}

module.exports = self => {
  const methods = mfs({
    ipld: self._ipld,
    blocks: self._blockService,
    datastore: self._repo.root,
    repoOwner: self._options.repoOwner
  })

  return {
    cp: callbackify.variadic(methods.cp),
    flush: callbackify.variadic(methods.flush),
    ls: callbackify.variadic(async (path, options = {}) => {
      const files = await all(methods.ls(path, options))

      return files.map(mapLsFile(options))
    }),
    lsReadableStream: (path, options = {}) => {
      const stream = toReadableStream.obj(methods.ls(path, options))
      const through = new PassThrough({
        objectMode: true
      })
      stream.on('data', (file) => {
        through.write(mapLsFile(options)(file))
      })
      stream.on('error', (err) => {
        through.destroy(err)
      })
      stream.on('end', (file, enc, cb) => {
        if (file) {
          file = mapLsFile(options)(file)
        }

        through.end(file, enc, cb)
      })

      return through
    },
    lsPullStream: (path, options = {}) => {
      return pull(
        toPullStream.source(methods.ls(path, options)),
        map(mapLsFile(options))
      )
    },
    mkdir: callbackify.variadic(methods.mkdir),
    mv: callbackify.variadic(methods.mv),
    read: callbackify(async (path, options = {}) => {
      return Buffer.concat(await all(methods.read(path, options)))
    }),
    readPullStream: (path, options = {}) => {
      return toPullStream.source(methods.read(path, options))
    },
    readReadableStream: (path, options = {}) => {
      return toReadableStream(methods.read(path, options))
    },
    rm: callbackify.variadic(methods.rm),
    stat: callbackify(async (path, options = {}) => {
      const stats = await methods.stat(path, options)

      stats.hash = stats.cid.toBaseEncodedString(options && options.cidBase)
      delete stats.cid

      return stats
    }),
    write: callbackify.variadic(async (path, content, options = {}) => {
      if (isPullStream.isSource(content)) {
        content = pullStreamToAsyncIterator(content)
      }

      await methods.write(path, content, options)
    })
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/files-mfs.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/restricted/confirm.js", {"eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/restricted/confirm.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.confirmBuilder = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const methodName = 'snap_confirm';
/**
 * `snap_confirm` lets the Snap display a confirmation dialog to the user.
 */
const specificationBuilder = ({ allowedCaveats = null, methodHooks, }) => {
    return {
        targetKey: methodName,
        allowedCaveats,
        methodImplementation: getConfirmImplementation(methodHooks),
    };
};
exports.confirmBuilder = Object.freeze({
    targetKey: methodName,
    specificationBuilder,
    methodHooks: {
        showConfirmation: true,
    },
});
function getConfirmImplementation({ showConfirmation }) {
    return async function confirmImplementation(args) {
        const { params = [] } = args;
        const [prompt, title, subtitle] = params;
        if (!prompt || typeof prompt !== 'string') {
            throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
                message: 'Must specify a non-empty string prompt.',
            });
        }
        try {
            return await showConfirmation(prompt, title || '', subtitle || '');
        }
        catch (error) {
            return null;
        }
    };
}
//# sourceMappingURL=confirm.js.map
      };
    };
  }
}, {package:"@metamask/rpc-methods",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/restricted/confirm.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/restricted/invokeSnap.js", {"../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/utils.js","@metamask/snap-controllers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/index.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/restricted/invokeSnap.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.invokeSnapBuilder = void 0;
const snap_controllers_1 = require("@metamask/snap-controllers");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const utils_1 = require("../utils");
const methodPrefix = snap_controllers_1.SNAP_PREFIX;
const targetKey = `${methodPrefix}*`;
/**
 * `wallet_snap_*` attempts to invoke an RPC method of the specified Snap.
 * Requesting its corresponding permission will attempt to connect to the Snap,
 * and install it if it's not avaialble yet.
 */
const specificationBuilder = ({ allowedCaveats = null, methodHooks, }) => {
    return {
        targetKey,
        allowedCaveats,
        methodImplementation: getInvokeSnapImplementation(methodHooks),
    };
};
exports.invokeSnapBuilder = Object.freeze({
    targetKey,
    specificationBuilder,
    methodHooks: {
        getSnap: true,
        addSnap: true,
        getSnapRpcHandler: true,
    },
});
function getInvokeSnapImplementation({ getSnap, addSnap, getSnapRpcHandler, }) {
    return async function invokeSnap(options) {
        const { params = [], method, context } = options;
        const snapRpcRequest = params[0];
        if (!utils_1.isPlainObject(snapRpcRequest)) {
            throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
                message: 'Must specify snap RPC request object as single parameter.',
            });
        }
        const snapOriginString = method.substr(snap_controllers_1.SNAP_PREFIX.length);
        if (!getSnap(snapOriginString)) {
            await addSnap({
                name: snapOriginString,
                manifestUrl: snapOriginString,
            });
        }
        const handler = await getSnapRpcHandler(snapOriginString);
        if (!handler) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound({
                message: `Snap RPC message handler not found for snap "${snapOriginString}".`,
            });
        }
        const fromSubject = context.origin;
        // Handler is an async function that takes an snapOriginString string and a request object.
        // It should return the result it would like returned to the fromDomain as part of response.result
        return (await handler(fromSubject, snapRpcRequest));
    };
}
//# sourceMappingURL=invokeSnap.js.map
      };
    };
  }
}, {package:"@metamask/rpc-methods",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/restricted/invokeSnap.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/restricted/manageState.js", {"../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/utils.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/restricted/manageState.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManageStateOperation = exports.manageStateBuilder = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const utils_1 = require("../utils");
const methodName = 'snap_manageState';
/**
 * `snap_manageState` let's the Snap store and manage some of its state on
 * your device.
 */
const specificationBuilder = ({ allowedCaveats = null, methodHooks, }) => {
    return {
        targetKey: methodName,
        allowedCaveats,
        methodImplementation: getManageStateImplementation(methodHooks),
    };
};
exports.manageStateBuilder = Object.freeze({
    targetKey: methodName,
    specificationBuilder,
    methodHooks: {
        clearSnapState: true,
        getSnapState: true,
        updateSnapState: true,
    },
});
var ManageStateOperation;
(function (ManageStateOperation) {
    ManageStateOperation["clearState"] = "clear";
    ManageStateOperation["getState"] = "get";
    ManageStateOperation["updateState"] = "update";
})(ManageStateOperation = exports.ManageStateOperation || (exports.ManageStateOperation = {}));
function getManageStateImplementation({ clearSnapState, getSnapState, updateSnapState, }) {
    return async function manageState(options) {
        const { params = [], method } = options;
        const [operation, newState] = params;
        switch (operation) {
            case ManageStateOperation.clearState:
                await clearSnapState();
                return null;
            case ManageStateOperation.getState:
                return await getSnapState();
            case ManageStateOperation.updateState:
                if (!utils_1.isPlainObject(newState)) {
                    throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
                        message: `Invalid ${method} "updateState" parameter: The new state must be a plain object.`,
                        data: {
                            receivedNewState: typeof newState === 'undefined' ? 'undefined' : newState,
                        },
                    });
                }
                await updateSnapState(newState);
                return null;
            default:
                throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid ${method} operation: "${operation}"`);
        }
    };
}
//# sourceMappingURL=manageState.js.map
      };
    };
  }
}, {package:"@metamask/rpc-methods",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/restricted/manageState.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/restricted/getBip44Entropy.js", {"@metamask/key-tree":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/key-tree/dist/index.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/restricted/getBip44Entropy.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBip44EntropyBuilder = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const key_tree_1 = require("@metamask/key-tree");
const methodPrefix = 'snap_getBip44Entropy_';
const targetKey = `${methodPrefix}*`;
/**
 * `snap_getBip44Entropy_*` lets the Snap control private keys for a particular
 * BIP-32 coin type.
 */
const specificationBuilder = ({ allowedCaveats = null, methodHooks, }) => {
    return {
        targetKey,
        allowedCaveats,
        methodImplementation: getBip44EntropyImplementation(methodHooks),
    };
};
exports.getBip44EntropyBuilder = Object.freeze({
    targetKey,
    specificationBuilder,
    methodHooks: {
        getMnemonic: true,
    },
});
const ALL_DIGIT_REGEX = /^\d+$/u;
function getBip44EntropyImplementation({ getMnemonic, }) {
    return async function getBip44Entropy(args) {
        const bip44Code = args.method.substr(methodPrefix.length);
        if (!ALL_DIGIT_REGEX.test(bip44Code)) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound({
                message: `Invalid BIP-44 code: ${bip44Code}`,
            });
        }
        return new key_tree_1.BIP44CoinTypeNode([
            `bip39:${await getMnemonic()}`,
            `bip32:44'`,
            `bip32:${Number(bip44Code)}'`,
        ]).toJSON();
    };
}
//# sourceMappingURL=getBip44Entropy.js.map
      };
    };
  }
}, {package:"@metamask/rpc-methods",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/restricted/getBip44Entropy.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/getSnaps.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/getSnaps.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSnapsHandler = void 0;
/**
 * `wallet_getSnaps` gets the requester's permitted and installed Snaps.
 */
exports.getSnapsHandler = {
    methodNames: ['wallet_getSnaps'],
    implementation: getSnapsImplementation,
    hookNames: {
        getSnaps: true,
    },
};
async function getSnapsImplementation(_req, res, _next, end, { getSnaps }) {
    // getSnaps is already bound to the origin
    res.result = getSnaps();
    return end();
}
//# sourceMappingURL=getSnaps.js.map
      };
    };
  }
}, {package:"@metamask/rpc-methods",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/getSnaps.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/getAppKey.js", {"eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/getAppKey.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAppKeyHandler = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
/**
 * `snap_getAppKey` gets the Snap's app key.
 */
exports.getAppKeyHandler = {
    methodNames: ['snap_getAppKey'],
    implementation: getAppKeyImplementation,
    hookNames: {
        getAppKey: true,
    },
};
async function getAppKeyImplementation(req, res, _next, end, { getAppKey }) {
    const [requestedAccount] = (req === null || req === void 0 ? void 0 : req.params) || [];
    if (requestedAccount !== undefined &&
        (!requestedAccount || typeof requestedAccount !== 'string')) {
        return end(eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: 'Must omit params completely or specify a single hexadecimal string Ethereum account.',
        }));
    }
    try {
        res.result = await getAppKey(requestedAccount);
        return end();
    }
    catch (error) {
        return end(error);
    }
}
//# sourceMappingURL=getAppKey.js.map
      };
    };
  }
}, {package:"@metamask/rpc-methods",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/getAppKey.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/installSnaps.js", {"./common/snapInstallation":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/common/snapInstallation.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/installSnaps.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.installSnapsHandler = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const snapInstallation_1 = require("./common/snapInstallation");
/**
 * `wallet_installSnaps` installs the requested Snaps, if they are permitted.
 */
exports.installSnapsHandler = {
    methodNames: ['wallet_installSnaps'],
    implementation: installSnapsImplementation,
    hookNames: {
        installSnaps: true,
    },
};
async function installSnapsImplementation(req, res, _next, end, { installSnaps }) {
    if (!Array.isArray(req.params)) {
        return end(eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: '"params" must be an array.',
        }));
    }
    try {
        res.result = await snapInstallation_1.handleInstallSnaps(req.params[0], installSnaps);
    }
    catch (err) {
        res.error = err;
    }
    return end();
}
//# sourceMappingURL=installSnaps.js.map
      };
    };
  }
}, {package:"@metamask/rpc-methods",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/installSnaps.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/invokeSnapSugar.js", {"../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/utils.js","@metamask/snap-controllers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/index.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/invokeSnapSugar.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.invokeSnapSugarHandler = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const snap_controllers_1 = require("@metamask/snap-controllers");
const utils_1 = require("../utils");
/**
 * `wallet_invokeSnap` attempts to invoke an RPC method of the specified Snap.
 */
exports.invokeSnapSugarHandler = {
    methodNames: ['wallet_invokeSnap'],
    implementation: invokeSnapSugar,
    hookNames: undefined,
};
async function invokeSnapSugar(req, _res, next, end) {
    if (!Array.isArray(req.params) ||
        typeof req.params[0] !== 'string' ||
        !utils_1.isPlainObject(req.params[1])) {
        return end(eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: 'Must specify a string snap ID and a plain request object.',
        }));
    }
    req.method = snap_controllers_1.SNAP_PREFIX + req.params[0];
    req.params = [req.params[1]];
    return next();
}
//# sourceMappingURL=invokeSnapSugar.js.map
      };
    };
  }
}, {package:"@metamask/rpc-methods",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/invokeSnapSugar.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/enable.js", {"./common/snapInstallation":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/common/snapInstallation.js","@metamask/snap-controllers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/node_modules/@metamask/snap-controllers/dist/index.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/enable.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enableWalletHandler = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const snap_controllers_1 = require("@metamask/snap-controllers");
const snapInstallation_1 = require("./common/snapInstallation");
/**
 * `wallet_enable` is a convenience method that takes a request permissions
 * object as its single parameter, and then calls `wallet_requestPermissions`,
 * `wallet_installSnaps`, and `eth_accounts` as appropriate based on the
 * requested permissions. The method returns a single object result with
 * separate properties for the return values of each method, and any errors
 * that occurred:
 *
 * `{ accounts, permissions, snaps, errors? }`
 */
exports.enableWalletHandler = {
    methodNames: ['wallet_enable'],
    implementation: enableWallet,
    hookNames: {
        getAccounts: true,
        installSnaps: true,
        requestPermissions: true,
    },
};
async function enableWallet(req, res, _next, end, { getAccounts, installSnaps, requestPermissions }) {
    if (!Array.isArray(req.params)) {
        return end(eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: '"params" must be an array.',
        }));
    }
    const result = {
        accounts: [],
        permissions: [],
        snaps: {},
    };
    // request the permissions
    let requestedPermissions;
    try {
        // we expect the params to be the same as wallet_requestPermissions
        requestedPermissions = snapInstallation_1.preprocessRequestedPermissions(req.params[0]);
        result.permissions = await requestPermissions(requestedPermissions);
        if (!result.permissions || !result.permissions.length) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest({ data: req });
        }
    }
    catch (err) {
        return end(err);
    }
    // install snaps, if any
    // get the names of the approved snaps
    const requestedSnaps = result.permissions
        // requestPermissions returns all permissions for the domain,
        // so we're filtering out non-snap and preexisting permissions
        .filter((perm) => perm.parentCapability.startsWith(snap_controllers_1.SNAP_PREFIX) &&
        perm.parentCapability in requestedPermissions)
        // convert from namespaced permissions to snap names
        .reduce((_requestedSnaps, perm) => {
        const snapId = perm.parentCapability.replace(snap_controllers_1.SNAP_PREFIX_REGEX, '');
        _requestedSnaps[snapId] = requestedPermissions[perm.parentCapability];
        return _requestedSnaps;
    }, {});
    try {
        if (Object.keys(requestedSnaps).length > 0) {
            // this throws if requestedSnaps is empty
            result.snaps = await snapInstallation_1.handleInstallSnaps(requestedSnaps, installSnaps);
        }
    }
    catch (err) {
        if (!result.errors) {
            result.errors = [];
        }
        result.errors.push(eth_rpc_errors_1.serializeError(err));
    }
    // get whatever accounts we have
    result.accounts = await getAccounts();
    // return the result
    res.result = result;
    return end();
}
//# sourceMappingURL=enable.js.map
      };
    };
  }
}, {package:"@metamask/rpc-methods",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/enable.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/src/maps.js", {"./generated-table":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/src/generated-table.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/src/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/src/maps.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').ConstantCodeMap} ConstantCodeMap */
/** @typedef {__import__('./generated-types').NameUint8ArrayMap} NameUint8ArrayMap */
/** @typedef {__import__('./generated-types').CodeNameMap} CodeNameMap */
/** @typedef {__import__('./generated-types').CodecName} CodecName */
/** @typedef {__import__('./generated-types').CodecConstant} CodecConstant */

const { baseTable } = require('./generated-table')
const varintEncode = require('./util').varintEncode

const nameToVarint = /** @type {NameUint8ArrayMap} */ ({})
const constantToCode = /** @type {ConstantCodeMap} */({})
const codeToName = /** @type {CodeNameMap} */({})

// eslint-disable-next-line guard-for-in
for (const name in baseTable) {
  const codecName = /** @type {CodecName} */(name)
  const code = baseTable[codecName]
  nameToVarint[codecName] = varintEncode(code)

  const constant = /** @type {CodecConstant} */(codecName.toUpperCase().replace(/-/g, '_'))
  constantToCode[constant] = code

  if (!codeToName[code]) {
    codeToName[code] = codecName
  }
}

Object.freeze(nameToVarint)
Object.freeze(constantToCode)
Object.freeze(codeToName)
const nameToCode = Object.freeze(baseTable)
module.exports = {
  nameToVarint,
  constantToCode,
  nameToCode,
  codeToName
}

      };
    };
  }
}, {package:"multicodec",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/src/maps.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/node_modules/varint/index.js", {"./decode.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/node_modules/varint/decode.js","./encode.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/node_modules/varint/encode.js","./length.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/node_modules/varint/length.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/node_modules/varint/index.js
      return function (require, module, exports) {
module.exports = {
    encode: require('./encode.js')
  , decode: require('./decode.js')
  , encodingLength: require('./length.js')
}

      };
    };
  }
}, {package:"varint",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/node_modules/varint/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/src/util.js", {"uint8arrays/from-string":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/from-string.js","uint8arrays/to-string":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/to-string.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/src/util.js
      return function (require, module, exports) {
'use strict'

const varint = require('varint')
const uint8ArrayToString = require('uint8arrays/to-string')
const uint8ArrayFromString = require('uint8arrays/from-string')

module.exports = {
  numberToUint8Array,
  uint8ArrayToNumber,
  varintUint8ArrayEncode,
  varintEncode
}

/**
 * @param {Uint8Array} buf
 */
function uint8ArrayToNumber (buf) {
  return parseInt(uint8ArrayToString(buf, 'base16'), 16)
}

/**
 * @param {number} num
 */
function numberToUint8Array (num) {
  let hexString = num.toString(16)
  if (hexString.length % 2 === 1) {
    hexString = '0' + hexString
  }
  return uint8ArrayFromString(hexString, 'base16')
}

/**
 * @param {Uint8Array} input
 */
function varintUint8ArrayEncode (input) {
  return Uint8Array.from(varint.encode(uint8ArrayToNumber(input)))
}

/**
 * @param {number} num
 */
function varintEncode (num) {
  return Uint8Array.from(varint.encode(num))
}

      };
    };
  }
}, {package:"multicodec",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/src/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multihashes/src/constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multihashes/src/constants.js
      return function (require, module, exports) {
/* eslint quote-props: off */
'use strict'

/**
 * Names for all available hashes
 *
 * @typedef { "identity" | "sha1" | "sha2-256" | "sha2-512" | "sha3-512" | "sha3-384" | "sha3-256" | "sha3-224" | "shake-128" | "shake-256" | "keccak-224" | "keccak-256" | "keccak-384" | "keccak-512" | "blake3" | "murmur3-128" | "murmur3-32" | "dbl-sha2-256" | "md4" | "md5" | "bmt" | "sha2-256-trunc254-padded" | "ripemd-128" | "ripemd-160" | "ripemd-256" | "ripemd-320" | "x11" | "kangarootwelve" | "sm3-256" | "blake2b-8" | "blake2b-16" | "blake2b-24" | "blake2b-32" | "blake2b-40" | "blake2b-48" | "blake2b-56" | "blake2b-64" | "blake2b-72" | "blake2b-80" | "blake2b-88" | "blake2b-96" | "blake2b-104" | "blake2b-112" | "blake2b-120" | "blake2b-128" | "blake2b-136" | "blake2b-144" | "blake2b-152" | "blake2b-160" | "blake2b-168" | "blake2b-176" | "blake2b-184" | "blake2b-192" | "blake2b-200" | "blake2b-208" | "blake2b-216" | "blake2b-224" | "blake2b-232" | "blake2b-240" | "blake2b-248" | "blake2b-256" | "blake2b-264" | "blake2b-272" | "blake2b-280" | "blake2b-288" | "blake2b-296" | "blake2b-304" | "blake2b-312" | "blake2b-320" | "blake2b-328" | "blake2b-336" | "blake2b-344" | "blake2b-352" | "blake2b-360" | "blake2b-368" | "blake2b-376" | "blake2b-384" | "blake2b-392" | "blake2b-400" | "blake2b-408" | "blake2b-416" | "blake2b-424" | "blake2b-432" | "blake2b-440" | "blake2b-448" | "blake2b-456" | "blake2b-464" | "blake2b-472" | "blake2b-480" | "blake2b-488" | "blake2b-496" | "blake2b-504" | "blake2b-512" | "blake2s-8" | "blake2s-16" | "blake2s-24" | "blake2s-32" | "blake2s-40" | "blake2s-48" | "blake2s-56" | "blake2s-64" | "blake2s-72" | "blake2s-80" | "blake2s-88" | "blake2s-96" | "blake2s-104" | "blake2s-112" | "blake2s-120" | "blake2s-128" | "blake2s-136" | "blake2s-144" | "blake2s-152" | "blake2s-160" | "blake2s-168" | "blake2s-176" | "blake2s-184" | "blake2s-192" | "blake2s-200" | "blake2s-208" | "blake2s-216" | "blake2s-224" | "blake2s-232" | "blake2s-240" | "blake2s-248" | "blake2s-256" | "skein256-8" | "skein256-16" | "skein256-24" | "skein256-32" | "skein256-40" | "skein256-48" | "skein256-56" | "skein256-64" | "skein256-72" | "skein256-80" | "skein256-88" | "skein256-96" | "skein256-104" | "skein256-112" | "skein256-120" | "skein256-128" | "skein256-136" | "skein256-144" | "skein256-152" | "skein256-160" | "skein256-168" | "skein256-176" | "skein256-184" | "skein256-192" | "skein256-200" | "skein256-208" | "skein256-216" | "skein256-224" | "skein256-232" | "skein256-240" | "skein256-248" | "skein256-256" | "skein512-8" | "skein512-16" | "skein512-24" | "skein512-32" | "skein512-40" | "skein512-48" | "skein512-56" | "skein512-64" | "skein512-72" | "skein512-80" | "skein512-88" | "skein512-96" | "skein512-104" | "skein512-112" | "skein512-120" | "skein512-128" | "skein512-136" | "skein512-144" | "skein512-152" | "skein512-160" | "skein512-168" | "skein512-176" | "skein512-184" | "skein512-192" | "skein512-200" | "skein512-208" | "skein512-216" | "skein512-224" | "skein512-232" | "skein512-240" | "skein512-248" | "skein512-256" | "skein512-264" | "skein512-272" | "skein512-280" | "skein512-288" | "skein512-296" | "skein512-304" | "skein512-312" | "skein512-320" | "skein512-328" | "skein512-336" | "skein512-344" | "skein512-352" | "skein512-360" | "skein512-368" | "skein512-376" | "skein512-384" | "skein512-392" | "skein512-400" | "skein512-408" | "skein512-416" | "skein512-424" | "skein512-432" | "skein512-440" | "skein512-448" | "skein512-456" | "skein512-464" | "skein512-472" | "skein512-480" | "skein512-488" | "skein512-496" | "skein512-504" | "skein512-512" | "skein1024-8" | "skein1024-16" | "skein1024-24" | "skein1024-32" | "skein1024-40" | "skein1024-48" | "skein1024-56" | "skein1024-64" | "skein1024-72" | "skein1024-80" | "skein1024-88" | "skein1024-96" | "skein1024-104" | "skein1024-112" | "skein1024-120" | "skein1024-128" | "skein1024-136" | "skein1024-144" | "skein1024-152" | "skein1024-160" | "skein1024-168" | "skein1024-176" | "skein1024-184" | "skein1024-192" | "skein1024-200" | "skein1024-208" | "skein1024-216" | "skein1024-224" | "skein1024-232" | "skein1024-240" | "skein1024-248" | "skein1024-256" | "skein1024-264" | "skein1024-272" | "skein1024-280" | "skein1024-288" | "skein1024-296" | "skein1024-304" | "skein1024-312" | "skein1024-320" | "skein1024-328" | "skein1024-336" | "skein1024-344" | "skein1024-352" | "skein1024-360" | "skein1024-368" | "skein1024-376" | "skein1024-384" | "skein1024-392" | "skein1024-400" | "skein1024-408" | "skein1024-416" | "skein1024-424" | "skein1024-432" | "skein1024-440" | "skein1024-448" | "skein1024-456" | "skein1024-464" | "skein1024-472" | "skein1024-480" | "skein1024-488" | "skein1024-496" | "skein1024-504" | "skein1024-512" | "skein1024-520" | "skein1024-528" | "skein1024-536" | "skein1024-544" | "skein1024-552" | "skein1024-560" | "skein1024-568" | "skein1024-576" | "skein1024-584" | "skein1024-592" | "skein1024-600" | "skein1024-608" | "skein1024-616" | "skein1024-624" | "skein1024-632" | "skein1024-640" | "skein1024-648" | "skein1024-656" | "skein1024-664" | "skein1024-672" | "skein1024-680" | "skein1024-688" | "skein1024-696" | "skein1024-704" | "skein1024-712" | "skein1024-720" | "skein1024-728" | "skein1024-736" | "skein1024-744" | "skein1024-752" | "skein1024-760" | "skein1024-768" | "skein1024-776" | "skein1024-784" | "skein1024-792" | "skein1024-800" | "skein1024-808" | "skein1024-816" | "skein1024-824" | "skein1024-832" | "skein1024-840" | "skein1024-848" | "skein1024-856" | "skein1024-864" | "skein1024-872" | "skein1024-880" | "skein1024-888" | "skein1024-896" | "skein1024-904" | "skein1024-912" | "skein1024-920" | "skein1024-928" | "skein1024-936" | "skein1024-944" | "skein1024-952" | "skein1024-960" | "skein1024-968" | "skein1024-976" | "skein1024-984" | "skein1024-992" | "skein1024-1000" | "skein1024-1008" | "skein1024-1016" | "skein1024-1024" | "poseidon-bls12_381-a2-fc1" | "poseidon-bls12_381-a2-fc1-sc" } HashName
 */
/**
 * Codes for all available hashes
 *
 * @typedef { 0x00 | 0x11 | 0x12 | 0x13 | 0x14 | 0x15 | 0x16 | 0x17 | 0x18 | 0x19 | 0x1a | 0x1b | 0x1c | 0x1d | 0x1e | 0x22 | 0x23 | 0x56 | 0xd4 | 0xd5 | 0xd6 | 0x1012 | 0x1052 | 0x1053 | 0x1054 | 0x1055 | 0x1100 | 0x1d01 | 0x534d | 0xb201 | 0xb202 | 0xb203 | 0xb204 | 0xb205 | 0xb206 | 0xb207 | 0xb208 | 0xb209 | 0xb20a | 0xb20b | 0xb20c | 0xb20d | 0xb20e | 0xb20f | 0xb210 | 0xb211 | 0xb212 | 0xb213 | 0xb214 | 0xb215 | 0xb216 | 0xb217 | 0xb218 | 0xb219 | 0xb21a | 0xb21b | 0xb21c | 0xb21d | 0xb21e | 0xb21f | 0xb220 | 0xb221 | 0xb222 | 0xb223 | 0xb224 | 0xb225 | 0xb226 | 0xb227 | 0xb228 | 0xb229 | 0xb22a | 0xb22b | 0xb22c | 0xb22d | 0xb22e | 0xb22f | 0xb230 | 0xb231 | 0xb232 | 0xb233 | 0xb234 | 0xb235 | 0xb236 | 0xb237 | 0xb238 | 0xb239 | 0xb23a | 0xb23b | 0xb23c | 0xb23d | 0xb23e | 0xb23f | 0xb240 | 0xb241 | 0xb242 | 0xb243 | 0xb244 | 0xb245 | 0xb246 | 0xb247 | 0xb248 | 0xb249 | 0xb24a | 0xb24b | 0xb24c | 0xb24d | 0xb24e | 0xb24f | 0xb250 | 0xb251 | 0xb252 | 0xb253 | 0xb254 | 0xb255 | 0xb256 | 0xb257 | 0xb258 | 0xb259 | 0xb25a | 0xb25b | 0xb25c | 0xb25d | 0xb25e | 0xb25f | 0xb260 | 0xb301 | 0xb302 | 0xb303 | 0xb304 | 0xb305 | 0xb306 | 0xb307 | 0xb308 | 0xb309 | 0xb30a | 0xb30b | 0xb30c | 0xb30d | 0xb30e | 0xb30f | 0xb310 | 0xb311 | 0xb312 | 0xb313 | 0xb314 | 0xb315 | 0xb316 | 0xb317 | 0xb318 | 0xb319 | 0xb31a | 0xb31b | 0xb31c | 0xb31d | 0xb31e | 0xb31f | 0xb320 | 0xb321 | 0xb322 | 0xb323 | 0xb324 | 0xb325 | 0xb326 | 0xb327 | 0xb328 | 0xb329 | 0xb32a | 0xb32b | 0xb32c | 0xb32d | 0xb32e | 0xb32f | 0xb330 | 0xb331 | 0xb332 | 0xb333 | 0xb334 | 0xb335 | 0xb336 | 0xb337 | 0xb338 | 0xb339 | 0xb33a | 0xb33b | 0xb33c | 0xb33d | 0xb33e | 0xb33f | 0xb340 | 0xb341 | 0xb342 | 0xb343 | 0xb344 | 0xb345 | 0xb346 | 0xb347 | 0xb348 | 0xb349 | 0xb34a | 0xb34b | 0xb34c | 0xb34d | 0xb34e | 0xb34f | 0xb350 | 0xb351 | 0xb352 | 0xb353 | 0xb354 | 0xb355 | 0xb356 | 0xb357 | 0xb358 | 0xb359 | 0xb35a | 0xb35b | 0xb35c | 0xb35d | 0xb35e | 0xb35f | 0xb360 | 0xb361 | 0xb362 | 0xb363 | 0xb364 | 0xb365 | 0xb366 | 0xb367 | 0xb368 | 0xb369 | 0xb36a | 0xb36b | 0xb36c | 0xb36d | 0xb36e | 0xb36f | 0xb370 | 0xb371 | 0xb372 | 0xb373 | 0xb374 | 0xb375 | 0xb376 | 0xb377 | 0xb378 | 0xb379 | 0xb37a | 0xb37b | 0xb37c | 0xb37d | 0xb37e | 0xb37f | 0xb380 | 0xb381 | 0xb382 | 0xb383 | 0xb384 | 0xb385 | 0xb386 | 0xb387 | 0xb388 | 0xb389 | 0xb38a | 0xb38b | 0xb38c | 0xb38d | 0xb38e | 0xb38f | 0xb390 | 0xb391 | 0xb392 | 0xb393 | 0xb394 | 0xb395 | 0xb396 | 0xb397 | 0xb398 | 0xb399 | 0xb39a | 0xb39b | 0xb39c | 0xb39d | 0xb39e | 0xb39f | 0xb3a0 | 0xb3a1 | 0xb3a2 | 0xb3a3 | 0xb3a4 | 0xb3a5 | 0xb3a6 | 0xb3a7 | 0xb3a8 | 0xb3a9 | 0xb3aa | 0xb3ab | 0xb3ac | 0xb3ad | 0xb3ae | 0xb3af | 0xb3b0 | 0xb3b1 | 0xb3b2 | 0xb3b3 | 0xb3b4 | 0xb3b5 | 0xb3b6 | 0xb3b7 | 0xb3b8 | 0xb3b9 | 0xb3ba | 0xb3bb | 0xb3bc | 0xb3bd | 0xb3be | 0xb3bf | 0xb3c0 | 0xb3c1 | 0xb3c2 | 0xb3c3 | 0xb3c4 | 0xb3c5 | 0xb3c6 | 0xb3c7 | 0xb3c8 | 0xb3c9 | 0xb3ca | 0xb3cb | 0xb3cc | 0xb3cd | 0xb3ce | 0xb3cf | 0xb3d0 | 0xb3d1 | 0xb3d2 | 0xb3d3 | 0xb3d4 | 0xb3d5 | 0xb3d6 | 0xb3d7 | 0xb3d8 | 0xb3d9 | 0xb3da | 0xb3db | 0xb3dc | 0xb3dd | 0xb3de | 0xb3df | 0xb3e0 | 0xb401 | 0xb402 } HashCode
 */

/**
 * @type { Record<HashName,HashCode> }
 */
const names = Object.freeze({
  'identity': 0x00,
  'sha1': 0x11,
  'sha2-256': 0x12,
  'sha2-512': 0x13,
  'sha3-512': 0x14,
  'sha3-384': 0x15,
  'sha3-256': 0x16,
  'sha3-224': 0x17,
  'shake-128': 0x18,
  'shake-256': 0x19,
  'keccak-224': 0x1a,
  'keccak-256': 0x1b,
  'keccak-384': 0x1c,
  'keccak-512': 0x1d,
  'blake3': 0x1e,
  'murmur3-128': 0x22,
  'murmur3-32': 0x23,
  'dbl-sha2-256': 0x56,
  'md4': 0xd4,
  'md5': 0xd5,
  'bmt': 0xd6,
  'sha2-256-trunc254-padded': 0x1012,
  'ripemd-128': 0x1052,
  'ripemd-160': 0x1053,
  'ripemd-256': 0x1054,
  'ripemd-320': 0x1055,
  'x11': 0x1100,
  'kangarootwelve': 0x1d01,
  'sm3-256': 0x534d,
  'blake2b-8': 0xb201,
  'blake2b-16': 0xb202,
  'blake2b-24': 0xb203,
  'blake2b-32': 0xb204,
  'blake2b-40': 0xb205,
  'blake2b-48': 0xb206,
  'blake2b-56': 0xb207,
  'blake2b-64': 0xb208,
  'blake2b-72': 0xb209,
  'blake2b-80': 0xb20a,
  'blake2b-88': 0xb20b,
  'blake2b-96': 0xb20c,
  'blake2b-104': 0xb20d,
  'blake2b-112': 0xb20e,
  'blake2b-120': 0xb20f,
  'blake2b-128': 0xb210,
  'blake2b-136': 0xb211,
  'blake2b-144': 0xb212,
  'blake2b-152': 0xb213,
  'blake2b-160': 0xb214,
  'blake2b-168': 0xb215,
  'blake2b-176': 0xb216,
  'blake2b-184': 0xb217,
  'blake2b-192': 0xb218,
  'blake2b-200': 0xb219,
  'blake2b-208': 0xb21a,
  'blake2b-216': 0xb21b,
  'blake2b-224': 0xb21c,
  'blake2b-232': 0xb21d,
  'blake2b-240': 0xb21e,
  'blake2b-248': 0xb21f,
  'blake2b-256': 0xb220,
  'blake2b-264': 0xb221,
  'blake2b-272': 0xb222,
  'blake2b-280': 0xb223,
  'blake2b-288': 0xb224,
  'blake2b-296': 0xb225,
  'blake2b-304': 0xb226,
  'blake2b-312': 0xb227,
  'blake2b-320': 0xb228,
  'blake2b-328': 0xb229,
  'blake2b-336': 0xb22a,
  'blake2b-344': 0xb22b,
  'blake2b-352': 0xb22c,
  'blake2b-360': 0xb22d,
  'blake2b-368': 0xb22e,
  'blake2b-376': 0xb22f,
  'blake2b-384': 0xb230,
  'blake2b-392': 0xb231,
  'blake2b-400': 0xb232,
  'blake2b-408': 0xb233,
  'blake2b-416': 0xb234,
  'blake2b-424': 0xb235,
  'blake2b-432': 0xb236,
  'blake2b-440': 0xb237,
  'blake2b-448': 0xb238,
  'blake2b-456': 0xb239,
  'blake2b-464': 0xb23a,
  'blake2b-472': 0xb23b,
  'blake2b-480': 0xb23c,
  'blake2b-488': 0xb23d,
  'blake2b-496': 0xb23e,
  'blake2b-504': 0xb23f,
  'blake2b-512': 0xb240,
  'blake2s-8': 0xb241,
  'blake2s-16': 0xb242,
  'blake2s-24': 0xb243,
  'blake2s-32': 0xb244,
  'blake2s-40': 0xb245,
  'blake2s-48': 0xb246,
  'blake2s-56': 0xb247,
  'blake2s-64': 0xb248,
  'blake2s-72': 0xb249,
  'blake2s-80': 0xb24a,
  'blake2s-88': 0xb24b,
  'blake2s-96': 0xb24c,
  'blake2s-104': 0xb24d,
  'blake2s-112': 0xb24e,
  'blake2s-120': 0xb24f,
  'blake2s-128': 0xb250,
  'blake2s-136': 0xb251,
  'blake2s-144': 0xb252,
  'blake2s-152': 0xb253,
  'blake2s-160': 0xb254,
  'blake2s-168': 0xb255,
  'blake2s-176': 0xb256,
  'blake2s-184': 0xb257,
  'blake2s-192': 0xb258,
  'blake2s-200': 0xb259,
  'blake2s-208': 0xb25a,
  'blake2s-216': 0xb25b,
  'blake2s-224': 0xb25c,
  'blake2s-232': 0xb25d,
  'blake2s-240': 0xb25e,
  'blake2s-248': 0xb25f,
  'blake2s-256': 0xb260,
  'skein256-8': 0xb301,
  'skein256-16': 0xb302,
  'skein256-24': 0xb303,
  'skein256-32': 0xb304,
  'skein256-40': 0xb305,
  'skein256-48': 0xb306,
  'skein256-56': 0xb307,
  'skein256-64': 0xb308,
  'skein256-72': 0xb309,
  'skein256-80': 0xb30a,
  'skein256-88': 0xb30b,
  'skein256-96': 0xb30c,
  'skein256-104': 0xb30d,
  'skein256-112': 0xb30e,
  'skein256-120': 0xb30f,
  'skein256-128': 0xb310,
  'skein256-136': 0xb311,
  'skein256-144': 0xb312,
  'skein256-152': 0xb313,
  'skein256-160': 0xb314,
  'skein256-168': 0xb315,
  'skein256-176': 0xb316,
  'skein256-184': 0xb317,
  'skein256-192': 0xb318,
  'skein256-200': 0xb319,
  'skein256-208': 0xb31a,
  'skein256-216': 0xb31b,
  'skein256-224': 0xb31c,
  'skein256-232': 0xb31d,
  'skein256-240': 0xb31e,
  'skein256-248': 0xb31f,
  'skein256-256': 0xb320,
  'skein512-8': 0xb321,
  'skein512-16': 0xb322,
  'skein512-24': 0xb323,
  'skein512-32': 0xb324,
  'skein512-40': 0xb325,
  'skein512-48': 0xb326,
  'skein512-56': 0xb327,
  'skein512-64': 0xb328,
  'skein512-72': 0xb329,
  'skein512-80': 0xb32a,
  'skein512-88': 0xb32b,
  'skein512-96': 0xb32c,
  'skein512-104': 0xb32d,
  'skein512-112': 0xb32e,
  'skein512-120': 0xb32f,
  'skein512-128': 0xb330,
  'skein512-136': 0xb331,
  'skein512-144': 0xb332,
  'skein512-152': 0xb333,
  'skein512-160': 0xb334,
  'skein512-168': 0xb335,
  'skein512-176': 0xb336,
  'skein512-184': 0xb337,
  'skein512-192': 0xb338,
  'skein512-200': 0xb339,
  'skein512-208': 0xb33a,
  'skein512-216': 0xb33b,
  'skein512-224': 0xb33c,
  'skein512-232': 0xb33d,
  'skein512-240': 0xb33e,
  'skein512-248': 0xb33f,
  'skein512-256': 0xb340,
  'skein512-264': 0xb341,
  'skein512-272': 0xb342,
  'skein512-280': 0xb343,
  'skein512-288': 0xb344,
  'skein512-296': 0xb345,
  'skein512-304': 0xb346,
  'skein512-312': 0xb347,
  'skein512-320': 0xb348,
  'skein512-328': 0xb349,
  'skein512-336': 0xb34a,
  'skein512-344': 0xb34b,
  'skein512-352': 0xb34c,
  'skein512-360': 0xb34d,
  'skein512-368': 0xb34e,
  'skein512-376': 0xb34f,
  'skein512-384': 0xb350,
  'skein512-392': 0xb351,
  'skein512-400': 0xb352,
  'skein512-408': 0xb353,
  'skein512-416': 0xb354,
  'skein512-424': 0xb355,
  'skein512-432': 0xb356,
  'skein512-440': 0xb357,
  'skein512-448': 0xb358,
  'skein512-456': 0xb359,
  'skein512-464': 0xb35a,
  'skein512-472': 0xb35b,
  'skein512-480': 0xb35c,
  'skein512-488': 0xb35d,
  'skein512-496': 0xb35e,
  'skein512-504': 0xb35f,
  'skein512-512': 0xb360,
  'skein1024-8': 0xb361,
  'skein1024-16': 0xb362,
  'skein1024-24': 0xb363,
  'skein1024-32': 0xb364,
  'skein1024-40': 0xb365,
  'skein1024-48': 0xb366,
  'skein1024-56': 0xb367,
  'skein1024-64': 0xb368,
  'skein1024-72': 0xb369,
  'skein1024-80': 0xb36a,
  'skein1024-88': 0xb36b,
  'skein1024-96': 0xb36c,
  'skein1024-104': 0xb36d,
  'skein1024-112': 0xb36e,
  'skein1024-120': 0xb36f,
  'skein1024-128': 0xb370,
  'skein1024-136': 0xb371,
  'skein1024-144': 0xb372,
  'skein1024-152': 0xb373,
  'skein1024-160': 0xb374,
  'skein1024-168': 0xb375,
  'skein1024-176': 0xb376,
  'skein1024-184': 0xb377,
  'skein1024-192': 0xb378,
  'skein1024-200': 0xb379,
  'skein1024-208': 0xb37a,
  'skein1024-216': 0xb37b,
  'skein1024-224': 0xb37c,
  'skein1024-232': 0xb37d,
  'skein1024-240': 0xb37e,
  'skein1024-248': 0xb37f,
  'skein1024-256': 0xb380,
  'skein1024-264': 0xb381,
  'skein1024-272': 0xb382,
  'skein1024-280': 0xb383,
  'skein1024-288': 0xb384,
  'skein1024-296': 0xb385,
  'skein1024-304': 0xb386,
  'skein1024-312': 0xb387,
  'skein1024-320': 0xb388,
  'skein1024-328': 0xb389,
  'skein1024-336': 0xb38a,
  'skein1024-344': 0xb38b,
  'skein1024-352': 0xb38c,
  'skein1024-360': 0xb38d,
  'skein1024-368': 0xb38e,
  'skein1024-376': 0xb38f,
  'skein1024-384': 0xb390,
  'skein1024-392': 0xb391,
  'skein1024-400': 0xb392,
  'skein1024-408': 0xb393,
  'skein1024-416': 0xb394,
  'skein1024-424': 0xb395,
  'skein1024-432': 0xb396,
  'skein1024-440': 0xb397,
  'skein1024-448': 0xb398,
  'skein1024-456': 0xb399,
  'skein1024-464': 0xb39a,
  'skein1024-472': 0xb39b,
  'skein1024-480': 0xb39c,
  'skein1024-488': 0xb39d,
  'skein1024-496': 0xb39e,
  'skein1024-504': 0xb39f,
  'skein1024-512': 0xb3a0,
  'skein1024-520': 0xb3a1,
  'skein1024-528': 0xb3a2,
  'skein1024-536': 0xb3a3,
  'skein1024-544': 0xb3a4,
  'skein1024-552': 0xb3a5,
  'skein1024-560': 0xb3a6,
  'skein1024-568': 0xb3a7,
  'skein1024-576': 0xb3a8,
  'skein1024-584': 0xb3a9,
  'skein1024-592': 0xb3aa,
  'skein1024-600': 0xb3ab,
  'skein1024-608': 0xb3ac,
  'skein1024-616': 0xb3ad,
  'skein1024-624': 0xb3ae,
  'skein1024-632': 0xb3af,
  'skein1024-640': 0xb3b0,
  'skein1024-648': 0xb3b1,
  'skein1024-656': 0xb3b2,
  'skein1024-664': 0xb3b3,
  'skein1024-672': 0xb3b4,
  'skein1024-680': 0xb3b5,
  'skein1024-688': 0xb3b6,
  'skein1024-696': 0xb3b7,
  'skein1024-704': 0xb3b8,
  'skein1024-712': 0xb3b9,
  'skein1024-720': 0xb3ba,
  'skein1024-728': 0xb3bb,
  'skein1024-736': 0xb3bc,
  'skein1024-744': 0xb3bd,
  'skein1024-752': 0xb3be,
  'skein1024-760': 0xb3bf,
  'skein1024-768': 0xb3c0,
  'skein1024-776': 0xb3c1,
  'skein1024-784': 0xb3c2,
  'skein1024-792': 0xb3c3,
  'skein1024-800': 0xb3c4,
  'skein1024-808': 0xb3c5,
  'skein1024-816': 0xb3c6,
  'skein1024-824': 0xb3c7,
  'skein1024-832': 0xb3c8,
  'skein1024-840': 0xb3c9,
  'skein1024-848': 0xb3ca,
  'skein1024-856': 0xb3cb,
  'skein1024-864': 0xb3cc,
  'skein1024-872': 0xb3cd,
  'skein1024-880': 0xb3ce,
  'skein1024-888': 0xb3cf,
  'skein1024-896': 0xb3d0,
  'skein1024-904': 0xb3d1,
  'skein1024-912': 0xb3d2,
  'skein1024-920': 0xb3d3,
  'skein1024-928': 0xb3d4,
  'skein1024-936': 0xb3d5,
  'skein1024-944': 0xb3d6,
  'skein1024-952': 0xb3d7,
  'skein1024-960': 0xb3d8,
  'skein1024-968': 0xb3d9,
  'skein1024-976': 0xb3da,
  'skein1024-984': 0xb3db,
  'skein1024-992': 0xb3dc,
  'skein1024-1000': 0xb3dd,
  'skein1024-1008': 0xb3de,
  'skein1024-1016': 0xb3df,
  'skein1024-1024': 0xb3e0,
  'poseidon-bls12_381-a2-fc1': 0xb401,
  'poseidon-bls12_381-a2-fc1-sc': 0xb402
})

module.exports = { names }

      };
    };
  }
}, {package:"multihashes",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multihashes/src/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/from-string.js", {"multibase":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/from-string.js
      return function (require, module, exports) {
'use strict'

const { encoding: getCodec } = require('multibase')
const utf8Encoder = new TextEncoder()

/**
 * @typedef {__import__('multibase/src/types').BaseName | 'utf8' | 'utf-8' | 'ascii' | undefined} SupportedEncodings
 */

/**
 * Interprets each character in a string as a byte and
 * returns a Uint8Array of those bytes.
 *
 * @param {string} string - The string to turn into an array
 */
function asciiStringToUint8Array (string) {
  const array = new Uint8Array(string.length)

  for (let i = 0; i < string.length; i++) {
    array[i] = string.charCodeAt(i)
  }

  return array
}

/**
 * Create a `Uint8Array` from the passed string
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 *
 * @param {string} string
 * @param {SupportedEncodings} [encoding=utf8] - utf8, base16, base64, base64urlpad, etc
 * @returns {Uint8Array}
 */
function fromString (string, encoding = 'utf8') {
  if (encoding === 'utf8' || encoding === 'utf-8') {
    return utf8Encoder.encode(string)
  }

  if (encoding === 'ascii') {
    return asciiStringToUint8Array(string)
  }

  return getCodec(encoding).decode(string)
}

module.exports = fromString

      };
    };
  }
}, {package:"uint8arrays",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/from-string.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/util.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/util.js
      return function (require, module, exports) {
'use strict'

const textDecoder = new TextDecoder()
/**
 * @param {ArrayBufferView|ArrayBuffer} bytes
 * @returns {string}
 */
const decodeText = (bytes) => textDecoder.decode(bytes)

const textEncoder = new TextEncoder()
/**
 * @param {string} text
 * @returns {Uint8Array}
 */
const encodeText = (text) => textEncoder.encode(text)

/**
 * Returns a new Uint8Array created by concatenating the passed Arrays
 *
 * @param {Array<ArrayLike<number>>} arrs
 * @param {number} length
 * @returns {Uint8Array}
 */
function concat (arrs, length) {
  const output = new Uint8Array(length)
  let offset = 0

  for (const arr of arrs) {
    output.set(arr, offset)
    offset += arr.length
  }

  return output
}

module.exports = { decodeText, encodeText, concat }

      };
    };
  }
}, {package:"multibase",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/constants.js", {"./base.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/base.js","./rfc4648":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/rfc4648.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/util.js","@multiformats/base-x":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@multiformats/base-x/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/constants.js
      return function (require, module, exports) {
'use strict'

const baseX = require('@multiformats/base-x')
const Base = require('./base.js')
const { rfc4648 } = require('./rfc4648')
const { decodeText, encodeText } = require('./util')

/** @typedef {__import__('./types').CodecFactory} CodecFactory */
/** @typedef {__import__('./types').Codec} Codec */
/** @typedef {__import__('./types').BaseName} BaseName */
/** @typedef {__import__('./types').BaseCode} BaseCode */

/** @type {CodecFactory} */
const identity = () => {
  return {
    encode: decodeText,
    decode: encodeText
  }
}

/**
 *
 * name, code, implementation, alphabet
 *
 * @type {Array<[BaseName, BaseCode, CodecFactory, string]>}
 */
const constants = [
  ['identity', '\x00', identity, ''],
  ['base2', '0', rfc4648(1), '01'],
  ['base8', '7', rfc4648(3), '01234567'],
  ['base10', '9', baseX, '0123456789'],
  ['base16', 'f', rfc4648(4), '0123456789abcdef'],
  ['base16upper', 'F', rfc4648(4), '0123456789ABCDEF'],
  ['base32hex', 'v', rfc4648(5), '0123456789abcdefghijklmnopqrstuv'],
  ['base32hexupper', 'V', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV'],
  ['base32hexpad', 't', rfc4648(5), '0123456789abcdefghijklmnopqrstuv='],
  ['base32hexpadupper', 'T', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV='],
  ['base32', 'b', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567'],
  ['base32upper', 'B', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'],
  ['base32pad', 'c', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567='],
  ['base32padupper', 'C', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='],
  ['base32z', 'h', rfc4648(5), 'ybndrfg8ejkmcpqxot1uwisza345h769'],
  ['base36', 'k', baseX, '0123456789abcdefghijklmnopqrstuvwxyz'],
  ['base36upper', 'K', baseX, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'],
  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
  ['base64', 'm', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
  ['base64pad', 'M', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
  ['base64url', 'u', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
  ['base64urlpad', 'U', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
]

/** @type {Record<BaseName,Base>} */
const names = constants.reduce((prev, tupple) => {
  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
  return prev
}, /** @type {Record<BaseName,Base>} */({}))

/** @type {Record<BaseCode,Base>} */
const codes = constants.reduce((prev, tupple) => {
  prev[tupple[1]] = names[tupple[0]]
  return prev
}, /** @type {Record<BaseCode,Base>} */({}))

module.exports = {
  names,
  codes
}

      };
    };
  }
}, {package:"multibase",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/rfc4648.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/rfc4648.js
      return function (require, module, exports) {
// @ts-check
'use strict'

/** @typedef {__import__('./base').CodecFactory} CodecFactory */

/**
 * @param {string} string
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {Uint8Array}
 */
const decode = (string, alphabet, bitsPerChar) => {
  // Build the character lookup table:
  const codes = {}
  for (let i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i
  }

  // Count the padding bytes:
  let end = string.length
  while (string[end - 1] === '=') {
    --end
  }

  // Allocate the output:
  const out = new Uint8Array((end * bitsPerChar / 8) | 0)

  // Parse the data:
  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  let written = 0 // Next byte to write
  for (let i = 0; i < end; ++i) {
    // Read one character from the string:
    const value = codes[string[i]]
    if (value === undefined) {
      throw new SyntaxError('Invalid character ' + string[i])
    }

    // Append the bits to the buffer:
    buffer = (buffer << bitsPerChar) | value
    bits += bitsPerChar

    // Write out some bits if the buffer has a byte's worth:
    if (bits >= 8) {
      bits -= 8
      out[written++] = 0xff & (buffer >> bits)
    }
  }

  // Verify that we have received just enough bits:
  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
    throw new SyntaxError('Unexpected end of data')
  }

  return out
}

/**
 * @param {Uint8Array} data
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {string}
 */
const encode = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === '='
  const mask = (1 << bitsPerChar) - 1
  let out = ''

  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  for (let i = 0; i < data.length; ++i) {
    // Slurp data into the buffer:
    buffer = (buffer << 8) | data[i]
    bits += 8

    // Write out as much as we can:
    while (bits > bitsPerChar) {
      bits -= bitsPerChar
      out += alphabet[mask & (buffer >> bits)]
    }
  }

  // Partial character:
  if (bits) {
    out += alphabet[mask & (buffer << (bitsPerChar - bits))]
  }

  // Add padding characters until we hit a byte boundary:
  if (pad) {
    while ((out.length * bitsPerChar) & 7) {
      out += '='
    }
  }

  return out
}

/**
 * @param {number} bitsPerChar
 * @returns {CodecFactory}
 */
module.exports = (bitsPerChar) => (alphabet) => {
  return {
    /**
     * @param {Uint8Array} input
     * @returns {string}
     */
    encode (input) {
      return encode(input, alphabet, bitsPerChar)
    },
    /**
     * @param {string} input
     * @returns {Uint8Array}
     */
    decode (input) {
      return decode(input, alphabet, bitsPerChar)
    }
  }
}

      };
    };
  }
}, {package:"multibase",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/rfc4648.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/base.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/base.js
      return function (require, module, exports) {
// @ts-check
'use strict'
const { Buffer } = require('buffer')

/**
 * @typedef {Object} Codec
 * @property {function(Uint8Array):string} encode
 * @property {function(string):Uint8Array} decode
 *
 * @typedef {function(string):Codec} CodecFactory
 */

class Base {
  /**
   * @param {string} name
   * @param {string} code
   * @param {CodecFactory} implementation
   * @param {string} alphabet
   */
  constructor (name, code, implementation, alphabet) {
    this.name = name
    this.code = code
    this.codeBuf = Buffer.from(this.code)
    this.alphabet = alphabet
    this.engine = implementation(alphabet)
  }

  /**
   * @param {Uint8Array} buf
   * @returns {string}
   */
  encode (buf) {
    return this.engine.encode(buf)
  }

  /**
   * @param {string} string
   * @returns {Uint8Array}
   */
  decode (string) {
    for (const char of string) {
      if (this.alphabet && this.alphabet.indexOf(char) < 0) {
        throw new Error(`invalid character '${char}' in '${string}'`)
      }
    }
    return this.engine.decode(string)
  }
}

module.exports = Base

      };
    };
  }
}, {package:"multibase",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/base.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/node_modules/multibase/src/constants.js", {"./base.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/node_modules/multibase/src/base.js","./rfc4648":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/node_modules/multibase/src/rfc4648.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/node_modules/multibase/src/util.js","@multiformats/base-x":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@multiformats/base-x/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/node_modules/multibase/src/constants.js
      return function (require, module, exports) {
'use strict'

const baseX = require('@multiformats/base-x')
const Base = require('./base.js')
const { rfc4648 } = require('./rfc4648')
const { decodeText, encodeText } = require('./util')

/** @typedef {__import__('./types').CodecFactory} CodecFactory */
/** @typedef {__import__('./types').Codec} Codec */
/** @typedef {__import__('./types').BaseName} BaseName */
/** @typedef {__import__('./types').BaseCode} BaseCode */

/** @type {CodecFactory} */
const identity = () => {
  return {
    encode: decodeText,
    decode: encodeText
  }
}

/**
 *
 * name, code, implementation, alphabet
 *
 * @type {Array<[BaseName, BaseCode, CodecFactory, string]>}
 */
const constants = [
  ['identity', '\x00', identity, ''],
  ['base2', '0', rfc4648(1), '01'],
  ['base8', '7', rfc4648(3), '01234567'],
  ['base10', '9', baseX, '0123456789'],
  ['base16', 'f', rfc4648(4), '0123456789abcdef'],
  ['base16upper', 'F', rfc4648(4), '0123456789ABCDEF'],
  ['base32hex', 'v', rfc4648(5), '0123456789abcdefghijklmnopqrstuv'],
  ['base32hexupper', 'V', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV'],
  ['base32hexpad', 't', rfc4648(5), '0123456789abcdefghijklmnopqrstuv='],
  ['base32hexpadupper', 'T', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV='],
  ['base32', 'b', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567'],
  ['base32upper', 'B', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'],
  ['base32pad', 'c', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567='],
  ['base32padupper', 'C', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='],
  ['base32z', 'h', rfc4648(5), 'ybndrfg8ejkmcpqxot1uwisza345h769'],
  ['base36', 'k', baseX, '0123456789abcdefghijklmnopqrstuvwxyz'],
  ['base36upper', 'K', baseX, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'],
  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
  ['base64', 'm', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
  ['base64pad', 'M', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
  ['base64url', 'u', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
  ['base64urlpad', 'U', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
]

/** @type {Record<BaseName,Base>} */
const names = constants.reduce((prev, tupple) => {
  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
  return prev
}, /** @type {Record<BaseName,Base>} */({}))

/** @type {Record<BaseCode,Base>} */
const codes = constants.reduce((prev, tupple) => {
  prev[tupple[1]] = names[tupple[0]]
  return prev
}, /** @type {Record<BaseCode,Base>} */({}))

module.exports = {
  names,
  codes
}

      };
    };
  }
}, {package:"multibase",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/node_modules/multibase/src/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/buildURL.js", {"./../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/buildURL.js
      return function (require, module, exports) {
'use strict';

var utils = require('./../utils');

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/buildURL.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/InterceptorManager.js", {"./../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/InterceptorManager.js
      return function (require, module, exports) {
'use strict';

var utils = require('./../utils');

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/InterceptorManager.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/validator.js", {"./../../package.json":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/package.json"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/validator.js
      return function (require, module, exports) {
'use strict';

var pkg = require('./../../package.json');

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};
var currentVerArr = pkg.version.split('.');

/**
 * Compare package versions
 * @param {string} version
 * @param {string?} thanVersion
 * @returns {boolean}
 */
function isOlderVersion(version, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
  var destVer = version.split('.');
  for (var i = 0; i < 3; i++) {
    if (pkgVersionArr[i] > destVer[i]) {
      return true;
    } else if (pkgVersionArr[i] < destVer[i]) {
      return false;
    }
  }
  return false;
}

/**
 * Transitional option validator
 * @param {function|boolean?} validator
 * @param {string?} version
 * @param {string} message
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  var isDeprecated = version && isOlderVersion(version);

  function formatMessage(opt, desc) {
    return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed in ' + version));
    }

    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new TypeError('options must be an object');
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

module.exports = {
  isOlderVersion: isOlderVersion,
  assertOptions: assertOptions,
  validators: validators
};

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/validator.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/dispatchRequest.js", {"../cancel/isCancel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/cancel/isCancel.js","../defaults":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/defaults.js","./../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/utils.js","./transformData":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/transformData.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/dispatchRequest.js
      return function (require, module, exports) {
'use strict';

var utils = require('./../utils');
var transformData = require('./transformData');
var isCancel = require('../cancel/isCancel');
var defaults = require('../defaults');

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/dispatchRequest.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/adapters/xhr.js", {"../core/buildFullPath":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/buildFullPath.js","../core/createError":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/createError.js","./../core/settle":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/settle.js","./../helpers/buildURL":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/buildURL.js","./../helpers/cookies":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/cookies.js","./../helpers/isURLSameOrigin":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/isURLSameOrigin.js","./../helpers/parseHeaders":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/parseHeaders.js","./../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/adapters/xhr.js
      return function (require, module, exports) {
'use strict';

var utils = require('./../utils');
var settle = require('./../core/settle');
var cookies = require('./../helpers/cookies');
var buildURL = require('./../helpers/buildURL');
var buildFullPath = require('../core/buildFullPath');
var parseHeaders = require('./../helpers/parseHeaders');
var isURLSameOrigin = require('./../helpers/isURLSameOrigin');
var createError = require('../core/createError');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(
        timeoutErrorMessage,
        config,
        config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/adapters/xhr.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/enhanceError.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/enhanceError.js
      return function (require, module, exports) {
'use strict';

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/enhanceError.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/normalizeHeaderName.js", {"../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/normalizeHeaderName.js
      return function (require, module, exports) {
'use strict';

var utils = require('../utils');

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/normalizeHeaderName.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/node_modules/pify/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/node_modules/pify/index.js
      return function (require, module, exports) {
'use strict';

const processFn = (fn, opts) => function () {
	const P = opts.promiseModule;
	const args = new Array(arguments.length);

	for (let i = 0; i < arguments.length; i++) {
		args[i] = arguments[i];
	}

	return new P((resolve, reject) => {
		if (opts.errorFirst) {
			args.push(function (err, result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 1; i < arguments.length; i++) {
						results[i - 1] = arguments[i];
					}

					if (err) {
						results.unshift(err);
						reject(results);
					} else {
						resolve(results);
					}
				} else if (err) {
					reject(err);
				} else {
					resolve(result);
				}
			});
		} else {
			args.push(function (result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 0; i < arguments.length; i++) {
						results[i] = arguments[i];
					}

					resolve(results);
				} else {
					resolve(result);
				}
			});
		}

		fn.apply(this, args);
	});
};

module.exports = (obj, opts) => {
	opts = Object.assign({
		exclude: [/.+(Sync|Stream)$/],
		errorFirst: true,
		promiseModule: Promise
	}, opts);

	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
	};

	let ret;
	if (typeof obj === 'function') {
		ret = function () {
			if (opts.excludeMain) {
				return obj.apply(this, arguments);
			}

			return processFn(obj, opts).apply(this, arguments);
		};
	} else {
		ret = Object.create(Object.getPrototypeOf(obj));
	}

	for (const key in obj) { // eslint-disable-line guard-for-in
		const x = obj[key];
		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;
	}

	return ret;
};

      };
    };
  }
}, {package:"pify",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/node_modules/pify/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/construct.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/construct.js
      return function (require, module, exports) {
// All of MetaMask's supported browsers include `Reflect.construct` support, so
// we don't need this polyfill.

// This Proxy preseves the two properties that were added by `@babel/runtime`.
// I am not entire sure what these properties are for (maybe ES5/ES6
// interoperability?) but they have been preserved just in case.
const reflectProxy =  new Proxy(
  Reflect.construct,
  {
    get: function (target, property) {
      if (property === 'default') {
        return target;
      } else if (property === '__esModule') {
        return true;
      }
      return Reflect.get(...arguments);
    }
  }
);

module.exports = reflectProxy;

      };
    };
  }
}, {package:"@babel/runtime",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/construct.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/isNativeFunction.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/isNativeFunction.js
      return function (require, module, exports) {
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction;
module.exports["default"] = module.exports, module.exports.__esModule = true;
      };
    };
  }
}, {package:"@babel/runtime",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/isNativeFunction.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/node_modules/whatwg-fetch/dist/fetch.umd.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/node_modules/whatwg-fetch/dist/fetch.umd.js
      return function (require, module, exports) {
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.WHATWGFetch = {})));
}(this, (function (exports) { 'use strict';

  var global =
    (typeof globalThis !== 'undefined' && globalThis) ||
    (typeof self !== 'undefined' && self) ||
    (typeof global !== 'undefined' && global);

  var support = {
    searchParams: 'URLSearchParams' in global,
    iterable: 'Symbol' in global && 'iterator' in Symbol,
    blob:
      'FileReader' in global &&
      'Blob' in global &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in global,
    arrayBuffer: 'ArrayBuffer' in global
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
      throw new TypeError('Invalid character in header field name: "' + name + '"')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      /*
        fetch-mock wraps the Response object in an ES6 Proxy to
        provide useful test harness features such as flush. However, on
        ES5 browsers without fetch or Proxy support pollyfills must be used;
        the proxy-pollyfill is unable to proxy an attribute unless it exists
        on the object before the Proxy is created. This change ensures
        Response.bodyUsed exists on the instance, while maintaining the
        semantic of setting Request.bodyUsed in the constructor before
        _initBody is called.
      */
      this.bodyUsed = this.bodyUsed;
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          var isConsumed = consumed(this);
          if (isConsumed) {
            return isConsumed
          }
          if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
            return Promise.resolve(
              this._bodyArrayBuffer.buffer.slice(
                this._bodyArrayBuffer.byteOffset,
                this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
              )
            )
          } else {
            return Promise.resolve(this._bodyArrayBuffer)
          }
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    if (!(this instanceof Request)) {
      throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
    }

    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);

    if (this.method === 'GET' || this.method === 'HEAD') {
      if (options.cache === 'no-store' || options.cache === 'no-cache') {
        // Search for a '_' parameter in the query string
        var reParamSearch = /([?&])_=[^&]*/;
        if (reParamSearch.test(this.url)) {
          // If it already exists then set the value with the current time
          this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
        } else {
          // Otherwise add a new '_' parameter to the end with the current time
          var reQueryString = /\?/;
          this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
        }
      }
    }
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
    // https://github.com/github/fetch/issues/748
    // https://github.com/zloirock/core-js/issues/751
    preProcessedHeaders
      .split('\r')
      .map(function(header) {
        return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header
      })
      .forEach(function(line) {
        var parts = line.split(':');
        var key = parts.shift().trim();
        if (key) {
          var value = parts.join(':').trim();
          headers.append(key, value);
        }
      });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!(this instanceof Response)) {
      throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
    }
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = global.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        setTimeout(function() {
          resolve(new Response(body, options));
        }, 0);
      };

      xhr.onerror = function() {
        setTimeout(function() {
          reject(new TypeError('Network request failed'));
        }, 0);
      };

      xhr.ontimeout = function() {
        setTimeout(function() {
          reject(new TypeError('Network request failed'));
        }, 0);
      };

      xhr.onabort = function() {
        setTimeout(function() {
          reject(new exports.DOMException('Aborted', 'AbortError'));
        }, 0);
      };

      function fixUrl(url) {
        try {
          return url === '' && global.location.href ? global.location.href : url
        } catch (e) {
          return url
        }
      }

      xhr.open(request.method, fixUrl(request.url), true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr) {
        if (support.blob) {
          xhr.responseType = 'blob';
        } else if (
          support.arrayBuffer &&
          request.headers.get('Content-Type') &&
          request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1
        ) {
          xhr.responseType = 'arraybuffer';
        }
      }

      if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {
        Object.getOwnPropertyNames(init.headers).forEach(function(name) {
          xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
        });
      } else {
        request.headers.forEach(function(value, name) {
          xhr.setRequestHeader(name, value);
        });
      }

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!global.fetch) {
    global.fetch = fetch;
    global.Headers = Headers;
    global.Request = Request;
    global.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

      };
    };
  }
}, {package:"whatwg-fetch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/node_modules/whatwg-fetch/dist/fetch.umd.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/lib/keccak-state-unroll.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/lib/keccak-state-unroll.js
      return function (require, module, exports) {
'use strict'
var P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648]

exports.p1600 = function (s) {
  for (var round = 0; round < 24; ++round) {
    // theta
    var lo0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40]
    var hi0 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41]
    var lo1 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42]
    var hi1 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43]
    var lo2 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44]
    var hi2 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45]
    var lo3 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46]
    var hi3 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47]
    var lo4 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48]
    var hi4 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49]

    var lo = lo4 ^ (lo1 << 1 | hi1 >>> 31)
    var hi = hi4 ^ (hi1 << 1 | lo1 >>> 31)
    var t1slo0 = s[0] ^ lo
    var t1shi0 = s[1] ^ hi
    var t1slo5 = s[10] ^ lo
    var t1shi5 = s[11] ^ hi
    var t1slo10 = s[20] ^ lo
    var t1shi10 = s[21] ^ hi
    var t1slo15 = s[30] ^ lo
    var t1shi15 = s[31] ^ hi
    var t1slo20 = s[40] ^ lo
    var t1shi20 = s[41] ^ hi
    lo = lo0 ^ (lo2 << 1 | hi2 >>> 31)
    hi = hi0 ^ (hi2 << 1 | lo2 >>> 31)
    var t1slo1 = s[2] ^ lo
    var t1shi1 = s[3] ^ hi
    var t1slo6 = s[12] ^ lo
    var t1shi6 = s[13] ^ hi
    var t1slo11 = s[22] ^ lo
    var t1shi11 = s[23] ^ hi
    var t1slo16 = s[32] ^ lo
    var t1shi16 = s[33] ^ hi
    var t1slo21 = s[42] ^ lo
    var t1shi21 = s[43] ^ hi
    lo = lo1 ^ (lo3 << 1 | hi3 >>> 31)
    hi = hi1 ^ (hi3 << 1 | lo3 >>> 31)
    var t1slo2 = s[4] ^ lo
    var t1shi2 = s[5] ^ hi
    var t1slo7 = s[14] ^ lo
    var t1shi7 = s[15] ^ hi
    var t1slo12 = s[24] ^ lo
    var t1shi12 = s[25] ^ hi
    var t1slo17 = s[34] ^ lo
    var t1shi17 = s[35] ^ hi
    var t1slo22 = s[44] ^ lo
    var t1shi22 = s[45] ^ hi
    lo = lo2 ^ (lo4 << 1 | hi4 >>> 31)
    hi = hi2 ^ (hi4 << 1 | lo4 >>> 31)
    var t1slo3 = s[6] ^ lo
    var t1shi3 = s[7] ^ hi
    var t1slo8 = s[16] ^ lo
    var t1shi8 = s[17] ^ hi
    var t1slo13 = s[26] ^ lo
    var t1shi13 = s[27] ^ hi
    var t1slo18 = s[36] ^ lo
    var t1shi18 = s[37] ^ hi
    var t1slo23 = s[46] ^ lo
    var t1shi23 = s[47] ^ hi
    lo = lo3 ^ (lo0 << 1 | hi0 >>> 31)
    hi = hi3 ^ (hi0 << 1 | lo0 >>> 31)
    var t1slo4 = s[8] ^ lo
    var t1shi4 = s[9] ^ hi
    var t1slo9 = s[18] ^ lo
    var t1shi9 = s[19] ^ hi
    var t1slo14 = s[28] ^ lo
    var t1shi14 = s[29] ^ hi
    var t1slo19 = s[38] ^ lo
    var t1shi19 = s[39] ^ hi
    var t1slo24 = s[48] ^ lo
    var t1shi24 = s[49] ^ hi

    // rho & pi
    var t2slo0 = t1slo0
    var t2shi0 = t1shi0
    var t2slo16 = (t1shi5 << 4 | t1slo5 >>> 28)
    var t2shi16 = (t1slo5 << 4 | t1shi5 >>> 28)
    var t2slo7 = (t1slo10 << 3 | t1shi10 >>> 29)
    var t2shi7 = (t1shi10 << 3 | t1slo10 >>> 29)
    var t2slo23 = (t1shi15 << 9 | t1slo15 >>> 23)
    var t2shi23 = (t1slo15 << 9 | t1shi15 >>> 23)
    var t2slo14 = (t1slo20 << 18 | t1shi20 >>> 14)
    var t2shi14 = (t1shi20 << 18 | t1slo20 >>> 14)
    var t2slo10 = (t1slo1 << 1 | t1shi1 >>> 31)
    var t2shi10 = (t1shi1 << 1 | t1slo1 >>> 31)
    var t2slo1 = (t1shi6 << 12 | t1slo6 >>> 20)
    var t2shi1 = (t1slo6 << 12 | t1shi6 >>> 20)
    var t2slo17 = (t1slo11 << 10 | t1shi11 >>> 22)
    var t2shi17 = (t1shi11 << 10 | t1slo11 >>> 22)
    var t2slo8 = (t1shi16 << 13 | t1slo16 >>> 19)
    var t2shi8 = (t1slo16 << 13 | t1shi16 >>> 19)
    var t2slo24 = (t1slo21 << 2 | t1shi21 >>> 30)
    var t2shi24 = (t1shi21 << 2 | t1slo21 >>> 30)
    var t2slo20 = (t1shi2 << 30 | t1slo2 >>> 2)
    var t2shi20 = (t1slo2 << 30 | t1shi2 >>> 2)
    var t2slo11 = (t1slo7 << 6 | t1shi7 >>> 26)
    var t2shi11 = (t1shi7 << 6 | t1slo7 >>> 26)
    var t2slo2 = (t1shi12 << 11 | t1slo12 >>> 21)
    var t2shi2 = (t1slo12 << 11 | t1shi12 >>> 21)
    var t2slo18 = (t1slo17 << 15 | t1shi17 >>> 17)
    var t2shi18 = (t1shi17 << 15 | t1slo17 >>> 17)
    var t2slo9 = (t1shi22 << 29 | t1slo22 >>> 3)
    var t2shi9 = (t1slo22 << 29 | t1shi22 >>> 3)
    var t2slo5 = (t1slo3 << 28 | t1shi3 >>> 4)
    var t2shi5 = (t1shi3 << 28 | t1slo3 >>> 4)
    var t2slo21 = (t1shi8 << 23 | t1slo8 >>> 9)
    var t2shi21 = (t1slo8 << 23 | t1shi8 >>> 9)
    var t2slo12 = (t1slo13 << 25 | t1shi13 >>> 7)
    var t2shi12 = (t1shi13 << 25 | t1slo13 >>> 7)
    var t2slo3 = (t1slo18 << 21 | t1shi18 >>> 11)
    var t2shi3 = (t1shi18 << 21 | t1slo18 >>> 11)
    var t2slo19 = (t1shi23 << 24 | t1slo23 >>> 8)
    var t2shi19 = (t1slo23 << 24 | t1shi23 >>> 8)
    var t2slo15 = (t1slo4 << 27 | t1shi4 >>> 5)
    var t2shi15 = (t1shi4 << 27 | t1slo4 >>> 5)
    var t2slo6 = (t1slo9 << 20 | t1shi9 >>> 12)
    var t2shi6 = (t1shi9 << 20 | t1slo9 >>> 12)
    var t2slo22 = (t1shi14 << 7 | t1slo14 >>> 25)
    var t2shi22 = (t1slo14 << 7 | t1shi14 >>> 25)
    var t2slo13 = (t1slo19 << 8 | t1shi19 >>> 24)
    var t2shi13 = (t1shi19 << 8 | t1slo19 >>> 24)
    var t2slo4 = (t1slo24 << 14 | t1shi24 >>> 18)
    var t2shi4 = (t1shi24 << 14 | t1slo24 >>> 18)

    // chi
    s[0] = t2slo0 ^ (~t2slo1 & t2slo2)
    s[1] = t2shi0 ^ (~t2shi1 & t2shi2)
    s[10] = t2slo5 ^ (~t2slo6 & t2slo7)
    s[11] = t2shi5 ^ (~t2shi6 & t2shi7)
    s[20] = t2slo10 ^ (~t2slo11 & t2slo12)
    s[21] = t2shi10 ^ (~t2shi11 & t2shi12)
    s[30] = t2slo15 ^ (~t2slo16 & t2slo17)
    s[31] = t2shi15 ^ (~t2shi16 & t2shi17)
    s[40] = t2slo20 ^ (~t2slo21 & t2slo22)
    s[41] = t2shi20 ^ (~t2shi21 & t2shi22)
    s[2] = t2slo1 ^ (~t2slo2 & t2slo3)
    s[3] = t2shi1 ^ (~t2shi2 & t2shi3)
    s[12] = t2slo6 ^ (~t2slo7 & t2slo8)
    s[13] = t2shi6 ^ (~t2shi7 & t2shi8)
    s[22] = t2slo11 ^ (~t2slo12 & t2slo13)
    s[23] = t2shi11 ^ (~t2shi12 & t2shi13)
    s[32] = t2slo16 ^ (~t2slo17 & t2slo18)
    s[33] = t2shi16 ^ (~t2shi17 & t2shi18)
    s[42] = t2slo21 ^ (~t2slo22 & t2slo23)
    s[43] = t2shi21 ^ (~t2shi22 & t2shi23)
    s[4] = t2slo2 ^ (~t2slo3 & t2slo4)
    s[5] = t2shi2 ^ (~t2shi3 & t2shi4)
    s[14] = t2slo7 ^ (~t2slo8 & t2slo9)
    s[15] = t2shi7 ^ (~t2shi8 & t2shi9)
    s[24] = t2slo12 ^ (~t2slo13 & t2slo14)
    s[25] = t2shi12 ^ (~t2shi13 & t2shi14)
    s[34] = t2slo17 ^ (~t2slo18 & t2slo19)
    s[35] = t2shi17 ^ (~t2shi18 & t2shi19)
    s[44] = t2slo22 ^ (~t2slo23 & t2slo24)
    s[45] = t2shi22 ^ (~t2shi23 & t2shi24)
    s[6] = t2slo3 ^ (~t2slo4 & t2slo0)
    s[7] = t2shi3 ^ (~t2shi4 & t2shi0)
    s[16] = t2slo8 ^ (~t2slo9 & t2slo5)
    s[17] = t2shi8 ^ (~t2shi9 & t2shi5)
    s[26] = t2slo13 ^ (~t2slo14 & t2slo10)
    s[27] = t2shi13 ^ (~t2shi14 & t2shi10)
    s[36] = t2slo18 ^ (~t2slo19 & t2slo15)
    s[37] = t2shi18 ^ (~t2shi19 & t2shi15)
    s[46] = t2slo23 ^ (~t2slo24 & t2slo20)
    s[47] = t2shi23 ^ (~t2shi24 & t2shi20)
    s[8] = t2slo4 ^ (~t2slo0 & t2slo1)
    s[9] = t2shi4 ^ (~t2shi0 & t2shi1)
    s[18] = t2slo9 ^ (~t2slo5 & t2slo6)
    s[19] = t2shi9 ^ (~t2shi5 & t2shi6)
    s[28] = t2slo14 ^ (~t2slo10 & t2slo11)
    s[29] = t2shi14 ^ (~t2shi10 & t2shi11)
    s[38] = t2slo19 ^ (~t2slo15 & t2slo16)
    s[39] = t2shi19 ^ (~t2shi15 & t2shi16)
    s[48] = t2slo24 ^ (~t2slo20 & t2slo21)
    s[49] = t2shi24 ^ (~t2shi20 & t2shi21)

    // iota
    s[0] ^= P1600_ROUND_CONSTANTS[round * 2]
    s[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1]
  }
}

      };
    };
  }
}, {package:"keccak",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/lib/keccak-state-unroll.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/lib/api/keccak.js", {"inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js","stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/stream-browserify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/lib/api/keccak.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var Transform = require('stream').Transform
var inherits = require('inherits')

module.exports = function (KeccakState) {
  function Keccak (rate, capacity, delimitedSuffix, hashBitLength, options) {
    Transform.call(this, options)

    this._rate = rate
    this._capacity = capacity
    this._delimitedSuffix = delimitedSuffix
    this._hashBitLength = hashBitLength
    this._options = options

    this._state = new KeccakState()
    this._state.initialize(rate, capacity)
    this._finalized = false
  }

  inherits(Keccak, Transform)

  Keccak.prototype._transform = function (chunk, encoding, callback) {
    var error = null
    try {
      this.update(chunk, encoding)
    } catch (err) {
      error = err
    }

    callback(error)
  }

  Keccak.prototype._flush = function (callback) {
    var error = null
    try {
      this.push(this.digest())
    } catch (err) {
      error = err
    }

    callback(error)
  }

  Keccak.prototype.update = function (data, encoding) {
    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')
    if (this._finalized) throw new Error('Digest already called')
    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

    this._state.absorb(data)

    return this
  }

  Keccak.prototype.digest = function (encoding) {
    if (this._finalized) throw new Error('Digest already called')
    this._finalized = true

    if (this._delimitedSuffix) this._state.absorbLastFewBits(this._delimitedSuffix)
    var digest = this._state.squeeze(this._hashBitLength / 8)
    if (encoding !== undefined) digest = digest.toString(encoding)

    this._resetState()

    return digest
  }

  // remove result from memory
  Keccak.prototype._resetState = function () {
    this._state.initialize(this._rate, this._capacity)
    return this
  }

  // because sometimes we need hash right now and little later
  Keccak.prototype._clone = function () {
    var clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options)
    this._state.copy(clone._state)
    clone._finalized = this._finalized

    return clone
  }

  return Keccak
}

      };
    };
  }
}, {package:"keccak",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/lib/api/keccak.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/lib/api/shake.js", {"inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/inherits/inherits_browser.js","safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js","stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/stream-browserify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/lib/api/shake.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var Transform = require('stream').Transform
var inherits = require('inherits')

module.exports = function (KeccakState) {
  function Shake (rate, capacity, delimitedSuffix, options) {
    Transform.call(this, options)

    this._rate = rate
    this._capacity = capacity
    this._delimitedSuffix = delimitedSuffix
    this._options = options

    this._state = new KeccakState()
    this._state.initialize(rate, capacity)
    this._finalized = false
  }

  inherits(Shake, Transform)

  Shake.prototype._transform = function (chunk, encoding, callback) {
    var error = null
    try {
      this.update(chunk, encoding)
    } catch (err) {
      error = err
    }

    callback(error)
  }

  Shake.prototype._flush = function () {}

  Shake.prototype._read = function (size) {
    this.push(this.squeeze(size))
  }

  Shake.prototype.update = function (data, encoding) {
    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')
    if (this._finalized) throw new Error('Squeeze already called')
    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

    this._state.absorb(data)

    return this
  }

  Shake.prototype.squeeze = function (dataByteLength, encoding) {
    if (!this._finalized) {
      this._finalized = true
      this._state.absorbLastFewBits(this._delimitedSuffix)
    }

    var data = this._state.squeeze(dataByteLength)
    if (encoding !== undefined) data = data.toString(encoding)

    return data
  }

  Shake.prototype._resetState = function () {
    this._state.initialize(this._rate, this._capacity)
    return this
  }

  Shake.prototype._clone = function () {
    var clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options)
    this._state.copy(clone._state)
    clone._finalized = this._finalized

    return clone
  }

  return Shake
}

      };
    };
  }
}, {package:"keccak",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/lib/api/shake.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/lib/keccak.js", {"./keccak-state-unroll":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/lib/keccak-state-unroll.js","safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/lib/keccak.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var keccakState = require('./keccak-state-unroll')

function Keccak () {
  // much faster than `new Array(50)`
  this.state = [
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0
  ]

  this.blockSize = null
  this.count = 0
  this.squeezing = false
}

Keccak.prototype.initialize = function (rate, capacity) {
  for (var i = 0; i < 50; ++i) this.state[i] = 0
  this.blockSize = rate / 8
  this.count = 0
  this.squeezing = false
}

Keccak.prototype.absorb = function (data) {
  for (var i = 0; i < data.length; ++i) {
    this.state[~~(this.count / 4)] ^= data[i] << (8 * (this.count % 4))
    this.count += 1
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state)
      this.count = 0
    }
  }
}

Keccak.prototype.absorbLastFewBits = function (bits) {
  this.state[~~(this.count / 4)] ^= bits << (8 * (this.count % 4))
  if ((bits & 0x80) !== 0 && this.count === (this.blockSize - 1)) keccakState.p1600(this.state)
  this.state[~~((this.blockSize - 1) / 4)] ^= 0x80 << (8 * ((this.blockSize - 1) % 4))
  keccakState.p1600(this.state)
  this.count = 0
  this.squeezing = true
}

Keccak.prototype.squeeze = function (length) {
  if (!this.squeezing) this.absorbLastFewBits(0x01)

  var output = Buffer.alloc(length)
  for (var i = 0; i < length; ++i) {
    output[i] = (this.state[~~(this.count / 4)] >>> (8 * (this.count % 4))) & 0xff
    this.count += 1
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state)
      this.count = 0
    }
  }

  return output
}

Keccak.prototype.copy = function (dest) {
  for (var i = 0; i < 50; ++i) dest.state[i] = this.state[i]
  dest.blockSize = this.blockSize
  dest.count = this.count
  dest.squeezing = this.squeezing
}

module.exports = Keccak

      };
    };
  }
}, {package:"keccak",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/lib/keccak.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/lib/api/index.js", {"./keccak":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/lib/api/keccak.js","./shake":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/lib/api/shake.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/lib/api/index.js
      return function (require, module, exports) {
'use strict'
var createKeccak = require('./keccak')
var createShake = require('./shake')

module.exports = function (KeccakState) {
  var Keccak = createKeccak(KeccakState)
  var Shake = createShake(KeccakState)

  return function (algorithm, options) {
    var hash = typeof algorithm === 'string' ? algorithm.toLowerCase() : algorithm
    switch (hash) {
      case 'keccak224': return new Keccak(1152, 448, null, 224, options)
      case 'keccak256': return new Keccak(1088, 512, null, 256, options)
      case 'keccak384': return new Keccak(832, 768, null, 384, options)
      case 'keccak512': return new Keccak(576, 1024, null, 512, options)

      case 'sha3-224': return new Keccak(1152, 448, 0x06, 224, options)
      case 'sha3-256': return new Keccak(1088, 512, 0x06, 256, options)
      case 'sha3-384': return new Keccak(832, 768, 0x06, 384, options)
      case 'sha3-512': return new Keccak(576, 1024, 0x06, 512, options)

      case 'shake128': return new Shake(1344, 256, 0x1f, options)
      case 'shake256': return new Shake(1088, 512, 0x1f, options)

      default: throw new Error('Invald algorithm: ' + algorithm)
    }
  }
}

      };
    };
  }
}, {package:"keccak",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/lib/api/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/index.js", {"./account":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/account.js","./bytes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js","./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/constants.js","./hash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/hash.js","./object":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/object.js","./secp256k1v3-adapter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js","./signature":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/signature.js","bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bn.js/lib/bn.js","ethjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethjs-util/lib/index.js","rlp":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/rlp/dist.browser/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.secp256k1 = exports.rlp = exports.BN = void 0;
var secp256k1 = require('./secp256k1v3-adapter');
exports.secp256k1 = secp256k1;
var ethjsUtil = require('ethjs-util');
var BN = require("bn.js");
exports.BN = BN;
var rlp = require("rlp");
exports.rlp = rlp;
Object.assign(exports, ethjsUtil);
/**
 * Constants
 */
__exportStar(require("./constants"), exports);
/**
 * Public-key cryptography (secp256k1) and addresses
 */
__exportStar(require("./account"), exports);
/**
 * Hash functions
 */
__exportStar(require("./hash"), exports);
/**
 * ECDSA signature
 */
__exportStar(require("./signature"), exports);
/**
 * Utilities for manipulating Buffers, byte arrays, etc.
 */
__exportStar(require("./bytes"), exports);
/**
 * Function for definining properties on an object
 */
__exportStar(require("./object"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/utils.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/utils.js
      return function (require, module, exports) {
'use strict';

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = function(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.params = function(str){
  return str.split(/ *; */).reduce(function(obj, str){
    var parts = str.split(/ *= */);
    var key = parts.shift();
    var val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.parseLinks = function(str){
  return str.split(/ *, */).reduce(function(obj, str){
    var parts = str.split(/ *; */);
    var url = parts[0].slice(1, -1);
    var rel = parts[1].split(/ *= */)[1].slice(1, -1);
    obj[rel] = url;
    return obj;
  }, {});
};

/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */

exports.cleanHeader = function(header, changesOrigin){
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header['host'];
  // secuirty
  if (changesOrigin) {
    delete header['authorization'];
    delete header['cookie'];
  }
  return header;
};

      };
    };
  }
}, {package:"superagent",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/circular-shift-right.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/circular-shift-right.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Circular Shift Right
 *
 * @example
 * circularShiftRight([1,0,1,1,0,1]) => [1,1,0,1,1,0]
 *
 * @see {@link https://en.wikipedia.org/wiki/Circular_shift}
 *
 * @param {Array} bits input data
 * @param {number} amount how far should it be shifted
 * @return {Array} [ROR bits]
 */
exports.default = (function (bits, amount) {
    var result = [];
    if (amount > bits.length)
        throw new Error('shift amount can’t be larger than bits array length');
    for (var i = 0; i < bits.length; i++)
        result[(i + amount) % bits.length] = bits[i];
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/circular-shift-right.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/and.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/and.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Applies the AND operation, expects two arrays of the same size and returns a new one.
 *
 * @example
 * and([1,0,0,0,1,1,0,1], [0,1,1,0,0,1,0,0]) => [0,0,0,0,0,1,0,0]
 *
 * @param {Array} bits1 input data
 * @param {Array} bits2 input data
 * @return {Array} [bits1 AND bits2]
 */
exports.default = (function (bits1, bits2) {
    var result = [];
    for (var i = 0; i < bits1.length; i++)
        result[i] = (bits1[i] & bits2[i]);
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/and.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/circular-shift-left.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/circular-shift-left.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Circular Shift Left
 *
 * @example
 * circularShiftLeft([1,0,1,1,0,1]) => [0,1,1,0,1,1]
 *
 * @see {@link https://en.wikipedia.org/wiki/Circular_shift}
 *
 * @param {Array} bits input data
 * @param {number} amount how far should it be shifted
 * @return {Array} [ROL bits]
 */
exports.default = (function (bits, amount) {
    var result = [];
    if (amount > bits.length)
        throw new Error('shift amount can’t be larger than bits array length');
    for (var i = 0; i < bits.length; i++)
        result[(bits.length + i - amount) % bits.length] = bits[i];
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/circular-shift-left.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/nand.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/nand.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Applies the NAND operation, expects two arrays of the same size and returns a new one.
 *
 * @example
 * nand([1,0,0,0,1,1,0,1], [0,1,1,0,0,1,0,0]) => [1,1,1,1,1,0,1,1]
 *
 * @param {Array} bits1 input data
 * @param {Array} bits2 input data
 * @return {Array} [bits1 NAND bits2]
 */
exports.default = (function (bits1, bits2) {
    var result = [];
    for (var i = 0; i < bits1.length; i++)
        result[i] = ((bits1[i] & bits2[i]) ^ 1);
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/nand.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/not.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/not.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Flips all given bits and returns the flipped bits.
 *
 * @example
 * not([1,0,1,1,0,1]) => [0,1,0,0,1,0]
 *
 * @param {Array} bits input data
 * @return {Array} [NOT bits]
 */
exports.default = (function (bits) {
    var result = [];
    for (var i = 0; i < bits.length; i++)
        result[i] = (bits[i] ^ 1);
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/not.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/nor.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/nor.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Applies the NOR operation, expects two arrays of the same size and returns a new one.
 *
 * @example
 * nor([1,0,0,0,1,1,0,1], [0,1,1,0,0,1,0,0]) => [0,0,0,1,0,0,1,0]
 *
 * @param {Array} bits1 input data
 * @param {Array} bits2 input data
 * @return {Array} [bits1 NOR bits2]
 */
exports.default = (function (bits1, bits2) {
    var result = [];
    for (var i = 0; i < bits1.length; i++)
        result[i] = ((bits1[i] | bits2[i]) ^ 1);
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/nor.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-and.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-and.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Applies the AND operation on the given bits. Returns one bit.
 * Throws if less than 2 bits are given.
 *
 * @example
 * reduceAnd([1, 0, 0, 0, 1, 1, 0, 1]) => 0
 *
 * @param {Array} bits input data
 * @return {Integer} AND bits
 */
exports.default = (function (bits) {
    if (bits.length < 2)
        throw new RangeError('Not enough bits.');
    var result = bits[0];
    for (var i = 1; i < bits.length; i++)
        result &= bits[i];
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-and.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/or.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/or.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Applies the OR operation, expects two arrays of the same size and returns a new one.
 *
 * @example
 * or([1,0,0,0,1,1,0,1], [0,1,1,0,0,1,0,0]) => [1,1,1,0,1,1,0,1]
 *
 * @param {Array} bits1 input data
 * @param {Array} bits2 input data
 * @return {Array} [bits1 OR bits2]
 */
exports.default = (function (bits1, bits2) {
    var result = [];
    for (var i = 0; i < bits1.length; i++)
        result[i] = (bits1[i] | bits2[i]);
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/or.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-nand.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-nand.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Applies the NAND operation on the given bits. Returns one bit.
 * Throws if less than 2 bits are given.
 *
 * @example
 * reduceNand([1, 0, 0, 0, 1, 1, 0, 1]) => 0
 *
 * @param {Array} bits input data
 * @return {Integer} NAND bits
 */
exports.default = (function (bits) {
    if (bits.length < 2)
        throw new RangeError('Not enough bits.');
    var result = bits[0];
    for (var i = 1; i < bits.length; i++)
        result = ((result & bits[i]) ^ 1);
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-nand.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-nor.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-nor.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Applies the NOR operation on the given bits. Returns one bit.
 * Throws if less than 2 bits are given.
 *
 * @example
 * reduceNor([1, 0, 0, 0, 1, 1, 0, 1]) => 0
 *
 * @param {Array} bits input data
 * @return {Integer} NOR bits
 */
exports.default = (function (bits) {
    if (bits.length < 2)
        throw new RangeError('Not enough bits.');
    var result = bits[0];
    for (var i = 1; i < bits.length; i++)
        result = ((result | bits[i]) ^ 1);
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-nor.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-or.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-or.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Applies the OR operation on the given bits. Returns one bit.
 * Throws if less than 2 bits are given.
 *
 * @example
 * reduceOr([1, 0, 0, 0, 1, 1, 0, 1]) => 1
 *
 * @param {Array} bits input data
 * @return {Integer} OR bits
 */
exports.default = (function (bits) {
    if (bits.length < 2)
        throw new RangeError('Not enough bits.');
    var result = bits[0];
    for (var i = 1; i < bits.length; i++)
        result |= bits[i];
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-or.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-xnor.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-xnor.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Applies the XNOR operation on the given bits. Returns one bit.
 * Throws if less than 2 bits are given.
 *
 * @example
 * reduceXnor([1, 0, 0, 0, 1, 1, 0, 1]) => 1
 *
 * @param {Array} bits input data
 * @return {Integer} XNOR bits
 */
exports.default = (function (bits) {
    if (bits.length < 2)
        throw new RangeError('Not enough bits.');
    var result = bits[0];
    for (var i = 1; i < bits.length; i++)
        result ^= bits[i] ^ 1;
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-xnor.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-xor.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-xor.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Applies the XOR operation on the given bits. Returns one bit.
 * Throws if less than 2 bits are given.
 *
 * @example
 * reduceXor([1, 0, 0, 0, 1, 1, 0, 1]) => 0
 *
 * @param {Array} bits input data
 * @return {Integer} XOR bits
 */
exports.default = (function (bits) {
    if (bits.length < 2)
        throw new RangeError('Not enough bits.');
    var result = bits[0];
    for (var i = 1; i < bits.length; i++)
        result ^= bits[i];
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/reduce-xor.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/to-boolean.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/to-boolean.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Converts a bit array to a boolean array.
 *
 * @example toBoolean([0, 1]) => [false, true]
 * @param {Array} bits input data
 * @returns {Array} boolean bits
 */
exports.default = (function (bits) {
    var result = [];
    for (var i = 0; i < bits.length; i++)
        result[i] = bits[i] === 1;
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/to-boolean.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/to-string.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/to-string.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Converts a bit array to a string. If defined, inserts spacer every spacing characters, but never inserts it as the last substring.
 *
 * @example
 * toString([1,0,1,0,1,0], 2, '_') => '10_10_10'
 *
 * @param {Array} bits the bits to convert
 * @param {Number} spacing where to place the spacers
 * @param {Number} spacer the string used as a spacer
 * @return {String}
 */
exports.default = (function (bits, spacing, spacer) {
    if (spacing === void 0) { spacing = 0; }
    if (spacer === void 0) { spacer = ' '; }
    if (!spacing)
        return bits.join('');
    var result = '';
    for (var i = 0; i < bits.length; i++) {
        result += "" + bits[i];
        if (i % spacing === spacing - 1 && i !== bits.length - 1)
            result += spacer;
    }
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/to-string.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/xnor.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/xnor.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Applies the exclusive NOR operation, expects two arrays of the same size and returns a new one.
 *
 * @example
 * xnor([1,0,0,0,1,1,0,1], [0,1,1,0,0,1,0,0]) => [0,0,0,1,0,1,1,0]
 *
 * @param {Array} bits1 input data
 * @param {Array} bits2 input data
 * @return {Array} [bits1 XNOR bits2]
 */
exports.default = (function (bits1, bits2) {
    var result = [];
    for (var i = 0; i < bits1.length; i++)
        result[i] = (bits1[i] ^ bits2[i] ^ 1);
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/xnor.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/xor.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/xor.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Applies the exclusive or operation, expects two arrays of the same size and returns a new one.
 *
 * @example
 * xor([1,0,0,0,1,1,0,1], [0,1,1,0,0,1,0,0]) => [1,1,1,0,1,0,0,1]
 *
 * @param {Array} bits1 input data
 * @param {Array} bits2 input data
 * @return {Array} [bits1 XOR bits2]
 */
exports.default = (function (bits1, bits2) {
    var result = [];
    for (var i = 0; i < bits1.length; i++)
        result[i] = (bits1[i] ^ bits2[i]);
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/xor.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/integer/get-bit.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/integer/get-bit.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Gets the value of a specific bit.
 * @example bitwise.integer.getBit(128, 7) => 1
 * @param {Integer} int32 input number
 * @param {Integer} position bit's position
 * @returns {Integer} bit's value
 */
exports.default = (function (int32, position) {
    return ((int32 >> position) & 1);
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/integer/get-bit.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/integer/set-bit.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/integer/set-bit.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Sets the value of a specific bit.
 * @example bitwise.integer.set(128, 7, 0) => 0
 * @param {Integer} int32 input number
 * @param {Integer} position bit’s position
 * @param {Integer} value bit’s new value
 * @returns {Integer} resulting number
 */
exports.default = (function (int32, position, value) {
    return (value === 1 ? int32 | (1 << position) : int32 & ~(1 << position));
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/integer/set-bit.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/integer/toggle-bit.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/integer/toggle-bit.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Toggles a specific bit.
 * @example bitwise.integer.getBit(128, 7) => 0
 * @param {Integer} int32 input number
 * @param {Integer} position bit’s position
 * @returns {Integer} updated number
 */
exports.default = (function (int32, position) { return int32 ^ (1 << position); });

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/integer/toggle-bit.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/byte/read.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/byte/read.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns an Array of length 8 containing the read bits.
 *
 * @example
 * byte.read(42) => [0,0,1,0,1,0,1,0]
 *
 * @param {Number} byte one byte
 * @return {Array}
 */
exports.default = (function (byte) {
    if (byte > 255 || byte < 0 || ~~byte !== byte)
        throw new RangeError('invalid byte');
    var result = [0, 0, 0, 0, 0, 0, 0, 0];
    for (var i = 0; i < 8; i++)
        result[7 - i] = ((byte >> i) & 1);
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/byte/read.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/byte/write.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/byte/write.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns a UInt8 (0-255) which equals the given bits.
 *
 * @example
 * byte.write([0,0,1,0,1,0,1,0]) => 42
 *
 * @param {Array} byte 8 bits
 * @return {Number} 8-bit unsigned integer
 */
exports.default = (function (byte) {
    if (!Array.isArray(byte) || byte.length !== 8)
        throw new RangeError('invalid array length');
    var data = 0;
    for (var i = 0; i < 8; i++)
        if (byte[7 - i])
            data |= 1 << i;
    return data;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/byte/write.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/string/to-bits.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/string/to-bits.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Converts a string into an array of bits. Ignores all characters except 1 and 0.
 *
 * @example
 * toBits('10 10 12$%_.0') => [1,0,1,0,1,0]
 *
 * @param {String} string the string to convert
 * @returns {Array} resulting array of bits
 */
exports.default = (function (string) {
    var result = [];
    for (var i = 0; i < string.length; i++) {
        if (string[i] === '1')
            result.push(1);
        else if (string[i] === '0')
            result.push(0);
    }
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/string/to-bits.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/nibble/read.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/nibble/read.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns an Array of length 8 containing the read bits.
 *
 * @example
 * nibble.read(15) => [1,1,1,1]
 *
 * @param {Number} nibble one nibble
 * @return {Array}
 */
exports.default = (function (nibble) {
    if (nibble < 16 && nibble >= 0 && Math.floor(nibble) === nibble) {
        var result = [0, 0, 0, 0];
        for (var i = 0; i < 4; i++)
            result[3 - i] = ((nibble >> i) & 1);
        return result;
    }
    else
        throw new RangeError('invalid array length');
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/nibble/read.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/nibble/write.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/nibble/write.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns a Nibble (0-15) which equals the given bits.
 *
 * @example
 * byte.write([1,0,1,0]) => 10
 *
 * @param {Array} nibble 4-bit unsigned integer
 * @return {Number}
 */
exports.default = (function (nibble) {
    if (!Array.isArray(nibble) || nibble.length !== 4)
        throw new RangeError('invalid array length');
    var result = 0;
    for (var i = 0; i < 4; i++)
        if (nibble[3 - i])
            result |= 1 << i;
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/nibble/write.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/and.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/and.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Applies a bitwise AND to the contents of two buffers. Returns a new buffer.
 *
 * @example
 * bitwise.buffer.and(a, b, false) => Buffer(a AND b)
 *
 * @param {Buffer} a first buffer
 * @param {Buffer} b second buffer
 * @param {Boolean} isLooping loop through first buffer
 * @return {Buffer} a AND b
 */
exports.default = (function (a, b, isLooping) {
    if (isLooping === void 0) { isLooping = false; }
    var length = isLooping ? b.length : a.length;
    var result = Buffer.alloc(length);
    for (var i = 0; i < length; i++) {
        var j = isLooping ? i % a.length : i;
        result[i] = a[j] & b[i];
    }
    return result;
});

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/and.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/nand.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/nand.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Applies a bitwise NAND to the contents of two buffers. Returns a new buffer.
 *
 * @example
 * bitwise.buffer.nand(a, b, false) => Buffer(a NAND b)
 *
 * @param {Buffer} a first buffer
 * @param {Buffer} b second buffer
 * @param {Boolean} isLooping loop through first buffer
 * @return {Buffer} a NAND b
 */
exports.default = (function (a, b, isLooping) {
    if (isLooping === void 0) { isLooping = false; }
    var length = isLooping ? b.length : a.length;
    var result = Buffer.alloc(length);
    for (var i = 0; i < length; i++) {
        var j = isLooping ? i % a.length : i;
        result[i] = ~(a[j] & b[i]);
    }
    return result;
});

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/nand.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/nor.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/nor.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Applies a bitwise NOR to the contents of two buffers. Returns a new buffer.
 *
 * @example
 * bitwise.buffer.nor(a, b, false) => Buffer(a NOR b)
 *
 * @param {Buffer} a first buffer
 * @param {Buffer} b second buffer
 * @param {Boolean} isLooping loop through first buffer
 * @return {Buffer} a NOR b
 */
exports.default = (function (a, b, isLooping) {
    if (isLooping === void 0) { isLooping = false; }
    var length = isLooping ? b.length : a.length;
    var result = Buffer.alloc(length);
    for (var i = 0; i < length; i++) {
        var j = isLooping ? i % a.length : i;
        result[i] = ~(a[j] | b[i]);
    }
    return result;
});

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/nor.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/not.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/not.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Applies a bitwise NOT to the contents of a buffer. Returns a new buffer.
 *
 * @example
 * bitwise.buffer.not(buffer) => Buffer(NOT buffer)
 *
 * @param {Buffer} buffer input data
 * @return {Buffer} Buffer(NOT buffer)
 */
exports.default = (function (buffer) {
    var result = Buffer.alloc(buffer.length);
    for (var i = 0; i < buffer.length; i++)
        result[i] = ~buffer[i];
    return result;
});

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/not.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/or.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/or.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Applies a bitwise OR to the contents of two buffers. Returns a new buffer.
 *
 * @example
 * bitwise.buffer.or(a, b, false) => Buffer(a OR b)
 *
 * @param {Buffer} a first buffer
 * @param {Buffer} b second buffer
 * @param {Boolean} isLooping loop through first buffer
 * @return {Buffer} a OR b
 */
exports.default = (function (a, b, isLooping) {
    if (isLooping === void 0) { isLooping = false; }
    var length = isLooping ? b.length : a.length;
    var result = Buffer.alloc(length);
    for (var i = 0; i < length; i++) {
        var j = isLooping ? i % a.length : i;
        result[i] = a[j] | b[i];
    }
    return result;
});

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/or.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/xnor.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/xnor.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Applies a bitwise XNOR to the contents of two buffers. Returns a new buffer.
 *
 * @example
 * bitwise.buffer.xnor(a, b, false) => Buffer(a XNOR b)
 *
 * @param {Buffer} a first buffer
 * @param {Buffer} b second buffer
 * @param {Boolean} isLooping loop through first buffer
 * @return {Buffer} a XNOR b
 */
exports.default = (function (a, b, isLooping) {
    if (isLooping === void 0) { isLooping = false; }
    var length = isLooping ? b.length : a.length;
    var result = Buffer.alloc(length);
    for (var i = 0; i < length; i++) {
        var j = isLooping ? i % a.length : i;
        result[i] = ~(a[j] ^ b[i]);
    }
    return result;
});

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/xnor.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/xor.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/xor.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Applies a bitwise XOR to the contents of two buffers. Returns a new buffer.
 *
 * @example
 * bitwise.buffer.xor(a, b, false) => Buffer(a XOR b)
 *
 * @param {Buffer} a first buffer
 * @param {Buffer} b second buffer
 * @param {Boolean} isLooping loop through first buffer
 * @return {Buffer} a XOR b
 */
exports.default = (function (a, b, isLooping) {
    if (isLooping === void 0) { isLooping = false; }
    var length = isLooping ? b.length : a.length;
    var result = Buffer.alloc(length);
    for (var i = 0; i < length; i++) {
        var j = isLooping ? i % a.length : i;
        result[i] = a[j] ^ b[i];
    }
    return result;
});

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/xor.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/create.js", {"../byte/write":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/byte/write.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/create.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var write_1 = require("../byte/write");
/**
 * Creates a new buffer and writes the given bits.
 *
 * @example
 * createBuffer([1,1,1,1, 0,0,0,1, 1,0,1,0]) => buffer with data 1111 0001 1010 0000
 *
 * @param {Array} bits an array containing the bits to insert
 * @returns {Buffer}
 */
exports.default = (function (bits) {
    var data = [0, 0, 0, 0, 0, 0, 0, 0];
    var buffer = Buffer.alloc(Math.ceil(bits.length / 8));
    for (var i = 0; i < buffer.length; i++) {
        for (var j = 0; j < 8; j++) {
            if (bits[i * 8 + j])
                data[j] = bits[i * 8 + j];
            else
                data[j] = 0;
        }
        buffer[i] = write_1.default(data);
    }
    return buffer;
});

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/create.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/modify.js", {"../byte/write":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/byte/write.js","./read":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/read.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/modify.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var write_1 = require("../byte/write");
var read_1 = require("./read");
/**
 * Modifies the buffer's bits to equal newBits starting at bitOffset.
 *
 * @example
 * modifyBuffer(buffer, [0,0,1,0], 0) => buffer was modified
 *
 * @param {Buffer} buffer the buffer to modify
 * @param {Array} bits the bits to insert
 * @param {Number} offset where to start (in bits)
 * @returns {undefined}
 */
exports.default = (function (buffer, bits, offset) {
    if (offset === void 0) { offset = 0; }
    var start = Math.floor(offset / 8);
    var end = Math.ceil((offset + bits.length) / 8);
    var subBuffer = buffer.slice(start, end);
    var byteData = read_1.default(subBuffer);
    var subOffset = offset % 8;
    for (var i = 0; i < bits.length; i++)
        byteData[subOffset++] = bits[i];
    var length = end - start;
    for (var i_1 = 0; i_1 < length; i_1++)
        subBuffer[i_1] = write_1.default(byteData.slice(i_1 * 8, (i_1 + 1) * 8));
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/modify.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/read.js", {"../byte/read":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/byte/read.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/read.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var read_1 = require("../byte/read");
/**
 * Returns an Array containing bitLength bits starting at bitOffset.
 *
 * @example
 * readBuffer(buffer, 2, 4) => [0,0,1,0]
 *
 * @param {Buffer} buffer the buffer to read
 * @param {Number} offset where to start (in bits)
 * @param {Number} length how many bits to read
 * @returns {Array}
 */
exports.default = (function (buffer, offset, length) {
    if (offset === void 0) { offset = 0; }
    if (!length)
        length = buffer.length * 8 - offset;
    var start = Math.floor(offset / 8);
    var bytesToRead = Math.floor(length / 8) + 2;
    var arr = [];
    arr.length = bytesToRead * 8;
    for (var i = 0; i < bytesToRead; i++) {
        var toRead = buffer[start + i];
        if (toRead === undefined)
            continue;
        var bits = read_1.default(buffer[start + i]);
        arr[i * 8] = bits[0];
        arr[i * 8 + 1] = bits[1];
        arr[i * 8 + 2] = bits[2];
        arr[i * 8 + 3] = bits[3];
        arr[i * 8 + 4] = bits[4];
        arr[i * 8 + 5] = bits[5];
        arr[i * 8 + 6] = bits[6];
        arr[i * 8 + 7] = bits[7];
    }
    var subOffset = offset % 8;
    return arr.slice(subOffset, subOffset + length);
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/read.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/read-u-int.js", {"../utilities":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/utilities.js","./read":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/read.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/read-u-int.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utilities_1 = require("../utilities");
var read_1 = require("./read");
/**
 * Converts a section of a buffer to an unsigned integer.
 *
 * @example
 * // buffer 11110110
 * readUInt(buffer, 3, 5) => 22
 *
 * @param {Buffer} buffer the buffer to extract information from
 * @param {Number} length the length of the unsigned integer (in bits)
 * @param {Number} offset where to start (in bits)
 * @returns {Number}
 */
exports.default = (function (buffer, offset, length) {
    if (offset === void 0) { offset = 0; }
    if (length === void 0) { length = 8; }
    var arr = read_1.default(buffer, offset, length);
    var result = 0;
    for (var i = 0; i < length; i++)
        result += arr[i] * utilities_1.p2[length - i - 1];
    return result;
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/read-u-int.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/read-int.js", {"../bits/not":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/not.js","../utilities":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/utilities.js","./read":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/read.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/read-int.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utilities_1 = require("../utilities");
var not_1 = require("../bits/not");
var read_1 = require("./read");
/**
 * Converts a section of a buffer to a signed integer.
 *
 * @example
 * // buffer 11110110
 * readUInt(buffer, 3, 5) => -10
 *
 * @param {Buffer} buffer the buffer to extract information from
 * @param {Number} length the length of the signed integer (in bits)
 * @param {Number} offset where to start (in bits)
 * @return {Number}
 */
exports.default = (function (buffer, offset, length) {
    if (offset === void 0) { offset = 0; }
    if (length === void 0) { length = 8; }
    var bits = read_1.default(buffer, offset, length);
    if (bits[0] === 0) {
        var result = 0;
        for (var i = 0; i < length; i++)
            if (bits[i])
                result += utilities_1.p2[length - i - 1];
        return result;
    }
    else {
        var result = -1;
        var inverted = not_1.default(bits);
        for (var i = 0; i < length; i++)
            if (inverted[i])
                result -= utilities_1.p2[length - i - 1];
        return result;
    }
});

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/read-int.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/node_modules/secp256k1/lib/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/node_modules/secp256k1/lib/index.js
      return function (require, module, exports) {
const errors = {
  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',
  TWEAK_ADD:
    'The tweak was out of range or the resulted private key is invalid',
  TWEAK_MUL: 'The tweak was out of range or equal to zero',
  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',
  SECKEY_INVALID: 'Private Key is invalid',
  PUBKEY_PARSE: 'Public Key could not be parsed',
  PUBKEY_SERIALIZE: 'Public Key serialization error',
  PUBKEY_COMBINE: 'The sum of the public keys is not valid',
  SIG_PARSE: 'Signature could not be parsed',
  SIGN: 'The nonce generation function failed, or the private key was invalid',
  RECOVER: 'Public key could not be recover',
  ECDH: 'Scalar was invalid (zero or overflow)'
}

function assert (cond, msg) {
  if (!cond) throw new Error(msg)
}

function isUint8Array (name, value, length) {
  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`)

  if (length !== undefined) {
    if (Array.isArray(length)) {
      const numbers = length.join(', ')
      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`
      assert(length.includes(value.length), msg)
    } else {
      const msg = `Expected ${name} to be an Uint8Array with length ${length}`
      assert(value.length === length, msg)
    }
  }
}

function isCompressed (value) {
  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean')
}

function getAssertedOutput (output = (len) => new Uint8Array(len), length) {
  if (typeof output === 'function') output = output(length)
  isUint8Array('output', output, length)
  return output
}

function toTypeString (value) {
  return Object.prototype.toString.call(value).slice(8, -1)
}

module.exports = (secp256k1) => {
  return {
    contextRandomize (seed) {
      assert(
        seed === null || seed instanceof Uint8Array,
        'Expected seed to be an Uint8Array or null'
      )
      if (seed !== null) isUint8Array('seed', seed, 32)

      switch (secp256k1.contextRandomize(seed)) {
        case 1:
          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW)
      }
    },

    privateKeyVerify (seckey) {
      isUint8Array('private key', seckey, 32)

      return secp256k1.privateKeyVerify(seckey) === 0
    },

    privateKeyNegate (seckey) {
      isUint8Array('private key', seckey, 32)

      switch (secp256k1.privateKeyNegate(seckey)) {
        case 0:
          return seckey
        case 1:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    privateKeyTweakAdd (seckey, tweak) {
      isUint8Array('private key', seckey, 32)
      isUint8Array('tweak', tweak, 32)

      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
        case 0:
          return seckey
        case 1:
          throw new Error(errors.TWEAK_ADD)
      }
    },

    privateKeyTweakMul (seckey, tweak) {
      isUint8Array('private key', seckey, 32)
      isUint8Array('tweak', tweak, 32)

      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
        case 0:
          return seckey
        case 1:
          throw new Error(errors.TWEAK_MUL)
      }
    },

    publicKeyVerify (pubkey) {
      isUint8Array('public key', pubkey, [33, 65])

      return secp256k1.publicKeyVerify(pubkey) === 0
    },

    publicKeyCreate (seckey, compressed = true, output) {
      isUint8Array('private key', seckey, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyCreate(output, seckey)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.SECKEY_INVALID)
        case 2:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyConvert (pubkey, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyConvert(output, pubkey)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyNegate (pubkey, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyNegate(output, pubkey)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
        case 3:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyCombine (pubkeys, compressed = true, output) {
      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array')
      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items')
      for (const pubkey of pubkeys) {
        isUint8Array('public key', pubkey, [33, 65])
      }
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyCombine(output, pubkeys)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.PUBKEY_COMBINE)
        case 3:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyTweakAdd (pubkey, tweak, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isUint8Array('tweak', tweak, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.TWEAK_ADD)
      }
    },

    publicKeyTweakMul (pubkey, tweak, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isUint8Array('tweak', tweak, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.TWEAK_MUL)
      }
    },

    signatureNormalize (sig) {
      isUint8Array('signature', sig, 64)

      switch (secp256k1.signatureNormalize(sig)) {
        case 0:
          return sig
        case 1:
          throw new Error(errors.SIG_PARSE)
      }
    },

    signatureExport (sig, output) {
      isUint8Array('signature', sig, 64)
      output = getAssertedOutput(output, 72)

      const obj = { output, outputlen: 72 }
      switch (secp256k1.signatureExport(obj, sig)) {
        case 0:
          return output.slice(0, obj.outputlen)
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    signatureImport (sig, output) {
      isUint8Array('signature', sig)
      output = getAssertedOutput(output, 64)

      switch (secp256k1.signatureImport(output, sig)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    ecdsaSign (msg32, seckey, options = {}, output) {
      isUint8Array('message', msg32, 32)
      isUint8Array('private key', seckey, 32)
      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')
      if (options.data !== undefined) isUint8Array('options.data', options.data)
      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function')
      output = getAssertedOutput(output, 64)

      const obj = { signature: output, recid: null }
      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
        case 0:
          return obj
        case 1:
          throw new Error(errors.SIGN)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    ecdsaVerify (sig, msg32, pubkey) {
      isUint8Array('signature', sig, 64)
      isUint8Array('message', msg32, 32)
      isUint8Array('public key', pubkey, [33, 65])

      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
        case 0:
          return true
        case 3:
          return false
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.PUBKEY_PARSE)
      }
    },

    ecdsaRecover (sig, recid, msg32, compressed = true, output) {
      isUint8Array('signature', sig, 64)
      assert(
        toTypeString(recid) === 'Number' &&
          recid >= 0 &&
          recid <= 3,
        'Expected recovery id to be a Number within interval [0, 3]'
      )
      isUint8Array('message', msg32, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.RECOVER)
        case 3:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    ecdh (pubkey, seckey, options = {}, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isUint8Array('private key', seckey, 32)
      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')
      if (options.data !== undefined) isUint8Array('options.data', options.data)
      if (options.hashfn !== undefined) {
        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function')
        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32)
        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32)
        isUint8Array('output', output)
      } else {
        output = getAssertedOutput(output, 32)
      }

      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.ECDH)
      }
    }
  }
}

      };
    };
  }
}, {package:"secp256k1",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/node_modules/secp256k1/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/node_modules/secp256k1/lib/elliptic.js", {"elliptic":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/elliptic/lib/elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/node_modules/secp256k1/lib/elliptic.js
      return function (require, module, exports) {
const EC = require('elliptic').ec

const ec = new EC('secp256k1')
const ecparams = ec.curve

// Hack, we can not use bn.js@5, while elliptic uses bn.js@4
// See https://github.com/indutny/elliptic/issues/191#issuecomment-569888758
const BN = ecparams.n.constructor

function loadCompressedPublicKey (first, xbuf) {
  let x = new BN(xbuf)

  // overflow
  if (x.cmp(ecparams.p) >= 0) return null
  x = x.toRed(ecparams.red)

  // compute corresponding Y
  let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt()
  if ((first === 0x03) !== y.isOdd()) y = y.redNeg()

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadUncompressedPublicKey (first, xbuf, ybuf) {
  let x = new BN(xbuf)
  let y = new BN(ybuf)

  // overflow
  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null

  x = x.toRed(ecparams.red)
  y = y.toRed(ecparams.red)

  // is odd flag
  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null

  // x*x*x + b = y*y
  const x3 = x.redSqr().redIMul(x)
  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadPublicKey (pubkey) {
  // length should be validated in interface
  const first = pubkey[0]
  switch (first) {
    case 0x02:
    case 0x03:
      if (pubkey.length !== 33) return null
      return loadCompressedPublicKey(first, pubkey.subarray(1, 33))
    case 0x04:
    case 0x06:
    case 0x07:
      if (pubkey.length !== 65) return null
      return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65))
    default:
      return null
  }
}

function savePublicKey (output, point) {
  const pubkey = point.encode(null, output.length === 33)
  // Loop should be faster because we do not need create extra Uint8Array
  // output.set(new Uint8Array(pubkey))
  for (let i = 0; i < output.length; ++i) output[i] = pubkey[i]
}

module.exports = {
  contextRandomize () {
    return 0
  },

  privateKeyVerify (seckey) {
    const bn = new BN(seckey)
    return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1
  },

  privateKeyNegate (seckey) {
    const bn = new BN(seckey)
    const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, 'be', 32)
    seckey.set(negate)
    return 0
  },

  privateKeyTweakAdd (seckey, tweak) {
    const bn = new BN(tweak)
    if (bn.cmp(ecparams.n) >= 0) return 1

    bn.iadd(new BN(seckey))
    if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n)
    if (bn.isZero()) return 1

    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32)
    seckey.set(tweaked)

    return 0
  },

  privateKeyTweakMul (seckey, tweak) {
    let bn = new BN(tweak)
    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1

    bn.imul(new BN(seckey))
    if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n)

    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32)
    seckey.set(tweaked)

    return 0
  },

  publicKeyVerify (pubkey) {
    const pair = loadPublicKey(pubkey)
    return pair === null ? 1 : 0
  },

  publicKeyCreate (output, seckey) {
    const bn = new BN(seckey)
    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1

    const point = ec.keyFromPrivate(seckey).getPublic()
    savePublicKey(output, point)

    return 0
  },

  publicKeyConvert (output, pubkey) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    const point = pair.getPublic()
    savePublicKey(output, point)

    return 0
  },

  publicKeyNegate (output, pubkey) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    const point = pair.getPublic()
    point.y = point.y.redNeg()
    savePublicKey(output, point)

    return 0
  },

  publicKeyCombine (output, pubkeys) {
    const pairs = new Array(pubkeys.length)
    for (let i = 0; i < pubkeys.length; ++i) {
      pairs[i] = loadPublicKey(pubkeys[i])
      if (pairs[i] === null) return 1
    }

    let point = pairs[0].getPublic()
    for (let i = 1; i < pairs.length; ++i) point = point.add(pairs[i].pub)
    if (point.isInfinity()) return 2

    savePublicKey(output, point)

    return 0
  },

  publicKeyTweakAdd (output, pubkey, tweak) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    tweak = new BN(tweak)
    if (tweak.cmp(ecparams.n) >= 0) return 2

    const point = pair.getPublic().add(ecparams.g.mul(tweak))
    if (point.isInfinity()) return 2

    savePublicKey(output, point)

    return 0
  },

  publicKeyTweakMul (output, pubkey, tweak) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    tweak = new BN(tweak)
    if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2

    const point = pair.getPublic().mul(tweak)
    savePublicKey(output, point)

    return 0
  },

  signatureNormalize (sig) {
    const r = new BN(sig.subarray(0, 32))
    const s = new BN(sig.subarray(32, 64))
    if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1

    if (s.cmp(ec.nh) === 1) {
      sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, 'be', 32), 32)
    }

    return 0
  },

  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
  // Adapted for Uint8Array instead Buffer
  signatureExport (obj, sig) {
    const sigR = sig.subarray(0, 32)
    const sigS = sig.subarray(32, 64)
    if (new BN(sigR).cmp(ecparams.n) >= 0) return 1
    if (new BN(sigS).cmp(ecparams.n) >= 0) return 1

    const { output } = obj

    // Prepare R
    let r = output.subarray(4, 4 + 33)
    r[0] = 0x00
    r.set(sigR, 1)

    let lenR = 33
    let posR = 0
    for (; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);

    r = r.subarray(posR)
    if (r[0] & 0x80) return 1
    if (lenR > 1 && (r[0] === 0x00) && !(r[1] & 0x80)) return 1

    // Prepare S
    let s = output.subarray(6 + 33, 6 + 33 + 33)
    s[0] = 0x00
    s.set(sigS, 1)

    let lenS = 33
    let posS = 0
    for (; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);

    s = s.subarray(posS)
    if (s[0] & 0x80) return 1
    if (lenS > 1 && (s[0] === 0x00) && !(s[1] & 0x80)) return 1

    // Set output length for return
    obj.outputlen = 6 + lenR + lenS

    // Output in specified format
    // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
    output[0] = 0x30
    output[1] = obj.outputlen - 2
    output[2] = 0x02
    output[3] = r.length
    output.set(r, 4)
    output[4 + lenR] = 0x02
    output[5 + lenR] = s.length
    output.set(s, 6 + lenR)

    return 0
  },

  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
  // Adapted for Uint8Array instead Buffer
  signatureImport (output, sig) {
    if (sig.length < 8) return 1
    if (sig.length > 72) return 1
    if (sig[0] !== 0x30) return 1
    if (sig[1] !== sig.length - 2) return 1
    if (sig[2] !== 0x02) return 1

    const lenR = sig[3]
    if (lenR === 0) return 1
    if (5 + lenR >= sig.length) return 1
    if (sig[4 + lenR] !== 0x02) return 1

    const lenS = sig[5 + lenR]
    if (lenS === 0) return 1
    if ((6 + lenR + lenS) !== sig.length) return 1

    if (sig[4] & 0x80) return 1
    if (lenR > 1 && (sig[4] === 0x00) && !(sig[5] & 0x80)) return 1

    if (sig[lenR + 6] & 0x80) return 1
    if (lenS > 1 && (sig[lenR + 6] === 0x00) && !(sig[lenR + 7] & 0x80)) return 1

    let sigR = sig.subarray(4, 4 + lenR)
    if (sigR.length === 33 && sigR[0] === 0x00) sigR = sigR.subarray(1)
    if (sigR.length > 32) return 1

    let sigS = sig.subarray(6 + lenR)
    if (sigS.length === 33 && sigS[0] === 0x00) sigS = sigS.slice(1)
    if (sigS.length > 32) throw new Error('S length is too long')

    let r = new BN(sigR)
    if (r.cmp(ecparams.n) >= 0) r = new BN(0)

    let s = new BN(sig.subarray(6 + lenR))
    if (s.cmp(ecparams.n) >= 0) s = new BN(0)

    output.set(r.toArrayLike(Uint8Array, 'be', 32), 0)
    output.set(s.toArrayLike(Uint8Array, 'be', 32), 32)

    return 0
  },

  ecdsaSign (obj, message, seckey, data, noncefn) {
    if (noncefn) {
      const _noncefn = noncefn
      noncefn = (counter) => {
        const nonce = _noncefn(message, seckey, null, data, counter)

        const isValid = nonce instanceof Uint8Array && nonce.length === 32
        if (!isValid) throw new Error('This is the way')

        return new BN(nonce)
      }
    }

    const d = new BN(seckey)
    if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1

    let sig
    try {
      sig = ec.sign(message, seckey, { canonical: true, k: noncefn, pers: data })
    } catch (err) {
      return 1
    }

    obj.signature.set(sig.r.toArrayLike(Uint8Array, 'be', 32), 0)
    obj.signature.set(sig.s.toArrayLike(Uint8Array, 'be', 32), 32)
    obj.recid = sig.recoveryParam

    return 0
  },

  ecdsaVerify (sig, msg32, pubkey) {
    const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) }

    const sigr = new BN(sigObj.r)
    const sigs = new BN(sigObj.s)
    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1
    if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3

    const pair = loadPublicKey(pubkey)
    if (pair === null) return 2

    const point = pair.getPublic()
    const isValid = ec.verify(msg32, sigObj, point)
    return isValid ? 0 : 3
  },

  ecdsaRecover (output, sig, recid, msg32) {
    const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) }

    const sigr = new BN(sigObj.r)
    const sigs = new BN(sigObj.s)
    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1

    if (sigr.isZero() || sigs.isZero()) return 2

    // Can throw `throw new Error('Unable to find sencond key candinate');`
    let point
    try {
      point = ec.recoverPubKey(msg32, sigObj, recid)
    } catch (err) {
      return 2
    }

    savePublicKey(output, point)

    return 0
  },

  ecdh (output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    const scalar = new BN(seckey)
    if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2

    const point = pair.getPublic().mul(scalar)

    if (hashfn === undefined) {
      const data = point.encode(null, true)
      const sha256 = ec.hash().update(data).digest()
      for (let i = 0; i < 32; ++i) output[i] = sha256[i]
    } else {
      if (!xbuf) xbuf = new Uint8Array(32)
      const x = point.getX().toArray('be', 32)
      for (let i = 0; i < 32; ++i) xbuf[i] = x[i]

      if (!ybuf) ybuf = new Uint8Array(32)
      const y = point.getY().toArray('be', 32)
      for (let i = 0; i < 32; ++i) ybuf[i] = y[i]

      const hash = hashfn(xbuf, ybuf, data)

      const isValid = hash instanceof Uint8Array && hash.length === output.length
      if (!isValid) return 2

      output.set(hash)
    }

    return 0
  }
}

      };
    };
  }
}, {package:"secp256k1",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/node_modules/secp256k1/lib/elliptic.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/tagged.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/tagged.js
      return function (require, module, exports) {
'use strict'

/**
 * A CBOR tagged item, where the tag does not have semantics specified at the
 * moment, or those semantics threw an error during parsing. Typically this will
 * be an extension point you're not yet expecting.
 */
class Tagged {
  /**
   * Creates an instance of Tagged.
   *
   * @param {Number} tag - the number of the tag
   * @param {any} value - the value inside the tag
   * @param {Error} err - the error that was thrown parsing the tag, or null
   */
  constructor (tag, value, err) {
    this.tag = tag
    this.value = value
    this.err = err
    if (typeof this.tag !== 'number') {
      throw new Error('Invalid tag type (' + (typeof this.tag) + ')')
    }
    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {
      throw new Error('Tag must be a positive integer: ' + this.tag)
    }
  }

  /**
   * Convert to a String
   *
   * @returns {String} string of the form '1(2)'
   */
  toString () {
    return `${this.tag}(${JSON.stringify(this.value)})`
  }

  /**
   * Push the simple value onto the CBOR stream
   *
   * @param {cbor.Encoder} gen The generator to push onto
   * @returns {number}
   */
  encodeCBOR (gen) {
    gen._pushTag(this.tag)
    return gen.pushAny(this.value)
  }

  /**
   * If we have a converter for this type, do the conversion.  Some converters
   * are built-in.  Additional ones can be passed in.  If you want to remove
   * a built-in converter, pass a converter in whose value is 'null' instead
   * of a function.
   *
   * @param {Object} converters - keys in the object are a tag number, the value
   *   is a function that takes the decoded CBOR and returns a JavaScript value
   *   of the appropriate type.  Throw an exception in the function on errors.
   * @returns {any} - the converted item
   */
  convert (converters) {
    var er, f
    f = converters != null ? converters[this.tag] : undefined
    if (typeof f !== 'function') {
      f = Tagged['_tag' + this.tag]
      if (typeof f !== 'function') {
        return this
      }
    }
    try {
      return f.call(Tagged, this.value)
    } catch (error) {
      er = error
      this.err = er
      return this
    }
  }
}

module.exports = Tagged

      };
    };
  }
}, {package:"borc",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/tagged.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/simple.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/constants.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/simple.js
      return function (require, module, exports) {
'use strict'

const constants = require('./constants')
const MT = constants.MT
const SIMPLE = constants.SIMPLE
const SYMS = constants.SYMS

/**
 * A CBOR Simple Value that does not map onto a known constant.
 */
class Simple {
  /**
   * Creates an instance of Simple.
   *
   * @param {integer} value - the simple value's integer value
   */
  constructor (value) {
    if (typeof value !== 'number') {
      throw new Error('Invalid Simple type: ' + (typeof value))
    }
    if ((value < 0) || (value > 255) || ((value | 0) !== value)) {
      throw new Error('value must be a small positive integer: ' + value)
    }
    this.value = value
  }

  /**
   * Debug string for simple value
   *
   * @returns {string} simple(value)
   */
  toString () {
    return 'simple(' + this.value + ')'
  }

  /**
   * Debug string for simple value
   *
   * @returns {string} simple(value)
   */
  inspect () {
    return 'simple(' + this.value + ')'
  }

  /**
   * Push the simple value onto the CBOR stream
   *
   * @param {cbor.Encoder} gen The generator to push onto
   * @returns {number}
   */
  encodeCBOR (gen) {
    return gen._pushInt(this.value, MT.SIMPLE_FLOAT)
  }

  /**
   * Is the given object a Simple?
   *
   * @param {any} obj - object to test
   * @returns {bool} - is it Simple?
   */
  static isSimple (obj) {
    return obj instanceof Simple
  }

  /**
   * Decode from the CBOR additional information into a JavaScript value.
   * If the CBOR item has no parent, return a "safe" symbol instead of
   * `null` or `undefined`, so that the value can be passed through a
   * stream in object mode.
   *
   * @param {Number} val - the CBOR additional info to convert
   * @param {bool} hasParent - Does the CBOR item have a parent?
   * @returns {(null|undefined|Boolean|Symbol)} - the decoded value
   */
  static decode (val, hasParent) {
    if (hasParent == null) {
      hasParent = true
    }
    switch (val) {
      case SIMPLE.FALSE:
        return false
      case SIMPLE.TRUE:
        return true
      case SIMPLE.NULL:
        if (hasParent) {
          return null
        } else {
          return SYMS.NULL
        }
      case SIMPLE.UNDEFINED:
        if (hasParent) {
          return undefined
        } else {
          return SYMS.UNDEFINED
        }
      case -1:
        if (!hasParent) {
          throw new Error('Invalid BREAK')
        }
        return SYMS.BREAK
      default:
        return new Simple(val)
    }
  }
}

module.exports = Simple

      };
    };
  }
}, {package:"borc",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/simple.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/decoder.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/constants.js","./decoder.asm":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/decoder.asm.js","./simple":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/simple.js","./tagged":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/tagged.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/utils.js","bignumber.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/node_modules/bignumber.js/bignumber.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ieee754":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ieee754/index.js","iso-url":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/iso-url/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/decoder.js
      return function (require, module, exports) {
'use strict'

const { Buffer } = require('buffer')
const ieee754 = require('ieee754')
const Bignumber = require('bignumber.js').BigNumber

const parser = require('./decoder.asm')
const utils = require('./utils')
const c = require('./constants')
const Simple = require('./simple')
const Tagged = require('./tagged')
const { URL } = require('iso-url')

/**
 * Transform binary cbor data into JavaScript objects.
 */
class Decoder {
  /**
   * @param {Object} [opts={}]
   * @param {number} [opts.size=65536] - Size of the allocated heap.
   */
  constructor (opts) {
    opts = opts || {}

    if (!opts.size || opts.size < 0x10000) {
      opts.size = 0x10000
    } else {
      // Ensure the size is a power of 2
      opts.size = utils.nextPowerOf2(opts.size)
    }

    // Heap use to share the input with the parser
    this._heap = new ArrayBuffer(opts.size)
    this._heap8 = new Uint8Array(this._heap)
    this._buffer = Buffer.from(this._heap)

    this._reset()

    // Known tags
    this._knownTags = Object.assign({
      0: (val) => new Date(val),
      1: (val) => new Date(val * 1000),
      2: (val) => utils.arrayBufferToBignumber(val),
      3: (val) => c.NEG_ONE.minus(utils.arrayBufferToBignumber(val)),
      4: (v) => {
        // const v = new Uint8Array(val)
        return c.TEN.pow(v[0]).times(v[1])
      },
      5: (v) => {
        // const v = new Uint8Array(val)
        return c.TWO.pow(v[0]).times(v[1])
      },
      32: (val) => new URL(val),
      35: (val) => new RegExp(val)
    }, opts.tags)

    // Initialize asm based parser
    this.parser = parser(global, {
      // eslint-disable-next-line no-console
      log: console.log.bind(console),
      pushInt: this.pushInt.bind(this),
      pushInt32: this.pushInt32.bind(this),
      pushInt32Neg: this.pushInt32Neg.bind(this),
      pushInt64: this.pushInt64.bind(this),
      pushInt64Neg: this.pushInt64Neg.bind(this),
      pushFloat: this.pushFloat.bind(this),
      pushFloatSingle: this.pushFloatSingle.bind(this),
      pushFloatDouble: this.pushFloatDouble.bind(this),
      pushTrue: this.pushTrue.bind(this),
      pushFalse: this.pushFalse.bind(this),
      pushUndefined: this.pushUndefined.bind(this),
      pushNull: this.pushNull.bind(this),
      pushInfinity: this.pushInfinity.bind(this),
      pushInfinityNeg: this.pushInfinityNeg.bind(this),
      pushNaN: this.pushNaN.bind(this),
      pushNaNNeg: this.pushNaNNeg.bind(this),
      pushArrayStart: this.pushArrayStart.bind(this),
      pushArrayStartFixed: this.pushArrayStartFixed.bind(this),
      pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this),
      pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this),
      pushObjectStart: this.pushObjectStart.bind(this),
      pushObjectStartFixed: this.pushObjectStartFixed.bind(this),
      pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this),
      pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this),
      pushByteString: this.pushByteString.bind(this),
      pushByteStringStart: this.pushByteStringStart.bind(this),
      pushUtf8String: this.pushUtf8String.bind(this),
      pushUtf8StringStart: this.pushUtf8StringStart.bind(this),
      pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this),
      pushTagUnassigned: this.pushTagUnassigned.bind(this),
      pushTagStart: this.pushTagStart.bind(this),
      pushTagStart4: this.pushTagStart4.bind(this),
      pushTagStart8: this.pushTagStart8.bind(this),
      pushBreak: this.pushBreak.bind(this)
    }, this._heap)
  }

  get _depth () {
    return this._parents.length
  }

  get _currentParent () {
    return this._parents[this._depth - 1]
  }

  get _ref () {
    return this._currentParent.ref
  }

  // Finish the current parent
  _closeParent () {
    var p = this._parents.pop()

    if (p.length > 0) {
      throw new Error(`Missing ${p.length} elements`)
    }

    switch (p.type) {
      case c.PARENT.TAG:
        this._push(
          this.createTag(p.ref[0], p.ref[1])
        )
        break
      case c.PARENT.BYTE_STRING:
        this._push(this.createByteString(p.ref, p.length))
        break
      case c.PARENT.UTF8_STRING:
        this._push(this.createUtf8String(p.ref, p.length))
        break
      case c.PARENT.MAP:
        if (p.values % 2 > 0) {
          throw new Error('Odd number of elements in the map')
        }
        this._push(this.createMap(p.ref, p.length))
        break
      case c.PARENT.OBJECT:
        if (p.values % 2 > 0) {
          throw new Error('Odd number of elements in the map')
        }
        this._push(this.createObject(p.ref, p.length))
        break
      case c.PARENT.ARRAY:
        this._push(this.createArray(p.ref, p.length))
        break
      default:
        break
    }

    if (this._currentParent && this._currentParent.type === c.PARENT.TAG) {
      this._dec()
    }
  }

  // Reduce the expected length of the current parent by one
  _dec () {
    const p = this._currentParent
    // The current parent does not know the epxected child length

    if (p.length < 0) {
      return
    }

    p.length--

    // All children were seen, we can close the current parent
    if (p.length === 0) {
      this._closeParent()
    }
  }

  // Push any value to the current parent
  _push (val, hasChildren) {
    const p = this._currentParent
    p.values++

    switch (p.type) {
      case c.PARENT.ARRAY:
      case c.PARENT.BYTE_STRING:
      case c.PARENT.UTF8_STRING:
        if (p.length > -1) {
          this._ref[this._ref.length - p.length] = val
        } else {
          this._ref.push(val)
        }
        this._dec()
        break
      case c.PARENT.OBJECT:
        if (p.tmpKey != null) {
          this._ref[p.tmpKey] = val
          p.tmpKey = null
          this._dec()
        } else {
          p.tmpKey = val

          if (typeof p.tmpKey !== 'string') {
            // too bad, convert to a Map
            p.type = c.PARENT.MAP
            p.ref = utils.buildMap(p.ref)
          }
        }
        break
      case c.PARENT.MAP:
        if (p.tmpKey != null) {
          this._ref.set(p.tmpKey, val)
          p.tmpKey = null
          this._dec()
        } else {
          p.tmpKey = val
        }
        break
      case c.PARENT.TAG:
        this._ref.push(val)
        if (!hasChildren) {
          this._dec()
        }
        break
      default:
        throw new Error('Unknown parent type')
    }
  }

  // Create a new parent in the parents list
  _createParent (obj, type, len) {
    this._parents[this._depth] = {
      type: type,
      length: len,
      ref: obj,
      values: 0,
      tmpKey: null
    }
  }

  // Reset all state back to the beginning, also used for initiatlization
  _reset () {
    this._res = []
    this._parents = [{
      type: c.PARENT.ARRAY,
      length: -1,
      ref: this._res,
      values: 0,
      tmpKey: null
    }]
  }

  // -- Interface to customize deoding behaviour
  createTag (tagNumber, value) {
    const typ = this._knownTags[tagNumber]

    if (!typ) {
      return new Tagged(tagNumber, value)
    }

    return typ(value)
  }

  createMap (obj, len) {
    return obj
  }

  createObject (obj, len) {
    return obj
  }

  createArray (arr, len) {
    return arr
  }

  createByteString (raw, len) {
    return Buffer.concat(raw)
  }

  createByteStringFromHeap (start, end) {
    if (start === end) {
      return Buffer.alloc(0)
    }

    return Buffer.from(this._heap.slice(start, end))
  }

  createInt (val) {
    return val
  }

  createInt32 (f, g) {
    return utils.buildInt32(f, g)
  }

  createInt64 (f1, f2, g1, g2) {
    return utils.buildInt64(f1, f2, g1, g2)
  }

  createFloat (val) {
    return val
  }

  createFloatSingle (a, b, c, d) {
    return ieee754.read([a, b, c, d], 0, false, 23, 4)
  }

  createFloatDouble (a, b, c, d, e, f, g, h) {
    return ieee754.read([a, b, c, d, e, f, g, h], 0, false, 52, 8)
  }

  createInt32Neg (f, g) {
    return -1 - utils.buildInt32(f, g)
  }

  createInt64Neg (f1, f2, g1, g2) {
    const f = utils.buildInt32(f1, f2)
    const g = utils.buildInt32(g1, g2)

    if (f > c.MAX_SAFE_HIGH) {
      return c.NEG_ONE.minus(new Bignumber(f).times(c.SHIFT32).plus(g))
    }

    return -1 - ((f * c.SHIFT32) + g)
  }

  createTrue () {
    return true
  }

  createFalse () {
    return false
  }

  createNull () {
    return null
  }

  createUndefined () {
    return undefined
  }

  createInfinity () {
    return Infinity
  }

  createInfinityNeg () {
    return -Infinity
  }

  createNaN () {
    return NaN
  }

  createNaNNeg () {
    return -NaN
  }

  createUtf8String (raw, len) {
    return raw.join('')
  }

  createUtf8StringFromHeap (start, end) {
    if (start === end) {
      return ''
    }

    return this._buffer.toString('utf8', start, end)
  }

  createSimpleUnassigned (val) {
    return new Simple(val)
  }

  // -- Interface for decoder.asm.js

  pushInt (val) {
    this._push(this.createInt(val))
  }

  pushInt32 (f, g) {
    this._push(this.createInt32(f, g))
  }

  pushInt64 (f1, f2, g1, g2) {
    this._push(this.createInt64(f1, f2, g1, g2))
  }

  pushFloat (val) {
    this._push(this.createFloat(val))
  }

  pushFloatSingle (a, b, c, d) {
    this._push(this.createFloatSingle(a, b, c, d))
  }

  pushFloatDouble (a, b, c, d, e, f, g, h) {
    this._push(this.createFloatDouble(a, b, c, d, e, f, g, h))
  }

  pushInt32Neg (f, g) {
    this._push(this.createInt32Neg(f, g))
  }

  pushInt64Neg (f1, f2, g1, g2) {
    this._push(this.createInt64Neg(f1, f2, g1, g2))
  }

  pushTrue () {
    this._push(this.createTrue())
  }

  pushFalse () {
    this._push(this.createFalse())
  }

  pushNull () {
    this._push(this.createNull())
  }

  pushUndefined () {
    this._push(this.createUndefined())
  }

  pushInfinity () {
    this._push(this.createInfinity())
  }

  pushInfinityNeg () {
    this._push(this.createInfinityNeg())
  }

  pushNaN () {
    this._push(this.createNaN())
  }

  pushNaNNeg () {
    this._push(this.createNaNNeg())
  }

  pushArrayStart () {
    this._createParent([], c.PARENT.ARRAY, -1)
  }

  pushArrayStartFixed (len) {
    this._createArrayStartFixed(len)
  }

  pushArrayStartFixed32 (len1, len2) {
    const len = utils.buildInt32(len1, len2)
    this._createArrayStartFixed(len)
  }

  pushArrayStartFixed64 (len1, len2, len3, len4) {
    const len = utils.buildInt64(len1, len2, len3, len4)
    this._createArrayStartFixed(len)
  }

  pushObjectStart () {
    this._createObjectStartFixed(-1)
  }

  pushObjectStartFixed (len) {
    this._createObjectStartFixed(len)
  }

  pushObjectStartFixed32 (len1, len2) {
    const len = utils.buildInt32(len1, len2)
    this._createObjectStartFixed(len)
  }

  pushObjectStartFixed64 (len1, len2, len3, len4) {
    const len = utils.buildInt64(len1, len2, len3, len4)
    this._createObjectStartFixed(len)
  }

  pushByteStringStart () {
    this._parents[this._depth] = {
      type: c.PARENT.BYTE_STRING,
      length: -1,
      ref: [],
      values: 0,
      tmpKey: null
    }
  }

  pushByteString (start, end) {
    this._push(this.createByteStringFromHeap(start, end))
  }

  pushUtf8StringStart () {
    this._parents[this._depth] = {
      type: c.PARENT.UTF8_STRING,
      length: -1,
      ref: [],
      values: 0,
      tmpKey: null
    }
  }

  pushUtf8String (start, end) {
    this._push(this.createUtf8StringFromHeap(start, end))
  }

  pushSimpleUnassigned (val) {
    this._push(this.createSimpleUnassigned(val))
  }

  pushTagStart (tag) {
    this._parents[this._depth] = {
      type: c.PARENT.TAG,
      length: 1,
      ref: [tag]
    }
  }

  pushTagStart4 (f, g) {
    this.pushTagStart(utils.buildInt32(f, g))
  }

  pushTagStart8 (f1, f2, g1, g2) {
    this.pushTagStart(utils.buildInt64(f1, f2, g1, g2))
  }

  pushTagUnassigned (tagNumber) {
    this._push(this.createTag(tagNumber))
  }

  pushBreak () {
    if (this._currentParent.length > -1) {
      throw new Error('Unexpected break')
    }

    this._closeParent()
  }

  _createObjectStartFixed (len) {
    if (len === 0) {
      this._push(this.createObject({}))
      return
    }

    this._createParent({}, c.PARENT.OBJECT, len)
  }

  _createArrayStartFixed (len) {
    if (len === 0) {
      this._push(this.createArray([]))
      return
    }

    this._createParent(new Array(len), c.PARENT.ARRAY, len)
  }

  _decode (input) {
    if (input.byteLength === 0) {
      throw new Error('Input too short')
    }

    this._reset()
    this._heap8.set(input)
    const code = this.parser.parse(input.byteLength)

    if (this._depth > 1) {
      while (this._currentParent.length === 0) {
        this._closeParent()
      }
      if (this._depth > 1) {
        throw new Error('Undeterminated nesting')
      }
    }

    if (code > 0) {
      throw new Error('Failed to parse')
    }

    if (this._res.length === 0) {
      throw new Error('No valid result')
    }
  }

  // -- Public Interface

  decodeFirst (input) {
    this._decode(input)

    return this._res[0]
  }

  decodeAll (input) {
    this._decode(input)

    return this._res
  }

  /**
   * Decode the first cbor object.
   *
   * @param {Buffer|string} input
   * @param {string} [enc='hex'] - Encoding used if a string is passed.
   * @returns {*}
   */
  static decode (input, enc) {
    if (typeof input === 'string') {
      input = Buffer.from(input, enc || 'hex')
    }

    const dec = new Decoder({ size: input.length })
    return dec.decodeFirst(input)
  }

  /**
   * Decode all cbor objects.
   *
   * @param {Buffer|string} input
   * @param {string} [enc='hex'] - Encoding used if a string is passed.
   * @returns {Array<*>}
   */
  static decodeAll (input, enc) {
    if (typeof input === 'string') {
      input = Buffer.from(input, enc || 'hex')
    }

    const dec = new Decoder({ size: input.length })
    return dec.decodeAll(input)
  }
}

Decoder.decodeFirst = Decoder.decode

module.exports = Decoder

      };
    };
  }
}, {package:"borc",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/decoder.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/diagnose.js", {"./decoder":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/decoder.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/utils.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/diagnose.js
      return function (require, module, exports) {
'use strict'

const { Buffer } = require('buffer')
const Decoder = require('./decoder')
const utils = require('./utils')

/**
 * Output the diagnostic format from a stream of CBOR bytes.
 *
 */
class Diagnose extends Decoder {
  createTag (tagNumber, value) {
    return `${tagNumber}(${value})`
  }

  createInt (val) {
    return super.createInt(val).toString()
  }

  createInt32 (f, g) {
    return super.createInt32(f, g).toString()
  }

  createInt64 (f1, f2, g1, g2) {
    return super.createInt64(f1, f2, g1, g2).toString()
  }

  createInt32Neg (f, g) {
    return super.createInt32Neg(f, g).toString()
  }

  createInt64Neg (f1, f2, g1, g2) {
    return super.createInt64Neg(f1, f2, g1, g2).toString()
  }

  createTrue () {
    return 'true'
  }

  createFalse () {
    return 'false'
  }

  createFloat (val) {
    const fl = super.createFloat(val)
    if (utils.isNegativeZero(val)) {
      return '-0_1'
    }

    return `${fl}_1`
  }

  createFloatSingle (a, b, c, d) {
    const fl = super.createFloatSingle(a, b, c, d)
    return `${fl}_2`
  }

  createFloatDouble (a, b, c, d, e, f, g, h) {
    const fl = super.createFloatDouble(a, b, c, d, e, f, g, h)
    return `${fl}_3`
  }

  createByteString (raw, len) {
    const val = raw.join(', ')

    if (len === -1) {
      return `(_ ${val})`
    }
    return `h'${val}`
  }

  createByteStringFromHeap (start, end) {
    const val = (Buffer.from(
      super.createByteStringFromHeap(start, end)
    )).toString('hex')

    return `h'${val}'`
  }

  createInfinity () {
    return 'Infinity_1'
  }

  createInfinityNeg () {
    return '-Infinity_1'
  }

  createNaN () {
    return 'NaN_1'
  }

  createNaNNeg () {
    return '-NaN_1'
  }

  createNull () {
    return 'null'
  }

  createUndefined () {
    return 'undefined'
  }

  createSimpleUnassigned (val) {
    return `simple(${val})`
  }

  createArray (arr, len) {
    const val = super.createArray(arr, len)

    if (len === -1) {
      // indefinite
      return `[_ ${val.join(', ')}]`
    }

    return `[${val.join(', ')}]`
  }

  createMap (map, len) {
    const val = super.createMap(map)
    const list = Array.from(val.keys())
      .reduce(collectObject(val), '')

    if (len === -1) {
      return `{_ ${list}}`
    }

    return `{${list}}`
  }

  createObject (obj, len) {
    const val = super.createObject(obj)
    const map = Object.keys(val)
      .reduce(collectObject(val), '')

    if (len === -1) {
      return `{_ ${map}}`
    }

    return `{${map}}`
  }

  createUtf8String (raw, len) {
    const val = raw.join(', ')

    if (len === -1) {
      return `(_ ${val})`
    }

    return `"${val}"`
  }

  createUtf8StringFromHeap (start, end) {
    const val = (Buffer.from(
      super.createUtf8StringFromHeap(start, end)
    )).toString('utf8')

    return `"${val}"`
  }

  static diagnose (input, enc) {
    if (typeof input === 'string') {
      input = Buffer.from(input, enc || 'hex')
    }

    const dec = new Diagnose()
    return dec.decodeFirst(input)
  }
}

module.exports = Diagnose

function collectObject (val) {
  return (acc, key) => {
    if (acc) {
      return `${acc}, ${key}: ${val[key]}`
    }
    return `${key}: ${val[key]}`
  }
}

      };
    };
  }
}, {package:"borc",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/diagnose.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/encoder.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/constants.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/utils.js","bignumber.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/node_modules/bignumber.js/bignumber.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","iso-url":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/iso-url/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/encoder.js
      return function (require, module, exports) {
'use strict'

const { Buffer } = require('buffer')
const { URL } = require('iso-url')
const Bignumber = require('bignumber.js').BigNumber

const utils = require('./utils')
const constants = require('./constants')
const MT = constants.MT
const NUMBYTES = constants.NUMBYTES
const SHIFT32 = constants.SHIFT32
const SYMS = constants.SYMS
const TAG = constants.TAG
const HALF = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.TWO
const FLOAT = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.FOUR
const DOUBLE = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.EIGHT
const TRUE = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.TRUE
const FALSE = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.FALSE
const UNDEFINED = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.UNDEFINED
const NULL = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.NULL

const MAXINT_BN = new Bignumber('0x20000000000000')
const BUF_NAN = Buffer.from('f97e00', 'hex')
const BUF_INF_NEG = Buffer.from('f9fc00', 'hex')
const BUF_INF_POS = Buffer.from('f97c00', 'hex')

function toType (obj) {
  // [object Type]
  // --------8---1
  return ({}).toString.call(obj).slice(8, -1)
}

/**
 * Transform JavaScript values into CBOR bytes
 *
 */
class Encoder {
  /**
   * @param {Object} [options={}]
   * @param {function(Buffer)} options.stream
   */
  constructor (options) {
    options = options || {}

    this.streaming = typeof options.stream === 'function'
    this.onData = options.stream

    this.semanticTypes = [
      [URL, this._pushUrl],
      [Bignumber, this._pushBigNumber]
    ]

    const addTypes = options.genTypes || []
    const len = addTypes.length
    for (let i = 0; i < len; i++) {
      this.addSemanticType(
        addTypes[i][0],
        addTypes[i][1]
      )
    }

    this._reset()
  }

  addSemanticType (type, fun) {
    const len = this.semanticTypes.length
    for (let i = 0; i < len; i++) {
      const typ = this.semanticTypes[i][0]
      if (typ === type) {
        const old = this.semanticTypes[i][1]
        this.semanticTypes[i][1] = fun
        return old
      }
    }
    this.semanticTypes.push([type, fun])
    return null
  }

  push (val) {
    if (!val) {
      return true
    }

    this.result[this.offset] = val
    this.resultMethod[this.offset] = 0
    this.resultLength[this.offset] = val.length
    this.offset++

    if (this.streaming) {
      this.onData(this.finalize())
    }

    return true
  }

  pushWrite (val, method, len) {
    this.result[this.offset] = val
    this.resultMethod[this.offset] = method
    this.resultLength[this.offset] = len
    this.offset++

    if (this.streaming) {
      this.onData(this.finalize())
    }

    return true
  }

  _pushUInt8 (val) {
    return this.pushWrite(val, 1, 1)
  }

  _pushUInt16BE (val) {
    return this.pushWrite(val, 2, 2)
  }

  _pushUInt32BE (val) {
    return this.pushWrite(val, 3, 4)
  }

  _pushDoubleBE (val) {
    return this.pushWrite(val, 4, 8)
  }

  _pushNaN () {
    return this.push(BUF_NAN)
  }

  _pushInfinity (obj) {
    const half = (obj < 0) ? BUF_INF_NEG : BUF_INF_POS
    return this.push(half)
  }

  _pushFloat (obj) {
    const b2 = Buffer.allocUnsafe(2)

    if (utils.writeHalf(b2, obj)) {
      if (utils.parseHalf(b2) === obj) {
        return this._pushUInt8(HALF) && this.push(b2)
      }
    }

    const b4 = Buffer.allocUnsafe(4)
    b4.writeFloatBE(obj, 0)
    if (b4.readFloatBE(0) === obj) {
      return this._pushUInt8(FLOAT) && this.push(b4)
    }

    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj)
  }

  _pushInt (obj, mt, orig) {
    const m = mt << 5
    if (obj < 24) {
      return this._pushUInt8(m | obj)
    }

    if (obj <= 0xff) {
      return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj)
    }

    if (obj <= 0xffff) {
      return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj)
    }

    if (obj <= 0xffffffff) {
      return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj)
    }

    if (obj <= Number.MAX_SAFE_INTEGER) {
      return this._pushUInt8(m | NUMBYTES.EIGHT) &&
        this._pushUInt32BE(Math.floor(obj / SHIFT32)) &&
        this._pushUInt32BE(obj % SHIFT32)
    }

    if (mt === MT.NEG_INT) {
      return this._pushFloat(orig)
    }

    return this._pushFloat(obj)
  }

  _pushIntNum (obj) {
    if (obj < 0) {
      return this._pushInt(-obj - 1, MT.NEG_INT, obj)
    } else {
      return this._pushInt(obj, MT.POS_INT)
    }
  }

  _pushNumber (obj) {
    switch (false) {
      case (obj === obj): // eslint-disable-line
        return this._pushNaN(obj)
      case isFinite(obj):
        return this._pushInfinity(obj)
      case ((obj % 1) !== 0):
        return this._pushIntNum(obj)
      default:
        return this._pushFloat(obj)
    }
  }

  _pushString (obj) {
    const len = Buffer.byteLength(obj, 'utf8')
    return this._pushInt(len, MT.UTF8_STRING) && this.pushWrite(obj, 5, len)
  }

  _pushBoolean (obj) {
    return this._pushUInt8(obj ? TRUE : FALSE)
  }

  _pushUndefined (obj) {
    return this._pushUInt8(UNDEFINED)
  }

  _pushArray (gen, obj) {
    const len = obj.length
    if (!gen._pushInt(len, MT.ARRAY)) {
      return false
    }
    for (let j = 0; j < len; j++) {
      if (!gen.pushAny(obj[j])) {
        return false
      }
    }
    return true
  }

  _pushTag (tag) {
    return this._pushInt(tag, MT.TAG)
  }

  _pushDate (gen, obj) {
    // Round date, to get seconds since 1970-01-01 00:00:00 as defined in
    // Sec. 2.4.1 and get a possibly more compact encoding. Note that it is
    // still allowed to encode fractions of seconds which can be achieved by
    // changing overwriting the encode function for Date objects.
    return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(Math.round(obj / 1000))
  }

  _pushBuffer (gen, obj) {
    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj)
  }

  _pushNoFilter (gen, obj) {
    return gen._pushBuffer(gen, obj.slice())
  }

  _pushRegexp (gen, obj) {
    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source)
  }

  _pushSet (gen, obj) {
    if (!gen._pushInt(obj.size, MT.ARRAY)) {
      return false
    }
    for (const x of obj) {
      if (!gen.pushAny(x)) {
        return false
      }
    }
    return true
  }

  _pushUrl (gen, obj) {
    return gen._pushTag(TAG.URI) && gen.pushAny(obj.format())
  }

  _pushBigint (obj) {
    let tag = TAG.POS_BIGINT
    if (obj.isNegative()) {
      obj = obj.negated().minus(1)
      tag = TAG.NEG_BIGINT
    }
    let str = obj.toString(16)
    if (str.length % 2) {
      str = '0' + str
    }
    const buf = Buffer.from(str, 'hex')
    return this._pushTag(tag) && this._pushBuffer(this, buf)
  }

  _pushBigNumber (gen, obj) {
    if (obj.isNaN()) {
      return gen._pushNaN()
    }
    if (!obj.isFinite()) {
      return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity)
    }
    if (obj.isInteger()) {
      return gen._pushBigint(obj)
    }
    if (!(gen._pushTag(TAG.DECIMAL_FRAC) &&
      gen._pushInt(2, MT.ARRAY))) {
      return false
    }

    const dec = obj.decimalPlaces()
    const slide = obj.multipliedBy(new Bignumber(10).pow(dec))
    if (!gen._pushIntNum(-dec)) {
      return false
    }
    if (slide.abs().isLessThan(MAXINT_BN)) {
      return gen._pushIntNum(slide.toNumber())
    } else {
      return gen._pushBigint(slide)
    }
  }

  _pushMap (gen, obj) {
    if (!gen._pushInt(obj.size, MT.MAP)) {
      return false
    }

    return this._pushRawMap(
      obj.size,
      Array.from(obj)
    )
  }

  _pushObject (obj) {
    if (!obj) {
      return this._pushUInt8(NULL)
    }

    var len = this.semanticTypes.length
    for (var i = 0; i < len; i++) {
      if (obj instanceof this.semanticTypes[i][0]) {
        return this.semanticTypes[i][1].call(obj, this, obj)
      }
    }

    var f = obj.encodeCBOR
    if (typeof f === 'function') {
      return f.call(obj, this)
    }

    var keys = Object.keys(obj)
    var keyLength = keys.length
    if (!this._pushInt(keyLength, MT.MAP)) {
      return false
    }

    return this._pushRawMap(
      keyLength,
      keys.map((k) => [k, obj[k]])
    )
  }

  _pushRawMap (len, map) {
    // Sort keys for canoncialization
    // 1. encode key
    // 2. shorter key comes before longer key
    // 3. same length keys are sorted with lower
    //    byte value before higher

    map = map.map(function (a) {
      a[0] = Encoder.encode(a[0])
      return a
    }).sort(utils.keySorter)

    for (var j = 0; j < len; j++) {
      if (!this.push(map[j][0])) {
        return false
      }

      if (!this.pushAny(map[j][1])) {
        return false
      }
    }

    return true
  }

  /**
   * Alias for `.pushAny`
   *
   * @param {*} obj
   * @returns {boolean} true on success
   */
  write (obj) {
    return this.pushAny(obj)
  }

  /**
   * Push any supported type onto the encoded stream
   *
   * @param {any} obj
   * @returns {boolean} true on success
   */
  pushAny (obj) {
    var typ = toType(obj)

    switch (typ) {
      case 'Number':
        return this._pushNumber(obj)
      case 'String':
        return this._pushString(obj)
      case 'Boolean':
        return this._pushBoolean(obj)
      case 'Object':
        return this._pushObject(obj)
      case 'Array':
        return this._pushArray(this, obj)
      case 'Uint8Array':
        return this._pushBuffer(this, Buffer.isBuffer(obj) ? obj : Buffer.from(obj))
      case 'Null':
        return this._pushUInt8(NULL)
      case 'Undefined':
        return this._pushUndefined(obj)
      case 'Map':
        return this._pushMap(this, obj)
      case 'Set':
        return this._pushSet(this, obj)
      case 'URL':
        return this._pushUrl(this, obj)
      case 'BigNumber':
        return this._pushBigNumber(this, obj)
      case 'Date':
        return this._pushDate(this, obj)
      case 'RegExp':
        return this._pushRegexp(this, obj)
      case 'Symbol':
        switch (obj) {
          case SYMS.NULL:
            return this._pushObject(null)
          case SYMS.UNDEFINED:
            return this._pushUndefined(undefined)
          // TODO: Add pluggable support for other symbols
          default:
            throw new Error('Unknown symbol: ' + obj.toString())
        }
      default:
        throw new Error('Unknown type: ' + typeof obj + ', ' + (obj ? obj.toString() : ''))
    }
  }

  finalize () {
    if (this.offset === 0) {
      return null
    }

    var result = this.result
    var resultLength = this.resultLength
    var resultMethod = this.resultMethod
    var offset = this.offset

    // Determine the size of the buffer
    var size = 0
    var i = 0

    for (; i < offset; i++) {
      size += resultLength[i]
    }

    var res = Buffer.allocUnsafe(size)
    var index = 0
    var length = 0

    // Write the content into the result buffer
    for (i = 0; i < offset; i++) {
      length = resultLength[i]

      switch (resultMethod[i]) {
        case 0:
          result[i].copy(res, index)
          break
        case 1:
          res.writeUInt8(result[i], index, true)
          break
        case 2:
          res.writeUInt16BE(result[i], index, true)
          break
        case 3:
          res.writeUInt32BE(result[i], index, true)
          break
        case 4:
          res.writeDoubleBE(result[i], index, true)
          break
        case 5:
          res.write(result[i], index, length, 'utf8')
          break
        default:
          throw new Error('unkown method')
      }

      index += length
    }

    var tmp = res

    this._reset()

    return tmp
  }

  _reset () {
    this.result = []
    this.resultMethod = []
    this.resultLength = []
    this.offset = 0
  }

  /**
   * Encode the given value
   * @param {*} o
   * @returns {Buffer}
   */
  static encode (o) {
    const enc = new Encoder()
    const ret = enc.pushAny(o)
    if (!ret) {
      throw new Error('Failed to encode input')
    }

    return enc.finalize()
  }
}

module.exports = Encoder

      };
    };
  }
}, {package:"borc",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/encoder.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/constants.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FALL_BACK_VS_CURRENCY = exports.RPC = exports.MAINNET = void 0;
exports.MAINNET = 'mainnet';
exports.RPC = 'rpc';
exports.FALL_BACK_VS_CURRENCY = 'ETH';
//# sourceMappingURL=constants.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/apis/crypto-compare.js", {"../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/apis/crypto-compare.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchExchangeRate = void 0;
const util_1 = require("../util");
function getPricingURL(currentCurrency, nativeCurrency, includeUSDRate) {
    return (`https://min-api.cryptocompare.com/data/price?fsym=` +
        `${nativeCurrency.toUpperCase()}&tsyms=${currentCurrency.toUpperCase()}` +
        `${includeUSDRate && currentCurrency.toUpperCase() !== 'USD' ? ',USD' : ''}`);
}
/**
 * Fetches the exchange rate for a given currency
 *
 * @param currency - ISO 4217 currency code
 * @param nativeCurrency - Symbol for base asset
 * @param includeUSDRate - Whether to add the USD rate to the fetch
 * @returns - Promise resolving to exchange rate for given currency
 */
function fetchExchangeRate(currency, nativeCurrency, includeUSDRate) {
    return __awaiter(this, void 0, void 0, function* () {
        const json = yield util_1.handleFetch(getPricingURL(currency, nativeCurrency, includeUSDRate));
        /*
        Example expected error response (if pair is not found)
        {
          Response: "Error",
          Message: "cccagg_or_exchange market does not exist for this coin pair (ETH-<NON_EXISTENT_TOKEN>)",
          HasWarning: false,
        }
        */
        if (json.Response === 'Error') {
            throw new Error(json.Message);
        }
        const conversionRate = Number(json[currency.toUpperCase()]);
        const usdConversionRate = Number(json.USD);
        if (!Number.isFinite(conversionRate)) {
            throw new Error(`Invalid response for ${currency.toUpperCase()}: ${json[currency.toUpperCase()]}`);
        }
        if (includeUSDRate && !Number.isFinite(usdConversionRate)) {
            throw new Error(`Invalid response for usdConversionRate: ${json.USD}`);
        }
        return {
            conversionRate,
            usdConversionRate,
        };
    });
}
exports.fetchExchangeRate = fetchExchangeRate;
//# sourceMappingURL=crypto-compare.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/apis/crypto-compare.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/message-manager/AbstractMessageManager.js", {"../BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseController.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/message-manager/AbstractMessageManager.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractMessageManager = void 0;
const events_1 = require("events");
const BaseController_1 = require("../BaseController");
/**
 * Controller in charge of managing - storing, adding, removing, updating - Messages.
 */
class AbstractMessageManager extends BaseController_1.BaseController {
    /**
     * Creates an AbstractMessageManager instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor(config, state) {
        super(config, state);
        /**
         * EventEmitter instance used to listen to specific message events
         */
        this.hub = new events_1.EventEmitter();
        /**
         * Name of this controller used during composition
         */
        this.name = 'AbstractMessageManager';
        this.defaultState = {
            unapprovedMessages: {},
            unapprovedMessagesCount: 0,
        };
        this.messages = [];
        this.initialize();
    }
    /**
     * Saves the unapproved messages, and their count to state
     *
     */
    saveMessageList() {
        const unapprovedMessages = this.getUnapprovedMessages();
        const unapprovedMessagesCount = this.getUnapprovedMessagesCount();
        this.update({ unapprovedMessages, unapprovedMessagesCount });
        this.hub.emit('updateBadge');
    }
    /**
     * Updates the status of a Message in this.messages
     *
     * @param messageId - The id of the Message to update
     * @param status - The new status of the Message
     */
    setMessageStatus(messageId, status) {
        const message = this.getMessage(messageId);
        if (!message) {
            throw new Error(`${this.name}: Message not found for id: ${messageId}.`);
        }
        message.status = status;
        this.updateMessage(message);
        this.hub.emit(`${messageId}:${status}`, message);
        if (status === 'rejected' || status === 'signed' || status === 'errored') {
            this.hub.emit(`${messageId}:finished`, message);
        }
    }
    /**
     * Sets a Message in this.messages to the passed Message if the ids are equal.
     * Then saves the unapprovedMessage list to storage
     *
     * @param message - A Message that will replace an existing Message (with the id) in this.messages
     */
    updateMessage(message) {
        const index = this.messages.findIndex((msg) => message.id === msg.id);
        /* istanbul ignore next */
        if (index !== -1) {
            this.messages[index] = message;
        }
        this.saveMessageList();
    }
    /**
     * A getter for the number of 'unapproved' Messages in this.messages
     *
     * @returns - The number of 'unapproved' Messages in this.messages
     *
     */
    getUnapprovedMessagesCount() {
        return Object.keys(this.getUnapprovedMessages()).length;
    }
    /**
     * A getter for the 'unapproved' Messages in state messages
     *
     * @returns - An index of Message ids to Messages, for all 'unapproved' Messages in this.messages
     *
     */
    getUnapprovedMessages() {
        return this.messages
            .filter((message) => message.status === 'unapproved')
            .reduce((result, message) => {
            result[message.id] = message;
            return result;
        }, {});
    }
    /**
     * Adds a passed Message to this.messages, and calls this.saveMessageList() to save
     * the unapproved Messages from that list to this.messages.
     *
     * @param {Message} message The Message to add to this.messages
     *
     */
    addMessage(message) {
        this.messages.push(message);
        this.saveMessageList();
    }
    /**
     * Returns a specified Message.
     *
     * @param messageId - The id of the Message to get
     * @returns - The Message with the id that matches the passed messageId, or undefined
     * if no Message has that id.
     *
     */
    getMessage(messageId) {
        return this.messages.find((message) => message.id === messageId);
    }
    /**
     * Approves a Message. Sets the message status via a call to this.setMessageStatusApproved,
     * and returns a promise with any the message params modified for proper signing.
     *
     * @param messageParams - The messageParams to be used when signing method is called,
     * plus data added by MetaMask
     * @returns - Promise resolving to the messageParams with the metamaskId property removed
     */
    approveMessage(messageParams) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        this.setMessageStatusApproved(messageParams.metamaskId);
        return this.prepMessageForSigning(messageParams);
    }
    /**
     * Sets a Message status to 'approved' via a call to this.setMessageStatus.
     *
     * @param messageId - The id of the Message to approve
     */
    setMessageStatusApproved(messageId) {
        this.setMessageStatus(messageId, 'approved');
    }
    /**
     * Sets a Message status to 'signed' via a call to this.setMessageStatus and updates
     * that Message in this.messages by adding the raw signature data of the signature
     * request to the Message.
     *
     * @param messageId - The id of the Message to sign
     * @param rawSig - The raw data of the signature request
     */
    setMessageStatusSigned(messageId, rawSig) {
        const message = this.getMessage(messageId);
        /* istanbul ignore if */
        if (!message) {
            return;
        }
        message.rawSig = rawSig;
        this.updateMessage(message);
        this.setMessageStatus(messageId, 'signed');
    }
    /**
     * Sets a Message status to 'rejected' via a call to this.setMessageStatus.
     *
     * @param messageId - The id of the Message to reject.
     */
    rejectMessage(messageId) {
        this.setMessageStatus(messageId, 'rejected');
    }
}
exports.AbstractMessageManager = AbstractMessageManager;
exports.default = AbstractMessageManager;
//# sourceMappingURL=AbstractMessageManager.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/message-manager/AbstractMessageManager.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/assetsUtil.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/assetsUtil.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareCollectiblesMetadata = void 0;
/**
 * Compares collectible metadata entries to any collectible entry
 * We need this method when comparing a new fetched collectible metadata, in case a entry changed to a defined value,
 * there's a need to update the collectible in state.
 *
 * @param collectibleMetadata - Collectible metadata object
 * @param collectible - Collectible object to compare with
 * @returns - Whether there are differences
 */
function compareCollectiblesMetadata(newCollectibleMetadata, collectible) {
    const keys = [
        'image',
        'backgroundColor',
        'imagePreview',
        'imageThumbnail',
        'imageOriginal',
        'animation',
        'animationOriginal',
        'externalLink',
    ];
    const differentValues = keys.reduce((value, key) => {
        if (newCollectibleMetadata[key] &&
            newCollectibleMetadata[key] !== collectible[key]) {
            return value + 1;
        }
        return value;
    }, 0);
    return differentValues > 0;
}
exports.compareCollectiblesMetadata = compareCollectiblesMetadata;
//# sourceMappingURL=assetsUtil.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/assetsUtil.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/gas/gas-util.js", {"../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/gas/gas-util.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateTimeEstimate = exports.fetchEthGasPriceEstimate = exports.fetchLegacyGasPriceEstimates = exports.fetchGasEstimates = exports.normalizeGWEIDecimalNumbers = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const util_1 = require("../util");
const makeClientIdHeader = (clientId) => ({ 'X-Client-Id': clientId });
function normalizeGWEIDecimalNumbers(n) {
    const numberAsWEIHex = util_1.gweiDecToWEIBN(n).toString(16);
    const numberAsGWEI = util_1.weiHexToGweiDec(numberAsWEIHex).toString(10);
    return numberAsGWEI;
}
exports.normalizeGWEIDecimalNumbers = normalizeGWEIDecimalNumbers;
function fetchGasEstimates(url, clientId) {
    return __awaiter(this, void 0, void 0, function* () {
        const estimates = yield util_1.handleFetch(url, clientId ? { headers: makeClientIdHeader(clientId) } : undefined);
        const normalizedEstimates = {
            estimatedBaseFee: normalizeGWEIDecimalNumbers(estimates.estimatedBaseFee),
            low: Object.assign(Object.assign({}, estimates.low), { suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxPriorityFeePerGas), suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxFeePerGas) }),
            medium: Object.assign(Object.assign({}, estimates.medium), { suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxPriorityFeePerGas), suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxFeePerGas) }),
            high: Object.assign(Object.assign({}, estimates.high), { suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxPriorityFeePerGas), suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxFeePerGas) }),
        };
        return normalizedEstimates;
    });
}
exports.fetchGasEstimates = fetchGasEstimates;
/**
 * Hit the legacy MetaSwaps gasPrices estimate api and return the low, medium
 * high values from that API.
 */
function fetchLegacyGasPriceEstimates(url, clientId) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield util_1.handleFetch(url, {
            referrer: url,
            referrerPolicy: 'no-referrer-when-downgrade',
            method: 'GET',
            mode: 'cors',
            headers: Object.assign({ 'Content-Type': 'application/json' }, (clientId && makeClientIdHeader(clientId))),
        });
        return {
            low: result.SafeGasPrice,
            medium: result.ProposeGasPrice,
            high: result.FastGasPrice,
        };
    });
}
exports.fetchLegacyGasPriceEstimates = fetchLegacyGasPriceEstimates;
function fetchEthGasPriceEstimate(ethQuery) {
    return __awaiter(this, void 0, void 0, function* () {
        const gasPrice = yield util_1.query(ethQuery, 'gasPrice');
        return {
            gasPrice: util_1.weiHexToGweiDec(gasPrice).toString(),
        };
    });
}
exports.fetchEthGasPriceEstimate = fetchEthGasPriceEstimate;
function calculateTimeEstimate(maxPriorityFeePerGas, maxFeePerGas, gasFeeEstimates) {
    const { low, medium, high, estimatedBaseFee } = gasFeeEstimates;
    const maxPriorityFeePerGasInWEI = util_1.gweiDecToWEIBN(maxPriorityFeePerGas);
    const maxFeePerGasInWEI = util_1.gweiDecToWEIBN(maxFeePerGas);
    const estimatedBaseFeeInWEI = util_1.gweiDecToWEIBN(estimatedBaseFee);
    const effectiveMaxPriorityFee = ethereumjs_util_1.BN.min(maxPriorityFeePerGasInWEI, maxFeePerGasInWEI.sub(estimatedBaseFeeInWEI));
    const lowMaxPriorityFeeInWEI = util_1.gweiDecToWEIBN(low.suggestedMaxPriorityFeePerGas);
    const mediumMaxPriorityFeeInWEI = util_1.gweiDecToWEIBN(medium.suggestedMaxPriorityFeePerGas);
    const highMaxPriorityFeeInWEI = util_1.gweiDecToWEIBN(high.suggestedMaxPriorityFeePerGas);
    let lowerTimeBound;
    let upperTimeBound;
    if (effectiveMaxPriorityFee.lt(lowMaxPriorityFeeInWEI)) {
        lowerTimeBound = null;
        upperTimeBound = 'unknown';
    }
    else if (effectiveMaxPriorityFee.gte(lowMaxPriorityFeeInWEI) &&
        effectiveMaxPriorityFee.lt(mediumMaxPriorityFeeInWEI)) {
        lowerTimeBound = low.minWaitTimeEstimate;
        upperTimeBound = low.maxWaitTimeEstimate;
    }
    else if (effectiveMaxPriorityFee.gte(mediumMaxPriorityFeeInWEI) &&
        effectiveMaxPriorityFee.lt(highMaxPriorityFeeInWEI)) {
        lowerTimeBound = medium.minWaitTimeEstimate;
        upperTimeBound = medium.maxWaitTimeEstimate;
    }
    else if (effectiveMaxPriorityFee.eq(highMaxPriorityFeeInWEI)) {
        lowerTimeBound = high.minWaitTimeEstimate;
        upperTimeBound = high.maxWaitTimeEstimate;
    }
    else {
        lowerTimeBound = 0;
        upperTimeBound = high.maxWaitTimeEstimate;
    }
    return {
        lowerTimeBound,
        upperTimeBound,
    };
}
exports.calculateTimeEstimate = calculateTimeEstimate;
//# sourceMappingURL=gas-util.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/gas/gas-util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-util/lib/index.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","is-hex-prefixed":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-hex-prefixed/src/index.js","strip-hex-prefix":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/strip-hex-prefix/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-util/lib/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/ethjs-util/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/apis/token-service.js", {"../util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/apis/token-service.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchTokenMetadata = exports.fetchTokenList = void 0;
const util_1 = require("../util");
const END_POINT = 'https://token-api.metaswap.codefi.network';
function getTokensURL(chainId) {
    return `${END_POINT}/tokens/${chainId}`;
}
function getTokenMetadataURL(chainId, tokenAddress) {
    return `${END_POINT}/token/${chainId}?address=${tokenAddress}`;
}
// Token list averages 1.6 MB in size
// timeoutFetch by default has a 500ms timeout, which will almost always timeout given the response size.
const timeout = 10000;
/**
 * Fetches the list of token metadata for a given network chainId
 *
 * @returns - Promise resolving token List
 */
function fetchTokenList(chainId, abortSignal) {
    return __awaiter(this, void 0, void 0, function* () {
        const tokenURL = getTokensURL(chainId);
        const response = yield queryApi(tokenURL, abortSignal);
        if (response) {
            return parseJsonResponse(response);
        }
        return undefined;
    });
}
exports.fetchTokenList = fetchTokenList;
/**
 * Fetch metadata for the token address provided for a given network chainId
 *
 * @return Promise resolving token metadata for the tokenAddress provided
 */
function fetchTokenMetadata(chainId, tokenAddress, abortSignal) {
    return __awaiter(this, void 0, void 0, function* () {
        const tokenMetadataURL = getTokenMetadataURL(chainId, tokenAddress);
        const response = yield queryApi(tokenMetadataURL, abortSignal);
        if (response) {
            return parseJsonResponse(response);
        }
        return undefined;
    });
}
exports.fetchTokenMetadata = fetchTokenMetadata;
/**
 * Perform fetch request against the api
 *
 * @return Promise resolving request response
 */
function queryApi(apiURL, abortSignal) {
    return __awaiter(this, void 0, void 0, function* () {
        const fetchOptions = {
            referrer: apiURL,
            referrerPolicy: 'no-referrer-when-downgrade',
            method: 'GET',
            mode: 'cors',
            signal: abortSignal,
            cache: 'default',
        };
        fetchOptions.headers = new window.Headers();
        fetchOptions.headers.set('Content-Type', 'application/json');
        try {
            return yield util_1.timeoutFetch(apiURL, fetchOptions, timeout);
        }
        catch (err) {
            if (err.name === 'AbortError') {
                console.log('Request is aborted');
            }
        }
        return undefined;
    });
}
/**
 * Parse response
 *
 * @return Promise resolving request response json value
 */
function parseJsonResponse(apiResponse) {
    return __awaiter(this, void 0, void 0, function* () {
        const responseObj = yield apiResponse.json();
        // api may return errors as json without setting an error http status code
        if (responseObj === null || responseObj === void 0 ? void 0 : responseObj.error) {
            throw new Error(`TokenService Error: ${responseObj.error}`);
        }
        return responseObj;
    });
}
//# sourceMappingURL=token-service.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/apis/token-service.js",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9tdWx0aWhhc2hlcy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGItcHVic3ViL3NyYy9pcGZzLXB1YnN1Yi5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWxvZy9zcmMvbG9nLmpzIiwibm9kZV9tb2R1bGVzLzNib3gvbm9kZV9tb2R1bGVzL2RpZC1qd3QvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWlkZW50aXR5LXByb3ZpZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtZGlkLWRvY3VtZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtbWluaS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvM2JveC9saWIvM2lkL2tleXJpbmcuanMiLCJub2RlX21vZHVsZXMvM2lkLXJlc29sdmVyL2xpYi9yZWdpc3Rlci5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1hY2Nlc3MtY29udHJvbGxlcnMvc3JjL2FjY2Vzcy1jb250cm9sbGVycy5qcyIsIm5vZGVfbW9kdWxlcy8zYm94LW9yYml0ZGItcGx1Z2lucy9zcmMvbW9kZXJhdG9yQWNjZXNzQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy8zYm94LW9yYml0ZGItcGx1Z2lucy9zcmMvbGVnYWN5SXBmczNib3hBY2Nlc3NDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzLzNib3gtb3JiaXRkYi1wbHVnaW5zL3NyYy90aHJlYWRBY2Nlc3NDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzLzNib3gtb3JiaXRkYi1wbHVnaW5zL3NyYy9vZGJJZGVudGl0eVByb3ZpZGVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZ3BsZWFzZS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGItZmVlZHN0b3JlL3NyYy9GZWVkU3RvcmUuanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGIta3ZzdG9yZS9zcmMvS2V5VmFsdWVTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1kb2NzdG9yZS9zcmMvRG9jdW1lbnRTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi9zcmMvdXRpbHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGIvc3JjL2RiLW1hbmlmZXN0LmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWNvdW50ZXJzdG9yZS9zcmMvQ291bnRlclN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiL3NyYy9leGNoYW5nZS1oZWFkcy5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1ldmVudHN0b3JlL3NyYy9FdmVudFN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWNhY2hlL2luZGV4LWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGIta2V5c3RvcmUvaW5kZXgtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcy1pcGZzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tZXJnZS1vcHRpb25zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvcnVudGltZS9yZXBvLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9tZnMtcHJlbG9hZC5qcyIsIm5vZGVfbW9kdWxlcy9wZWVyLWJvb2svc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtYmxvY2stc2VydmljZS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9zdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jaWRzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wZWVyLWluZm8vc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL3BlZXItaWQvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvcHJlbG9hZC5qcyIsIm5vZGVfbW9kdWxlcy9pcGxkL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL211bHRpYWRkci9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy9ub2RlX21vZHVsZXMvbXVsdGloYXNoaW5nLWFzeW5jL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL3J1bnRpbWUvaXBsZC1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvYm9vdC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtY3J5cHRvL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvaW5kZXguanMiLCJhcHAvc2NyaXB0cy9saWIvcnBjLW1ldGhvZC1taWRkbGV3YXJlL2hhbmRsZXJzL2V0aC1hY2NvdW50cy5qcyIsImFwcC9zY3JpcHRzL2xpYi9ycGMtbWV0aG9kLW1pZGRsZXdhcmUvaGFuZGxlcnMvbG9nLXdlYjMtc2hpbS11c2FnZS5qcyIsImFwcC9zY3JpcHRzL2xpYi9ycGMtbWV0aG9kLW1pZGRsZXdhcmUvaGFuZGxlcnMvd2F0Y2gtYXNzZXQuanMiLCJhcHAvc2NyaXB0cy9saWIvcnBjLW1ldGhvZC1taWRkbGV3YXJlL2hhbmRsZXJzL3JlcXVlc3QtYWNjb3VudHMuanMiLCJhcHAvc2NyaXB0cy9saWIvcnBjLW1ldGhvZC1taWRkbGV3YXJlL2hhbmRsZXJzL3N3aXRjaC1ldGhlcmV1bS1jaGFpbi5qcyIsImFwcC9zY3JpcHRzL2xpYi9ycGMtbWV0aG9kLW1pZGRsZXdhcmUvaGFuZGxlcnMvYWRkLWV0aGVyZXVtLWNoYWluLmpzIiwiYXBwL3NjcmlwdHMvbGliL3JwYy1tZXRob2QtbWlkZGxld2FyZS9oYW5kbGVycy9nZXQtcHJvdmlkZXItc3RhdGUuanMiLCJhcHAvc2NyaXB0cy9saWIvcnBjLW1ldGhvZC1taWRkbGV3YXJlL2hhbmRsZXJzL3NlbmQtbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL2Rpc3QvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL2Rpc3QvcmVzdHJpY3RlZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvZGlzdC9wZXJtaXR0ZWQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFzdC1qc29uLXBhdGNoL25vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9jaWRzL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9jb25jYXQuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9jaWRzL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9lcXVhbHMuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9jaWRzL3NyYy9jaWQtdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL2NpZHMvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL3RvLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL2NpZHMvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvY2lkcy9ub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvY2lkcy9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92YXJpbnQvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3ZhcmludC9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvdmFyaW50L2xlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9zcmMvYmFzZS10YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvbm9kZV9tb2R1bGVzL3ZhcmludC9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL25vZGVfbW9kdWxlcy92YXJpbnQvbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9ub2RlX21vZHVsZXMvdmFyaW50L2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2Zyb20tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvdG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2lzLXJldHJ5LWFsbG93ZWQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL21lcmdlQ29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwibm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtd2FsbGV0L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9zZWNwMjU2azF2My1saWIvZGVyLmpzIiwibm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtd2FsbGV0L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9zZWNwMjU2azF2My1saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9Qb2xsaW5nQmxvY2tUcmFja2VyLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL2Rpc3QvU3Vic2NyaWJlQmxvY2tUcmFja2VyLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL2Rpc3QvQmFzZUJsb2NrVHJhY2tlci5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvdHJlem9yL3Byb3RvYnVmLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvd3JhcE5hdGl2ZVN1cGVyLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi91dGlscy9kZWZlcnJlZC5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvZW52L2Jyb3dzZXIvbmV0d29ya1V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi9pZnJhbWUvaW5saW5lLXN0eWxlcy5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvcG9wdXAvc2hvd1BvcHVwUmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMva2VjY2FrL2xpYi9rZWNjYWsuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcvbm9kZV9tb2R1bGVzL2tlY2Nhay9saWIvYXBpL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9ldGhqcy11dGlsL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMva2VjY2FrL2pzLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLWFiaS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9iZWNoMzIvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvYWdlbnQtYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9yZXF1ZXN0LWJhc2UuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvcmVzcG9uc2UtYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9iaXR3aXNlL2JpdHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYml0d2lzZS9pbnRlZ2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpdHdpc2UvYnl0ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaXR3aXNlL3N0cmluZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaXR3aXNlL25pYmJsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaXR3aXNlL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIuanMiLCJub2RlX21vZHVsZXMvcmxwLWJyb3dzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXRoZXJzLWVpcDcxMi9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvc2VjcDI1NmsxL2VsbGlwdGljLmpzIiwibm9kZV9tb2R1bGVzL2JvcmMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9CYXNlQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvQ29udHJvbGxlck1lc3Nlbmdlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvQ29tcG9zYWJsZUNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L3VzZXIvQWRkcmVzc0Jvb2tDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9hc3NldHMvQXNzZXRzRGV0ZWN0aW9uQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvdXNlci9QcmVmZXJlbmNlc0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L25vdGlmaWNhdGlvbi9Ob3RpZmljYXRpb25Db250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9hc3NldHMvVG9rZW5SYXRlc0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L0Jhc2VDb250cm9sbGVyVjIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2Fzc2V0cy9Bc3NldHNDb250cmFjdENvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2Fzc2V0cy9BY2NvdW50VHJhY2tlckNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2FwcHJvdmFsL0FwcHJvdmFsQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvYXNzZXRzL0N1cnJlbmN5UmF0ZUNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L21lc3NhZ2UtbWFuYWdlci9NZXNzYWdlTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvYXNzZXRzL1Rva2VuQmFsYW5jZXNDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9tZXNzYWdlLW1hbmFnZXIvUGVyc29uYWxNZXNzYWdlTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvbWVzc2FnZS1tYW5hZ2VyL1R5cGVkTWVzc2FnZU1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2Fzc2V0cy9Db2xsZWN0aWJsZXNDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9nYXMvR2FzRmVlQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvYXNzZXRzL1Rva2VuTGlzdENvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2Fzc2V0cy9Ub2tlbnNDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC90aGlyZC1wYXJ0eS9QaGlzaGluZ0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L25ldHdvcmsvTmV0d29ya0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2tleXJpbmcvS2V5cmluZ0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L3RyYW5zYWN0aW9uL1RyYW5zYWN0aW9uQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL25hbm9pZC91cmwtYWxwaGFiZXQvaW5kZXguY2pzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvYXNTdHJlYW0uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9Db21wb3NlZFN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvTWVyZ2VkU3RvcmUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9PYnNlcnZhYmxlU3RvcmUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtd29ya2Vycy9kaXN0L2VudW1zLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL25vZGVfbW9kdWxlcy9qc29uLXJwYy1taWRkbGV3YXJlLXN0cmVhbS9kaXN0L2NyZWF0ZUVuZ2luZVN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvanNvbi1ycGMtbWlkZGxld2FyZS1zdHJlYW0vZGlzdC9jcmVhdGVTdHJlYW1NaWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYmplY3QtbXVsdGlwbGV4L2Rpc3QvT2JqZWN0TXVsdGlwbGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9wb3N0LW1lc3NhZ2Utc3RyZWFtL2Rpc3QvV29ya2VyUGFyZW50UG9zdE1lc3NhZ2VTdHJlYW0uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3Bvc3QtbWVzc2FnZS1zdHJlYW0vZGlzdC9Xb3JrZXJQb3N0TWVzc2FnZVN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcG9zdC1tZXNzYWdlLXN0cmVhbS9kaXN0L1dpbmRvd1Bvc3RNZXNzYWdlU3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy90aHJvdWdoMi90aHJvdWdoMi5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy90eC9kaXN0LmJyb3dzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnktZXRoL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zdXBlclByb3BCYXNlLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3BsdWdpbnMvbGliL2pzb24yLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3N0b3JhZ2VzL21lbW9yeVN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3RvcmFnZXMvb2xkRkYtZ2xvYmFsU3RvcmFnZS5qcyIsIm5vZGVfbW9kdWxlcy9zdG9yZS9zdG9yYWdlcy9vbGRJRS11c2VyRGF0YVN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3RvcmFnZXMvbG9jYWxTdG9yYWdlLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3N0b3JhZ2VzL2Nvb2tpZVN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3RvcmFnZXMvc2Vzc2lvblN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvaHR0cHMtZGlkLXJlc29sdmVyL2xpYi9yZWdpc3Rlci5qcyIsIm5vZGVfbW9kdWxlcy9tdXBvcnQtZGlkLXJlc29sdmVyL2xpYi9yZWdpc3Rlci5qcyIsIm5vZGVfbW9kdWxlcy9ncmFwaHFsLXJlcXVlc3QvZGlzdC9zcmMvdHlwZXMuanMiLCJub2RlX21vZHVsZXMvZ3JhcGhxbC1yZXF1ZXN0L25vZGVfbW9kdWxlcy9jcm9zcy1mZXRjaC9kaXN0L2Jyb3dzZXItcG9seWZpbGwuanMiLCJub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXB1YnN1Yi1wZWVyLW1vbml0b3Ivc3JjL2lwZnMtcHVic3ViLXBlZXItbW9uaXRvci5qcyIsIm5vZGVfbW9kdWxlcy9wLXNlcmllcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWxvZy9zcmMvZy1zZXQuanMiLCJub2RlX21vZHVsZXMvaXBmcy1sb2cvc3JjL2xvZy1lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvaXBmcy1sb2cvc3JjL2xhbXBvcnQtY2xvY2suanMiLCJub2RlX21vZHVsZXMvaXBmcy1sb2cvc3JjL2RlZmF1bHQtYWNjZXNzLWNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvaXBmcy1sb2cvc3JjL2VudHJ5LWluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtbG9nL3NyYy9sb2ctc29ydGluZy5qcyIsIm5vZGVfbW9kdWxlcy9wLWVhY2gtc2VyaWVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtbG9nL3NyYy91dGlscy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWxvZy9zcmMvbG9nLWlvLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtbG9nL3NyYy9lbnRyeS5qcyIsIm5vZGVfbW9kdWxlcy8zYm94L25vZGVfbW9kdWxlcy9kaWQtand0L25vZGVfbW9kdWxlcy9qcy1zaGEzL3NyYy9zaGEzLmpzIiwibm9kZV9tb2R1bGVzL2RpZC1yZXNvbHZlci9saWIvcmVzb2x2ZXIuanMiLCJub2RlX21vZHVsZXMvQHN0YWJsZWxpYi91dGY4L2xpYi91dGY4LmpzIiwibm9kZV9tb2R1bGVzL3Vwb3J0LWJhc2U2NHVybC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1pZGVudGl0eS1wcm92aWRlci9zcmMvaWRlbnRpdGllcy5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLW1pbmkvc3JjL2xpYi9YTUxIdHRwUmVxdWVzdC1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jhc2U2NHVybC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kaWQtand0L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1hY2Nlc3MtY29udHJvbGxlcnMvc3JjL2FjY2Vzcy1jb250cm9sbGVyLW1hbmlmZXN0LmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWFjY2Vzcy1jb250cm9sbGVycy9zcmMvbGVnYWN5LWlwZnMtYWNjZXNzLWNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGItYWNjZXNzLWNvbnRyb2xsZXJzL3NyYy9vcmJpdGRiLWFjY2Vzcy1jb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWFjY2Vzcy1jb250cm9sbGVycy9zcmMvaXBmcy1hY2Nlc3MtY29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1pby9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1hY2Nlc3MtY29udHJvbGxlcnMvc3JjL3V0aWxzL2Vuc3VyZS1hYy1hZGRyZXNzLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWZlZWRzdG9yZS9zcmMvRmVlZEluZGV4LmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWt2c3RvcmUvc3JjL0tleVZhbHVlSW5kZXguanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGItc3RvcmUvc3JjL1N0b3JlLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWRvY3N0b3JlL3NyYy9Eb2N1bWVudEluZGV4LmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWRvY3N0b3JlL25vZGVfbW9kdWxlcy9wLW1hcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi9zcmMvdXRpbHMvaXMtZGVmaW5lZC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1jb3VudGVyc3RvcmUvc3JjL0NvdW50ZXJJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jcmR0cy9zcmMvRy1Db3VudGVyLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtcHVic3ViLTFvbjEvc3JjL2RpcmVjdC1jaGFubmVsLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWV2ZW50c3RvcmUvc3JjL0V2ZW50SW5kZXguanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGItY2FjaGUvQ2FjaGUuanMiLCJub2RlX21vZHVsZXMvbGV2ZWwtanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGIta2V5c3RvcmUvc3JjL2tleXN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL21hZm10L3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1wbGFpbi1vYmovaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy1yZXBvL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9zZXRJbW1lZGlhdGUuanMiLCJub2RlX21vZHVsZXMvZnNtLWV2ZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy9wcmludC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy9uYW1lLXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL3ZhcmludC10YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2NsYXNzLWlzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL2Jhc2UtdGFibGUuanMiLCJub2RlX21vZHVsZXMvY2lkcy9zcmMvY2lkLXV0aWwuanMiLCJub2RlX21vZHVsZXMvcGVlci1pbmZvL3NyYy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9wZWVyLWluZm8vc3JjL211bHRpYWRkci1zZXQuanMiLCJub2RlX21vZHVsZXMvc3VwZXJzdHJ1Y3QvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1jcnlwdG8vc3JjL2tleXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXVsdGlhZGRyLXRvLXVyaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL3J1bnRpbWUvcHJlbG9hZC1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL3JldHJ5LmpzIiwibm9kZV9tb2R1bGVzL2lwbGQvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvaXBsZC1kYWctY2Jvci9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBsZC1kYWctcGIvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwbGQtcmF3L3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNpZnktZXM2L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3R5cGljYWwvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWJsb2NrL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWFkZHIvc3JjL3Byb3RvY29scy10YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWFkZHIvc3JjL2NvZGVjLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvbm9kZV9tb2R1bGVzL211bHRpaGFzaGluZy1hc3luYy9zcmMvY3J5cHRvLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1jcnlwdG8vc3JjL2htYWMvaW5kZXgtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtY3J5cHRvL3NyYy9yYW5kb20tYnl0ZXMuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWNyeXB0by9zcmMvYWVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1jcnlwdG8vc3JjL3Bia2RmMi5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvaXMtb25saW5lLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvY29tcG9uZW50cy92ZXJzaW9uLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvY29tcG9uZW50cy9jb25maWcuanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9jb21wb25lbnRzL2Rucy5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMva2V5LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvY29tcG9uZW50cy9yZXBvLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvY29tcG9uZW50cy9ib290c3RyYXAuanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9jb21wb25lbnRzL3BpbmctcHVsbC1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9jb21wb25lbnRzL3BpbmctcmVhZGFibGUtc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvY29tcG9uZW50cy9zdG9wLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvY29tcG9uZW50cy9pZC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvYmxvY2suanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9jb21wb25lbnRzL29iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvcGluZy5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvYml0c3dhcC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvcHVic3ViLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvY29tcG9uZW50cy9yZXNvbHZlLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvY29tcG9uZW50cy9zd2FybS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvc3RhdHMuanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9jb21wb25lbnRzL2RodC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvZGFnLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvY29tcG9uZW50cy9waW4uanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9jb21wb25lbnRzL25hbWUuanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9jb21wb25lbnRzL3ByZS1zdGFydC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvc3RhcnQuanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9jb21wb25lbnRzL2luaXQuanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9jb21wb25lbnRzL2xpYnAycC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvZmlsZXMtcmVndWxhci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL2NvbXBvbmVudHMvZmlsZXMtbWZzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9kaXN0L3Jlc3RyaWN0ZWQvY29uZmlybS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvZGlzdC9yZXN0cmljdGVkL2ludm9rZVNuYXAuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL2Rpc3QvcmVzdHJpY3RlZC9tYW5hZ2VTdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvZGlzdC9yZXN0cmljdGVkL2dldEJpcDQ0RW50cm9weS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvZGlzdC9wZXJtaXR0ZWQvZ2V0U25hcHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL2Rpc3QvcGVybWl0dGVkL2dldEFwcEtleS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvZGlzdC9wZXJtaXR0ZWQvaW5zdGFsbFNuYXBzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9kaXN0L3Blcm1pdHRlZC9pbnZva2VTbmFwU3VnYXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL2Rpc3QvcGVybWl0dGVkL2VuYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL2NpZHMvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL21hcHMuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9jaWRzL25vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL25vZGVfbW9kdWxlcy92YXJpbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9jaWRzL25vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvY2lkcy9ub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL2NpZHMvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2Zyb20tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvY2lkcy9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvY2lkcy9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL3JmYzQ2NDguanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2Jhc2UuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3ZhbGlkYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvcGlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NvbnN0cnVjdC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3Qvbm9kZV9tb2R1bGVzL3doYXR3Zy1mZXRjaC9kaXN0L2ZldGNoLnVtZC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMva2VjY2FrL2xpYi9rZWNjYWstc3RhdGUtdW5yb2xsLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9rZWNjYWsvbGliL2FwaS9rZWNjYWsuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcvbm9kZV9tb2R1bGVzL2tlY2Nhay9saWIvYXBpL3NoYWtlLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9rZWNjYWsvbGliL2tlY2Nhay5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMva2VjY2FrL2xpYi9hcGkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtYWJpL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9iaXR3aXNlL2JpdHMvY2lyY3VsYXItc2hpZnQtcmlnaHQuanMiLCJub2RlX21vZHVsZXMvYml0d2lzZS9iaXRzL2FuZC5qcyIsIm5vZGVfbW9kdWxlcy9iaXR3aXNlL2JpdHMvY2lyY3VsYXItc2hpZnQtbGVmdC5qcyIsIm5vZGVfbW9kdWxlcy9iaXR3aXNlL2JpdHMvbmFuZC5qcyIsIm5vZGVfbW9kdWxlcy9iaXR3aXNlL2JpdHMvbm90LmpzIiwibm9kZV9tb2R1bGVzL2JpdHdpc2UvYml0cy9ub3IuanMiLCJub2RlX21vZHVsZXMvYml0d2lzZS9iaXRzL3JlZHVjZS1hbmQuanMiLCJub2RlX21vZHVsZXMvYml0d2lzZS9iaXRzL29yLmpzIiwibm9kZV9tb2R1bGVzL2JpdHdpc2UvYml0cy9yZWR1Y2UtbmFuZC5qcyIsIm5vZGVfbW9kdWxlcy9iaXR3aXNlL2JpdHMvcmVkdWNlLW5vci5qcyIsIm5vZGVfbW9kdWxlcy9iaXR3aXNlL2JpdHMvcmVkdWNlLW9yLmpzIiwibm9kZV9tb2R1bGVzL2JpdHdpc2UvYml0cy9yZWR1Y2UteG5vci5qcyIsIm5vZGVfbW9kdWxlcy9iaXR3aXNlL2JpdHMvcmVkdWNlLXhvci5qcyIsIm5vZGVfbW9kdWxlcy9iaXR3aXNlL2JpdHMvdG8tYm9vbGVhbi5qcyIsIm5vZGVfbW9kdWxlcy9iaXR3aXNlL2JpdHMvdG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2JpdHdpc2UvYml0cy94bm9yLmpzIiwibm9kZV9tb2R1bGVzL2JpdHdpc2UvYml0cy94b3IuanMiLCJub2RlX21vZHVsZXMvYml0d2lzZS9pbnRlZ2VyL2dldC1iaXQuanMiLCJub2RlX21vZHVsZXMvYml0d2lzZS9pbnRlZ2VyL3NldC1iaXQuanMiLCJub2RlX21vZHVsZXMvYml0d2lzZS9pbnRlZ2VyL3RvZ2dsZS1iaXQuanMiLCJub2RlX21vZHVsZXMvYml0d2lzZS9ieXRlL3JlYWQuanMiLCJub2RlX21vZHVsZXMvYml0d2lzZS9ieXRlL3dyaXRlLmpzIiwibm9kZV9tb2R1bGVzL2JpdHdpc2Uvc3RyaW5nL3RvLWJpdHMuanMiLCJub2RlX21vZHVsZXMvYml0d2lzZS9uaWJibGUvcmVhZC5qcyIsIm5vZGVfbW9kdWxlcy9iaXR3aXNlL25pYmJsZS93cml0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iaXR3aXNlL2J1ZmZlci9hbmQuanMiLCJub2RlX21vZHVsZXMvYml0d2lzZS9idWZmZXIvbmFuZC5qcyIsIm5vZGVfbW9kdWxlcy9iaXR3aXNlL2J1ZmZlci9ub3IuanMiLCJub2RlX21vZHVsZXMvYml0d2lzZS9idWZmZXIvbm90LmpzIiwibm9kZV9tb2R1bGVzL2JpdHdpc2UvYnVmZmVyL29yLmpzIiwibm9kZV9tb2R1bGVzL2JpdHdpc2UvYnVmZmVyL3hub3IuanMiLCJub2RlX21vZHVsZXMvYml0d2lzZS9idWZmZXIveG9yLmpzIiwibm9kZV9tb2R1bGVzL2JpdHdpc2UvYnVmZmVyL2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iaXR3aXNlL2J1ZmZlci9tb2RpZnkuanMiLCJub2RlX21vZHVsZXMvYml0d2lzZS9idWZmZXIvcmVhZC5qcyIsIm5vZGVfbW9kdWxlcy9iaXR3aXNlL2J1ZmZlci9yZWFkLXUtaW50LmpzIiwibm9kZV9tb2R1bGVzL2JpdHdpc2UvYnVmZmVyL3JlYWQtaW50LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9ub2RlX21vZHVsZXMvc2VjcDI1NmsxL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9saWIvZWxsaXB0aWMuanMiLCJub2RlX21vZHVsZXMvYm9yYy9zcmMvdGFnZ2VkLmpzIiwibm9kZV9tb2R1bGVzL2JvcmMvc3JjL3NpbXBsZS5qcyIsIm5vZGVfbW9kdWxlcy9ib3JjL3NyYy9kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL2JvcmMvc3JjL2RpYWdub3NlLmpzIiwibm9kZV9tb2R1bGVzL2JvcmMvc3JjL2VuY29kZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvYXBpcy9jcnlwdG8tY29tcGFyZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvbWVzc2FnZS1tYW5hZ2VyL0Fic3RyYWN0TWVzc2FnZU1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2Fzc2V0cy9hc3NldHNVdGlsLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9nYXMvZ2FzLXV0aWwuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL2V0aGpzLXV0aWwvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9hcGlzL3Rva2VuLXNlcnZpY2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMxc0JBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDak9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ2paQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMxY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0JBOztBQUVBO0FBQ0E7QUFDQTtBQUVBLE1BQU0sdUJBQXVCLEdBQUc7QUFDOUIsRUFBQSxXQUFXLEVBQUUsQ0FBQyxrQkFBYSxZQUFkLENBRGlCO0FBRTlCLEVBQUEsY0FBYyxFQUFFLGtCQUZjO0FBRzlCLEVBQUEsU0FBUyxFQUFFO0FBQ1QsSUFBQSxXQUFXLEVBQUU7QUFESjtBQUhtQixDQUFoQztlQU9lLHVCO0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0EsZUFBZSxrQkFBZixDQUFrQyxJQUFsQyxFQUF3QyxHQUF4QyxFQUE2QyxLQUE3QyxFQUFvRCxHQUFwRCxFQUF5RDtBQUFFLEVBQUE7QUFBRixDQUF6RCxFQUEwRTtBQUN4RSxFQUFBLEdBQUcsQ0FBQyxNQUFKLEdBQWEsTUFBTSxXQUFXLEVBQTlCO0FBQ0EsU0FBTyxHQUFHLEVBQVY7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxNQUFNLGdCQUFnQixHQUFHO0FBQ3ZCLEVBQUEsV0FBVyxFQUFFLENBQUMsa0JBQWEsbUJBQWQsQ0FEVTtBQUV2QixFQUFBLGNBQWMsRUFBRSx1QkFGTztBQUd2QixFQUFBLFNBQVMsRUFBRTtBQUNULElBQUEsV0FBVyxFQUFFLElBREo7QUFFVCxJQUFBLHFCQUFxQixFQUFFLElBRmQ7QUFHVCxJQUFBLHdCQUF3QixFQUFFO0FBSGpCO0FBSFksQ0FBekI7ZUFTZSxnQjtBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQSxTQUFTLHVCQUFULENBQ0UsR0FERixFQUVFLEdBRkYsRUFHRSxLQUhGLEVBSUUsR0FKRixFQUtFO0FBQUUsRUFBQSxXQUFGO0FBQWUsRUFBQSxxQkFBZjtBQUFzQyxFQUFBO0FBQXRDLENBTEYsRUFNRTtBQUNBLFFBQU07QUFBRSxJQUFBO0FBQUYsTUFBYSxHQUFuQjs7QUFDQSxNQUFJLHFCQUFxQixDQUFDLE1BQUQsQ0FBckIsS0FBa0MsU0FBdEMsRUFBaUQ7QUFDL0MsSUFBQSx3QkFBd0IsQ0FBQyxNQUFELENBQXhCO0FBRUEsSUFBQSxXQUFXLENBQ1Q7QUFDRSxNQUFBLEtBQUssRUFBRyxtQ0FEVjtBQUVFLE1BQUEsUUFBUSxFQUFFLGlCQUZaO0FBR0UsTUFBQSxRQUFRLEVBQUU7QUFDUixRQUFBLEdBQUcsRUFBRTtBQURHO0FBSFosS0FEUyxFQVFUO0FBQ0UsTUFBQSxvQkFBb0IsRUFBRTtBQUR4QixLQVJTLENBQVg7QUFZRDs7QUFFRCxFQUFBLEdBQUcsQ0FBQyxNQUFKLEdBQWEsSUFBYjtBQUNBLFNBQU8sR0FBRyxFQUFWO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvREQ7O0FBRUEsTUFBTSxVQUFVLEdBQUc7QUFDakIsRUFBQSxXQUFXLEVBQUUsQ0FBQyxrQkFBYSxXQUFkLEVBQTJCLGtCQUFhLGtCQUF4QyxDQURJO0FBRWpCLEVBQUEsY0FBYyxFQUFFLGlCQUZDO0FBR2pCLEVBQUEsU0FBUyxFQUFFO0FBQ1QsSUFBQSx1QkFBdUIsRUFBRTtBQURoQjtBQUhNLENBQW5CO2VBT2UsVTtBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQSxlQUFlLGlCQUFmLENBQ0UsR0FERixFQUVFLEdBRkYsRUFHRSxLQUhGLEVBSUUsR0FKRixFQUtFO0FBQUUsRUFBQTtBQUFGLENBTEYsRUFNRTtBQUNBLE1BQUk7QUFDRixVQUFNO0FBQUUsTUFBQSxPQUFPLEVBQUUsS0FBWDtBQUFrQixNQUFBO0FBQWxCLFFBQTJCLEdBQUcsQ0FBQyxNQUFyQztBQUNBLElBQUEsR0FBRyxDQUFDLE1BQUosR0FBYSxNQUFNLHVCQUF1QixDQUFDLEtBQUQsRUFBUSxJQUFSLENBQTFDO0FBQ0EsV0FBTyxHQUFHLEVBQVY7QUFDRCxHQUpELENBSUUsT0FBTyxLQUFQLEVBQWM7QUFDZCxXQUFPLEdBQUcsQ0FBQyxLQUFELENBQVY7QUFDRDtBQUNGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0NEOztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsTUFBTSx1QkFBdUIsR0FBRztBQUM5QixFQUFBLFdBQVcsRUFBRSxDQUFDLGtCQUFhLG9CQUFkLENBRGlCO0FBRTlCLEVBQUEsY0FBYyxFQUFFLDhCQUZjO0FBRzlCLEVBQUEsU0FBUyxFQUFFO0FBQ1QsSUFBQSxNQUFNLEVBQUUsSUFEQztBQUVULElBQUEsV0FBVyxFQUFFLElBRko7QUFHVCxJQUFBLGdCQUFnQixFQUFFLElBSFQ7QUFJVCxJQUFBLGFBQWEsRUFBRSxJQUpOO0FBS1QsSUFBQSx5QkFBeUIsRUFBRTtBQUxsQjtBQUhtQixDQUFoQztlQVdlLHVCLEVBRWY7OztBQUNBLE1BQU0sS0FBSyxHQUFHLElBQUksR0FBSixFQUFkO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsZUFBZSw4QkFBZixDQUNFLElBREYsRUFFRSxHQUZGLEVBR0UsS0FIRixFQUlFLEdBSkYsRUFLRTtBQUNFLEVBQUEsTUFERjtBQUVFLEVBQUEsV0FGRjtBQUdFLEVBQUEsZ0JBSEY7QUFJRSxFQUFBLGFBSkY7QUFLRSxFQUFBO0FBTEYsQ0FMRixFQVlFO0FBQ0EsTUFBSSxLQUFLLENBQUMsR0FBTixDQUFVLE1BQVYsQ0FBSixFQUF1QjtBQUNyQixJQUFBLEdBQUcsQ0FBQyxLQUFKLEdBQVksd0JBQVUsR0FBVixDQUFjLG1CQUFkLENBQ1Qsc0JBQXFCLGtCQUFhLG9CQUFxQixnQkFEOUMsQ0FBWjtBQUdBLFdBQU8sR0FBRyxFQUFWO0FBQ0Q7O0FBRUQsTUFBSSxhQUFhLENBQUMsa0JBQWEsWUFBZCxDQUFqQixFQUE4QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxRQUFJO0FBQ0YsTUFBQSxLQUFLLENBQUMsR0FBTixDQUFVLE1BQVY7QUFDQSxZQUFNLGdCQUFnQixFQUF0QjtBQUNBLE1BQUEsR0FBRyxDQUFDLE1BQUosR0FBYSxNQUFNLFdBQVcsRUFBOUI7QUFDQSxNQUFBLEdBQUc7QUFDSixLQUxELENBS0UsT0FBTyxLQUFQLEVBQWM7QUFDZCxNQUFBLEdBQUcsQ0FBQyxLQUFELENBQUg7QUFDRCxLQVBELFNBT1U7QUFDUixNQUFBLEtBQUssQ0FBQyxNQUFOLENBQWEsTUFBYjtBQUNEOztBQUNELFdBQU8sU0FBUDtBQUNELEdBdkJELENBeUJBOzs7QUFDQSxNQUFJO0FBQ0YsVUFBTSx5QkFBeUIsRUFBL0I7QUFDRCxHQUZELENBRUUsT0FBTyxHQUFQLEVBQVk7QUFDWixJQUFBLEdBQUcsQ0FBQyxLQUFKLEdBQVksR0FBWjtBQUNBLFdBQU8sR0FBRyxFQUFWO0FBQ0QsR0EvQkQsQ0FpQ0E7OztBQUNBLFFBQU0sUUFBUSxHQUFHLE1BQU0sV0FBVyxFQUFsQztBQUNBOztBQUNBLE1BQUksUUFBUSxDQUFDLE1BQVQsR0FBa0IsQ0FBdEIsRUFBeUI7QUFDdkIsSUFBQSxHQUFHLENBQUMsTUFBSixHQUFhLFFBQWI7QUFDRCxHQUZELE1BRU87QUFDTDtBQUNBO0FBQ0EsSUFBQSxHQUFHLENBQUMsS0FBSixHQUFZLHdCQUFVLEdBQVYsQ0FBYyxRQUFkLENBQ1YsNERBRFUsQ0FBWjtBQUdEOztBQUVELFNBQU8sR0FBRyxFQUFWO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzR0Q7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBTUE7O0FBS0EsTUFBTSxtQkFBbUIsR0FBRztBQUMxQixFQUFBLFdBQVcsRUFBRSxDQUFDLGtCQUFhLHFCQUFkLENBRGE7QUFFMUIsRUFBQSxjQUFjLEVBQUUsMEJBRlU7QUFHMUIsRUFBQSxTQUFTLEVBQUU7QUFDVCxJQUFBLGlCQUFpQixFQUFFLElBRFY7QUFFVCxJQUFBLGVBQWUsRUFBRSxJQUZSO0FBR1QsSUFBQSxlQUFlLEVBQUUsSUFIUjtBQUlULElBQUEsZUFBZSxFQUFFLElBSlI7QUFLVCxJQUFBLG1CQUFtQixFQUFFO0FBTFo7QUFIZSxDQUE1QjtlQVdlLG1COzs7QUFFZixTQUFTLG1CQUFULENBQTZCLE9BQTdCLEVBQXNDLGVBQXRDLEVBQXVEO0FBQ3JELE1BQUksT0FBTyxJQUFJLDZCQUFmLEVBQXFDO0FBQ25DLFdBQU87QUFDTCxNQUFBLE9BREs7QUFFTCxNQUFBLE1BQU0sRUFBRSxtQkFGSDtBQUdMLE1BQUEsUUFBUSxFQUFFLDZCQUFvQixPQUFwQixDQUhMO0FBSUwsTUFBQSxNQUFNLEVBQUUsaUNBQXdCLE9BQXhCLENBSkg7QUFLTCxNQUFBLElBQUksRUFBRSw4QkFBcUIsT0FBckI7QUFMRCxLQUFQO0FBT0Q7O0FBRUQsU0FBTyxlQUFlLENBQUM7QUFBRSxJQUFBO0FBQUYsR0FBRCxDQUF0QjtBQUNEOztBQUVELGVBQWUsMEJBQWYsQ0FDRSxHQURGLEVBRUUsR0FGRixFQUdFLEtBSEYsRUFJRSxHQUpGLEVBS0U7QUFDRSxFQUFBLGlCQURGO0FBRUUsRUFBQSxlQUZGO0FBR0UsRUFBQSxlQUhGO0FBSUUsRUFBQSxlQUpGO0FBS0UsRUFBQTtBQUxGLENBTEYsRUFZRTtBQUFBOztBQUNBLE1BQUksaUJBQUMsR0FBRyxDQUFDLE1BQUwsd0NBQUMsWUFBYSxDQUFiLENBQUQsS0FBb0IsT0FBTyxHQUFHLENBQUMsTUFBSixDQUFXLENBQVgsQ0FBUCxLQUF5QixRQUFqRCxFQUEyRDtBQUN6RCxXQUFPLEdBQUcsQ0FDUix3QkFBVSxHQUFWLENBQWMsYUFBZCxDQUE0QjtBQUMxQixNQUFBLE9BQU8sRUFBRyxpREFBZ0QsSUFBSSxDQUFDLFNBQUwsQ0FDeEQsR0FBRyxDQUFDLE1BRG9ELENBRXhEO0FBSHdCLEtBQTVCLENBRFEsQ0FBVjtBQU9EOztBQUVELFFBQU07QUFBRSxJQUFBO0FBQUYsTUFBYSxHQUFuQjtBQUVBLFFBQU07QUFBRSxJQUFBO0FBQUYsTUFBYyxHQUFHLENBQUMsTUFBSixDQUFXLENBQVgsQ0FBcEI7QUFFQSxRQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsSUFBUCxDQUFZLGtCQUFLLEdBQUcsQ0FBQyxNQUFKLENBQVcsQ0FBWCxDQUFMLEVBQW9CLENBQUMsU0FBRCxDQUFwQixDQUFaLENBQWxCOztBQUVBLE1BQUksU0FBUyxDQUFDLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEIsV0FBTyxHQUFHLENBQ1Isd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FBNEI7QUFDMUIsTUFBQSxPQUFPLEVBQUcsb0VBQW1FLFNBQVU7QUFEN0QsS0FBNUIsQ0FEUSxDQUFWO0FBS0Q7O0FBRUQsUUFBTSxRQUFRLEdBQUcsT0FBTyxPQUFQLEtBQW1CLFFBQW5CLElBQStCLE9BQU8sQ0FBQyxXQUFSLEVBQWhEOztBQUVBLE1BQUksQ0FBQyw0Q0FBNkIsUUFBN0IsQ0FBTCxFQUE2QztBQUMzQyxXQUFPLEdBQUcsQ0FDUix3QkFBVSxHQUFWLENBQWMsYUFBZCxDQUE0QjtBQUMxQixNQUFBLE9BQU8sRUFBRyxxRkFBb0YsT0FBUTtBQUQ1RSxLQUE1QixDQURRLENBQVY7QUFLRDs7QUFFRCxNQUFJLENBQUMsNkJBQWMsUUFBUSxDQUFDLFFBQUQsRUFBVyxFQUFYLENBQXRCLENBQUwsRUFBNEM7QUFDMUMsV0FBTyxHQUFHLENBQ1Isd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FBNEI7QUFDMUIsTUFBQSxPQUFPLEVBQUcscUJBQW9CLFFBQVMsOERBQTZELE9BQVE7QUFEbEYsS0FBNUIsQ0FEUSxDQUFWO0FBS0Q7O0FBRUQsUUFBTSxXQUFXLEdBQUcsbUJBQW1CLENBQUMsUUFBRCxFQUFXLGVBQVgsQ0FBdkM7O0FBQ0EsTUFBSSxXQUFKLEVBQWlCO0FBQ2YsVUFBTSxjQUFjLEdBQUcsaUJBQWlCLEVBQXhDOztBQUNBLFFBQUksY0FBYyxLQUFLLFFBQXZCLEVBQWlDO0FBQy9CLE1BQUEsR0FBRyxDQUFDLE1BQUosR0FBYSxJQUFiO0FBQ0EsYUFBTyxHQUFHLEVBQVY7QUFDRDs7QUFDRCxRQUFJO0FBQ0YsWUFBTSxtQkFBbUIsR0FBRyxNQUFNLG1CQUFtQixDQUFDO0FBQ3BELFFBQUEsTUFEb0Q7QUFFcEQsUUFBQSxJQUFJLEVBQUUsa0JBQWEscUJBRmlDO0FBR3BELFFBQUE7QUFIb0QsT0FBRCxDQUFyRDs7QUFLQSxVQUFJLE9BQU8sSUFBSSw2QkFBZixFQUFxQztBQUNuQyxRQUFBLGVBQWUsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFyQixDQUFmO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsY0FBTSxlQUFlLENBQUMsbUJBQUQsQ0FBckI7QUFDRDs7QUFDRCxNQUFBLEdBQUcsQ0FBQyxNQUFKLEdBQWEsSUFBYjtBQUNELEtBWkQsQ0FZRSxPQUFPLEtBQVAsRUFBYztBQUNkLGFBQU8sR0FBRyxDQUFDLEtBQUQsQ0FBVjtBQUNEOztBQUNELFdBQU8sR0FBRyxFQUFWO0FBQ0Q7O0FBQ0QsU0FBTyxHQUFHLENBQ1Isd0JBQVUsUUFBVixDQUFtQixNQUFuQixDQUEwQjtBQUN4QixJQUFBLElBQUksRUFBRSxJQURrQjtBQUNaO0FBQ1osSUFBQSxPQUFPLEVBQUcsMEJBQXlCLE9BQVEsaUNBQWdDLGtCQUFhLGtCQUFtQjtBQUZuRixHQUExQixDQURRLENBQVY7QUFNRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUhEOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUlBOztBQUNBOztBQUVBLE1BQU0sZ0JBQWdCLEdBQUc7QUFDdkIsRUFBQSxXQUFXLEVBQUUsQ0FBQyxrQkFBYSxrQkFBZCxDQURVO0FBRXZCLEVBQUEsY0FBYyxFQUFFLHVCQUZPO0FBR3ZCLEVBQUEsU0FBUyxFQUFFO0FBQ1QsSUFBQSxZQUFZLEVBQUUsSUFETDtBQUVULElBQUEsaUJBQWlCLEVBQUUsSUFGVjtBQUdULElBQUEsZUFBZSxFQUFFLElBSFI7QUFJVCxJQUFBLGVBQWUsRUFBRSxJQUpSO0FBS1QsSUFBQSxtQkFBbUIsRUFBRSxJQUxaO0FBTVQsSUFBQSxXQUFXLEVBQUU7QUFOSjtBQUhZLENBQXpCO2VBWWUsZ0I7OztBQUVmLGVBQWUsdUJBQWYsQ0FDRSxHQURGLEVBRUUsR0FGRixFQUdFLEtBSEYsRUFJRSxHQUpGLEVBS0U7QUFDRSxFQUFBLFlBREY7QUFFRSxFQUFBLGlCQUZGO0FBR0UsRUFBQSxlQUhGO0FBSUUsRUFBQSxlQUpGO0FBS0UsRUFBQSxtQkFMRjtBQU1FLEVBQUE7QUFORixDQUxGLEVBYUU7QUFBQTs7QUFDQSxNQUFJLGlCQUFDLEdBQUcsQ0FBQyxNQUFMLHdDQUFDLFlBQWEsQ0FBYixDQUFELEtBQW9CLE9BQU8sR0FBRyxDQUFDLE1BQUosQ0FBVyxDQUFYLENBQVAsS0FBeUIsUUFBakQsRUFBMkQ7QUFDekQsV0FBTyxHQUFHLENBQ1Isd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FBNEI7QUFDMUIsTUFBQSxPQUFPLEVBQUcsaURBQWdELElBQUksQ0FBQyxTQUFMLENBQ3hELEdBQUcsQ0FBQyxNQURvRCxDQUV4RDtBQUh3QixLQUE1QixDQURRLENBQVY7QUFPRDs7QUFFRCxRQUFNO0FBQUUsSUFBQTtBQUFGLE1BQWEsR0FBbkI7QUFFQSxRQUFNO0FBQ0osSUFBQSxPQURJO0FBRUosSUFBQSxTQUFTLEdBQUcsSUFGUjtBQUdKLElBQUEsaUJBQWlCLEdBQUcsSUFIaEI7QUFJSixJQUFBLGNBQWMsR0FBRyxJQUpiO0FBS0osSUFBQTtBQUxJLE1BTUYsR0FBRyxDQUFDLE1BQUosQ0FBVyxDQUFYLENBTko7QUFRQSxRQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsSUFBUCxDQUNoQixrQkFBSyxHQUFHLENBQUMsTUFBSixDQUFXLENBQVgsQ0FBTCxFQUFvQixDQUNsQixTQURrQixFQUVsQixXQUZrQixFQUdsQixtQkFIa0IsRUFJbEIsVUFKa0IsRUFLbEIsU0FMa0IsRUFNbEIsZ0JBTmtCLENBQXBCLENBRGdCLENBQWxCOztBQVdBLE1BQUksU0FBUyxDQUFDLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEIsV0FBTyxHQUFHLENBQ1Isd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FBNEI7QUFDMUIsTUFBQSxPQUFPLEVBQUcsb0VBQW1FLFNBQVU7QUFEN0QsS0FBNUIsQ0FEUSxDQUFWO0FBS0Q7O0FBRUQsUUFBTSxnQkFBZ0IsR0FBRyxLQUFLLENBQUMsT0FBTixDQUFjLE9BQWQsSUFDckIsT0FBTyxDQUFDLElBQVIsQ0FBYyxNQUFELElBQVksa0JBQVMsVUFBVCxDQUFvQixNQUFwQixDQUF6QixDQURxQixHQUVyQixJQUZKO0FBSUEsUUFBTSwwQkFBMEIsR0FDOUIsaUJBQWlCLEtBQUssSUFBdEIsSUFBOEIsS0FBSyxDQUFDLE9BQU4sQ0FBYyxpQkFBZCxDQUE5QixHQUNJLGlCQUFpQixDQUFDLElBQWxCLENBQXdCLGdCQUFELElBQ3JCLGtCQUFTLFVBQVQsQ0FBb0IsZ0JBQXBCLENBREYsQ0FESixHQUlJLElBTE47O0FBT0EsTUFBSSxDQUFDLGdCQUFMLEVBQXVCO0FBQ3JCLFdBQU8sR0FBRyxDQUNSLHdCQUFVLEdBQVYsQ0FBYyxhQUFkLENBQTRCO0FBQzFCLE1BQUEsT0FBTyxFQUFHLG9GQUFtRixPQUFRO0FBRDNFLEtBQTVCLENBRFEsQ0FBVjtBQUtEOztBQUVELE1BQUksaUJBQWlCLEtBQUssSUFBdEIsSUFBOEIsQ0FBQywwQkFBbkMsRUFBK0Q7QUFDN0QsV0FBTyxHQUFHLENBQ1Isd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FBNEI7QUFDMUIsTUFBQSxPQUFPLEVBQUcsaUdBQWdHLGlCQUFrQjtBQURsRyxLQUE1QixDQURRLENBQVY7QUFLRDs7QUFFRCxRQUFNLFFBQVEsR0FBRyxPQUFPLE9BQVAsS0FBbUIsUUFBbkIsSUFBK0IsT0FBTyxDQUFDLFdBQVIsRUFBaEQ7O0FBRUEsTUFBSSxDQUFDLDJDQUE2QixRQUE3QixDQUFMLEVBQTZDO0FBQzNDLFdBQU8sR0FBRyxDQUNSLHdCQUFVLEdBQVYsQ0FBYyxhQUFkLENBQTRCO0FBQzFCLE1BQUEsT0FBTyxFQUFHLHFGQUFvRixPQUFRO0FBRDVFLEtBQTVCLENBRFEsQ0FBVjtBQUtEOztBQUVELE1BQUksQ0FBQyw0QkFBYyxRQUFRLENBQUMsUUFBRCxFQUFXLEVBQVgsQ0FBdEIsQ0FBTCxFQUE0QztBQUMxQyxXQUFPLEdBQUcsQ0FDUix3QkFBVSxHQUFWLENBQWMsYUFBZCxDQUE0QjtBQUMxQixNQUFBLE9BQU8sRUFBRyxxQkFBb0IsUUFBUyw4REFBNkQsT0FBUTtBQURsRixLQUE1QixDQURRLENBQVY7QUFLRDs7QUFFRCxNQUFJLHFDQUEyQixRQUEzQixDQUFKLEVBQTBDO0FBQ3hDLFdBQU8sR0FBRyxDQUNSLHdCQUFVLEdBQVYsQ0FBYyxhQUFkLENBQTRCO0FBQzFCLE1BQUEsT0FBTyxFQUFHO0FBRGdCLEtBQTVCLENBRFEsQ0FBVjtBQUtEOztBQUVELFFBQU0sZUFBZSxHQUFHLGVBQWUsQ0FBQztBQUFFLElBQUEsT0FBTyxFQUFFO0FBQVgsR0FBRCxDQUF2Qzs7QUFFQSxNQUFJLGVBQUosRUFBcUI7QUFDbkI7QUFDQSxJQUFBLEdBQUcsQ0FBQyxNQUFKLEdBQWEsSUFBYjtBQUVBLFVBQU0sY0FBYyxHQUFHLGlCQUFpQixFQUF4Qzs7QUFDQSxRQUFJLGNBQWMsS0FBSyxRQUF2QixFQUFpQztBQUMvQixhQUFPLEdBQUcsRUFBVjtBQUNELEtBUGtCLENBU25COzs7QUFDQSxRQUFJO0FBQ0YsWUFBTSxlQUFlLENBQ25CLE1BQU0sbUJBQW1CLENBQUM7QUFDeEIsUUFBQSxNQUR3QjtBQUV4QixRQUFBLElBQUksRUFBRSxrQkFBYSxxQkFGSztBQUd4QixRQUFBLFdBQVcsRUFBRTtBQUNYLFVBQUEsTUFBTSxFQUFFLGVBQWUsQ0FBQyxNQURiO0FBRVgsVUFBQSxPQUFPLEVBQUUsZUFBZSxDQUFDLE9BRmQ7QUFHWCxVQUFBLFFBQVEsRUFBRSxlQUFlLENBQUMsUUFIZjtBQUlYLFVBQUEsTUFBTSxFQUFFLGVBQWUsQ0FBQztBQUpiO0FBSFcsT0FBRCxDQUROLENBQXJCO0FBWUEsTUFBQSxHQUFHLENBQUMsTUFBSixHQUFhLElBQWI7QUFDRCxLQWRELENBY0UsT0FBTyxLQUFQLEVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFJLEtBQUssQ0FBQyxJQUFOLEtBQWUseUJBQVcsUUFBWCxDQUFvQixtQkFBdkMsRUFBNEQ7QUFDMUQsZUFBTyxHQUFHLENBQUMsS0FBRCxDQUFWO0FBQ0Q7QUFDRjs7QUFDRCxXQUFPLEdBQUcsRUFBVjtBQUNEOztBQUVELE1BQUksZUFBSjs7QUFFQSxNQUFJO0FBQ0YsSUFBQSxlQUFlLEdBQUcsTUFBTSx5QkFBZSxnQkFBZixFQUFpQyxhQUFqQyxDQUF4QjtBQUNELEdBRkQsQ0FFRSxPQUFPLEdBQVAsRUFBWTtBQUNaLFdBQU8sR0FBRyxDQUNSLHdCQUFVLEdBQVYsQ0FBYyxRQUFkLENBQXVCO0FBQ3JCLE1BQUEsT0FBTyxFQUFHLHNDQUFxQyxnQkFBaUIsU0FEM0M7QUFFckIsTUFBQSxJQUFJLEVBQUU7QUFBRSxRQUFBLFVBQVUsRUFBRTtBQUFkO0FBRmUsS0FBdkIsQ0FEUSxDQUFWO0FBTUQ7O0FBRUQsTUFBSSxRQUFRLEtBQUssZUFBakIsRUFBa0M7QUFDaEMsV0FBTyxHQUFHLENBQ1Isd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FBNEI7QUFDMUIsTUFBQSxPQUFPLEVBQUcsZ0NBQStCLGdCQUFpQixtQkFBa0IsUUFBUyxFQUQzRDtBQUUxQixNQUFBLElBQUksRUFBRTtBQUFFLFFBQUEsT0FBTyxFQUFFO0FBQVg7QUFGb0IsS0FBNUIsQ0FEUSxDQUFWO0FBTUQ7O0FBRUQsTUFBSSxPQUFPLFNBQVAsS0FBcUIsUUFBckIsSUFBaUMsQ0FBQyxTQUF0QyxFQUFpRDtBQUMvQyxXQUFPLEdBQUcsQ0FDUix3QkFBVSxHQUFWLENBQWMsYUFBZCxDQUE0QjtBQUMxQixNQUFBLE9BQU8sRUFBRyxxREFBb0QsU0FBVTtBQUQ5QyxLQUE1QixDQURRLENBQVY7QUFLRDs7QUFDRCxRQUFNLFVBQVUsR0FDZCxTQUFTLENBQUMsTUFBVixHQUFtQixHQUFuQixHQUF5QixTQUFTLENBQUMsU0FBVixDQUFvQixDQUFwQixFQUF1QixHQUF2QixDQUF6QixHQUF1RCxTQUR6RDs7QUFHQSxNQUFJLGNBQWMsS0FBSyxJQUF2QixFQUE2QjtBQUMzQixRQUFJLE9BQU8sY0FBUCxLQUEwQixRQUExQixJQUFzQyxLQUFLLENBQUMsT0FBTixDQUFjLGNBQWQsQ0FBMUMsRUFBeUU7QUFDdkUsYUFBTyxHQUFHLENBQ1Isd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FBNEI7QUFDMUIsUUFBQSxPQUFPLEVBQUcsd0RBQXVELGNBQWU7QUFEdEQsT0FBNUIsQ0FEUSxDQUFWO0FBS0Q7O0FBQ0QsUUFBSSxjQUFjLENBQUMsUUFBZixLQUE0QixFQUFoQyxFQUFvQztBQUNsQyxhQUFPLEdBQUcsQ0FDUix3QkFBVSxHQUFWLENBQWMsYUFBZCxDQUE0QjtBQUMxQixRQUFBLE9BQU8sRUFBRyxxR0FBb0csY0FBYyxDQUFDLFFBQVM7QUFENUcsT0FBNUIsQ0FEUSxDQUFWO0FBS0Q7O0FBRUQsUUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFoQixJQUEwQixPQUFPLGNBQWMsQ0FBQyxNQUF0QixLQUFpQyxRQUEvRCxFQUF5RTtBQUN2RSxhQUFPLEdBQUcsQ0FDUix3QkFBVSxHQUFWLENBQWMsYUFBZCxDQUE0QjtBQUMxQixRQUFBLE9BQU8sRUFBRyx3REFBdUQsY0FBYyxDQUFDLE1BQU87QUFEN0QsT0FBNUIsQ0FEUSxDQUFWO0FBS0Q7QUFDRjs7QUFDRCxRQUFNLE1BQU0sR0FBRyxDQUFBLGNBQWMsU0FBZCxJQUFBLGNBQWMsV0FBZCxZQUFBLGNBQWMsQ0FBRSxNQUFoQixLQUEwQixLQUF6Qzs7QUFFQSxNQUFJLE9BQU8sTUFBUCxLQUFrQixRQUFsQixJQUE4QixNQUFNLENBQUMsTUFBUCxHQUFnQixDQUE5QyxJQUFtRCxNQUFNLENBQUMsTUFBUCxHQUFnQixDQUF2RSxFQUEwRTtBQUN4RSxXQUFPLEdBQUcsQ0FDUix3QkFBVSxHQUFWLENBQWMsYUFBZCxDQUE0QjtBQUMxQixNQUFBLE9BQU8sRUFBRyxxRUFBb0UsTUFBTztBQUQzRCxLQUE1QixDQURRLENBQVY7QUFLRDs7QUFFRCxNQUFJO0FBQ0YsVUFBTSxZQUFZLENBQ2hCLE1BQU0sbUJBQW1CLENBQUM7QUFDeEIsTUFBQSxNQUR3QjtBQUV4QixNQUFBLElBQUksRUFBRSxrQkFBYSxrQkFGSztBQUd4QixNQUFBLFdBQVcsRUFBRTtBQUNYLFFBQUEsT0FBTyxFQUFFLFFBREU7QUFFWCxRQUFBLGdCQUFnQixFQUFFLDBCQUZQO0FBR1gsUUFBQSxTQUFTLEVBQUUsVUFIQTtBQUlYLFFBQUEsTUFBTSxFQUFFLGdCQUpHO0FBS1gsUUFBQTtBQUxXO0FBSFcsS0FBRCxDQURULENBQWxCO0FBY0EsSUFBQSxXQUFXLENBQUM7QUFDVixNQUFBLEtBQUssRUFBRSxzQkFERztBQUVWLE1BQUEsUUFBUSxFQUFFLFNBRkE7QUFHVixNQUFBLFFBQVEsRUFBRTtBQUNSLFFBQUEsR0FBRyxFQUFFO0FBREcsT0FIQTtBQU1WLE1BQUEsbUJBQW1CLEVBQUU7QUFDbkIsUUFBQSxRQUFRLEVBQUUsUUFEUztBQUVuQixRQUFBLE9BQU8sRUFBRSxnQkFGVTtBQUduQixRQUFBLFlBQVksRUFBRSxVQUhLO0FBSW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBQSxPQUFPLEVBQUUsZ0JBUlU7QUFTbkIsUUFBQSxNQUFNLEVBQUUsTUFUVztBQVVuQixRQUFBLGtCQUFrQixFQUFFLDBCQVZEO0FBV25CLFFBQUEsTUFBTSxFQUFFO0FBWFc7QUFOWCxLQUFELENBQVgsQ0FmRSxDQW9DRjs7QUFDQSxJQUFBLEdBQUcsQ0FBQyxNQUFKLEdBQWEsSUFBYjtBQUNELEdBdENELENBc0NFLE9BQU8sS0FBUCxFQUFjO0FBQ2QsV0FBTyxHQUFHLENBQUMsS0FBRCxDQUFWO0FBQ0QsR0E1T0QsQ0E4T0E7OztBQUNBLE1BQUk7QUFDRixVQUFNLGVBQWUsQ0FDbkIsTUFBTSxtQkFBbUIsQ0FBQztBQUN4QixNQUFBLE1BRHdCO0FBRXhCLE1BQUEsSUFBSSxFQUFFLGtCQUFhLHFCQUZLO0FBR3hCLE1BQUEsV0FBVyxFQUFFO0FBQ1gsUUFBQSxNQUFNLEVBQUUsZ0JBREc7QUFFWCxRQUFBLE9BQU8sRUFBRSxRQUZFO0FBR1gsUUFBQSxRQUFRLEVBQUUsVUFIQztBQUlYLFFBQUE7QUFKVztBQUhXLEtBQUQsQ0FETixDQUFyQjtBQVlELEdBYkQsQ0FhRSxPQUFPLEtBQVAsRUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFFBQUksS0FBSyxDQUFDLElBQU4sS0FBZSx5QkFBVyxRQUFYLENBQW9CLG1CQUF2QyxFQUE0RDtBQUMxRCxhQUFPLEdBQUcsQ0FBQyxLQUFELENBQVY7QUFDRDtBQUNGOztBQUNELFNBQU8sR0FBRyxFQUFWO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM1NEOzs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsTUFBTSxnQkFBZ0IsR0FBRztBQUN2QixFQUFBLFdBQVcsRUFBRSxDQUFDLGtCQUFhLGtCQUFkLENBRFU7QUFFdkIsRUFBQSxjQUFjLEVBQUUsdUJBRk87QUFHdkIsRUFBQSxTQUFTLEVBQUU7QUFDVCxJQUFBLGdCQUFnQixFQUFFO0FBRFQ7QUFIWSxDQUF6QjtlQU9lLGdCO0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQSxlQUFlLHVCQUFmLENBQ0UsR0FERixFQUVFLEdBRkYsRUFHRSxLQUhGLEVBSUUsR0FKRixFQUtFO0FBQUUsRUFBQSxnQkFBZ0IsRUFBRTtBQUFwQixDQUxGLEVBTUU7QUFDQSxFQUFBLEdBQUcsQ0FBQyxNQUFKLHFCQUNNLE1BQU0saUJBQWlCLENBQUMsR0FBRyxDQUFDLE1BQUwsQ0FEN0I7QUFHQSxTQUFPLEdBQUcsRUFBVjtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEREOztBQUNBOzs7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxNQUFNLFlBQVksR0FBRztBQUNuQixFQUFBLFdBQVcsRUFBRSxDQUFDLGtCQUFhLGFBQWQsQ0FETTtBQUVuQixFQUFBLGNBQWMsRUFBRSxtQkFGRztBQUduQixFQUFBLFNBQVMsRUFBRTtBQUNULElBQUEsa0JBQWtCLEVBQUUsSUFEWDtBQUVULElBQUEsV0FBVyxFQUFFO0FBRko7QUFIUSxDQUFyQjtlQVFlLFk7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQSxTQUFTLG1CQUFULENBQ0UsR0FERixFQUVFLEdBRkYsRUFHRSxLQUhGLEVBSUUsR0FKRixFQUtFO0FBQUUsRUFBQSxrQkFBRjtBQUFzQixFQUFBO0FBQXRCLENBTEYsRUFNRTtBQUNBLFFBQU07QUFBRSxJQUFBLE1BQUY7QUFBVSxJQUFBO0FBQVYsTUFBcUIsR0FBM0I7O0FBQ0EsTUFBSSxNQUFNLElBQUksT0FBTyxNQUFQLEtBQWtCLFFBQTVCLElBQXdDLENBQUMsS0FBSyxDQUFDLE9BQU4sQ0FBYyxNQUFkLENBQTdDLEVBQW9FO0FBQ2xFLFVBQU07QUFBRSxNQUFBLElBQUksR0FBRyxJQUFUO0FBQWUsTUFBQSxJQUFJLEdBQUc7QUFBdEIsUUFBbUQsTUFBekQ7QUFBQSxVQUFxQyxlQUFyQywwQ0FBeUQsTUFBekQ7QUFFQSxJQUFBLGtCQUFrQixpQ0FDYixlQURhO0FBRWhCLE1BQUEsT0FBTyxFQUFFLElBRk87QUFHaEIsTUFBQSxJQUhnQjtBQUloQixNQUFBLFdBSmdCO0FBS2hCLE1BQUE7QUFMZ0IsT0FBbEI7QUFPRCxHQVZELE1BVU87QUFDTCxXQUFPLEdBQUcsQ0FBQyx3QkFBVSxHQUFWLENBQWMsYUFBZCxDQUE0QjtBQUFFLE1BQUEsSUFBSSxFQUFFO0FBQVIsS0FBNUIsQ0FBRCxDQUFWO0FBQ0Q7O0FBRUQsRUFBQSxHQUFHLENBQUMsTUFBSixHQUFhLElBQWI7QUFDQSxTQUFPLEdBQUcsRUFBVjtBQUNEOzs7Ozs7Ozs7Ozs7QUN6REQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN6bkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNOQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3QxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwTEE7QUFDQTs7Ozs7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNoUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2NEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDamRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JnQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pKQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9iQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDOWJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDandDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNqUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcmJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDemdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImJhY2tncm91bmQtMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTXVsdGloYXNoIGltcGxlbWVudGF0aW9uIGluIEphdmFTY3JpcHQuXG4gKlxuICogQG1vZHVsZSBtdWx0aWhhc2hcbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJzNTggPSByZXF1aXJlKCdiczU4JylcblxuY29uc3QgY3MgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbmV4cG9ydHMubmFtZXMgPSBjcy5uYW1lc1xuZXhwb3J0cy5jb2RlcyA9IGNzLmNvZGVzXG5leHBvcnRzLmRlZmF1bHRMZW5ndGhzID0gY3MuZGVmYXVsdExlbmd0aHNcblxuY29uc3QgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBtdWx0aWhhc2ggdG8gYSBoZXggZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGhhc2hcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMudG9IZXhTdHJpbmcgPSBmdW5jdGlvbiB0b0hleFN0cmluZyAoaGFzaCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihoYXNoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBiZSBwYXNzZWQgYSBidWZmZXInKVxuICB9XG5cbiAgcmV0dXJuIGhhc2gudG9TdHJpbmcoJ2hleCcpXG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gaGV4IGVuY29kZWQgc3RyaW5nIHRvIGEgbXVsdGloYXNoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5leHBvcnRzLmZyb21IZXhTdHJpbmcgPSBmdW5jdGlvbiBmcm9tSGV4U3RyaW5nIChoYXNoKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShoYXNoLCAnaGV4Jylcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBtdWx0aWhhc2ggdG8gYSBiYXNlNTggZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGhhc2hcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMudG9CNThTdHJpbmcgPSBmdW5jdGlvbiB0b0I1OFN0cmluZyAoaGFzaCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihoYXNoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBiZSBwYXNzZWQgYSBidWZmZXInKVxuICB9XG5cbiAgcmV0dXJuIGJzNTguZW5jb2RlKGhhc2gpXG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gYmFzZTU4IGVuY29kZWQgc3RyaW5nIHRvIGEgbXVsdGloYXNoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gaGFzaFxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5mcm9tQjU4U3RyaW5nID0gZnVuY3Rpb24gZnJvbUI1OFN0cmluZyAoaGFzaCkge1xuICBsZXQgZW5jb2RlZCA9IGhhc2hcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihoYXNoKSkge1xuICAgIGVuY29kZWQgPSBoYXNoLnRvU3RyaW5nKClcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShiczU4LmRlY29kZShlbmNvZGVkKSlcbn1cblxuLyoqXG4gKiBEZWNvZGUgYSBoYXNoIGZyb20gdGhlIGdpdmVuIG11bHRpaGFzaC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gKiBAcmV0dXJucyB7e2NvZGU6IG51bWJlciwgbmFtZTogc3RyaW5nLCBsZW5ndGg6IG51bWJlciwgZGlnZXN0OiBCdWZmZXJ9fSByZXN1bHRcbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUgKGJ1Zikge1xuICBpZiAoIShCdWZmZXIuaXNCdWZmZXIoYnVmKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpaGFzaCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChidWYubGVuZ3RoIDwgMykge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVsdGloYXNoIHRvbyBzaG9ydC4gbXVzdCBiZSA+IDMgYnl0ZXMuJylcbiAgfVxuXG4gIGNvbnN0IGNvZGUgPSB2YXJpbnQuZGVjb2RlKGJ1ZilcbiAgaWYgKCFleHBvcnRzLmlzVmFsaWRDb2RlKGNvZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtdWx0aWhhc2ggdW5rbm93biBmdW5jdGlvbiBjb2RlOiAweCR7Y29kZS50b1N0cmluZygxNil9YClcbiAgfVxuICBidWYgPSBidWYuc2xpY2UodmFyaW50LmRlY29kZS5ieXRlcylcblxuICBjb25zdCBsZW4gPSB2YXJpbnQuZGVjb2RlKGJ1ZilcbiAgaWYgKGxlbiA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG11bHRpaGFzaCBpbnZhbGlkIGxlbmd0aDogMHgke2xlbi50b1N0cmluZygxNil9YClcbiAgfVxuICBidWYgPSBidWYuc2xpY2UodmFyaW50LmRlY29kZS5ieXRlcylcblxuICBpZiAoYnVmLmxlbmd0aCAhPT0gbGVuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtdWx0aWhhc2ggbGVuZ3RoIGluY29uc2lzdGVudDogMHgke2J1Zi50b1N0cmluZygnaGV4Jyl9YClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29kZTogY29kZSxcbiAgICBuYW1lOiBjcy5jb2Rlc1tjb2RlXSxcbiAgICBsZW5ndGg6IGxlbixcbiAgICBkaWdlc3Q6IGJ1ZlxuICB9XG59XG5cbi8qKlxuICogIEVuY29kZSBhIGhhc2ggZGlnZXN0IGFsb25nIHdpdGggdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBjb2RlLlxuICpcbiAqID4gKipOb3RlOioqIHRoZSBsZW5ndGggaXMgZGVyaXZlZCBmcm9tIHRoZSBsZW5ndGggb2YgdGhlIGRpZ2VzdCBpdHNlbGYuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGRpZ2VzdFxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBjb2RlXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF1cbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlIChkaWdlc3QsIGNvZGUsIGxlbmd0aCkge1xuICBpZiAoIWRpZ2VzdCB8fCBjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpaGFzaCBlbmNvZGUgcmVxdWlyZXMgYXQgbGVhc3QgdHdvIGFyZ3M6IGRpZ2VzdCwgY29kZScpXG4gIH1cblxuICAvLyBlbnN1cmUgaXQncyBhIGhhc2hmdW5jdGlvbiBjb2RlLlxuICBjb25zdCBoYXNoZm4gPSBleHBvcnRzLmNvZXJjZUNvZGUoY29kZSlcblxuICBpZiAoIShCdWZmZXIuaXNCdWZmZXIoZGlnZXN0KSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKGxlbmd0aCA9PSBudWxsKSB7XG4gICAgbGVuZ3RoID0gZGlnZXN0Lmxlbmd0aFxuICB9XG5cbiAgaWYgKGxlbmd0aCAmJiBkaWdlc3QubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCBsZW5ndGggc2hvdWxkIGJlIGVxdWFsIHRvIHNwZWNpZmllZCBsZW5ndGguJylcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtcbiAgICBCdWZmZXIuZnJvbSh2YXJpbnQuZW5jb2RlKGhhc2hmbikpLFxuICAgIEJ1ZmZlci5mcm9tKHZhcmludC5lbmNvZGUobGVuZ3RoKSksXG4gICAgZGlnZXN0XG4gIF0pXG59XG5cbi8qKlxuICogQ29udmVydHMgYSBoYXNoIGZ1bmN0aW9uIG5hbWUgaW50byB0aGUgbWF0Y2hpbmcgY29kZS5cbiAqIElmIHBhc3NlZCBhIG51bWJlciBpdCB3aWxsIHJldHVybiB0aGUgbnVtYmVyIGlmIGl0J3MgYSB2YWxpZCBjb2RlLlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLmNvZXJjZUNvZGUgPSBmdW5jdGlvbiBjb2VyY2VDb2RlIChuYW1lKSB7XG4gIGxldCBjb2RlID0gbmFtZVxuXG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoY3MubmFtZXNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgaGFzaCBmdW5jdGlvbiBuYW1lZDogJHtuYW1lfWApXG4gICAgfVxuICAgIGNvZGUgPSBjcy5uYW1lc1tuYW1lXVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgSGFzaCBmdW5jdGlvbiBjb2RlIHNob3VsZCBiZSBhIG51bWJlci4gR290OiAke2NvZGV9YClcbiAgfVxuXG4gIGlmIChjcy5jb2Rlc1tjb2RlXSA9PT0gdW5kZWZpbmVkICYmICFleHBvcnRzLmlzQXBwQ29kZShjb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGZ1bmN0aW9uIGNvZGU6ICR7Y29kZX1gKVxuICB9XG5cbiAgcmV0dXJuIGNvZGVcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2V0aGVyIGEgY29kZSBpcyBwYXJ0IG9mIHRoZSBhcHAgcmFuZ2VcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNBcHBDb2RlID0gZnVuY3Rpb24gYXBwQ29kZSAoY29kZSkge1xuICByZXR1cm4gY29kZSA+IDAgJiYgY29kZSA8IDB4MTBcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIG11bHRpaGFzaCBjb2RlIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQ29kZSA9IGZ1bmN0aW9uIHZhbGlkQ29kZSAoY29kZSkge1xuICBpZiAoZXhwb3J0cy5pc0FwcENvZGUoY29kZSkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKGNzLmNvZGVzW2NvZGVdKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBidWZmZXIgaXMgYSB2YWxpZCBtdWx0aWhhc2guIFRocm93cyBhbiBlcnJvciBpZiBpdCBpcyBub3QgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IG11bHRpaGFzaFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEB0aHJvd3Mge0Vycm9yfVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZSAobXVsdGloYXNoKSB7XG4gIGV4cG9ydHMuZGVjb2RlKG11bHRpaGFzaCkgLy8gdGhyb3dzIGlmIGJhZC5cbn1cbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZVxuXG4vKipcbiAqIFJldHVybnMgYSBwcmVmaXggZnJvbSBhIHZhbGlkIG11bHRpaGFzaC4gVGhyb3dzIGFuIGVycm9yIGlmIGl0IGlzIG5vdCB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbXVsdGloYXNoXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHRocm93cyB7RXJyb3J9XG4gKi9cbmV4cG9ydHMucHJlZml4ID0gZnVuY3Rpb24gcHJlZml4IChtdWx0aWhhc2gpIHtcbiAgdmFsaWRhdGUobXVsdGloYXNoKVxuXG4gIHJldHVybiBtdWx0aWhhc2guc2xpY2UoMCwgMilcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwU2VyaWVzID0gcmVxdWlyZSgncC1zZXJpZXMnKVxuY29uc3QgUGVlck1vbml0b3IgPSByZXF1aXJlKCdpcGZzLXB1YnN1Yi1wZWVyLW1vbml0b3InKVxuXG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCdsb2dwbGVhc2UnKVxuY29uc3QgbG9nZ2VyID0gTG9nZ2VyLmNyZWF0ZShcInB1YnN1YlwiLCB7IGNvbG9yOiBMb2dnZXIuQ29sb3JzLlllbGxvdyB9KVxuTG9nZ2VyLnNldExvZ0xldmVsKCdFUlJPUicpXG5cbmNvbnN0IG1heFRvcGljc09wZW4gPSAyNTZcbmxldCB0b3BpY3NPcGVuQ291bnQgPSAwXG5cbmNsYXNzIElQRlNQdWJzdWIge1xuICBjb25zdHJ1Y3RvcihpcGZzLCBpZCkge1xuICAgIHRoaXMuX2lwZnMgPSBpcGZzXG4gICAgdGhpcy5faWQgPSBpZFxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSB7fVxuXG4gICAgaWYgKHRoaXMuX2lwZnMucHVic3ViID09PSBudWxsKVxuICAgICAgbG9nZ2VyLmVycm9yKFwiVGhlIHByb3ZpZGVkIHZlcnNpb24gb2YgaXBmcyBkb2Vzbid0IGhhdmUgcHVic3ViIHN1cHBvcnQuIE1lc3NhZ2VzIHdpbGwgbm90IGJlIGV4Y2hhbmdlZC5cIilcblxuICAgIHRoaXMuX2hhbmRsZU1lc3NhZ2UgPSB0aGlzLl9oYW5kbGVNZXNzYWdlLmJpbmQodGhpcylcblxuICAgIC8vIEJ1bXAgdXAgdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgd2UgY2FuIGhhdmUgb3BlbixcbiAgICAvLyBpZS4gbnVtYmVyIG9mIGRhdGFiYXNlcyByZXBsaWNhdGluZ1xuICAgIGlmICh0aGlzLl9pcGZzLnNldE1heExpc3RlbmVycylcbiAgICAgIHRoaXMuX2lwZnMuc2V0TWF4TGlzdGVuZXJzKG1heFRvcGljc09wZW4pXG4gIH1cblxuICBhc3luYyBzdWJzY3JpYmUodG9waWMsIG9uTWVzc2FnZUNhbGxiYWNrLCBvbk5ld1BlZXJDYWxsYmFjaykge1xuICAgIGlmKCF0aGlzLl9zdWJzY3JpcHRpb25zW3RvcGljXSAmJiB0aGlzLl9pcGZzLnB1YnN1Yikge1xuICAgICAgYXdhaXQgdGhpcy5faXBmcy5wdWJzdWIuc3Vic2NyaWJlKHRvcGljLCB0aGlzLl9oYW5kbGVNZXNzYWdlKVxuXG4gICAgICBjb25zdCB0b3BpY01vbml0b3IgPSBuZXcgUGVlck1vbml0b3IodGhpcy5faXBmcy5wdWJzdWIsIHRvcGljKVxuXG4gICAgICB0b3BpY01vbml0b3Iub24oJ2pvaW4nLCAocGVlcikgPT4ge1xuICAgICAgICBsb2dnZXIuZGVidWcoYFBlZXIgam9pbmVkICR7dG9waWN9OmApXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhwZWVyKVxuICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uc1t0b3BpY10pIHtcbiAgICAgICAgICBvbk5ld1BlZXJDYWxsYmFjayh0b3BpYywgcGVlcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIud2FybignUGVlciBqb2luZWQgYSByb29tIHdlIGRvblxcJ3QgaGF2ZSBhIHN1YnNjcmlwdGlvbiBmb3InKVxuICAgICAgICAgIGxvZ2dlci53YXJuKHRvcGljLCBwZWVyKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICB0b3BpY01vbml0b3Iub24oJ2xlYXZlJywgKHBlZXIpID0+IGxvZ2dlci5kZWJ1ZyhgUGVlciAke3BlZXJ9IGxlZnQgJHt0b3BpY31gKSlcbiAgICAgIHRvcGljTW9uaXRvci5vbignZXJyb3InLCAoZSkgPT4gbG9nZ2VyLmVycm9yKGUpKVxuXG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW3RvcGljXSA9IHtcbiAgICAgICAgdG9waWNNb25pdG9yOiB0b3BpY01vbml0b3IsXG4gICAgICAgIG9uTWVzc2FnZTogb25NZXNzYWdlQ2FsbGJhY2ssXG4gICAgICAgIG9uTmV3UGVlcjogb25OZXdQZWVyQ2FsbGJhY2tcbiAgICAgIH1cblxuICAgICAgdG9waWNzT3BlbkNvdW50ICsrXG4gICAgICBsb2dnZXIuZGVidWcoXCJUb3BpY3Mgb3BlbjpcIiwgdG9waWNzT3BlbkNvdW50KVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHVuc3Vic2NyaWJlKGhhc2gpIHtcbiAgICBpZih0aGlzLl9zdWJzY3JpcHRpb25zW2hhc2hdKSB7XG4gICAgICBhd2FpdCB0aGlzLl9pcGZzLnB1YnN1Yi51bnN1YnNjcmliZShoYXNoLCB0aGlzLl9oYW5kbGVNZXNzYWdlKVxuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc1toYXNoXS50b3BpY01vbml0b3Iuc3RvcCgpXG4gICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uc1toYXNoXVxuICAgICAgbG9nZ2VyLmRlYnVnKGBVbnN1YnNjcmliZWQgZnJvbSAnJHtoYXNofSdgKVxuICAgICAgdG9waWNzT3BlbkNvdW50IC0tXG4gICAgICBsb2dnZXIuZGVidWcoXCJUb3BpY3Mgb3BlbjpcIiwgdG9waWNzT3BlbkNvdW50KVxuICAgIH1cbiAgfVxuXG4gIHB1Ymxpc2godG9waWMsIG1lc3NhZ2UpIHtcbiAgICBpZih0aGlzLl9zdWJzY3JpcHRpb25zW3RvcGljXSAmJiB0aGlzLl9pcGZzLnB1YnN1Yikge1xuICAgICAgdGhpcy5faXBmcy5wdWJzdWIucHVibGlzaCh0b3BpYywgQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgY29uc3QgdG9waWNzID0gT2JqZWN0LmtleXModGhpcy5fc3Vic2NyaXB0aW9ucylcbiAgICBhd2FpdCBwU2VyaWVzKHRvcGljcy5tYXAoKHQpID0+IHRoaXMudW5zdWJzY3JpYmUuYmluZCh0aGlzLCB0KSkpXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IHt9XG4gIH1cblxuICBhc3luYyBfaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgLy8gRG9uJ3QgcHJvY2VzcyBvdXIgb3duIG1lc3NhZ2VzXG4gICAgaWYgKG1lc3NhZ2UuZnJvbSA9PT0gdGhpcy5faWQpXG4gICAgICByZXR1cm5cblxuICAgIC8vIEdldCB0aGUgbWVzc2FnZSBjb250ZW50IGFuZCBhIHN1YnNjcmlwdGlvblxuICAgIGxldCBjb250ZW50LCBzdWJzY3JpcHRpb24sIHRvcGljSWRcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IHRoZSB0b3BpY1xuICAgICAgdG9waWNJZCA9IG1lc3NhZ2UudG9waWNJRHNbMF1cbiAgICAgIGNvbnRlbnQgPSBKU09OLnBhcnNlKG1lc3NhZ2UuZGF0YSlcbiAgICAgIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnNbdG9waWNJZF1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoZSlcbiAgICAgIGxvZ2dlci5lcnJvcignQ291bGRuXFwndCBwYXJzZSBwdWJzdWIgbWVzc2FnZTonLCBtZXNzYWdlKVxuICAgIH1cblxuICAgIGlmKHN1YnNjcmlwdGlvbiAmJiBzdWJzY3JpcHRpb24ub25NZXNzYWdlICYmIGNvbnRlbnQpIHtcbiAgICAgIGF3YWl0IHN1YnNjcmlwdGlvbi5vbk1lc3NhZ2UodG9waWNJZCwgY29udGVudClcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJUEZTUHVic3ViXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcEVhY2hTZXJpZXMgPSByZXF1aXJlKCdwLWVhY2gtc2VyaWVzJylcbmNvbnN0IEdTZXQgPSByZXF1aXJlKCcuL2ctc2V0JylcbmNvbnN0IEVudHJ5ID0gcmVxdWlyZSgnLi9lbnRyeScpXG5jb25zdCBMb2dJTyA9IHJlcXVpcmUoJy4vbG9nLWlvJylcbmNvbnN0IExvZ0Vycm9yID0gcmVxdWlyZSgnLi9sb2ctZXJyb3JzJylcbmNvbnN0IENsb2NrID0gcmVxdWlyZSgnLi9sYW1wb3J0LWNsb2NrJylcbmNvbnN0IFNvcnRpbmcgPSByZXF1aXJlKCcuL2xvZy1zb3J0aW5nJylcbmNvbnN0IHsgTGFzdFdyaXRlV2lucywgTm9aZXJvZXMgfSA9IFNvcnRpbmdcbmNvbnN0IEFjY2Vzc0NvbnRyb2xsZXIgPSByZXF1aXJlKCcuL2RlZmF1bHQtYWNjZXNzLWNvbnRyb2xsZXInKVxuY29uc3QgeyBpc0RlZmluZWQsIGZpbmRVbmlxdWVzIH0gPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IEVudHJ5SW5kZXggPSByZXF1aXJlKCcuL2VudHJ5LWluZGV4JylcbmNvbnN0IHJhbmRvbUlkID0gKCkgPT4gbmV3IERhdGUoKS5nZXRUaW1lKCkudG9TdHJpbmcoKVxuY29uc3QgZ2V0SGFzaCA9IGUgPT4gZS5oYXNoXG5jb25zdCBmbGF0TWFwID0gKHJlcywgYWNjKSA9PiByZXMuY29uY2F0KGFjYylcbmNvbnN0IGdldE5leHRQb2ludGVycyA9IGVudHJ5ID0+IGVudHJ5Lm5leHRcbmNvbnN0IG1heENsb2NrVGltZVJlZHVjZXIgPSAocmVzLCBhY2MpID0+IE1hdGgubWF4KHJlcywgYWNjLmNsb2NrLnRpbWUpXG5jb25zdCB1bmlxdWVFbnRyaWVzUmVkdWNlciA9IChyZXMsIGFjYykgPT4ge1xuICByZXNbYWNjLmhhc2hdID0gYWNjXG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBMb2cuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBMb2cgaW1wbGVtZW50cyBhIEctU2V0IENSRFQgYW5kIGFkZHMgb3JkZXJpbmcuXG4gKlxuICogRnJvbTpcbiAqIFwiQSBjb21wcmVoZW5zaXZlIHN0dWR5IG9mIENvbnZlcmdlbnQgYW5kIENvbW11dGF0aXZlIFJlcGxpY2F0ZWQgRGF0YSBUeXBlc1wiXG4gKiBodHRwczovL2hhbC5pbnJpYS5mci9pbnJpYS0wMDU1NTU4OFxuICovXG5jbGFzcyBMb2cgZXh0ZW5kcyBHU2V0IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBMb2cgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtJUEZTfSBpcGZzIEFuIElQRlMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGlkZW50aXR5IElkZW50aXR5IChodHRwczovL2dpdGh1Yi5jb20vb3JiaXRkYi9vcmJpdC1kYi1pZGVudGl0eS1wcm92aWRlci9ibG9iL21hc3Rlci9zcmMvaWRlbnRpdHkuanMpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxvZ0lkIElEIG9mIHRoZSBsb2dcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuYWNjZXNzIEFjY2Vzc0NvbnRyb2xsZXIgKC4vZGVmYXVsdC1hY2Nlc3MtY29udHJvbGxlcilcbiAgICogQHBhcmFtIHtBcnJheTxFbnRyeT59IG9wdGlvbnMuZW50cmllcyBBbiBBcnJheSBvZiBFbnRyaWVzIGZyb20gd2hpY2ggdG8gY3JlYXRlIHRoZSBsb2dcbiAgICogQHBhcmFtIHtBcnJheTxFbnRyeT59IG9wdGlvbnMuaGVhZHMgU2V0IHRoZSBoZWFkcyBvZiB0aGUgbG9nXG4gICAqIEBwYXJhbSB7Q2xvY2t9IG9wdGlvbnMuY2xvY2sgU2V0IHRoZSBjbG9jayBvZiB0aGUgbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuc29ydEZuIFRoZSBzb3J0IGZ1bmN0aW9uIC0gYnkgZGVmYXVsdCBMYXN0V3JpdGVXaW5zXG4gICAqIEByZXR1cm4ge0xvZ30gVGhlIGxvZyBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGlwZnMsIGlkZW50aXR5LCB7IGxvZ0lkLCBhY2Nlc3MsIGVudHJpZXMsIGhlYWRzLCBjbG9jaywgc29ydEZuIH0gPSB7fSkge1xuICAgIGlmICghaXNEZWZpbmVkKGlwZnMpKSB7XG4gICAgICB0aHJvdyBMb2dFcnJvci5JUEZTTm90RGVmaW5lZEVycm9yKClcbiAgICB9XG5cbiAgICBpZiAoIWlzRGVmaW5lZChpZGVudGl0eSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWRlbnRpdHkgaXMgcmVxdWlyZWQnKVxuICAgIH1cblxuICAgIGlmICghaXNEZWZpbmVkKGFjY2VzcykpIHtcbiAgICAgIGFjY2VzcyA9IG5ldyBBY2Nlc3NDb250cm9sbGVyKClcbiAgICB9XG5cbiAgICBpZiAoaXNEZWZpbmVkKGVudHJpZXMpICYmICFBcnJheS5pc0FycmF5KGVudHJpZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCdlbnRyaWVzJyBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5IG9mIEVudHJ5IGluc3RhbmNlc2ApXG4gICAgfVxuXG4gICAgaWYgKGlzRGVmaW5lZChoZWFkcykgJiYgIUFycmF5LmlzQXJyYXkoaGVhZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCdoZWFkcycgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheWApXG4gICAgfVxuXG4gICAgaWYgKCFpc0RlZmluZWQoc29ydEZuKSkge1xuICAgICAgc29ydEZuID0gTGFzdFdyaXRlV2luc1xuICAgIH1cblxuICAgIHN1cGVyKClcblxuICAgIHRoaXMuX3NvcnRGbiA9IE5vWmVyb2VzKHNvcnRGbilcblxuICAgIHRoaXMuX3N0b3JhZ2UgPSBpcGZzXG4gICAgdGhpcy5faWQgPSBsb2dJZCB8fCByYW5kb21JZCgpXG5cbiAgICAvLyBBY2Nlc3MgQ29udHJvbGxlclxuICAgIHRoaXMuX2FjY2VzcyA9IGFjY2Vzc1xuICAgIC8vIElkZW50aXR5XG4gICAgdGhpcy5faWRlbnRpdHkgPSBpZGVudGl0eVxuXG4gICAgLy8gQWRkIGVudHJpZXMgdG8gdGhlIGludGVybmFsIGNhY2hlXG4gICAgZW50cmllcyA9IGVudHJpZXMgfHwgW11cbiAgICB0aGlzLl9lbnRyeUluZGV4ID0gbmV3IEVudHJ5SW5kZXgoZW50cmllcy5yZWR1Y2UodW5pcXVlRW50cmllc1JlZHVjZXIsIHt9KSlcblxuICAgIC8vIFNldCBoZWFkcyBpZiBub3QgcGFzc2VkIGFzIGFuIGFyZ3VtZW50XG4gICAgaGVhZHMgPSBoZWFkcyB8fCBMb2cuZmluZEhlYWRzKGVudHJpZXMpXG4gICAgdGhpcy5faGVhZHNJbmRleCA9IGhlYWRzLnJlZHVjZSh1bmlxdWVFbnRyaWVzUmVkdWNlciwge30pXG5cbiAgICAvLyBJbmRleCBvZiBhbGwgbmV4dCBwb2ludGVycyBpbiB0aGlzIGxvZ1xuICAgIHRoaXMuX25leHRzSW5kZXggPSB7fVxuICAgIGNvbnN0IGFkZFRvTmV4dHNJbmRleCA9IGUgPT4gZS5uZXh0LmZvckVhY2goYSA9PiAodGhpcy5fbmV4dHNJbmRleFthXSA9IGUuaGFzaCkpXG4gICAgZW50cmllcy5mb3JFYWNoKGFkZFRvTmV4dHNJbmRleClcblxuICAgIC8vIFNldCB0aGUgbGVuZ3RoLCB3ZSBjYWxjdWxhdGUgdGhlIGxlbmd0aCBtYW51YWxseSBpbnRlcm5hbGx5XG4gICAgdGhpcy5fbGVuZ3RoID0gZW50cmllcy5sZW5ndGhcblxuICAgIC8vIFNldCB0aGUgY2xvY2tcbiAgICBjb25zdCBtYXhUaW1lID0gTWF0aC5tYXgoY2xvY2sgPyBjbG9jay50aW1lIDogMCwgdGhpcy5oZWFkcy5yZWR1Y2UobWF4Q2xvY2tUaW1lUmVkdWNlciwgMCkpXG4gICAgLy8gVGFrZSB0aGUgZ2l2ZW4ga2V5IGFzIHRoZSBjbG9jayBpZCBpcyBpdCdzIGEgS2V5IGluc3RhbmNlLFxuICAgIC8vIG90aGVyd2lzZSBpZiBrZXkgd2FzIGdpdmVuLCB0YWtlIHdoYXRldmVyIGl0IGlzLFxuICAgIC8vIGFuZCBpZiBpdCB3YXMgbnVsbCwgdGFrZSB0aGUgZ2l2ZW4gaWQgYXMgdGhlIGNsb2NrIGlkXG4gICAgdGhpcy5fY2xvY2sgPSBuZXcgQ2xvY2sodGhpcy5faWRlbnRpdHkucHVibGljS2V5LCBtYXhUaW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIElEIG9mIHRoZSBsb2cuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9pZFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNsb2NrIG9mIHRoZSBsb2cuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgY2xvY2sgKCkge1xuICAgIHJldHVybiB0aGlzLl9jbG9ja1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgbG9nLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IExlbmd0aFxuICAgKi9cbiAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlcyBpbiB0aGUgbG9nLlxuICAgKiBAcmV0dXJucyB7QXJyYXk8RW50cnk+fVxuICAgKi9cbiAgZ2V0IHZhbHVlcyAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy50cmF2ZXJzZSh0aGlzLmhlYWRzKSkucmV2ZXJzZSgpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBoZWFkcyBhcyBoYXNoZXMuXG4gICAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fVxuICAgKi9cbiAgZ2V0IGhlYWRzICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLl9oZWFkc0luZGV4KS5zb3J0KHRoaXMuX3NvcnRGbikucmV2ZXJzZSgpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBFbnRyeSBvYmplY3RzIHRoYXQgcmVmZXJlbmNlIGVudHJpZXMgd2hpY2hcbiAgICogYXJlIG5vdCBpbiB0aGUgbG9nIGN1cnJlbnRseS5cbiAgICogQHJldHVybnMge0FycmF5PEVudHJ5Pn1cbiAgICovXG4gIGdldCB0YWlscyAoKSB7XG4gICAgcmV0dXJuIExvZy5maW5kVGFpbHModGhpcy52YWx1ZXMpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBoYXNoZXMgdGhhdCBhcmUgcmVmZXJlbmNlZCBieSBlbnRyaWVzIHdoaWNoXG4gICAqIGFyZSBub3QgaW4gdGhlIGxvZyBjdXJyZW50bHkuXG4gICAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSBBcnJheSBvZiBoYXNoZXNcbiAgICovXG4gIGdldCB0YWlsSGFzaGVzICgpIHtcbiAgICByZXR1cm4gTG9nLmZpbmRUYWlsSGFzaGVzKHRoaXMudmFsdWVzKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgaWRlbnRpdHkgZm9yIHRoZSBsb2dcbiAgICogQHBhcmFtIHtJZGVudGl0eX0gW2lkZW50aXR5XSBUaGUgaWRlbnRpdHkgdG8gYmUgc2V0XG4gICAqL1xuICBzZXRJZGVudGl0eSAoaWRlbnRpdHkpIHtcbiAgICB0aGlzLl9pZGVudGl0eSA9IGlkZW50aXR5XG4gICAgLy8gRmluZCB0aGUgbGF0ZXN0IGNsb2NrIGZyb20gdGhlIGhlYWRzXG4gICAgY29uc3QgdGltZSA9IE1hdGgubWF4KHRoaXMuY2xvY2sudGltZSwgdGhpcy5oZWFkcy5yZWR1Y2UobWF4Q2xvY2tUaW1lUmVkdWNlciwgMCkpXG4gICAgdGhpcy5fY2xvY2sgPSBuZXcgQ2xvY2sodGhpcy5faWRlbnRpdHkucHVibGljS2V5LCB0aW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYW4gZW50cnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbaGFzaF0gVGhlIGhhc2hlcyBvZiB0aGUgZW50cnlcbiAgICogQHJldHVybnMge0VudHJ5fHVuZGVmaW5lZH1cbiAgICovXG4gIGdldCAoaGFzaCkge1xuICAgIHJldHVybiB0aGlzLl9lbnRyeUluZGV4LmdldChoYXNoKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGVudHJ5IGlzIHBhcnQgb2YgdGhlIGxvZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBUaGUgaGFzaCBvZiB0aGUgZW50cnlcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBoYXMgKGVudHJ5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VudHJ5SW5kZXguZ2V0KGVudHJ5Lmhhc2ggfHwgZW50cnkpICE9PSB1bmRlZmluZWRcbiAgfVxuXG4gIHRyYXZlcnNlIChyb290RW50cmllcywgYW1vdW50ID0gLTEsIGVuZEhhc2gpIHtcbiAgICAvLyBTb3J0IHRoZSBnaXZlbiBnaXZlbiByb290IGVudHJpZXMgYW5kIHVzZSBhcyB0aGUgc3RhcnRpbmcgc3RhY2tcbiAgICB2YXIgc3RhY2sgPSByb290RW50cmllcy5zb3J0KHRoaXMuX3NvcnRGbikucmV2ZXJzZSgpXG4gICAgLy8gQ2FjaGUgZm9yIGNoZWNraW5nIGlmIHdlJ3ZlIHByb2Nlc3NlZCBhbiBlbnRyeSBhbHJlYWR5XG4gICAgbGV0IHRyYXZlcnNlZCA9IHt9XG4gICAgLy8gRW5kIHJlc3VsdFxuICAgIGxldCByZXN1bHQgPSB7fVxuICAgIC8vIFdlIGtlZXAgYSBjb3VudGVyIHRvIGNoZWNrIGlmIHdlIGhhdmUgdHJhdmVyc2VkIHJlcXVlc3RlZCBhbW91bnQgb2YgZW50cmllc1xuICAgIGxldCBjb3VudCA9IDBcblxuICAgIC8vIE5hbWVkIGZ1bmN0aW9uIGZvciBnZXR0aW5nIGFuIGVudHJ5IGZyb20gdGhlIGxvZ1xuICAgIGNvbnN0IGdldEVudHJ5ID0gZSA9PiB0aGlzLmdldChlKVxuXG4gICAgLy8gQWRkIGFuIGVudHJ5IHRvIHRoZSBzdGFjayBhbmQgdHJhdmVyc2VkIG5vZGVzIGluZGV4XG4gICAgY29uc3QgYWRkVG9TdGFjayA9IGVudHJ5ID0+IHtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgcHJvY2Vzc2VkIHRoZSBlbnRyeSwgZG9uJ3QgYWRkIGl0IHRvIHRoZSBzdGFja1xuICAgICAgaWYgKCFlbnRyeSB8fCB0cmF2ZXJzZWRbZW50cnkuaGFzaF0pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0aGUgZW50cnkgaW4gZnJvbnQgb2YgdGhlIHN0YWNrIGFuZCBzb3J0XG4gICAgICBzdGFjayA9IFtlbnRyeSwgLi4uc3RhY2tdXG4gICAgICAgIC5zb3J0KHRoaXMuX3NvcnRGbilcbiAgICAgICAgLnJldmVyc2UoKVxuXG4gICAgICAvLyBBZGQgdG8gdGhlIGNhY2hlIG9mIHByb2Nlc3NlZCBlbnRyaWVzXG4gICAgICB0cmF2ZXJzZWRbZW50cnkuaGFzaF0gPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gU3RhcnQgdHJhdmVyc2FsXG4gICAgLy8gUHJvY2VzcyBzdGFjayB1bnRpbCBpdCdzIGVtcHR5ICh0cmF2ZXJzZWQgdGhlIGZ1bGwgbG9nKVxuICAgIC8vIG9yIHdoZW4gd2UgaGF2ZSB0aGUgcmVxdWVzdGVkIGFtb3VudCBvZiBlbnRyaWVzXG4gICAgLy8gSWYgcmVxdWVzdGVkIGVudHJ5IGFtb3VudCBpcyAtMSwgdHJhdmVyc2UgYWxsXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDAgJiYgKGFtb3VudCA9PT0gLTEgfHwgY291bnQgPCBhbW91bnQpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5tb2RpZmllZC1sb29wLWNvbmRpdGlvblxuICAgICAgLy8gR2V0IHRoZSBuZXh0IGVsZW1lbnQgZnJvbSB0aGUgc3RhY2tcbiAgICAgIGNvbnN0IGVudHJ5ID0gc3RhY2suc2hpZnQoKVxuXG4gICAgICAvLyBBZGQgdG8gdGhlIHJlc3VsdFxuICAgICAgY291bnQrK1xuICAgICAgcmVzdWx0W2VudHJ5Lmhhc2hdID0gZW50cnlcbiAgICAgIC8vIEFkZCBlbnRyeSdzIG5leHQgcmVmZXJlbmNlcyB0byB0aGUgc3RhY2tcbiAgICAgIGVudHJ5Lm5leHQubWFwKGdldEVudHJ5KVxuICAgICAgICAuZmlsdGVyKGlzRGVmaW5lZClcbiAgICAgICAgLmZvckVhY2goYWRkVG9TdGFjaylcblxuICAgICAgLy8gSWYgaXQgaXMgdGhlIHNwZWNpZmllZCBlbmQgaGFzaCwgYnJlYWsgb3V0IG9mIHRoZSB3aGlsZSBsb29wXG4gICAgICBpZiAoZW50cnkuaGFzaCA9PT0gZW5kSGFzaCkgYnJlYWtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kIGFuIGVudHJ5IHRvIHRoZSBsb2cuXG4gICAqIEBwYXJhbSB7RW50cnl9IGVudHJ5IEVudHJ5IHRvIGFkZFxuICAgKiBAcmV0dXJuIHtMb2d9IE5ldyBMb2cgY29udGFpbmluZyB0aGUgYXBwZW5kZWQgdmFsdWVcbiAgICovXG4gIGFzeW5jIGFwcGVuZCAoZGF0YSwgcG9pbnRlckNvdW50ID0gMSkge1xuICAgIC8vIFVwZGF0ZSB0aGUgY2xvY2sgKGZpbmQgdGhlIGxhdGVzdCBjbG9jaylcbiAgICBjb25zdCBuZXdUaW1lID0gTWF0aC5tYXgodGhpcy5jbG9jay50aW1lLCB0aGlzLmhlYWRzLnJlZHVjZShtYXhDbG9ja1RpbWVSZWR1Y2VyLCAwKSkgKyAxXG4gICAgdGhpcy5fY2xvY2sgPSBuZXcgQ2xvY2sodGhpcy5jbG9jay5pZCwgbmV3VGltZSlcblxuICAgIC8vIEdldCB0aGUgcmVxdWlyZWQgYW1vdW50IG9mIGhhc2hlcyB0byBuZXh0IGVudHJpZXMgKGFzIHBlciBjdXJyZW50IHN0YXRlIG9mIHRoZSBsb2cpXG4gICAgY29uc3QgcmVmZXJlbmNlcyA9IHRoaXMudHJhdmVyc2UodGhpcy5oZWFkcywgTWF0aC5tYXgocG9pbnRlckNvdW50LCB0aGlzLmhlYWRzLmxlbmd0aCkpXG5cbiAgICBjb25zdCBzb3J0ZWRIZWFkSW5kZXggPSB0aGlzLmhlYWRzLnJldmVyc2UoKS5yZWR1Y2UodW5pcXVlRW50cmllc1JlZHVjZXIsIHt9KVxuICAgIGNvbnN0IG5leHRzID0gT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgc29ydGVkSGVhZEluZGV4LCByZWZlcmVuY2VzKSlcbiAgICAvLyBAVE9ETzogU3BsaXQgRW50cnkuY3JlYXRlIGludG8gY3JlYXRpbmcgb2JqZWN0LCBjaGVja2luZyBwZXJtaXNzaW9uLCBzaWduaW5nIGFuZCB0aGVuIHBvc3RpbmcgdG8gSVBGU1xuICAgIC8vIENyZWF0ZSB0aGUgZW50cnkgYW5kIGFkZCBpdCB0byB0aGUgaW50ZXJuYWwgY2FjaGVcbiAgICBjb25zdCBlbnRyeSA9IGF3YWl0IEVudHJ5LmNyZWF0ZShcbiAgICAgIHRoaXMuX3N0b3JhZ2UsXG4gICAgICB0aGlzLl9pZGVudGl0eSxcbiAgICAgIHRoaXMuaWQsXG4gICAgICBkYXRhLFxuICAgICAgbmV4dHMsXG4gICAgICB0aGlzLmNsb2NrXG4gICAgKVxuXG4gICAgY29uc3QgY2FuQXBwZW5kID0gYXdhaXQgdGhpcy5fYWNjZXNzLmNhbkFwcGVuZChlbnRyeSwgdGhpcy5faWRlbnRpdHkucHJvdmlkZXIpXG4gICAgaWYgKCFjYW5BcHBlbmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGFwcGVuZCBlbnRyeSwga2V5IFwiJHt0aGlzLl9pZGVudGl0eS5pZH1cIiBpcyBub3QgYWxsb3dlZCB0byB3cml0ZSB0byB0aGUgbG9nYClcbiAgICB9XG5cbiAgICB0aGlzLl9lbnRyeUluZGV4LnNldChlbnRyeS5oYXNoLCBlbnRyeSlcbiAgICBuZXh0cy5mb3JFYWNoKGUgPT4gKHRoaXMuX25leHRzSW5kZXhbZV0gPSBlbnRyeS5oYXNoKSlcbiAgICB0aGlzLl9oZWFkc0luZGV4ID0ge31cbiAgICB0aGlzLl9oZWFkc0luZGV4W2VudHJ5Lmhhc2hdID0gZW50cnlcbiAgICAvLyBVcGRhdGUgdGhlIGxlbmd0aFxuICAgIHRoaXMuX2xlbmd0aCsrXG4gICAgcmV0dXJuIGVudHJ5XG4gIH1cblxuICAvKlxuICAgKiBDcmVhdGVzIGEgamF2c2NyaXB0IGl0ZXJhdG9yIG92ZXIgbG9nIGVudHJpZXNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IG9wdGlvbnMuZ3QgQmVnaW5uaW5nIGhhc2ggb2YgdGhlIGl0ZXJhdG9yLCBub24taW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBvcHRpb25zLmd0ZSBCZWdpbm5pbmcgaGFzaCBvZiB0aGUgaXRlcmF0b3IsIGluY2x1c2l2ZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gb3B0aW9ucy5sdCBFbmRpbmcgaGFzaCBvZiB0aGUgaXRlcmF0b3IsIG5vbi1pbmNsdXNpdmVcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IG9wdGlvbnMubHRlIEVuZGluZyBoYXNoIG9mIHRoZSBpdGVyYXRvciwgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7YW1vdW50fSBvcHRpb25zLmFtb3VudCBOdW1iZXIgb2YgZW50cmllZCB0byByZXR1cm4gdG8gLyBmcm9tIHRoZSBndGUgLyBsdGUgaGFzaFxuICAgKiBAcmV0dXJucyB7U3ltYm9sLkl0ZXJhdG9yfSBJdGVyYXRvciBvYmplY3QgY29udGFpbmluZyBsb2cgZW50cmllc1xuICAgKlxuICAgKiBAZXhhbXBsZXNcbiAgICpcbiAgICogKGFzeW5jICgpID0+IHtcbiAgICogICBsb2cxID0gbmV3IExvZyhpcGZzLCB0ZXN0SWRlbnRpdHksIHsgbG9nSWQ6ICdYJyB9KVxuICAgKlxuICAgKiAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDEwMDsgaSsrKSB7XG4gICAqICAgICBhd2FpdCBsb2cxLmFwcGVuZCgnZW50cnknICsgaSlcbiAgICogICB9XG4gICAqXG4gICAqICAgbGV0IGl0ID0gbG9nMS5pdGVyYXRvcih7XG4gICAqICAgICBsdGU6ICd6ZHB1QXBGZDVYQVBrQ1RtU3g3cVdRbVF6dnRkSlB0eDJLNXA5dG82eXRDUzc5YmZrJyxcbiAgICogICAgIGFtb3VudDogMTBcbiAgICogICB9KVxuICAgKlxuICAgKiAgIFsuLi5pdF0ubGVuZ3RoIC8vIDEwXG4gICAqIH0pKClcbiAgICpcbiAgICpcbiAgICovXG4gIGl0ZXJhdG9yICh7IGd0ID0gdW5kZWZpbmVkLCBndGUgPSB1bmRlZmluZWQsIGx0ID0gdW5kZWZpbmVkLCBsdGUgPSB1bmRlZmluZWQsIGFtb3VudCA9IC0xIH0gPVxuICB7fSkge1xuICAgIGlmIChhbW91bnQgPT09IDApIHJldHVybiAoZnVuY3Rpb24gKiAoKSB7fSkoKVxuICAgIGlmICh0eXBlb2YgbHRlID09PSAnc3RyaW5nJykgbHRlID0gW3RoaXMuZ2V0KGx0ZSldXG4gICAgaWYgKHR5cGVvZiBsdCA9PT0gJ3N0cmluZycpIGx0ID0gW3RoaXMuZ2V0KHRoaXMuZ2V0KGx0KS5uZXh0KV1cblxuICAgIGlmIChsdGUgJiYgIUFycmF5LmlzQXJyYXkobHRlKSkgdGhyb3cgTG9nRXJyb3IuTHRPckx0ZU11c3RCZVN0cmluZ09yQXJyYXkoKVxuICAgIGlmIChsdCAmJiAhQXJyYXkuaXNBcnJheShsdCkpIHRocm93IExvZ0Vycm9yLkx0T3JMdGVNdXN0QmVTdHJpbmdPckFycmF5KClcblxuICAgIGxldCBzdGFydCA9IGx0ZSB8fCAobHQgfHwgdGhpcy5oZWFkcylcbiAgICBsZXQgZW5kSGFzaCA9IGd0ZSA/IHRoaXMuZ2V0KGd0ZSkuaGFzaCA6IGd0ID8gdGhpcy5nZXQoZ3QpLmhhc2ggOiBudWxsXG4gICAgbGV0IGNvdW50ID0gZW5kSGFzaCA/IC0xIDogYW1vdW50IHx8IC0xXG5cbiAgICBsZXQgZW50cmllcyA9IHRoaXMudHJhdmVyc2Uoc3RhcnQsIGNvdW50LCBlbmRIYXNoKVxuICAgIGxldCBlbnRyeVZhbHVlcyA9IE9iamVjdC52YWx1ZXMoZW50cmllcylcblxuICAgIC8vIFN0cmlwIG9mZiBsYXN0IGVudHJ5IGlmIGd0IGlzIG5vbi1pbmNsdXNpdmVcbiAgICBpZiAoZ3QpIGVudHJ5VmFsdWVzLnBvcCgpXG5cbiAgICAvLyBEZWFsIHdpdGggdGhlIGFtb3VudCBhcmd1bWVudCB3b3JraW5nIGJhY2t3YXJkcyBmcm9tIGd0L2d0ZVxuICAgIGlmICgoZ3QgfHwgZ3RlKSAmJiBhbW91bnQgPiAtMSkge1xuICAgICAgZW50cnlWYWx1ZXMgPSBlbnRyeVZhbHVlcy5zbGljZShlbnRyeVZhbHVlcy5sZW5ndGggLSBhbW91bnQsIGVudHJ5VmFsdWVzLmxlbmd0aClcbiAgICB9XG5cbiAgICByZXR1cm4gKGZ1bmN0aW9uICogKCkge1xuICAgICAgZm9yIChsZXQgaSBpbiBlbnRyeVZhbHVlcykge1xuICAgICAgICB5aWVsZCBlbnRyeVZhbHVlc1tpXVxuICAgICAgfVxuICAgIH0pKClcbiAgfVxuXG4gIC8qKlxuICAgKiBKb2luIHR3byBsb2dzLlxuICAgKlxuICAgKiBKb2lucyBhbm90aGVyIGxvZyBpbnRvIHRoaXMgb25lLlxuICAgKlxuICAgKiBAcGFyYW0ge0xvZ30gbG9nIExvZyB0byBqb2luIHdpdGggdGhpcyBMb2dcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPS0xXSBNYXggc2l6ZSBvZiB0aGUgam9pbmVkIGxvZ1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxMb2c+fSBUaGlzIExvZyBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZVxuICAgKiBhd2FpdCBsb2cxLmpvaW4obG9nMilcbiAgICovXG4gIGFzeW5jIGpvaW4gKGxvZywgc2l6ZSA9IC0xKSB7XG4gICAgaWYgKCFpc0RlZmluZWQobG9nKSkgdGhyb3cgTG9nRXJyb3IuTG9nTm90RGVmaW5lZEVycm9yKClcbiAgICBpZiAoIUxvZy5pc0xvZyhsb2cpKSB0aHJvdyBMb2dFcnJvci5Ob3RBTG9nRXJyb3IoKVxuICAgIGlmICh0aGlzLmlkICE9PSBsb2cuaWQpIHJldHVyblxuXG4gICAgLy8gR2V0IHRoZSBkaWZmZXJlbmNlIG9mIHRoZSBsb2dzXG4gICAgY29uc3QgbmV3SXRlbXMgPSBMb2cuZGlmZmVyZW5jZShsb2csIHRoaXMpXG5cbiAgICBjb25zdCBpZGVudGl0eVByb3ZpZGVyID0gdGhpcy5faWRlbnRpdHkucHJvdmlkZXJcbiAgICAvLyBWZXJpZnkgaWYgZW50cmllcyBhcmUgYWxsb3dlZCB0byBiZSBhZGRlZCB0byB0aGUgbG9nIGFuZCB0aHJvd3MgaWZcbiAgICAvLyB0aGVyZSdzIGFuIGludmFsaWQgZW50cnlcbiAgICBjb25zdCBwZXJtaXR0ZWQgPSBhc3luYyAoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IGNhbkFwcGVuZCA9IGF3YWl0IHRoaXMuX2FjY2Vzcy5jYW5BcHBlbmQoZW50cnksIGlkZW50aXR5UHJvdmlkZXIpXG4gICAgICBpZiAoIWNhbkFwcGVuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBhcHBlbmQgZW50cnksIGtleSBcIiR7ZW50cnkuaWRlbnRpdHkuaWR9XCIgaXMgbm90IGFsbG93ZWQgdG8gd3JpdGUgdG8gdGhlIGxvZ2ApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmVyaWZ5IHNpZ25hdHVyZSBmb3IgZWFjaCBlbnRyeSBhbmQgdGhyb3dzIGlmIHRoZXJlJ3MgYW4gaW52YWxpZCBzaWduYXR1cmVcbiAgICBjb25zdCB2ZXJpZnkgPSBhc3luYyAoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBFbnRyeS52ZXJpZnkoaWRlbnRpdHlQcm92aWRlciwgZW50cnkpXG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBlbnRyeS5pZGVudGl0eSA/IGVudHJ5LmlkZW50aXR5LnB1YmxpY0tleSA6IGVudHJ5LmtleVxuICAgICAgaWYgKCFpc1ZhbGlkKSB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCB2YWxpZGF0ZSBzaWduYXR1cmUgXCIke2VudHJ5LnNpZ31cIiBmb3IgZW50cnkgXCIke2VudHJ5Lmhhc2h9XCIgYW5kIGtleSBcIiR7cHVibGljS2V5fVwiYClcbiAgICB9XG5cbiAgICBjb25zdCBlbnRyaWVzVG9Kb2luID0gT2JqZWN0LnZhbHVlcyhuZXdJdGVtcylcbiAgICBhd2FpdCBwRWFjaFNlcmllcyhlbnRyaWVzVG9Kb2luLCBhc3luYyBlID0+IHtcbiAgICAgIGF3YWl0IHBlcm1pdHRlZChlKVxuICAgICAgYXdhaXQgdmVyaWZ5KGUpXG4gICAgfSlcblxuICAgIC8vIFVwZGF0ZSB0aGUgaW50ZXJuYWwgbmV4dCBwb2ludGVycyBpbmRleFxuICAgIGNvbnN0IGFkZFRvTmV4dHNJbmRleCA9IGUgPT4ge1xuICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmdldChlLmhhc2gpXG4gICAgICBpZiAoIWVudHJ5KSB0aGlzLl9sZW5ndGgrKyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgZS5uZXh0LmZvckVhY2goYSA9PiAodGhpcy5fbmV4dHNJbmRleFthXSA9IGUuaGFzaCkpXG4gICAgfVxuICAgIE9iamVjdC52YWx1ZXMobmV3SXRlbXMpLmZvckVhY2goYWRkVG9OZXh0c0luZGV4KVxuXG4gICAgLy8gVXBkYXRlIHRoZSBpbnRlcm5hbCBlbnRyeSBpbmRleFxuICAgIHRoaXMuX2VudHJ5SW5kZXguYWRkKG5ld0l0ZW1zKVxuXG4gICAgLy8gTWVyZ2UgdGhlIGhlYWRzXG4gICAgY29uc3Qgbm90UmVmZXJlbmNlZEJ5TmV3SXRlbXMgPSBlID0+ICFuZXh0c0Zyb21OZXdJdGVtcy5maW5kKGEgPT4gYSA9PT0gZS5oYXNoKVxuICAgIGNvbnN0IG5vdEluQ3VycmVudE5leHRzID0gZSA9PiAhdGhpcy5fbmV4dHNJbmRleFtlLmhhc2hdXG4gICAgY29uc3QgbmV4dHNGcm9tTmV3SXRlbXMgPSBPYmplY3QudmFsdWVzKG5ld0l0ZW1zKS5tYXAoZ2V0TmV4dFBvaW50ZXJzKS5yZWR1Y2UoZmxhdE1hcCwgW10pXG4gICAgY29uc3QgbWVyZ2VkSGVhZHMgPSBMb2cuZmluZEhlYWRzKE9iamVjdC52YWx1ZXMoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5faGVhZHNJbmRleCwgbG9nLl9oZWFkc0luZGV4KSkpXG4gICAgICAuZmlsdGVyKG5vdFJlZmVyZW5jZWRCeU5ld0l0ZW1zKVxuICAgICAgLmZpbHRlcihub3RJbkN1cnJlbnROZXh0cylcbiAgICAgIC5yZWR1Y2UodW5pcXVlRW50cmllc1JlZHVjZXIsIHt9KVxuXG4gICAgdGhpcy5faGVhZHNJbmRleCA9IG1lcmdlZEhlYWRzXG5cbiAgICAvLyBTbGljZSB0byB0aGUgcmVxdWVzdGVkIHNpemVcbiAgICBpZiAoc2l6ZSA+IC0xKSB7XG4gICAgICBsZXQgdG1wID0gdGhpcy52YWx1ZXNcbiAgICAgIHRtcCA9IHRtcC5zbGljZSgtc2l6ZSlcbiAgICAgIHRoaXMuX2VudHJ5SW5kZXggPSBudWxsXG4gICAgICB0aGlzLl9lbnRyeUluZGV4ID0gbmV3IEVudHJ5SW5kZXgodG1wLnJlZHVjZSh1bmlxdWVFbnRyaWVzUmVkdWNlciwge30pKVxuICAgICAgdGhpcy5faGVhZHNJbmRleCA9IExvZy5maW5kSGVhZHModG1wKS5yZWR1Y2UodW5pcXVlRW50cmllc1JlZHVjZXIsIHt9KVxuICAgICAgdGhpcy5fbGVuZ3RoID0gdGhpcy5fZW50cnlJbmRleC5sZW5ndGhcbiAgICB9XG5cbiAgICAvLyBGaW5kIHRoZSBsYXRlc3QgY2xvY2sgZnJvbSB0aGUgaGVhZHNcbiAgICBjb25zdCBtYXhDbG9jayA9IE9iamVjdC52YWx1ZXModGhpcy5faGVhZHNJbmRleCkucmVkdWNlKG1heENsb2NrVGltZVJlZHVjZXIsIDApXG4gICAgdGhpcy5fY2xvY2sgPSBuZXcgQ2xvY2sodGhpcy5jbG9jay5pZCwgTWF0aC5tYXgodGhpcy5jbG9jay50aW1lLCBtYXhDbG9jaykpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxvZyBpbiBKU09OIGZvcm1hdC5cbiAgICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIGlkIGFuZCBoZWFkcyBwcm9wZXJ0aWVzXG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGhlYWRzOiB0aGlzLmhlYWRzXG4gICAgICAgIC5zb3J0KHRoaXMuX3NvcnRGbikgLy8gZGVmYXVsdCBzb3J0aW5nXG4gICAgICAgIC5yZXZlcnNlKCkgLy8gd2Ugd2FudCB0aGUgbGF0ZXN0IGFzIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICAgIC5tYXAoZ2V0SGFzaCkgLy8gcmV0dXJuIG9ubHkgdGhlIGhlYWQgaGFzaGVzXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbG9nIGluIEpTT04gZm9ybWF0IGFzIGEgc25hcHNob3QuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSBpZCwgaGVhZHMgYW5kIHZhbHVlIHByb3BlcnRpZXNcbiAgICovXG4gIHRvU25hcHNob3QgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGhlYWRzOiB0aGlzLmhlYWRzLFxuICAgICAgdmFsdWVzOiB0aGlzLnZhbHVlc1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxvZyBhcyBhIEJ1ZmZlci5cbiAgICogQHJldHVybnMge0J1ZmZlcn1cbiAgICovXG4gIHRvQnVmZmVyICgpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbG9nIGVudHJpZXMgYXMgYSBmb3JtYXR0ZWQgc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiB0d29cbiAgICog4pSU4pSAb25lXG4gICAqICAg4pSU4pSAdGhyZWVcbiAgICovXG4gIHRvU3RyaW5nIChwYXlsb2FkTWFwcGVyKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzXG4gICAgICAuc2xpY2UoKVxuICAgICAgLnJldmVyc2UoKVxuICAgICAgLm1hcCgoZSwgaWR4KSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmVudHMgPSBFbnRyeS5maW5kQ2hpbGRyZW4oZSwgdGhpcy52YWx1ZXMpXG4gICAgICAgIGNvbnN0IGxlbiA9IHBhcmVudHMubGVuZ3RoXG4gICAgICAgIGxldCBwYWRkaW5nID0gbmV3IEFycmF5KE1hdGgubWF4KGxlbiAtIDEsIDApKVxuICAgICAgICBwYWRkaW5nID0gbGVuID4gMSA/IHBhZGRpbmcuZmlsbCgnICAnKSA6IHBhZGRpbmdcbiAgICAgICAgcGFkZGluZyA9IGxlbiA+IDAgPyBwYWRkaW5nLmNvbmNhdChbJ+KUlOKUgCddKSA6IHBhZGRpbmdcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIHBhZGRpbmcuam9pbignJykgKyAocGF5bG9hZE1hcHBlciA/IHBheWxvYWRNYXBwZXIoZS5wYXlsb2FkKSA6IGUucGF5bG9hZClcbiAgICAgIH0pXG4gICAgICAuam9pbignXFxuJylcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBpcyBhIExvZyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGxvZyBBbiBvYmplY3QgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNMb2cgKGxvZykge1xuICAgIHJldHVybiBsb2cuaWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgbG9nLmhlYWRzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIGxvZy5fZW50cnlJbmRleCAhPT0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsb2cncyBtdWx0aWhhc2guXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IE11bHRpaGFzaCBvZiB0aGUgTG9nIGFzIEJhc2U1OCBlbmNvZGVkIHN0cmluZ3hcbiAgICovXG4gIHRvTXVsdGloYXNoICh7IGZvcm1hdCB9ID0ge30pIHtcbiAgICByZXR1cm4gTG9nSU8udG9NdWx0aWhhc2godGhpcy5fc3RvcmFnZSwgdGhpcywgeyBmb3JtYXQgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsb2cgZnJvbSBhIGhhc2hlcy5cbiAgICogQHBhcmFtIHtJUEZTfSBpcGZzIEFuIElQRlMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtJZGVudGl0eX0gaWRlbnRpdHkgVGhlIGlkZW50aXR5IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIFRoZSBsb2cgaGFzaFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0FjY2Vzc0NvbnRyb2xsZXJ9IG9wdGlvbnMuYWNjZXNzIFRoZSBhY2Nlc3MgY29udHJvbGxlciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5sZW5ndGggSG93IG1hbnkgaXRlbXMgdG8gaW5jbHVkZSBpbiB0aGUgbG9nXG4gICAqIEBwYXJhbSB7QXJyYXk8RW50cnk+fSBvcHRpb25zLmV4Y2x1ZGUgRW50cmllcyB0byBub3QgZmV0Y2ggKGNhY2hlZClcbiAgICogQHBhcmFtIHtmdW5jdGlvbihoYXNoLCBlbnRyeSwgcGFyZW50LCBkZXB0aCl9IG9wdGlvbnMub25Qcm9ncmVzc0NhbGxiYWNrXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuc29ydEZuIFRoZSBzb3J0IGZ1bmN0aW9uIC0gYnkgZGVmYXVsdCBMYXN0V3JpdGVXaW5zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPExvZz59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZnJvbU11bHRpaGFzaCAoaXBmcywgaWRlbnRpdHksIGhhc2gsXG4gICAgeyBhY2Nlc3MsIGxlbmd0aCA9IC0xLCBleGNsdWRlLCBvblByb2dyZXNzQ2FsbGJhY2ssIHNvcnRGbiwgdGltZW91dCwgZm9ybWF0IH0gPSB7fSkge1xuICAgIC8vIFRPRE86IG5lZWQgdG8gdmVyaWZ5IHRoZSBlbnRyaWVzIHdpdGggJ2tleSdcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgTG9nSU8uZnJvbU11bHRpaGFzaChpcGZzLCBoYXNoLCB7IGxlbmd0aCwgZXhjbHVkZSwgb25Qcm9ncmVzc0NhbGxiYWNrLCB0aW1lb3V0LCBmb3JtYXQgfSlcbiAgICByZXR1cm4gbmV3IExvZyhpcGZzLCBpZGVudGl0eSwge1xuICAgICAgbG9nSWQ6IGRhdGEuaWQsXG4gICAgICBhY2Nlc3M6IGFjY2VzcyxcbiAgICAgIGVudHJpZXM6IGRhdGEudmFsdWVzLFxuICAgICAgaGVhZHM6IGRhdGEuaGVhZHMsXG4gICAgICBjbG9jazogbmV3IENsb2NrKGRhdGEuY2xvY2suaWQsIGRhdGEuY2xvY2sudGltZSksXG4gICAgICBzb3J0Rm46IHNvcnRGblxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbG9nIGZyb20gYSBzaW5nbGUgZW50cnkncyBoYXNoLlxuICAgKiBAcGFyYW0ge0lQRlN9IGlwZnMgQW4gSVBGUyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0lkZW50aXR5fSBpZGVudGl0eSBUaGUgaWRlbnRpdHkgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggVGhlIGVudHJ5J3MgaGFzaFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sb2dJZCBUaGUgSUQgb2YgdGhlIGxvZ1xuICAgKiBAcGFyYW0ge0FjY2Vzc0NvbnRyb2xsZXJ9IG9wdGlvbnMuYWNjZXNzIFRoZSBhY2Nlc3MgY29udHJvbGxlciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5sZW5ndGggSG93IG1hbnkgZW50cmllcyB0byBpbmNsdWRlIGluIHRoZSBsb2dcbiAgICogQHBhcmFtIHtBcnJheTxFbnRyeT59IG9wdGlvbnMuZXhjbHVkZSBFbnRyaWVzIHRvIG5vdCBmZXRjaCAoY2FjaGVkKVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGhhc2gsIGVudHJ5LCBwYXJlbnQsIGRlcHRoKX0gb3B0aW9ucy5vblByb2dyZXNzQ2FsbGJhY2tcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5zb3J0Rm4gVGhlIHNvcnQgZnVuY3Rpb24gLSBieSBkZWZhdWx0IExhc3RXcml0ZVdpbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudGltZW91dCBUaW1lb3V0IGZvciBmZXRjaGluZyBhIGxvZyBlbnRyeSBmcm9tIElQRlNcbiAgICogQHJldHVybiB7UHJvbWlzZTxMb2c+fSBOZXcgTG9nXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZnJvbUVudHJ5SGFzaCAoaXBmcywgaWRlbnRpdHksIGhhc2gsXG4gICAgeyBsb2dJZCwgYWNjZXNzLCBsZW5ndGggPSAtMSwgZXhjbHVkZSwgb25Qcm9ncmVzc0NhbGxiYWNrLCBzb3J0Rm4sIHRpbWVvdXQgfSkge1xuICAgIC8vIFRPRE86IG5lZWQgdG8gdmVyaWZ5IHRoZSBlbnRyaWVzIHdpdGggJ2tleSdcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgTG9nSU8uZnJvbUVudHJ5SGFzaChpcGZzLCBoYXNoLCB7IGxlbmd0aCwgZXhjbHVkZSwgb25Qcm9ncmVzc0NhbGxiYWNrLCB0aW1lb3V0IH0pXG4gICAgcmV0dXJuIG5ldyBMb2coaXBmcywgaWRlbnRpdHksIHsgbG9nSWQsIGFjY2VzcywgZW50cmllczogZGF0YS52YWx1ZXMsIHNvcnRGbiB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGxvZyBmcm9tIGEgTG9nIFNuYXBzaG90IEpTT04uXG4gICAqIEBwYXJhbSB7SVBGU30gaXBmcyBBbiBJUEZTIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SWRlbnRpdHl9IGlkZW50aXR5IFRoZSBpZGVudGl0eSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiBMb2cgc25hcHNob3QgYXMgSlNPTiBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtBY2Nlc3NDb250cm9sbGVyfSBvcHRpb25zLmFjY2VzcyBUaGUgYWNjZXNzIGNvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubGVuZ3RoIEhvdyBtYW55IGVudHJpZXMgdG8gaW5jbHVkZSBpbiB0aGUgbG9nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRpbWVvdXQgTWF4aW11bSB0aW1lIHRvIHdhaXQgZm9yIGVhY2ggZmV0Y2ggb3BlcmF0aW9uLCBpbiBtc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGhhc2gsIGVudHJ5LCBwYXJlbnQsIGRlcHRoKX0gW29wdGlvbnMub25Qcm9ncmVzc0NhbGxiYWNrXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNvcnRGbiBUaGUgc29ydCBmdW5jdGlvbiAtIGJ5IGRlZmF1bHQgTGFzdFdyaXRlV2luc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlPExvZz59IE5ldyBMb2dcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmcm9tSlNPTiAoaXBmcywgaWRlbnRpdHksIGpzb24sXG4gICAgeyBhY2Nlc3MsIGxlbmd0aCA9IC0xLCB0aW1lb3V0LCBvblByb2dyZXNzQ2FsbGJhY2ssIHNvcnRGbiB9ID0ge30pIHtcbiAgICAvLyBUT0RPOiBuZWVkIHRvIHZlcmlmeSB0aGUgZW50cmllcyB3aXRoICdrZXknXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IExvZ0lPLmZyb21KU09OKGlwZnMsIGpzb24sIHsgbGVuZ3RoLCB0aW1lb3V0LCBvblByb2dyZXNzQ2FsbGJhY2sgfSlcbiAgICByZXR1cm4gbmV3IExvZyhpcGZzLCBpZGVudGl0eSwgeyBsb2dJZDogZGF0YS5pZCwgYWNjZXNzLCBlbnRyaWVzOiBkYXRhLnZhbHVlcywgc29ydEZuIH0pXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGxvZyBmcm9tIGFuIEVudHJ5IGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge0lQRlN9IGlwZnMgQW4gSVBGUyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0lkZW50aXR5fSBpZGVudGl0eSBUaGUgaWRlbnRpdHkgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtFbnRyeXxBcnJheTxFbnRyeT59IHNvdXJjZUVudHJpZXMgQW4gRW50cnkgb3IgYW4gYXJyYXkgb2YgZW50cmllcyB0byBmZXRjaCBhIGxvZyBmcm9tXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7QWNjZXNzQ29udHJvbGxlcn0gb3B0aW9ucy5hY2Nlc3MgVGhlIGFjY2VzcyBjb250cm9sbGVyIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmxlbmd0aCBIb3cgbWFueSBlbnRyaWVzIHRvIGluY2x1ZGUuIERlZmF1bHQ6IGluZmluaXRlLlxuICAgKiBAcGFyYW0ge0FycmF5PEVudHJ5Pn0gb3B0aW9ucy5leGNsdWRlIEVudHJpZXMgdG8gbm90IGZldGNoIChjYWNoZWQpXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaGFzaCwgZW50cnksIHBhcmVudCwgZGVwdGgpfSBbb3B0aW9ucy5vblByb2dyZXNzQ2FsbGJhY2tdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuc29ydEZuIFRoZSBzb3J0IGZ1bmN0aW9uIC0gYnkgZGVmYXVsdCBMYXN0V3JpdGVXaW5zXG4gICAqIEByZXR1cm4ge1Byb21pc2U8TG9nPn0gTmV3IExvZ1xuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21FbnRyeSAoaXBmcywgaWRlbnRpdHksIHNvdXJjZUVudHJpZXMsXG4gICAgeyBhY2Nlc3MsIGxlbmd0aCA9IC0xLCBleGNsdWRlLCBvblByb2dyZXNzQ2FsbGJhY2ssIHRpbWVvdXQsIHNvcnRGbiB9ID0ge30pIHtcbiAgICAvLyBUT0RPOiBuZWVkIHRvIHZlcmlmeSB0aGUgZW50cmllcyB3aXRoICdrZXknXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IExvZ0lPLmZyb21FbnRyeShpcGZzLCBzb3VyY2VFbnRyaWVzLFxuICAgICAgeyBsZW5ndGgsIGV4Y2x1ZGUsIG9uUHJvZ3Jlc3NDYWxsYmFjaywgdGltZW91dCB9KVxuICAgIHJldHVybiBuZXcgTG9nKGlwZnMsIGlkZW50aXR5LCB7IGxvZ0lkOiBkYXRhLmlkLCBhY2Nlc3MsIGVudHJpZXM6IGRhdGEudmFsdWVzLCBzb3J0Rm4gfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGhlYWRzIGZyb20gYSBjb2xsZWN0aW9uIG9mIGVudHJpZXMuXG4gICAqXG4gICAqIEZpbmRzIGVudHJpZXMgdGhhdCBhcmUgdGhlIGhlYWRzIG9mIHRoaXMgY29sbGVjdGlvbixcbiAgICogaWUuIGVudHJpZXMgdGhhdCBhcmUgbm90IHJlZmVyZW5jZWQgYnkgb3RoZXIgZW50cmllcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxFbnRyeT59IGVudHJpZXMgRW50cmllcyB0byBzZWFyY2ggaGVhZHMgZnJvbVxuICAgKiBAcmV0dXJucyB7QXJyYXk8RW50cnk+fVxuICAgKi9cbiAgc3RhdGljIGZpbmRIZWFkcyAoZW50cmllcykge1xuICAgIHZhciBpbmRleFJlZHVjZXIgPSAocmVzLCBlbnRyeSwgaWR4LCBhcnIpID0+IHtcbiAgICAgIHZhciBhZGRUb1Jlc3VsdCA9IGUgPT4gKHJlc1tlXSA9IGVudHJ5Lmhhc2gpXG4gICAgICBlbnRyeS5uZXh0LmZvckVhY2goYWRkVG9SZXN1bHQpXG4gICAgICByZXR1cm4gcmVzXG4gICAgfVxuXG4gICAgdmFyIGl0ZW1zID0gZW50cmllcy5yZWR1Y2UoaW5kZXhSZWR1Y2VyLCB7fSlcblxuICAgIHZhciBleGlzdHMgPSBlID0+IGl0ZW1zW2UuaGFzaF0gPT09IHVuZGVmaW5lZFxuICAgIHZhciBjb21wYXJlSWRzID0gKGEsIGIpID0+IGEuY2xvY2suaWQgPiBiLmNsb2NrLmlkXG5cbiAgICByZXR1cm4gZW50cmllcy5maWx0ZXIoZXhpc3RzKS5zb3J0KGNvbXBhcmVJZHMpXG4gIH1cblxuICAvLyBGaW5kIGVudHJpZXMgdGhhdCBwb2ludCB0byBhbm90aGVyIGVudHJ5IHRoYXQgaXMgbm90IGluIHRoZVxuICAvLyBpbnB1dCBhcnJheVxuICBzdGF0aWMgZmluZFRhaWxzIChlbnRyaWVzKSB7XG4gICAgLy8gUmV2ZXJzZSBpbmRleCB7IG5leHQgLT4gZW50cnkgfVxuICAgIHZhciByZXZlcnNlSW5kZXggPSB7fVxuICAgIC8vIE51bGwgaW5kZXggY29udGFpbmluZyBlbnRyaWVzIHRoYXQgaGF2ZSBubyBwYXJlbnRzIChuZXh0cylcbiAgICB2YXIgbnVsbEluZGV4ID0gW11cbiAgICAvLyBIYXNoZXMgZm9yIGFsbCBlbnRyaWVzIGZvciBxdWljayBsb29rdXBzXG4gICAgdmFyIGhhc2hlcyA9IHt9XG4gICAgLy8gSGFzaGVzIG9mIGFsbCBuZXh0IGVudHJpZXNcbiAgICB2YXIgbmV4dHMgPSBbXVxuXG4gICAgdmFyIGFkZFRvSW5kZXggPSAoZSkgPT4ge1xuICAgICAgaWYgKGUubmV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbnVsbEluZGV4LnB1c2goZSlcbiAgICAgIH1cbiAgICAgIHZhciBhZGRUb1JldmVyc2VJbmRleCA9IChhKSA9PiB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICghcmV2ZXJzZUluZGV4W2FdKSByZXZlcnNlSW5kZXhbYV0gPSBbXVxuICAgICAgICByZXZlcnNlSW5kZXhbYV0ucHVzaChlKVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgYWxsIGVudHJpZXMgYW5kIHRoZWlyIHBhcmVudHMgdG8gdGhlIHJldmVyc2UgaW5kZXhcbiAgICAgIGUubmV4dC5mb3JFYWNoKGFkZFRvUmV2ZXJzZUluZGV4KVxuICAgICAgLy8gR2V0IGFsbCBuZXh0IHJlZmVyZW5jZXNcbiAgICAgIG5leHRzID0gbmV4dHMuY29uY2F0KGUubmV4dClcbiAgICAgIC8vIEdldCB0aGUgaGFzaGVzIG9mIGlucHV0IGVudHJpZXNcbiAgICAgIGhhc2hlc1tlLmhhc2hdID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBvdXIgaW5kaWNlc1xuICAgIGVudHJpZXMuZm9yRWFjaChhZGRUb0luZGV4KVxuXG4gICAgdmFyIGFkZFVuaXF1ZXMgPSAocmVzLCBlbnRyaWVzLCBpZHgsIGFycikgPT4gcmVzLmNvbmNhdChmaW5kVW5pcXVlcyhlbnRyaWVzLCAnaGFzaCcpKVxuICAgIHZhciBleGlzdHMgPSBlID0+IGhhc2hlc1tlXSA9PT0gdW5kZWZpbmVkXG4gICAgdmFyIGZpbmRGcm9tUmV2ZXJzZUluZGV4ID0gZSA9PiByZXZlcnNlSW5kZXhbZV1cblxuICAgIC8vIERyb3AgaGFzaGVzIHRoYXQgYXJlIG5vdCBpbiB0aGUgaW5wdXQgZW50cmllc1xuICAgIGNvbnN0IHRhaWxzID0gbmV4dHMgLy8gRm9yIGV2ZXJ5IGhhc2ggaW4gbmV4dHM6XG4gICAgICAuZmlsdGVyKGV4aXN0cykgLy8gUmVtb3ZlIHVuZGVmaW5lZHMgYW5kIG51bGxzXG4gICAgICAubWFwKGZpbmRGcm9tUmV2ZXJzZUluZGV4KSAvLyBHZXQgdGhlIEVudHJ5IGZyb20gdGhlIHJldmVyc2UgaW5kZXhcbiAgICAgIC5yZWR1Y2UoYWRkVW5pcXVlcywgW10pIC8vIEZsYXR0ZW4gdGhlIHJlc3VsdCBhbmQgdGFrZSBvbmx5IHVuaXF1ZXNcbiAgICAgIC5jb25jYXQobnVsbEluZGV4KSAvLyBDb21iaW5lIHdpdGggdGFpbHMgdGhlIGhhdmUgbm8gbmV4dCByZWZzIChpZS4gZmlyc3QtaW4tdGhlaXItY2hhaW4pXG5cbiAgICByZXR1cm4gZmluZFVuaXF1ZXModGFpbHMsICdoYXNoJykuc29ydChFbnRyeS5jb21wYXJlKVxuICB9XG5cbiAgLy8gRmluZCB0aGUgaGFzaGVzIHRvIGVudHJpZXMgdGhhdCBhcmUgbm90IGluIGEgY29sbGVjdGlvblxuICAvLyBidXQgcmVmZXJlbmNlZCBieSBvdGhlciBlbnRyaWVzXG4gIHN0YXRpYyBmaW5kVGFpbEhhc2hlcyAoZW50cmllcykge1xuICAgIHZhciBoYXNoZXMgPSB7fVxuICAgIHZhciBhZGRUb0luZGV4ID0gZSA9PiAoaGFzaGVzW2UuaGFzaF0gPSB0cnVlKVxuICAgIHZhciByZWR1Y2VUYWlsSGFzaGVzID0gKHJlcywgZW50cnksIGlkeCwgYXJyKSA9PiB7XG4gICAgICB2YXIgYWRkVG9SZXN1bHQgPSAoZSkgPT4ge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaGFzaGVzW2VdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXMuc3BsaWNlKDAsIDAsIGUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVudHJ5Lm5leHQucmV2ZXJzZSgpLmZvckVhY2goYWRkVG9SZXN1bHQpXG4gICAgICByZXR1cm4gcmVzXG4gICAgfVxuXG4gICAgZW50cmllcy5mb3JFYWNoKGFkZFRvSW5kZXgpXG4gICAgcmV0dXJuIGVudHJpZXMucmVkdWNlKHJlZHVjZVRhaWxIYXNoZXMsIFtdKVxuICB9XG5cbiAgc3RhdGljIGRpZmZlcmVuY2UgKGEsIGIpIHtcbiAgICBsZXQgc3RhY2sgPSBPYmplY3Qua2V5cyhhLl9oZWFkc0luZGV4KVxuICAgIGxldCB0cmF2ZXJzZWQgPSB7fVxuICAgIGxldCByZXMgPSB7fVxuXG4gICAgY29uc3QgcHVzaFRvU3RhY2sgPSBoYXNoID0+IHtcbiAgICAgIGlmICghdHJhdmVyc2VkW2hhc2hdICYmICFiLmdldChoYXNoKSkge1xuICAgICAgICBzdGFjay5wdXNoKGhhc2gpXG4gICAgICAgIHRyYXZlcnNlZFtoYXNoXSA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaGFzaCA9IHN0YWNrLnNoaWZ0KClcbiAgICAgIGNvbnN0IGVudHJ5ID0gYS5nZXQoaGFzaClcbiAgICAgIGlmIChlbnRyeSAmJiAhYi5nZXQoaGFzaCkgJiYgZW50cnkuaWQgPT09IGIuaWQpIHtcbiAgICAgICAgcmVzW2VudHJ5Lmhhc2hdID0gZW50cnlcbiAgICAgICAgdHJhdmVyc2VkW2VudHJ5Lmhhc2hdID0gdHJ1ZVxuICAgICAgICBlbnRyeS5uZXh0LmZvckVhY2gocHVzaFRvU3RhY2spXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExvZ1xubW9kdWxlLmV4cG9ydHMuU29ydGluZyA9IFNvcnRpbmdcbm1vZHVsZS5leHBvcnRzLkFjY2Vzc0NvbnRyb2xsZXIgPSBBY2Nlc3NDb250cm9sbGVyXG4iLCJmdW5jdGlvbiByKHIpe3JldHVybiByJiZcIm9iamVjdFwiPT10eXBlb2YgciYmXCJkZWZhdWx0XCJpbiByP3IuZGVmYXVsdDpyfXZhciBlPXJlcXVpcmUoXCJqcy1zaGEyNTZcIiksdD1yZXF1aXJlKFwianMtc2hhM1wiKSxuPXJlcXVpcmUoXCJlbGxpcHRpY1wiKSxvPXIocmVxdWlyZShcInR3ZWV0bmFjbFwiKSksaT1yZXF1aXJlKFwiQHN0YWJsZWxpYi91dGY4XCIpLGE9cmVxdWlyZShcImJ1ZmZlclwiKSx1PXIocmVxdWlyZShcInVwb3J0LWJhc2U2NHVybFwiKSksYz1yKHJlcXVpcmUoXCJkaWQtcmVzb2x2ZXJcIikpO2Z1bmN0aW9uIGYocil7cmV0dXJuIGEuQnVmZmVyLmZyb20oZS5zaGEyNTYuYXJyYXlCdWZmZXIocikpfWZ1bmN0aW9uIHMocil7cmV0dXJuXCIweFwiKyhlPWEuQnVmZmVyLmZyb20oci5zbGljZSgyKSxcImhleFwiKSxhLkJ1ZmZlci5mcm9tKHQua2VjY2FrXzI1Ni5hcnJheUJ1ZmZlcihlKSkpLnNsaWNlKC0yMCkudG9TdHJpbmcoXCJoZXhcIik7dmFyIGV9dmFyIGQ9bmV3IG4uZWMoXCJzZWNwMjU2azFcIik7ZnVuY3Rpb24gaChyLGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT02NCksci5sZW5ndGg9PT1lP3I6XCIwXCIucmVwZWF0KGUtci5sZW5ndGgpK3J9ZnVuY3Rpb24gbChyKXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoQnVmZmVyLmZyb20ocixcImJhc2U2NFwiKSwwKSl9dmFyIHA9bmV3IG4uZWMoXCJzZWNwMjU2azFcIik7ZnVuY3Rpb24gdihyLGUpe3ZvaWQgMD09PWUmJihlPSExKTt2YXIgdD11LnRvQnVmZmVyKHIpO2lmKHQubGVuZ3RoIT09KGU/NjU6NjQpKXRocm93IG5ldyBFcnJvcihcIndyb25nIHNpZ25hdHVyZSBsZW5ndGhcIik7dmFyIG49e3I6dC5zbGljZSgwLDMyKS50b1N0cmluZyhcImhleFwiKSxzOnQuc2xpY2UoMzIsNjQpLnRvU3RyaW5nKFwiaGV4XCIpfTtyZXR1cm4gZSYmKG4ucmVjb3ZlcnlQYXJhbT10WzY0XSksbn12YXIgdz17RVMyNTZLOmZ1bmN0aW9uKHIsZSx0KXt2YXIgbj1mKHIpLG89dihlKSxpPXQuZmluZChmdW5jdGlvbihyKXtyZXR1cm4gcC5rZXlGcm9tUHVibGljKHIucHVibGljS2V5SGV4LFwiaGV4XCIpLnZlcmlmeShuLG8pfSk7aWYoIWkpdGhyb3cgbmV3IEVycm9yKFwiU2lnbmF0dXJlIGludmFsaWQgZm9yIEpXVFwiKTtyZXR1cm4gaX0sXCJFUzI1NkstUlwiOmZ1bmN0aW9uKHIsZSx0KXt2YXIgbj12KGUsITApLG89ZihyKSxpPXAucmVjb3ZlclB1YktleShvLG4sbi5yZWNvdmVyeVBhcmFtKSxhPWkuZW5jb2RlKFwiaGV4XCIpLHU9aS5lbmNvZGUoXCJoZXhcIiwhMCksYz1zKGEpLGQ9dC5maW5kKGZ1bmN0aW9uKHIpe3ZhciBlPXIucHVibGljS2V5SGV4O3JldHVybiBlPT09YXx8ZT09PXV8fHIuZXRoZXJldW1BZGRyZXNzPT09Y30pO2lmKCFkKXRocm93IG5ldyBFcnJvcihcIlNpZ25hdHVyZSBpbnZhbGlkIGZvciBKV1RcIik7cmV0dXJuIGR9LEVkMjU1MTk6ZnVuY3Rpb24ocixlLHQpe3ZhciBuPWkuZW5jb2RlKHIpLGE9bCh1LnRvQmFzZTY0KGUpKSxjPXQuZmluZChmdW5jdGlvbihyKXtyZXR1cm4gby5zaWduLmRldGFjaGVkLnZlcmlmeShuLGEsbChyLnB1YmxpY0tleUJhc2U2NCkpfSk7aWYoIWMpdGhyb3cgbmV3IEVycm9yKFwiU2lnbmF0dXJlIGludmFsaWQgZm9yIEpXVFwiKTtyZXR1cm4gY319O2Z1bmN0aW9uIHkocil7dmFyIGU9d1tyXTtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBhbGdvcml0aG0gXCIrcik7cmV0dXJuIGV9ZnVuY3Rpb24gZyhyKXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgciYmXCJyXCJpbiByJiZcInNcImluIHJ9ZnVuY3Rpb24gbShyKXtyZXR1cm4gZnVuY3Rpb24oZSx0KXt0cnl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0KGUpKS50aGVuKGZ1bmN0aW9uKGUpe2lmKGcoZSkpcmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBuPWUucixvPWUucyxpPWUucmVjb3ZlcnlQYXJhbSxjPWEuQnVmZmVyLmFsbG9jKHI/NjU6NjQpO2lmKGEuQnVmZmVyLmZyb20obixcImhleFwiKS5jb3B5KGMsMCksYS5CdWZmZXIuZnJvbShvLFwiaGV4XCIpLmNvcHkoYywzMikscil7aWYodm9pZCAwPT09aSl0aHJvdyBuZXcgRXJyb3IoXCJTaWduZXIgZGlkIG5vdCByZXR1cm4gYSByZWNvdmVyeVBhcmFtXCIpO2NbNjRdPWl9cmV0dXJuIHUuZW5jb2RlKGMpfSgpO3Rocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIGEgc2lnbmVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNpZ25hdHVyZSBvYmplY3QgaW5zdGVhZCBvZiBzdHJpbmdcIil9KX1jYXRjaChyKXtyZXR1cm4gUHJvbWlzZS5yZWplY3Qocil9fX15LnRvU2lnbmF0dXJlT2JqZWN0PXY7dmFyIEU9e0VTMjU2SzptKCksXCJFUzI1NkstUlwiOm0oITApLEVkMjU1MTk6ZnVuY3Rpb24ocixlKXt0cnl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShlKHIpKS50aGVuKGZ1bmN0aW9uKHIpe2lmKGcocikpdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgYSBzaWduZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc3RyaW5nIGluc3RlYWQgb2Ygc2lnbmF0dXJlIG9iamVjdFwiKTtyZXR1cm4gcn0pfWNhdGNoKHIpe3JldHVybiBQcm9taXNlLnJlamVjdChyKX19fSxiPXtFUzI1Nks6W1wiU2VjcDI1NmsxVmVyaWZpY2F0aW9uS2V5MjAxOFwiLFwiU2VjcDI1NmsxU2lnbmF0dXJlVmVyaWZpY2F0aW9uS2V5MjAxOFwiLFwiRWNkc2FQdWJsaWNLZXlTZWNwMjU2azFcIl0sXCJFUzI1NkstUlwiOltcIlNlY3AyNTZrMVZlcmlmaWNhdGlvbktleTIwMThcIixcIlNlY3AyNTZrMVNpZ25hdHVyZVZlcmlmaWNhdGlvbktleTIwMThcIixcIkVjZHNhUHVibGljS2V5U2VjcDI1NmsxXCJdLEVkMjU1MTk6W1wiRUQyNTUxOVNpZ25hdHVyZVZlcmlmaWNhdGlvblwiXX07ZnVuY3Rpb24gUyhyKXtyZXR1cm4gdS5lbmNvZGUoSlNPTi5zdHJpbmdpZnkocikpfWZ1bmN0aW9uIHgocil7cmV0dXJuIHIubWF0Y2goL15bMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5el0rJC8pfWZ1bmN0aW9uIFAocil7aWYoci5tYXRjaCgvXmRpZDovKSlyZXR1cm4gcjtpZih4KHIpKXJldHVyblwiZGlkOnVwb3J0OlwiK3I7dGhyb3cgbmV3IEVycm9yKFwiTm90IGEgdmFsaWQgRElEICdcIityK1wiJ1wiKX1mdW5jdGlvbiBrKHIpe2lmKCFyKXRocm93IG5ldyBFcnJvcihcIm5vIEpXVCBwYXNzZWQgaW50byBkZWNvZGVKV1RcIik7dmFyIGU9ci5tYXRjaCgvXihbYS16QS1aMC05Xy1dKylcXC4oW2EtekEtWjAtOV8tXSspXFwuKFthLXpBLVowLTlfLV0rKSQvKTtpZihlKXJldHVybntoZWFkZXI6SlNPTi5wYXJzZSh1LmRlY29kZShlWzFdKSkscGF5bG9hZDpKU09OLnBhcnNlKHUuZGVjb2RlKGVbMl0pKSxzaWduYXR1cmU6ZVszXSxkYXRhOmVbMV0rXCIuXCIrZVsyXX07dGhyb3cgbmV3IEVycm9yKFwiSW5jb3JyZWN0IGZvcm1hdCBKV1RcIil9ZXhwb3J0cy5TaW1wbGVTaWduZXI9ZnVuY3Rpb24ocil7dmFyIGU9ZC5rZXlGcm9tUHJpdmF0ZShyKTtyZXR1cm4gZnVuY3Rpb24ocil7dHJ5e3ZhciB0PWUuc2lnbihmKHIpKSxuPXQucyxvPXQucmVjb3ZlcnlQYXJhbTtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtyOmgodC5yLnRvU3RyaW5nKFwiaGV4XCIpKSxzOmgobi50b1N0cmluZyhcImhleFwiKSkscmVjb3ZlcnlQYXJhbTpvfSl9Y2F0Y2gocil7cmV0dXJuIFByb21pc2UucmVqZWN0KHIpfX19LGV4cG9ydHMuTmFjbFNpZ25lcj1mdW5jdGlvbihyKXt2YXIgZT1sKHIpO3JldHVybiBmdW5jdGlvbihyKXt0cnl7dmFyIHQ9aS5lbmNvZGUociksbj1vLnNpZ24uZGV0YWNoZWQodCxlKSxjPXUuZW5jb2RlKGEuQnVmZmVyLmZyb20obikpO3JldHVybiBQcm9taXNlLnJlc29sdmUoYyl9Y2F0Y2gocil7cmV0dXJuIFByb21pc2UucmVqZWN0KHIpfX19LGV4cG9ydHMudmVyaWZ5SldUPWZ1bmN0aW9uKHIsZSl7dm9pZCAwPT09ZSYmKGU9e2F1dGg6bnVsbCxhdWRpZW5jZTpudWxsLGNhbGxiYWNrVXJsOm51bGx9KTt0cnl7dmFyIHQ9ZS5hdWRpZW5jZT9QKGUuYXVkaWVuY2UpOnZvaWQgMCxuPWsociksbz1uLnBheWxvYWQsaT1uLmhlYWRlcixhPW4uc2lnbmF0dXJlLHU9bi5kYXRhO3JldHVybiBQcm9taXNlLnJlc29sdmUoZnVuY3Rpb24ocixlLHQpe3RyeXt2YXIgbj1iW3JdO2lmKCFufHwwPT09bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VwcG9ydGVkIHNpZ25hdHVyZSB0eXBlcyBmb3IgYWxnb3JpdGhtIFwiK3IpO3ZhciBvPVAoZSk7cmV0dXJuIFByb21pc2UucmVzb2x2ZShjKG8pKS50aGVuKGZ1bmN0aW9uKGUpe2lmKCFlKXRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byByZXNvbHZlIERJRCBkb2N1bWVudCBmb3IgXCIrbyk7dmFyIGk9IXR8fChlLmF1dGhlbnRpY2F0aW9ufHxbXSkubWFwKGZ1bmN0aW9uKHIpe3JldHVybiByLnB1YmxpY0tleX0pLGE9KGUucHVibGljS2V5fHxbXSkuZmlsdGVyKGZ1bmN0aW9uKHIpe3ZhciBlPXIudHlwZSxvPXIuaWQ7cmV0dXJuIG4uZmluZChmdW5jdGlvbihyKXtyZXR1cm4gcj09PWUmJighdHx8QXJyYXkuaXNBcnJheShpKSYmaS5pbmRleE9mKG8pPj0wKX0pfSk7aWYodCYmKCFhfHwwPT09YS5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihcIkRJRCBkb2N1bWVudCBmb3IgXCIrbytcIiBkb2VzIG5vdCBoYXZlIHB1YmxpYyBrZXlzIHN1aXRhYmxlIGZvciBhdXRoZW50aWNhdGlvbmcgdXNlclwiKTtpZighYXx8MD09PWEubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkRJRCBkb2N1bWVudCBmb3IgXCIrbytcIiBkb2VzIG5vdCBoYXZlIHB1YmxpYyBrZXlzIGZvciBcIityKTtyZXR1cm57YXV0aGVudGljYXRvcnM6YSxpc3N1ZXI6byxkb2M6ZX19KX1jYXRjaChyKXtyZXR1cm4gUHJvbWlzZS5yZWplY3Qocil9fShpLmFsZyxvLmlzcyxlLmF1dGgpKS50aGVuKGZ1bmN0aW9uKG4pe3ZhciBjLGY9bi5kb2Mscz1uLmF1dGhlbnRpY2F0b3JzLGQ9bi5pc3N1ZXIsaD15KGkuYWxnKSh1LGEscyksbD1NYXRoLmZsb29yKERhdGUubm93KCkvMWUzKTtpZihoKXtpZihvLmlhdCYmby5pYXQ+bCszMDApdGhyb3cgbmV3IEVycm9yKFwiSldUIG5vdCB2YWxpZCB5ZXQgKGlzc3VlZCBpbiB0aGUgZnV0dXJlKTogaWF0OiBcIitvLmlhdCtcIiA+IG5vdzogXCIrbCk7aWYoby5leHAmJm8uZXhwPD1sLTMwMCl0aHJvdyBuZXcgRXJyb3IoXCJKV1QgaGFzIGV4cGlyZWQ6IGV4cDogXCIrby5leHArXCIgPCBub3c6IFwiK2wpO2lmKG8uYXVkKWlmKChjPW8uYXVkKSYmKGMubWF0Y2goL15kaWQ6Lyl8fHgoYykpKXtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJKV1QgYXVkaWVuY2UgaXMgcmVxdWlyZWQgYnV0IHlvdXIgYXBwIGFkZHJlc3MgaGFzIG5vdCBiZWVuIGNvbmZpZ3VyZWRcIik7aWYodCE9PVAoby5hdWQpKXRocm93IG5ldyBFcnJvcihcIkpXVCBhdWRpZW5jZSBkb2VzIG5vdCBtYXRjaCB5b3VyIERJRDogYXVkOiBcIitvLmF1ZCtcIiAhPT0geW91cnM6IFwiK3QpfWVsc2V7aWYoIWUuY2FsbGJhY2tVcmwpdGhyb3cgbmV3IEVycm9yKFwiSldUIGF1ZGllbmNlIG1hdGNoaW5nIHlvdXIgY2FsbGJhY2sgdXJsIGlzIHJlcXVpcmVkIGJ1dCBvbmUgd2Fzbid0IHBhc3NlZCBpblwiKTtpZihvLmF1ZCE9PWUuY2FsbGJhY2tVcmwpdGhyb3cgbmV3IEVycm9yKFwiSldUIGF1ZGllbmNlIGRvZXMgbm90IG1hdGNoIHRoZSBjYWxsYmFjayB1cmw6IGF1ZDogXCIrby5hdWQrXCIgIT09IHVybDogXCIrZS5jYWxsYmFja1VybCl9cmV0dXJue3BheWxvYWQ6byxkb2M6Zixpc3N1ZXI6ZCxzaWduZXI6aCxqd3Q6cn19fSl9Y2F0Y2gocil7cmV0dXJuIFByb21pc2UucmVqZWN0KHIpfX0sZXhwb3J0cy5jcmVhdGVKV1Q9ZnVuY3Rpb24ocixlKXt2YXIgdD1lLmlzc3VlcixuPWUuc2lnbmVyLG89ZS5hbGcsaT1lLmV4cGlyZXNJbjt0cnl7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiTm8gU2lnbmVyIGZ1bmN0aW9uYWxpdHkgaGFzIGJlZW4gY29uZmlndXJlZFwiKTtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJObyBpc3N1aW5nIERJRCBoYXMgYmVlbiBjb25maWd1cmVkXCIpO3ZhciBhPXt0eXA6XCJKV1RcIixhbGc6b3x8XCJFUzI1NktcIn0sdT17aWF0Ok1hdGguZmxvb3IoRGF0ZS5ub3coKS8xZTMpLGV4cDp2b2lkIDB9O2lmKGkpe2lmKFwibnVtYmVyXCIhPXR5cGVvZiBpKXRocm93IG5ldyBFcnJvcihcIkpXVCBleHBpcmVzSW4gaXMgbm90IGEgbnVtYmVyXCIpO3UuZXhwPXUuaWF0K01hdGguZmxvb3IoaSl9dmFyIGM9W1MoYSksUyhPYmplY3QuYXNzaWduKHt9LHUscix7aXNzOnR9KSldLmpvaW4oXCIuXCIpLGY9ZnVuY3Rpb24ocil7dmFyIGU9RVtyXTtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBhbGdvcml0aG0gXCIrcik7cmV0dXJuIGV9KGEuYWxnKTtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGYoYyxuKSkudGhlbihmdW5jdGlvbihyKXtyZXR1cm5bYyxyXS5qb2luKFwiLlwiKX0pfWNhdGNoKHIpe3JldHVybiBQcm9taXNlLnJlamVjdChyKX19LGV4cG9ydHMuZGVjb2RlSldUPWssZXhwb3J0cy50b0V0aGVyZXVtQWRkcmVzcz1zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IElkZW50aXR5UHJvdmlkZXIgPSByZXF1aXJlKCcuL3NyYy9pZGVudGl0aWVzJylcblxubW9kdWxlLmV4cG9ydHMgPSBJZGVudGl0eVByb3ZpZGVyXG4iLCJjb25zdCBESURfUExBQ0VIT0xERVIgPSAnR0VORVNJUydcblxuLyoqXG4gKiBBIGNsYXNzIGZvciBjcmVhdGluZyBpcGZzIGJhc2VkIERJRCBEb2N1bWVudHMuXG4gKiBCYXNlZCBvbiB0aGUgRElEIHNwZWM6IGh0dHBzOi8vdzNjLWNjZy5naXRodWIuaW8vZGlkLXNwZWMvXG4gKi9cbmNsYXNzIERpZERvY3VtZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBESUQgRG9jdW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgICAgIGlwZnMgICAgICAgICAgICBBbiBqcy1pcGZzIGluc3RhbmNlXG4gICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgICAgIG1ldGhvZCAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgRElEIE1ldGhvZFxuICAgKiBAcmV0dXJuICAgIHtEaWREb2N1bWVudH0gICAgICAgICAgICAgICAgICAgc2VsZlxuICAgKi9cbiAgY29uc3RydWN0b3IgKGlwZnMsIG1ldGhvZCkge1xuICAgIHRoaXMuX2lwZnMgPSBpcGZzXG4gICAgdGhpcy5fY29udGVudCA9IHtcbiAgICAgIGlkOiBgZGlkOiR7bWV0aG9kfToke0RJRF9QTEFDRUhPTERFUn1gXG4gICAgfVxuICB9XG5cbiAgZ2V0IERJRCAoKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRlbnQuaWQuaW5jbHVkZXMoRElEX1BMQUNFSE9MREVSKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdESUQgaXMgbm90IGF2YWlsYWJsZSBiZWZvcmUgY29tbWl0JylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQuaWRcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGFuIGFscmVhZHkgZXhpc3RpbmcgRElEIERvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgICAgICBpcGZzICAgICAgICAgICAgQW4ganMtaXBmcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICBkb2N1bWVudENpZCAgICAgVGhlIENJRCBvZiB0aGUgZG9jdW1lbnRcbiAgICogQHJldHVybiAgICB7UHJvbWlzZTxEaWREb2N1bWVudD59ICAgICAgICAgICAgICAgICAgIHNlbGZcbiAgICovXG4gIHN0YXRpYyBhc3luYyBsb2FkIChpcGZzLCBkb2N1bWVudENpZCkge1xuICAgIGNvbnN0IGRvYyA9IG5ldyBEaWREb2N1bWVudChpcGZzKVxuICAgIGRvYy5fY29udGVudCA9IGF3YWl0IERpZERvY3VtZW50LmNpZFRvRG9jdW1lbnQoaXBmcywgZG9jdW1lbnRDaWQpXG4gICAgZG9jLl9jb250ZW50LnByZXZpb3VzRG9jdW1lbnQgPSB7ICcvJzogZG9jdW1lbnRDaWQudG9TdHJpbmcoKSB9XG4gICAgcmV0dXJuIGRvY1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBwdWJsaWMga2V5XG4gICAqXG4gICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgICAgIGlkICAgICAgICAgICAgICBUaGUgaWQgb2YgdGhlIGtleSwgZS5nLiBcImtleTFcIlxuICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICB0eXBlICAgICAgICAgICAgVGhlIHR5cGUgb2YgdGhlIGtleVxuICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICBlbmNvZGluZyAgICAgICAgVGhlIGVuY29kaW5nIG9mIHRoZSBrZXlcbiAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAga2V5ICAgICAgICAgICAgIFRoZSBlbmNvZGVkIHB1YmxpYyBrZXlcbiAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAgb3duZXIgICAgICAgICAgIFRoZSBvd25lciBvZiB0aGUga2V5IChvcHRpb25hbClcbiAgICovXG4gIGFkZFB1YmxpY0tleSAoaWQsIHR5cGUsIGVuY29kaW5nLCBrZXksIG93bmVyKSB7XG4gICAgaWYgKCF0aGlzLl9jb250ZW50LnB1YmxpY0tleSkge1xuICAgICAgdGhpcy5fY29udGVudC5wdWJsaWNLZXkgPSBbXVxuICAgIH1cbiAgICBsZXQgZW50cnkgPSB7XG4gICAgICBpZDogYCR7dGhpcy5fY29udGVudC5pZH0jJHtpZH1gLFxuICAgICAgdHlwZVxuICAgIH1cbiAgICBlbnRyeVtlbmNvZGluZ10gPSBrZXlcbiAgICBpZiAob3duZXIpIHtcbiAgICAgIGVudHJ5Lm93bmVyID0gb3duZXJcbiAgICB9XG4gICAgdGhpcy5fY29udGVudC5wdWJsaWNLZXkucHVzaChlbnRyeSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBwdWJsaWMga2V5XG4gICAqXG4gICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgICAgIGlkICAgICAgICAgICAgICBUaGUgaWQgb2YgdGhlIGtleSwgZS5nLiBcImtleTFcIlxuICAgKi9cbiAgcmVtb3ZlUHVibGljS2V5IChpZCkge1xuICAgIGNvbnN0IGlkeCA9IHRoaXMuX2NvbnRlbnQucHVibGljS2V5LmZpbmRJbmRleChlID0+IGUuaWQuZW5kc1dpdGgoaWQpKVxuICAgIHRoaXMuX2NvbnRlbnQucHVibGljS2V5LnNwbGljZShpZHgsIDEpXG4gICAgaWYgKCF0aGlzLl9jb250ZW50LnB1YmxpY0tleS5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9jb250ZW50LnB1YmxpY0tleVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgYXV0aGVudGljYXRpb25cbiAgICpcbiAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAgdHlwZSAgICAgICAgICAgIFRoZSB0eXBlIG9mIHRoZSBhdXRoZW50aWNhdGlvblxuICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICBpZCAgICAgICAgICAgICAgVGhlIGlkIG9mIHRoZSBrZXkgdG8gYmUgdXNlZCwgZS5nLiBcImtleTFcIlxuICAgKi9cbiAgYWRkQXV0aGVudGljYXRpb24gKHR5cGUsIGlkKSB7XG4gICAgaWYgKCF0aGlzLl9jb250ZW50LmF1dGhlbnRpY2F0aW9uKSB7XG4gICAgICB0aGlzLl9jb250ZW50LmF1dGhlbnRpY2F0aW9uID0gW11cbiAgICB9XG4gICAgdGhpcy5fY29udGVudC5hdXRoZW50aWNhdGlvbi5wdXNoKHtcbiAgICAgIHR5cGUsXG4gICAgICBwdWJsaWNLZXk6IGAke3RoaXMuX2NvbnRlbnQuaWR9IyR7aWR9YFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGF1dGhlbnRpY2F0aW9uXG4gICAqXG4gICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgICAgIGlkICAgICAgICAgICAgICBUaGUgaWQgb2YgdGhlIGtleSwgZS5nLiBcImtleTFcIlxuICAgKi9cbiAgcmVtb3ZlQXV0aGVudGljYXRpb24gKGlkKSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy5fY29udGVudC5hdXRoZW50aWNhdGlvbi5maW5kSW5kZXgoZSA9PiBlLnB1YmxpY0tleS5lbmRzV2l0aChpZCkpXG4gICAgdGhpcy5fY29udGVudC5hdXRoZW50aWNhdGlvbi5zcGxpY2UoaWR4LCAxKVxuICAgIGlmICghdGhpcy5fY29udGVudC5hdXRoZW50aWNhdGlvbi5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9jb250ZW50LmF1dGhlbnRpY2F0aW9uXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBzZXJ2aWNlXG4gICAqXG4gICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgICAgIGlkICAgICAgICAgICAgICAgICAgVGhlIGlkIG9mIHRoZSBrZXkgdG8gYmUgdXNlZCwgZS5nLiBcImtleTFcIlxuICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICB0eXBlICAgICAgICAgICAgICAgIFRoZSB0eXBlIG9mIHRoZSBzZXJ2aWNlXG4gICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgICAgIHNlcnZpY2VFbmRwb2ludCAgICAgVGhlIGVuZHBvaW50IG9mIHRoZSBzZXJ2aWNlXG4gICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgICAgIGFkZGl0aW9uYWxGaWVsZHMgICAgQW55IGFkZGl0aW9uYWwgZmllbGRzIChvcHRpb25hbClcbiAgICovXG4gIGFkZFNlcnZpY2UgKGlkLCB0eXBlLCBzZXJ2aWNlRW5kcG9pbnQsIGFkZGl0aW9uYWxGaWVsZHMpIHtcbiAgICBpZiAoIXRoaXMuX2NvbnRlbnQuc2VydmljZSkge1xuICAgICAgdGhpcy5fY29udGVudC5zZXJ2aWNlID0gW11cbiAgICB9XG4gICAgdGhpcy5fY29udGVudC5zZXJ2aWNlLnB1c2goT2JqZWN0LmFzc2lnbih7XG4gICAgICBpZDogYCR7dGhpcy5fY29udGVudC5pZH07JHtpZH1gLFxuICAgICAgdHlwZSxcbiAgICAgIHNlcnZpY2VFbmRwb2ludFxuICAgIH0sIGFkZGl0aW9uYWxGaWVsZHMpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHNlcnZpY2VcbiAgICpcbiAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAgaWQgICAgICAgICAgICAgIFRoZSBpZCBvZiB0aGUga2V5LCBlLmcuIFwia2V5MVwiXG4gICAqL1xuICByZW1vdmVTZXJ2aWNlIChpZCkge1xuICAgIGNvbnN0IGlkeCA9IHRoaXMuX2NvbnRlbnQuc2VydmljZS5maW5kSW5kZXgoZSA9PiBlLmlkLmVuZHNXaXRoKGlkKSlcbiAgICB0aGlzLl9jb250ZW50LnNlcnZpY2Uuc3BsaWNlKGlkeCwgMSlcbiAgICBpZiAoIXRoaXMuX2NvbnRlbnQuc2VydmljZS5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9jb250ZW50LnNlcnZpY2VcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSByZXZvY2F0aW9uTWV0aG9kLiBUaGlzIGNhbiBiZSBvZiBhbnkganMgb2JqZWN0XG4gICAqIGFuZCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBpbXBsZW1lbnRlciBvZiBhIHJldm9jYXRpb24gbW9kdWxlLlxuICAgKlxuICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgICAgICBtZXRob2REZXNjcmlwdG9yICAgIHRoZSBvYmplY3QgdGhhdCBkZWZpbmVzIHRoZSByZXZvY2F0aW9uIG1ldGhvZFxuICAgKi9cbiAgc2V0UmV2b2NhdGlvbk1ldGhvZCAobWV0aG9kRGVzY3JpcHRvcikge1xuICAgIHRoaXMuX2NvbnRlbnQucmV2b2NhdGlvbk1ldGhvZCA9IG1ldGhvZERlc2NyaXB0b3JcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgcHJvcGVydHlcbiAgICpcbiAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAgcHJvcE5hbWUgICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICogQHBhcmFtICAgICB7T2JqZWN0fSAgICAgICAgcHJvcFZhbHVlICAgICAgICAgICBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gICAqL1xuICBhZGRDdXN0b21Qcm9wZXJ0eSAocHJvcE5hbWUsIHByb3BWYWx1ZSkge1xuICAgIHRoaXMuX2NvbnRlbnRbcHJvcE5hbWVdID0gcHJvcFZhbHVlXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgcHJvcGVydHlcbiAgICpcbiAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAgcHJvcE5hbWUgICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICovXG4gIHJlbW92ZUN1c3RvbVByb3BlcnR5IChwcm9wTmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLl9jb250ZW50W3Byb3BOYW1lXVxuICB9XG5cbiAgLyoqXG4gICAqIENvbW1pdCBhbGwgY2hhbmdlcyBhbmQgY3JlYXRlIGEgbmV3IGlwZnMgZGFnIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtICAgICB7T2JqZWN0fSAgICAgICAgb3B0cyAgICAgICAgICAgICAgICBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSAgICAge0Jvb2xlYW59ICAgICAgIG5vVGltZXN0YW1wICAgICAgICAgRG9uJ3QgdXNlIHRpbWVzdGFtcHMgaWYgdHJ1ZVxuICAgKlxuICAgKiBAcmV0dXJuICAgIHtQcm9taXNlPENJRD59ICAgICAgICAgICAgICAgICAgIFRoZSBDSUQgb2YgdGhlIG9iamVjdFxuICAgKi9cbiAgYXN5bmMgY29tbWl0IChvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuX2NvbnRlbnQuY3JlYXRlZCkge1xuICAgICAgdGhpcy5fY29udGVudFsnQGNvbnRleHQnXSA9ICdodHRwczovL3czaWQub3JnL2RpZC92MSdcbiAgICAgIGlmICghb3B0cy5ub1RpbWVzdGFtcCkge1xuICAgICAgICB0aGlzLl9jb250ZW50LmNyZWF0ZWQgPSAobmV3IERhdGUoRGF0ZS5ub3coKSkpLnRvSVNPU3RyaW5nKClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFvcHRzLm5vVGltZXN0YW1wKSB7XG4gICAgICB0aGlzLl9jb250ZW50LnVwZGF0ZWQgPSAobmV3IERhdGUoRGF0ZS5ub3coKSkpLnRvSVNPU3RyaW5nKClcbiAgICB9XG4gICAgY29uc3QgY2lkID0gYXdhaXQgdGhpcy5faXBmcy5kYWcucHV0KHRoaXMuX2NvbnRlbnQsIHsgZm9ybWF0OiAnZGFnLWNib3InLCBoYXNoQWxnOiAnc2hhMi0yNTYnIH0pXG4gICAgLy8gc2V0IHVwIGZvciBmdXJ0aGVyIGNoYW5nZXM6XG4gICAgdGhpcy5fY29udGVudCA9IGF3YWl0IERpZERvY3VtZW50LmNpZFRvRG9jdW1lbnQodGhpcy5faXBmcywgY2lkKVxuICAgIHRoaXMuX2NvbnRlbnQucHJldmlvdXNEb2N1bWVudCA9IHsgJy8nOiBjaWQudG9TdHJpbmcoKSB9XG4gICAgcmV0dXJuIGNpZFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIERJRCBkb2N1bWVudCBvZiBhIGRvY3VtZW50IENJRFxuICAgKlxuICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgICAgICBpcGZzICAgICAgICAgICAgQW4ganMtaXBmcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICBkb2N1bWVudENpZCAgICAgVGhlIENJRCBvZiB0aGUgZG9jdW1lbnRcbiAgICogQHJldHVybiAgICB7UHJvbWlzZTxPYmplY3Q+fSAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBESUQgZG9jdW1lbnQgYXMgYSBqcyBvYmplY3RcbiAgICovXG4gIHN0YXRpYyBhc3luYyBjaWRUb0RvY3VtZW50IChpcGZzLCBkb2N1bWVudENpZCkge1xuICAgIGxldCBkb2MgPSAoYXdhaXQgaXBmcy5kYWcuZ2V0KGRvY3VtZW50Q2lkKSkudmFsdWVcbiAgICAvLyBJZiBnZW5lc2lzIGRvY3VtZW50IHJlcGxhY2UgcGxhY2Vob2xkZXIgaWRlbnRpZmllciB3aXRoIGNpZFxuICAgIGlmIChkb2MuaWQuaW5jbHVkZXMoRElEX1BMQUNFSE9MREVSKSkge1xuICAgICAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKERJRF9QTEFDRUhPTERFUiwgJ2dpJylcbiAgICAgIGRvYy5pZCA9IGRvYy5pZC5yZXBsYWNlKHJlLCBkb2N1bWVudENpZClcbiAgICAgIGlmIChkb2MucHVibGljS2V5KSB7XG4gICAgICAgIGRvYy5wdWJsaWNLZXkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRvYy5wdWJsaWNLZXkpLnJlcGxhY2UocmUsIGRvY3VtZW50Q2lkKSlcbiAgICAgIH1cbiAgICAgIGlmIChkb2MuYXV0aGVudGljYXRpb24pIHtcbiAgICAgICAgZG9jLmF1dGhlbnRpY2F0aW9uID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkb2MuYXV0aGVudGljYXRpb24pLnJlcGxhY2UocmUsIGRvY3VtZW50Q2lkKSlcbiAgICAgIH1cbiAgICAgIGlmIChkb2Muc2VydmljZSkge1xuICAgICAgICBkb2Muc2VydmljZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZG9jLnNlcnZpY2UpLnJlcGxhY2UocmUsIGRvY3VtZW50Q2lkKSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRvYy5wcmV2aW91c0RvY3VtZW50KSB7XG4gICAgICAvLyBtYWtlIENJRCBodW1hbiByZWFkYWJsZVxuICAgICAgZG9jLnByZXZpb3VzRG9jdW1lbnQgPSB7ICcvJzogZG9jLnByZXZpb3VzRG9jdW1lbnQudG9TdHJpbmcoKSB9XG4gICAgfVxuICAgIHJldHVybiBkb2NcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpZERvY3VtZW50XG4iLCJ2YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCcuL2xpYi9YTUxIdHRwUmVxdWVzdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElQRlM7XG5cbi8qKlxuICogVGhlIHZhcnJ1Y3RvciBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBgcHJvdmlkZXJgIHRoZSBwcm92aWRlciBvYmplY3RcbiAqIEByZXR1cm4ge09iamVjdH0gYGlwZnNgIHJldHVybnMgYW4gSVBGUyBpbnN0YW5jZVxuICogQHRocm93cyBpZiB0aGUgYG5ld2AgZmxhZyBpcyBub3QgdXNlZFxuICovXG5mdW5jdGlvbiBJUEZTKHByb3ZpZGVyKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJUEZTKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ1tpcGZzLW1pbmldIElQRlMgaW5zdGFuY2UgbXVzdCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBcIm5ld1wiIGZsYWcgKGUuZy4gdmFyIGlwZnMgPSBuZXcgSVBGUyhcImh0dHA6Ly9sb2NhbGhvc3Q6ODU0NVwiKTspLicpOyB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnNldFByb3ZpZGVyKHByb3ZpZGVyIHx8IHt9KTtcbn1cblxuLyoqXG4gKiBObyBvcGVyYXRpb24gbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuZnVuY3Rpb24gbmV3UHJvbWlzZSh2YWwpIHsgcmV0dXJuIG5ldyBQcm9taXNlKHZhbCk7IH1cbmZ1bmN0aW9uIG5vb3BQcm9taXNlKHZhbCkgeyB2YWwobm9vcCwgbm9vcCk7IH1cblxuLyoqXG4gKiBTZXRzIHRoZSBwcm92aWRlciBvZiB0aGUgSVBGUyBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IGBwcm92aWRlcmAgdGhlIHByb3ZpZGVyIG9iamVjdFxuICogQHRocm93cyBpZiB0aGUgcHJvdmlkZXIgb2JqZWN0IGlzIG5vdCBhbiBvYmplY3RcbiAqL1xuSVBGUy5wcm90b3R5cGUuc2V0UHJvdmlkZXIgPSBmdW5jdGlvbiBzZXRQcm92aWRlcihwcm92aWRlcikge1xuICBpZiAodHlwZW9mIHByb3ZpZGVyICE9PSAnb2JqZWN0JykgeyB0aHJvdyBuZXcgRXJyb3IoYFtpZnBzanNdIHByb3ZpZGVyIG11c3QgYmUgdHlwZSBPYmplY3QsIGdvdCAnJHt0eXBlb2YgcHJvdmlkZXJ9Jy5gKTsgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBkYXRhID0gc2VsZi5wcm92aWRlciA9IE9iamVjdC5hc3NpZ24oe1xuICAgIGhvc3Q6ICcxMjcuMC4wLjEnLFxuICAgIHBpbm5pbmc6IHRydWUsXG4gICAgcG9ydDogJzUwMDEnLFxuICAgIHByb3RvY29sOiAnaHR0cCcsXG4gICAgYmFzZTogJy9hcGkvdjAnIH0sIHByb3ZpZGVyIHx8IHt9KTtcbiAgc2VsZi5yZXF1ZXN0QmFzZSA9IFN0cmluZyhgJHtkYXRhLnByb3RvY29sfTovLyR7ZGF0YS5ob3N0fToke2RhdGEucG9ydH0ke2RhdGEuYmFzZX1gKTtcbn07XG5cbi8qKlxuICogU2VuZHMgYW4gYXN5bmMgZGF0YSBwYWNrZXQgdG8gYW4gSVBGUyBub2RlXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdHNgIHRoZSBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gYGNiYCB0aGUgcHJvdmlkZXIgY2FsbGJhY2tcbiAqIEBjYWxsYmFjayByZXR1cm5zIGFuIGVycm9yIGlmIGFueSwgb3IgdGhlIGRhdGEgZnJvbSBJUEZTXG4gKi9cbklQRlMucHJvdG90eXBlLnNlbmRBc3luYyA9IGZ1bmN0aW9uIHNlbmRBc3luYyhvcHRzLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9O1xuXG4gIHJldHVybiAoY2IgPyBub29wUHJvbWlzZSA6IG5ld1Byb21pc2UpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBjYWxsYmFjayhlLCByKXtcbiAgICAgIChjYiB8fCBub29wKShlLCBvcHRpb25zLnRha2VIYXNoICYmIHIgPyByLkhhc2ggOiByKTtcbiAgICAgIGlmIChlKSByZXR1cm4gcmVqZWN0KGUpO1xuICAgICAgaWYgKCFlICYmIHIpIHJldHVybiByZXNvbHZlKG9wdGlvbnMudGFrZUhhc2ggPyByLkhhc2ggOiByKTtcbiAgICB9O1xuXG4gICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocmVxdWVzdC5yZWFkeVN0YXRlID09PSA0ICYmIHJlcXVlc3QudGltZW91dCAhPT0gMSkge1xuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihgW2lwZnMtbWluaV0gc3RhdHVzICR7cmVxdWVzdC5zdGF0dXN9OiAke3JlcXVlc3QucmVzcG9uc2VUZXh0fWApLCBudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgKG9wdGlvbnMuanNvblBhcnNlID8gSlNPTi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCkgOiByZXF1ZXN0LnJlc3BvbnNlVGV4dCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGpzb25FcnJvcikge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKGBbaXBmcy1taW5pXSB3aGlsZSBwYXJzaW5nIGRhdGE6ICcke1N0cmluZyhyZXF1ZXN0LnJlc3BvbnNlVGV4dCl9JywgZXJyb3I6ICR7U3RyaW5nKGpzb25FcnJvcil9IHdpdGggcHJvdmlkZXI6ICcke3NlbGYucmVxdWVzdEJhc2V9J2AsIG51bGwpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBwaW5uaW5nVVJJID0gc2VsZi5wcm92aWRlci5waW5uaW5nICYmIG9wdHMudXJpID09PSAnL2FkZCcgPyAnP3Bpbj10cnVlJyA6ICcnO1xuXG4gICAgICBpZiAob3B0aW9ucy5wYXlsb2FkKSB7XG4gICAgICAgIHJlcXVlc3Qub3BlbignUE9TVCcsIGAke3NlbGYucmVxdWVzdEJhc2V9JHtvcHRzLnVyaX0ke3Bpbm5pbmdVUkl9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIGAke3NlbGYucmVxdWVzdEJhc2V9JHtvcHRzLnVyaX0ke3Bpbm5pbmdVUkl9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmFjY2VwdCkge1xuICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoJ2FjY2VwdCcsIG9wdGlvbnMuYWNjZXB0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucGF5bG9hZCAmJiBvcHRpb25zLmJvdW5kYXJ5KSB7XG4gICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgYG11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PSR7b3B0aW9ucy5ib3VuZGFyeX1gKTtcbiAgICAgICAgcmVxdWVzdC5zZW5kKG9wdGlvbnMucGF5bG9hZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogY3JlYXRlcyBhIGJvdW5kYXJ5IHRoYXQgaXNuJ3QgcGFydCBvZiB0aGUgcGF5bG9hZFxuICovXG5mdW5jdGlvbiBjcmVhdGVCb3VuZGFyeShkYXRhKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIGJvdW5kYXJ5ID0gYC0tLS1JUEZTTWluaSR7TWF0aC5yYW5kb20oKSAqIDEwMDAwMH0uJHtNYXRoLnJhbmRvbSgpICogMTAwMDAwfWA7XG4gICAgaWYgKGRhdGEuaW5kZXhPZihib3VuZGFyeSkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gYm91bmRhcnk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWRkIGFuIHN0cmluZyBvciBidWZmZXIgdG8gSVBGU1xuICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfSBgaW5wdXRgIGEgc2luZ2xlIHN0cmluZyBvciBidWZmZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGBjYWxsYmFja2AgYSBjYWxsYmFjaywgd2l0aCAoZXJyb3IsIGlwZnNIYXNoIFN0cmluZylcbiAqIEBjYWxsYmFjayB7U3RyaW5nfSBgaXBmc0hhc2hgIHJldHVybnMgYW4gSVBGUyBoYXNoIHN0cmluZ1xuICovXG5JUEZTLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGREYXRhKGlucHV0LCBjYWxsYmFjaykge1xuICB2YXIgZGF0YSA9ICgodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dC5pc0J1ZmZlcikgPyBpbnB1dC50b1N0cmluZygnYmluYXJ5JykgOiBpbnB1dCk7XG4gIHZhciBib3VuZGFyeSA9IGNyZWF0ZUJvdW5kYXJ5KGRhdGEpO1xuICB2YXIgcGF5bG9hZCA9IGAtLSR7Ym91bmRhcnl9XFxyXFxuQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhOyBuYW1lPVwicGF0aFwiXFxyXFxuQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cXHJcXG5cXHJcXG4ke2RhdGF9XFxyXFxuLS0ke2JvdW5kYXJ5fS0tYDtcblxuICByZXR1cm4gdGhpcy5zZW5kQXN5bmMoe1xuICAgIGpzb25QYXJzZTogdHJ1ZSxcbiAgICBhY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICB1cmk6ICcvYWRkJyxcbiAgICB0YWtlSGFzaDogdHJ1ZSxcbiAgICBwYXlsb2FkLCBib3VuZGFyeSxcbiAgfSwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gSlNPTiBvYmplY3QgdG8gSVBGU1xuICogQHBhcmFtIHtPYmplY3R9IGBqc29uRGF0YWAgYSBzaW5nbGUgSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGBjYWxsYmFja2AgYSBjYWxsYmFjaywgd2l0aCAoZXJyb3IsIGlwZnNIYXNoIFN0cmluZylcbiAqIEBjYWxsYmFjayB7U3RyaW5nfSBgaXBmc0hhc2hgIHJldHVybnMgYW4gSVBGUyBoYXNoIHN0cmluZ1xuICovXG5JUEZTLnByb3RvdHlwZS5hZGRKU09OID0gZnVuY3Rpb24gYWRkSnNvbihqc29uRGF0YSwgY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gc2VsZi5hZGQoSlNPTi5zdHJpbmdpZnkoanNvbkRhdGEpLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgc3RhdCBgL29iamVjdC9zdGF0YCBmb3IgYW4gSVBGUyBoYXNoXG4gKiBAcGFyYW0ge1N0cmluZ30gYGlwZnNIYXNoYCBhIHNpbmdsZSBJUEZTIGhhc2ggU3RyaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgY2FsbGJhY2tgIGEgY2FsbGJhY2ssIHdpdGggKGVycm9yLCBzdGF0cyBPYmplY3QpXG4gKiBAY2FsbGJhY2sge09iamVjdH0gYHN0YXRzYCByZXR1cm5zIHRoZSBzdGF0cyBvYmplY3QgZm9yIHRoYXQgSVBGUyBoYXNoXG4gKi9cbklQRlMucHJvdG90eXBlLnN0YXQgPSBmdW5jdGlvbiBjYXQoaXBmc0hhc2gsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIHNlbGYuc2VuZEFzeW5jKHsganNvblBhcnNlOiB0cnVlLCB1cmk6IGAvb2JqZWN0L3N0YXQvJHtpcGZzSGFzaH1gIH0sIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBkYXRhIGZyb20gYW4gSVBGUyBoYXNoXG4gKiBAcGFyYW0ge1N0cmluZ30gYGlwZnNIYXNoYCBhIHNpbmdsZSBJUEZTIGhhc2ggU3RyaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgY2FsbGJhY2tgIGEgY2FsbGJhY2ssIHdpdGggKGVycm9yLCBzdGF0cyBPYmplY3QpXG4gKiBAY2FsbGJhY2sge1N0cmluZ30gYGRhdGFgIHJldHVybnMgdGhlIG91dHB1dCBkYXRhXG4gKi9cbklQRlMucHJvdG90eXBlLmNhdCA9IGZ1bmN0aW9uIGNhdChpcGZzSGFzaCwgY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gc2VsZi5zZW5kQXN5bmMoeyB1cmk6IGAvY2F0LyR7aXBmc0hhc2h9YCB9LCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZGF0YSBmcm9tIGFuIElQRlMgaGFzaCB0aGF0IGlzIGEgSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBgaXBmc0hhc2hgIGEgc2luZ2xlIElQRlMgaGFzaCBTdHJpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGBjYWxsYmFja2AgYSBjYWxsYmFjaywgd2l0aCAoZXJyb3IsIGpzb24gT2JqZWN0KVxuICogQGNhbGxiYWNrIHtPYmplY3R9IGBkYXRhYCByZXR1cm5zIHRoZSBvdXRwdXQgZGF0YSBKU09OIG9iamVjdFxuICovXG5JUEZTLnByb3RvdHlwZS5jYXRKU09OID0gZnVuY3Rpb24gY2F0SlNPTihpcGZzSGFzaCwgY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gc2VsZi5zZW5kQXN5bmMoeyB1cmk6IGAvY2F0LyR7aXBmc0hhc2h9YCwganNvblBhcnNlOiB0cnVlIH0sIGNhbGxiYWNrKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBIRE5vZGUgPSByZXF1aXJlKCdldGhlcnMnKS51dGlscy5IRE5vZGU7XG5cbnZhciBuYWNsID0gcmVxdWlyZSgndHdlZXRuYWNsJyk7XG5cbm5hY2wudXRpbCA9IHJlcXVpcmUoJ3R3ZWV0bmFjbC11dGlsJyk7XG5cbnZhciBTaW1wbGVTaWduZXIgPSByZXF1aXJlKCdkaWQtand0JykuU2ltcGxlU2lnbmVyO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuLi91dGlscy9pbmRleCcpLFxuICAgIHNoYTI1NiA9IF9yZXF1aXJlLnNoYTI1NjtcblxudmFyIEVDID0gcmVxdWlyZSgnZWxsaXB0aWMnKS5lYztcblxudmFyIGVjID0gbmV3IEVDKCdzZWNwMjU2azEnKTtcbnZhciBCQVNFX1BBVEggPSBcIm0vNzY5NjUwMCcvMCcvMCdcIjtcbnZhciBNTV9QQVRIID0gXCJtLzQ0Jy82MCcvMCcvMFwiO1xuXG52YXIgS2V5cmluZyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEtleXJpbmcoc2VlZCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgS2V5cmluZyk7XG4gICAgdGhpcy5fc2VlZCA9IHNlZWQ7XG4gICAgdmFyIHNlZWROb2RlID0gSEROb2RlLmZyb21TZWVkKHRoaXMuX3NlZWQpO1xuICAgIHZhciBiYXNlTm9kZSA9IHNlZWROb2RlLmRlcml2ZVBhdGgoQkFTRV9QQVRIKTtcbiAgICB0aGlzLnNpZ25pbmdLZXkgPSBiYXNlTm9kZS5kZXJpdmVQYXRoKFwiMFwiKTtcbiAgICB2YXIgdG1wRW5jS2V5ID0gQnVmZmVyLmZyb20oYmFzZU5vZGUuZGVyaXZlUGF0aChcIjJcIikucHJpdmF0ZUtleS5zbGljZSgyKSwgJ2hleCcpO1xuICAgIHRoaXMuYXN5bUVuY3J5cHRpb25LZXkgPSBuYWNsLmJveC5rZXlQYWlyLmZyb21TZWNyZXRLZXkobmV3IFVpbnQ4QXJyYXkodG1wRW5jS2V5KSk7XG4gICAgdGhpcy5zeW1FbmNyeXB0aW9uS2V5ID0gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20oYmFzZU5vZGUuZGVyaXZlUGF0aChcIjNcIikucHJpdmF0ZUtleS5zbGljZSgyKSwgJ2hleCcpKTtcbiAgICB0aGlzLmV0aGVyZXVtS2V5ID0gc2VlZE5vZGUuZGVyaXZlUGF0aChNTV9QQVRIKS5kZXJpdmVQYXRoKFwiMFwiKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoS2V5cmluZywgW3tcbiAgICBrZXk6IFwiYXN5bUVuY3J5cHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXN5bUVuY3J5cHQobXNnLCB0b1B1YmxpYywgbm9uY2UpIHtcbiAgICAgIG5vbmNlID0gbm9uY2UgfHwgcmFuZG9tTm9uY2UoKTtcbiAgICAgIHRvUHVibGljID0gbmFjbC51dGlsLmRlY29kZUJhc2U2NCh0b1B1YmxpYyk7XG5cbiAgICAgIGlmICh0eXBlb2YgbXNnID09PSAnc3RyaW5nJykge1xuICAgICAgICBtc2cgPSBuYWNsLnV0aWwuZGVjb2RlVVRGOChtc2cpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2lwaGVydGV4dCA9IG5hY2wuYm94KG1zZywgbm9uY2UsIHRvUHVibGljLCB0aGlzLmFzeW1FbmNyeXB0aW9uS2V5LnNlY3JldEtleSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub25jZTogbmFjbC51dGlsLmVuY29kZUJhc2U2NChub25jZSksXG4gICAgICAgIGNpcGhlcnRleHQ6IG5hY2wudXRpbC5lbmNvZGVCYXNlNjQoY2lwaGVydGV4dClcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFzeW1EZWNyeXB0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzeW1EZWNyeXB0KGNpcGhlcnRleHQsIGZyb21QdWJsaWMsIG5vbmNlLCB0b0J1ZmZlcikge1xuICAgICAgZnJvbVB1YmxpYyA9IG5hY2wudXRpbC5kZWNvZGVCYXNlNjQoZnJvbVB1YmxpYyk7XG4gICAgICBjaXBoZXJ0ZXh0ID0gbmFjbC51dGlsLmRlY29kZUJhc2U2NChjaXBoZXJ0ZXh0KTtcbiAgICAgIG5vbmNlID0gbmFjbC51dGlsLmRlY29kZUJhc2U2NChub25jZSk7XG4gICAgICB2YXIgY2xlYXJ0ZXh0ID0gbmFjbC5ib3gub3BlbihjaXBoZXJ0ZXh0LCBub25jZSwgZnJvbVB1YmxpYywgdGhpcy5hc3ltRW5jcnlwdGlvbktleS5zZWNyZXRLZXkpO1xuXG4gICAgICBpZiAodG9CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGNsZWFydGV4dCA/IEJ1ZmZlci5mcm9tKGNsZWFydGV4dCkgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xlYXJ0ZXh0ID8gbmFjbC51dGlsLmVuY29kZVVURjgoY2xlYXJ0ZXh0KSA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN5bUVuY3J5cHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3ltRW5jcnlwdChtc2csIG5vbmNlKSB7XG4gICAgICByZXR1cm4gc3ltRW5jcnlwdEJhc2UobXNnLCB0aGlzLnN5bUVuY3J5cHRpb25LZXksIG5vbmNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3ltRGVjcnlwdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzeW1EZWNyeXB0KGNpcGhlcnRleHQsIG5vbmNlLCB0b0J1ZmZlcikge1xuICAgICAgcmV0dXJuIHN5bURlY3J5cHRCYXNlKGNpcGhlcnRleHQsIHRoaXMuc3ltRW5jcnlwdGlvbktleSwgbm9uY2UsIHRvQnVmZmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SldUU2lnbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEpXVFNpZ25lcigpIHtcbiAgICAgIHJldHVybiBTaW1wbGVTaWduZXIodGhpcy5zaWduaW5nS2V5LnByaXZhdGVLZXkuc2xpY2UoMikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREQlNhbHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0REJTYWx0KCkge1xuICAgICAgcmV0dXJuIHNoYTI1Nih0aGlzLnNpZ25pbmdLZXkuZGVyaXZlUGF0aCgnMCcpLnByaXZhdGVLZXkuc2xpY2UoMikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQdWJsaWNLZXlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFB1YmxpY0tleXModW5jb21wcmVzc2VkKSB7XG4gICAgICB2YXIgc2lnbmluZ0tleSA9IHRoaXMuc2lnbmluZ0tleS5wdWJsaWNLZXkuc2xpY2UoMik7XG4gICAgICB2YXIgZXRoZXJldW1LZXkgPSB0aGlzLmV0aGVyZXVtS2V5LnB1YmxpY0tleS5zbGljZSgyKTtcblxuICAgICAgaWYgKHVuY29tcHJlc3NlZCkge1xuICAgICAgICBzaWduaW5nS2V5ID0gZWMua2V5RnJvbVB1YmxpYyhCdWZmZXIuZnJvbShzaWduaW5nS2V5LCAnaGV4JykpLmdldFB1YmxpYyhmYWxzZSwgJ2hleCcpO1xuICAgICAgICBldGhlcmV1bUtleSA9IGVjLmtleUZyb21QdWJsaWMoQnVmZmVyLmZyb20oZXRoZXJldW1LZXksICdoZXgnKSkuZ2V0UHVibGljKGZhbHNlLCAnaGV4Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNpZ25pbmdLZXk6IHNpZ25pbmdLZXksXG4gICAgICAgIGV0aGVyZXVtS2V5OiBldGhlcmV1bUtleSxcbiAgICAgICAgYXN5bUVuY3J5cHRpb25LZXk6IG5hY2wudXRpbC5lbmNvZGVCYXNlNjQodGhpcy5hc3ltRW5jcnlwdGlvbktleS5wdWJsaWNLZXkpXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlZWQ7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLZXlyaW5nO1xufSgpO1xuXG52YXIgcmFuZG9tTm9uY2UgPSBmdW5jdGlvbiByYW5kb21Ob25jZSgpIHtcbiAgcmV0dXJuIG5hY2wucmFuZG9tQnl0ZXMoMjQpO1xufTtcblxudmFyIHN5bUVuY3J5cHRCYXNlID0gZnVuY3Rpb24gc3ltRW5jcnlwdEJhc2UobXNnLCBzeW1LZXksIG5vbmNlKSB7XG4gIG5vbmNlID0gbm9uY2UgfHwgcmFuZG9tTm9uY2UoKTtcblxuICBpZiAodHlwZW9mIG1zZyA9PT0gJ3N0cmluZycpIHtcbiAgICBtc2cgPSBuYWNsLnV0aWwuZGVjb2RlVVRGOChtc2cpO1xuICB9XG5cbiAgdmFyIGNpcGhlcnRleHQgPSBuYWNsLnNlY3JldGJveChtc2csIG5vbmNlLCBzeW1LZXkpO1xuICByZXR1cm4ge1xuICAgIG5vbmNlOiBuYWNsLnV0aWwuZW5jb2RlQmFzZTY0KG5vbmNlKSxcbiAgICBjaXBoZXJ0ZXh0OiBuYWNsLnV0aWwuZW5jb2RlQmFzZTY0KGNpcGhlcnRleHQpXG4gIH07XG59O1xuXG52YXIgc3ltRGVjcnlwdEJhc2UgPSBmdW5jdGlvbiBzeW1EZWNyeXB0QmFzZShjaXBoZXJ0ZXh0LCBzeW1LZXksIG5vbmNlLCB0b0J1ZmZlcikge1xuICBjaXBoZXJ0ZXh0ID0gbmFjbC51dGlsLmRlY29kZUJhc2U2NChjaXBoZXJ0ZXh0KTtcbiAgbm9uY2UgPSBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KG5vbmNlKTtcbiAgdmFyIGNsZWFydGV4dCA9IG5hY2wuc2VjcmV0Ym94Lm9wZW4oY2lwaGVydGV4dCwgbm9uY2UsIHN5bUtleSk7XG5cbiAgaWYgKHRvQnVmZmVyKSB7XG4gICAgcmV0dXJuIGNsZWFydGV4dCA/IEJ1ZmZlci5mcm9tKGNsZWFydGV4dCkgOiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNsZWFydGV4dCA/IG5hY2wudXRpbC5lbmNvZGVVVEY4KGNsZWFydGV4dCkgOiBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlyaW5nOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfZGlkSnd0ID0gcmVxdWlyZShcImRpZC1qd3RcIik7XG5cbnZhciBfaXBmc0RpZERvY3VtZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiaXBmcy1kaWQtZG9jdW1lbnRcIikpO1xuXG52YXIgX2Jhc2U2NHVybCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImJhc2U2NHVybFwiKSk7XG5cbnZhciBfZGlkUmVzb2x2ZXIgPSByZXF1aXJlKFwiZGlkLXJlc29sdmVyXCIpO1xuXG52YXIgUFVCS0VZX0lEUyA9IFsnc2lnbmluZ0tleScsICdtYW5hZ2VtZW50S2V5JywgJ2VuY3J5cHRpb25LZXknXTtcbnZhciBTVUJfUFVCS0VZX0lEUyA9IFsnc3ViU2lnbmluZ0tleScsICdzdWJFbmNyeXB0aW9uS2V5J107XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyKGlwZnMpIHtcbiAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAoMCwgX2RpZFJlc29sdmVyLnJlZ2lzdGVyTWV0aG9kKSgnMycsIGZ1bmN0aW9uIChfLCBfcmVmKSB7XG4gICAgdmFyIGlkID0gX3JlZi5pZDtcbiAgICByZXR1cm4gcmVzb2x2ZShpcGZzLCBpZCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlKF94LCBfeDIsIF94Mykge1xuICByZXR1cm4gX3Jlc29sdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmUoKSB7XG4gIF9yZXNvbHZlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAvKiNfX1BVUkVfXyovXG4gIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKGlwZnMsIGNpZCwgaXNSb290KSB7XG4gICAgdmFyIGRvYywgcm9vdERvYztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiBfaXBmc0RpZERvY3VtZW50W1wiZGVmYXVsdFwiXS5jaWRUb0RvY3VtZW50KGlwZnMsIGNpZCk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBkb2MgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgdmFsaWRhdGVEb2MoZG9jKTtcblxuICAgICAgICAgICAgaWYgKCFkb2Mucm9vdCkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzUm9vdCkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgbGF5ZXIgc3ViRG9jIGFsbG93ZWQnKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGlwZnMsIGRvYy5yb290LnNwbGl0KCc6JylbMl0sIHRydWUpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJvb3REb2MgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzO1xuICAgICAgICAgICAgcmV0dXJuIHZlcmlmeVByb29mKGRvYyk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgZG9jID0gbWVyZ2VEb2N1bWVudHMocm9vdERvYywgZG9jKTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjY7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTY7XG4gICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTg7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjE7XG4gICAgICAgICAgICByZXR1cm4gaXBmcy5waW4ucm0oY2lkKTtcblxuICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjM7XG4gICAgICAgICAgICBfY29udGV4dC50MSA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMTgpO1xuXG4gICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCAzSUQnKTtcblxuICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGRvYyk7XG5cbiAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzAsIDE2XSwgWzE4LCAyM11dKTtcbiAgfSkpO1xuICByZXR1cm4gX3Jlc29sdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVEb2MoZG9jKSB7XG4gIHZhciBwdWJLZXlJZHMgPSBQVUJLRVlfSURTO1xuXG4gIGlmICghZG9jIHx8ICFkb2MucHVibGljS2V5IHx8ICFkb2MuYXV0aGVudGljYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHZhbGlkIDNJRCcpO1xuICB9XG5cbiAgaWYgKGRvYy5yb290KSB7XG4gICAgcHViS2V5SWRzID0gU1VCX1BVQktFWV9JRFM7XG4gICAgaWYgKCFkb2Muc3BhY2UpIHRocm93IG5ldyBFcnJvcignTm90IGEgdmFsaWQgM0lEJyk7XG4gIH1cblxuICBkb2MucHVibGljS2V5Lm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICB2YXIgaWQgPSBlbnRyeS5pZC5zcGxpdCgnIycpWzFdO1xuICAgIGlmICghcHViS2V5SWRzLmluY2x1ZGVzKGlkKSkgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSB2YWxpZCAzSUQnKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVNlY3Rpb24oZGF0YSkge1xuICByZXR1cm4gX2Jhc2U2NHVybFtcImRlZmF1bHRcIl0uZW5jb2RlKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5UHJvb2YoX3g0KSB7XG4gIHJldHVybiBfdmVyaWZ5UHJvb2YuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3ZlcmlmeVByb29mKCkge1xuICBfdmVyaWZ5UHJvb2YgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gIC8qI19fUFVSRV9fKi9cbiAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHN1YkRvYykge1xuICAgIHZhciBzdWJTaWduaW5nS2V5LCBzdWJFbmNyeXB0aW9uS2V5LCBwYXlsb2FkLCBoZWFkZXIsIGp3dDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHN1YlNpZ25pbmdLZXkgPSBzdWJEb2MucHVibGljS2V5LmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbnRyeS5pZC5pbmNsdWRlcyhTVUJfUFVCS0VZX0lEU1swXSk7XG4gICAgICAgICAgICB9KS5wdWJsaWNLZXlIZXg7XG4gICAgICAgICAgICBzdWJFbmNyeXB0aW9uS2V5ID0gc3ViRG9jLnB1YmxpY0tleS5maW5kKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICByZXR1cm4gZW50cnkuaWQuaW5jbHVkZXMoU1VCX1BVQktFWV9JRFNbMV0pO1xuICAgICAgICAgICAgfSkucHVibGljS2V5QmFzZTY0O1xuICAgICAgICAgICAgcGF5bG9hZCA9IGVuY29kZVNlY3Rpb24oe1xuICAgICAgICAgICAgICBpYXQ6IG51bGwsXG4gICAgICAgICAgICAgIHN1YlNpZ25pbmdLZXk6IHN1YlNpZ25pbmdLZXksXG4gICAgICAgICAgICAgIHN1YkVuY3J5cHRpb25LZXk6IHN1YkVuY3J5cHRpb25LZXksXG4gICAgICAgICAgICAgIHNwYWNlOiBzdWJEb2Muc3BhY2UsXG4gICAgICAgICAgICAgIGlzczogc3ViRG9jLnJvb3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGVhZGVyID0gZW5jb2RlU2VjdGlvbih7XG4gICAgICAgICAgICAgIHR5cDogJ0pXVCcsXG4gICAgICAgICAgICAgIGFsZzogc3ViRG9jLnByb29mLmFsZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBqd3QgPSBcIlwiLmNvbmNhdChoZWFkZXIsIFwiLlwiKS5jb25jYXQocGF5bG9hZCwgXCIuXCIpLmNvbmNhdChzdWJEb2MucHJvb2Yuc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2RpZEp3dC52ZXJpZnlKV1QpKGp3dCk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMik7XG4gIH0pKTtcbiAgcmV0dXJuIF92ZXJpZnlQcm9vZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBtZXJnZURvY3VtZW50cyhkb2MsIHN1YkRvYykge1xuICBzdWJEb2MucHVibGljS2V5ID0gZG9jLnB1YmxpY0tleS5jb25jYXQoc3ViRG9jLnB1YmxpY0tleSk7XG4gIHJldHVybiBzdWJEb2M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVnaXN0ZXI7IiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEFjY2Vzc0NvbnRyb2xsZXJNYW5pZmVzdCA9IHJlcXVpcmUoJy4vYWNjZXNzLWNvbnRyb2xsZXItbWFuaWZlc3QnKVxuY29uc3QgTGVnYWN5SVBGU0FjY2Vzc0NvbnRyb2xsZXIgPSByZXF1aXJlKCcuL2xlZ2FjeS1pcGZzLWFjY2Vzcy1jb250cm9sbGVyJylcbmNvbnN0IElQRlNBY2Nlc3NDb250cm9sbGVyID0gcmVxdWlyZSgnLi9pcGZzLWFjY2Vzcy1jb250cm9sbGVyJylcbmNvbnN0IE9yYml0REJBY2Nlc3NDb250cm9sbGVyID0gcmVxdWlyZSgnLi9vcmJpdGRiLWFjY2Vzcy1jb250cm9sbGVyJylcblxubGV0IHN1cHBvcnRlZFR5cGVzID0ge1xuICAnbGVnYWN5LWlwZnMnOiBMZWdhY3lJUEZTQWNjZXNzQ29udHJvbGxlcixcbiAgJ2lwZnMnOiBJUEZTQWNjZXNzQ29udHJvbGxlcixcbiAgJ29yYml0ZGInOiBPcmJpdERCQWNjZXNzQ29udHJvbGxlclxufVxuXG5jb25zdCBnZXRIYW5kbGVyRm9yID0gKHR5cGUpID0+IHtcbiAgaWYgKCFBY2Nlc3NDb250cm9sbGVycy5pc1N1cHBvcnRlZCh0eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQWNjZXNzQ29udHJvbGxlciB0eXBlICcke3R5cGV9JyBpcyBub3Qgc3VwcG9ydGVkYClcbiAgfVxuICByZXR1cm4gc3VwcG9ydGVkVHlwZXNbdHlwZV1cbn1cblxuY2xhc3MgQWNjZXNzQ29udHJvbGxlcnMge1xuICBzdGF0aWMgaXNTdXBwb3J0ZWQgKHR5cGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc3VwcG9ydGVkVHlwZXMpLmluY2x1ZGVzKHR5cGUpXG4gIH1cblxuICBzdGF0aWMgYWRkQWNjZXNzQ29udHJvbGxlciAob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5BY2Nlc3NDb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY2Vzc0NvbnRyb2xsZXIgY2xhc3MgbmVlZHMgdG8gYmUgZ2l2ZW4gYXMgYW4gb3B0aW9uJylcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMuQWNjZXNzQ29udHJvbGxlci50eXBlIHx8XG4gICAgICB0eXBlb2Ygb3B0aW9ucy5BY2Nlc3NDb250cm9sbGVyLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIEFjY2Vzc0NvbnRyb2xsZXIgY2xhc3MgbmVlZHMgdG8gaW1wbGVtZW50OiBzdGF0aWMgZ2V0IHR5cGUoKSB7IC8qIHJldHVybiBhIHN0cmluZyAqL30uJylcbiAgICB9XG5cbiAgICBzdXBwb3J0ZWRUeXBlc1tvcHRpb25zLkFjY2Vzc0NvbnRyb2xsZXIudHlwZV0gPSBvcHRpb25zLkFjY2Vzc0NvbnRyb2xsZXJcbiAgfVxuXG4gIHN0YXRpYyBhZGRBY2Nlc3NDb250cm9sbGVycyAob3B0aW9ucykge1xuICAgIGNvbnN0IGFjY2Vzc0NvbnRyb2xsZXJzID0gb3B0aW9ucy5BY2Nlc3NDb250cm9sbGVyc1xuICAgIGlmICghYWNjZXNzQ29udHJvbGxlcnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWNjZXNzQ29udHJvbGxlciBjbGFzc2VzIG5lZWQgdG8gYmUgZ2l2ZW4gYXMgYW4gb3B0aW9uJylcbiAgICB9XG5cbiAgICBhY2Nlc3NDb250cm9sbGVycy5mb3JFYWNoKChhY2Nlc3NDb250cm9sbGVyKSA9PiB7XG4gICAgICBBY2Nlc3NDb250cm9sbGVycy5hZGRBY2Nlc3NDb250cm9sbGVyKHsgQWNjZXNzQ29udHJvbGxlcjogYWNjZXNzQ29udHJvbGxlciB9KVxuICAgIH0pXG4gIH1cblxuICBzdGF0aWMgcmVtb3ZlQWNjZXNzQ29udHJvbGxlciAodHlwZSkge1xuICAgIGRlbGV0ZSBzdXBwb3J0ZWRUeXBlc1t0eXBlXVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIHJlc29sdmUgKG9yYml0ZGIsIG1hbmlmZXN0QWRkcmVzcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyB0eXBlLCBwYXJhbXMgfSA9IGF3YWl0IEFjY2Vzc0NvbnRyb2xsZXJNYW5pZmVzdC5yZXNvbHZlKG9yYml0ZGIuX2lwZnMsIG1hbmlmZXN0QWRkcmVzcywgb3B0aW9ucylcbiAgICBjb25zdCBBY2Nlc3NDb250cm9sbGVyID0gZ2V0SGFuZGxlckZvcih0eXBlKVxuICAgIGNvbnN0IGFjY2Vzc0NvbnRyb2xsZXIgPSBhd2FpdCBBY2Nlc3NDb250cm9sbGVyLmNyZWF0ZShvcmJpdGRiLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCBwYXJhbXMpKVxuICAgIGF3YWl0IGFjY2Vzc0NvbnRyb2xsZXIubG9hZChwYXJhbXMuYWRkcmVzcylcbiAgICByZXR1cm4gYWNjZXNzQ29udHJvbGxlclxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZSAob3JiaXRkYiwgdHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgQWNjZXNzQ29udHJvbGxlciA9IGdldEhhbmRsZXJGb3IodHlwZSlcbiAgICBjb25zdCBhYyA9IGF3YWl0IEFjY2Vzc0NvbnRyb2xsZXIuY3JlYXRlKG9yYml0ZGIsIG9wdGlvbnMpXG4gICAgY29uc3QgcGFyYW1zID0gYXdhaXQgYWMuc2F2ZSgpXG4gICAgY29uc3QgaGFzaCA9IGF3YWl0IEFjY2Vzc0NvbnRyb2xsZXJNYW5pZmVzdC5jcmVhdGUob3JiaXRkYi5faXBmcywgdHlwZSwgcGFyYW1zKVxuICAgIHJldHVybiBoYXNoXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBY2Nlc3NDb250cm9sbGVyc1xuIiwiY29uc3QgdHlwZSA9ICdtb2RlcmF0b3ItYWNjZXNzJ1xuXG5jb25zdCBNT0RFUkFUT1IgPSAnTU9ERVJBVE9SJ1xuY29uc3QgTUVNQkVSID0gJ01FTUJFUidcblxuY2xhc3MgTW9kZXJhdG9yQWNjZXNzQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yIChmaXJzdE1vZGVyYXRvciwgb3B0aW9ucykge1xuICAgIHRoaXMuX2NhcGFiaWxpdHlUeXBlcyA9IFtNT0RFUkFUT1JdXG4gICAgdGhpcy5fd3JpdGUgPSBbXSAgICAgLy8gQWxsb3dlZCB0byBhZGQgb3RoZXIgbW9kcyBvciBtZW1iZXJzXG4gICAgdGhpcy5fZmlyc3RNb2RlcmF0b3IgPSBmaXJzdE1vZGVyYXRvclxuICAgIHRoaXMuX3dyaXRlLnB1c2godGhpcy5fZmlyc3RNb2RlcmF0b3IpXG4gICAgdGhpcy5fbWVtYmVycyA9IEJvb2xlYW4ob3B0aW9ucy5tZW1iZXJzKVxuICAgIGlmICh0aGlzLl9tZW1iZXJzKSB0aGlzLl9jYXBhYmlsaXR5VHlwZXMucHVzaChNRU1CRVIpXG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkgeyByZXR1cm4gdHlwZSB9XG5cbiAgaXNNb2QoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGUuaW5jbHVkZXMoaWQpXG4gIH1cblxuICBpc1ZhbGlkQ2FwYWJpbGl0eSAoY2FwYWJpbGl0eSkge1xuICAgIHJldHVybiB0aGlzLl9jYXBhYmlsaXR5VHlwZXMuaW5jbHVkZXMoY2FwYWJpbGl0eSlcbiAgfVxuXG4gIGdldCBmaXJzdE1vZGVyYXRvciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpcnN0TW9kZXJhdG9yXG4gIH1cblxuICBhc3luYyBjYW5BcHBlbmQgKGVudHJ5LCBpZGVudGl0eVByb3ZpZGVyKSB7XG4gICAgY29uc3QgZW50cnlJRCA9IGVudHJ5LmlkZW50aXR5LmlkXG4gICAgY29uc3QgY2FwYWJpbGl0eSA9IGVudHJ5LnBheWxvYWQudmFsdWUuY2FwYWJpbGl0eVxuICAgIGNvbnN0IGlkQWRkID0gZW50cnkucGF5bG9hZC52YWx1ZS5pZFxuICAgIGNvbnN0IGlzTW9kID0gdGhpcy5pc01vZChlbnRyeUlEKVxuICAgIGNvbnN0IHZhbGlkQ2FwYWJpbGl0eSA9IHRoaXMuaXNWYWxpZENhcGFiaWxpdHkoY2FwYWJpbGl0eSlcbiAgICBjb25zdCB2YWxpZFNpZyA9IGFzeW5jICgpID0+IGlkZW50aXR5UHJvdmlkZXIudmVyaWZ5SWRlbnRpdHkoZW50cnkuaWRlbnRpdHkpXG4gICAgaWYgKGlzTW9kICYmIHZhbGlkQ2FwYWJpbGl0eSAmJiAoYXdhaXQgdmFsaWRTaWcoKSkpIHtcbiAgICAgIGlmIChjYXBhYmlsaXR5ID09PSBNT0RFUkFUT1IpIHRoaXMuX3dyaXRlLnB1c2goaWRBZGQpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgYXN5bmMgbG9hZCAoYWRkcmVzcykge1xuICAgIGNvbnN0IGFkZExpc3QgPSBhZGRyZXNzLnNwbGl0KCcvJylcbiAgICBjb25zdCBzdWZmaXggPSBhZGRMaXN0LnBvcCgpXG4gICAgdGhpcy5fbWVtYmVycyA9IHN1ZmZpeCA9PT0gJ21lbWJlcnMnXG4gICAgY29uc3QgbW9kID0gc3VmZml4LmluY2x1ZGVzKCdtb2QnKSA/IHN1ZmZpeCA6IGFkZExpc3QucG9wKClcbiAgICB0aGlzLl9maXJzdE1vZGVyYXRvciA9IG1vZC5zcGxpdCgnXycpWzFdXG4gIH1cblxuICBhc3luYyBzYXZlICgpIHtcbiAgICAvLyBUT0RPIGlmIGVudGlyZSBvYmogc2F2ZWQgaW4gbWFuZmVzdCwgY2FuIGp1c3QgcGFzcyBvdXIgb3duIGZpZWxkc1xuICAgIGxldCBhZGRyZXNzID0gYCR7dHlwZX0vbW9kXyR7dGhpcy5fZmlyc3RNb2RlcmF0b3J9YFxuICAgIGFkZHJlc3MgKz0gdGhpcy5fbWVtYmVycyA/ICcvbWVtYmVycycgOiAnJ1xuICAgIHJldHVybiB7IGFkZHJlc3MgfVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZSAob3JiaXRkYiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFvcHRpb25zLmZpcnN0TW9kZXJhdG9yKSB0aHJvdyBuZXcgRXJyb3IoJ01vZGVyYXRvciBBQzogZmlyc3RNb2RlcmF0b3IgcmVxdWlyZWQnKVxuICAgIHJldHVybiBuZXcgTW9kZXJhdG9yQWNjZXNzQ29udHJvbGxlcihvcHRpb25zLmZpcnN0TW9kZXJhdG9yLCBvcHRpb25zKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZXJhdG9yQWNjZXNzQ29udHJvbGxlclxuIiwiY29uc3QgaW8gPSByZXF1aXJlKCdvcmJpdC1kYi1pbycpXG5jb25zdCBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuLy9jb25zdCBBY2Nlc3NDb250cm9sbGVyID0gcmVxdWlyZSgnLi9hY2Nlc3MtY29udHJvbGxlci1pbnRlcmZhY2UnKVxuY29uc3QgcmVzb2x2ZSA9IHJlcXVpcmUoJ2RpZC1yZXNvbHZlcicpLmRlZmF1bHRcbmNvbnN0IHR5cGUgPSAnbGVnYWN5LWlwZnMtM2JveCdcblxuY29uc3QgcHVibGljS2V5RnJvbURJRCA9IGFzeW5jIGRpZCA9PiB7XG4gIC8vIFRPRE8gLSB0aGlzIHNob3VsZCBsb29rIGF0IGF1dGhlbnRpY2F0aW9uIGtleXMgYW5kIGdldCBwdWJsaWNLZXkgZnJvbSB0aGF0XG4gIGNvbnN0IGRvYyA9IGF3YWl0IHJlc29sdmUoZGlkKVxuICByZXR1cm4gZG9jLnB1YmxpY0tleS5maW5kKGVudHJ5ID0+IHtcbiAgICBjb25zdCBpZCA9IGVudHJ5LmlkLnNwbGl0KCcjJylcbiAgICByZXR1cm4gaWRbMF0gPT09IGRvYy5pZCAmJlxuICAgICAgKGlkWzFdID09PSAnc3ViU2lnbmluZ0tleScgfHwgaWRbMV0gPT09ICdzaWduaW5nS2V5JylcbiAgfSkucHVibGljS2V5SGV4XG59XG5cbmNsYXNzIExlZ2FjeUlQRlMzQm94QWNjZXNzQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yIChpcGZzLCBvcHRpb25zKSB7XG4gICAgLy9zdXBlcigpXG4gICAgdGhpcy5faXBmcyA9IGlwZnNcbiAgICB0aGlzLl93cml0ZSA9IEFycmF5LmZyb20ob3B0aW9ucy53cml0ZSB8fCBbXSlcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIHR5cGUgb2YgdGhlIGFjY2VzcyBjb250cm9sbGVyXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7IHJldHVybiB0eXBlIH1cblxuICAvLyBSZXR1cm4gYSBTZXQgb2Yga2V5cyB0aGF0IGhhdmUgYGFjY2Vzc2AgY2FwYWJpbGl0eVxuICBnZXQgd3JpdGUgKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0ZVxuICB9XG5cbiAgYXN5bmMgY2FuQXBwZW5kIChlbnRyeSwgaWRlbnRpdHlQcm92aWRlcikge1xuICAgIC8vIEFsbG93IGlmIGFjY2VzcyBsaXN0IGNvbnRhaW4gdGhlIHdyaXRlcidzIHB1YmxpY0tleSBvciBpcyAnKidcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBlbnRyeS52ID09PSAwID8gZW50cnkua2V5IDogYXdhaXQgcHVibGljS2V5RnJvbURJRChlbnRyeS5pZGVudGl0eS5pZClcbiAgICBpZiAodGhpcy53cml0ZS5pbmNsdWRlcyhwdWJsaWNLZXkpIHx8XG4gICAgICB0aGlzLndyaXRlLmluY2x1ZGVzKCcqJykpIHtcbiAgICAgIHJldHVybiBlbnRyeS52ID09PSAwID8gdHJ1ZSA6IGF3YWl0IGlkZW50aXR5UHJvdmlkZXIudmVyaWZ5SWRlbnRpdHkoZW50cnkuaWRlbnRpdHkpXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgYXN5bmMgbG9hZCAoYWRkcmVzcykge1xuICAgIC8vIFRyYW5zZm9ybSAnL2lwZnMvUW1QRnRIaTNjbWZaZXJ4dEg5eVNMZHpwZzF5RmhvY1lEWmdFWnl3ZFVYSHhGVSdcbiAgICAvLyB0byAnUW1QRnRIaTNjbWZaZXJ4dEg5eVNMZHpwZzF5RmhvY1lEWmdFWnl3ZFVYSHhGVSdcbiAgICBpZiAoYWRkcmVzcy5pbmRleE9mKCcvaXBmcycpID09PSAwKSB7IGFkZHJlc3MgPSBhZGRyZXNzLnNwbGl0KCcvJylbMl0gfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFjY2VzcyA9IGF3YWl0IGlvLnJlYWQodGhpcy5faXBmcywgYWRkcmVzcylcbiAgICAgIHRoaXMuX3dyaXRlID0gYWNjZXNzLndyaXRlXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coJ0xlZ2FjeUlQRlMzQm94QWNjZXNzQ29udHJvbGxlci5sb2FkIEVSUk9SOicsIGUpXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc2F2ZSAob3B0aW9ucykge1xuICAgIGxldCBjaWRcbiAgICBjb25zdCBhY2Nlc3MgPSB7IGFkbWluOiBbXSwgd3JpdGU6IHRoaXMud3JpdGUsIHJlYWQ6IFtdIH1cbiAgICB0cnkge1xuICAgICAgY2lkID0gYXdhaXQgaW8ud3JpdGUodGhpcy5faXBmcywgJ3JhdycsIEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KGFjY2VzcywgbnVsbCwgMikpLCB7IGZvcm1hdDogJ2RhZy1wYid9KVxuXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coJ0xlZ2FjeUlQRlMzQm94QWNjZXNzQ29udHJvbGxlci5zYXZlIEVSUk9SOicsIGUpXG4gICAgfVxuICAgIC8vIHJldHVybiB0aGUgbWFuaWZlc3QgZGF0YVxuICAgIHJldHVybiB7IGFkZHJlc3M6IGNpZCwgc2tpcE1hbmlmZXN0OiB0cnVlIH1cbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBjcmVhdGUgKG9yYml0ZGIsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIC4uLnsgd3JpdGU6IG9wdGlvbnMud3JpdGUgfHwgW29yYml0ZGIuaWRlbnRpdHkucHVibGljS2V5XSB9IH1cbiAgICByZXR1cm4gbmV3IExlZ2FjeUlQRlMzQm94QWNjZXNzQ29udHJvbGxlcihvcmJpdGRiLl9pcGZzLCBvcHRpb25zKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGVnYWN5SVBGUzNCb3hBY2Nlc3NDb250cm9sbGVyXG4iLCJjb25zdCBlbnN1cmVBZGRyZXNzID0gcmVxdWlyZSgnb3JiaXQtZGItYWNjZXNzLWNvbnRyb2xsZXJzL3NyYy91dGlscy9lbnN1cmUtYWMtYWRkcmVzcycpXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbmNvbnN0IGVudHJ5SVBGUyA9IHJlcXVpcmUoJ2lwZnMtbG9nL3NyYy9lbnRyeScpXG5jb25zdCBpc0lQRlMgPSByZXF1aXJlKCdpcy1pcGZzJylcblxuY29uc3QgdHlwZSA9ICd0aHJlYWQtYWNjZXNzJ1xuY29uc3QgTU9ERVJBVE9SID0gJ01PREVSQVRPUidcbmNvbnN0IE1FTUJFUiA9ICdNRU1CRVInXG5cbmNvbnN0IGlzVmFsaWQzSUQgPSBkaWQgPT4ge1xuICBjb25zdCBwYXJ0cyA9IGRpZC5zcGxpdCgnOicpXG4gIGlmICghcGFydHNbMF0gPT09ICdkaWQnIHx8ICFwYXJ0c1sxXSA9PT0gJzMnKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIGlzSVBGUy5jaWQocGFydHNbMl0pXG59XG5cbmNsYXNzIFRocmVhZEFjY2Vzc0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXJ7XG4gIGNvbnN0cnVjdG9yIChvcmJpdGRiLCBpcGZzLCBpZGVudGl0eSwgZmlyc3RNb2RlcmF0b3IsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fb3JiaXRkYiA9IG9yYml0ZGJcbiAgICB0aGlzLl9kYiA9IG51bGxcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIHRoaXMuX2lwZnMgPSBpcGZzXG4gICAgdGhpcy5fbWVtYmVycyA9IEJvb2xlYW4ob3B0aW9ucy5tZW1iZXJzKVxuICAgIHRoaXMuX2ZpcnN0TW9kZXJhdG9yID0gZmlyc3RNb2RlcmF0b3JcbiAgICB0aGlzLl90aHJlYWROYW1lID0gb3B0aW9ucy50aHJlYWROYW1lXG4gICAgdGhpcy5faWRlbnRpdHkgPSBpZGVudGl0eVxuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHsgcmV0dXJuIHR5cGUgfVxuXG4gIC8vIHJldHVybiBhZGRyZXMgb2YgQUMgKGluIHRoaXMgY2FzZSBvcmJpdGRiIGFkZHJlc3Mgb2YgQUMpXG4gIGdldCBhZGRyZXNzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGIuYWRkcmVzc1xuICB9XG5cbiAgYXN5bmMgY2FuQXBwZW5kIChlbnRyeSwgaWRlbnRpdHlQcm92aWRlcikge1xuICAgIGNvbnN0IHRydWVJZlZhbGlkU2lnID0gYXN5bmMgKCkgPT4gYXdhaXQgaWRlbnRpdHlQcm92aWRlci52ZXJpZnlJZGVudGl0eShlbnRyeS5pZGVudGl0eSlcblxuICAgIGNvbnN0IG9wID0gZW50cnkucGF5bG9hZC5vcFxuICAgIGNvbnN0IG1vZHMgPSB0aGlzLmNhcGFiaWxpdGllc1snbW9kZXJhdG9ycyddXG4gICAgY29uc3QgbWVtYmVycyA9IHRoaXMuY2FwYWJpbGl0aWVzWydtZW1iZXJzJ11cbiAgICBjb25zdCBpc01vZCA9IG1vZHMuaW5jbHVkZXMoZW50cnkuaWRlbnRpdHkuaWQpXG4gICAgY29uc3QgaXNNZW1iZXIgPSBtZW1iZXJzLmluY2x1ZGVzKGVudHJ5LmlkZW50aXR5LmlkKVxuXG4gICAgaWYgKG9wID09PSAnQUREJykge1xuICAgICAgLy8gQW55b25lIGNhbiBhZGQgZW50cnkgaWYgb3BlbiB0aHJlYWRcbiAgICAgIGlmICghdGhpcy5fbWVtYmVycykgcmV0dXJuIGF3YWl0IHRydWVJZlZhbGlkU2lnKClcbiAgICAgIC8vIE5vdCBvcGVuIHRocmVhZCwgYW55IG1lbWJlciBvciBtb2QgY2FuIGFkZCB0byB0aHJlYWRcbiAgICAgIGlmIChpc01lbWJlciB8fCBpc01vZCkgcmV0dXJuIGF3YWl0IHRydWVJZlZhbGlkU2lnKClcbiAgICB9XG5cbiAgICBpZiAob3AgPT09ICdERUwnKSB7XG4gICAgICBjb25zdCBoYXNoID0gZW50cnkucGF5bG9hZC52YWx1ZVxuICAgICAgY29uc3QgZGVsRW50cnkgPSBhd2FpdCBlbnRyeUlQRlMuZnJvbU11bHRpaGFzaCh0aGlzLl9pcGZzLCBoYXNoKVxuXG4gICAgICAvLyBBbiBpZCBjYW4gZGVsZXRlIHRoZWlyIG93biBlbnRyaWVzXG4gICAgICBpZiAoZGVsRW50cnkuaWRlbnRpdHkuaWQgPT09IGVudHJ5LmlkZW50aXR5LmlkKSByZXR1cm4gYXdhaXQgdHJ1ZUlmVmFsaWRTaWcoKVxuXG4gICAgICAvLyBNb2RzIGNhbiBkZWxldGUgYW55IGVudHJ5XG4gICAgICBpZiAoaXNNb2QpIHJldHVybiBhd2FpdCB0cnVlSWZWYWxpZFNpZygpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBnZXQgY2FwYWJpbGl0aWVzICgpIHtcbiAgICBpZiAoIXRoaXMuX2NhcGFiaWxpdGllcykgdGhpcy5fdXBkYXRlQ2FwYWJpbGl0ZXMoKVxuICAgIHJldHVybiB0aGlzLl9jYXBhYmlsaXRpZXNcbiAgfVxuXG4gIF91cGRhdGVDYXBhYmlsaXRlcyAoKSB7XG4gICAgbGV0IG1vZGVyYXRvcnMgPSBbXSwgbWVtYmVycyA9IFtdXG4gICAgaWYgKHRoaXMuX2RiKSB7XG4gICAgICBtb2RlcmF0b3JzLnB1c2godGhpcy5fZGIuYWNjZXNzLl9maXJzdE1vZGVyYXRvcilcbiAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuX2RiLmluZGV4KS5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgY29uc3QgY2FwYWJpbGl0eSA9IGVudHJ5WzFdLnBheWxvYWQudmFsdWUuY2FwYWJpbGl0eVxuICAgICAgICBjb25zdCBpZCA9IGVudHJ5WzFdLnBheWxvYWQudmFsdWUuaWRcbiAgICAgICAgaWYgKGNhcGFiaWxpdHkgPT09IE1PREVSQVRPUikgbW9kZXJhdG9ycy5wdXNoKGlkKVxuICAgICAgICBpZiAoY2FwYWJpbGl0eSA9PT0gTUVNQkVSKSBtZW1iZXJzLnB1c2goaWQpXG4gICAgICB9KVxuICAgIH1cbiAgICB0aGlzLl9jYXBhYmlsaXRpZXMgPSB7bW9kZXJhdG9ycywgbWVtYmVyc31cbiAgICByZXR1cm4gdGhpcy5fY2FwYWJpbGl0aWVzXG4gIH1cblxuICBnZXQgKGNhcGFiaWxpdHkpIHtcbiAgICByZXR1cm4gdGhpcy5jYXBhYmlsaXRpZXNbY2FwYWJpbGl0eV0gfHwgW11cbiAgfVxuXG4gIGFzeW5jIGNsb3NlICgpIHtcbiAgICBhd2FpdCB0aGlzLl9kYi5jbG9zZSgpXG4gIH1cblxuICBhc3luYyBsb2FkIChhZGRyZXNzKSB7XG4gICAgaWYgKHRoaXMuX2RiKSB7IGF3YWl0IHRoaXMuX2RiLmNsb3NlKCkgfVxuXG4gICAgLy8gVE9ETyAtIHNraXAgbWFuaWZlc3QgZm9yIG1vZC1hY2Nlc3NcbiAgICB0aGlzLl9kYiA9IGF3YWl0IHRoaXMuX29yYml0ZGIuZmVlZChlbnN1cmVBZGRyZXNzKGFkZHJlc3MpLCB7XG4gICAgICBpZGVudGl0eTogdGhpcy5faWRlbnRpdHksXG4gICAgICBhY2Nlc3NDb250cm9sbGVyOiB7XG4gICAgICAgIHR5cGU6ICdtb2RlcmF0b3ItYWNjZXNzJyxcbiAgICAgICAgZmlyc3RNb2RlcmF0b3I6IHRoaXMuX2ZpcnN0TW9kZXJhdG9yLFxuICAgICAgICBtZW1iZXJzOiB0aGlzLl9tZW1iZXJzXG4gICAgICB9LFxuICAgICAgc3luYzogdHJ1ZVxuICAgIH0pXG5cbiAgICB0aGlzLl9kYi5ldmVudHMub24oJ3JlYWR5JywgdGhpcy5fb25VcGRhdGUuYmluZCh0aGlzKSlcbiAgICB0aGlzLl9kYi5ldmVudHMub24oJ3dyaXRlJywgdGhpcy5fb25VcGRhdGUuYmluZCh0aGlzKSlcbiAgICB0aGlzLl9kYi5ldmVudHMub24oJ3JlcGxpY2F0ZWQnLCB0aGlzLl9vblVwZGF0ZS5iaW5kKHRoaXMpKVxuXG4gICAgYXdhaXQgdGhpcy5fZGIubG9hZCgpXG4gIH1cblxuICBhc3luYyBzYXZlICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkcmVzczogdGhpcy5fZGIuYWRkcmVzcy50b1N0cmluZygpLFxuICAgICAgZmlyc3RNb2RlcmF0b3I6IHRoaXMuX2ZpcnN0TW9kZXJhdG9yLFxuICAgICAgbWVtYmVyczogdGhpcy5fbWVtYmVyc1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdyYW50IChjYXBhYmlsaXR5LCBpZCkge1xuICAgIGlmICghdGhpcy5fZGIuYWNjZXNzLmlzVmFsaWRDYXBhYmlsaXR5KGNhcGFiaWxpdHkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dyYW50OiBJbnZhbGlkIGNhcGFiaWxpdHkgdG8gZ3JhbnQnKVxuICAgIH1cbiAgICBpZiAoY2FwYWJpbGl0eSA9PT0gTUVNQkVSICYmIHRoaXMuY2FwYWJpbGl0aWVzWydtZW1iZXJzJ10uaW5jbHVkZXMoaWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZ3JhbnQ6IGNhcGFiaWxpdHkgJHtjYXBhYmlsaXR5fSBoYXMgYWxyZWFkeSBiZWVuIGdyYW50ZWQgdG8gJHtpZH1gKVxuICAgIH1cbiAgICBpZiAoY2FwYWJpbGl0eSA9PT0gTU9ERVJBVE9SICYmIHRoaXMuY2FwYWJpbGl0aWVzWydtb2RlcmF0b3JzJ10uaW5jbHVkZXMoaWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZ3JhbnQ6IGNhcGFiaWxpdHkgJHtjYXBhYmlsaXR5fSBoYXMgYWxyZWFkeSBiZWVuIGdyYW50ZWQgdG8gJHtpZH1gKVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fZGIuYWRkKHtjYXBhYmlsaXR5LCBpZH0pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUudG9TdHJpbmcoKS5pbmNsdWRlcygnbm90IGFwcGVuZCBlbnRyeScpKSB0aHJvdyBuZXcgRXJyb3IoYGdyYW50OiBDYXBhYmlsaXR5ICR7Y2FwYWJpbGl0eX0gY2FuIG5vdCBiZSBncmFudGVkIHRvICR7aWR9YClcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH1cblxuICBfb25VcGRhdGUgKCkge1xuICAgIHRoaXMuX3VwZGF0ZUNhcGFiaWxpdGVzKClcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZWQnKVxuICB9XG5cbiAgLyogRmFjdG9yeSAqL1xuICBzdGF0aWMgYXN5bmMgY3JlYXRlIChvcmJpdGRiLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIW9wdGlvbnMuZmlyc3RNb2RlcmF0b3IpIHRocm93IG5ldyBFcnJvcignVGhyZWFkIEFDOiBmaXJzdE1vZGVyYXRvciByZXF1aXJlZCcpXG4gICAgY29uc3QgYWMgPSBuZXcgVGhyZWFkQWNjZXNzQ29udHJvbGxlcihvcmJpdGRiLCBvcmJpdGRiLl9pcGZzLCBvcHRpb25zLmlkZW50aXR5LCBvcHRpb25zLmZpcnN0TW9kZXJhdG9yLCBvcHRpb25zKVxuICAgIGF3YWl0IGFjLmxvYWQob3B0aW9ucy5hZGRyZXNzIHx8IG9wdGlvbnMudGhyZWFkTmFtZSlcbiAgICByZXR1cm4gYWNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRocmVhZEFjY2Vzc0NvbnRyb2xsZXJcbiIsImNvbnN0IGJhc2U2NHVybCA9IHJlcXVpcmUoJ2Jhc2U2NHVybCcpXG5jb25zdCB7IHZlcmlmeUpXVCB9ID0gcmVxdWlyZSgnZGlkLWp3dCcpXG5cbmNvbnN0IGVuY29kZVNlY3Rpb24gPSBkYXRhID0+IGJhc2U2NHVybC5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoZGF0YSkpXG5cbmNvbnN0IFRZUEUgPSAnM0lEJ1xuY29uc3QgSldUX0hFQURFUiA9IGVuY29kZVNlY3Rpb24oeyB0eXA6ICdKV1QnLCBhbGc6ICdFUzI1NksnIH0pXG5cblxuY2xhc3MgT2RiSWRlbnRpdHlQcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yICh7IHRocmVlSWQgfSkge1xuICAgIC8vIHN1cGVyKG9wdGlvbnMpXG4gICAgdGhpcy50aHJlZUlkID0gdGhyZWVJZFxuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJzNJRCdcbiAgfVxuXG4gIGFzeW5jIGdldElkICh7IHNwYWNlIH0pIHtcbiAgICBpZiAoc3BhY2UpIHtcbiAgICAgIHJldHVybiB0aGlzLnRocmVlSWQuZ2V0U3ViRElEKHNwYWNlKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy50aHJlZUlkLkRJRFxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHNpZ25JZGVudGl0eSAoZGF0YSwgeyBzcGFjZSB9KSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIGRhdGEsXG4gICAgICBpYXQ6IG51bGxcbiAgICB9XG4gICAgY29uc3Qgb3B0cyA9ICFzcGFjZSA/IHsgdXNlM0lEOiB0cnVlIH0gOiB7IHNwYWNlIH1cbiAgICByZXR1cm4gKGF3YWl0IHRoaXMudGhyZWVJZC5zaWduSldUKHBheWxvYWQsIG9wdHMpKS5zcGxpdCgnLicpWzJdXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgdmVyaWZ5SWRlbnRpdHkgKGlkZW50aXR5KSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IGVuY29kZVNlY3Rpb24oe1xuICAgICAgaWF0OiBudWxsLFxuICAgICAgZGF0YTogaWRlbnRpdHkucHVibGljS2V5ICsgaWRlbnRpdHkuc2lnbmF0dXJlcy5pZCxcbiAgICAgIGlzczogaWRlbnRpdHkuaWRcbiAgICB9KVxuICAgIGNvbnN0IGp3dCA9IGAke0pXVF9IRUFERVJ9LiR7cGF5bG9hZH0uJHtpZGVudGl0eS5zaWduYXR1cmVzLnB1YmxpY0tleX1gXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHZlcmlmeUpXVChqd3QsIHsgYXV0aDogdHJ1ZSB9KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9kYklkZW50aXR5UHJvdmlkZXJcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgZm9ybWF0ID0gcmVxdWlyZSgndXRpbCcpLmZvcm1hdDtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxubGV0IGlzRWxlY3Ryb25SZW5kZXJlciA9IHByb2Nlc3MudHlwZSAmJiBwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcic7XG5sZXQgaXNOb2RlanMgPSAhaXNFbGVjdHJvblJlbmRlcmVyICYmIHByb2Nlc3MudmVyc2lvbiA/IHRydWUgOiBmYWxzZTtcblxuY29uc3QgTG9nTGV2ZWxzID0ge1xuICAnREVCVUcnOiAnREVCVUcnLFxuICAnSU5GTyc6ICAnSU5GTycsXG4gICdXQVJOJzogICdXQVJOJyxcbiAgJ0VSUk9SJzogJ0VSUk9SJyxcbiAgJ05PTkUnOiAgJ05PTkUnLFxufTtcblxuLy8gR2xvYmFsIGxvZyBsZXZlbFxubGV0IEdsb2JhbExvZ0xldmVsID0gTG9nTGV2ZWxzLkRFQlVHO1xuXG4vLyBHbG9iYWwgbG9nIGZpbGUgbmFtZVxubGV0IEdsb2JhbExvZ2ZpbGUgPSBudWxsO1xuXG5sZXQgR2xvYmFsRXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4vLyBBTlNJIGNvbG9yc1xubGV0IENvbG9ycyA9IHtcbiAgJ0JsYWNrJzogICAwLFxuICAnUmVkJzogICAgIDEsXG4gICdHcmVlbic6ICAgMixcbiAgJ1llbGxvdyc6ICAzLFxuICAnQmx1ZSc6ICAgIDQsXG4gICdNYWdlbnRhJzogNSxcbiAgJ0N5YW4nOiAgICA2LFxuICAnR3JleSc6ICAgIDcsXG4gICdXaGl0ZSc6ICAgOSxcbiAgJ0RlZmF1bHQnOiA5LFxufTtcblxuLy8gQ1NTIGNvbG9yc1xuaWYoIWlzTm9kZWpzKSB7XG4gIENvbG9ycyA9IHtcbiAgICAnQmxhY2snOiAgICdCbGFjaycsXG4gICAgJ1JlZCc6ICAgICAnSW5kaWFuUmVkJyxcbiAgICAnR3JlZW4nOiAgICdMaW1lR3JlZW4nLFxuICAgICdZZWxsb3cnOiAgJ09yYW5nZScsXG4gICAgJ0JsdWUnOiAgICAnUm95YWxCbHVlJyxcbiAgICAnTWFnZW50YSc6ICdPcmNoaWQnLFxuICAgICdDeWFuJzogICAgJ1NreUJsdWUnLFxuICAgICdHcmV5JzogICAgJ0RpbUdyZXknLFxuICAgICdXaGl0ZSc6ICAgJ1doaXRlJyxcbiAgICAnRGVmYXVsdCc6ICdCbGFjaycsXG4gIH07XG59XG5cbmNvbnN0IGxvZ2xldmVsQ29sb3JzID0gW0NvbG9ycy5DeWFuLCBDb2xvcnMuR3JlZW4sIENvbG9ycy5ZZWxsb3csIENvbG9ycy5SZWQsIENvbG9ycy5EZWZhdWx0XTtcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHVzZUNvbG9yczogdHJ1ZSxcbiAgY29sb3I6IENvbG9ycy5EZWZhdWx0LFxuICBzaG93VGltZXN0YW1wOiB0cnVlLFxuICB1c2VMb2NhbFRpbWU6IGZhbHNlLFxuICBzaG93TGV2ZWw6IHRydWUsXG4gIGZpbGVuYW1lOiBHbG9iYWxMb2dmaWxlLFxuICBhcHBlbmRGaWxlOiB0cnVlLFxufTtcblxuY2xhc3MgTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoY2F0ZWdvcnksIG9wdGlvbnMpIHtcbiAgICB0aGlzLmNhdGVnb3J5ID0gY2F0ZWdvcnk7XG4gICAgbGV0IG9wdHMgPSB7fTtcbiAgICBPYmplY3QuYXNzaWduKG9wdHMsIGRlZmF1bHRPcHRpb25zKTtcbiAgICBPYmplY3QuYXNzaWduKG9wdHMsIG9wdGlvbnMpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdHM7XG4gICAgdGhpcy5kZWJ1ZyA9IHRoaXMuZGVidWcuYmluZCh0aGlzKTtcbiAgICB0aGlzLmxvZyA9IHRoaXMubG9nLmJpbmQodGhpcyk7XG4gICAgdGhpcy5pbmZvID0gdGhpcy5pbmZvLmJpbmQodGhpcyk7XG4gICAgdGhpcy53YXJuID0gdGhpcy53YXJuLmJpbmQodGhpcyk7XG4gICAgdGhpcy5lcnJvciA9IHRoaXMuZXJyb3IuYmluZCh0aGlzKTtcbiAgfVxuXG4gIGRlYnVnKCkge1xuICAgIGlmKHRoaXMuX3Nob3VsZExvZyhMb2dMZXZlbHMuREVCVUcpKVxuICAgICAgdGhpcy5fd3JpdGUoTG9nTGV2ZWxzLkRFQlVHLCBmb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gIH1cblxuICBsb2coKSB7XG4gICAgaWYodGhpcy5fc2hvdWxkTG9nKExvZ0xldmVscy5ERUJVRykpXG4gICAgICB0aGlzLmRlYnVnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpbmZvKCkge1xuICAgIGlmKHRoaXMuX3Nob3VsZExvZyhMb2dMZXZlbHMuSU5GTykpXG4gICAgICB0aGlzLl93cml0ZShMb2dMZXZlbHMuSU5GTywgZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgd2FybigpIHtcbiAgICBpZih0aGlzLl9zaG91bGRMb2coTG9nTGV2ZWxzLldBUk4pKVxuICAgICAgdGhpcy5fd3JpdGUoTG9nTGV2ZWxzLldBUk4sIGZvcm1hdC5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIGVycm9yKCkge1xuICAgIGlmKHRoaXMuX3Nob3VsZExvZyhMb2dMZXZlbHMuRVJST1IpKVxuICAgICAgdGhpcy5fd3JpdGUoTG9nTGV2ZWxzLkVSUk9SLCBmb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfd3JpdGUobGV2ZWwsIHRleHQpIHtcbiAgICBpZigodGhpcy5vcHRpb25zLmZpbGVuYW1lIHx8IEdsb2JhbExvZ2ZpbGUpICYmICF0aGlzLmZpbGVXcml0ZXIgJiYgaXNOb2RlanMpXG4gICAgICB0aGlzLmZpbGVXcml0ZXIgPSBmcy5vcGVuU3luYyh0aGlzLm9wdGlvbnMuZmlsZW5hbWUgfHwgR2xvYmFsTG9nZmlsZSwgdGhpcy5vcHRpb25zLmFwcGVuZEZpbGUgPyAnYSsnIDogJ3crJyk7XG5cbiAgICBsZXQgZm9ybWF0ID0gdGhpcy5fZm9ybWF0KGxldmVsLCB0ZXh0KTtcbiAgICBsZXQgdW5mb3JtYXR0ZWRUZXh0ID0gdGhpcy5fY3JlYXRlTG9nTWVzc2FnZShsZXZlbCwgdGV4dCk7XG4gICAgbGV0IGZvcm1hdHRlZFRleHQgPSB0aGlzLl9jcmVhdGVMb2dNZXNzYWdlKGxldmVsLCB0ZXh0LCBmb3JtYXQudGltZXN0YW1wLCBmb3JtYXQubGV2ZWwsIGZvcm1hdC5jYXRlZ29yeSwgZm9ybWF0LnRleHQpO1xuXG4gICAgaWYodGhpcy5maWxlV3JpdGVyICYmIGlzTm9kZWpzKVxuICAgICAgZnMud3JpdGVTeW5jKHRoaXMuZmlsZVdyaXRlciwgdW5mb3JtYXR0ZWRUZXh0ICsgJ1xcbicsIG51bGwsICd1dGYtOCcpO1xuXG4gICAgaWYoaXNOb2RlanMgfHwgIXRoaXMub3B0aW9ucy51c2VDb2xvcnMpIHtcbiAgICAgIGNvbnNvbGUubG9nKGZvcm1hdHRlZFRleHQpXG4gICAgICBHbG9iYWxFdmVudHMuZW1pdCgnZGF0YScsIHRoaXMuY2F0ZWdvcnksIGxldmVsLCB0ZXh0KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBjbGVhbiB0aGlzIHVwXG4gICAgICBpZihsZXZlbCA9PT0gTG9nTGV2ZWxzLkVSUk9SKSB7XG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5zaG93VGltZXN0YW1wICYmIHRoaXMub3B0aW9ucy5zaG93TGV2ZWwpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdHRlZFRleHQsIGZvcm1hdC50aW1lc3RhbXAsIGZvcm1hdC5sZXZlbCwgZm9ybWF0LmNhdGVnb3J5LCBmb3JtYXQudGV4dClcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMub3B0aW9ucy5zaG93VGltZXN0YW1wICYmICF0aGlzLm9wdGlvbnMuc2hvd0xldmVsKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXR0ZWRUZXh0LCBmb3JtYXQudGltZXN0YW1wLCBmb3JtYXQuY2F0ZWdvcnksIGZvcm1hdC50ZXh0KVxuICAgICAgICB9IGVsc2UgaWYoIXRoaXMub3B0aW9ucy5zaG93VGltZXN0YW1wICYmIHRoaXMub3B0aW9ucy5zaG93TGV2ZWwpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdHRlZFRleHQsIGZvcm1hdC5sZXZlbCwgZm9ybWF0LmNhdGVnb3J5LCBmb3JtYXQudGV4dClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdHRlZFRleHQsIGZvcm1hdC5jYXRlZ29yeSwgZm9ybWF0LnRleHQpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5zaG93VGltZXN0YW1wICYmIHRoaXMub3B0aW9ucy5zaG93TGV2ZWwpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhmb3JtYXR0ZWRUZXh0LCBmb3JtYXQudGltZXN0YW1wLCBmb3JtYXQubGV2ZWwsIGZvcm1hdC5jYXRlZ29yeSwgZm9ybWF0LnRleHQpXG4gICAgICAgIH0gZWxzZSBpZih0aGlzLm9wdGlvbnMuc2hvd1RpbWVzdGFtcCAmJiAhdGhpcy5vcHRpb25zLnNob3dMZXZlbCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGZvcm1hdHRlZFRleHQsIGZvcm1hdC50aW1lc3RhbXAsIGZvcm1hdC5jYXRlZ29yeSwgZm9ybWF0LnRleHQpXG4gICAgICAgIH0gZWxzZSBpZighdGhpcy5vcHRpb25zLnNob3dUaW1lc3RhbXAgJiYgdGhpcy5vcHRpb25zLnNob3dMZXZlbCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGZvcm1hdHRlZFRleHQsIGZvcm1hdC5sZXZlbCwgZm9ybWF0LmNhdGVnb3J5LCBmb3JtYXQudGV4dClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhmb3JtYXR0ZWRUZXh0LCBmb3JtYXQuY2F0ZWdvcnksIGZvcm1hdC50ZXh0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2Zvcm1hdChsZXZlbCwgdGV4dCkge1xuICAgIGxldCB0aW1lc3RhbXBGb3JtYXQgPSAnJztcbiAgICBsZXQgbGV2ZWxGb3JtYXQgICAgID0gJyc7XG4gICAgbGV0IGNhdGVnb3J5Rm9ybWF0ICA9ICcnO1xuICAgIGxldCB0ZXh0Rm9ybWF0ICAgICAgPSAnOiAnO1xuXG4gICAgaWYodGhpcy5vcHRpb25zLnVzZUNvbG9ycykge1xuICAgICAgICBjb25zdCBsZXZlbENvbG9yICAgID0gT2JqZWN0LmtleXMoTG9nTGV2ZWxzKS5tYXAoKGYpID0+IExvZ0xldmVsc1tmXSkuaW5kZXhPZihsZXZlbCk7XG4gICAgICAgIGNvbnN0IGNhdGVnb3J5Q29sb3IgPSB0aGlzLm9wdGlvbnMuY29sb3I7XG5cbiAgICAgIGlmKGlzTm9kZWpzKSB7XG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5zaG93VGltZXN0YW1wKVxuICAgICAgICAgIHRpbWVzdGFtcEZvcm1hdCA9ICdcXHUwMDFiWzMnICsgQ29sb3JzLkdyZXkgKyAnbSc7XG5cbiAgICAgICAgaWYodGhpcy5vcHRpb25zLnNob3dMZXZlbClcbiAgICAgICAgICBsZXZlbEZvcm1hdCA9ICdcXHUwMDFiWzMnICsgbG9nbGV2ZWxDb2xvcnNbbGV2ZWxDb2xvcl0gKyAnOzIybSc7XG5cbiAgICAgICAgY2F0ZWdvcnlGb3JtYXQgPSAnXFx1MDAxYlszJyArIGNhdGVnb3J5Q29sb3IgKyAnOzFtJztcbiAgICAgICAgdGV4dEZvcm1hdCA9ICdcXHUwMDFiWzBtOiAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYodGhpcy5vcHRpb25zLnNob3dUaW1lc3RhbXApXG4gICAgICAgICAgdGltZXN0YW1wRm9ybWF0ID0gJ2NvbG9yOicgKyBDb2xvcnMuR3JleTtcblxuICAgICAgICBpZih0aGlzLm9wdGlvbnMuc2hvd0xldmVsKVxuICAgICAgICAgIGxldmVsRm9ybWF0ID0gJ2NvbG9yOicgKyBsb2dsZXZlbENvbG9yc1tsZXZlbENvbG9yXTtcblxuICAgICAgICBjYXRlZ29yeUZvcm1hdCA9ICdjb2xvcjonICsgY2F0ZWdvcnlDb2xvciArICc7IGZvbnQtd2VpZ2h0OiBib2xkJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXBGb3JtYXQsXG4gICAgICBsZXZlbDogbGV2ZWxGb3JtYXQsXG4gICAgICBjYXRlZ29yeTogY2F0ZWdvcnlGb3JtYXQsXG4gICAgICB0ZXh0OiB0ZXh0Rm9ybWF0XG4gICAgfTtcbiAgfVxuXG4gIF9jcmVhdGVMb2dNZXNzYWdlKGxldmVsLCB0ZXh0LCB0aW1lc3RhbXBGb3JtYXQsIGxldmVsRm9ybWF0LCBjYXRlZ29yeUZvcm1hdCwgdGV4dEZvcm1hdCkge1xuICAgIHRpbWVzdGFtcEZvcm1hdCA9IHRpbWVzdGFtcEZvcm1hdCB8fCAnJztcbiAgICBsZXZlbEZvcm1hdCAgICAgPSBsZXZlbEZvcm1hdCAgICAgfHwgJyc7XG4gICAgY2F0ZWdvcnlGb3JtYXQgID0gY2F0ZWdvcnlGb3JtYXQgIHx8ICcnO1xuICAgIHRleHRGb3JtYXQgICAgICA9IHRleHRGb3JtYXQgICAgICB8fCAnOiAnO1xuXG4gICAgaWYoIWlzTm9kZWpzICYmIHRoaXMub3B0aW9ucy51c2VDb2xvcnMpIHtcbiAgICAgIGlmKHRoaXMub3B0aW9ucy5zaG93VGltZXN0YW1wKVxuICAgICAgICB0aW1lc3RhbXBGb3JtYXQgPSAnJWMnO1xuXG4gICAgICBpZih0aGlzLm9wdGlvbnMuc2hvd0xldmVsKVxuICAgICAgICBsZXZlbEZvcm1hdCA9ICclYyc7XG5cbiAgICAgIGNhdGVnb3J5Rm9ybWF0ICA9ICclYyc7XG4gICAgICB0ZXh0Rm9ybWF0ID0gJzogJWMnO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSAnJztcblxuICAgIGlmKHRoaXMub3B0aW9ucy5zaG93VGltZXN0YW1wICYmICF0aGlzLm9wdGlvbnMudXNlTG9jYWxUaW1lKVxuICAgICAgcmVzdWx0ICs9ICcnICsgbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgJyAnO1xuXG4gICAgaWYodGhpcy5vcHRpb25zLnNob3dUaW1lc3RhbXAgJiYgdGhpcy5vcHRpb25zLnVzZUxvY2FsVGltZSlcbiAgICAgIHJlc3VsdCArPSAnJyArIG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSArICcgJztcblxuICAgIHJlc3VsdCA9IHRpbWVzdGFtcEZvcm1hdCArIHJlc3VsdDtcblxuICAgIGlmKHRoaXMub3B0aW9ucy5zaG93TGV2ZWwpXG4gICAgICByZXN1bHQgKz0gbGV2ZWxGb3JtYXQgKyAnWycgKyBsZXZlbCArJ10nICsgKGxldmVsID09PSBMb2dMZXZlbHMuSU5GTyB8fCBsZXZlbCA9PT0gTG9nTGV2ZWxzLldBUk4gPyAnICcgOiAnJykgKyAnICc7XG5cbiAgICByZXN1bHQgKz0gY2F0ZWdvcnlGb3JtYXQgKyB0aGlzLmNhdGVnb3J5O1xuICAgIHJlc3VsdCArPSB0ZXh0Rm9ybWF0ICsgdGV4dDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgX3Nob3VsZExvZyhsZXZlbCkge1xuICAgIGxldCBlbnZMb2dMZXZlbCA9ICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudiAhPT0gdW5kZWZpbmVkICYmIHByb2Nlc3MuZW52LkxPRyAhPT0gdW5kZWZpbmVkKSA/IHByb2Nlc3MuZW52LkxPRy50b1VwcGVyQ2FzZSgpIDogbnVsbDtcbiAgICBlbnZMb2dMZXZlbCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5MT0cpID8gd2luZG93LkxPRy50b1VwcGVyQ2FzZSgpIDogZW52TG9nTGV2ZWw7XG5cbiAgICBjb25zdCBsb2dMZXZlbCA9IGVudkxvZ0xldmVsIHx8IEdsb2JhbExvZ0xldmVsO1xuICAgIGNvbnN0IGxldmVscyAgID0gT2JqZWN0LmtleXMoTG9nTGV2ZWxzKS5tYXAoKGYpID0+IExvZ0xldmVsc1tmXSk7XG4gICAgY29uc3QgaW5kZXggICAgPSBsZXZlbHMuaW5kZXhPZihsZXZlbCk7XG4gICAgY29uc3QgbGV2ZWxJZHggPSBsZXZlbHMuaW5kZXhPZihsb2dMZXZlbCk7XG4gICAgcmV0dXJuIGluZGV4ID49IGxldmVsSWR4O1xuICB9XG59O1xuXG4vKiBQdWJsaWMgQVBJICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ29sb3JzOiBDb2xvcnMsXG4gIExvZ0xldmVsczogTG9nTGV2ZWxzLFxuICBzZXRMb2dMZXZlbDogKGxldmVsKSA9PiB7XG4gICAgR2xvYmFsTG9nTGV2ZWwgPSBsZXZlbDtcbiAgfSxcbiAgc2V0TG9nZmlsZTogKGZpbGVuYW1lKSA9PiB7XG4gICAgR2xvYmFsTG9nZmlsZSA9IGZpbGVuYW1lO1xuICB9LFxuICBjcmVhdGU6IChjYXRlZ29yeSwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoY2F0ZWdvcnksIG9wdGlvbnMpO1xuICAgIHJldHVybiBsb2dnZXI7XG4gIH0sXG4gIGZvcmNlQnJvd3Nlck1vZGU6IChmb3JjZSkgPT4gaXNOb2RlanMgPSAhZm9yY2UsIC8vIGZvciB0ZXN0aW5nLFxuICBldmVudHM6IEdsb2JhbEV2ZW50cyxcbn07XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgRXZlbnRTdG9yZSA9IHJlcXVpcmUoJ29yYml0LWRiLWV2ZW50c3RvcmUnKVxuY29uc3QgRmVlZEluZGV4ICA9IHJlcXVpcmUoJy4vRmVlZEluZGV4JylcblxuY2xhc3MgRmVlZFN0b3JlIGV4dGVuZHMgRXZlbnRTdG9yZSB7XG4gIGNvbnN0cnVjdG9yIChpcGZzLCBpZCwgZGJuYW1lLCBvcHRpb25zKSB7XG4gICAgaWYoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fVxuICAgIGlmKCFvcHRpb25zLkluZGV4KSBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHsgSW5kZXg6IEZlZWRJbmRleCB9KVxuICAgIHN1cGVyKGlwZnMsIGlkLCBkYm5hbWUsIG9wdGlvbnMpXG4gICAgdGhpcy5fdHlwZSA9ICdmZWVkJ1xuICB9XG5cbiAgcmVtb3ZlIChoYXNoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVsKGhhc2gpXG4gIH1cblxuICBkZWwgKGhhc2gpIHtcbiAgICBjb25zdCBvcGVyYXRpb24gPSB7XG4gICAgICBvcDogJ0RFTCcsXG4gICAgICBrZXk6IG51bGwsXG4gICAgICB2YWx1ZTogaGFzaFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWRkT3BlcmF0aW9uKG9wZXJhdGlvbilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZlZWRTdG9yZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFN0b3JlID0gcmVxdWlyZSgnb3JiaXQtZGItc3RvcmUnKVxuY29uc3QgS2V5VmFsdWVJbmRleCA9IHJlcXVpcmUoJy4vS2V5VmFsdWVJbmRleCcpXG5cbmNsYXNzIEtleVZhbHVlU3RvcmUgZXh0ZW5kcyBTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKGlwZnMsIGlkLCBkYm5hbWUsIG9wdGlvbnMpIHtcbiAgICBsZXQgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHsgSW5kZXg6IEtleVZhbHVlSW5kZXggfSlcbiAgICBPYmplY3QuYXNzaWduKG9wdHMsIG9wdGlvbnMpXG4gICAgc3VwZXIoaXBmcywgaWQsIGRibmFtZSwgb3B0cylcbiAgICB0aGlzLl90eXBlID0gJ2tleXZhbHVlJ1xuICB9XG5cbiAgZ2V0IGFsbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4Ll9pbmRleFxuICB9XG5cbiAgZ2V0IChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kZXguZ2V0KGtleSlcbiAgfVxuXG4gIHNldCAoa2V5LCBkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMucHV0KGtleSwgZGF0YSlcbiAgfVxuXG4gIHB1dCAoa2V5LCBkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZE9wZXJhdGlvbih7XG4gICAgICBvcDogJ1BVVCcsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHZhbHVlOiBkYXRhXG4gICAgfSlcbiAgfVxuXG4gIGRlbCAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZE9wZXJhdGlvbih7XG4gICAgICBvcDogJ0RFTCcsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEtleVZhbHVlU3RvcmVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBTdG9yZSA9IHJlcXVpcmUoJ29yYml0LWRiLXN0b3JlJylcbmNvbnN0IERvY3VtZW50SW5kZXggPSByZXF1aXJlKCcuL0RvY3VtZW50SW5kZXgnKVxuY29uc3QgcE1hcCA9IHJlcXVpcmUoJ3AtbWFwJylcbmNvbnN0IFJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcblxuY29uc3QgcmVwbGFjZUFsbCA9IChzdHIsIHNlYXJjaCwgcmVwbGFjZW1lbnQpID0+IHN0ci50b1N0cmluZygpLnNwbGl0KHNlYXJjaCkuam9pbihyZXBsYWNlbWVudClcblxuY2xhc3MgRG9jdW1lbnRTdG9yZSBleHRlbmRzIFN0b3JlIHtcbiAgY29uc3RydWN0b3IgKGlwZnMsIGlkLCBkYm5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fVxuICAgIGlmICghb3B0aW9ucy5pbmRleEJ5KSBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHsgaW5kZXhCeTogJ19pZCcgfSlcbiAgICBpZiAoIW9wdGlvbnMuSW5kZXgpIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgeyBJbmRleDogRG9jdW1lbnRJbmRleCB9KVxuICAgIHN1cGVyKGlwZnMsIGlkLCBkYm5hbWUsIG9wdGlvbnMpXG4gICAgdGhpcy5fdHlwZSA9ICdkb2NzdG9yZSdcbiAgfVxuXG4gIGdldCAoa2V5LCBjYXNlU2Vuc2l0aXZlID0gZmFsc2UpIHtcbiAgICBrZXkgPSBrZXkudG9TdHJpbmcoKVxuICAgIGNvbnN0IHRlcm1zID0ga2V5LnNwbGl0KCcgJylcbiAgICBrZXkgPSB0ZXJtcy5sZW5ndGggPiAxID8gcmVwbGFjZUFsbChrZXksICcuJywgJyAnKS50b0xvd2VyQ2FzZSgpIDoga2V5LnRvTG93ZXJDYXNlKClcblxuICAgIGNvbnN0IHNlYXJjaCA9IChlKSA9PiB7XG4gICAgICBpZiAodGVybXMubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm4gcmVwbGFjZUFsbChlLCAnLicsICcgJykudG9Mb3dlckNhc2UoKS5pbmRleE9mKGtleSkgIT09IC0xXG4gICAgICB9XG4gICAgICByZXR1cm4gZS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoa2V5KSAhPT0gLTFcbiAgICB9XG4gICAgY29uc3QgbWFwcGVyID0gZSA9PiB0aGlzLl9pbmRleC5nZXQoZSlcbiAgICBjb25zdCBmaWx0ZXIgPSBlID0+IGNhc2VTZW5zaXRpdmVcbiAgICAgID8gZS5pbmRleE9mKGtleSkgIT09IC0xIFxuICAgICAgOiBzZWFyY2goZSlcblxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9pbmRleC5faW5kZXgpXG4gICAgICAuZmlsdGVyKGZpbHRlcilcbiAgICAgIC5tYXAobWFwcGVyKVxuICB9XG5cbiAgcXVlcnkgKG1hcHBlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gV2hldGhlciB3ZSByZXR1cm4gdGhlIGZ1bGwgb3BlcmF0aW9uIGRhdGEgb3IganVzdCB0aGUgZGIgdmFsdWVcbiAgICBjb25zdCBmdWxsT3AgPSBvcHRpb25zLmZ1bGxPcCB8fCBmYWxzZVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2luZGV4Ll9pbmRleClcbiAgICAgIC5tYXAoKGUpID0+IHRoaXMuX2luZGV4LmdldChlLCBmdWxsT3ApKVxuICAgICAgLmZpbHRlcihtYXBwZXIpXG4gIH1cblxuICBiYXRjaFB1dCAoZG9jcywgb25Qcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgY29uc3QgbWFwcGVyID0gKGRvYywgaWR4KSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkT3BlcmF0aW9uQmF0Y2goXG4gICAgICAgIHtcbiAgICAgICAgICBvcDogJ1BVVCcsXG4gICAgICAgICAga2V5OiBkb2NbdGhpcy5vcHRpb25zLmluZGV4QnldLFxuICAgICAgICAgIHZhbHVlOiBkb2NcbiAgICAgICAgfSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgaWR4ID09PSBkb2NzLmxlbmd0aCAtIDEsXG4gICAgICAgIG9uUHJvZ3Jlc3NDYWxsYmFja1xuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiBwTWFwKGRvY3MsIG1hcHBlciwgeyBjb25jdXJyZW5jeTogMSB9KVxuICAgICAgLnRoZW4oKCkgPT4gdGhpcy5zYXZlU25hcHNob3QoKSlcbiAgfVxuXG4gIHB1dCAoZG9jKSB7XG4gICAgaWYgKCFkb2NbdGhpcy5vcHRpb25zLmluZGV4QnldKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgcHJvdmlkZWQgZG9jdW1lbnQgZG9lc24ndCBjb250YWluIGZpZWxkICcke3RoaXMub3B0aW9ucy5pbmRleEJ5fSdgKVxuXG4gICAgcmV0dXJuIHRoaXMuX2FkZE9wZXJhdGlvbih7XG4gICAgICBvcDogJ1BVVCcsXG4gICAgICBrZXk6IGRvY1t0aGlzLm9wdGlvbnMuaW5kZXhCeV0sXG4gICAgICB2YWx1ZTogZG9jXG4gICAgfSlcbiAgfVxuXG4gIGRlbCAoa2V5KSB7XG4gICAgaWYgKCF0aGlzLl9pbmRleC5nZXQoa2V5KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZW50cnkgd2l0aCBrZXkgJyR7a2V5fScgaW4gdGhlIGRhdGFiYXNlYClcblxuICAgIHJldHVybiB0aGlzLl9hZGRPcGVyYXRpb24oe1xuICAgICAgb3A6ICdERUwnLFxuICAgICAga2V5OiBrZXksXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEb2N1bWVudFN0b3JlIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGlzRGVmaW5lZCA9IHJlcXVpcmUoJy4vaXMtZGVmaW5lZCcpXG5jb25zdCBpbyA9IHJlcXVpcmUoJ29yYml0LWRiLWlvJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzRGVmaW5lZCxcbiAgaW9cbn1cbiIsImNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGlvID0gcmVxdWlyZSgnb3JiaXQtZGItaW8nKVxuXG4vLyBDcmVhdGVzIGEgREIgbWFuaWZlc3QgZmlsZSBhbmQgc2F2ZXMgaXQgaW4gSVBGU1xuY29uc3QgY3JlYXRlREJNYW5pZmVzdCA9IGFzeW5jIChpcGZzLCBuYW1lLCB0eXBlLCBhY2Nlc3NDb250cm9sbGVyQWRkcmVzcywgb3B0aW9ucykgPT4ge1xuICBjb25zdCBtYW5pZmVzdCA9IHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgYWNjZXNzQ29udHJvbGxlcjogcGF0aC5qb2luKCcvaXBmcycsIGFjY2Vzc0NvbnRyb2xsZXJBZGRyZXNzKSxcbiAgfVxuXG4gIHJldHVybiBpby53cml0ZShpcGZzLCBvcHRpb25zLmZvcm1hdCB8fCAnZGFnLWNib3InLCBtYW5pZmVzdCwgb3B0aW9ucylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEQk1hbmlmZXN0XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgU3RvcmUgPSByZXF1aXJlKCdvcmJpdC1kYi1zdG9yZScpXG5jb25zdCBDb3VudGVySW5kZXggPSByZXF1aXJlKCcuL0NvdW50ZXJJbmRleCcpXG5jb25zdCBDb3VudGVyID0gcmVxdWlyZSgnY3JkdHMvc3JjL0ctQ291bnRlcicpXG5cbmNsYXNzIENvdW50ZXJTdG9yZSBleHRlbmRzIFN0b3JlIHtcbiAgY29uc3RydWN0b3IoaXBmcywgaWQsIGRibmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYoIW9wdGlvbnMuSW5kZXgpIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgeyBJbmRleDogQ291bnRlckluZGV4IH0pXG4gICAgc3VwZXIoaXBmcywgaWQsIGRibmFtZSwgb3B0aW9ucylcbiAgICB0aGlzLl90eXBlID0gJ2NvdW50ZXInXG4gIH1cblxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4LmdldCgpLnZhbHVlXG4gIH1cblxuICBpbmMoYW1vdW50KSB7XG4gICAgY29uc3QgY291bnRlciA9IG5ldyBDb3VudGVyKHRoaXMuaWRlbnRpdHkucHVibGljS2V5LCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9pbmRleC5nZXQoKS5fY291bnRlcnMpKVxuICAgIGNvdW50ZXIuaW5jcmVtZW50KGFtb3VudClcbiAgICByZXR1cm4gdGhpcy5fYWRkT3BlcmF0aW9uKHtcbiAgICAgIG9wOiAnQ09VTlRFUicsXG4gICAgICBrZXk6IG51bGwsXG4gICAgICB2YWx1ZTogY291bnRlci50b0pTT04oKSxcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ291bnRlclN0b3JlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQ2hhbm5lbCA9IHJlcXVpcmUoJ2lwZnMtcHVic3ViLTFvbjEnKVxuXG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCdsb2dwbGVhc2UnKVxuY29uc3QgbG9nZ2VyID0gTG9nZ2VyLmNyZWF0ZShcImV4Y2hhbmdlLWhlYWRzXCIsIHsgY29sb3I6IExvZ2dlci5Db2xvcnMuWWVsbG93IH0pXG5Mb2dnZXIuc2V0TG9nTGV2ZWwoJ0VSUk9SJylcblxuY29uc3QgZ2V0SGVhZHNGb3JEYXRhYmFzZSA9IHN0b3JlID0+IChzdG9yZSAmJiBzdG9yZS5fb3Bsb2cpID8gc3RvcmUuX29wbG9nLmhlYWRzIDogW11cblxuY29uc3QgZXhjaGFuZ2VIZWFkcyA9IGFzeW5jIChpcGZzLCBhZGRyZXNzLCBwZWVyLCBnZXRTdG9yZSwgZ2V0RGlyZWN0Q29ubmVjdGlvbiwgb25NZXNzYWdlLCBvbkNoYW5uZWxDcmVhdGVkKSA9PiB7XG4gIGNvbnN0IF9oYW5kbGVNZXNzYWdlID0gbWVzc2FnZSA9PiB7XG4gICAgY29uc3QgbXNnID0gSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpXG4gICAgY29uc3QgeyBhZGRyZXNzLCBoZWFkcyB9ID0gbXNnXG4gICAgb25NZXNzYWdlKGFkZHJlc3MsIGhlYWRzKVxuICB9XG5cbiAgbGV0IGNoYW5uZWwgPSBnZXREaXJlY3RDb25uZWN0aW9uKHBlZXIpXG4gIGlmICghY2hhbm5lbCkge1xuICAgIHRyeSB7XG4gICAgICBsb2dnZXIuZGVidWcoYENyZWF0ZSBhIGNoYW5uZWwgdG8gJHtwZWVyfWApXG4gICAgICBjaGFubmVsID0gYXdhaXQgQ2hhbm5lbC5vcGVuKGlwZnMsIHBlZXIpXG4gICAgICBjaGFubmVsLm9uKCdtZXNzYWdlJywgX2hhbmRsZU1lc3NhZ2UpXG4gICAgICBsb2dnZXIuZGVidWcoYENoYW5uZWwgY3JlYXRlZCB0byAke3BlZXJ9YClcbiAgICAgIG9uQ2hhbm5lbENyZWF0ZWQoY2hhbm5lbClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoZSlcbiAgICB9XG4gIH1cblxuICAvLyBXYWl0IGZvciB0aGUgZGlyZWN0IGNoYW5uZWwgdG8gYmUgZnVsbHkgY29ubmVjdGVkXG4gIGF3YWl0IGNoYW5uZWwuY29ubmVjdCgpXG4gIGxvZ2dlci5kZWJ1ZyhgQ29ubmVjdGVkIHRvICR7cGVlcn1gKVxuXG4gIC8vIFNlbmQgdGhlIGhlYWRzIGlmIHdlIGhhdmUgYW55XG4gIGNvbnN0IGhlYWRzID0gZ2V0SGVhZHNGb3JEYXRhYmFzZShnZXRTdG9yZShhZGRyZXNzKSlcbiAgbG9nZ2VyLmRlYnVnKGBTZW5kIGxhdGVzdCBoZWFkcyBvZiAnJHthZGRyZXNzfSc6XFxuYCwgSlNPTi5zdHJpbmdpZnkoaGVhZHMubWFwKGUgPT4gZS5oYXNoKSwgbnVsbCwgMikpXG4gIGlmIChoZWFkcykge1xuICAgIGF3YWl0IGNoYW5uZWwuc2VuZChKU09OLnN0cmluZ2lmeSh7IGFkZHJlc3M6IGFkZHJlc3MsIGhlYWRzOiBoZWFkcyB9KSlcbiAgfVxuXG4gIHJldHVybiBjaGFubmVsXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhjaGFuZ2VIZWFkc1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFN0b3JlID0gcmVxdWlyZSgnb3JiaXQtZGItc3RvcmUnKVxuY29uc3QgRXZlbnRJbmRleCA9IHJlcXVpcmUoJy4vRXZlbnRJbmRleCcpXG5cbi8vIFRPRE86IGdlbmVyYWxpemUgdGhlIEl0ZXJhdG9yIGZ1bmN0aW9ucyBhbmQgc3BpbiB0byBpdHMgb3duIG1vZHVsZVxuXG5jbGFzcyBFdmVudFN0b3JlIGV4dGVuZHMgU3RvcmUge1xuICBjb25zdHJ1Y3RvciAoaXBmcywgaWQsIGRibmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMuSW5kZXggPT09IHVuZGVmaW5lZCkgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7IEluZGV4OiBFdmVudEluZGV4IH0pXG4gICAgc3VwZXIoaXBmcywgaWQsIGRibmFtZSwgb3B0aW9ucylcbiAgICB0aGlzLl90eXBlID0gJ2V2ZW50bG9nJ1xuICB9XG5cbiAgYWRkIChkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZE9wZXJhdGlvbih7XG4gICAgICBvcDogJ0FERCcsXG4gICAgICBrZXk6IG51bGwsXG4gICAgICB2YWx1ZTogZGF0YVxuICAgIH0pXG4gIH1cblxuICBnZXQgKGhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVyYXRvcih7IGd0ZTogaGFzaCwgbGltaXQ6IDEgfSkuY29sbGVjdCgpWzBdXG4gIH1cblxuICBpdGVyYXRvciAob3B0aW9ucykge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gdGhpcy5fcXVlcnkob3B0aW9ucylcbiAgICBsZXQgY3VycmVudEluZGV4ID0gMFxuICAgIGxldCBpdGVyYXRvciA9IHtcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0sXG4gICAgICBuZXh0ICgpIHtcbiAgICAgICAgbGV0IGl0ZW0gPSB7IHZhbHVlOiBudWxsLCBkb25lOiB0cnVlIH1cbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA8IG1lc3NhZ2VzLmxlbmd0aCkge1xuICAgICAgICAgIGl0ZW0gPSB7IHZhbHVlOiBtZXNzYWdlc1tjdXJyZW50SW5kZXhdLCBkb25lOiBmYWxzZSB9XG4gICAgICAgICAgY3VycmVudEluZGV4KytcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgfSxcbiAgICAgIGNvbGxlY3Q6ICgpID0+IG1lc3NhZ2VzXG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBfcXVlcnkgKG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuXG4gICAgY29uc3QgYW1vdW50ID0gb3B0cy5saW1pdCA/IChvcHRzLmxpbWl0ID4gLTEgPyBvcHRzLmxpbWl0IDogdGhpcy5faW5kZXguZ2V0KCkubGVuZ3RoKSA6IDEgLy8gUmV0dXJuIDEgaWYgbm8gbGltaXQgaXMgcHJvdmlkZWRcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLl9pbmRleC5nZXQoKS5zbGljZSgpXG4gICAgbGV0IHJlc3VsdCA9IFtdXG5cbiAgICBpZiAob3B0cy5ndCB8fCBvcHRzLmd0ZSkge1xuICAgICAgLy8gR3JlYXRlciB0aGFuIGNhc2VcbiAgICAgIHJlc3VsdCA9IHRoaXMuX3JlYWQoZXZlbnRzLCBvcHRzLmd0ID8gb3B0cy5ndCA6IG9wdHMuZ3RlLCBhbW91bnQsICEhb3B0cy5ndGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExvd2VyIHRoYW4gYW5kIGxhc3ROIGNhc2UsIHNlYXJjaCBsYXRlc3QgZmlyc3QgYnkgcmV2ZXJzaW5nIHRoZSBzZXF1ZW5jZVxuICAgICAgcmVzdWx0ID0gdGhpcy5fcmVhZChldmVudHMucmV2ZXJzZSgpLCBvcHRzLmx0ID8gb3B0cy5sdCA6IG9wdHMubHRlLCBhbW91bnQsIG9wdHMubHRlIHx8ICFvcHRzLmx0KS5yZXZlcnNlKClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBfcmVhZCAob3BzLCBoYXNoLCBhbW91bnQsIGluY2x1c2l2ZSkge1xuICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBndC9sdCBoYXNoLCBvciBzdGFydCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGlmIG5vdCBmb3VuZFxuICAgIGNvbnN0IGluZGV4ID0gb3BzLm1hcCgoZSkgPT4gZS5oYXNoKS5pbmRleE9mKGhhc2gpXG4gICAgbGV0IHN0YXJ0SW5kZXggPSBNYXRoLm1heChpbmRleCwgMClcbiAgICAvLyBJZiBndGUvbHRlIGlzIHNldCwgd2UgaW5jbHVkZSB0aGUgZ2l2ZW4gaGFzaCwgaWYgbm90LCBzdGFydCBmcm9tIHRoZSBuZXh0IGVsZW1lbnRcbiAgICBzdGFydEluZGV4ICs9IGluY2x1c2l2ZSA/IDAgOiAxXG4gICAgLy8gU2xpY2UgdGhlIGFycmF5IHRvIGl0cyByZXF1ZXN0ZWQgc2l6ZVxuICAgIGNvbnN0IHJlcyA9IG9wcy5zbGljZShzdGFydEluZGV4KS5zbGljZSgwLCBhbW91bnQpXG4gICAgcmV0dXJuIHJlc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRTdG9yZVxuIiwiY29uc3QgbGV2ZWwgPSByZXF1aXJlKCdsZXZlbC1qcycpXG5jb25zdCBDYWNoZSA9IHJlcXVpcmUoJy4vQ2FjaGUnKVxubW9kdWxlLmV4cG9ydHMgPSBDYWNoZShsZXZlbClcbiIsImNvbnN0IGxldmVsID0gcmVxdWlyZSgnbGV2ZWwtanMnKVxuY29uc3QgS2V5c3RvcmUgPSByZXF1aXJlKCcuL3NyYy9rZXlzdG9yZScpXG5tb2R1bGUuZXhwb3J0cyA9IEtleXN0b3JlKGxldmVsKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJhc2U1OCA9IHJlcXVpcmUoJ2JzNTgnKVxuY29uc3QgbXVsdGloYXNoID0gcmVxdWlyZSgnbXVsdGloYXNoZXMnKVxuY29uc3QgbXVsdGliYXNlID0gcmVxdWlyZSgnbXVsdGliYXNlJylcbmNvbnN0IE11bHRpYWRkciA9IHJlcXVpcmUoJ211bHRpYWRkcicpXG5jb25zdCBtYWZtdCA9IHJlcXVpcmUoJ21hZm10JylcbmNvbnN0IENJRCA9IHJlcXVpcmUoJ2NpZHMnKVxuXG5jb25zdCB1cmxQYXR0ZXJuID0gL15odHRwcz86XFwvXFwvW14vXStcXC8oaXAoZnxuKXMpXFwvKChcXHcrKS4qKS9cbmNvbnN0IHBhdGhQYXR0ZXJuID0gL15cXC8oaXAoZnxuKXMpXFwvKChcXHcrKS4qKS9cbmNvbnN0IGRlZmF1bHRQcm90b2NvbE1hdGNoID0gMVxuY29uc3QgZGVmYXVsdEhhc2hNYXRoID0gNFxuXG5jb25zdCBmcWRuUGF0dGVybiA9IC9eaHR0cHM/OlxcL1xcLyhbXi9dKylcXC4oaXAoPzpmfG4pcylcXC5bXi9dKy9cbmNvbnN0IGZxZG5IYXNoTWF0Y2ggPSAxXG5jb25zdCBmcWRuUHJvdG9jb2xNYXRjaCA9IDJcblxuZnVuY3Rpb24gaXNNdWx0aWhhc2ggKGhhc2gpIHtcbiAgY29uc3QgZm9ybWF0dGVkID0gY29udmVydFRvU3RyaW5nKGhhc2gpXG4gIHRyeSB7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oYmFzZTU4LmRlY29kZShmb3JtYXR0ZWQpKVxuICAgIG11bHRpaGFzaC5kZWNvZGUoYnVmZmVyKVxuICAgIHJldHVybiB0cnVlXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBpc011bHRpYmFzZSAoaGFzaCkge1xuICB0cnkge1xuICAgIHJldHVybiBtdWx0aWJhc2UuaXNFbmNvZGVkKGhhc2gpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NJRCAoaGFzaCkge1xuICB0cnkge1xuICAgIG5ldyBDSUQoaGFzaCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNNdWx0aWFkZHIgKGlucHV0KSB7XG4gIGlmICghaW5wdXQpIHJldHVybiBmYWxzZVxuICBpZiAoTXVsdGlhZGRyLmlzTXVsdGlhZGRyKGlucHV0KSkgcmV0dXJuIHRydWVcbiAgdHJ5IHtcbiAgICBuZXcgTXVsdGlhZGRyKGlucHV0KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIHJldHVybiB0cnVlXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1BlZXJNdWx0aWFkZHIgKGlucHV0KSB7XG4gIHJldHVybiBpc011bHRpYWRkcihpbnB1dCkgJiYgbWFmbXQuSVBGUy5tYXRjaGVzKGlucHV0KVxufVxuXG5mdW5jdGlvbiBpc0lwZnMgKGlucHV0LCBwYXR0ZXJuLCBwcm90b2NvbE1hdGNoID0gZGVmYXVsdFByb3RvY29sTWF0Y2gsIGhhc2hNYXRjaCA9IGRlZmF1bHRIYXNoTWF0aCkge1xuICBjb25zdCBmb3JtYXR0ZWQgPSBjb252ZXJ0VG9TdHJpbmcoaW5wdXQpXG4gIGlmICghZm9ybWF0dGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBtYXRjaCA9IGZvcm1hdHRlZC5tYXRjaChwYXR0ZXJuKVxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAobWF0Y2hbcHJvdG9jb2xNYXRjaF0gIT09ICdpcGZzJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgbGV0IGhhc2ggPSBtYXRjaFtoYXNoTWF0Y2hdXG5cbiAgaWYgKGhhc2ggJiYgcGF0dGVybiA9PT0gZnFkblBhdHRlcm4pIHtcbiAgICAvLyB3aGVuIGRvaW5nIGNoZWNrcyBmb3Igc3ViZG9tYWluIGNvbnRleHRcbiAgICAvLyBlbnN1cmUgaGFzaCBpcyBjYXNlLWluc2Vuc2l0aXZlXG4gICAgLy8gKGJyb3dzZXJzIGZvcmNlLWxvd2VyY2FzZSBhdXRob3JpdHkgY29tcG90ZW50IGFueXdheSlcbiAgICBoYXNoID0gaGFzaC50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICByZXR1cm4gaXNDSUQoaGFzaClcbn1cblxuZnVuY3Rpb24gaXNJcG5zIChpbnB1dCwgcGF0dGVybiwgcHJvdG9jb2xNYXRjaCA9IGRlZmF1bHRQcm90b2NvbE1hdGNoLCBoYXNoTWF0Y2gpIHtcbiAgY29uc3QgZm9ybWF0dGVkID0gY29udmVydFRvU3RyaW5nKGlucHV0KVxuICBpZiAoIWZvcm1hdHRlZCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGNvbnN0IG1hdGNoID0gZm9ybWF0dGVkLm1hdGNoKHBhdHRlcm4pXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChtYXRjaFtwcm90b2NvbE1hdGNoXSAhPT0gJ2lwbnMnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoaGFzaE1hdGNoICYmIHBhdHRlcm4gPT09IGZxZG5QYXR0ZXJuKSB7XG4gICAgbGV0IGhhc2ggPSBtYXRjaFtoYXNoTWF0Y2hdXG4gICAgLy8gd2hlbiBkb2luZyBjaGVja3MgZm9yIHN1YmRvbWFpbiBjb250ZXh0XG4gICAgLy8gZW5zdXJlIGhhc2ggaXMgY2FzZS1pbnNlbnNpdGl2ZVxuICAgIC8vIChicm93c2VycyBmb3JjZS1sb3dlcmNhc2UgYXV0aG9yaXR5IGNvbXBvdGVudCBhbnl3YXkpXG4gICAgaGFzaCA9IGhhc2gudG9Mb3dlckNhc2UoKVxuICAgIHJldHVybiBpc0NJRChoYXNoKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcgKGlucHV0KSB7XG4gIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUb1N0cmluZyAoaW5wdXQpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICByZXR1cm4gYmFzZTU4LmVuY29kZShpbnB1dClcbiAgfVxuXG4gIGlmIChpc1N0cmluZyhpbnB1dCkpIHtcbiAgICByZXR1cm4gaW5wdXRcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5jb25zdCBpcGZzU3ViZG9tYWluID0gKHVybCkgPT4gaXNJcGZzKHVybCwgZnFkblBhdHRlcm4sIGZxZG5Qcm90b2NvbE1hdGNoLCBmcWRuSGFzaE1hdGNoKVxuY29uc3QgaXBuc1N1YmRvbWFpbiA9ICh1cmwpID0+IGlzSXBucyh1cmwsIGZxZG5QYXR0ZXJuLCBmcWRuUHJvdG9jb2xNYXRjaCwgZnFkbkhhc2hNYXRjaClcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG11bHRpaGFzaDogaXNNdWx0aWhhc2gsXG4gIG11bHRpYWRkcjogaXNNdWx0aWFkZHIsXG4gIHBlZXJNdWx0aWFkZHI6IGlzUGVlck11bHRpYWRkcixcbiAgY2lkOiBpc0NJRCxcbiAgYmFzZTMyY2lkOiAoY2lkKSA9PiAoaXNNdWx0aWJhc2UoY2lkKSA9PT0gJ2Jhc2UzMicgJiYgaXNDSUQoY2lkKSksXG4gIGlwZnNTdWJkb21haW46IGlwZnNTdWJkb21haW4sXG4gIGlwbnNTdWJkb21haW46IGlwbnNTdWJkb21haW4sXG4gIHN1YmRvbWFpbjogKHVybCkgPT4gKGlwZnNTdWJkb21haW4odXJsKSB8fCBpcG5zU3ViZG9tYWluKHVybCkpLFxuICBzdWJkb21haW5QYXR0ZXJuOiBmcWRuUGF0dGVybixcbiAgaXBmc1VybDogKHVybCkgPT4gaXNJcGZzKHVybCwgdXJsUGF0dGVybiksXG4gIGlwbnNVcmw6ICh1cmwpID0+IGlzSXBucyh1cmwsIHVybFBhdHRlcm4pLFxuICB1cmw6ICh1cmwpID0+IChpc0lwZnModXJsLCB1cmxQYXR0ZXJuKSB8fCBpc0lwbnModXJsLCB1cmxQYXR0ZXJuKSksXG4gIHVybFBhdHRlcm46IHVybFBhdHRlcm4sXG4gIGlwZnNQYXRoOiAocGF0aCkgPT4gaXNJcGZzKHBhdGgsIHBhdGhQYXR0ZXJuKSxcbiAgaXBuc1BhdGg6IChwYXRoKSA9PiBpc0lwbnMocGF0aCwgcGF0aFBhdHRlcm4pLFxuICBwYXRoOiAocGF0aCkgPT4gKGlzSXBmcyhwYXRoLCBwYXRoUGF0dGVybikgfHwgaXNJcG5zKHBhdGgsIHBhdGhQYXR0ZXJuKSksXG4gIHBhdGhQYXR0ZXJuOiBwYXRoUGF0dGVybixcbiAgdXJsT3JQYXRoOiAoeCkgPT4gKGlzSXBmcyh4LCB1cmxQYXR0ZXJuKSB8fCBpc0lwbnMoeCwgdXJsUGF0dGVybikgfHwgaXNJcGZzKHgsIHBhdGhQYXR0ZXJuKSB8fCBpc0lwbnMoeCwgcGF0aFBhdHRlcm4pKSxcbiAgY2lkUGF0aDogcGF0aCA9PiBpc1N0cmluZyhwYXRoKSAmJiAhaXNDSUQocGF0aCkgJiYgaXNJcGZzKGAvaXBmcy8ke3BhdGh9YCwgcGF0aFBhdHRlcm4pXG59XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBpc09wdGlvbk9iamVjdCA9IHJlcXVpcmUoJ2lzLXBsYWluLW9iaicpO1xuXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5jb25zdCBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuY29uc3QgZGVmaW5lUHJvcGVydHkgPSAob2JqLCBuYW1lLCB2YWx1ZSkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwge1xuXHR2YWx1ZSxcblx0d3JpdGFibGU6IHRydWUsXG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbmNvbnN0IGdsb2JhbFRoaXMgPSB0aGlzO1xuY29uc3QgZGVmYXVsdE1lcmdlT3B0cyA9IHtcblx0Y29uY2F0QXJyYXlzOiBmYWxzZVxufTtcblxuY29uc3QgZ2V0RW51bWVyYWJsZU93blByb3BlcnR5S2V5cyA9IHZhbHVlID0+IHtcblx0Y29uc3Qga2V5cyA9IFtdO1xuXG5cdGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG5cdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcblx0XHRcdGtleXMucHVzaChrZXkpO1xuXHRcdH1cblx0fVxuXG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xuXHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdGNvbnN0IHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbHVlKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0a2V5cy5wdXNoKHN5bWJvbHNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBrZXlzO1xufTtcblxuZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcblx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0cmV0dXJuIGNsb25lQXJyYXkodmFsdWUpO1xuXHR9XG5cblx0aWYgKGlzT3B0aW9uT2JqZWN0KHZhbHVlKSkge1xuXHRcdHJldHVybiBjbG9uZU9wdGlvbk9iamVjdCh2YWx1ZSk7XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNsb25lQXJyYXkoYXJyYXkpIHtcblx0Y29uc3QgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgMCk7XG5cblx0Z2V0RW51bWVyYWJsZU93blByb3BlcnR5S2V5cyhhcnJheSkuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGRlZmluZVByb3BlcnR5KHJlc3VsdCwga2V5LCBjbG9uZShhcnJheVtrZXldKSk7XG5cdH0pO1xuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNsb25lT3B0aW9uT2JqZWN0KG9iaikge1xuXHRjb25zdCByZXN1bHQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcblxuXHRnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlLZXlzKG9iaikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGRlZmluZVByb3BlcnR5KHJlc3VsdCwga2V5LCBjbG9uZShvYmpba2V5XSkpO1xuXHR9KTtcblxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBwYXJhbSBtZXJnZWQge2FscmVhZHkgY2xvbmVkfVxuICogQHJldHVybiB7Y2xvbmVkIE9iamVjdH1cbiAqL1xuY29uc3QgbWVyZ2VLZXlzID0gKG1lcmdlZCwgc291cmNlLCBrZXlzLCBtZXJnZU9wdHMpID0+IHtcblx0a2V5cy5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Ly8gRG8gbm90IHJlY3Vyc2UgaW50byBwcm90b3R5cGUgY2hhaW4gb2YgbWVyZ2VkXG5cdFx0aWYgKGtleSBpbiBtZXJnZWQgJiYgbWVyZ2VkW2tleV0gIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZihtZXJnZWQpKSB7XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eShtZXJnZWQsIGtleSwgbWVyZ2UobWVyZ2VkW2tleV0sIHNvdXJjZVtrZXldLCBtZXJnZU9wdHMpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkobWVyZ2VkLCBrZXksIGNsb25lKHNvdXJjZVtrZXldKSk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gbWVyZ2VkO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gbWVyZ2VkIHthbHJlYWR5IGNsb25lZH1cbiAqIEByZXR1cm4ge2Nsb25lZCBPYmplY3R9XG4gKlxuICogc2VlIFtBcnJheS5wcm90b3R5cGUuY29uY2F0ICggLi4uYXJndW1lbnRzICldKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1hcnJheS5wcm90b3R5cGUuY29uY2F0KVxuICovXG5jb25zdCBjb25jYXRBcnJheXMgPSAobWVyZ2VkLCBzb3VyY2UsIG1lcmdlT3B0cykgPT4ge1xuXHRsZXQgcmVzdWx0ID0gbWVyZ2VkLnNsaWNlKDAsIDApO1xuXHRsZXQgcmVzdWx0SW5kZXggPSAwO1xuXG5cdFttZXJnZWQsIHNvdXJjZV0uZm9yRWFjaChhcnJheSA9PiB7XG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXG5cdFx0Ly8gYHJlc3VsdC5jb25jYXQoYXJyYXkpYCB3aXRoIGNsb25pbmdcblx0XHRmb3IgKGxldCBrID0gMDsgayA8IGFycmF5Lmxlbmd0aDsgaysrKSB7XG5cdFx0XHRpZiAoIWhhc093blByb3BlcnR5LmNhbGwoYXJyYXksIGspKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpbmRpY2VzLnB1c2goU3RyaW5nKGspKTtcblxuXHRcdFx0aWYgKGFycmF5ID09PSBtZXJnZWQpIHtcblx0XHRcdFx0Ly8gQWxyZWFkeSBjbG9uZWRcblx0XHRcdFx0ZGVmaW5lUHJvcGVydHkocmVzdWx0LCByZXN1bHRJbmRleCsrLCBhcnJheVtrXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZpbmVQcm9wZXJ0eShyZXN1bHQsIHJlc3VsdEluZGV4KyssIGNsb25lKGFycmF5W2tdKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTWVyZ2Ugbm9uLWluZGV4IGtleXNcblx0XHRyZXN1bHQgPSBtZXJnZUtleXMocmVzdWx0LCBhcnJheSwgZ2V0RW51bWVyYWJsZU93blByb3BlcnR5S2V5cyhhcnJheSkuZmlsdGVyKGtleSA9PiB7XG5cdFx0XHRyZXR1cm4gaW5kaWNlcy5pbmRleE9mKGtleSkgPT09IC0xO1xuXHRcdH0pLCBtZXJnZU9wdHMpO1xuXHR9KTtcblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0gbWVyZ2VkIHthbHJlYWR5IGNsb25lZH1cbiAqIEByZXR1cm4ge2Nsb25lZCBPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1lcmdlKG1lcmdlZCwgc291cmNlLCBtZXJnZU9wdHMpIHtcblx0aWYgKG1lcmdlT3B0cy5jb25jYXRBcnJheXMgJiYgQXJyYXkuaXNBcnJheShtZXJnZWQpICYmIEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuXHRcdHJldHVybiBjb25jYXRBcnJheXMobWVyZ2VkLCBzb3VyY2UsIG1lcmdlT3B0cyk7XG5cdH1cblxuXHRpZiAoIWlzT3B0aW9uT2JqZWN0KHNvdXJjZSkgfHwgIWlzT3B0aW9uT2JqZWN0KG1lcmdlZCkpIHtcblx0XHRyZXR1cm4gY2xvbmUoc291cmNlKTtcblx0fVxuXG5cdHJldHVybiBtZXJnZUtleXMobWVyZ2VkLCBzb3VyY2UsIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMoc291cmNlKSwgbWVyZ2VPcHRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdGNvbnN0IG1lcmdlT3B0cyA9IG1lcmdlKGNsb25lKGRlZmF1bHRNZXJnZU9wdHMpLCAodGhpcyAhPT0gZ2xvYmFsVGhpcyAmJiB0aGlzKSB8fCB7fSwgZGVmYXVsdE1lcmdlT3B0cyk7XG5cdGxldCBtZXJnZWQgPSB7Zm9vYmFyOiB7fX07XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBvcHRpb24gPSBhcmd1bWVudHNbaV07XG5cblx0XHRpZiAob3B0aW9uID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmICghaXNPcHRpb25PYmplY3Qob3B0aW9uKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYCcgKyBvcHRpb24gKyAnYCBpcyBub3QgYW4gT3B0aW9uIE9iamVjdCcpO1xuXHRcdH1cblxuXHRcdG1lcmdlZCA9IG1lcmdlKG1lcmdlZCwge2Zvb2Jhcjogb3B0aW9ufSwgbWVyZ2VPcHRzKTtcblx0fVxuXG5cdHJldHVybiBtZXJnZWQuZm9vYmFyO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBJUEZTUmVwbyA9IHJlcXVpcmUoJ2lwZnMtcmVwbycpXG5cbm1vZHVsZS5leHBvcnRzID0gKGRpcikgPT4ge1xuICBjb25zdCByZXBvUGF0aCA9IGRpciB8fCAnaXBmcydcbiAgcmV0dXJuIG5ldyBJUEZTUmVwbyhyZXBvUGF0aClcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcbmNvbnN0IHNldEltbWVkaWF0ZSA9IHJlcXVpcmUoJ2FzeW5jL3NldEltbWVkaWF0ZScpXG5jb25zdCBsb2cgPSBkZWJ1ZygnaXBmczptZnMtcHJlbG9hZCcpXG5sb2cuZXJyb3IgPSBkZWJ1ZygnaXBmczptZnMtcHJlbG9hZDplcnJvcicpXG5cbm1vZHVsZS5leHBvcnRzID0gKHNlbGYpID0+IHtcbiAgY29uc3Qgb3B0aW9ucyA9IHNlbGYuX29wdGlvbnMucHJlbG9hZCB8fCB7fVxuICBvcHRpb25zLmludGVydmFsID0gb3B0aW9ucy5pbnRlcnZhbCB8fCAzMCAqIDEwMDBcblxuICBpZiAoIW9wdGlvbnMuZW5hYmxlZCkge1xuICAgIGxvZygnTUZTIHByZWxvYWQgZGlzYWJsZWQnKVxuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogKGNiKSA9PiBzZXRJbW1lZGlhdGUoY2IpLFxuICAgICAgc3RvcDogKGNiKSA9PiBzZXRJbW1lZGlhdGUoY2IpXG4gICAgfVxuICB9XG5cbiAgbGV0IHJvb3RDaWRcbiAgbGV0IHRpbWVvdXRJZFxuXG4gIGNvbnN0IHByZWxvYWRNZnMgPSAoKSA9PiB7XG4gICAgc2VsZi5maWxlcy5zdGF0KCcvJywgKGVyciwgc3RhdHMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChwcmVsb2FkTWZzLCBvcHRpb25zLmludGVydmFsKVxuICAgICAgICByZXR1cm4gbG9nLmVycm9yKCdmYWlsZWQgdG8gc3RhdCBNRlMgcm9vdCBmb3IgcHJlbG9hZCcsIGVycilcbiAgICAgIH1cblxuICAgICAgaWYgKHJvb3RDaWQgIT09IHN0YXRzLmhhc2gpIHtcbiAgICAgICAgbG9nKGBwcmVsb2FkaW5nIHVwZGF0ZWQgTUZTIHJvb3QgJHtyb290Q2lkfSAtPiAke3N0YXRzLmhhc2h9YClcblxuICAgICAgICByZXR1cm4gc2VsZi5fcHJlbG9hZChzdGF0cy5oYXNoLCAoZXJyKSA9PiB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChwcmVsb2FkTWZzLCBvcHRpb25zLmludGVydmFsKVxuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBsb2cuZXJyb3IoYGZhaWxlZCB0byBwcmVsb2FkIE1GUyByb290ICR7c3RhdHMuaGFzaH1gLCBlcnIpXG4gICAgICAgICAgcm9vdENpZCA9IHN0YXRzLmhhc2hcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChwcmVsb2FkTWZzLCBvcHRpb25zLmludGVydmFsKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0IChjYikge1xuICAgICAgc2VsZi5maWxlcy5zdGF0KCcvJywgKGVyciwgc3RhdHMpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgICAgcm9vdENpZCA9IHN0YXRzLmhhc2hcbiAgICAgICAgbG9nKGBtb25pdG9yaW5nIE1GUyByb290ICR7cm9vdENpZH1gKVxuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KHByZWxvYWRNZnMsIG9wdGlvbnMuaW50ZXJ2YWwpXG4gICAgICAgIGNiKClcbiAgICAgIH0pXG4gICAgfSxcbiAgICBzdG9wIChjYikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICAgIGNiKClcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiczU4ID0gcmVxdWlyZSgnYnM1OCcpXG5jb25zdCBQZWVySWQgPSByZXF1aXJlKCdwZWVyLWlkJylcbmNvbnN0IFBlZXJJbmZvID0gcmVxdWlyZSgncGVlci1pbmZvJylcblxuZnVuY3Rpb24gZ2V0QjU4U3RyIChwZWVyKSB7XG4gIGxldCBiNThTdHJcblxuICBpZiAodHlwZW9mIHBlZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgYjU4U3RyID0gcGVlclxuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihwZWVyKSkge1xuICAgIGI1OFN0ciA9IGJzNTguZW5jb2RlKHBlZXIpLnRvU3RyaW5nKClcbiAgfSBlbHNlIGlmIChQZWVySWQuaXNQZWVySWQocGVlcikpIHtcbiAgICBiNThTdHIgPSBwZWVyLnRvQjU4U3RyaW5nKClcbiAgfSBlbHNlIGlmIChQZWVySW5mby5pc1BlZXJJbmZvKHBlZXIpKSB7XG4gICAgYjU4U3RyID0gcGVlci5pZC50b0I1OFN0cmluZygpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgdmFsaWQgUGVlcklkIG9yIFBlZXJJbmZvLCBvciBCNThTdHInKVxuICB9XG5cbiAgcmV0dXJuIGI1OFN0clxufVxuXG5jbGFzcyBQZWVyQm9vayB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9wZWVycyA9IHt9XG4gIH1cblxuICAvLyBjaGVja3MgaWYgcGVlciBleGlzdHNcbiAgLy8gcGVlciBjYW4gYmUgUGVlcklkLCBiNThTdHJpbmcgb3IgUGVlckluZm9cbiAgaGFzIChwZWVyKSB7XG4gICAgY29uc3QgYjU4U3RyID0gZ2V0QjU4U3RyKHBlZXIpXG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fcGVlcnNbYjU4U3RyXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYSBwZWVySW5mbywgaWYgYWxyZWFkeSBleGlzdCwgbWVyZ2VzIHRoZSBuZXcgaW50byB0aGUgb2xkLlxuICAgKlxuICAgKiBAcGFyYW0ge1BlZXJJbmZvfSBwZWVySW5mb1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlcGxhY2VcbiAgICogQHJldHVybnMge1BlZXJJbmZvfVxuICAgKi9cbiAgcHV0IChwZWVySW5mbywgcmVwbGFjZSkge1xuICAgIGNvbnN0IGxvY2FsUGVlckluZm8gPSB0aGlzLl9wZWVyc1twZWVySW5mby5pZC50b0I1OFN0cmluZygpXVxuXG4gICAgLy8gaW5zZXJ0IGlmIGRvZXNuJ3QgZXhpc3Qgb3IgcmVwbGFjZSBpZiByZXBsYWNlIGZsYWcgaXMgdHJ1ZVxuICAgIGlmICghbG9jYWxQZWVySW5mbyB8fCByZXBsYWNlKSB7XG4gICAgICB0aGlzLl9wZWVyc1twZWVySW5mby5pZC50b0I1OFN0cmluZygpXSA9IHBlZXJJbmZvXG4gICAgICByZXR1cm4gcGVlckluZm9cbiAgICB9XG5cbiAgICAvLyBwZWVySW5mby5yZXBsYWNlIG1lcmdlcyBieSBkZWZhdWx0IGlmIG5vbmUgdG8gcmVwbGFjZSBhcmUgcGFzc2VkXG4gICAgcGVlckluZm8ubXVsdGlhZGRycy5mb3JFYWNoKChtYSkgPT4gbG9jYWxQZWVySW5mby5tdWx0aWFkZHJzLmFkZChtYSkpXG5cbiAgICAvLyBwYXNzIGFjdGl2ZSBjb25uZWN0aW9uIHN0YXRlXG4gICAgY29uc3QgbWEgPSBwZWVySW5mby5pc0Nvbm5lY3RlZCgpXG4gICAgaWYgKG1hKSB7XG4gICAgICBsb2NhbFBlZXJJbmZvLmNvbm5lY3QobWEpXG4gICAgfVxuXG4gICAgLy8gcGFzcyBrbm93biBwcm90b2NvbHNcbiAgICBwZWVySW5mby5wcm90b2NvbHMuZm9yRWFjaCgocCkgPT4gbG9jYWxQZWVySW5mby5wcm90b2NvbHMuYWRkKHApKVxuXG4gICAgaWYgKCFsb2NhbFBlZXJJbmZvLmlkLnByaXZLZXkgJiYgcGVlckluZm8uaWQucHJpdktleSkge1xuICAgICAgbG9jYWxQZWVySW5mby5pZC5wcml2S2V5ID0gcGVlckluZm8uaWQucHJpdktleVxuICAgIH1cblxuICAgIGlmICghbG9jYWxQZWVySW5mby5pZC5wdWJLZXkgJiYgcGVlckluZm8uaWQucHViS2V5KSB7XG4gICAgICBsb2NhbFBlZXJJbmZvLmlkLnB1YktleSA9IHBlZXJJbmZvLmlkLnB1YktleVxuICAgIH1cblxuICAgIHJldHVybiBsb2NhbFBlZXJJbmZvXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbmZvIHRvIHRoZSBnaXZlbiBQZWVySWQsIFBlZXJJbmZvIG9yIGI1OFN0ciBpZFxuICAgKlxuICAgKiBAcGFyYW0ge1BlZXJJZH0gcGVlclxuICAgKiBAcmV0dXJucyB7UGVlckluZm99XG4gICAqL1xuICBnZXQgKHBlZXIpIHtcbiAgICBjb25zdCBiNThTdHIgPSBnZXRCNThTdHIocGVlcilcblxuICAgIGNvbnN0IHBlZXJJbmZvID0gdGhpcy5fcGVlcnNbYjU4U3RyXVxuXG4gICAgaWYgKHBlZXJJbmZvKSB7XG4gICAgICByZXR1cm4gcGVlckluZm9cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQZWVySW5mbyBub3QgZm91bmQnKVxuICB9XG5cbiAgZ2V0QWxsICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGVlcnNcbiAgfVxuXG4gIGdldEFsbEFycmF5ICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fcGVlcnMpLm1hcCgoYjU4U3RyKSA9PiB0aGlzLl9wZWVyc1tiNThTdHJdKVxuICB9XG5cbiAgZ2V0TXVsdGlhZGRycyAocGVlcikge1xuICAgIGNvbnN0IGluZm8gPSB0aGlzLmdldChwZWVyKVxuICAgIHJldHVybiBpbmZvLm11bHRpYWRkcnMudG9BcnJheSgpXG4gIH1cblxuICByZW1vdmUgKHBlZXIpIHtcbiAgICBjb25zdCBiNThTdHIgPSBnZXRCNThTdHIocGVlcilcblxuICAgIGlmICh0aGlzLl9wZWVyc1tiNThTdHJdKSB7XG4gICAgICBkZWxldGUgdGhpcy5fcGVlcnNbYjU4U3RyXVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlZXJCb29rXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgYXN5bmNNYXAgPSByZXF1aXJlKCdhc3luYy9tYXAnKVxuXG4vKipcbiAqIEJsb2NrU2VydmljZSBpcyBhIGh5YnJpZCBibG9jayBkYXRhc3RvcmUuIEl0IHN0b3JlcyBkYXRhIGluIGEgbG9jYWxcbiAqIGRhdGFzdG9yZSBhbmQgbWF5IHJldHJpZXZlIGRhdGEgZnJvbSBhIHJlbW90ZSBFeGNoYW5nZS5cbiAqIEl0IHVzZXMgYW4gaW50ZXJuYWwgYGRhdGFzdG9yZS5EYXRhc3RvcmVgIGluc3RhbmNlIHRvIHN0b3JlIHZhbHVlcy5cbiAqL1xuY2xhc3MgQmxvY2tTZXJ2aWNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBCbG9ja1NlcnZpY2VcbiAgICpcbiAgICogQHBhcmFtIHtJUEZTUmVwb30gaXBmc1JlcG9cbiAgICovXG4gIGNvbnN0cnVjdG9yIChpcGZzUmVwbykge1xuICAgIHRoaXMuX3JlcG8gPSBpcGZzUmVwb1xuICAgIHRoaXMuX2JpdHN3YXAgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgYml0c3dhcCBpbnN0YW5jZSB0aGF0IGNvbW11bmljYXRlcyB3aXRoIHRoZVxuICAgKiBuZXR3b3JrIHRvIHJldHJlaXZlIGJsb2NrcyB0aGF0IGFyZSBub3QgaW4gdGhlIGxvY2FsIHN0b3JlLlxuICAgKlxuICAgKiBJZiB0aGUgbm9kZSBpcyBvbmxpbmUgYWxsIHJlcXVlc3RzIGZvciBibG9ja3MgZmlyc3RcbiAgICogY2hlY2sgbG9jYWxseSBhbmQgYWZ0ZXJ3YXJkcyBhc2sgdGhlIG5ldHdvcmsgZm9yIHRoZSBibG9ja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7Qml0c3dhcH0gYml0c3dhcFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHNldEV4Y2hhbmdlIChiaXRzd2FwKSB7XG4gICAgdGhpcy5fYml0c3dhcCA9IGJpdHN3YXBcbiAgfVxuXG4gIC8qKlxuICAgKiBHbyBvZmZsaW5lLCBpLmUuIGRyb3AgdGhlIHJlZmVyZW5jZSB0byBiaXRzd2FwLlxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHVuc2V0RXhjaGFuZ2UgKCkge1xuICAgIHRoaXMuX2JpdHN3YXAgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogSXMgdGhlIGJsb2Nrc2VydmljZSBvbmxpbmUsIGkuZS4gaXMgYml0c3dhcCBwcmVzZW50LlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbH1cbiAgICovXG4gIGhhc0V4Y2hhbmdlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYml0c3dhcCAhPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogUHV0IGEgYmxvY2sgdG8gdGhlIHVuZGVybHlpbmcgZGF0YXN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2NrfSBibG9ja1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBwdXQgKGJsb2NrLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmhhc0V4Y2hhbmdlKCkpIHtcbiAgICAgIHRoaXMuX2JpdHN3YXAucHV0KGJsb2NrLCBjYWxsYmFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVwby5ibG9ja3MucHV0KGJsb2NrLCBjYWxsYmFjaylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHV0IGEgbXVsdGlwbGUgYmxvY2tzIHRvIHRoZSB1bmRlcmx5aW5nIGRhdGFzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxCbG9jaz59IGJsb2Nrc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBwdXRNYW55IChibG9ja3MsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuaGFzRXhjaGFuZ2UoKSkge1xuICAgICAgdGhpcy5fYml0c3dhcC5wdXRNYW55KGJsb2NrcywgY2FsbGJhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlcG8uYmxvY2tzLnB1dE1hbnkoYmxvY2tzLCBjYWxsYmFjaylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgYmxvY2sgYnkgY2lkLlxuICAgKlxuICAgKiBAcGFyYW0ge0NJRH0gY2lkXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEJsb2NrKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBnZXQgKGNpZCwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5oYXNFeGNoYW5nZSgpKSB7XG4gICAgICB0aGlzLl9iaXRzd2FwLmdldChjaWQsIGNhbGxiYWNrKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXBvLmJsb2Nrcy5nZXQoY2lkLCBjYWxsYmFjaylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IG11bHRpcGxlIGJsb2NrcyBiYWNrIGZyb20gYW4gYXJyYXkgb2YgY2lkcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxDSUQ+fSBjaWRzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEJsb2NrKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBnZXRNYW55IChjaWRzLCBjYWxsYmFjaykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjaWRzKSkge1xuICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBhbiBhcnJheSBvZiBjaWRzJykpXG4gICAgfSBlbHNlIGlmICh0aGlzLmhhc0V4Y2hhbmdlKCkpIHtcbiAgICAgIHRoaXMuX2JpdHN3YXAuZ2V0TWFueShjaWRzLCBjYWxsYmFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgYXN5bmNNYXAoY2lkcywgKGNpZCwgY2IpID0+IHRoaXMuX3JlcG8uYmxvY2tzLmdldChjaWQsIGNiKSwgY2FsbGJhY2spXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGJsb2NrIGZyb20gdGhlIGJsb2Nrc3RvcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7Q0lEfSBjaWRcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBkZWxldGUgKGNpZCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9yZXBvLmJsb2Nrcy5kZWxldGUoY2lkLCBjYWxsYmFjaylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJsb2NrU2VydmljZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgbG9nID0gZGVidWcoJ2lwZnM6c3RhdGUnKVxubG9nLmVycm9yID0gZGVidWcoJ2lwZnM6c3RhdGU6ZXJyb3InKVxuXG5jb25zdCBmc20gPSByZXF1aXJlKCdmc20tZXZlbnQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChzZWxmKSA9PiB7XG4gIGNvbnN0IHMgPSBmc20oJ3VuaW5pdGlhbGl6ZWQnLCB7XG4gICAgdW5pbml0aWFsaXplZDoge1xuICAgICAgaW5pdDogJ2luaXRpYWxpemluZycsXG4gICAgICBpbml0aWFsaXplZDogJ3N0b3BwZWQnXG4gICAgfSxcbiAgICBpbml0aWFsaXppbmc6IHtcbiAgICAgIGluaXRpYWxpemVkOiAnc3RvcHBlZCdcbiAgICB9LFxuICAgIHN0b3BwZWQ6IHtcbiAgICAgIHN0YXJ0OiAnc3RhcnRpbmcnXG4gICAgfSxcbiAgICBzdGFydGluZzoge1xuICAgICAgc3RhcnRlZDogJ3J1bm5pbmcnXG4gICAgfSxcbiAgICBydW5uaW5nOiB7XG4gICAgICBzdG9wOiAnc3RvcHBpbmcnXG4gICAgfSxcbiAgICBzdG9wcGluZzoge1xuICAgICAgc3RvcHBlZDogJ3N0b3BwZWQnXG4gICAgfVxuICB9KVxuXG4gIC8vIGxvZyBldmVudHNcbiAgcy5vbignZXJyb3InLCAoZXJyKSA9PiBsb2cuZXJyb3IoZXJyKSlcbiAgcy5vbignZG9uZScsICgpID0+IGxvZygnLT4gJyArIHMuX3N0YXRlKSlcblxuICAvLyAtLSBBY3Rpb25zXG5cbiAgcy5pbml0ID0gKCkgPT4ge1xuICAgIHMoJ2luaXQnKVxuICB9XG5cbiAgcy5pbml0aWFsaXplZCA9ICgpID0+IHtcbiAgICBzKCdpbml0aWFsaXplZCcpXG4gIH1cblxuICBzLnN0b3AgPSAoKSA9PiB7XG4gICAgcygnc3RvcCcpXG4gIH1cblxuICBzLnN0b3BwZWQgPSAoKSA9PiB7XG4gICAgcygnc3RvcHBlZCcpXG4gIH1cblxuICBzLnN0YXJ0ID0gKCkgPT4ge1xuICAgIHMoJ3N0YXJ0JylcbiAgfVxuXG4gIHMuc3RhcnRlZCA9ICgpID0+IHtcbiAgICBzKCdzdGFydGVkJylcbiAgfVxuXG4gIHMuc3RhdGUgPSAoKSA9PiBzLl9zdGF0ZVxuXG4gIHJldHVybiBzXG59XG4iLCIvKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBtdWx0aWNvZGVjIHNwZWNpZmljYXRpb24uXG4gKlxuICogQG1vZHVsZSBtdWx0aWNvZGVjXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbXVsdGljb2RlYyA9IHJlcXVpcmUoJ211bHRpY29kZWMnKVxuICpcbiAqIGNvbnN0IHByZWZpeGVkUHJvdG9idWYgPSBtdWx0aWNvZGVjLmFkZFByZWZpeCgncHJvdG9idWYnLCBwcm90b2J1ZkJ1ZmZlcilcbiAqIC8vIHByZWZpeGVkUHJvdG9idWYgMHg1MC4uLlxuICpcbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG5jb25zdCBjb2RlY05hbWVUb0NvZGVWYXJpbnQgPSByZXF1aXJlKCcuL3ZhcmludC10YWJsZScpXG5jb25zdCBjb2RlVG9Db2RlY05hbWUgPSByZXF1aXJlKCcuL25hbWUtdGFibGUnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0c1xuXG4vKipcbiAqIFByZWZpeCBhIGJ1ZmZlciB3aXRoIGEgbXVsdGljb2RlYy1wYWNrZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBtdWx0aWNvZGVjU3RyT3JDb2RlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YVxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5hZGRQcmVmaXggPSAobXVsdGljb2RlY1N0ck9yQ29kZSwgZGF0YSkgPT4ge1xuICBsZXQgcHJlZml4XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihtdWx0aWNvZGVjU3RyT3JDb2RlKSkge1xuICAgIHByZWZpeCA9IHV0aWwudmFyaW50QnVmZmVyRW5jb2RlKG11bHRpY29kZWNTdHJPckNvZGUpXG4gIH0gZWxzZSB7XG4gICAgaWYgKGNvZGVjTmFtZVRvQ29kZVZhcmludFttdWx0aWNvZGVjU3RyT3JDb2RlXSkge1xuICAgICAgcHJlZml4ID0gY29kZWNOYW1lVG9Db2RlVmFyaW50W211bHRpY29kZWNTdHJPckNvZGVdXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbXVsdGljb2RlYyBub3QgcmVjb2duaXplZCcpXG4gICAgfVxuICB9XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtwcmVmaXgsIGRhdGFdKVxufVxuXG4vKipcbiAqIERlY2Fwc3VsYXRlIHRoZSBtdWx0aWNvZGVjLXBhY2tlZCBwcmVmaXggZnJvbSB0aGUgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YVxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5ybVByZWZpeCA9IChkYXRhKSA9PiB7XG4gIHZhcmludC5kZWNvZGUoZGF0YSlcbiAgcmV0dXJuIGRhdGEuc2xpY2UodmFyaW50LmRlY29kZS5ieXRlcylcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGVjIG9mIHRoZSBwcmVmaXhlZCBkYXRhLlxuICogQHBhcmFtIHtCdWZmZXJ9IHByZWZpeGVkRGF0YVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5nZXRDb2RlYyA9IChwcmVmaXhlZERhdGEpID0+IHtcbiAgY29uc3QgY29kZSA9IHV0aWwudmFyaW50QnVmZmVyRGVjb2RlKHByZWZpeGVkRGF0YSlcbiAgY29uc3QgY29kZWNOYW1lID0gY29kZVRvQ29kZWNOYW1lW2NvZGUudG9TdHJpbmcoJ2hleCcpXVxuICBpZiAoY29kZWNOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGUgYDB4JyArIGNvZGUudG9TdHJpbmcoJ2hleCcpICsgJ2Agbm90IGZvdW5kJylcbiAgfVxuICByZXR1cm4gY29kZWNOYW1lXG59XG5cbi8qKlxuICogR2V0IHRoZSBuYW1lIG9mIHRoZSBjb2RlYy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlY1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5nZXROYW1lID0gKGNvZGVjKSA9PiB7XG4gIHJldHVybiBjb2RlVG9Db2RlY05hbWVbY29kZWMudG9TdHJpbmcoMTYpXVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29kZSBvZiB0aGUgY29kZWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLmdldE51bWJlciA9IChuYW1lKSA9PiB7XG4gIGNvbnN0IGNvZGUgPSBjb2RlY05hbWVUb0NvZGVWYXJpbnRbbmFtZV1cbiAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29kZWMgYCcgKyBuYW1lICsgJ2Agbm90IGZvdW5kJylcbiAgfVxuICByZXR1cm4gdXRpbC52YXJpbnRCdWZmZXJEZWNvZGUoY29kZSlbMF1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGUgb2YgdGhlIHByZWZpeGVkIGRhdGEuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJlZml4ZWREYXRhXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLmdldENvZGUgPSAocHJlZml4ZWREYXRhKSA9PiB7XG4gIHJldHVybiB2YXJpbnQuZGVjb2RlKHByZWZpeGVkRGF0YSlcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGUgYXMgdmFyaW50IG9mIGEgY29kZWMgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlY05hbWVcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuZ2V0Q29kZVZhcmludCA9IChjb2RlY05hbWUpID0+IHtcbiAgY29uc3QgY29kZSA9IGNvZGVjTmFtZVRvQ29kZVZhcmludFtjb2RlY05hbWVdXG4gIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVjIGAnICsgY29kZWNOYW1lICsgJ2Agbm90IGZvdW5kJylcbiAgfVxuICByZXR1cm4gY29kZVxufVxuXG4vKipcbiAqIEdldCB0aGUgdmFyaW50IG9mIGEgY29kZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XG4gKi9cbmV4cG9ydHMuZ2V0VmFyaW50ID0gKGNvZGUpID0+IHtcbiAgcmV0dXJuIHZhcmludC5lbmNvZGUoY29kZSlcbn1cblxuLy8gTWFrZSB0aGUgY29uc3RhbnRzIHRvcC1sZXZlbCBjb25zdGFudHNcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbk9iamVjdC5hc3NpZ24oZXhwb3J0cywgY29uc3RhbnRzKVxuXG4vLyBIdW1hbiBmcmllbmRseSBuYW1lcyBmb3IgcHJpbnRpbmcsIGUuZy4gaW4gZXJyb3IgbWVzc2FnZXNcbmV4cG9ydHMucHJpbnQgPSByZXF1aXJlKCcuL3ByaW50JylcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBtaCA9IHJlcXVpcmUoJ211bHRpaGFzaGVzJylcbmNvbnN0IG11bHRpYmFzZSA9IHJlcXVpcmUoJ211bHRpYmFzZScpXG5jb25zdCBtdWx0aWNvZGVjID0gcmVxdWlyZSgnbXVsdGljb2RlYycpXG5jb25zdCBjb2RlY3MgPSByZXF1aXJlKCdtdWx0aWNvZGVjL3NyYy9iYXNlLXRhYmxlJylcbmNvbnN0IENJRFV0aWwgPSByZXF1aXJlKCcuL2NpZC11dGlsJylcbmNvbnN0IHdpdGhJcyA9IHJlcXVpcmUoJ2NsYXNzLWlzJylcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTZXJpYWxpemVkQ0lEXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZWNcbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJzaW9uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbXVsdGloYXNoXG4gKi9cblxuLyoqXG4gKiBUZXN0IGlmIHRoZSBnaXZlbiBpbnB1dCBpcyBhIENJRC5cbiAqIEBmdW5jdGlvbiBpc0NJRFxuICogQG1lbWJlcm9mIENJRFxuICogQHN0YXRpY1xuICogQHBhcmFtIHthbnl9IG90aGVyXG4gKiBAcmV0dXJucyB7Ym9vbH1cbiAqL1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIENJRCBgPG1iYXNlPjx2ZXJzaW9uPjxtY29kZWM+PG1oYXNoPmBcbiAqICwgYXMgZGVmaW5lZCBpbiBbaXBsZC9jaWRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvY2lkKS5cbiAqIEBjbGFzcyBDSURcbiAqL1xuY2xhc3MgQ0lEIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBDSUQuXG4gICAqXG4gICAqIFRoZSBhbGdvcml0aG0gZm9yIGFyZ3VtZW50IGlucHV0IGlzIHJvdWdobHk6XG4gICAqIGBgYFxuICAgKiBpZiAoY2lkKVxuICAgKiAgIC0+IGNyZWF0ZSBhIGNvcHlcbiAgICogZWxzZSBpZiAoc3RyKVxuICAgKiAgIGlmICgxc3QgY2hhciBpcyBvbiBtdWx0aWJhc2UgdGFibGUpIC0+IENJRCBTdHJpbmdcbiAgICogICBlbHNlIC0+IGJzNTggZW5jb2RlZCBtdWx0aWhhc2hcbiAgICogZWxzZSBpZiAoQnVmZmVyKVxuICAgKiAgIGlmICgxc3QgYnl0ZSBpcyAwIG9yIDEpIC0+IENJRFxuICAgKiAgIGVsc2UgLT4gbXVsdGloYXNoXG4gICAqIGVsc2UgaWYgKE51bWJlcilcbiAgICogICAtPiBjb25zdHJ1Y3QgQ0lEIGJ5IHBhcnRzXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8Q0lEfSB2ZXJzaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZWNdXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbbXVsdGloYXNoXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW211bHRpYmFzZU5hbWVdXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBDSUQoPHZlcnNpb24+LCA8Y29kZWM+LCA8bXVsdGloYXNoPiwgPG11bHRpYmFzZU5hbWU+KVxuICAgKiBuZXcgQ0lEKDxjaWRTdHI+KVxuICAgKiBuZXcgQ0lEKDxjaWQuYnVmZmVyPilcbiAgICogbmV3IENJRCg8bXVsdGloYXNoPilcbiAgICogbmV3IENJRCg8YnM1OCBlbmNvZGVkIG11bHRpaGFzaD4pXG4gICAqIG5ldyBDSUQoPGNpZD4pXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodmVyc2lvbiwgY29kZWMsIG11bHRpaGFzaCwgbXVsdGliYXNlTmFtZSkge1xuICAgIGlmIChfQ0lELmlzQ0lEKHZlcnNpb24pKSB7XG4gICAgICAvLyB2ZXJzaW9uIGlzIGFuIGV4aXNpbmcgQ0lEIGluc3RhbmNlXG4gICAgICBjb25zdCBjaWQgPSB2ZXJzaW9uXG4gICAgICB0aGlzLnZlcnNpb24gPSBjaWQudmVyc2lvblxuICAgICAgdGhpcy5jb2RlYyA9IGNpZC5jb2RlY1xuICAgICAgdGhpcy5tdWx0aWhhc2ggPSBCdWZmZXIuZnJvbShjaWQubXVsdGloYXNoKVxuICAgICAgLy8gRGVmYXVsdCBndWFyZCBmb3Igd2hlbiBhIENJRCA8IDAuNyBpcyBwYXNzZWQgd2l0aCBubyBtdWx0aWJhc2VOYW1lXG4gICAgICB0aGlzLm11bHRpYmFzZU5hbWUgPSBjaWQubXVsdGliYXNlTmFtZSB8fCAoY2lkLnZlcnNpb24gPT09IDAgPyAnYmFzZTU4YnRjJyA6ICdiYXNlMzInKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZS5nLiAnYmFzZTMyJyBvciBmYWxzZVxuICAgICAgY29uc3QgYmFzZU5hbWUgPSBtdWx0aWJhc2UuaXNFbmNvZGVkKHZlcnNpb24pXG4gICAgICBpZiAoYmFzZU5hbWUpIHtcbiAgICAgICAgLy8gdmVyc2lvbiBpcyBhIENJRCBTdHJpbmcgZW5jb2RlZCB3aXRoIG11bHRpYmFzZSwgc28gdjFcbiAgICAgICAgY29uc3QgY2lkID0gbXVsdGliYXNlLmRlY29kZSh2ZXJzaW9uKVxuICAgICAgICB0aGlzLnZlcnNpb24gPSBwYXJzZUludChjaWQuc2xpY2UoMCwgMSkudG9TdHJpbmcoJ2hleCcpLCAxNilcbiAgICAgICAgdGhpcy5jb2RlYyA9IG11bHRpY29kZWMuZ2V0Q29kZWMoY2lkLnNsaWNlKDEpKVxuICAgICAgICB0aGlzLm11bHRpaGFzaCA9IG11bHRpY29kZWMucm1QcmVmaXgoY2lkLnNsaWNlKDEpKVxuICAgICAgICB0aGlzLm11bHRpYmFzZU5hbWUgPSBiYXNlTmFtZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdmVyc2lvbiBpcyBhIGJhc2U1OGJ0YyBzdHJpbmcgbXVsdGloYXNoLCBzbyB2MFxuICAgICAgICB0aGlzLnZlcnNpb24gPSAwXG4gICAgICAgIHRoaXMuY29kZWMgPSAnZGFnLXBiJ1xuICAgICAgICB0aGlzLm11bHRpaGFzaCA9IG1oLmZyb21CNThTdHJpbmcodmVyc2lvbilcbiAgICAgICAgdGhpcy5tdWx0aWJhc2VOYW1lID0gJ2Jhc2U1OGJ0YydcbiAgICAgIH1cbiAgICAgIENJRC52YWxpZGF0ZUNJRCh0aGlzKVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdHJpbmcnLCB7IHZhbHVlOiB2ZXJzaW9uIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZlcnNpb24pKSB7XG4gICAgICBjb25zdCBmaXJzdEJ5dGUgPSB2ZXJzaW9uLnNsaWNlKDAsIDEpXG4gICAgICBjb25zdCB2ID0gcGFyc2VJbnQoZmlyc3RCeXRlLnRvU3RyaW5nKCdoZXgnKSwgMTYpXG4gICAgICBpZiAodiA9PT0gMSkge1xuICAgICAgICAvLyB2ZXJzaW9uIGlzIGEgQ0lEIGJ1ZmZlclxuICAgICAgICBjb25zdCBjaWQgPSB2ZXJzaW9uXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZcbiAgICAgICAgdGhpcy5jb2RlYyA9IG11bHRpY29kZWMuZ2V0Q29kZWMoY2lkLnNsaWNlKDEpKVxuICAgICAgICB0aGlzLm11bHRpaGFzaCA9IG11bHRpY29kZWMucm1QcmVmaXgoY2lkLnNsaWNlKDEpKVxuICAgICAgICB0aGlzLm11bHRpYmFzZU5hbWUgPSAnYmFzZTMyJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdmVyc2lvbiBpcyBhIHJhdyBtdWx0aWhhc2ggYnVmZmVyLCBzbyB2MFxuICAgICAgICB0aGlzLnZlcnNpb24gPSAwXG4gICAgICAgIHRoaXMuY29kZWMgPSAnZGFnLXBiJ1xuICAgICAgICB0aGlzLm11bHRpaGFzaCA9IHZlcnNpb25cbiAgICAgICAgdGhpcy5tdWx0aWJhc2VOYW1lID0gJ2Jhc2U1OGJ0YydcbiAgICAgIH1cbiAgICAgIENJRC52YWxpZGF0ZUNJRCh0aGlzKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlLCBhc3NlbWJsZSB0aGUgQ0lEIGZyb20gdGhlIHBhcmFtZXRlcnNcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvblxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNvZGVjID0gY29kZWNcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCdWZmZXJ9XG4gICAgICovXG4gICAgdGhpcy5tdWx0aWhhc2ggPSBtdWx0aWhhc2hcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5tdWx0aWJhc2VOYW1lID0gbXVsdGliYXNlTmFtZSB8fCAodmVyc2lvbiA9PT0gMCA/ICdiYXNlNThidGMnIDogJ2Jhc2UzMicpXG5cbiAgICBDSUQudmFsaWRhdGVDSUQodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgQ0lEIGFzIGEgYEJ1ZmZlcmBcbiAgICpcbiAgICogQHJldHVybiB7QnVmZmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICpcbiAgICogQG1lbWJlck9mIENJRFxuICAgKi9cbiAgZ2V0IGJ1ZmZlciAoKSB7XG4gICAgbGV0IGJ1ZmZlciA9IHRoaXMuX2J1ZmZlclxuXG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIGlmICh0aGlzLnZlcnNpb24gPT09IDApIHtcbiAgICAgICAgYnVmZmVyID0gdGhpcy5tdWx0aWhhc2hcbiAgICAgIH0gZWxzZSBpZiAodGhpcy52ZXJzaW9uID09PSAxKSB7XG4gICAgICAgIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgIEJ1ZmZlci5mcm9tKCcwMScsICdoZXgnKSxcbiAgICAgICAgICBtdWx0aWNvZGVjLmdldENvZGVWYXJpbnQodGhpcy5jb2RlYyksXG4gICAgICAgICAgdGhpcy5tdWx0aWhhc2hcbiAgICAgICAgXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgdmVyc2lvbicpXG4gICAgICB9XG5cbiAgICAgIC8vIENhY2hlIHRoaXMgYnVmZmVyIHNvIGl0IGRvZXNuJ3QgaGF2ZSB0byBiZSByZWNyZWF0ZWRcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX2J1ZmZlcicsIHsgdmFsdWU6IGJ1ZmZlciB9KVxuICAgIH1cblxuICAgIHJldHVybiBidWZmZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByZWZpeCBvZiB0aGUgQ0lELlxuICAgKlxuICAgKiBAcmV0dXJucyB7QnVmZmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwcmVmaXggKCkge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtcbiAgICAgIEJ1ZmZlci5mcm9tKGAwJHt0aGlzLnZlcnNpb259YCwgJ2hleCcpLFxuICAgICAgbXVsdGljb2RlYy5nZXRDb2RlVmFyaW50KHRoaXMuY29kZWMpLFxuICAgICAgbWgucHJlZml4KHRoaXMubXVsdGloYXNoKVxuICAgIF0pXG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0byBhIENJRCBvZiB2ZXJzaW9uIGAwYC5cbiAgICpcbiAgICogQHJldHVybnMge0NJRH1cbiAgICovXG4gIHRvVjAgKCkge1xuICAgIGlmICh0aGlzLmNvZGVjICE9PSAnZGFnLXBiJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCBhIG5vbiBkYWctcGIgQ0lEIHRvIENJRHYwJylcbiAgICB9XG5cbiAgICBjb25zdCB7IG5hbWUsIGxlbmd0aCB9ID0gbWguZGVjb2RlKHRoaXMubXVsdGloYXNoKVxuXG4gICAgaWYgKG5hbWUgIT09ICdzaGEyLTI1NicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgbm9uIHNoYTItMjU2IG11bHRpaGFzaCBDSUQgdG8gQ0lEdjAnKVxuICAgIH1cblxuICAgIGlmIChsZW5ndGggIT09IDMyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IG5vbiAzMiBieXRlIG11bHRpaGFzaCBDSUQgdG8gQ0lEdjAnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgX0NJRCgwLCB0aGlzLmNvZGVjLCB0aGlzLm11bHRpaGFzaClcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRvIGEgQ0lEIG9mIHZlcnNpb24gYDFgLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q0lEfVxuICAgKi9cbiAgdG9WMSAoKSB7XG4gICAgcmV0dXJuIG5ldyBfQ0lEKDEsIHRoaXMuY29kZWMsIHRoaXMubXVsdGloYXNoKVxuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSB0aGUgQ0lEIGludG8gYSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYmFzZT10aGlzLm11bHRpYmFzZU5hbWVdIC0gQmFzZSBlbmNvZGluZyB0byB1c2UuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICB0b0Jhc2VFbmNvZGVkU3RyaW5nIChiYXNlID0gdGhpcy5tdWx0aWJhc2VOYW1lKSB7XG4gICAgaWYgKHRoaXMuc3RyaW5nICYmIGJhc2UgPT09IHRoaXMubXVsdGliYXNlTmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nXG4gICAgfVxuICAgIGxldCBzdHIgPSBudWxsXG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMCkge1xuICAgICAgaWYgKGJhc2UgIT09ICdiYXNlNThidGMnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IHN1cHBvcnRlZCB3aXRoIENJRHYwLCB0byBzdXBwb3J0IGRpZmZlcmVudCBiYXNlcywgcGxlYXNlIG1pZ3JhdGUgdGhlIGluc3RhbmNlIGRvIENJRHYxLCB5b3UgY2FuIGRvIHRoYXQgdGhyb3VnaCBjaWQudG9WMSgpJylcbiAgICAgIH1cbiAgICAgIHN0ciA9IG1oLnRvQjU4U3RyaW5nKHRoaXMubXVsdGloYXNoKVxuICAgIH0gZWxzZSBpZiAodGhpcy52ZXJzaW9uID09PSAxKSB7XG4gICAgICBzdHIgPSBtdWx0aWJhc2UuZW5jb2RlKGJhc2UsIHRoaXMuYnVmZmVyKS50b1N0cmluZygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgdmVyc2lvbicpXG4gICAgfVxuICAgIGlmIChiYXNlID09PSB0aGlzLm11bHRpYmFzZU5hbWUpIHtcbiAgICAgIC8vIGNhY2hlIHRoZSBzdHJpbmcgdmFsdWVcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RyaW5nJywgeyB2YWx1ZTogc3RyIH0pXG4gICAgfVxuICAgIHJldHVybiBzdHJcbiAgfVxuXG4gIHRvU3RyaW5nIChiYXNlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9CYXNlRW5jb2RlZFN0cmluZyhiYXNlKVxuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0byBhIHBsYWluIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMge1NlcmlhbGl6ZWRDSUR9XG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb2RlYzogdGhpcy5jb2RlYyxcbiAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICAgIGhhc2g6IHRoaXMubXVsdGloYXNoXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmUgZXF1YWxpdHkgd2l0aCBhbm90aGVyIENJRC5cbiAgICpcbiAgICogQHBhcmFtIHtDSUR9IG90aGVyXG4gICAqIEByZXR1cm5zIHtib29sfVxuICAgKi9cbiAgZXF1YWxzIChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvZGVjID09PSBvdGhlci5jb2RlYyAmJlxuICAgICAgdGhpcy52ZXJzaW9uID09PSBvdGhlci52ZXJzaW9uICYmXG4gICAgICB0aGlzLm11bHRpaGFzaC5lcXVhbHMob3RoZXIubXVsdGloYXNoKVxuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgaWYgdGhlIGdpdmVuIGlucHV0IGlzIGEgdmFsaWQgQ0lEIG9iamVjdC5cbiAgICogVGhyb3dzIGlmIGl0IGlzIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IG90aGVyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgc3RhdGljIHZhbGlkYXRlQ0lEIChvdGhlcikge1xuICAgIGxldCBlcnJvck1zZyA9IENJRFV0aWwuY2hlY2tDSURDb21wb25lbnRzKG90aGVyKVxuICAgIGlmIChlcnJvck1zZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBfQ0lEID0gd2l0aElzKENJRCwge1xuICBjbGFzc05hbWU6ICdDSUQnLFxuICBzeW1ib2xOYW1lOiAnQGlwbGQvanMtY2lkL0NJRCdcbn0pXG5cbl9DSUQuY29kZWNzID0gY29kZWNzXG5cbm1vZHVsZS5leHBvcnRzID0gX0NJRFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFBlZXJJZCA9IHJlcXVpcmUoJ3BlZXItaWQnKVxuY29uc3QgeyBlbnN1cmVNdWx0aWFkZHIgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgTXVsdGlhZGRyU2V0ID0gcmVxdWlyZSgnLi9tdWx0aWFkZHItc2V0JylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5cbi8vIFBlZXIgcmVwcmVzZW50cyBhIHBlZXIgb24gdGhlIElQRlMgbmV0d29ya1xuY2xhc3MgUGVlckluZm8ge1xuICBjb25zdHJ1Y3RvciAocGVlcklkKSB7XG4gICAgYXNzZXJ0KHBlZXJJZCwgJ01pc3NpbmcgcGVlcklkLiBVc2UgUGVlci5jcmVhdGUoY2IpIHRvIGNyZWF0ZSBvbmUnKVxuXG4gICAgdGhpcy5pZCA9IHBlZXJJZFxuICAgIHRoaXMubXVsdGlhZGRycyA9IG5ldyBNdWx0aWFkZHJTZXQoKVxuICAgIHRoaXMucHJvdG9jb2xzID0gbmV3IFNldCgpXG4gICAgdGhpcy5fY29ubmVjdGVkTXVsdGlhZGRyID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBvbmx5IHN0b3JlcyB0aGUgY3VycmVudCBtdWx0aWFkZHIgYmVpbmcgdXNlZFxuICBjb25uZWN0IChtYSkge1xuICAgIG1hID0gZW5zdXJlTXVsdGlhZGRyKG1hKVxuICAgIGlmICghdGhpcy5tdWx0aWFkZHJzLmhhcyhtYSkgJiYgbWEudG9TdHJpbmcoKSAhPT0gYC9pcGZzLyR7dGhpcy5pZC50b0I1OFN0cmluZygpfWApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2FuXFwndCBiZSBjb25uZWN0ZWQgdG8gbWlzc2luZyBtdWx0aWFkZHIgZnJvbSBzZXQnKVxuICAgIH1cbiAgICB0aGlzLl9jb25uZWN0ZWRNdWx0aWFkZHIgPSBtYVxuICB9XG5cbiAgZGlzY29ubmVjdCAoKSB7XG4gICAgdGhpcy5fY29ubmVjdGVkTXVsdGlhZGRyID0gdW5kZWZpbmVkXG4gIH1cblxuICBpc0Nvbm5lY3RlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RlZE11bHRpYWRkclxuICB9XG59XG5cblBlZXJJbmZvLmNyZWF0ZSA9IChwZWVySWQsIGNhbGxiYWNrKSA9PiB7XG4gIGlmICh0eXBlb2YgcGVlcklkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBwZWVySWRcbiAgICBwZWVySWQgPSBudWxsXG5cbiAgICBQZWVySWQuY3JlYXRlKChlcnIsIGlkKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIG5ldyBQZWVySW5mbyhpZCkpXG4gICAgfSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIEFscmVhZHkgYSBQZWVySWQgaW5zdGFuY2VcbiAgaWYgKHR5cGVvZiBwZWVySWQudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgbmV3IFBlZXJJbmZvKHBlZXJJZCkpXG4gIH0gZWxzZSB7XG4gICAgUGVlcklkLmNyZWF0ZUZyb21KU09OKHBlZXJJZCwgKGVyciwgaWQpID0+IGNhbGxiYWNrKGVyciwgbmV3IFBlZXJJbmZvKGlkKSkpXG4gIH1cbn1cblxuUGVlckluZm8uaXNQZWVySW5mbyA9IChwZWVySW5mbykgPT4ge1xuICByZXR1cm4gQm9vbGVhbih0eXBlb2YgcGVlckluZm8gPT09ICdvYmplY3QnICYmXG4gICAgcGVlckluZm8uaWQgJiZcbiAgICBwZWVySW5mby5tdWx0aWFkZHJzKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlZXJJbmZvXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgTXVsdGlhZGRyID0gcmVxdWlyZSgnbXVsdGlhZGRyJylcbmNvbnN0IG1hZm10ID0gcmVxdWlyZSgnbWFmbXQnKVxuY29uc3QgeyBzdHJ1Y3QsIHN1cGVyc3RydWN0IH0gPSByZXF1aXJlKCdzdXBlcnN0cnVjdCcpXG5cbmNvbnN0IHsgb3B0aW9uYWwsIHVuaW9uIH0gPSBzdHJ1Y3RcbmNvbnN0IHMgPSBzdXBlcnN0cnVjdCh7XG4gIHR5cGVzOiB7XG4gICAgbXVsdGlhZGRyOiB2ID0+IHtcbiAgICAgIGlmICh2ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBgbXVsdGlhZGRyIGludmFsaWQsIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgb3IgYW5vdGhlciBNdWx0aWFkZHIgZ290ICR7dn1gXG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIE11bHRpYWRkcih2KVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBgbXVsdGlhZGRyIGludmFsaWQsICR7ZXJyLm1lc3NhZ2V9YFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0sXG4gICAgJ211bHRpYWRkci1pcGZzJzogdiA9PiBtYWZtdC5JUEZTLm1hdGNoZXModikgPyB0cnVlIDogYG11bHRpYWRkciBJUEZTIGludmFsaWRgXG4gIH1cbn0pXG5cbmNvbnN0IGNvbmZpZ1NjaGVtYSA9IHMoe1xuICByZXBvOiBvcHRpb25hbChzKCdvYmplY3R8c3RyaW5nJykpLFxuICByZXBvT3duZXI6ICdib29sZWFuPycsXG4gIHByZWxvYWQ6IHMoe1xuICAgIGVuYWJsZWQ6ICdib29sZWFuPycsXG4gICAgYWRkcmVzc2VzOiBvcHRpb25hbChzKFsnbXVsdGlhZGRyJ10pKSxcbiAgICBpbnRlcnZhbDogJ251bWJlcj8nXG4gIH0sIHsgZW5hYmxlZDogdHJ1ZSwgaW50ZXJ2YWw6IDMwICogMTAwMCB9KSxcbiAgaW5pdDogb3B0aW9uYWwodW5pb24oWydib29sZWFuJywgcyh7XG4gICAgYml0czogJ251bWJlcj8nLFxuICAgIGVtcHR5UmVwbzogJ2Jvb2xlYW4/JyxcbiAgICBwcml2YXRlS2V5OiBvcHRpb25hbChzKCdvYmplY3R8c3RyaW5nJykpLCAvLyBvYmplY3Qgc2hvdWxkIGJlIGEgY3VzdG9tIHR5cGUgZm9yIFBlZXJJZCB1c2luZyAna2luZC1vZidcbiAgICBwYXNzOiAnc3RyaW5nPydcbiAgfSldKSksXG4gIHN0YXJ0OiAnYm9vbGVhbj8nLFxuICBvZmZsaW5lOiAnYm9vbGVhbj8nLFxuICBwYXNzOiAnc3RyaW5nPycsXG4gIHNpbGVudDogJ2Jvb2xlYW4/JyxcbiAgcmVsYXk6ICdvYmplY3Q/JywgLy8gcmVsYXkgdmFsaWRhdGVzIGluIGxpYnAycFxuICBFWFBFUklNRU5UQUw6IG9wdGlvbmFsKHMoe1xuICAgIHB1YnN1YjogJ2Jvb2xlYW4/JyxcbiAgICBpcG5zUHVic3ViOiAnYm9vbGVhbj8nLFxuICAgIHNoYXJkaW5nOiAnYm9vbGVhbj8nLFxuICAgIGRodDogJ2Jvb2xlYW4/J1xuICB9KSksXG4gIGNvbm5lY3Rpb25NYW5hZ2VyOiAnb2JqZWN0PycsXG4gIGNvbmZpZzogb3B0aW9uYWwocyh7XG4gICAgQVBJOiAnb2JqZWN0PycsXG4gICAgQWRkcmVzc2VzOiBvcHRpb25hbChzKHtcbiAgICAgIFN3YXJtOiBvcHRpb25hbChzKFsnbXVsdGlhZGRyJ10pKSxcbiAgICAgIEFQSTogJ211bHRpYWRkcj8nLFxuICAgICAgR2F0ZXdheTogJ211bHRpYWRkcidcbiAgICB9KSksXG4gICAgRGlzY292ZXJ5OiBvcHRpb25hbChzKHtcbiAgICAgIE1ETlM6IG9wdGlvbmFsKHMoe1xuICAgICAgICBFbmFibGVkOiAnYm9vbGVhbj8nLFxuICAgICAgICBJbnRlcnZhbDogJ251bWJlcj8nXG4gICAgICB9KSksXG4gICAgICB3ZWJSVENTdGFyOiBvcHRpb25hbChzKHtcbiAgICAgICAgRW5hYmxlZDogJ2Jvb2xlYW4/J1xuICAgICAgfSkpXG4gICAgfSkpLFxuICAgIEJvb3RzdHJhcDogb3B0aW9uYWwocyhbJ211bHRpYWRkci1pcGZzJ10pKVxuICB9KSksXG4gIGlwbGQ6ICdvYmplY3Q/JyxcbiAgbGlicDJwOiBvcHRpb25hbCh1bmlvbihbJ2Z1bmN0aW9uJywgJ29iamVjdCddKSkgLy8gbGlicDJwIHZhbGlkYXRlcyB0aGlzXG59LCB7XG4gIHJlcG9Pd25lcjogdHJ1ZVxufSlcblxuY29uc3QgdmFsaWRhdGUgPSAob3B0cykgPT4ge1xuICBjb25zdCBbZXJyLCBvcHRpb25zXSA9IGNvbmZpZ1NjaGVtYS52YWxpZGF0ZShvcHRzKVxuXG4gIGlmIChlcnIpIHtcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zXG59XG5cbm1vZHVsZS5leHBvcnRzID0geyB2YWxpZGF0ZSB9XG4iLCIvKlxuICogSWQgaXMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgcGVlciBJZC4gYSBwZWVyIElkIGlzIGEgbXVsdGloYXNoXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG1oID0gcmVxdWlyZSgnbXVsdGloYXNoZXMnKVxuY29uc3QgY3J5cHRvS2V5cyA9IHJlcXVpcmUoJ2xpYnAycC1jcnlwdG8vc3JjL2tleXMnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHdhdGVyZmFsbCA9IHJlcXVpcmUoJ2FzeW5jL3dhdGVyZmFsbCcpXG5jb25zdCB3aXRoSXMgPSByZXF1aXJlKCdjbGFzcy1pcycpXG5cbmNsYXNzIFBlZXJJZCB7XG4gIGNvbnN0cnVjdG9yIChpZCwgcHJpdktleSwgcHViS2V5KSB7XG4gICAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihpZCksICdpbnZhbGlkIGlkIHByb3ZpZGVkJylcblxuICAgIGlmIChwcml2S2V5ICYmIHB1YktleSkge1xuICAgICAgYXNzZXJ0KHByaXZLZXkucHVibGljLmJ5dGVzLmVxdWFscyhwdWJLZXkuYnl0ZXMpLCAnaW5jb25zaXN0ZW50IGFyZ3VtZW50cycpXG4gICAgfVxuXG4gICAgdGhpcy5faWQgPSBpZFxuICAgIHRoaXMuX2lkQjU4U3RyaW5nID0gbWgudG9CNThTdHJpbmcodGhpcy5pZClcbiAgICB0aGlzLl9wcml2S2V5ID0gcHJpdktleVxuICAgIHRoaXMuX3B1YktleSA9IHB1YktleVxuICB9XG5cbiAgZ2V0IGlkICgpIHtcbiAgICByZXR1cm4gdGhpcy5faWRcbiAgfVxuXG4gIHNldCBpZCAodmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJZCBpcyBpbW11dGFibGUnKVxuICB9XG5cbiAgZ2V0IHByaXZLZXkgKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2S2V5XG4gIH1cblxuICBzZXQgcHJpdktleSAocHJpdktleSkge1xuICAgIHRoaXMuX3ByaXZLZXkgPSBwcml2S2V5XG4gIH1cblxuICBnZXQgcHViS2V5ICgpIHtcbiAgICBpZiAodGhpcy5fcHViS2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHViS2V5XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3ByaXZLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2S2V5LnB1YmxpY1xuICAgIH1cbiAgfVxuXG4gIHNldCBwdWJLZXkgKHB1YktleSkge1xuICAgIHRoaXMuX3B1YktleSA9IHB1YktleVxuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSBwcm90b2J1ZiB2ZXJzaW9uIG9mIHRoZSBwdWJsaWMga2V5LCBtYXRjaGluZyBnbyBpcGZzIGZvcm1hdHRpbmdcbiAgbWFyc2hhbFB1YktleSAoKSB7XG4gICAgaWYgKHRoaXMucHViS2V5KSB7XG4gICAgICByZXR1cm4gY3J5cHRvS2V5cy5tYXJzaGFsUHVibGljS2V5KHRoaXMucHViS2V5KVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgcHJvdG9idWYgdmVyc2lvbiBvZiB0aGUgcHJpdmF0ZSBrZXksIG1hdGNoaW5nIGdvIGlwZnMgZm9ybWF0dGluZ1xuICBtYXJzaGFsUHJpdktleSAoKSB7XG4gICAgaWYgKHRoaXMucHJpdktleSkge1xuICAgICAgcmV0dXJuIGNyeXB0b0tleXMubWFyc2hhbFByaXZhdGVLZXkodGhpcy5wcml2S2V5KVxuICAgIH1cbiAgfVxuXG4gIHRvUHJpbnQgKCkge1xuICAgIGxldCBwaWQgPSB0aGlzLnRvQjU4U3RyaW5nKClcbiAgICAvLyBBbGwgc2hhMjU2IG5vZGVzIHN0YXJ0IHdpdGggUW1cbiAgICAvLyBXZSBjYW4gc2tpcCB0aGUgUW0gdG8gbWFrZSB0aGUgcGVlci5JRCBtb3JlIHVzZWZ1bFxuICAgIGlmIChwaWQuc3RhcnRzV2l0aCgnUW0nKSkge1xuICAgICAgcGlkID0gcGlkLnNsaWNlKDIpXG4gICAgfVxuICAgIGxldCBtYXhSdW5lcyA9IDZcbiAgICBpZiAocGlkLmxlbmd0aCA8IG1heFJ1bmVzKSB7XG4gICAgICBtYXhSdW5lcyA9IHBpZC5sZW5ndGhcbiAgICB9XG5cbiAgICByZXR1cm4gJzxwZWVyLklEICcgKyBwaWQuc3Vic3RyKDAsIG1heFJ1bmVzKSArICc+J1xuICB9XG5cbiAgLy8gcmV0dXJuIHRoZSBqc29uaWZpZWQgdmVyc2lvbiBvZiB0aGUga2V5LCBtYXRjaGluZyB0aGUgZm9ybWF0dGluZ1xuICAvLyBvZiBnby1pcGZzIGZvciBpdHMgY29uZmlnIGZpbGVcbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMudG9CNThTdHJpbmcoKSxcbiAgICAgIHByaXZLZXk6IHRvQjY0T3B0KHRoaXMubWFyc2hhbFByaXZLZXkoKSksXG4gICAgICBwdWJLZXk6IHRvQjY0T3B0KHRoaXMubWFyc2hhbFB1YktleSgpKVxuICAgIH1cbiAgfVxuXG4gIC8vIGVuY29kZS9kZWNvZGUgZnVuY3Rpb25zXG4gIHRvSGV4U3RyaW5nICgpIHtcbiAgICByZXR1cm4gbWgudG9IZXhTdHJpbmcodGhpcy5pZClcbiAgfVxuXG4gIHRvQnl0ZXMgKCkge1xuICAgIHJldHVybiB0aGlzLmlkXG4gIH1cblxuICB0b0I1OFN0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkQjU4U3RyaW5nXG4gIH1cblxuICBpc0VxdWFsIChpZCkge1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoaWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5pZC5lcXVhbHMoaWQpXG4gICAgfSBlbHNlIGlmIChpZC5pZCkge1xuICAgICAgcmV0dXJuIHRoaXMuaWQuZXF1YWxzKGlkLmlkKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCB2YWxpZCBJZCcpXG4gICAgfVxuICB9XG5cbiAgLypcbiAgICogQ2hlY2sgaWYgdGhpcyBQZWVySWQgaW5zdGFuY2UgaXMgdmFsaWQgKHByaXZLZXkgLT4gcHViS2V5IC0+IElkKVxuICAgKi9cbiAgaXNWYWxpZCAoY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPIE5lZWRzIGJldHRlciBjaGVja2luZ1xuICAgIGlmICh0aGlzLnByaXZLZXkgJiZcbiAgICAgIHRoaXMucHJpdktleS5wdWJsaWMgJiZcbiAgICAgIHRoaXMucHJpdktleS5wdWJsaWMuYnl0ZXMgJiZcbiAgICAgIEJ1ZmZlci5pc0J1ZmZlcih0aGlzLnB1YktleS5ieXRlcykgJiZcbiAgICAgIHRoaXMucHJpdktleS5wdWJsaWMuYnl0ZXMuZXF1YWxzKHRoaXMucHViS2V5LmJ5dGVzKSkge1xuICAgICAgY2FsbGJhY2soKVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0tleXMgbm90IG1hdGNoJykpXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IFBlZXJJZFdpdGhJcyA9IHdpdGhJcyhQZWVySWQsIHsgY2xhc3NOYW1lOiAnUGVlcklkJywgc3ltYm9sTmFtZTogJ0BsaWJwMnAvanMtcGVlci1pZC9QZWVySWQnIH0pXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFBlZXJJZFdpdGhJc1xuXG5jb25zdCBjb21wdXRlRGlnZXN0ID0gKHB1YktleSwgY2IpID0+IHtcbiAgaWYgKHB1YktleS5ieXRlcy5sZW5ndGggPD0gNDIpIHtcbiAgICBjb25zdCBkaWdlc3QgPSBtaC5lbmNvZGUocHViS2V5LmJ5dGVzLCAnaWRlbnRpdHknKVxuICAgIGNiKG51bGwsIGRpZ2VzdClcbiAgfSBlbHNlIHtcbiAgICBwdWJLZXkuaGFzaCgoZXJyLCBkaWdlc3QpID0+IHtcbiAgICAgIGNiKGVyciwgZGlnZXN0KVxuICAgIH0pXG4gIH1cbn1cblxuY29uc3QgY29tcHV0ZVBlZXJJZCA9IChwcml2S2V5LCBwdWJLZXksIGNiKSA9PiB7XG4gIGNvbXB1dGVEaWdlc3QocHViS2V5LCAoZXJyLCBkaWdlc3QpID0+IHtcbiAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgIGNiKGVycilcbiAgICB9IGVsc2Uge1xuICAgICAgY2IobnVsbCwgbmV3IFBlZXJJZFdpdGhJcyhkaWdlc3QsIHByaXZLZXksIHB1YktleSkpXG4gICAgfVxuICB9KVxufVxuXG4vLyBnZW5lcmF0aW9uXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHNcbiAgICBvcHRzID0ge31cbiAgfVxuICBvcHRzID0gb3B0cyB8fCB7fVxuICBvcHRzLmJpdHMgPSBvcHRzLmJpdHMgfHwgMjA0OFxuICBvcHRzLmtleVR5cGUgPSBvcHRzLmtleVR5cGUgfHwgJ1JTQSdcblxuICBjcnlwdG9LZXlzLmdlbmVyYXRlS2V5UGFpcihvcHRzLmtleVR5cGUsIG9wdHMuYml0cywgKGVyciwgcHJpdktleSkgPT4ge1xuICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2soZXJyKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wdXRlUGVlcklkKHByaXZLZXksIHByaXZLZXkucHVibGljLCBjYWxsYmFjaylcbiAgICB9XG4gIH0pXG59XG5cbmV4cG9ydHMuY3JlYXRlRnJvbUhleFN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIG5ldyBQZWVySWRXaXRoSXMobWguZnJvbUhleFN0cmluZyhzdHIpKVxufVxuXG5leHBvcnRzLmNyZWF0ZUZyb21CeXRlcyA9IGZ1bmN0aW9uIChidWYpIHtcbiAgcmV0dXJuIG5ldyBQZWVySWRXaXRoSXMoYnVmKVxufVxuXG5leHBvcnRzLmNyZWF0ZUZyb21CNThTdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBuZXcgUGVlcklkV2l0aElzKG1oLmZyb21CNThTdHJpbmcoc3RyKSlcbn1cblxuLy8gUHVibGljIEtleSBpbnB1dCB3aWxsIGJlIGEgYnVmZmVyXG5leHBvcnRzLmNyZWF0ZUZyb21QdWJLZXkgPSBmdW5jdGlvbiAoa2V5LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsYmFjayBpcyByZXF1aXJlZCcpXG4gIH1cblxuICBsZXQgcHViS2V5XG5cbiAgdHJ5IHtcbiAgICBsZXQgYnVmID0ga2V5XG4gICAgaWYgKHR5cGVvZiBidWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShrZXksICdiYXNlNjQnKVxuICAgIH1cblxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQga2V5IGlzIG5laXRoZXIgYSBiYXNlNjQgc3RyaW5nIG5vciBhIGJ1ZmZlcicpXG5cbiAgICBwdWJLZXkgPSBjcnlwdG9LZXlzLnVubWFyc2hhbFB1YmxpY0tleShidWYpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gIH1cblxuICBjb21wdXRlUGVlcklkKG51bGwsIHB1YktleSwgY2FsbGJhY2spXG59XG5cbi8vIFByaXZhdGUga2V5IGlucHV0IHdpbGwgYmUgYSBzdHJpbmdcbmV4cG9ydHMuY3JlYXRlRnJvbVByaXZLZXkgPSBmdW5jdGlvbiAoa2V5LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsYmFjayBpcyByZXF1aXJlZCcpXG4gIH1cblxuICBsZXQgYnVmID0ga2V5XG5cbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIGJ1ZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGtleSwgJ2Jhc2U2NCcpXG4gICAgfVxuXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCBrZXkgaXMgbmVpdGhlciBhIGJhc2U2NCBzdHJpbmcgbm9yIGEgYnVmZmVyJylcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgfVxuXG4gIGNyeXB0b0tleXMudW5tYXJzaGFsUHJpdmF0ZUtleShidWYsIChlcnIsIHByaXZLZXkpID0+IHtcbiAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgIGNhbGxiYWNrKGVycilcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcHV0ZVBlZXJJZChwcml2S2V5LCBwcml2S2V5LnB1YmxpYywgY2FsbGJhY2spXG4gICAgfVxuICB9KVxufVxuXG5leHBvcnRzLmNyZWF0ZUZyb21KU09OID0gZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGJhY2sgaXMgcmVxdWlyZWQnKVxuICB9XG5cbiAgbGV0IGlkXG4gIGxldCByYXdQcml2S2V5XG4gIGxldCByYXdQdWJLZXlcbiAgbGV0IHB1YlxuXG4gIHRyeSB7XG4gICAgaWQgPSBtaC5mcm9tQjU4U3RyaW5nKG9iai5pZClcbiAgICByYXdQcml2S2V5ID0gb2JqLnByaXZLZXkgJiYgQnVmZmVyLmZyb20ob2JqLnByaXZLZXksICdiYXNlNjQnKVxuICAgIHJhd1B1YktleSA9IG9iai5wdWJLZXkgJiYgQnVmZmVyLmZyb20ob2JqLnB1YktleSwgJ2Jhc2U2NCcpXG4gICAgcHViID0gcmF3UHViS2V5ICYmIGNyeXB0b0tleXMudW5tYXJzaGFsUHVibGljS2V5KHJhd1B1YktleSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgfVxuXG4gIGlmICghcmF3UHJpdktleSkge1xuICAgIGNhbGxiYWNrKG51bGwsIG5ldyBQZWVySWRXaXRoSXMoaWQsIG51bGwsIHB1YikpXG4gICAgcmV0dXJuXG4gIH1cblxuICB3YXRlcmZhbGwoW1xuICAgIChjYikgPT4gY3J5cHRvS2V5cy51bm1hcnNoYWxQcml2YXRlS2V5KHJhd1ByaXZLZXksIGNiKSxcbiAgICAocHJpdiwgY2IpID0+IHtcbiAgICAgIGNvbXB1dGVEaWdlc3QocHJpdi5wdWJsaWMsIChlcnIsIGRpZ2VzdCkgPT4ge1xuICAgICAgICBjYihlcnIsIGRpZ2VzdCwgcHJpdilcbiAgICAgIH0pXG4gICAgfSxcbiAgICAocHJpdkRpZ2VzdCwgcHJpdiwgY2IpID0+IHtcbiAgICAgIGlmIChwdWIpIHtcbiAgICAgICAgY29tcHV0ZURpZ2VzdChwdWIsIChlcnIsIHB1YkRpZ2VzdCkgPT4ge1xuICAgICAgICAgIGNiKGVyciwgcHJpdkRpZ2VzdCwgcHJpdiwgcHViRGlnZXN0KVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IobnVsbCwgcHJpdkRpZ2VzdCwgcHJpdilcbiAgICAgIH1cbiAgICB9XG4gIF0sIChlcnIsIHByaXZEaWdlc3QsIHByaXYsIHB1YkRpZ2VzdCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuXG4gICAgaWYgKHB1YiAmJiAhcHJpdkRpZ2VzdC5lcXVhbHMocHViRGlnZXN0KSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignUHVibGljIGFuZCBwcml2YXRlIGtleSBkbyBub3QgbWF0Y2gnKSlcbiAgICB9XG5cbiAgICBpZiAoaWQgJiYgIXByaXZEaWdlc3QuZXF1YWxzKGlkKSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignSWQgYW5kIHByaXZhdGUga2V5IGRvIG5vdCBtYXRjaCcpKVxuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIG5ldyBQZWVySWRXaXRoSXMoaWQsIHByaXYsIHB1YikpXG4gIH0pXG59XG5cbmV4cG9ydHMuaXNQZWVySWQgPSBmdW5jdGlvbiAocGVlcklkKSB7XG4gIHJldHVybiBCb29sZWFuKHR5cGVvZiBwZWVySWQgPT09ICdvYmplY3QnICYmXG4gICAgcGVlcklkLl9pZCAmJlxuICAgIHBlZXJJZC5faWRCNThTdHJpbmcpXG59XG5cbmZ1bmN0aW9uIHRvQjY0T3B0ICh2YWwpIHtcbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB2YWwudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdhc3luYy9zZXRJbW1lZGlhdGUnKVxuY29uc3QgcmV0cnkgPSByZXF1aXJlKCdhc3luYy9yZXRyeScpXG5jb25zdCB0b1VyaSA9IHJlcXVpcmUoJ211bHRpYWRkci10by11cmknKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcbmNvbnN0IHByZWxvYWQgPSByZXF1aXJlKCcuL3J1bnRpbWUvcHJlbG9hZC1ub2RlanMnKVxuXG5jb25zdCBsb2cgPSBkZWJ1ZygnaXBmczpwcmVsb2FkJylcbmxvZy5lcnJvciA9IGRlYnVnKCdpcGZzOnByZWxvYWQ6ZXJyb3InKVxuXG5jb25zdCBub29wID0gKGVycikgPT4geyBpZiAoZXJyKSBsb2cuZXJyb3IoZXJyKSB9XG5cbm1vZHVsZS5leHBvcnRzID0gc2VsZiA9PiB7XG4gIGNvbnN0IG9wdGlvbnMgPSBzZWxmLl9vcHRpb25zLnByZWxvYWQgfHwge31cbiAgb3B0aW9ucy5lbmFibGVkID0gQm9vbGVhbihvcHRpb25zLmVuYWJsZWQpXG4gIG9wdGlvbnMuYWRkcmVzc2VzID0gb3B0aW9ucy5hZGRyZXNzZXMgfHwgW11cblxuICBpZiAoIW9wdGlvbnMuZW5hYmxlZCB8fCAhb3B0aW9ucy5hZGRyZXNzZXMubGVuZ3RoKSB7XG4gICAgbG9nKCdwcmVsb2FkIGRpc2FibGVkJylcbiAgICBjb25zdCBhcGkgPSAoXywgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2soKSlcbiAgICAgIH1cbiAgICB9XG4gICAgYXBpLnN0YXJ0ID0gKCkgPT4ge31cbiAgICBhcGkuc3RvcCA9ICgpID0+IHt9XG4gICAgcmV0dXJuIGFwaVxuICB9XG5cbiAgbGV0IHN0b3BwZWQgPSB0cnVlXG4gIGxldCByZXF1ZXN0cyA9IFtdXG4gIGNvbnN0IGFwaVVyaXMgPSBvcHRpb25zLmFkZHJlc3Nlcy5tYXAoYXBpQWRkclRvVXJpKVxuXG4gIGNvbnN0IGFwaSA9IChjaWQsIGNhbGxiYWNrKSA9PiB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wXG5cbiAgICBpZiAodHlwZW9mIGNpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNpZCA9IG5ldyBDSUQoY2lkKS50b0Jhc2VFbmNvZGVkU3RyaW5nKClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKGVycikpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZmFsbGJhY2tBcGlVcmlzID0gQXJyYXkuZnJvbShhcGlVcmlzKVxuICAgIGxldCByZXF1ZXN0XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuXG4gICAgcmV0cnkoeyB0aW1lczogZmFsbGJhY2tBcGlVcmlzLmxlbmd0aCB9LCAoY2IpID0+IHtcbiAgICAgIGlmIChzdG9wcGVkKSByZXR1cm4gY2IobmV3IEVycm9yKGBwcmVsb2FkIGFib3J0ZWQgZm9yICR7Y2lkfWApKVxuXG4gICAgICAvLyBSZW1vdmUgZmFpbGVkIHJlcXVlc3QgZnJvbSBhIHByZXZpb3VzIGF0dGVtcHRcbiAgICAgIHJlcXVlc3RzID0gcmVxdWVzdHMuZmlsdGVyKHIgPT4gciAhPT0gcmVxdWVzdClcblxuICAgICAgY29uc3QgYXBpVXJpID0gZmFsbGJhY2tBcGlVcmlzLnNoaWZ0KClcblxuICAgICAgcmVxdWVzdCA9IHByZWxvYWQoYCR7YXBpVXJpfS9hcGkvdjAvcmVmcz9yPXRydWUmYXJnPSR7Y2lkfWAsIGNiKVxuICAgICAgcmVxdWVzdHMgPSByZXF1ZXN0cy5jb25jYXQocmVxdWVzdClcbiAgICB9LCAoZXJyKSA9PiB7XG4gICAgICByZXF1ZXN0cyA9IHJlcXVlc3RzLmZpbHRlcihyID0+IHIgIT09IHJlcXVlc3QpXG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgbG9nKGBwcmVsb2FkZWQgJHtjaWR9IGluICR7RGF0ZS5ub3coKSAtIG5vd31tc2ApXG4gICAgICBjYWxsYmFjaygpXG4gICAgfSlcbiAgfVxuXG4gIGFwaS5zdGFydCA9ICgpID0+IHtcbiAgICBzdG9wcGVkID0gZmFsc2VcbiAgfVxuXG4gIGFwaS5zdG9wID0gKCkgPT4ge1xuICAgIHN0b3BwZWQgPSB0cnVlXG4gICAgbG9nKGBjYW5jZWxpbmcgJHtyZXF1ZXN0cy5sZW5ndGh9IHBlbmRpbmcgcHJlbG9hZCByZXF1ZXN0KHMpYClcbiAgICByZXF1ZXN0cy5mb3JFYWNoKHIgPT4gci5jYW5jZWwoKSlcbiAgICByZXF1ZXN0cyA9IFtdXG4gIH1cblxuICByZXR1cm4gYXBpXG59XG5cbmZ1bmN0aW9uIGFwaUFkZHJUb1VyaSAoYWRkcikge1xuICBpZiAoIShhZGRyLmVuZHNXaXRoKCdodHRwJykgfHwgYWRkci5lbmRzV2l0aCgnaHR0cHMnKSkpIHtcbiAgICBhZGRyID0gYWRkciArICcvaHR0cCdcbiAgfVxuICByZXR1cm4gdG9VcmkoYWRkcilcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBCbG9jayA9IHJlcXVpcmUoJ2lwZnMtYmxvY2snKVxuY29uc3QgQ0lEID0gcmVxdWlyZSgnY2lkcycpXG5jb25zdCBtZXJnZU9wdGlvbnMgPSByZXF1aXJlKCdtZXJnZS1vcHRpb25zJylcbmNvbnN0IGlwbGREYWdDYm9yID0gcmVxdWlyZSgnaXBsZC1kYWctY2JvcicpXG5jb25zdCBpcGxkRGFnUGIgPSByZXF1aXJlKCdpcGxkLWRhZy1wYicpXG5jb25zdCBpcGxkUmF3ID0gcmVxdWlyZSgnaXBsZC1yYXcnKVxuY29uc3QgbXVsdGljb2RlYyA9IHJlcXVpcmUoJ211bHRpY29kZWMnKVxuY29uc3QgcHJvbWlzaWZ5ID0gcmVxdWlyZSgncHJvbWlzaWZ5LWVzNicpXG5jb25zdCB0eXBpY2FsID0gcmVxdWlyZSgndHlwaWNhbCcpXG5jb25zdCB7IGV4dGVuZEl0ZXJhdG9yIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuXG5jbGFzcyBJUExEUmVzb2x2ZXIge1xuICBjb25zdHJ1Y3RvciAodXNlck9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRpb25zID0gbWVyZ2VPcHRpb25zKElQTERSZXNvbHZlci5kZWZhdWx0T3B0aW9ucywgdXNlck9wdGlvbnMpXG5cbiAgICBpZiAoIW9wdGlvbnMuYmxvY2tTZXJ2aWNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgYmxvY2tzZXJ2aWNlJylcbiAgICB9XG4gICAgdGhpcy5icyA9IG9wdGlvbnMuYmxvY2tTZXJ2aWNlXG5cbiAgICAvLyBPYmplY3Qgd2l0aCBjdXJyZW50IGxpc3Qgb2YgYWN0aXZlIHJlc29sdmVyc1xuICAgIHRoaXMucmVzb2x2ZXJzID0ge31cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2FkRm9ybWF0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmxvYWRGb3JtYXQgPSBhc3luYyAoY29kZWMpID0+IHtcbiAgICAgICAgY29uc3QgY29kZWNOYW1lID0gbXVsdGljb2RlYy5wcmludFtjb2RlY11cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyByZXNvbHZlciBmb3VuZCBmb3IgY29kZWMgXCIke2NvZGVjTmFtZX1cImApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9hZEZvcm1hdCA9IG9wdGlvbnMubG9hZEZvcm1hdFxuICAgIH1cblxuICAgIC8vIEVuYWJsZSBhbGwgc3VwcGxpZWQgZm9ybWF0c1xuICAgIGZvciAoY29uc3QgZm9ybWF0IG9mIG9wdGlvbnMuZm9ybWF0cykge1xuICAgICAgdGhpcy5hZGRGb3JtYXQoZm9ybWF0KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgc3VwcG9ydCBmb3IgYW4gSVBMRCBGb3JtYXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmb3JtYXQgLSBUaGUgaW1wbGVtZW50YXRpb24gb2YgYW4gSVBMRCBGb3JtYXQuXG4gICAqIEByZXR1cm5zIHt0aGlzfVxuICAgKi9cbiAgYWRkRm9ybWF0IChmb3JtYXQpIHtcbiAgICBjb25zdCBjb2RlYyA9IGZvcm1hdC5jb2RlY1xuICAgIGlmICh0aGlzLnJlc29sdmVyc1tmb3JtYXQuZm9ybWF0XSkge1xuICAgICAgY29uc3QgY29kZWNOYW1lID0gbXVsdGljb2RlYy5wcmludFtjb2RlY11cbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVzb2x2ZXIgYWxyZWFkeSBleGlzdHMgZm9yIGNvZGVjIFwiJHtjb2RlY05hbWV9XCJgKVxuICAgIH1cblxuICAgIHRoaXMucmVzb2x2ZXJzW2NvZGVjXSA9IGZvcm1hdFxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgc3VwcG9ydCBmb3IgYW4gSVBMRCBGb3JtYXQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlYyAtIFRoZSBjb2RlYyBvZiB0aGUgSVBMRCBGb3JtYXQgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICovXG4gIHJlbW92ZUZvcm1hdCAoY29kZWMpIHtcbiAgICBpZiAodGhpcy5yZXNvbHZlcnNbY29kZWNdKSB7XG4gICAgICBkZWxldGUgdGhpcy5yZXNvbHZlcnNbY29kZWNdXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgSVBMRCBOb2RlcyBhbG9uZyB0aGUgYHBhdGhgIHRoYXQgaXMgcm9vdGVkIGF0IGBjaWRgLlxuICAgKlxuICAgKiBAcGFyYW0ge0NJRH0gY2lkIC0gdGhlIENJRCB0aGUgcmVzb2x2aW5nIHN0YXJ0cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSB0aGUgcGF0aCB0aGF0IHNob3VsZCBiZSByZXNvbHZlZC5cbiAgICogQHJldHVybnMge0l0ZXJhYmxlLjxQcm9taXNlLjx7cmVtYWluZGVyUGF0aDogc3RyaW5nLCB2YWx1ZX0+Pn0gLSBSZXR1cm5zIGFuIGFzeW5jIGl0ZXJhdG9yIG9mIGFsbCB0aGUgSVBMRCBOb2RlcyB0aGF0IHdlcmUgdHJhdmVyc2VkIGR1cmluZyB0aGUgcGF0aCByZXNvbHZpbmcuIEV2ZXJ5IGVsZW1lbnQgaXMgYW4gb2JqZWN0IHdpdGggdGhlc2UgZmllbGRzOlxuICAgKiAgIC0gYHJlbWFpbmRlclBhdGhgOiB0aGUgcGFydCBvZiB0aGUgcGF0aCB0aGF0IHdhc27igJl0IHJlc29sdmVkIHlldC5cbiAgICogICAtIGB2YWx1ZWA6IHRoZSB2YWx1ZSB3aGVyZSB0aGUgcmVzb2x2ZWQgcGF0aCBwb2ludHMgdG8uIElmIGZ1cnRoZXIgdHJhdmVyc2luZyBpcyBwb3NzaWJsZSwgdGhlbiB0aGUgdmFsdWUgaXMgYSBDSUQgb2JqZWN0IGxpbmtpbmcgdG8gYW5vdGhlciBJUExEIE5vZGUuIElmIGl0IHdhcyBwb3NzaWJsZSB0byBmdWxseSByZXNvbHZlIHRoZSBwYXRoLCB2YWx1ZSBpcyB0aGUgdmFsdWUgdGhlIHBhdGggcG9pbnRzIHRvLiBTbyBpZiB5b3UgbmVlZCB0aGUgQ0lEIG9mIHRoZSBJUExEIE5vZGUgeW914oCZcmUgY3VycmVudGx5IGF0LCBqdXN0IHRha2UgdGhlIHZhbHVlIG9mIHRoZSBwcmV2aW91c2x5IHJldHVybmVkIElQTEQgTm9kZS5cbiAgICovXG4gIHJlc29sdmUgKGNpZCwgcGF0aCkge1xuICAgIGlmICghQ0lELmlzQ0lEKGNpZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYGNpZGAgYXJndW1lbnQgbXVzdCBiZSBhIENJRCcpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHBhdGhgIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cblxuICAgIGNvbnN0IGdlbmVyYXRvciA9IGFzeW5jIGZ1bmN0aW9uICogKCkge1xuICAgICAgLy8gRW5kIGl0ZXJhdGlvbiBpZiB0aGVyZSBpc24ndCBhIENJRCB0byBmb2xsb3cgYW55bW9yZVxuICAgICAgd2hpbGUgKGNpZCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBmb3JtYXQgPSBhd2FpdCB0aGlzLl9nZXRGb3JtYXQoY2lkLmNvZGVjKVxuXG4gICAgICAgIC8vIGdldCBibG9ja1xuICAgICAgICAvLyB1c2UgbG9jYWwgcmVzb2x2ZXJcbiAgICAgICAgLy8gdXBkYXRlIHBhdGggdmFsdWVcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCBwcm9taXNpZnkodGhpcy5icy5nZXQuYmluZCh0aGlzLmJzKSkoY2lkKVxuICAgICAgICBjb25zdCByZXN1bHQgPSBmb3JtYXQucmVzb2x2ZXIucmVzb2x2ZShibG9jay5kYXRhLCBwYXRoKVxuXG4gICAgICAgIC8vIFByZXBhcmUgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbiBpZiB0aGVyZSBpcyBhIGByZW1haW5kZXJQYXRoYFxuICAgICAgICBwYXRoID0gcmVzdWx0LnJlbWFpbmRlclBhdGhcbiAgICAgICAgbGV0IHZhbHVlID0gcmVzdWx0LnZhbHVlXG4gICAgICAgIC8vIE5PVEUgdm14IDIwMTgtMTEtMjk6IE5vdCBhbGwgSVBMRCBGb3JtYXRzIHJldHVybiBsaW5rcyBhc1xuICAgICAgICAvLyBDSURzIHlldC4gSGVuY2UgdHJ5IHRvIGNvbnZlcnQgb2xkIHN0eWxlIGxpbmtzIHRvIENJRHNcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDEgJiYgJy8nIGluIHZhbHVlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IENJRCh2YWx1ZVsnLyddKVxuICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgdmFsdWUgPSBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNpZCA9IENJRC5pc0NJRCh2YWx1ZSkgPyB2YWx1ZSA6IG51bGxcblxuICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgcmVtYWluZGVyUGF0aDogcGF0aCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpXG5cbiAgICByZXR1cm4gZXh0ZW5kSXRlcmF0b3IoZ2VuZXJhdG9yKCkpXG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgbm9kZSBieSBDSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q0lEfSBjaWQgLSBUaGUgQ0lEIG9mIHRoZSBJUExEIE5vZGUgdGhhdCBzaG91bGQgYmUgcmV0cmlldmVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48T2JqZWN0Pn0gLSBSZXR1cm5zIGEgUHJvbWlzZSB3aXRoIHRoZSBJUExEIE5vZGUgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBnaXZlbiBgY2lkYC5cbiAgICovXG4gIGFzeW5jIGdldCAoY2lkKSB7XG4gICAgY29uc3QgYmxvY2sgPSBhd2FpdCBwcm9taXNpZnkodGhpcy5icy5nZXQuYmluZCh0aGlzLmJzKSkoY2lkKVxuICAgIGNvbnN0IGZvcm1hdCA9IGF3YWl0IHRoaXMuX2dldEZvcm1hdChibG9jay5jaWQuY29kZWMpXG4gICAgY29uc3Qgbm9kZSA9IGZvcm1hdC51dGlsLmRlc2VyaWFsaXplKGJsb2NrLmRhdGEpXG5cbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBtdWx0aXBsZSBub2RlcyBiYWNrIGZyb20gYW4gYXJyYXkgb2YgQ0lEcy5cbiAgICpcbiAgICogQHBhcmFtIHtJdGVyYWJsZS48Q0lEPn0gY2lkcyAtIFRoZSBDSURzIG9mIHRoZSBJUExEIE5vZGVzIHRoYXQgc2hvdWxkIGJlIHJldHJpZXZlZC5cbiAgICogQHJldHVybnMge0l0ZXJhYmxlLjxQcm9taXNlLjxPYmplY3Q+Pn0gLSBSZXR1cm5zIGFuIGFzeW5jIGl0ZXJhdG9yIHdpdGggdGhlIElQTEQgTm9kZXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBnaXZlbiBgY2lkc2AuXG4gICAqL1xuICBnZXRNYW55IChjaWRzKSB7XG4gICAgaWYgKCF0eXBpY2FsLmlzSXRlcmFibGUoY2lkcykgfHwgdHlwZW9mIGNpZHMgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIEJ1ZmZlci5pc0J1ZmZlcihjaWRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgY2lkc2AgbXVzdCBiZSBhbiBpdGVyYWJsZSBvZiBDSURzJylcbiAgICB9XG5cbiAgICBjb25zdCBnZW5lcmF0b3IgPSBhc3luYyBmdW5jdGlvbiAqICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgY2lkIG9mIGNpZHMpIHtcbiAgICAgICAgeWllbGQgdGhpcy5nZXQoY2lkKVxuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKVxuXG4gICAgcmV0dXJuIGV4dGVuZEl0ZXJhdG9yKGdlbmVyYXRvcigpKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgZ2l2ZW4gSVBMRCBOb2RlIG9mIGEgcmVjb2duaXplZCBJUExEIEZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgLSBUaGUgZGVzZXJpYWxpemVkIElQTEQgbm9kZSB0aGF0IHNob3VsZCBiZSBpbnNlcnRlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZvcm1hdCAtIFRoZSBtdWx0aWNvZGVjIG9mIHRoZSBmb3JtYXQgdGhhdCBJUExEIE5vZGUgc2hvdWxkIGJlIGVuY29kZWQgaW4uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbdXNlck9wdGlvbnNdIC0gIE9wdGlvbnMgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3VzZXJPdGlvbnMuaGFzaEFsZz1oYXNoIGFsZ29yaXRobSBvZiB0aGUgZ2l2ZW4gbXVsdGljb2RlY10gLSBUaGUgaGFzaGluZyBhbGdvcml0aG0gdGhhdCBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgQ0lELlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3VzZXJPcHRpb25zLmNpZFZlcnNpb249MV0gLSBUaGUgQ0lEIHZlcnNpb24gdG8gdXNlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VyT3B0aW9ucy5vbmx5SGFzaD1mYWxzZV0gLSBJZiB0cnVlIHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIElQTEQgTm9kZSB3aWxsIG5vdCBiZSBwYXNzZWQgdG8gdGhlIHVuZGVybHlpbmcgYmxvY2sgc3RvcmUuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlLjxDSUQ+fSAtIFJldHVybnMgdGhlIENJRCBvZiB0aGUgc2VyaWFsaXplZCBJUExEIE5vZGVzLlxuICAgKi9cbiAgYXN5bmMgcHV0IChub2RlLCBmb3JtYXQsIHVzZXJPcHRpb25zKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BwdXRgIHJlcXVpcmVzIGEgZm9ybWF0JylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmb3JtYXQgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bmb3JtYXRgIHBhcmFtZXRlciBtdXN0IGJlIG51bWJlciAobXVsdGljb2RlYyknKVxuICAgIH1cblxuICAgIGNvbnN0IGZvcm1hdEltcGwgPSBhd2FpdCB0aGlzLl9nZXRGb3JtYXQoZm9ybWF0KVxuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgaGFzaEFsZzogZm9ybWF0SW1wbC5kZWZhdWx0SGFzaEFsZyxcbiAgICAgIGNpZFZlcnNpb246IDEsXG4gICAgICBvbmx5SGFzaDogZmFsc2VcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhkZWZhdWx0T3B0aW9ucywgdXNlck9wdGlvbnMpXG5cbiAgICBjb25zdCBjaWRPcHRpb25zID0ge1xuICAgICAgY2lkVmVyc2lvbjogb3B0aW9ucy5jaWRWZXJzaW9uLFxuICAgICAgaGFzaEFsZzogb3B0aW9ucy5oYXNoQWxnLFxuICAgICAgb25seUhhc2g6IG9wdGlvbnMub25seUhhc2hcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IGZvcm1hdEltcGwudXRpbC5zZXJpYWxpemUobm9kZSlcbiAgICBjb25zdCBjaWQgPSBhd2FpdCBmb3JtYXRJbXBsLnV0aWwuY2lkKHNlcmlhbGl6ZWQsIGNpZE9wdGlvbnMpXG5cbiAgICBpZiAoIW9wdGlvbnMub25seUhhc2gpIHtcbiAgICAgIGNvbnN0IGJsb2NrID0gbmV3IEJsb2NrKHNlcmlhbGl6ZWQsIGNpZClcbiAgICAgIGF3YWl0IHByb21pc2lmeSh0aGlzLmJzLnB1dC5iaW5kKHRoaXMuYnMpKShibG9jaylcbiAgICB9XG5cbiAgICByZXR1cm4gY2lkXG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIHRoZSBnaXZlbiBJUExEIE5vZGVzIG9mIGEgcmVjb2duaXplZCBJUExEIEZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHtJdGVyYWJsZS48T2JqZWN0Pn0gbm9kZXMgLSBEZXNlcmlhbGl6ZWQgSVBMRCBub2RlcyB0aGF0IHNob3VsZCBiZSBpbnNlcnRlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZvcm1hdCAtIFRoZSBtdWx0aWNvZGVjIG9mIHRoZSBmb3JtYXQgdGhhdCBJUExEIE5vZGUgc2hvdWxkIGJlIGVuY29kZWQgaW4uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbdXNlck9wdGlvbnNdIC0gIE9wdGlvbnMgYXJlIGFwcGxpZWQgdG8gYW55IG9mIHRoZSBgbm9kZXNgIGFuZCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdXNlck90aW9ucy5oYXNoQWxnPWhhc2ggYWxnb3JpdGhtIG9mIHRoZSBnaXZlbiBtdWx0aWNvZGVjXSAtIFRoZSBoYXNoaW5nIGFsZ29yaXRobSB0aGF0IGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBDSUQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdXNlck9wdGlvbnMuY2lkVmVyc2lvbj0xXSAtIFRoZSBDSUQgdmVyc2lvbiB0byB1c2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZXJPcHRpb25zLm9ubHlIYXNoPWZhbHNlXSAtIElmIHRydWUgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgSVBMRCBOb2RlIHdpbGwgbm90IGJlIHBhc3NlZCB0byB0aGUgdW5kZXJseWluZyBibG9jayBzdG9yZS5cbiAgICogQHJldHVybnMge0l0ZXJhYmxlLjxQcm9taXNlLjxDSUQ+Pn0gLSBSZXR1cm5zIGFuIGFzeW5jIGl0ZXJhdG9yIHdpdGggdGhlIENJRHMgb2YgdGhlIHNlcmlhbGl6ZWQgSVBMRCBOb2Rlcy5cbiAgICovXG4gIHB1dE1hbnkgKG5vZGVzLCBmb3JtYXQsIHVzZXJPcHRpb25zKSB7XG4gICAgaWYgKCF0eXBpY2FsLmlzSXRlcmFibGUobm9kZXMpIHx8IHR5cGVvZiBub2RlcyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgQnVmZmVyLmlzQnVmZmVyKG5vZGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgbm9kZXNgIG11c3QgYmUgYW4gaXRlcmFibGUnKVxuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHB1dGAgcmVxdWlyZXMgYSBmb3JtYXQnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGZvcm1hdCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYGZvcm1hdGAgcGFyYW1ldGVyIG11c3QgYmUgbnVtYmVyIChtdWx0aWNvZGVjKScpXG4gICAgfVxuXG4gICAgbGV0IG9wdGlvbnNcbiAgICBsZXQgZm9ybWF0SW1wbFxuXG4gICAgY29uc3QgZ2VuZXJhdG9yID0gYXN5bmMgZnVuY3Rpb24gKiAoKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgLy8gTGF6eSBsb2FkIHRoZSBvcHRpb25zIG5vdCB3aGVuIHRoZSBpdGVyYXRvciBpcyBpbml0aWFsaXplZCwgYnV0XG4gICAgICAgIC8vIHdoZW4gd2UgaGl0IHRoZSBmaXJzdCBpdGVyYXRpb24uIFRoaXMgd2F5IHRoZSBjb25zdHJ1Y3RvciBjYW4gYmVcbiAgICAgICAgLy8gYSBzeW5jaHJvbm91cyBmdW5jdGlvbi5cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvcm1hdEltcGwgPSBhd2FpdCB0aGlzLl9nZXRGb3JtYXQoZm9ybWF0KVxuICAgICAgICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICAgICAgaGFzaEFsZzogZm9ybWF0SW1wbC5kZWZhdWx0SGFzaEFsZyxcbiAgICAgICAgICAgIGNpZFZlcnNpb246IDEsXG4gICAgICAgICAgICBvbmx5SGFzaDogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhkZWZhdWx0T3B0aW9ucywgdXNlck9wdGlvbnMpXG4gICAgICAgIH1cblxuICAgICAgICB5aWVsZCB0aGlzLnB1dChub2RlLCBmb3JtYXQsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpXG5cbiAgICByZXR1cm4gZXh0ZW5kSXRlcmF0b3IoZ2VuZXJhdG9yKCkpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIElQTEQgTm9kZSBieSB0aGUgZ2l2ZW4gQ0lELlxuICAgKlxuICAgKiBAcGFyYW0ge0NJRH0gY2lkIC0gVGhlIENJRCBvZiB0aGUgSVBMRCBOb2RlIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWQuXG4gICAqIEByZXR1cm4ge1Byb21pc2UuPENJRD59IFRoZSBDSUQgb2YgdGhlIHJlbW92ZWQgSVBMRCBOb2RlLlxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlIChjaWQpIHtcbiAgICByZXR1cm4gcHJvbWlzaWZ5KHRoaXMuYnMuZGVsZXRlLmJpbmQodGhpcy5icykpKGNpZClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgSVBMRCBOb2RlcyBieSB0aGUgZ2l2ZW4gQ0lEcy5cbiAgICpcbiAgICogVGhyb3dzIGFuIGVycm9yIGlmIGFueSBvZiB0aGUgQmxvY2tzIGNhbuKAmXQgYmUgcmVtb3ZlZC4gVGhpcyBvcGVyYXRpb24gaXNcbiAgICogKm5vdCogYXRvbWljLCBzb21lIEJsb2NrcyBtaWdodCBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0l0ZXJhYmxlLjxDSUQ+fSBjaWRzIC0gVGhlIENJRHMgb2YgdGhlIElQTEQgTm9kZXMgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICogQHJldHVybiB7SXRlcmFibGUuPFByb21pc2UuPENJRD4+fSBSZXR1cm5zIGFuIGFzeW5jIGl0ZXJhdG9yIHdpdGggdGhlIENJRHMgb2YgdGhlIHJlbW92ZWQgSVBMRCBOb2Rlcy5cbiAgICovXG4gIHJlbW92ZU1hbnkgKGNpZHMpIHtcbiAgICBpZiAoIXR5cGljYWwuaXNJdGVyYWJsZShjaWRzKSB8fCB0eXBlb2YgY2lkcyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgQnVmZmVyLmlzQnVmZmVyKGNpZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BjaWRzYCBtdXN0IGJlIGFuIGl0ZXJhYmxlIG9mIENJRHMnKVxuICAgIH1cblxuICAgIGNvbnN0IGdlbmVyYXRvciA9IGFzeW5jIGZ1bmN0aW9uICogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBjaWQgb2YgY2lkcykge1xuICAgICAgICB5aWVsZCB0aGlzLnJlbW92ZShjaWQpXG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpXG5cbiAgICByZXR1cm4gZXh0ZW5kSXRlcmF0b3IoZ2VuZXJhdG9yKCkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgdGhlIHBhdGhzIHRoYXQgY2FuIGJlIHJlc29sdmVkIGludG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjaWQgLSBUaGUgSUQgdG8gZ2V0IHRoZSBwYXRocyBmcm9tXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb2Zmc2V0UGF0aD0nJ10gLSB0aGUgcGF0aCB0byBzdGFydCB0byByZXRyaWV2ZSB0aGUgb3RoZXIgcGF0aHMgZnJvbS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFt1c2VyT3B0aW9uc11cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt1c2VyT3B0aW9ucy5yZWN1cnNpdmU9ZmFsc2VdIC0gd2hldGhlciB0byBnZXQgdGhlIHBhdGhzIHJlY3Vyc2l2ZWx5IG9yIG5vdC4gYGZhbHNlYCByZXNvbHZlcyBvbmx5IHRoZSBwYXRocyBvZiB0aGUgZ2l2ZW4gQ0lELlxuICAgKiBAcmV0dXJucyB7SXRlcmFibGUuPFByb21pc2UuPFN0cmluZz4+fSAtIFJldHVybnMgYW4gYXN5bmMgaXRlcmF0b3Igd2l0aCBwYXRocyB0aGF0IGNhbiBiZSByZXNvbHZlZCBpbnRvXG4gICAqL1xuICB0cmVlIChjaWQsIG9mZnNldFBhdGgsIHVzZXJPcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvZmZzZXRQYXRoID09PSAnb2JqZWN0Jykge1xuICAgICAgdXNlck9wdGlvbnMgPSBvZmZzZXRQYXRoXG4gICAgICBvZmZzZXRQYXRoID0gdW5kZWZpbmVkXG4gICAgfVxuICAgIG9mZnNldFBhdGggPSBvZmZzZXRQYXRoIHx8ICcnXG5cbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHJlY3Vyc2l2ZTogZmFsc2VcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhkZWZhdWx0T3B0aW9ucywgdXNlck9wdGlvbnMpXG5cbiAgICAvLyBJZiBhIHBhdGggaXMgYSBsaW5rIHRoZW4gZm9sbG93IGl0IGFuZCByZXR1cm4gaXRzIENJRFxuICAgIGNvbnN0IG1heWJlUmVjdXJzZSA9IGFzeW5jIChibG9jaywgdHJlZVBhdGgpID0+IHtcbiAgICAgIC8vIEEgdHJlZXBhdGggd2UgbWlnaHQgd2FudCB0byBmb2xsb3cgcmVjdXJzaXZlbHlcbiAgICAgIGNvbnN0IGZvcm1hdCA9IGF3YWl0IHRoaXMuX2dldEZvcm1hdChibG9jay5jaWQuY29kZWMpXG4gICAgICBjb25zdCByZXN1bHQgPSBmb3JtYXQucmVzb2x2ZXIucmVzb2x2ZShibG9jay5kYXRhLCB0cmVlUGF0aClcbiAgICAgIC8vIFNvbWV0aGluZyB0byBmb2xsb3cgcmVjdXNpdmVseSwgaGVuY2UgcHVzaCBpdCBpbnRvIHRoZSBxdWV1ZVxuICAgICAgaWYgKENJRC5pc0NJRChyZXN1bHQudmFsdWUpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQudmFsdWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZ2VuZXJhdG9yID0gYXN5bmMgZnVuY3Rpb24gKiAoKSB7XG4gICAgICAvLyBUaGUgbGlzdCBvZiBwYXRocyB0aGF0IHdpbGwgZ2V0IHJldHVybmVkXG4gICAgICBjb25zdCB0cmVlUGF0aHMgPSBbXVxuICAgICAgLy8gVGhlIGN1cnJlbnQgYmxvY2ssIG5lZWRlZCB0byBjYWxsIGBpc0xpbmsoKWAgb24gZXZlcnkgaW50ZXJhdGlvblxuICAgICAgbGV0IGJsb2NrXG4gICAgICAvLyBUaGUgbGlzdCBvZiBpdGVtcyB3ZSB3YW50IHRvIGZvbGxvdyByZWN1cnNpdmVseS4gVGhlIGl0ZW1zIGFyZVxuICAgICAgLy8gYW4gb2JqZWN0IGNvbnNpc3Rpbmcgb2YgdGhlIENJRCBhbmQgdGhlIGN1cnJlbnRseSBhbHJlYWR5IHJlc29sdmVkXG4gICAgICAvLyBwYXRoXG4gICAgICBjb25zdCBxdWV1ZSA9IFt7IGNpZCwgYmFzZVBhdGg6ICcnIH1dXG4gICAgICAvLyBUaGUgcGF0aCB0aGF0IHdhcyBhbHJlYWR5IHRyYXZlcnNlZFxuICAgICAgbGV0IGJhc2VQYXRoXG5cbiAgICAgIC8vIEVuZCBvZiBpdGVyYXRpb24gaWYgdGhlcmUgYXJlbid0IGFueSBwYXRocyBsZWZ0IHRvIHJldHVybiBvclxuICAgICAgLy8gaWYgd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZSByZWN1cnNpdmVseSBhbmQgaGF2ZSBhbHJlYWR5XG4gICAgICAvLyByZXR1cm5lIHRoZSBmaXJzdCBsZXZlbFxuICAgICAgd2hpbGUgKHRyZWVQYXRocy5sZW5ndGggPiAwIHx8IHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlbid0IGFueSBwYXRocyBsZWZ0LCBnZXQgdGhlbSBmcm9tIHRoZSBnaXZlbiBDSURcbiAgICAgICAgaWYgKHRyZWVQYXRocy5sZW5ndGggPT09IDAgJiYgcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICh7IGNpZCwgYmFzZVBhdGggfSA9IHF1ZXVlLnNoaWZ0KCkpXG4gICAgICAgICAgY29uc3QgZm9ybWF0ID0gYXdhaXQgdGhpcy5fZ2V0Rm9ybWF0KGNpZC5jb2RlYylcbiAgICAgICAgICBibG9jayA9IGF3YWl0IHByb21pc2lmeSh0aGlzLmJzLmdldC5iaW5kKHRoaXMuYnMpKShjaWQpXG5cbiAgICAgICAgICBjb25zdCBwYXRocyA9IGZvcm1hdC5yZXNvbHZlci50cmVlKGJsb2NrLmRhdGEpXG4gICAgICAgICAgdHJlZVBhdGhzLnB1c2goLi4ucGF0aHMpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0cmVlUGF0aCA9IHRyZWVQYXRocy5zaGlmdCgpXG4gICAgICAgIGxldCBmdWxsUGF0aCA9IGJhc2VQYXRoICsgdHJlZVBhdGhcblxuICAgICAgICAvLyBPbmx5IGZvbGxvdyBsaW5rcyBpZiByZWN1cnNpb24gaXMgaW50ZW5kZWRcbiAgICAgICAgaWYgKG9wdGlvbnMucmVjdXJzaXZlKSB7XG4gICAgICAgICAgY2lkID0gYXdhaXQgbWF5YmVSZWN1cnNlKGJsb2NrLCB0cmVlUGF0aClcbiAgICAgICAgICBpZiAoY2lkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKHsgY2lkLCBiYXNlUGF0aDogZnVsbFBhdGggKyAnLycgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gaXQgaWYgaXQgbWF0Y2hlcyB0aGUgZ2l2ZW4gb2Zmc2V0IHBhdGgsIGJ1dCBpcyBub3QgdGhlXG4gICAgICAgIC8vIG9mZnNldCBwYXRoIGl0c2VsZlxuICAgICAgICBpZiAoZnVsbFBhdGguc3RhcnRzV2l0aChvZmZzZXRQYXRoKSAmJlxuICAgICAgICAgICAgZnVsbFBhdGgubGVuZ3RoID4gb2Zmc2V0UGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAob2Zmc2V0UGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmdWxsUGF0aCA9IGZ1bGxQYXRoLnNsaWNlKG9mZnNldFBhdGgubGVuZ3RoICsgMSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB5aWVsZCBmdWxsUGF0aFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpXG5cbiAgICByZXR1cm4gZXh0ZW5kSXRlcmF0b3IoZ2VuZXJhdG9yKCkpXG4gIH1cblxuICAvKiAgICAgICAgICAgKi9cbiAgLyogaW50ZXJuYWxzICovXG4gIC8qICAgICAgICAgICAqL1xuICBhc3luYyBfZ2V0Rm9ybWF0IChjb2RlYykge1xuICAgIC8vIFRPRE8gdm14IDIwMTktMDEtMjQ6IE9uY2UgYWxsIENJRHMgc3VwcG9ydCBhY2Nlc3NpbmcgdGhlIGNvZGVjIGNvZGVcbiAgICAvLyBpbnN0ZWFkIG9mIHRoZSBuYW1lLCByZW1vdmUgdGhpcyBwYXJ0XG4gICAgaWYgKHR5cGVvZiBjb2RlYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGNvbnN0YW50TmFtZSA9IGNvZGVjLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvLS9nLCAnXycpXG4gICAgICBjb2RlYyA9IG11bHRpY29kZWNbY29uc3RhbnROYW1lXVxuICAgIH1cblxuICAgIGlmICh0aGlzLnJlc29sdmVyc1tjb2RlY10pIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc29sdmVyc1tjb2RlY11cbiAgICB9XG5cbiAgICAvLyBJZiBub3Qgc3VwcG9ydGVkLCBhdHRlbXB0IHRvIGR5bmFtaWNhbGx5IGxvYWQgdGhpcyBmb3JtYXRcbiAgICBjb25zdCBmb3JtYXQgPSBhd2FpdCB0aGlzLmxvYWRGb3JtYXQoY29kZWMpXG4gICAgdGhpcy5hZGRGb3JtYXQoZm9ybWF0KVxuICAgIHJldHVybiBmb3JtYXRcbiAgfVxufVxuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgSVBMRC5cbiAqL1xuSVBMRFJlc29sdmVyLmRlZmF1bHRPcHRpb25zID0ge1xuICBmb3JtYXRzOiBbaXBsZERhZ0Nib3IsIGlwbGREYWdQYiwgaXBsZFJhd11cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJUExEUmVzb2x2ZXJcbiIsIi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFttdWx0aWJhc2VdKGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvbXVsdGliYXNlKSBzcGVjaWZpY2F0aW9uLlxuICogQG1vZHVsZSBNdWx0aWJhc2VcbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gbXVsdGliYXNlXG5leHBvcnRzLmVuY29kZSA9IGVuY29kZVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGVcbmV4cG9ydHMuaXNFbmNvZGVkID0gaXNFbmNvZGVkXG5leHBvcnRzLm5hbWVzID0gT2JqZWN0LmZyZWV6ZShPYmplY3Qua2V5cyhjb25zdGFudHMubmFtZXMpKVxuZXhwb3J0cy5jb2RlcyA9IE9iamVjdC5mcmVlemUoT2JqZWN0LmtleXMoY29uc3RhbnRzLmNvZGVzKSlcblxuY29uc3QgZXJyTm90U3VwcG9ydGVkID0gbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBlbmNvZGluZycpXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGJ1ZmZlciB3aXRoIHRoZSBtdWx0aWJhc2UgdmFyaW50K2NvZGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lT3JDb2RlIC0gVGhlIG11bHRpYmFzZSBuYW1lIG9yIGNvZGUgbnVtYmVyLlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiAtIFRoZSBkYXRhIHRvIGJlIHByZWZpeGVkIHdpdGggbXVsdGliYXNlLlxuICogQG1lbWJlcm9mIE11bHRpYmFzZVxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gbXVsdGliYXNlIChuYW1lT3JDb2RlLCBidWYpIHtcbiAgaWYgKCFidWYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVzIGFuIGVuY29kZWQgYnVmZmVyJylcbiAgfVxuICBjb25zdCBiYXNlID0gZ2V0QmFzZShuYW1lT3JDb2RlKVxuICBjb25zdCBjb2RlQnVmID0gQnVmZmVyLmZyb20oYmFzZS5jb2RlKVxuXG4gIGNvbnN0IG5hbWUgPSBiYXNlLm5hbWVcbiAgdmFsaWRFbmNvZGUobmFtZSwgYnVmKVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbY29kZUJ1ZiwgYnVmXSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgZGF0YSB3aXRoIHRoZSBzcGVjaWZpZWQgYmFzZSBhbmQgYWRkIHRoZSBtdWx0aWJhc2UgcHJlZml4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbmFtZU9yQ29kZSAtIFRoZSBtdWx0aWJhc2UgbmFtZSBvciBjb2RlIG51bWJlci5cbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgLSBUaGUgZGF0YSB0byBiZSBlbmNvZGVkLlxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqIEBtZW1iZXJvZiBNdWx0aWJhc2VcbiAqL1xuZnVuY3Rpb24gZW5jb2RlIChuYW1lT3JDb2RlLCBidWYpIHtcbiAgY29uc3QgYmFzZSA9IGdldEJhc2UobmFtZU9yQ29kZSlcbiAgY29uc3QgbmFtZSA9IGJhc2UubmFtZVxuXG4gIHJldHVybiBtdWx0aWJhc2UobmFtZSwgQnVmZmVyLmZyb20oYmFzZS5lbmNvZGUoYnVmKSkpXG59XG5cbi8qKlxuICogVGFrZXMgYSBidWZmZXIgb3Igc3RyaW5nIGVuY29kZWQgd2l0aCBtdWx0aWJhc2UgaGVhZGVyLCBkZWNvZGVzIGl0IGFuZFxuICogcmV0dXJucyB0aGUgZGVjb2RlZCBidWZmZXJcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd9IGJ1Zk9yU3RyaW5nXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICogQG1lbWJlcm9mIE11bHRpYmFzZVxuICpcbiAqL1xuZnVuY3Rpb24gZGVjb2RlIChidWZPclN0cmluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1Zk9yU3RyaW5nKSkge1xuICAgIGJ1Zk9yU3RyaW5nID0gYnVmT3JTdHJpbmcudG9TdHJpbmcoKVxuICB9XG5cbiAgY29uc3QgY29kZSA9IGJ1Zk9yU3RyaW5nLnN1YnN0cmluZygwLCAxKVxuICBidWZPclN0cmluZyA9IGJ1Zk9yU3RyaW5nLnN1YnN0cmluZygxLCBidWZPclN0cmluZy5sZW5ndGgpXG5cbiAgaWYgKHR5cGVvZiBidWZPclN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICBidWZPclN0cmluZyA9IEJ1ZmZlci5mcm9tKGJ1Zk9yU3RyaW5nKVxuICB9XG5cbiAgY29uc3QgYmFzZSA9IGdldEJhc2UoY29kZSlcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJhc2UuZGVjb2RlKGJ1Zk9yU3RyaW5nLnRvU3RyaW5nKCkpKVxufVxuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBkYXRhIG11bHRpYmFzZSBlbmNvZGVkP1xuICpcbiAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ30gYnVmT3JTdHJpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQG1lbWJlcm9mIE11bHRpYmFzZVxuICovXG5mdW5jdGlvbiBpc0VuY29kZWQgKGJ1Zk9yU3RyaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmT3JTdHJpbmcpKSB7XG4gICAgYnVmT3JTdHJpbmcgPSBidWZPclN0cmluZy50b1N0cmluZygpXG4gIH1cblxuICAvLyBFbnN1cmUgYnVmT3JTdHJpbmcgaXMgYSBzdHJpbmdcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChidWZPclN0cmluZykgIT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBjb2RlID0gYnVmT3JTdHJpbmcuc3Vic3RyaW5nKDAsIDEpXG4gIHRyeSB7XG4gICAgY29uc3QgYmFzZSA9IGdldEJhc2UoY29kZSlcbiAgICByZXR1cm4gYmFzZS5uYW1lXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiB2YWxpZEVuY29kZSAobmFtZSwgYnVmKSB7XG4gIGNvbnN0IGJhc2UgPSBnZXRCYXNlKG5hbWUpXG4gIGJhc2UuZGVjb2RlKGJ1Zi50b1N0cmluZygpKVxufVxuXG5mdW5jdGlvbiBnZXRCYXNlIChuYW1lT3JDb2RlKSB7XG4gIGxldCBiYXNlXG5cbiAgaWYgKGNvbnN0YW50cy5uYW1lc1tuYW1lT3JDb2RlXSkge1xuICAgIGJhc2UgPSBjb25zdGFudHMubmFtZXNbbmFtZU9yQ29kZV1cbiAgfSBlbHNlIGlmIChjb25zdGFudHMuY29kZXNbbmFtZU9yQ29kZV0pIHtcbiAgICBiYXNlID0gY29uc3RhbnRzLmNvZGVzW25hbWVPckNvZGVdXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZXJyTm90U3VwcG9ydGVkXG4gIH1cblxuICBpZiAoIWJhc2UuaXNJbXBsZW1lbnRlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCYXNlICcgKyBuYW1lT3JDb2RlICsgJyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0JylcbiAgfVxuXG4gIHJldHVybiBiYXNlXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgY29kZWMgPSByZXF1aXJlKCcuL2NvZGVjJylcbmNvbnN0IHByb3RvY29scyA9IHJlcXVpcmUoJy4vcHJvdG9jb2xzLXRhYmxlJylcbmNvbnN0IHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG5jb25zdCBiczU4ID0gcmVxdWlyZSgnYnM1OCcpXG5jb25zdCB3aXRoSXMgPSByZXF1aXJlKCdjbGFzcy1pcycpXG5cbi8qKlxuICogQ3JlYXRlcyBhIFttdWx0aWFkZHJdKGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvbXVsdGlhZGRyKSBmcm9tXG4gKiBhIEJ1ZmZlciwgU3RyaW5nIG9yIGFub3RoZXIgTXVsdGlhZGRyIGluc3RhbmNlXG4gKiBwdWJsaWMga2V5LlxuICogQGNsYXNzIE11bHRpYWRkclxuICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcnxNdWx0aWFkZHIpfSBhZGRyIC0gSWYgU3RyaW5nIG9yIEJ1ZmZlciwgbmVlZHMgdG8gYWRoZXJlXG4gKiB0byB0aGUgYWRkcmVzcyBmb3JtYXQgb2YgYSBbbXVsdGlhZGRyXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL211bHRpYWRkciNzdHJpbmctZm9ybWF0KVxuICogQGV4YW1wbGVcbiAqIE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKVxuICogLy8gPE11bHRpYWRkciAwNDdmMDAwMDAxMDYwZmExIC0gL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDE+XG4gKi9cbmNvbnN0IE11bHRpYWRkciA9IHdpdGhJcy5wcm90byhmdW5jdGlvbiAoYWRkcikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTXVsdGlhZGRyKSkge1xuICAgIHJldHVybiBuZXcgTXVsdGlhZGRyKGFkZHIpXG4gIH1cblxuICAvLyBkZWZhdWx0XG4gIGlmIChhZGRyID09IG51bGwpIHtcbiAgICBhZGRyID0gJydcbiAgfVxuXG4gIGlmIChhZGRyIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0J1ZmZlcn0gLSBUaGUgcmF3IGJ5dGVzIHJlcHJlc2VudGluZyB0aGlzIG11bHRpYWRkcmVzc1xuICAgICAqL1xuICAgIHRoaXMuYnVmZmVyID0gY29kZWMuZnJvbUJ1ZmZlcihhZGRyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBhZGRyID09PSAnc3RyaW5nJyB8fCBhZGRyIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgaWYgKGFkZHIubGVuZ3RoID4gMCAmJiBhZGRyLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG11bHRpYWRkciBcIiR7YWRkcn1cIiBtdXN0IHN0YXJ0IHdpdGggYSBcIi9cImApXG4gICAgfVxuICAgIHRoaXMuYnVmZmVyID0gY29kZWMuZnJvbVN0cmluZyhhZGRyKVxuICB9IGVsc2UgaWYgKGFkZHIuYnVmZmVyICYmIGFkZHIucHJvdG9zICYmIGFkZHIucHJvdG9Db2RlcykgeyAvLyBNdWx0aWFkZHJcbiAgICB0aGlzLmJ1ZmZlciA9IGNvZGVjLmZyb21CdWZmZXIoYWRkci5idWZmZXIpIC8vIHZhbGlkYXRlICsgY29weSBidWZmZXJcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZHIgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBvciBhbm90aGVyIE11bHRpYWRkcicpXG4gIH1cbn0sIHsgY2xhc3NOYW1lOiAnTXVsdGlhZGRyJywgc3ltYm9sTmFtZTogJ0BtdWx0aWZvcm1hdHMvanMtbXVsdGlhZGRyL211bHRpYWRkcicgfSlcblxuLyoqXG4gKiBSZXR1cm5zIE11bHRpYWRkciBhcyBhIFN0cmluZ1xuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAZXhhbXBsZVxuICogTXVsdGlhZGRyKCcvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMScpLnRvU3RyaW5nKClcbiAqIC8vICcvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMSdcbiAqL1xuTXVsdGlhZGRyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgcmV0dXJuIGNvZGVjLmJ1ZmZlclRvU3RyaW5nKHRoaXMuYnVmZmVyKVxufVxuXG4vKipcbiAqIFJldHVybnMgTXVsdGlhZGRyIGFzIGEgSlNPTiBlbmNvZGVkIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAZXhhbXBsZVxuICogSlNPTi5zdHJpbmdpZnkoTXVsdGlhZGRyKCcvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMScpKVxuICogLy8gJy9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJ1xuICovXG5NdWx0aWFkZHIucHJvdG90eXBlLnRvSlNPTiA9IE11bHRpYWRkci5wcm90b3R5cGUudG9TdHJpbmdcblxuLyoqXG4gKiBSZXR1cm5zIE11bHRpYWRkciBhcyBhIGNvbnZpbmllbnQgb3B0aW9ucyBvYmplY3QgdG8gYmUgdXNlZCB3aXRoIG5ldC5jcmVhdGVDb25uZWN0aW9uXG4gKlxuICogQHJldHVybnMge3tmYW1pbHk6IFN0cmluZywgaG9zdDogU3RyaW5nLCB0cmFuc3BvcnQ6IFN0cmluZywgcG9ydDogU3RyaW5nfX1cbiAqIEBleGFtcGxlXG4gKiBNdWx0aWFkZHIoJy9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJykudG9PcHRpb25zKClcbiAqIC8vIHsgZmFtaWx5OiAnaXB2NCcsIGhvc3Q6ICcxMjcuMC4wLjEnLCB0cmFuc3BvcnQ6ICd0Y3AnLCBwb3J0OiAnNDAwMScgfVxuICovXG5NdWx0aWFkZHIucHJvdG90eXBlLnRvT3B0aW9ucyA9IGZ1bmN0aW9uIHRvT3B0aW9ucyAoKSB7XG4gIGNvbnN0IG9wdHMgPSB7fVxuICBjb25zdCBwYXJzZWQgPSB0aGlzLnRvU3RyaW5nKCkuc3BsaXQoJy8nKVxuICBvcHRzLmZhbWlseSA9IHBhcnNlZFsxXSA9PT0gJ2lwNCcgPyAnaXB2NCcgOiAnaXB2NidcbiAgb3B0cy5ob3N0ID0gcGFyc2VkWzJdXG4gIG9wdHMudHJhbnNwb3J0ID0gcGFyc2VkWzNdXG4gIG9wdHMucG9ydCA9IHBhcnNlZFs0XVxuICByZXR1cm4gb3B0c1xufVxuXG4vKipcbiAqIFJldHVybnMgTXVsdGlhZGRyIGFzIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nXG4gKlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBleGFtcGxlXG4gKiBNdWx0aWFkZHIoJy9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJykuaW5zcGVjdCgpXG4gKiAvLyAnPE11bHRpYWRkciAwNDdmMDAwMDAxMDYwZmExIC0gL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDE+J1xuICovXG5NdWx0aWFkZHIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgcmV0dXJuICc8TXVsdGlhZGRyICcgK1xuICAgIHRoaXMuYnVmZmVyLnRvU3RyaW5nKCdoZXgnKSArICcgLSAnICtcbiAgICBjb2RlYy5idWZmZXJUb1N0cmluZyh0aGlzLmJ1ZmZlcikgKyAnPidcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwcm90b2NvbHMgdGhlIE11bHRpYWRkciBpcyBkZWZpbmVkIHdpdGgsIGFzIGFuIGFycmF5IG9mIG9iamVjdHMsIGluXG4gKiBsZWZ0LXRvLXJpZ2h0IG9yZGVyLiBFYWNoIG9iamVjdCBjb250YWlucyB0aGUgcHJvdG9jb2wgY29kZSwgcHJvdG9jb2wgbmFtZSxcbiAqIGFuZCB0aGUgc2l6ZSBvZiBpdHMgYWRkcmVzcyBzcGFjZSBpbiBiaXRzLlxuICogW1NlZSBsaXN0IG9mIHByb3RvY29sc10oaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9tdWx0aWFkZHIvYmxvYi9tYXN0ZXIvcHJvdG9jb2xzLmNzdilcbiAqXG4gKiBAcmV0dXJucyB7QXJyYXkuPE9iamVjdD59IHByb3RvY29scyAtIEFsbCB0aGUgcHJvdG9jb2xzIHRoZSBhZGRyZXNzIGlzIGNvbXBvc2VkIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBwcm90b2NvbHNbXS5jb2RlXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBwcm90b2NvbHNbXS5zaXplXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBwcm90b2NvbHNbXS5uYW1lXG4gKiBAZXhhbXBsZVxuICogTXVsdGlhZGRyKCcvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMScpLnByb3RvcygpXG4gKiAvLyBbIHsgY29kZTogNCwgc2l6ZTogMzIsIG5hbWU6ICdpcDQnIH0sXG4gKiAvLyAgIHsgY29kZTogNiwgc2l6ZTogMTYsIG5hbWU6ICd0Y3AnIH0gXVxuICovXG5NdWx0aWFkZHIucHJvdG90eXBlLnByb3RvcyA9IGZ1bmN0aW9uIHByb3RvcyAoKSB7XG4gIHJldHVybiB0aGlzLnByb3RvQ29kZXMoKS5tYXAoY29kZSA9PiBPYmplY3QuYXNzaWduKHt9LCBwcm90b2NvbHMoY29kZSkpKVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvZGVzIG9mIHRoZSBwcm90b2NvbHMgaW4gbGVmdC10by1yaWdodCBvcmRlci5cbiAqIFtTZWUgbGlzdCBvZiBwcm90b2NvbHNdKGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvbXVsdGlhZGRyL2Jsb2IvbWFzdGVyL3Byb3RvY29scy5jc3YpXG4gKlxuICogQHJldHVybnMge0FycmF5LjxOdW1iZXI+fSBwcm90b2NvbCBjb2Rlc1xuICogQGV4YW1wbGVcbiAqIE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKS5wcm90b0NvZGVzKClcbiAqIC8vIFsgNCwgNiBdXG4gKi9cbk11bHRpYWRkci5wcm90b3R5cGUucHJvdG9Db2RlcyA9IGZ1bmN0aW9uIHByb3RvQ29kZXMgKCkge1xuICBjb25zdCBjb2RlcyA9IFtdXG4gIGNvbnN0IGJ1ZiA9IHRoaXMuYnVmZmVyXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGJ1Zi5sZW5ndGgpIHtcbiAgICBjb25zdCBjb2RlID0gdmFyaW50LmRlY29kZShidWYsIGkpXG4gICAgY29uc3QgbiA9IHZhcmludC5kZWNvZGUuYnl0ZXNcblxuICAgIGNvbnN0IHAgPSBwcm90b2NvbHMoY29kZSlcbiAgICBjb25zdCBzaXplID0gY29kZWMuc2l6ZUZvckFkZHIocCwgYnVmLnNsaWNlKGkgKyBuKSlcblxuICAgIGkgKz0gKHNpemUgKyBuKVxuICAgIGNvZGVzLnB1c2goY29kZSlcbiAgfVxuXG4gIHJldHVybiBjb2Rlc1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWVzIG9mIHRoZSBwcm90b2NvbHMgaW4gbGVmdC10by1yaWdodCBvcmRlci5cbiAqIFtTZWUgbGlzdCBvZiBwcm90b2NvbHNdKGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvbXVsdGlhZGRyL2Jsb2IvbWFzdGVyL3Byb3RvY29scy5jc3YpXG4gKlxuICogQHJldHVybiB7QXJyYXkuPFN0cmluZz59IHByb3RvY29sIG5hbWVzXG4gKiBAZXhhbXBsZVxuICogTXVsdGlhZGRyKCcvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMScpLnByb3RvTmFtZXMoKVxuICogLy8gWyAnaXA0JywgJ3RjcCcgXVxuICovXG5NdWx0aWFkZHIucHJvdG90eXBlLnByb3RvTmFtZXMgPSBmdW5jdGlvbiBwcm90b05hbWVzICgpIHtcbiAgcmV0dXJuIHRoaXMucHJvdG9zKCkubWFwKHByb3RvID0+IHByb3RvLm5hbWUpXG59XG5cbi8qKlxuICogUmV0dXJucyBhIHR1cGxlIG9mIHBhcnRzXG4gKlxuICogQHJldHVybiB7QXJyYXkuPEFycmF5Pn0gdHVwbGVzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHR1cGxlc1tdLjAgY29kZSBvZiBwcm90b2NvbFxuICogQHJldHVybiB7QnVmZmVyfSB0dXBsZXNbXS4xIGNvbnRlbnRzIG9mIGFkZHJlc3NcbiAqIEBleGFtcGxlXG4gKiBNdWx0aWFkZHIoXCIvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMVwiKS50dXBsZXMoKVxuICogLy8gWyBbIDQsIDxCdWZmZXIgN2YgMDAgMDAgMDE+IF0sIFsgNiwgPEJ1ZmZlciAwZiBhMT4gXSBdXG4gKi9cbk11bHRpYWRkci5wcm90b3R5cGUudHVwbGVzID0gZnVuY3Rpb24gdHVwbGVzICgpIHtcbiAgcmV0dXJuIGNvZGVjLmJ1ZmZlclRvVHVwbGVzKHRoaXMuYnVmZmVyKVxufVxuXG4vKipcbiAqIFJldHVybnMgYSB0dXBsZSBvZiBzdHJpbmcvbnVtYmVyIHBhcnRzXG4gKlxuICogQHJldHVybiB7QXJyYXkuPEFycmF5Pn0gdHVwbGVzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHR1cGxlc1tdLjAgY29kZSBvZiBwcm90b2NvbFxuICogQHJldHVybiB7KFN0cmluZ3xOdW1iZXIpfSB0dXBsZXNbXS4xIGNvbnRlbnRzIG9mIGFkZHJlc3NcbiAqIEBleGFtcGxlXG4gKiBNdWx0aWFkZHIoXCIvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMVwiKS5zdHJpbmdUdXBsZXMoKVxuICogLy8gWyBbIDQsICcxMjcuMC4wLjEnIF0sIFsgNiwgNDAwMSBdIF1cbiAqL1xuTXVsdGlhZGRyLnByb3RvdHlwZS5zdHJpbmdUdXBsZXMgPSBmdW5jdGlvbiBzdHJpbmdUdXBsZXMgKCkge1xuICBjb25zdCB0ID0gY29kZWMuYnVmZmVyVG9UdXBsZXModGhpcy5idWZmZXIpXG4gIHJldHVybiBjb2RlYy50dXBsZXNUb1N0cmluZ1R1cGxlcyh0KVxufVxuXG4vKipcbiAqIEVuY2Fwc3VsYXRlcyBhIE11bHRpYWRkciBpbiBhbm90aGVyIE11bHRpYWRkclxuICpcbiAqIEBwYXJhbSB7TXVsdGlhZGRyfSBhZGRyIC0gTXVsdGlhZGRyIHRvIGFkZCBpbnRvIHRoaXMgTXVsdGlhZGRyXG4gKiBAcmV0dXJuIHtNdWx0aWFkZHJ9XG4gKiBAZXhhbXBsZVxuICogY29uc3QgbWgxID0gTXVsdGlhZGRyKCcvaXA0LzguOC44LjgvdGNwLzEwODAnKVxuICogLy8gPE11bHRpYWRkciAwNDA4MDgwODA4MDYwNDM4IC0gL2lwNC84LjguOC44L3RjcC8xMDgwPlxuICpcbiAqIGNvbnN0IG1oMiA9IE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKVxuICogLy8gPE11bHRpYWRkciAwNDdmMDAwMDAxMDYwZmExIC0gL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDE+XG4gKlxuICogY29uc3QgbWgzID0gbWgxLmVuY2Fwc3VsYXRlKG1oMilcbiAqIC8vIDxNdWx0aWFkZHIgMDQwODA4MDgwODA2MDQzODA0N2YwMDAwMDEwNjBmYTEgLSAvaXA0LzguOC44LjgvdGNwLzEwODAvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMT5cbiAqXG4gKiBtaDMudG9TdHJpbmcoKVxuICogLy8gJy9pcDQvOC44LjguOC90Y3AvMTA4MC9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJ1xuICovXG5NdWx0aWFkZHIucHJvdG90eXBlLmVuY2Fwc3VsYXRlID0gZnVuY3Rpb24gZW5jYXBzdWxhdGUgKGFkZHIpIHtcbiAgYWRkciA9IE11bHRpYWRkcihhZGRyKVxuICByZXR1cm4gTXVsdGlhZGRyKHRoaXMudG9TdHJpbmcoKSArIGFkZHIudG9TdHJpbmcoKSlcbn1cblxuLyoqXG4gKiBEZWNhcHN1bGF0ZXMgYSBNdWx0aWFkZHIgZnJvbSBhbm90aGVyIE11bHRpYWRkclxuICpcbiAqIEBwYXJhbSB7TXVsdGlhZGRyfSBhZGRyIC0gTXVsdGlhZGRyIHRvIHJlbW92ZSBmcm9tIHRoaXMgTXVsdGlhZGRyXG4gKiBAcmV0dXJuIHtNdWx0aWFkZHJ9XG4gKiBAZXhhbXBsZVxuICogY29uc3QgbWgxID0gTXVsdGlhZGRyKCcvaXA0LzguOC44LjgvdGNwLzEwODAnKVxuICogLy8gPE11bHRpYWRkciAwNDA4MDgwODA4MDYwNDM4IC0gL2lwNC84LjguOC44L3RjcC8xMDgwPlxuICpcbiAqIGNvbnN0IG1oMiA9IE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKVxuICogLy8gPE11bHRpYWRkciAwNDdmMDAwMDAxMDYwZmExIC0gL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDE+XG4gKlxuICogY29uc3QgbWgzID0gbWgxLmVuY2Fwc3VsYXRlKG1oMilcbiAqIC8vIDxNdWx0aWFkZHIgMDQwODA4MDgwODA2MDQzODA0N2YwMDAwMDEwNjBmYTEgLSAvaXA0LzguOC44LjgvdGNwLzEwODAvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMT5cbiAqXG4gKiBtaDMuZGVjYXBzdWxhdGUobWgyKS50b1N0cmluZygpXG4gKiAvLyAnL2lwNC84LjguOC44L3RjcC8xMDgwJ1xuICovXG5NdWx0aWFkZHIucHJvdG90eXBlLmRlY2Fwc3VsYXRlID0gZnVuY3Rpb24gZGVjYXBzdWxhdGUgKGFkZHIpIHtcbiAgYWRkciA9IGFkZHIudG9TdHJpbmcoKVxuICBjb25zdCBzID0gdGhpcy50b1N0cmluZygpXG4gIGNvbnN0IGkgPSBzLmxhc3RJbmRleE9mKGFkZHIpXG4gIGlmIChpIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQWRkcmVzcyAnICsgdGhpcyArICcgZG9lcyBub3QgY29udGFpbiBzdWJhZGRyZXNzOiAnICsgYWRkcilcbiAgfVxuICByZXR1cm4gTXVsdGlhZGRyKHMuc2xpY2UoMCwgaSkpXG59XG5cbi8qKlxuICogRXh0cmFjdCB0aGUgcGVlcklkIGlmIHRoZSBtdWx0aWFkZHIgY29udGFpbnMgb25lXG4gKlxuICogQHJldHVybiB7U3RyaW5nfG51bGx9IHBlZXJJZCAtIFRoZSBpZCBvZiB0aGUgcGVlciBvciBudWxsIGlmIGludmFsaWQgb3IgbWlzc2luZyBmcm9tIHRoZSBtYVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG1oMSA9IE11bHRpYWRkcignL2lwNC84LjguOC44L3RjcC8xMDgwL2lwZnMvUW1WYWxpZEJhc2U1OHN0cmluZycpXG4gKiAvLyA8TXVsdGlhZGRyIDA0MDgwODA4MDgwNjA0MzggLSAvaXA0LzguOC44LjgvdGNwLzEwODAvaXBmcy9RbVZhbGlkQmFzZTU4c3RyaW5nPlxuICpcbiAqIC8vIHNob3VsZCByZXR1cm4gUW1WYWxpZEJhc2U1OHN0cmluZyBvciBudWxsIGlmIHRoZSBpZCBpcyBtaXNzaW5nIG9yIGludmFsaWRcbiAqIGNvbnN0IHBlZXJJZCA9IG1oMS5nZXRQZWVySWQoKVxuICovXG5NdWx0aWFkZHIucHJvdG90eXBlLmdldFBlZXJJZCA9IGZ1bmN0aW9uIGdldFBlZXJJZCAoKSB7XG4gIGxldCBiNThzdHIgPSBudWxsXG4gIHRyeSB7XG4gICAgYjU4c3RyID0gdGhpcy5zdHJpbmdUdXBsZXMoKS5maWx0ZXIoKHR1cGxlKSA9PiB7XG4gICAgICBpZiAodHVwbGVbMF0gPT09IHByb3RvY29scy5uYW1lcy5pcGZzLmNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9KVswXVsxXVxuXG4gICAgYnM1OC5kZWNvZGUoYjU4c3RyKVxuICB9IGNhdGNoIChlKSB7XG4gICAgYjU4c3RyID0gbnVsbFxuICB9XG5cbiAgcmV0dXJuIGI1OHN0clxufVxuXG4vKipcbiAqIEV4dHJhY3QgdGhlIHBhdGggaWYgdGhlIG11bHRpYWRkciBjb250YWlucyBvbmVcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH0gcGF0aCAtIFRoZSBwYXRoIG9mIHRoZSBtdWx0aWFkZHIsIG9yIG51bGwgaWYgbm8gcGF0aCBwcm90b2NvbCBpcyBwcmVzZW50XG4gKiBAZXhhbXBsZVxuICogY29uc3QgbWgxID0gTXVsdGlhZGRyKCcvaXA0LzguOC44LjgvdGNwLzEwODAvdW5peC90bXAvcDJwLnNvY2snKVxuICogLy8gPE11bHRpYWRkciAwNDA4MDgwODA4MDYwNDM4IC0gL2lwNC84LjguOC44L3RjcC8xMDgwL3VuaXgvdG1wL3AycC5zb2NrPlxuICpcbiAqIC8vIHNob3VsZCByZXR1cm4gdXRmOCBzdHJpbmcgb3IgbnVsbCBpZiB0aGUgaWQgaXMgbWlzc2luZyBvciBpbnZhbGlkXG4gKiBjb25zdCBwYXRoID0gbWgxLmdldFBhdGgoKVxuICovXG5NdWx0aWFkZHIucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbiBnZXRQYXRoICgpIHtcbiAgbGV0IHBhdGggPSBudWxsXG4gIHRyeSB7XG4gICAgcGF0aCA9IHRoaXMuc3RyaW5nVHVwbGVzKCkuZmlsdGVyKCh0dXBsZSkgPT4ge1xuICAgICAgY29uc3QgcHJvdG8gPSBwcm90b2NvbHModHVwbGVbMF0pXG4gICAgICBpZiAocHJvdG8ucGF0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pWzBdWzFdXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBwYXRoID0gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHBhdGhcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIE11bHRpYWRkcnMgYXJlIHRoZSBzYW1lXG4gKlxuICogQHBhcmFtIHtNdWx0aWFkZHJ9IGFkZHJcbiAqIEByZXR1cm4ge0Jvb2x9XG4gKiBAZXhhbXBsZVxuICogY29uc3QgbWgxID0gTXVsdGlhZGRyKCcvaXA0LzguOC44LjgvdGNwLzEwODAnKVxuICogLy8gPE11bHRpYWRkciAwNDA4MDgwODA4MDYwNDM4IC0gL2lwNC84LjguOC44L3RjcC8xMDgwPlxuICpcbiAqIGNvbnN0IG1oMiA9IE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKVxuICogLy8gPE11bHRpYWRkciAwNDdmMDAwMDAxMDYwZmExIC0gL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDE+XG4gKlxuICogbWgxLmVxdWFscyhtaDEpXG4gKiAvLyB0cnVlXG4gKlxuICogbWgxLmVxdWFscyhtaDIpXG4gKiAvLyBmYWxzZVxuICovXG5NdWx0aWFkZHIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYWRkcikge1xuICByZXR1cm4gdGhpcy5idWZmZXIuZXF1YWxzKGFkZHIuYnVmZmVyKVxufVxuXG4vKipcbiAqIEdldHMgYSBNdWx0aWFkZHJzIG5vZGUtZnJpZW5kbHkgYWRkcmVzcyBvYmplY3QuIE5vdGUgdGhhdCBwcm90b2NvbCBpbmZvcm1hdGlvblxuICogaXMgbGVmdCBvdXQ6IGluIE5vZGUgKGFuZCBtb3N0IG5ldHdvcmsgc3lzdGVtcykgdGhlIHByb3RvY29sIGlzIHVua25vd2FibGVcbiAqIGdpdmVuIG9ubHkgdGhlIGFkZHJlc3MuXG4gKlxuICogSGFzIHRvIGJlIGEgVGhpbldhaXN0IEFkZHJlc3MsIG90aGVyd2lzZSB0aHJvd3MgZXJyb3JcbiAqXG4gKiBAcmV0dXJucyB7e2ZhbWlseTogU3RyaW5nLCBhZGRyZXNzOiBTdHJpbmcsIHBvcnQ6IFN0cmluZ319XG4gKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3dzIGVycm9yIGlmIE11bHRpYWRkciBpcyBub3QgYSBUaGluIFdhaXN0IGFkZHJlc3NcbiAqIEBleGFtcGxlXG4gKiBNdWx0aWFkZHIoJy9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJykubm9kZUFkZHJlc3MoKVxuICogLy8ge2ZhbWlseTogJ0lQdjQnLCBhZGRyZXNzOiAnMTI3LjAuMC4xJywgcG9ydDogJzQwMDEnfVxuICovXG5NdWx0aWFkZHIucHJvdG90eXBlLm5vZGVBZGRyZXNzID0gZnVuY3Rpb24gbm9kZUFkZHJlc3MgKCkge1xuICBjb25zdCBjb2RlcyA9IHRoaXMucHJvdG9Db2RlcygpXG4gIGNvbnN0IG5hbWVzID0gdGhpcy5wcm90b05hbWVzKClcbiAgY29uc3QgcGFydHMgPSB0aGlzLnRvU3RyaW5nKCkuc3BsaXQoJy8nKS5zbGljZSgxKVxuXG4gIGlmIChwYXJ0cy5sZW5ndGggPCA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWFkZHIgbXVzdCBoYXZlIGEgdmFsaWQgZm9ybWF0OiBcIi97aXA0LCBpcDYsIGRuczQsIGRuczZ9L3thZGRyZXNzfS97dGNwLCB1ZHB9L3twb3J0fVwiLicpXG4gIH0gZWxzZSBpZiAoY29kZXNbMF0gIT09IDQgJiYgY29kZXNbMF0gIT09IDQxICYmIGNvZGVzWzBdICE9PSA1NCAmJiBjb2Rlc1swXSAhPT0gNTUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIHByb3RvY29sIHdpdGggbmFtZTogXCInJHtuYW1lc1swXX0nXCIuIE11c3QgaGF2ZSBhIHZhbGlkIGZhbWlseSBuYW1lOiBcIntpcDQsIGlwNiwgZG5zNCwgZG5zNn1cIi5gKVxuICB9IGVsc2UgaWYgKHBhcnRzWzJdICE9PSAndGNwJyAmJiBwYXJ0c1syXSAhPT0gJ3VkcCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIHByb3RvY29sIHdpdGggbmFtZTogXCInJHtuYW1lc1sxXX0nXCIuIE11c3QgaGF2ZSBhIHZhbGlkIHRyYW5zcG9ydCBwcm90b2NvbDogXCJ7dGNwLCB1ZHB9XCIuYClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZmFtaWx5OiAoY29kZXNbMF0gPT09IDQxIHx8IGNvZGVzWzBdID09PSA1NSkgPyA2IDogNCxcbiAgICBhZGRyZXNzOiBwYXJ0c1sxXSwgLy8gaXAgYWRkclxuICAgIHBvcnQ6IHBhcnRzWzNdIC8vIHRjcCBvciB1ZHAgcG9ydFxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIE11bHRpYWRkciBmcm9tIGEgbm9kZS1mcmllbmRseSBhZGRyZXNzIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0XG4gKiBAcmV0dXJucyB7TXVsdGlhZGRyfSBtdWx0aWFkZHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd3MgZXJyb3IgaWYgYWRkciBpcyBub3QgdHJ1dGh5XG4gKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3dzIGVycm9yIGlmIHRyYW5zcG9ydCBpcyBub3QgdHJ1dGh5XG4gKiBAZXhhbXBsZVxuICogTXVsdGlhZGRyLmZyb21Ob2RlQWRkcmVzcyh7YWRkcmVzczogJzEyNy4wLjAuMScsIHBvcnQ6ICc0MDAxJ30sICd0Y3AnKVxuICogLy8gPE11bHRpYWRkciAwNDdmMDAwMDAxMDYwZmExIC0gL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDE+XG4gKi9cbk11bHRpYWRkci5mcm9tTm9kZUFkZHJlc3MgPSBmdW5jdGlvbiBmcm9tTm9kZUFkZHJlc3MgKGFkZHIsIHRyYW5zcG9ydCkge1xuICBpZiAoIWFkZHIpIHRocm93IG5ldyBFcnJvcigncmVxdWlyZXMgbm9kZSBhZGRyZXNzIG9iamVjdCcpXG4gIGlmICghdHJhbnNwb3J0KSB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVzIHRyYW5zcG9ydCBwcm90b2NvbCcpXG4gIGNvbnN0IGlwID0gKGFkZHIuZmFtaWx5ID09PSAnSVB2NicpID8gJ2lwNicgOiAnaXA0J1xuICByZXR1cm4gTXVsdGlhZGRyKCcvJyArIFtpcCwgYWRkci5hZGRyZXNzLCB0cmFuc3BvcnQsIGFkZHIucG9ydF0uam9pbignLycpKVxufVxuXG4vLyBUT0RPIGZpbmQgYSBiZXR0ZXIgZXhhbXBsZSwgbm90IHN1cmUgYWJvdXQgaXQncyBnb29kIGVub3VnaFxuLyoqXG4gKiBSZXR1cm5zIGlmIGEgTXVsdGlhZGRyIGlzIGEgVGhpbiBXYWlzdCBhZGRyZXNzIG9yIG5vdC5cbiAqXG4gKiBUaGluIFdhaXN0IGlzIGlmIGEgTXVsdGlhZGRyIGFkaGVyZXMgdG8gdGhlIHN0YW5kYXJkIGNvbWJpbmF0aW9uIG9mOlxuICpcbiAqIGB7SVB2NCwgSVB2Nn0ve1RDUCwgVURQfWBcbiAqXG4gKiBAcGFyYW0ge011bHRpYWRkcn0gW2FkZHJdIC0gRGVmYXVsdHMgdG8gdXNpbmcgYHRoaXNgIGluc3RhbmNlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXNUaGluV2Fpc3RBZGRyZXNzXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbWgxID0gTXVsdGlhZGRyKCcvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMScpXG4gKiAvLyA8TXVsdGlhZGRyIDA0N2YwMDAwMDEwNjBmYTEgLSAvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMT5cbiAqIGNvbnN0IG1oMiA9IE11bHRpYWRkcignL2lwNC8xOTIuMTY4LjIuMS90Y3AvNTAwMScpXG4gKiAvLyA8TXVsdGlhZGRyIDA0YzBhODAyMDEwNjEzODkgLSAvaXA0LzE5Mi4xNjguMi4xL3RjcC81MDAxPlxuICogY29uc3QgbWgzID0gbWgxLmVuY2Fwc3VsYXRlKG1oMilcbiAqIC8vIDxNdWx0aWFkZHIgMDQ3ZjAwMDAwMTA2MGZhMTA0YzBhODAyMDEwNjEzODkgLSAvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMS9pcDQvMTkyLjE2OC4yLjEvdGNwLzUwMDE+XG4gKiBtaDEuaXNUaGluV2Fpc3RBZGRyZXNzKClcbiAqIC8vIHRydWVcbiAqIG1oMi5pc1RoaW5XYWlzdEFkZHJlc3MoKVxuICogLy8gdHJ1ZVxuICogbWgzLmlzVGhpbldhaXN0QWRkcmVzcygpXG4gKiAvLyBmYWxzZVxuICovXG5NdWx0aWFkZHIucHJvdG90eXBlLmlzVGhpbldhaXN0QWRkcmVzcyA9IGZ1bmN0aW9uIGlzVGhpbldhaXN0QWRkcmVzcyAoYWRkcikge1xuICBjb25zdCBwcm90b3MgPSAoYWRkciB8fCB0aGlzKS5wcm90b3MoKVxuXG4gIGlmIChwcm90b3MubGVuZ3RoICE9PSAyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAocHJvdG9zWzBdLmNvZGUgIT09IDQgJiYgcHJvdG9zWzBdLmNvZGUgIT09IDQxKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKHByb3Rvc1sxXS5jb2RlICE9PSA2ICYmIHByb3Rvc1sxXS5jb2RlICE9PSAyNzMpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIE9iamVjdCBjb250YWluaW5nIHRhYmxlLCBuYW1lcyBhbmQgY29kZXMgb2YgYWxsIHN1cHBvcnRlZCBwcm90b2NvbHMuXG4gKiBUbyBnZXQgdGhlIHByb3RvY29sIHZhbHVlcyBmcm9tIGEgTXVsdGlhZGRyLCB5b3UgY2FuIHVzZVxuICogW2AucHJvdG9zKClgXSgjbXVsdGlhZGRycHJvdG9zKSxcbiAqIFtgLnByb3RvQ29kZXMoKWBdKCNtdWx0aWFkZHJwcm90b2NvZGVzKSBvclxuICogW2AucHJvdG9OYW1lcygpYF0oI211bHRpYWRkcnByb3RvbmFtZXMpXG4gKlxuICogQGluc3RhbmNlXG4gKiBAcmV0dXJucyB7e3RhYmxlOiBBcnJheSwgbmFtZXM6IE9iamVjdCwgY29kZXM6IE9iamVjdH19XG4gKlxuICovXG5NdWx0aWFkZHIucHJvdG9jb2xzID0gcHJvdG9jb2xzXG5cbi8qKlxuICogUmV0dXJucyBpZiBzb21ldGhpbmcgaXMgYSBNdWx0aWFkZHIgdGhhdCBpcyBhIG5hbWVcbiAqXG4gKiBAcGFyYW0ge011bHRpYWRkcn0gYWRkclxuICogQHJldHVybiB7Qm9vbH0gaXNOYW1lXG4gKi9cbk11bHRpYWRkci5pc05hbWUgPSBmdW5jdGlvbiBpc05hbWUgKGFkZHIpIHtcbiAgaWYgKCFNdWx0aWFkZHIuaXNNdWx0aWFkZHIoYWRkcikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIGlmIGEgcGFydCBvZiB0aGUgbXVsdGlhZGRyIGlzIHJlc29sdmFibGUsIHRoZW4gcmV0dXJuIHRydWVcbiAgcmV0dXJuIGFkZHIucHJvdG9zKCkuc29tZSgocHJvdG8pID0+IHByb3RvLnJlc29sdmFibGUpXG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBtdWx0aWFkZHJzLCBieSByZXNvbHZpbmcgdGhlIG11bHRpYWRkciB0aGF0IGlzIGEgbmFtZVxuICpcbiAqIEBwYXJhbSB7TXVsdGlhZGRyfSBhZGRyXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge0Jvb2x9IGlzTmFtZVxuICovXG5NdWx0aWFkZHIucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUgKGFkZHIsIGNhbGxiYWNrKSB7XG4gIGlmICghTXVsdGlhZGRyLmlzTXVsdGlhZGRyKGFkZHIpIHx8ICFNdWx0aWFkZHIuaXNOYW1lKGFkZHIpKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignbm90IGEgdmFsaWQgbmFtZScpKVxuICB9XG5cbiAgLypcbiAgICogTmVlZHMgbW9yZSBjb25zaWRlcmF0aW9uIGZyb20gc3BlYyBkZXNpZ246XG4gICAqICAgLSB3aGF0IHRvIHJldHVyblxuICAgKiAgIC0gaG93IHRvIGFjaGlldmUgaXQgaW4gdGhlIGJyb3dzZXI/XG4gICAqL1xuICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQgeWV0JykpXG59XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IE11bHRpYWRkclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG11bHRpaGFzaCA9IHJlcXVpcmUoJ211bHRpaGFzaGVzJylcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJy4vY3J5cHRvJylcblxubW9kdWxlLmV4cG9ydHMgPSBNdWx0aWhhc2hpbmdcblxuLyoqXG4gKiBIYXNoIHRoZSBnaXZlbiBgYnVmYCB1c2luZyB0aGUgYWxnb3JpdGhtIHNwZWNpZmllZFxuICogYnkgYGZ1bmNgLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgLSBUaGUgdmFsdWUgdG8gaGFzaC5cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gZnVuYyAtIFRoZSBhbGdvcml0aG0gdG8gdXNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIC0gT3B0aW9uYWxseSB0cmltIHRoZSByZXN1bHQgdG8gdGhpcyBsZW5ndGguXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBCdWZmZXIpfSBjYWxsYmFja1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gTXVsdGloYXNoaW5nIChidWYsIGZ1bmMsIGxlbmd0aCwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBsZW5ndGggPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGxlbmd0aFxuICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBjYWxsYmFjaycpXG4gIH1cblxuICBNdWx0aWhhc2hpbmcuZGlnZXN0KGJ1ZiwgZnVuYywgbGVuZ3RoLCAoZXJyLCBkaWdlc3QpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIG11bHRpaGFzaC5lbmNvZGUoZGlnZXN0LCBmdW5jLCBsZW5ndGgpKVxuICB9KVxufVxuXG4vKipcbiAqIFRoZSBgYnVmZmVyYCBtb2R1bGUgZm9yIGVhc3kgdXNlIGluIHRoZSBicm93c2VyLlxuICpcbiAqIEB0eXBlIHtCdWZmZXJ9XG4gKi9cbk11bHRpaGFzaGluZy5CdWZmZXIgPSBCdWZmZXIgLy8gZm9yIGJyb3dzZXIgdGhpbmdzXG5cbi8qKlxuICogRXhwb3NlIG11bHRpaGFzaCBpdHNlbGYsIHRvIGF2b2lkIHNpbGx5IGRvdWJsZSByZXF1aXJlcy5cbiAqL1xuTXVsdGloYXNoaW5nLm11bHRpaGFzaCA9IG11bHRpaGFzaFxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgLSBUaGUgdmFsdWUgdG8gaGFzaC5cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gZnVuYyAtIFRoZSBhbGdvcml0aG0gdG8gdXNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIC0gT3B0aW9uYWxseSB0cmltIHRoZSByZXN1bHQgdG8gdGhpcyBsZW5ndGguXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBCdWZmZXIpfSBjYWxsYmFja1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuTXVsdGloYXNoaW5nLmRpZ2VzdCA9IGZ1bmN0aW9uIChidWYsIGZ1bmMsIGxlbmd0aCwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBsZW5ndGggPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGxlbmd0aFxuICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBjYWxsYmFjaycpXG4gIH1cblxuICBsZXQgY2IgPSBjYWxsYmFja1xuICBpZiAobGVuZ3RoKSB7XG4gICAgY2IgPSAoZXJyLCBkaWdlc3QpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgZGlnZXN0LnNsaWNlKDAsIGxlbmd0aCkpXG4gICAgfVxuICB9XG5cbiAgbGV0IGhhc2hcbiAgdHJ5IHtcbiAgICBoYXNoID0gTXVsdGloYXNoaW5nLmNyZWF0ZUhhc2goZnVuYylcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGNiKGVycilcbiAgfVxuXG4gIGhhc2goYnVmLCBjYilcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGZ1bmNcbiAqXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IC0gVGhlIHRvIGBmdW5jYCBjb3JyZXNwb25kaW5nIGhhc2ggZnVuY3Rpb24uXG4gKi9cbk11bHRpaGFzaGluZy5jcmVhdGVIYXNoID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgZnVuYyA9IG11bHRpaGFzaC5jb2VyY2VDb2RlKGZ1bmMpXG4gIGlmICghTXVsdGloYXNoaW5nLmZ1bmN0aW9uc1tmdW5jXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVsdGloYXNoIGZ1bmN0aW9uICcgKyBmdW5jICsgJyBub3QgeWV0IHN1cHBvcnRlZCcpXG4gIH1cblxuICByZXR1cm4gTXVsdGloYXNoaW5nLmZ1bmN0aW9uc1tmdW5jXVxufVxuXG4vKipcbiAqIE1hcHBpbmcgb2YgbXVsdGloYXNoIGNvZGVzIHRvIHRoZWlyIGhhc2hpbmcgZnVuY3Rpb25zLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuTXVsdGloYXNoaW5nLmZ1bmN0aW9ucyA9IHtcbiAgLy8gc2hhMVxuICAweDExOiBjcnlwdG8uc2hhMSxcbiAgLy8gc2hhMi0yNTZcbiAgMHgxMjogY3J5cHRvLnNoYTIyNTYsXG4gIC8vIHNoYTItNTEyXG4gIDB4MTM6IGNyeXB0by5zaGEyNTEyLFxuICAvLyBzaGEzLTUxMlxuICAweDE0OiBjcnlwdG8uc2hhMzUxMixcbiAgLy8gc2hhMy0zODRcbiAgMHgxNTogY3J5cHRvLnNoYTMzODQsXG4gIC8vIHNoYTMtMjU2XG4gIDB4MTY6IGNyeXB0by5zaGEzMjU2LFxuICAvLyBzaGEzLTIyNFxuICAweDE3OiBjcnlwdG8uc2hhMzIyNCxcbiAgLy8gc2hha2UtMTI4XG4gIDB4MTg6IGNyeXB0by5zaGFrZTEyOCxcbiAgLy8gc2hha2UtMjU2XG4gIDB4MTk6IGNyeXB0by5zaGFrZTI1NixcbiAgLy8ga2VjY2FrLTIyNFxuICAweDFBOiBjcnlwdG8ua2VjY2FrMjI0LFxuICAvLyBrZWNjYWstMjU2XG4gIDB4MUI6IGNyeXB0by5rZWNjYWsyNTYsXG4gIC8vIGtlY2Nhay0zODRcbiAgMHgxQzogY3J5cHRvLmtlY2NhazM4NCxcbiAgLy8ga2VjY2FrLTUxMlxuICAweDFEOiBjcnlwdG8ua2VjY2FrNTEyLFxuICAvLyBtdXJtdXIzLTEyOFxuICAweDIyOiBjcnlwdG8ubXVybXVyMzEyOCxcbiAgLy8gbXVybXVyMy0zMlxuICAweDIzOiBjcnlwdG8ubXVybXVyMzMyLFxuICAvLyBkYmwtc2hhMi0yNTZcbiAgMHg1NjogY3J5cHRvLmRibFNoYTIyNTZcbn1cblxuLy8gYWRkIGJsYWtlIGZ1bmN0aW9uc1xuY3J5cHRvLmFkZEJsYWtlKE11bHRpaGFzaGluZy5mdW5jdGlvbnMpXG5cbk11bHRpaGFzaGluZy52YWxpZGF0ZSA9IChkYXRhLCBoYXNoLCBjYWxsYmFjaykgPT4ge1xuICBsZXQgYWxnbyA9IG11bHRpaGFzaC5kZWNvZGUoaGFzaCkubmFtZVxuICBNdWx0aWhhc2hpbmcoZGF0YSwgYWxnbywgKGVyciwgbmV3SGFzaCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgY2FsbGJhY2soZXJyLCBCdWZmZXIuY29tcGFyZShoYXNoLCBuZXdIYXNoKSA9PT0gMClcbiAgfSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgbWVyZ2VPcHRpb25zID0gcmVxdWlyZSgnbWVyZ2Utb3B0aW9ucycpXG5jb25zdCBpcGxkRGFnQ2JvciA9IHJlcXVpcmUoJ2lwbGQtZGFnLWNib3InKVxuY29uc3QgaXBsZERhZ1BiID0gcmVxdWlyZSgnaXBsZC1kYWctcGInKVxuY29uc3QgaXBsZFJhdyA9IHJlcXVpcmUoJ2lwbGQtcmF3JylcblxubW9kdWxlLmV4cG9ydHMgPSAoYmxvY2tTZXJ2aWNlLCBvcHRpb25zID0ge30pID0+IHtcbiAgcmV0dXJuIG1lcmdlT3B0aW9ucy5jYWxsKFxuICAgIC8vIGVuc3VyZSB3ZSBoYXZlIHRoZSBkZWZhdWx0cyBmb3JtYXRzIGV2ZW4gaWYgdGhlIHVzZXIgb3ZlcnJpZGVzIGBmb3JtYXRzOiBbXWBcbiAgICB7IGNvbmNhdEFycmF5czogdHJ1ZSB9LFxuICAgIHtcbiAgICAgIGJsb2NrU2VydmljZTogYmxvY2tTZXJ2aWNlLFxuICAgICAgZm9ybWF0czogW2lwbGREYWdDYm9yLCBpcGxkRGFnUGIsIGlwbGRSYXddXG4gICAgfSwgb3B0aW9ucylcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB3YXRlcmZhbGwgPSByZXF1aXJlKCdhc3luYy93YXRlcmZhbGwnKVxuY29uc3QgUmVwb0Vycm9ycyA9IHJlcXVpcmUoJ2lwZnMtcmVwbycpLmVycm9yc1xuXG4vLyBCb290IGFuIElQRlMgbm9kZSBkZXBlbmRpbmcgb24gdGhlIG9wdGlvbnMgc2V0XG5tb2R1bGUuZXhwb3J0cyA9IChzZWxmKSA9PiB7XG4gIHNlbGYubG9nKCdib290aW5nJylcbiAgY29uc3Qgb3B0aW9ucyA9IHNlbGYuX29wdGlvbnNcbiAgY29uc3QgZG9Jbml0ID0gb3B0aW9ucy5pbml0XG4gIGNvbnN0IGRvU3RhcnQgPSBvcHRpb25zLnN0YXJ0XG5cbiAgLy8gRG8gdGhlIGFjdHVhbCBib290IHNlcXVlbmNlXG4gIHdhdGVyZmFsbChbXG4gICAgLy8gQ2hlY2tzIGlmIGEgcmVwbyBleGlzdHMsIGFuZCBpZiBzbyBvcGVucyBpdFxuICAgIC8vIFdpbGwgcmV0dXJuIGNhbGxiYWNrIHdpdGggYSBib29sIGluZGljYXRpbmcgdGhlIGV4aXN0ZW5jZVxuICAgIC8vIG9mIHRoZSByZXBvXG4gICAgKGNiKSA9PiB7XG4gICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICBpZiAoIXNlbGYuX3JlcG8uY2xvc2VkKSB7XG4gICAgICAgIHJldHVybiBjYihudWxsLCB0cnVlKVxuICAgICAgfVxuXG4gICAgICBzZWxmLl9yZXBvLm9wZW4oKGVyciwgcmVzKSA9PiB7XG4gICAgICAgIGlmIChpc1JlcG9VbmluaXRpYWxpemVkRXJyb3IoZXJyKSkgcmV0dXJuIGNiKG51bGwsIGZhbHNlKVxuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgICBjYihudWxsLCB0cnVlKVxuICAgICAgfSlcbiAgICB9LFxuICAgIChyZXBvT3BlbmVkLCBjYikgPT4ge1xuICAgICAgLy8gSW5pdCB3aXRoIGV4aXN0aW5nIGluaXRpYWxpemVkLCBvcGVuZWQsIHJlcG9cbiAgICAgIGlmIChyZXBvT3BlbmVkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmluaXQoeyByZXBvOiBzZWxmLl9yZXBvIH0sIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoT2JqZWN0LmFzc2lnbihlcnIsIHsgZW1pdHRlZDogdHJ1ZSB9KSlcbiAgICAgICAgICBjYigpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGlmIChkb0luaXQpIHtcbiAgICAgICAgY29uc3QgaW5pdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHsgYml0czogMjA0OCwgcGFzczogc2VsZi5fb3B0aW9ucy5wYXNzIH0sXG4gICAgICAgICAgdHlwZW9mIG9wdGlvbnMuaW5pdCA9PT0gJ29iamVjdCcgPyBvcHRpb25zLmluaXQgOiB7fVxuICAgICAgICApXG4gICAgICAgIHJldHVybiBzZWxmLmluaXQoaW5pdE9wdGlvbnMsIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoT2JqZWN0LmFzc2lnbihlcnIsIHsgZW1pdHRlZDogdHJ1ZSB9KSlcbiAgICAgICAgICBjYigpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGNiKClcbiAgICB9LFxuICAgIChjYikgPT4ge1xuICAgICAgLy8gTm8gcHJvYmxlbSwgd2UgZG9uJ3QgaGF2ZSB0byBzdGFydCB0aGUgbm9kZVxuICAgICAgaWYgKCFkb1N0YXJ0KSB7XG4gICAgICAgIHJldHVybiBjYigpXG4gICAgICB9XG5cbiAgICAgIHNlbGYuc3RhcnQoKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoT2JqZWN0LmFzc2lnbihlcnIsIHsgZW1pdHRlZDogdHJ1ZSB9KSlcbiAgICAgICAgY2IoKVxuICAgICAgfSlcbiAgICB9XG4gIF0sIChlcnIpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBpZiAoIWVyci5lbWl0dGVkKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2VsZi5sb2coJ2Jvb3RlZCcpXG4gICAgc2VsZi5lbWl0KCdyZWFkeScpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGlzUmVwb1VuaW5pdGlhbGl6ZWRFcnJvciAoZXJyKSB7XG4gIGlmICghZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBJZiB0aGUgZXJyb3IgaXMgdGhhdCBubyByZXBvIGV4aXN0cyxcbiAgLy8gd2hpY2ggaGFwcGVucyB3aGVuIHRoZSB2ZXJzaW9uIGZpbGUgaXMgbm90IGZvdW5kXG4gIC8vIHdlIGp1c3Qgd2FudCB0byBzaWduYWwgdGhhdCBubyByZXBvIGV4aXN0LCBub3RcbiAgLy8gZmFpbCB0aGUgd2hvbGUgcHJvY2Vzcy5cblxuICAvLyBVc2Ugc3RhbmRhcmRpemVkIGVycm9ycyBhcyBtdWNoIGFzIHBvc3NpYmxlXG4gIGlmIChlcnIuY29kZSA9PT0gUmVwb0Vycm9ycy5FUlJfUkVQT19OT1RfSU5JVElBTElaRUQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gVE9ETzogQXMgZXJyb3IgY29kZXMgY29udGludWUgdG8gYmUgc3RhbmRhcmRpemVkLCB0aGlzIGxvZ2ljIGNhbiBiZSBwaGFzZSBvdXQ7XG4gIC8vIGl0IGlzIGhlcmUgdG8gbWFpbnRhaW4gY29tcGF0aWJpbGl0eVxuICBpZiAoZXJyLm1lc3NhZ2UubWF0Y2goL25vdCBmb3VuZC8pIHx8IC8vIGluZGV4ZWRkYlxuICAgIGVyci5tZXNzYWdlLm1hdGNoKC9FTk9FTlQvKSB8fCAvLyBmc1xuICAgIGVyci5tZXNzYWdlLm1hdGNoKC9ObyB2YWx1ZS8pIC8vIG1lbW9yeVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgaG1hYyA9IHJlcXVpcmUoJy4vaG1hYycpXG5jb25zdCBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG5jb25zdCBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJylcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzXG5cbmV4cG9ydHMuYWVzID0gYWVzXG5leHBvcnRzLmhtYWMgPSBobWFjXG5leHBvcnRzLmtleXMgPSBrZXlzXG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gcmVxdWlyZSgnLi9yYW5kb20tYnl0ZXMnKVxuZXhwb3J0cy5wYmtkZjIgPSByZXF1aXJlKCcuL3Bia2RmMicpXG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5wcmVTdGFydCA9IHJlcXVpcmUoJy4vcHJlLXN0YXJ0JylcbmV4cG9ydHMuc3RhcnQgPSByZXF1aXJlKCcuL3N0YXJ0JylcbmV4cG9ydHMuc3RvcCA9IHJlcXVpcmUoJy4vc3RvcCcpXG5leHBvcnRzLmlzT25saW5lID0gcmVxdWlyZSgnLi9pcy1vbmxpbmUnKVxuZXhwb3J0cy52ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJylcbmV4cG9ydHMuaWQgPSByZXF1aXJlKCcuL2lkJylcbmV4cG9ydHMucmVwbyA9IHJlcXVpcmUoJy4vcmVwbycpXG5leHBvcnRzLmluaXQgPSByZXF1aXJlKCcuL2luaXQnKVxuZXhwb3J0cy5ib290c3RyYXAgPSByZXF1aXJlKCcuL2Jvb3RzdHJhcCcpXG5leHBvcnRzLmNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJylcbmV4cG9ydHMuYmxvY2sgPSByZXF1aXJlKCcuL2Jsb2NrJylcbmV4cG9ydHMub2JqZWN0ID0gcmVxdWlyZSgnLi9vYmplY3QnKVxuZXhwb3J0cy5kYWcgPSByZXF1aXJlKCcuL2RhZycpXG5leHBvcnRzLmxpYnAycCA9IHJlcXVpcmUoJy4vbGlicDJwJylcbmV4cG9ydHMuc3dhcm0gPSByZXF1aXJlKCcuL3N3YXJtJylcbmV4cG9ydHMucGluZyA9IHJlcXVpcmUoJy4vcGluZycpXG5leHBvcnRzLnBpbmdQdWxsU3RyZWFtID0gcmVxdWlyZSgnLi9waW5nLXB1bGwtc3RyZWFtJylcbmV4cG9ydHMucGluZ1JlYWRhYmxlU3RyZWFtID0gcmVxdWlyZSgnLi9waW5nLXJlYWRhYmxlLXN0cmVhbScpXG5leHBvcnRzLnBpbiA9IHJlcXVpcmUoJy4vcGluJylcbmV4cG9ydHMuZmlsZXNSZWd1bGFyID0gcmVxdWlyZSgnLi9maWxlcy1yZWd1bGFyJylcbmV4cG9ydHMuZmlsZXNNRlMgPSByZXF1aXJlKCcuL2ZpbGVzLW1mcycpXG5leHBvcnRzLmJpdHN3YXAgPSByZXF1aXJlKCcuL2JpdHN3YXAnKVxuZXhwb3J0cy5wdWJzdWIgPSByZXF1aXJlKCcuL3B1YnN1YicpXG5leHBvcnRzLmRodCA9IHJlcXVpcmUoJy4vZGh0JylcbmV4cG9ydHMuZG5zID0gcmVxdWlyZSgnLi9kbnMnKVxuZXhwb3J0cy5rZXkgPSByZXF1aXJlKCcuL2tleScpXG5leHBvcnRzLnN0YXRzID0gcmVxdWlyZSgnLi9zdGF0cycpXG5leHBvcnRzLnJlc29sdmUgPSByZXF1aXJlKCcuL3Jlc29sdmUnKVxuZXhwb3J0cy5uYW1lID0gcmVxdWlyZSgnLi9uYW1lJylcbiIsImltcG9ydCB7IE1FU1NBR0VfVFlQRSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvYXBwJztcblxuLyoqXG4gKiBBIHdyYXBwZXIgZm9yIGBldGhfYWNjb3VudHNgIHRoYXQgcmV0dXJucyBhbiBlbXB0eSBhcnJheSB3aGVuIHBlcm1pc3Npb24gaXMgZGVuaWVkLlxuICovXG5cbmNvbnN0IHJlcXVlc3RFdGhlcmV1bUFjY291bnRzID0ge1xuICBtZXRob2ROYW1lczogW01FU1NBR0VfVFlQRS5FVEhfQUNDT1VOVFNdLFxuICBpbXBsZW1lbnRhdGlvbjogZXRoQWNjb3VudHNIYW5kbGVyLFxuICBob29rTmFtZXM6IHtcbiAgICBnZXRBY2NvdW50czogdHJ1ZSxcbiAgfSxcbn07XG5leHBvcnQgZGVmYXVsdCByZXF1ZXN0RXRoZXJldW1BY2NvdW50cztcblxuLyoqXG4gKiBAdHlwZWRlZiB7UmVjb3JkPHN0cmluZywgRnVuY3Rpb24+fSBFdGhBY2NvdW50c09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGdldEFjY291bnRzIC0gR2V0cyB0aGUgYWNjb3VudHMgZm9yIHRoZSByZXF1ZXN0aW5nXG4gKiBvcmlnaW4uXG4gKi9cblxuLyoqXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJ2pzb24tcnBjLWVuZ2luZScpLkpzb25ScGNSZXF1ZXN0PHVua25vd24+fSByZXEgLSBUaGUgSlNPTi1SUEMgcmVxdWVzdCBvYmplY3QuXG4gKiBAcGFyYW0ge2ltcG9ydCgnanNvbi1ycGMtZW5naW5lJykuSnNvblJwY1Jlc3BvbnNlPHRydWU+fSByZXMgLSBUaGUgSlNPTi1SUEMgcmVzcG9uc2Ugb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gX25leHQgLSBUaGUganNvbi1ycGMtZW5naW5lICduZXh0JyBjYWxsYmFjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuZCAtIFRoZSBqc29uLXJwYy1lbmdpbmUgJ2VuZCcgY2FsbGJhY2suXG4gKiBAcGFyYW0ge0V0aEFjY291bnRzT3B0aW9uc30gb3B0aW9ucyAtIFRoZSBSUEMgbWV0aG9kIGhvb2tzLlxuICovXG5hc3luYyBmdW5jdGlvbiBldGhBY2NvdW50c0hhbmRsZXIoX3JlcSwgcmVzLCBfbmV4dCwgZW5kLCB7IGdldEFjY291bnRzIH0pIHtcbiAgcmVzLnJlc3VsdCA9IGF3YWl0IGdldEFjY291bnRzKCk7XG4gIHJldHVybiBlbmQoKTtcbn1cbiIsImltcG9ydCB7IE1FU1NBR0VfVFlQRSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvYXBwJztcblxuLyoqXG4gKiBUaGlzIFJQQyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBpbnBhZ2UgcHJvdmlkZXIgd2hlbmV2ZXIgaXQgZGV0ZWN0cyB0aGVcbiAqIGFjY2Vzc2luZyBvZiBhIG5vbi1leGlzdGVudCBwcm9wZXJ0eSBvbiBvdXIgd2luZG93LndlYjMgc2hpbS5cbiAqIFdlIGNvbGxlY3QgdGhpcyBkYXRhIHRvIHVuZGVyc3RhbmQgd2hpY2ggc2l0ZXMgYXJlIGJyZWFraW5nIGR1ZSB0byB0aGVcbiAqIHJlbW92YWwgb2Ygb3VyIHdpbmRvdy53ZWIzLlxuICovXG5cbmNvbnN0IGxvZ1dlYjNTaGltVXNhZ2UgPSB7XG4gIG1ldGhvZE5hbWVzOiBbTUVTU0FHRV9UWVBFLkxPR19XRUIzX1NISU1fVVNBR0VdLFxuICBpbXBsZW1lbnRhdGlvbjogbG9nV2ViM1NoaW1Vc2FnZUhhbmRsZXIsXG4gIGhvb2tOYW1lczoge1xuICAgIHNlbmRNZXRyaWNzOiB0cnVlLFxuICAgIGdldFdlYjNTaGltVXNhZ2VTdGF0ZTogdHJ1ZSxcbiAgICBzZXRXZWIzU2hpbVVzYWdlUmVjb3JkZWQ6IHRydWUsXG4gIH0sXG59O1xuZXhwb3J0IGRlZmF1bHQgbG9nV2ViM1NoaW1Vc2FnZTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMb2dXZWIzU2hpbVVzYWdlT3B0aW9uc1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gc2VuZE1ldHJpY3MgLSBBIGZ1bmN0aW9uIHRoYXQgcmVnaXN0ZXJzIGEgbWV0cmljcyBldmVudC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGdldFdlYjNTaGltVXNhZ2VTdGF0ZSAtIEEgZnVuY3Rpb24gdGhhdCBnZXRzIHdlYjMgc2hpbVxuICogdXNhZ2Ugc3RhdGUgZm9yIHRoZSBnaXZlbiBvcmlnaW4uXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBzZXRXZWIzU2hpbVVzYWdlUmVjb3JkZWQgLSBBIGZ1bmN0aW9uIHRoYXQgcmVjb3JkcyB3ZWIzIHNoaW1cbiAqIHVzYWdlIGZvciBhIHBhcnRpY3VsYXIgb3JpZ2luLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJ2pzb24tcnBjLWVuZ2luZScpLkpzb25ScGNSZXF1ZXN0PHVua25vd24+fSByZXEgLSBUaGUgSlNPTi1SUEMgcmVxdWVzdCBvYmplY3QuXG4gKiBAcGFyYW0ge2ltcG9ydCgnanNvbi1ycGMtZW5naW5lJykuSnNvblJwY1Jlc3BvbnNlPHRydWU+fSByZXMgLSBUaGUgSlNPTi1SUEMgcmVzcG9uc2Ugb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gX25leHQgLSBUaGUganNvbi1ycGMtZW5naW5lICduZXh0JyBjYWxsYmFjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuZCAtIFRoZSBqc29uLXJwYy1lbmdpbmUgJ2VuZCcgY2FsbGJhY2suXG4gKiBAcGFyYW0ge0xvZ1dlYjNTaGltVXNhZ2VPcHRpb25zfSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGxvZ1dlYjNTaGltVXNhZ2VIYW5kbGVyKFxuICByZXEsXG4gIHJlcyxcbiAgX25leHQsXG4gIGVuZCxcbiAgeyBzZW5kTWV0cmljcywgZ2V0V2ViM1NoaW1Vc2FnZVN0YXRlLCBzZXRXZWIzU2hpbVVzYWdlUmVjb3JkZWQgfSxcbikge1xuICBjb25zdCB7IG9yaWdpbiB9ID0gcmVxO1xuICBpZiAoZ2V0V2ViM1NoaW1Vc2FnZVN0YXRlKG9yaWdpbikgPT09IHVuZGVmaW5lZCkge1xuICAgIHNldFdlYjNTaGltVXNhZ2VSZWNvcmRlZChvcmlnaW4pO1xuXG4gICAgc2VuZE1ldHJpY3MoXG4gICAgICB7XG4gICAgICAgIGV2ZW50OiBgV2Vic2l0ZSBBY2Nlc3NlZCB3aW5kb3cud2ViMyBTaGltYCxcbiAgICAgICAgY2F0ZWdvcnk6ICdpbnBhZ2VfcHJvdmlkZXInLFxuICAgICAgICByZWZlcnJlcjoge1xuICAgICAgICAgIHVybDogb3JpZ2luLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZXhjbHVkZU1ldGFNZXRyaWNzSWQ6IHRydWUsXG4gICAgICB9LFxuICAgICk7XG4gIH1cblxuICByZXMucmVzdWx0ID0gdHJ1ZTtcbiAgcmV0dXJuIGVuZCgpO1xufVxuIiwiaW1wb3J0IHsgTUVTU0FHRV9UWVBFIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9hcHAnO1xuXG5jb25zdCB3YXRjaEFzc2V0ID0ge1xuICBtZXRob2ROYW1lczogW01FU1NBR0VfVFlQRS5XQVRDSF9BU1NFVCwgTUVTU0FHRV9UWVBFLldBVENIX0FTU0VUX0xFR0FDWV0sXG4gIGltcGxlbWVudGF0aW9uOiB3YXRjaEFzc2V0SGFuZGxlcixcbiAgaG9va05hbWVzOiB7XG4gICAgaGFuZGxlV2F0Y2hBc3NldFJlcXVlc3Q6IHRydWUsXG4gIH0sXG59O1xuZXhwb3J0IGRlZmF1bHQgd2F0Y2hBc3NldDtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBXYXRjaEFzc2V0T3B0aW9uc1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaGFuZGxlV2F0Y2hBc3NldFJlcXVlc3QgLSBUaGUgd2FsbGV0X3dhdGNoQXNzZXQgbWV0aG9kIGltcGxlbWVudGF0aW9uLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gV2F0Y2hBc3NldFBhcmFtXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBhc3NldCB0byB3YXRjaC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcHRpb25zIC0gV2F0Y2ggb3B0aW9ucyBmb3IgdGhlIGFzc2V0LlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJ2pzb24tcnBjLWVuZ2luZScpLkpzb25ScGNSZXF1ZXN0PFdhdGNoQXNzZXRQYXJhbT59IHJlcSAtIFRoZSBKU09OLVJQQyByZXF1ZXN0IG9iamVjdC5cbiAqIEBwYXJhbSB7aW1wb3J0KCdqc29uLXJwYy1lbmdpbmUnKS5Kc29uUnBjUmVzcG9uc2U8dHJ1ZT59IHJlcyAtIFRoZSBKU09OLVJQQyByZXNwb25zZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBfbmV4dCAtIFRoZSBqc29uLXJwYy1lbmdpbmUgJ25leHQnIGNhbGxiYWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5kIC0gVGhlIGpzb24tcnBjLWVuZ2luZSAnZW5kJyBjYWxsYmFjay5cbiAqIEBwYXJhbSB7V2F0Y2hBc3NldE9wdGlvbnN9IG9wdGlvbnNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gd2F0Y2hBc3NldEhhbmRsZXIoXG4gIHJlcSxcbiAgcmVzLFxuICBfbmV4dCxcbiAgZW5kLFxuICB7IGhhbmRsZVdhdGNoQXNzZXRSZXF1ZXN0IH0sXG4pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IG9wdGlvbnM6IGFzc2V0LCB0eXBlIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBoYW5kbGVXYXRjaEFzc2V0UmVxdWVzdChhc3NldCwgdHlwZSk7XG4gICAgcmV0dXJuIGVuZCgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBlbmQoZXJyb3IpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBldGhFcnJvcnMgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XG5pbXBvcnQgeyBNRVNTQUdFX1RZUEUgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2FwcCc7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgYXR0ZW1wdHMgdG8gcmV0cmlldmUgdGhlIEV0aGVyZXVtIGFjY291bnRzIGF2YWlsYWJsZSB0byB0aGVcbiAqIHJlcXVlc3Rlciwgb3IgaW5pdGlhdGUgYSByZXF1ZXN0IGZvciBhY2NvdW50IGFjY2VzcyBpZiBub25lIGFyZSBjdXJyZW50bHlcbiAqIGF2YWlsYWJsZS4gSXQgaXMgZXNzZW50aWFsbHkgYSB3cmFwcGVyIG9mIHdhbGxldF9yZXF1ZXN0UGVybWlzc2lvbnMgdGhhdFxuICogb25seSBlcnJvcnMgaWYgdGhlIHVzZXIgcmVqZWN0cyB0aGUgcmVxdWVzdC4gV2UgbWFpbnRhaW4gdGhlIG1ldGhvZCBmb3JcbiAqIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnMuXG4gKi9cblxuY29uc3QgcmVxdWVzdEV0aGVyZXVtQWNjb3VudHMgPSB7XG4gIG1ldGhvZE5hbWVzOiBbTUVTU0FHRV9UWVBFLkVUSF9SRVFVRVNUX0FDQ09VTlRTXSxcbiAgaW1wbGVtZW50YXRpb246IHJlcXVlc3RFdGhlcmV1bUFjY291bnRzSGFuZGxlcixcbiAgaG9va05hbWVzOiB7XG4gICAgb3JpZ2luOiB0cnVlLFxuICAgIGdldEFjY291bnRzOiB0cnVlLFxuICAgIGdldFVubG9ja1Byb21pc2U6IHRydWUsXG4gICAgaGFzUGVybWlzc2lvbjogdHJ1ZSxcbiAgICByZXF1ZXN0QWNjb3VudHNQZXJtaXNzaW9uOiB0cnVlLFxuICB9LFxufTtcbmV4cG9ydCBkZWZhdWx0IHJlcXVlc3RFdGhlcmV1bUFjY291bnRzO1xuXG4vLyBVc2VkIHRvIHJhdGUtbGltaXQgcGVuZGluZyByZXF1ZXN0cyB0byBvbmUgcGVyIG9yaWdpblxuY29uc3QgbG9ja3MgPSBuZXcgU2V0KCk7XG5cbi8qKlxuICogQHR5cGVkZWYge1JlY29yZDxzdHJpbmcsIHN0cmluZyB8IEZ1bmN0aW9uPn0gUmVxdWVzdEV0aGVyZXVtQWNjb3VudHNPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gb3JpZ2luIC0gVGhlIHJlcXVlc3Rpbmcgb3JpZ2luLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZ2V0QWNjb3VudHMgLSBHZXRzIHRoZSBhY2NvdW50cyBmb3IgdGhlIHJlcXVlc3RpbmdcbiAqIG9yaWdpbi5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGdldFVubG9ja1Byb21pc2UgLSBHZXRzIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW5cbiAqIHRoZSBleHRlbnNpb24gdW5sb2Nrcy5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGhhc1Blcm1pc3Npb24gLSBSZXR1cm5zIHdoZXRoZXIgdGhlIHJlcXVlc3Rpbmcgb3JpZ2luXG4gKiBoYXMgdGhlIHNwZWNpZmllZCBwZXJtaXNzaW9uLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcmVxdWVzdEFjY291bnRzUGVybWlzc2lvbiAtIFJlcXVlc3RzIHRoZSBgZXRoX2FjY291bnRzYFxuICogcGVybWlzc2lvbiBmb3IgdGhlIHJlcXVlc3Rpbmcgb3JpZ2luLlxuICovXG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KCdqc29uLXJwYy1lbmdpbmUnKS5Kc29uUnBjUmVxdWVzdDx1bmtub3duPn0gX3JlcSAtIFRoZSBKU09OLVJQQyByZXF1ZXN0IG9iamVjdC5cbiAqIEBwYXJhbSB7aW1wb3J0KCdqc29uLXJwYy1lbmdpbmUnKS5Kc29uUnBjUmVzcG9uc2U8dHJ1ZT59IHJlcyAtIFRoZSBKU09OLVJQQyByZXNwb25zZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBfbmV4dCAtIFRoZSBqc29uLXJwYy1lbmdpbmUgJ25leHQnIGNhbGxiYWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5kIC0gVGhlIGpzb24tcnBjLWVuZ2luZSAnZW5kJyBjYWxsYmFjay5cbiAqIEBwYXJhbSB7UmVxdWVzdEV0aGVyZXVtQWNjb3VudHNPcHRpb25zfSBvcHRpb25zIC0gVGhlIFJQQyBtZXRob2QgaG9va3MuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlcXVlc3RFdGhlcmV1bUFjY291bnRzSGFuZGxlcihcbiAgX3JlcSxcbiAgcmVzLFxuICBfbmV4dCxcbiAgZW5kLFxuICB7XG4gICAgb3JpZ2luLFxuICAgIGdldEFjY291bnRzLFxuICAgIGdldFVubG9ja1Byb21pc2UsXG4gICAgaGFzUGVybWlzc2lvbixcbiAgICByZXF1ZXN0QWNjb3VudHNQZXJtaXNzaW9uLFxuICB9LFxuKSB7XG4gIGlmIChsb2Nrcy5oYXMob3JpZ2luKSkge1xuICAgIHJlcy5lcnJvciA9IGV0aEVycm9ycy5ycGMucmVzb3VyY2VVbmF2YWlsYWJsZShcbiAgICAgIGBBbHJlYWR5IHByb2Nlc3NpbmcgJHtNRVNTQUdFX1RZUEUuRVRIX1JFUVVFU1RfQUNDT1VOVFN9LiBQbGVhc2Ugd2FpdC5gLFxuICAgICk7XG4gICAgcmV0dXJuIGVuZCgpO1xuICB9XG5cbiAgaWYgKGhhc1Blcm1pc3Npb24oTUVTU0FHRV9UWVBFLkVUSF9BQ0NPVU5UUykpIHtcbiAgICAvLyBXZSB3YWl0IGZvciB0aGUgZXh0ZW5zaW9uIHRvIHVubG9jayBpbiB0aGlzIGNhc2Ugb25seSwgYmVjYXVzZSBwZXJtaXNzaW9uXG4gICAgLy8gcmVxdWVzdHMgYXJlIGhhbmRsZWQgd2hlbiB0aGUgZXh0ZW5zaW9uIGlzIHVubG9ja2VkLCByZWdhcmRsZXNzIG9mIHRoZVxuICAgIC8vIGxvY2sgc3RhdGUgd2hlbiB0aGV5IHdlcmUgcmVjZWl2ZWQuXG4gICAgdHJ5IHtcbiAgICAgIGxvY2tzLmFkZChvcmlnaW4pO1xuICAgICAgYXdhaXQgZ2V0VW5sb2NrUHJvbWlzZSgpO1xuICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IGdldEFjY291bnRzKCk7XG4gICAgICBlbmQoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZW5kKGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgbG9ja3MuZGVsZXRlKG9yaWdpbik7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBJZiBubyBhY2NvdW50cywgcmVxdWVzdCB0aGUgYWNjb3VudHMgcGVybWlzc2lvblxuICB0cnkge1xuICAgIGF3YWl0IHJlcXVlc3RBY2NvdW50c1Blcm1pc3Npb24oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmVzLmVycm9yID0gZXJyO1xuICAgIHJldHVybiBlbmQoKTtcbiAgfVxuXG4gIC8vIEdldCB0aGUgYXBwcm92ZWQgYWNjb3VudHNcbiAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBnZXRBY2NvdW50cygpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogdG9vIGhhcmQgdG8gaW5kdWNlLCBzZWUgYmVsb3cgY29tbWVudCAqL1xuICBpZiAoYWNjb3VudHMubGVuZ3RoID4gMCkge1xuICAgIHJlcy5yZXN1bHQgPSBhY2NvdW50cztcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIGJlY2F1c2UgaXQgc2hvdWxkIGJlIGNhdWdodCBpbiB0aGVcbiAgICAvLyBhYm92ZSBjYXRjaCBjbGF1c2VcbiAgICByZXMuZXJyb3IgPSBldGhFcnJvcnMucnBjLmludGVybmFsKFxuICAgICAgJ0FjY291bnRzIHVuZXhwZWN0ZWRseSB1bmF2YWlsYWJsZS4gUGxlYXNlIHJlcG9ydCB0aGlzIGJ1Zy4nLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gZW5kKCk7XG59XG4iLCJpbXBvcnQgeyBldGhFcnJvcnMgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XG5pbXBvcnQgeyBvbWl0IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IE1FU1NBR0VfVFlQRSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvYXBwJztcbmltcG9ydCB7XG4gIEVUSF9TWU1CT0wsXG4gIENIQUlOX0lEX1RPX1RZUEVfTUFQLFxuICBORVRXT1JLX1RPX05BTUVfTUFQLFxuICBDSEFJTl9JRF9UT19SUENfVVJMX01BUCxcbn0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcbmltcG9ydCB7XG4gIGlzUHJlZml4ZWRGb3JtYXR0ZWRIZXhTdHJpbmcsXG4gIGlzU2FmZUNoYWluSWQsXG59IGZyb20gJy4uLy4uLy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL25ldHdvcmsudXRpbHMnO1xuXG5jb25zdCBzd2l0Y2hFdGhlcmV1bUNoYWluID0ge1xuICBtZXRob2ROYW1lczogW01FU1NBR0VfVFlQRS5TV0lUQ0hfRVRIRVJFVU1fQ0hBSU5dLFxuICBpbXBsZW1lbnRhdGlvbjogc3dpdGNoRXRoZXJldW1DaGFpbkhhbmRsZXIsXG4gIGhvb2tOYW1lczoge1xuICAgIGdldEN1cnJlbnRDaGFpbklkOiB0cnVlLFxuICAgIGZpbmRDdXN0b21ScGNCeTogdHJ1ZSxcbiAgICBzZXRQcm92aWRlclR5cGU6IHRydWUsXG4gICAgdXBkYXRlUnBjVGFyZ2V0OiB0cnVlLFxuICAgIHJlcXVlc3RVc2VyQXBwcm92YWw6IHRydWUsXG4gIH0sXG59O1xuZXhwb3J0IGRlZmF1bHQgc3dpdGNoRXRoZXJldW1DaGFpbjtcblxuZnVuY3Rpb24gZmluZEV4aXN0aW5nTmV0d29yayhjaGFpbklkLCBmaW5kQ3VzdG9tUnBjQnkpIHtcbiAgaWYgKGNoYWluSWQgaW4gQ0hBSU5fSURfVE9fVFlQRV9NQVApIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2hhaW5JZCxcbiAgICAgIHRpY2tlcjogRVRIX1NZTUJPTCxcbiAgICAgIG5pY2tuYW1lOiBORVRXT1JLX1RPX05BTUVfTUFQW2NoYWluSWRdLFxuICAgICAgcnBjVXJsOiBDSEFJTl9JRF9UT19SUENfVVJMX01BUFtjaGFpbklkXSxcbiAgICAgIHR5cGU6IENIQUlOX0lEX1RPX1RZUEVfTUFQW2NoYWluSWRdLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gZmluZEN1c3RvbVJwY0J5KHsgY2hhaW5JZCB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc3dpdGNoRXRoZXJldW1DaGFpbkhhbmRsZXIoXG4gIHJlcSxcbiAgcmVzLFxuICBfbmV4dCxcbiAgZW5kLFxuICB7XG4gICAgZ2V0Q3VycmVudENoYWluSWQsXG4gICAgZmluZEN1c3RvbVJwY0J5LFxuICAgIHNldFByb3ZpZGVyVHlwZSxcbiAgICB1cGRhdGVScGNUYXJnZXQsXG4gICAgcmVxdWVzdFVzZXJBcHByb3ZhbCxcbiAgfSxcbikge1xuICBpZiAoIXJlcS5wYXJhbXM/LlswXSB8fCB0eXBlb2YgcmVxLnBhcmFtc1swXSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZW5kKFxuICAgICAgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkIHNpbmdsZSwgb2JqZWN0IHBhcmFtZXRlci4gUmVjZWl2ZWQ6XFxuJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICByZXEucGFyYW1zLFxuICAgICAgICApfWAsXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgY29uc3QgeyBvcmlnaW4gfSA9IHJlcTtcblxuICBjb25zdCB7IGNoYWluSWQgfSA9IHJlcS5wYXJhbXNbMF07XG5cbiAgY29uc3Qgb3RoZXJLZXlzID0gT2JqZWN0LmtleXMob21pdChyZXEucGFyYW1zWzBdLCBbJ2NoYWluSWQnXSkpO1xuXG4gIGlmIChvdGhlcktleXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBlbmQoXG4gICAgICBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICBtZXNzYWdlOiBgUmVjZWl2ZWQgdW5leHBlY3RlZCBrZXlzIG9uIG9iamVjdCBwYXJhbWV0ZXIuIFVuc3VwcG9ydGVkIGtleXM6XFxuJHtvdGhlcktleXN9YCxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBfY2hhaW5JZCA9IHR5cGVvZiBjaGFpbklkID09PSAnc3RyaW5nJyAmJiBjaGFpbklkLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKCFpc1ByZWZpeGVkRm9ybWF0dGVkSGV4U3RyaW5nKF9jaGFpbklkKSkge1xuICAgIHJldHVybiBlbmQoXG4gICAgICBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICBtZXNzYWdlOiBgRXhwZWN0ZWQgMHgtcHJlZml4ZWQsIHVucGFkZGVkLCBub24temVybyBoZXhhZGVjaW1hbCBzdHJpbmcgJ2NoYWluSWQnLiBSZWNlaXZlZDpcXG4ke2NoYWluSWR9YCxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBpZiAoIWlzU2FmZUNoYWluSWQocGFyc2VJbnQoX2NoYWluSWQsIDE2KSkpIHtcbiAgICByZXR1cm4gZW5kKFxuICAgICAgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgbWVzc2FnZTogYEludmFsaWQgY2hhaW4gSUQgXCIke19jaGFpbklkfVwiOiBudW1lcmljYWwgdmFsdWUgZ3JlYXRlciB0aGFuIG1heCBzYWZlIHZhbHVlLiBSZWNlaXZlZDpcXG4ke2NoYWluSWR9YCxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBjb25zdCByZXF1ZXN0RGF0YSA9IGZpbmRFeGlzdGluZ05ldHdvcmsoX2NoYWluSWQsIGZpbmRDdXN0b21ScGNCeSk7XG4gIGlmIChyZXF1ZXN0RGF0YSkge1xuICAgIGNvbnN0IGN1cnJlbnRDaGFpbklkID0gZ2V0Q3VycmVudENoYWluSWQoKTtcbiAgICBpZiAoY3VycmVudENoYWluSWQgPT09IF9jaGFpbklkKSB7XG4gICAgICByZXMucmVzdWx0ID0gbnVsbDtcbiAgICAgIHJldHVybiBlbmQoKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFwcHJvdmVkUmVxdWVzdERhdGEgPSBhd2FpdCByZXF1ZXN0VXNlckFwcHJvdmFsKHtcbiAgICAgICAgb3JpZ2luLFxuICAgICAgICB0eXBlOiBNRVNTQUdFX1RZUEUuU1dJVENIX0VUSEVSRVVNX0NIQUlOLFxuICAgICAgICByZXF1ZXN0RGF0YSxcbiAgICAgIH0pO1xuICAgICAgaWYgKGNoYWluSWQgaW4gQ0hBSU5fSURfVE9fVFlQRV9NQVApIHtcbiAgICAgICAgc2V0UHJvdmlkZXJUeXBlKGFwcHJvdmVkUmVxdWVzdERhdGEudHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCB1cGRhdGVScGNUYXJnZXQoYXBwcm92ZWRSZXF1ZXN0RGF0YSk7XG4gICAgICB9XG4gICAgICByZXMucmVzdWx0ID0gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGVuZChlcnJvcik7XG4gICAgfVxuICAgIHJldHVybiBlbmQoKTtcbiAgfVxuICByZXR1cm4gZW5kKFxuICAgIGV0aEVycm9ycy5wcm92aWRlci5jdXN0b20oe1xuICAgICAgY29kZTogNDkwMiwgLy8gVG8tYmUtc3RhbmRhcmRpemVkIFwidW5yZWNvZ25pemVkIGNoYWluIElEXCIgZXJyb3JcbiAgICAgIG1lc3NhZ2U6IGBVbnJlY29nbml6ZWQgY2hhaW4gSUQgXCIke2NoYWluSWR9XCIuIFRyeSBhZGRpbmcgdGhlIGNoYWluIHVzaW5nICR7TUVTU0FHRV9UWVBFLkFERF9FVEhFUkVVTV9DSEFJTn0gZmlyc3QuYCxcbiAgICB9KSxcbiAgKTtcbn1cbiIsImltcG9ydCB7IGV0aEVycm9ycywgZXJyb3JDb2RlcyB9IGZyb20gJ2V0aC1ycGMtZXJyb3JzJztcbmltcG9ydCB2YWxpZFVybCBmcm9tICd2YWxpZC11cmwnO1xuaW1wb3J0IHsgb21pdCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBNRVNTQUdFX1RZUEUgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2FwcCc7XG5pbXBvcnQge1xuICBpc1ByZWZpeGVkRm9ybWF0dGVkSGV4U3RyaW5nLFxuICBpc1NhZmVDaGFpbklkLFxufSBmcm9tICcuLi8uLi8uLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9uZXR3b3JrLnV0aWxzJztcbmltcG9ydCB7IGpzb25ScGNSZXF1ZXN0IH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvcnBjLnV0aWxzJztcbmltcG9ydCB7IENIQUlOX0lEX1RPX05FVFdPUktfSURfTUFQIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcblxuY29uc3QgYWRkRXRoZXJldW1DaGFpbiA9IHtcbiAgbWV0aG9kTmFtZXM6IFtNRVNTQUdFX1RZUEUuQUREX0VUSEVSRVVNX0NIQUlOXSxcbiAgaW1wbGVtZW50YXRpb246IGFkZEV0aGVyZXVtQ2hhaW5IYW5kbGVyLFxuICBob29rTmFtZXM6IHtcbiAgICBhZGRDdXN0b21ScGM6IHRydWUsXG4gICAgZ2V0Q3VycmVudENoYWluSWQ6IHRydWUsXG4gICAgZmluZEN1c3RvbVJwY0J5OiB0cnVlLFxuICAgIHVwZGF0ZVJwY1RhcmdldDogdHJ1ZSxcbiAgICByZXF1ZXN0VXNlckFwcHJvdmFsOiB0cnVlLFxuICAgIHNlbmRNZXRyaWNzOiB0cnVlLFxuICB9LFxufTtcbmV4cG9ydCBkZWZhdWx0IGFkZEV0aGVyZXVtQ2hhaW47XG5cbmFzeW5jIGZ1bmN0aW9uIGFkZEV0aGVyZXVtQ2hhaW5IYW5kbGVyKFxuICByZXEsXG4gIHJlcyxcbiAgX25leHQsXG4gIGVuZCxcbiAge1xuICAgIGFkZEN1c3RvbVJwYyxcbiAgICBnZXRDdXJyZW50Q2hhaW5JZCxcbiAgICBmaW5kQ3VzdG9tUnBjQnksXG4gICAgdXBkYXRlUnBjVGFyZ2V0LFxuICAgIHJlcXVlc3RVc2VyQXBwcm92YWwsXG4gICAgc2VuZE1ldHJpY3MsXG4gIH0sXG4pIHtcbiAgaWYgKCFyZXEucGFyYW1zPy5bMF0gfHwgdHlwZW9mIHJlcS5wYXJhbXNbMF0gIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGVuZChcbiAgICAgIGV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCBzaW5nbGUsIG9iamVjdCBwYXJhbWV0ZXIuIFJlY2VpdmVkOlxcbiR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgcmVxLnBhcmFtcyxcbiAgICAgICAgKX1gLFxuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IHsgb3JpZ2luIH0gPSByZXE7XG5cbiAgY29uc3Qge1xuICAgIGNoYWluSWQsXG4gICAgY2hhaW5OYW1lID0gbnVsbCxcbiAgICBibG9ja0V4cGxvcmVyVXJscyA9IG51bGwsXG4gICAgbmF0aXZlQ3VycmVuY3kgPSBudWxsLFxuICAgIHJwY1VybHMsXG4gIH0gPSByZXEucGFyYW1zWzBdO1xuXG4gIGNvbnN0IG90aGVyS2V5cyA9IE9iamVjdC5rZXlzKFxuICAgIG9taXQocmVxLnBhcmFtc1swXSwgW1xuICAgICAgJ2NoYWluSWQnLFxuICAgICAgJ2NoYWluTmFtZScsXG4gICAgICAnYmxvY2tFeHBsb3JlclVybHMnLFxuICAgICAgJ2ljb25VcmxzJyxcbiAgICAgICdycGNVcmxzJyxcbiAgICAgICduYXRpdmVDdXJyZW5jeScsXG4gICAgXSksXG4gICk7XG5cbiAgaWYgKG90aGVyS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGVuZChcbiAgICAgIGV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgIG1lc3NhZ2U6IGBSZWNlaXZlZCB1bmV4cGVjdGVkIGtleXMgb24gb2JqZWN0IHBhcmFtZXRlci4gVW5zdXBwb3J0ZWQga2V5czpcXG4ke290aGVyS2V5c31gLFxuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGZpcnN0VmFsaWRSUENVcmwgPSBBcnJheS5pc0FycmF5KHJwY1VybHMpXG4gICAgPyBycGNVcmxzLmZpbmQoKHJwY1VybCkgPT4gdmFsaWRVcmwuaXNIdHRwc1VyaShycGNVcmwpKVxuICAgIDogbnVsbDtcblxuICBjb25zdCBmaXJzdFZhbGlkQmxvY2tFeHBsb3JlclVybCA9XG4gICAgYmxvY2tFeHBsb3JlclVybHMgIT09IG51bGwgJiYgQXJyYXkuaXNBcnJheShibG9ja0V4cGxvcmVyVXJscylcbiAgICAgID8gYmxvY2tFeHBsb3JlclVybHMuZmluZCgoYmxvY2tFeHBsb3JlclVybCkgPT5cbiAgICAgICAgICB2YWxpZFVybC5pc0h0dHBzVXJpKGJsb2NrRXhwbG9yZXJVcmwpLFxuICAgICAgICApXG4gICAgICA6IG51bGw7XG5cbiAgaWYgKCFmaXJzdFZhbGlkUlBDVXJsKSB7XG4gICAgcmV0dXJuIGVuZChcbiAgICAgIGV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IG9uZSB2YWxpZCBzdHJpbmcgSFRUUFMgdXJsICdycGNVcmxzJywgUmVjZWl2ZWQ6XFxuJHtycGNVcmxzfWAsXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgaWYgKGJsb2NrRXhwbG9yZXJVcmxzICE9PSBudWxsICYmICFmaXJzdFZhbGlkQmxvY2tFeHBsb3JlclVybCkge1xuICAgIHJldHVybiBlbmQoXG4gICAgICBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICBtZXNzYWdlOiBgRXhwZWN0ZWQgbnVsbCBvciBhcnJheSB3aXRoIGF0IGxlYXN0IG9uZSB2YWxpZCBzdHJpbmcgSFRUUFMgVVJMICdibG9ja0V4cGxvcmVyVXJsJy4gUmVjZWl2ZWQ6ICR7YmxvY2tFeHBsb3JlclVybHN9YCxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBfY2hhaW5JZCA9IHR5cGVvZiBjaGFpbklkID09PSAnc3RyaW5nJyAmJiBjaGFpbklkLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKCFpc1ByZWZpeGVkRm9ybWF0dGVkSGV4U3RyaW5nKF9jaGFpbklkKSkge1xuICAgIHJldHVybiBlbmQoXG4gICAgICBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICBtZXNzYWdlOiBgRXhwZWN0ZWQgMHgtcHJlZml4ZWQsIHVucGFkZGVkLCBub24temVybyBoZXhhZGVjaW1hbCBzdHJpbmcgJ2NoYWluSWQnLiBSZWNlaXZlZDpcXG4ke2NoYWluSWR9YCxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBpZiAoIWlzU2FmZUNoYWluSWQocGFyc2VJbnQoX2NoYWluSWQsIDE2KSkpIHtcbiAgICByZXR1cm4gZW5kKFxuICAgICAgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgbWVzc2FnZTogYEludmFsaWQgY2hhaW4gSUQgXCIke19jaGFpbklkfVwiOiBudW1lcmljYWwgdmFsdWUgZ3JlYXRlciB0aGFuIG1heCBzYWZlIHZhbHVlLiBSZWNlaXZlZDpcXG4ke2NoYWluSWR9YCxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBpZiAoQ0hBSU5fSURfVE9fTkVUV09SS19JRF9NQVBbX2NoYWluSWRdKSB7XG4gICAgcmV0dXJuIGVuZChcbiAgICAgIGV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgIG1lc3NhZ2U6IGBNYXkgbm90IHNwZWNpZnkgZGVmYXVsdCBNZXRhTWFzayBjaGFpbi5gLFxuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGV4aXN0aW5nTmV0d29yayA9IGZpbmRDdXN0b21ScGNCeSh7IGNoYWluSWQ6IF9jaGFpbklkIH0pO1xuXG4gIGlmIChleGlzdGluZ05ldHdvcmspIHtcbiAgICAvLyBJZiB0aGUgbmV0d29yayBhbHJlYWR5IGV4aXN0cywgdGhlIHJlcXVlc3QgaXMgY29uc2lkZXJlZCBzdWNjZXNzZnVsXG4gICAgcmVzLnJlc3VsdCA9IG51bGw7XG5cbiAgICBjb25zdCBjdXJyZW50Q2hhaW5JZCA9IGdldEN1cnJlbnRDaGFpbklkKCk7XG4gICAgaWYgKGN1cnJlbnRDaGFpbklkID09PSBfY2hhaW5JZCkge1xuICAgICAgcmV0dXJuIGVuZCgpO1xuICAgIH1cblxuICAgIC8vIEFzayB0aGUgdXNlciB0byBzd2l0Y2ggdGhlIG5ldHdvcmtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdXBkYXRlUnBjVGFyZ2V0KFxuICAgICAgICBhd2FpdCByZXF1ZXN0VXNlckFwcHJvdmFsKHtcbiAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgdHlwZTogTUVTU0FHRV9UWVBFLlNXSVRDSF9FVEhFUkVVTV9DSEFJTixcbiAgICAgICAgICByZXF1ZXN0RGF0YToge1xuICAgICAgICAgICAgcnBjVXJsOiBleGlzdGluZ05ldHdvcmsucnBjVXJsLFxuICAgICAgICAgICAgY2hhaW5JZDogZXhpc3RpbmdOZXR3b3JrLmNoYWluSWQsXG4gICAgICAgICAgICBuaWNrbmFtZTogZXhpc3RpbmdOZXR3b3JrLm5pY2tuYW1lLFxuICAgICAgICAgICAgdGlja2VyOiBleGlzdGluZ05ldHdvcmsudGlja2VyLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICAgIHJlcy5yZXN1bHQgPSBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBGb3IgdGhlIHB1cnBvc2VzIG9mIHRoaXMgbWV0aG9kLCBpdCBkb2VzIG5vdCBtYXR0ZXIgaWYgdGhlIHVzZXJcbiAgICAgIC8vIGRlY2xpbmVzIHRvIHN3aXRjaCB0aGUgc2VsZWN0ZWQgbmV0d29yay4gSG93ZXZlciwgb3RoZXIgZXJyb3JzIGluZGljYXRlXG4gICAgICAvLyB0aGF0IHNvbWV0aGluZyBpcyB3cm9uZy5cbiAgICAgIGlmIChlcnJvci5jb2RlICE9PSBlcnJvckNvZGVzLnByb3ZpZGVyLnVzZXJSZWplY3RlZFJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIGVuZChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmQoKTtcbiAgfVxuXG4gIGxldCBlbmRwb2ludENoYWluSWQ7XG5cbiAgdHJ5IHtcbiAgICBlbmRwb2ludENoYWluSWQgPSBhd2FpdCBqc29uUnBjUmVxdWVzdChmaXJzdFZhbGlkUlBDVXJsLCAnZXRoX2NoYWluSWQnKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGVuZChcbiAgICAgIGV0aEVycm9ycy5ycGMuaW50ZXJuYWwoe1xuICAgICAgICBtZXNzYWdlOiBgUmVxdWVzdCBmb3IgbWV0aG9kICdldGhfY2hhaW5JZCBvbiAke2ZpcnN0VmFsaWRSUENVcmx9IGZhaWxlZGAsXG4gICAgICAgIGRhdGE6IHsgbmV0d29ya0VycjogZXJyIH0sXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgaWYgKF9jaGFpbklkICE9PSBlbmRwb2ludENoYWluSWQpIHtcbiAgICByZXR1cm4gZW5kKFxuICAgICAgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgbWVzc2FnZTogYENoYWluIElEIHJldHVybmVkIGJ5IFJQQyBVUkwgJHtmaXJzdFZhbGlkUlBDVXJsfSBkb2VzIG5vdCBtYXRjaCAke19jaGFpbklkfWAsXG4gICAgICAgIGRhdGE6IHsgY2hhaW5JZDogZW5kcG9pbnRDaGFpbklkIH0sXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGFpbk5hbWUgIT09ICdzdHJpbmcnIHx8ICFjaGFpbk5hbWUpIHtcbiAgICByZXR1cm4gZW5kKFxuICAgICAgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkIG5vbi1lbXB0eSBzdHJpbmcgJ2NoYWluTmFtZScuIFJlY2VpdmVkOlxcbiR7Y2hhaW5OYW1lfWAsXG4gICAgICB9KSxcbiAgICApO1xuICB9XG4gIGNvbnN0IF9jaGFpbk5hbWUgPVxuICAgIGNoYWluTmFtZS5sZW5ndGggPiAxMDAgPyBjaGFpbk5hbWUuc3Vic3RyaW5nKDAsIDEwMCkgOiBjaGFpbk5hbWU7XG5cbiAgaWYgKG5hdGl2ZUN1cnJlbmN5ICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBuYXRpdmVDdXJyZW5jeSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShuYXRpdmVDdXJyZW5jeSkpIHtcbiAgICAgIHJldHVybiBlbmQoXG4gICAgICAgIGV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkIG51bGwgb3Igb2JqZWN0ICduYXRpdmVDdXJyZW5jeScuIFJlY2VpdmVkOlxcbiR7bmF0aXZlQ3VycmVuY3l9YCxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobmF0aXZlQ3VycmVuY3kuZGVjaW1hbHMgIT09IDE4KSB7XG4gICAgICByZXR1cm4gZW5kKFxuICAgICAgICBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCB0aGUgbnVtYmVyIDE4IGZvciAnbmF0aXZlQ3VycmVuY3kuZGVjaW1hbHMnIHdoZW4gJ25hdGl2ZUN1cnJlbmN5JyBpcyBwcm92aWRlZC4gUmVjZWl2ZWQ6ICR7bmF0aXZlQ3VycmVuY3kuZGVjaW1hbHN9YCxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghbmF0aXZlQ3VycmVuY3kuc3ltYm9sIHx8IHR5cGVvZiBuYXRpdmVDdXJyZW5jeS5zeW1ib2wgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZW5kKFxuICAgICAgICBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCBhIHN0cmluZyAnbmF0aXZlQ3VycmVuY3kuc3ltYm9sJy4gUmVjZWl2ZWQ6ICR7bmF0aXZlQ3VycmVuY3kuc3ltYm9sfWAsXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdGlja2VyID0gbmF0aXZlQ3VycmVuY3k/LnN5bWJvbCB8fCAnRVRIJztcblxuICBpZiAodHlwZW9mIHRpY2tlciAhPT0gJ3N0cmluZycgfHwgdGlja2VyLmxlbmd0aCA8IDIgfHwgdGlja2VyLmxlbmd0aCA+IDYpIHtcbiAgICByZXR1cm4gZW5kKFxuICAgICAgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkIDItNiBjaGFyYWN0ZXIgc3RyaW5nICduYXRpdmVDdXJyZW5jeS5zeW1ib2wnLiBSZWNlaXZlZDpcXG4ke3RpY2tlcn1gLFxuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYXdhaXQgYWRkQ3VzdG9tUnBjKFxuICAgICAgYXdhaXQgcmVxdWVzdFVzZXJBcHByb3ZhbCh7XG4gICAgICAgIG9yaWdpbixcbiAgICAgICAgdHlwZTogTUVTU0FHRV9UWVBFLkFERF9FVEhFUkVVTV9DSEFJTixcbiAgICAgICAgcmVxdWVzdERhdGE6IHtcbiAgICAgICAgICBjaGFpbklkOiBfY2hhaW5JZCxcbiAgICAgICAgICBibG9ja0V4cGxvcmVyVXJsOiBmaXJzdFZhbGlkQmxvY2tFeHBsb3JlclVybCxcbiAgICAgICAgICBjaGFpbk5hbWU6IF9jaGFpbk5hbWUsXG4gICAgICAgICAgcnBjVXJsOiBmaXJzdFZhbGlkUlBDVXJsLFxuICAgICAgICAgIHRpY2tlcixcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICBzZW5kTWV0cmljcyh7XG4gICAgICBldmVudDogJ0N1c3RvbSBOZXR3b3JrIEFkZGVkJyxcbiAgICAgIGNhdGVnb3J5OiAnTmV0d29yaycsXG4gICAgICByZWZlcnJlcjoge1xuICAgICAgICB1cmw6IG9yaWdpbixcbiAgICAgIH0sXG4gICAgICBzZW5zaXRpdmVQcm9wZXJ0aWVzOiB7XG4gICAgICAgIGNoYWluX2lkOiBfY2hhaW5JZCxcbiAgICAgICAgcnBjX3VybDogZmlyc3RWYWxpZFJQQ1VybCxcbiAgICAgICAgbmV0d29ya19uYW1lOiBfY2hhaW5OYW1lLFxuICAgICAgICAvLyBJbmNsdWRpbmcgbmV0d29yayB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBuZXR3b3JrXG4gICAgICAgIC8vIHByb3BlcnR5IGluY2x1ZGVkIGluIGFsbCBldmVudHMuIEZvciBSUEMgdHlwZSBuZXR3b3Jrc1xuICAgICAgICAvLyB0aGUgTWV0YU1ldHJpY3MgY29udHJvbGxlciB1c2VzIHRoZSBycGNVcmwgZm9yIHRoZSBuZXR3b3JrXG4gICAgICAgIC8vIHByb3BlcnR5LlxuICAgICAgICBuZXR3b3JrOiBmaXJzdFZhbGlkUlBDVXJsLFxuICAgICAgICBzeW1ib2w6IHRpY2tlcixcbiAgICAgICAgYmxvY2tfZXhwbG9yZXJfdXJsOiBmaXJzdFZhbGlkQmxvY2tFeHBsb3JlclVybCxcbiAgICAgICAgc291cmNlOiAnZGFwcCcsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gT25jZSB0aGUgbmV0d29yayBoYXMgYmVlbiBhZGRlZCwgdGhlIHJlcXVlc3RlZCBpcyBjb25zaWRlcmVkIHN1Y2Nlc3NmdWxcbiAgICByZXMucmVzdWx0ID0gbnVsbDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZW5kKGVycm9yKTtcbiAgfVxuXG4gIC8vIEFzayB0aGUgdXNlciB0byBzd2l0Y2ggdGhlIG5ldHdvcmtcbiAgdHJ5IHtcbiAgICBhd2FpdCB1cGRhdGVScGNUYXJnZXQoXG4gICAgICBhd2FpdCByZXF1ZXN0VXNlckFwcHJvdmFsKHtcbiAgICAgICAgb3JpZ2luLFxuICAgICAgICB0eXBlOiBNRVNTQUdFX1RZUEUuU1dJVENIX0VUSEVSRVVNX0NIQUlOLFxuICAgICAgICByZXF1ZXN0RGF0YToge1xuICAgICAgICAgIHJwY1VybDogZmlyc3RWYWxpZFJQQ1VybCxcbiAgICAgICAgICBjaGFpbklkOiBfY2hhaW5JZCxcbiAgICAgICAgICBuaWNrbmFtZTogX2NoYWluTmFtZSxcbiAgICAgICAgICB0aWNrZXIsXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIEZvciB0aGUgcHVycG9zZXMgb2YgdGhpcyBtZXRob2QsIGl0IGRvZXMgbm90IG1hdHRlciBpZiB0aGUgdXNlclxuICAgIC8vIGRlY2xpbmVzIHRvIHN3aXRjaCB0aGUgc2VsZWN0ZWQgbmV0d29yay4gSG93ZXZlciwgb3RoZXIgZXJyb3JzIGluZGljYXRlXG4gICAgLy8gdGhhdCBzb21ldGhpbmcgaXMgd3JvbmcuXG4gICAgaWYgKGVycm9yLmNvZGUgIT09IGVycm9yQ29kZXMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdCkge1xuICAgICAgcmV0dXJuIGVuZChlcnJvcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmQoKTtcbn1cbiIsImltcG9ydCB7IE1FU1NBR0VfVFlQRSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvYXBwJztcblxuLyoqXG4gKiBUaGlzIFJQQyBtZXRob2QgZ2V0cyBiYWNrZ3JvdW5kIHN0YXRlIHJlbGV2YW50IHRvIHRoZSBwcm92aWRlci5cbiAqIFRoZSBiYWNrZ3JvdW5kIHNlbmRzIFJQQyBub3RpZmljYXRpb25zIG9uIHN0YXRlIGNoYW5nZXMsIGJ1dCB0aGUgcHJvdmlkZXJcbiAqIGZpcnN0IHJlcXVlc3RzIHN0YXRlIG9uIGluaXRpYWxpemF0aW9uLlxuICovXG5cbmNvbnN0IGdldFByb3ZpZGVyU3RhdGUgPSB7XG4gIG1ldGhvZE5hbWVzOiBbTUVTU0FHRV9UWVBFLkdFVF9QUk9WSURFUl9TVEFURV0sXG4gIGltcGxlbWVudGF0aW9uOiBnZXRQcm92aWRlclN0YXRlSGFuZGxlcixcbiAgaG9va05hbWVzOiB7XG4gICAgZ2V0UHJvdmlkZXJTdGF0ZTogdHJ1ZSxcbiAgfSxcbn07XG5leHBvcnQgZGVmYXVsdCBnZXRQcm92aWRlclN0YXRlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3ZpZGVyU3RhdGVIYW5kbGVyUmVzdWx0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gY2hhaW5JZCAtIFRoZSBjdXJyZW50IGNoYWluIElELlxuICogQHByb3BlcnR5IHtib29sZWFufSBpc1VubG9ja2VkIC0gV2hldGhlciB0aGUgZXh0ZW5zaW9uIGlzIHVubG9ja2VkIG9yIG5vdC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuZXR3b3JrVmVyc2lvbiAtIFRoZSBjdXJyZW50IG5ldHdvcmsgSUQuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm92aWRlclN0YXRlSGFuZGxlck9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7KCkgPT4gUHJvdmlkZXJTdGF0ZUhhbmRsZXJSZXN1bHR9IGdldFByb3ZpZGVyU3RhdGUgLSBBIGZ1bmN0aW9uIHRoYXRcbiAqIGdldHMgdGhlIGN1cnJlbnQgcHJvdmlkZXIgc3RhdGUuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnanNvbi1ycGMtZW5naW5lJykuSnNvblJwY1JlcXVlc3Q8W10+fSByZXEgLSBUaGUgSlNPTi1SUEMgcmVxdWVzdCBvYmplY3QuXG4gKiBAcGFyYW0ge2ltcG9ydCgnanNvbi1ycGMtZW5naW5lJykuSnNvblJwY1Jlc3BvbnNlPFByb3ZpZGVyU3RhdGVIYW5kbGVyUmVzdWx0Pn0gcmVzIC0gVGhlIEpTT04tUlBDIHJlc3BvbnNlIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IF9uZXh0IC0gVGhlIGpzb24tcnBjLWVuZ2luZSAnbmV4dCcgY2FsbGJhY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmQgLSBUaGUganNvbi1ycGMtZW5naW5lICdlbmQnIGNhbGxiYWNrLlxuICogQHBhcmFtIHtQcm92aWRlclN0YXRlSGFuZGxlck9wdGlvbnN9IG9wdGlvbnNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UHJvdmlkZXJTdGF0ZUhhbmRsZXIoXG4gIHJlcSxcbiAgcmVzLFxuICBfbmV4dCxcbiAgZW5kLFxuICB7IGdldFByb3ZpZGVyU3RhdGU6IF9nZXRQcm92aWRlclN0YXRlIH0sXG4pIHtcbiAgcmVzLnJlc3VsdCA9IHtcbiAgICAuLi4oYXdhaXQgX2dldFByb3ZpZGVyU3RhdGUocmVxLm9yaWdpbikpLFxuICB9O1xuICByZXR1cm4gZW5kKCk7XG59XG4iLCJpbXBvcnQgeyBldGhFcnJvcnMgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XG5pbXBvcnQgeyBNRVNTQUdFX1RZUEUgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2FwcCc7XG5cbi8qKlxuICogVGhpcyBpbnRlcm5hbCBtZXRob2QgaXMgdXNlZCBieSBvdXIgZXh0ZXJuYWwgcHJvdmlkZXIgdG8gc2VuZCBtZXRhZGF0YSBhYm91dFxuICogcGVybWlzc2lvbiBzdWJqZWN0cyBzbyB0aGF0IHdlIGNhbiBlLmcuIGRpc3BsYXkgYSBwcm9wZXIgbmFtZSBhbmQgaWNvbiBpblxuICogb3VyIFVJLlxuICovXG5cbmNvbnN0IHNlbmRNZXRhZGF0YSA9IHtcbiAgbWV0aG9kTmFtZXM6IFtNRVNTQUdFX1RZUEUuU0VORF9NRVRBREFUQV0sXG4gIGltcGxlbWVudGF0aW9uOiBzZW5kTWV0YWRhdGFIYW5kbGVyLFxuICBob29rTmFtZXM6IHtcbiAgICBhZGRTdWJqZWN0TWV0YWRhdGE6IHRydWUsXG4gICAgc3ViamVjdFR5cGU6IHRydWUsXG4gIH0sXG59O1xuZXhwb3J0IGRlZmF1bHQgc2VuZE1ldGFkYXRhO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtSZWNvcmQ8c3RyaW5nLCBGdW5jdGlvbj59IFNlbmRNZXRhZGF0YU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGFkZFN1YmplY3RNZXRhZGF0YSAtIEEgZnVuY3Rpb24gdGhhdCByZWNvcmRzIHN1YmplY3RcbiAqIG1ldGFkYXRhLCBib3VuZCB0byB0aGUgcmVxdWVzdGluZyBvcmlnaW4uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3ViamVjdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgcmVxdWVzdGluZyBvcmlnaW4gLyBzdWJqZWN0LlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJ2pzb24tcnBjLWVuZ2luZScpLkpzb25ScGNSZXF1ZXN0PHVua25vd24+fSByZXEgLSBUaGUgSlNPTi1SUEMgcmVxdWVzdCBvYmplY3QuXG4gKiBAcGFyYW0ge2ltcG9ydCgnanNvbi1ycGMtZW5naW5lJykuSnNvblJwY1Jlc3BvbnNlPHRydWU+fSByZXMgLSBUaGUgSlNPTi1SUEMgcmVzcG9uc2Ugb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gX25leHQgLSBUaGUganNvbi1ycGMtZW5naW5lICduZXh0JyBjYWxsYmFjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuZCAtIFRoZSBqc29uLXJwYy1lbmdpbmUgJ2VuZCcgY2FsbGJhY2suXG4gKiBAcGFyYW0ge1NlbmRNZXRhZGF0YU9wdGlvbnN9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gc2VuZE1ldGFkYXRhSGFuZGxlcihcbiAgcmVxLFxuICByZXMsXG4gIF9uZXh0LFxuICBlbmQsXG4gIHsgYWRkU3ViamVjdE1ldGFkYXRhLCBzdWJqZWN0VHlwZSB9LFxuKSB7XG4gIGNvbnN0IHsgb3JpZ2luLCBwYXJhbXMgfSA9IHJlcTtcbiAgaWYgKHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgY29uc3QgeyBpY29uID0gbnVsbCwgbmFtZSA9IG51bGwsIC4uLnJlbWFpbmluZ1BhcmFtcyB9ID0gcGFyYW1zO1xuXG4gICAgYWRkU3ViamVjdE1ldGFkYXRhKHtcbiAgICAgIC4uLnJlbWFpbmluZ1BhcmFtcyxcbiAgICAgIGljb25Vcmw6IGljb24sXG4gICAgICBuYW1lLFxuICAgICAgc3ViamVjdFR5cGUsXG4gICAgICBvcmlnaW4sXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVuZChldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoeyBkYXRhOiBwYXJhbXMgfSkpO1xuICB9XG5cbiAgcmVzLnJlc3VsdCA9IHRydWU7XG4gIHJldHVybiBlbmQoKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZWxlY3RIb29rcyA9IGV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IHZvaWQgMDtcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5leHBvcnRzLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuZnVuY3Rpb24gc2VsZWN0SG9va3MoaG9va3MsIGhvb2tOYW1lcykge1xuICAgIGlmIChob29rTmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGhvb2tOYW1lcykucmVkdWNlKChob29rU3Vic2V0LCBfaG9va05hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhvb2tOYW1lID0gX2hvb2tOYW1lO1xuICAgICAgICAgICAgaG9va1N1YnNldFtob29rTmFtZV0gPSBob29rc1tob29rTmFtZV07XG4gICAgICAgICAgICByZXR1cm4gaG9va1N1YnNldDtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5zZWxlY3RIb29rcyA9IHNlbGVjdEhvb2tzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ1aWxkZXJzID0gZXhwb3J0cy5NYW5hZ2VTdGF0ZU9wZXJhdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGNvbmZpcm1fMSA9IHJlcXVpcmUoXCIuL2NvbmZpcm1cIik7XG5jb25zdCBnZXRCaXA0NEVudHJvcHlfMSA9IHJlcXVpcmUoXCIuL2dldEJpcDQ0RW50cm9weVwiKTtcbmNvbnN0IGludm9rZVNuYXBfMSA9IHJlcXVpcmUoXCIuL2ludm9rZVNuYXBcIik7XG5jb25zdCBtYW5hZ2VTdGF0ZV8xID0gcmVxdWlyZShcIi4vbWFuYWdlU3RhdGVcIik7XG52YXIgbWFuYWdlU3RhdGVfMiA9IHJlcXVpcmUoXCIuL21hbmFnZVN0YXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWFuYWdlU3RhdGVPcGVyYXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hbmFnZVN0YXRlXzIuTWFuYWdlU3RhdGVPcGVyYXRpb247IH0gfSk7XG5leHBvcnRzLmJ1aWxkZXJzID0ge1xuICAgIFtjb25maXJtXzEuY29uZmlybUJ1aWxkZXIudGFyZ2V0S2V5XTogY29uZmlybV8xLmNvbmZpcm1CdWlsZGVyLFxuICAgIFtnZXRCaXA0NEVudHJvcHlfMS5nZXRCaXA0NEVudHJvcHlCdWlsZGVyLnRhcmdldEtleV06IGdldEJpcDQ0RW50cm9weV8xLmdldEJpcDQ0RW50cm9weUJ1aWxkZXIsXG4gICAgW2ludm9rZVNuYXBfMS5pbnZva2VTbmFwQnVpbGRlci50YXJnZXRLZXldOiBpbnZva2VTbmFwXzEuaW52b2tlU25hcEJ1aWxkZXIsXG4gICAgW21hbmFnZVN0YXRlXzEubWFuYWdlU3RhdGVCdWlsZGVyLnRhcmdldEtleV06IG1hbmFnZVN0YXRlXzEubWFuYWdlU3RhdGVCdWlsZGVyLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYW5kbGVycyA9IHZvaWQgMDtcbmNvbnN0IGVuYWJsZV8xID0gcmVxdWlyZShcIi4vZW5hYmxlXCIpO1xuY29uc3QgZ2V0QXBwS2V5XzEgPSByZXF1aXJlKFwiLi9nZXRBcHBLZXlcIik7XG5jb25zdCBnZXRTbmFwc18xID0gcmVxdWlyZShcIi4vZ2V0U25hcHNcIik7XG5jb25zdCBpbnN0YWxsU25hcHNfMSA9IHJlcXVpcmUoXCIuL2luc3RhbGxTbmFwc1wiKTtcbmNvbnN0IGludm9rZVNuYXBTdWdhcl8xID0gcmVxdWlyZShcIi4vaW52b2tlU25hcFN1Z2FyXCIpO1xuZXhwb3J0cy5oYW5kbGVycyA9IFtcbiAgICBlbmFibGVfMS5lbmFibGVXYWxsZXRIYW5kbGVyLFxuICAgIGdldEFwcEtleV8xLmdldEFwcEtleUhhbmRsZXIsXG4gICAgZ2V0U25hcHNfMS5nZXRTbmFwc0hhbmRsZXIsXG4gICAgaW5zdGFsbFNuYXBzXzEuaW5zdGFsbFNuYXBzSGFuZGxlcixcbiAgICBpbnZva2VTbmFwU3VnYXJfMS5pbnZva2VTbmFwU3VnYXJIYW5kbGVyLFxuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xudmFyIGtleUxpc3QgPSBPYmplY3Qua2V5cztcbnZhciBoYXNQcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgdmFyIGFyckEgPSBpc0FycmF5KGEpXG4gICAgICAsIGFyckIgPSBpc0FycmF5KGIpXG4gICAgICAsIGlcbiAgICAgICwgbGVuZ3RoXG4gICAgICAsIGtleTtcblxuICAgIGlmIChhcnJBICYmIGFyckIpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoYXJyQSAhPSBhcnJCKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgZGF0ZUEgPSBhIGluc3RhbmNlb2YgRGF0ZVxuICAgICAgLCBkYXRlQiA9IGIgaW5zdGFuY2VvZiBEYXRlO1xuICAgIGlmIChkYXRlQSAhPSBkYXRlQikgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkYXRlQSAmJiBkYXRlQikgcmV0dXJuIGEuZ2V0VGltZSgpID09IGIuZ2V0VGltZSgpO1xuXG4gICAgdmFyIHJlZ2V4cEEgPSBhIGluc3RhbmNlb2YgUmVnRXhwXG4gICAgICAsIHJlZ2V4cEIgPSBiIGluc3RhbmNlb2YgUmVnRXhwO1xuICAgIGlmIChyZWdleHBBICE9IHJlZ2V4cEIpIHJldHVybiBmYWxzZTtcbiAgICBpZiAocmVnZXhwQSAmJiByZWdleHBCKSByZXR1cm4gYS50b1N0cmluZygpID09IGIudG9TdHJpbmcoKTtcblxuICAgIHZhciBrZXlzID0ga2V5TGlzdChhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcblxuICAgIGlmIChsZW5ndGggIT09IGtleUxpc3QoYikubGVuZ3RoKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFoYXNQcm9wLmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBVaW50OEFycmF5IGNyZWF0ZWQgYnkgY29uY2F0ZW5hdGluZyB0aGUgcGFzc2VkIEFycmF5TGlrZXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5TGlrZTxudW1iZXI+Pn0gYXJyYXlzXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF1cbiAqL1xuZnVuY3Rpb24gY29uY2F0IChhcnJheXMsIGxlbmd0aCkge1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IGFycmF5cy5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgY3Vyci5sZW5ndGgsIDApXG4gIH1cblxuICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGxldCBvZmZzZXQgPSAwXG5cbiAgZm9yIChjb25zdCBhcnIgb2YgYXJyYXlzKSB7XG4gICAgb3V0cHV0LnNldChhcnIsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gYXJyLmxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmNhdFxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gcGFzc2VkIFVpbnQ4QXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudFxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBiXG4gKi9cbmZ1bmN0aW9uIGVxdWFscyAoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbHNcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBtaCA9IHJlcXVpcmUoJ211bHRpaGFzaGVzJylcblxuY29uc3QgQ0lEVXRpbCA9IHtcbiAgLyoqXG4gICAqIFRlc3QgaWYgdGhlIGdpdmVuIGlucHV0IGlzIGEgdmFsaWQgQ0lEIG9iamVjdC5cbiAgICogUmV0dXJucyBhbiBlcnJvciBtZXNzYWdlIGlmIGl0IGlzIG5vdC5cbiAgICogUmV0dXJucyB1bmRlZmluZWQgaWYgaXQgaXMgYSB2YWxpZCBDSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBvdGhlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICovXG4gIGNoZWNrQ0lEQ29tcG9uZW50czogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgaWYgKG90aGVyID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnbnVsbCB2YWx1ZXMgYXJlIG5vdCB2YWxpZCBDSURzJ1xuICAgIH1cblxuICAgIGlmICghKG90aGVyLnZlcnNpb24gPT09IDAgfHwgb3RoZXIudmVyc2lvbiA9PT0gMSkpIHtcbiAgICAgIHJldHVybiAnSW52YWxpZCB2ZXJzaW9uLCBtdXN0IGJlIGEgbnVtYmVyIGVxdWFsIHRvIDEgb3IgMCdcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG90aGVyLmNvZGVjICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuICdjb2RlYyBtdXN0IGJlIHN0cmluZydcbiAgICB9XG5cbiAgICBpZiAob3RoZXIudmVyc2lvbiA9PT0gMCkge1xuICAgICAgaWYgKG90aGVyLmNvZGVjICE9PSAnZGFnLXBiJykge1xuICAgICAgICByZXR1cm4gXCJjb2RlYyBtdXN0IGJlICdkYWctcGInIGZvciBDSUR2MFwiXG4gICAgICB9XG4gICAgICBpZiAob3RoZXIubXVsdGliYXNlTmFtZSAhPT0gJ2Jhc2U1OGJ0YycpIHtcbiAgICAgICAgcmV0dXJuIFwibXVsdGliYXNlTmFtZSBtdXN0IGJlICdiYXNlNThidGMnIGZvciBDSUR2MFwiXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEob3RoZXIubXVsdGloYXNoIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgIHJldHVybiAnbXVsdGloYXNoIG11c3QgYmUgYSBVaW50OEFycmF5J1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBtaC52YWxpZGF0ZShvdGhlci5tdWx0aWhhc2gpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsZXQgZXJyb3JNc2cgPSBlcnIubWVzc2FnZVxuICAgICAgaWYgKCFlcnJvck1zZykgeyAvLyBKdXN0IGluIGNhc2UgbWgudmFsaWRhdGUoKSB0aHJvd3MgYW4gZXJyb3Igd2l0aCBlbXB0eSBlcnJvciBtZXNzYWdlXG4gICAgICAgIGVycm9yTXNnID0gJ011bHRpaGFzaCB2YWxpZGF0aW9uIGZhaWxlZCdcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnJvck1zZ1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENJRFV0aWxcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGVuY29kaW5nOiBnZXRDb2RlYyB9ID0gcmVxdWlyZSgnbXVsdGliYXNlJylcbmNvbnN0IHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGY4JylcblxuLyoqXG4gKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnbXVsdGliYXNlL3NyYy90eXBlcycpLkJhc2VOYW1lIHwgJ3V0ZjgnIHwgJ3V0Zi04JyB8ICdhc2NpaScgfCB1bmRlZmluZWR9IFN1cHBvcnRlZEVuY29kaW5nc1xuICovXG5cbi8qKlxuICogVHVybnMgYSBVaW50OEFycmF5IG9mIGJ5dGVzIGludG8gYSBzdHJpbmcgd2l0aCBlYWNoXG4gKiBjaGFyYWN0ZXIgYmVpbmcgdGhlIGNoYXIgY29kZSBvZiB0aGUgY29ycmVzcG9uZGluZyBieXRlXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byB0dXJuIGludG8gYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gdWludDhBcnJheVRvQXNjaWlTdHJpbmcgKGFycmF5KSB7XG4gIGxldCBzdHJpbmcgPSAnJ1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSlcbiAgfVxuICByZXR1cm4gc3RyaW5nXG59XG5cbi8qKlxuICogVHVybnMgYSBgVWludDhBcnJheWAgaW50byBhIHN0cmluZy5cbiAqXG4gKiBTdXBwb3J0cyBgdXRmOGAsIGB1dGYtOGAgYW5kIGFueSBlbmNvZGluZyBzdXBwb3J0ZWQgYnkgdGhlIG11bHRpYmFzZSBtb2R1bGUuXG4gKlxuICogQWxzbyBgYXNjaWlgIHdoaWNoIGlzIHNpbWlsYXIgdG8gbm9kZSdzICdiaW5hcnknIGVuY29kaW5nLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gdHVybiBpbnRvIGEgc3RyaW5nXG4gKiBAcGFyYW0ge1N1cHBvcnRlZEVuY29kaW5nc30gW2VuY29kaW5nPXV0ZjhdIC0gVGhlIGVuY29kaW5nIHRvIHVzZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKGFycmF5LCBlbmNvZGluZyA9ICd1dGY4Jykge1xuICBpZiAoZW5jb2RpbmcgPT09ICd1dGY4JyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi04Jykge1xuICAgIHJldHVybiB1dGY4RGVjb2Rlci5kZWNvZGUoYXJyYXkpXG4gIH1cblxuICBpZiAoZW5jb2RpbmcgPT09ICdhc2NpaScpIHtcbiAgICByZXR1cm4gdWludDhBcnJheVRvQXNjaWlTdHJpbmcoYXJyYXkpXG4gIH1cblxuICByZXR1cm4gZ2V0Q29kZWMoZW5jb2RpbmcpLmVuY29kZShhcnJheSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZ1xuIiwiLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgbXVsdGljb2RlYyBzcGVjaWZpY2F0aW9uLlxuICpcbiAqIEBtb2R1bGUgbXVsdGljb2RlY1xuICogQGV4YW1wbGVcbiAqIGNvbnN0IG11bHRpY29kZWMgPSByZXF1aXJlKCdtdWx0aWNvZGVjJylcbiAqXG4gKiBjb25zdCBwcmVmaXhlZFByb3RvYnVmID0gbXVsdGljb2RlYy5hZGRQcmVmaXgoJ3Byb3RvYnVmJywgcHJvdG9idWZCdWZmZXIpXG4gKiAvLyBwcmVmaXhlZFByb3RvYnVmIDB4NTAuLi5cbiAqXG4gKi9cbid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuQ29kZWNOYW1lfSBDb2RlY05hbWUgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5Db2RlY0NvZGV9IENvZGVjQ29kZSAqL1xuXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuY29uc3QgdWludDhBcnJheUNvbmNhdCA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL2NvbmNhdCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgbmFtZVRvVmFyaW50LCBjb25zdGFudFRvQ29kZSwgbmFtZVRvQ29kZSwgY29kZVRvTmFtZSB9ID0gcmVxdWlyZSgnLi9tYXBzJylcblxuLyoqXG4gKiBQcmVmaXggYSBidWZmZXIgd2l0aCBhIG11bHRpY29kZWMtcGFja2VkLlxuICpcbiAqIEBwYXJhbSB7Q29kZWNOYW1lfFVpbnQ4QXJyYXl9IG11bHRpY29kZWNTdHJPckNvZGVcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGFkZFByZWZpeCAobXVsdGljb2RlY1N0ck9yQ29kZSwgZGF0YSkge1xuICBsZXQgcHJlZml4XG5cbiAgaWYgKG11bHRpY29kZWNTdHJPckNvZGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcHJlZml4ID0gdXRpbC52YXJpbnRVaW50OEFycmF5RW5jb2RlKG11bHRpY29kZWNTdHJPckNvZGUpXG4gIH0gZWxzZSB7XG4gICAgaWYgKG5hbWVUb1ZhcmludFttdWx0aWNvZGVjU3RyT3JDb2RlXSkge1xuICAgICAgcHJlZml4ID0gbmFtZVRvVmFyaW50W211bHRpY29kZWNTdHJPckNvZGVdXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbXVsdGljb2RlYyBub3QgcmVjb2duaXplZCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVpbnQ4QXJyYXlDb25jYXQoW3ByZWZpeCwgZGF0YV0sIHByZWZpeC5sZW5ndGggKyBkYXRhLmxlbmd0aClcbn1cblxuLyoqXG4gKiBEZWNhcHN1bGF0ZSB0aGUgbXVsdGljb2RlYy1wYWNrZWQgcHJlZml4IGZyb20gdGhlIGRhdGEuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gcm1QcmVmaXggKGRhdGEpIHtcbiAgdmFyaW50LmRlY29kZSgvKiogQHR5cGUge0J1ZmZlcn0gKi8oZGF0YSkpXG4gIHJldHVybiBkYXRhLnNsaWNlKHZhcmludC5kZWNvZGUuYnl0ZXMpXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlYyBuYW1lIG9mIHRoZSBwcmVmaXhlZCBkYXRhLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gcHJlZml4ZWREYXRhXG4gKiBAcmV0dXJucyB7Q29kZWNOYW1lfVxuICovXG5mdW5jdGlvbiBnZXROYW1lRnJvbURhdGEgKHByZWZpeGVkRGF0YSkge1xuICBjb25zdCBjb2RlID0gLyoqIEB0eXBlIHtDb2RlY0NvZGV9ICovKHZhcmludC5kZWNvZGUoLyoqIEB0eXBlIHtCdWZmZXJ9ICovKHByZWZpeGVkRGF0YSkpKVxuICBjb25zdCBuYW1lID0gY29kZVRvTmFtZVtjb2RlXVxuICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlIFwiJHtjb2RlfVwiIG5vdCBmb3VuZGApXG4gIH1cbiAgcmV0dXJuIG5hbWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGVjIG5hbWUgZnJvbSBhIGNvZGUuXG4gKlxuICogQHBhcmFtIHtDb2RlY0NvZGV9IGNvZGVjXG4gKiBAcmV0dXJucyB7Q29kZWNOYW1lfVxuICovXG5mdW5jdGlvbiBnZXROYW1lRnJvbUNvZGUgKGNvZGVjKSB7XG4gIHJldHVybiBjb2RlVG9OYW1lW2NvZGVjXVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29kZSBvZiB0aGUgY29kZWNcbiAqXG4gKiBAcGFyYW0ge0NvZGVjTmFtZX0gbmFtZVxuICogQHJldHVybnMge0NvZGVjQ29kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29kZUZyb21OYW1lIChuYW1lKSB7XG4gIGNvbnN0IGNvZGUgPSBuYW1lVG9Db2RlW25hbWVdXG4gIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVjIFwiJHtuYW1lfVwiIG5vdCBmb3VuZGApXG4gIH1cbiAgcmV0dXJuIGNvZGVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGUgb2YgdGhlIHByZWZpeGVkIGRhdGEuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBwcmVmaXhlZERhdGFcbiAqIEByZXR1cm5zIHtDb2RlY0NvZGV9XG4gKi9cbmZ1bmN0aW9uIGdldENvZGVGcm9tRGF0YSAocHJlZml4ZWREYXRhKSB7XG4gIHJldHVybiAvKiogQHR5cGUge0NvZGVjQ29kZX0gKi8odmFyaW50LmRlY29kZSgvKiogQHR5cGUge0J1ZmZlcn0gKi8ocHJlZml4ZWREYXRhKSkpXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlIGFzIHZhcmludCBvZiBhIGNvZGVjIG5hbWUuXG4gKlxuICogQHBhcmFtIHtDb2RlY05hbWV9IG5hbWVcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBnZXRWYXJpbnRGcm9tTmFtZSAobmFtZSkge1xuICBjb25zdCBjb2RlID0gbmFtZVRvVmFyaW50W25hbWVdXG4gIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVjIFwiJHtuYW1lfVwiIG5vdCBmb3VuZGApXG4gIH1cbiAgcmV0dXJuIGNvZGVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhcmludCBvZiBhIGNvZGUuXG4gKlxuICogQHBhcmFtIHtDb2RlY0NvZGV9IGNvZGVcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBnZXRWYXJpbnRGcm9tQ29kZSAoY29kZSkge1xuICByZXR1cm4gdXRpbC52YXJpbnRFbmNvZGUoY29kZSlcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGVjIG5hbWUgb2YgdGhlIHByZWZpeGVkIGRhdGEuXG4gKlxuICogQGRlcHJlY2F0ZWQgdXNlIGdldE5hbWVGcm9tRGF0YSBpbnN0ZWFkLlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBwcmVmaXhlZERhdGFcbiAqIEByZXR1cm5zIHtDb2RlY05hbWV9XG4gKi9cbmZ1bmN0aW9uIGdldENvZGVjIChwcmVmaXhlZERhdGEpIHtcbiAgcmV0dXJuIGdldE5hbWVGcm9tRGF0YShwcmVmaXhlZERhdGEpXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlYyBuYW1lIGZyb20gYSBjb2RlLlxuICpcbiAqIEBkZXByZWNhdGVkIHVzZSBnZXROYW1lRnJvbUNvZGUgaW5zdGVhZC5cbiAqIEBwYXJhbSB7Q29kZWNDb2RlfSBjb2RlY1xuICogQHJldHVybnMge0NvZGVjTmFtZX1cbiAqL1xuZnVuY3Rpb24gZ2V0TmFtZSAoY29kZWMpIHtcbiAgcmV0dXJuIGdldE5hbWVGcm9tQ29kZShjb2RlYylcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGUgb2YgdGhlIGNvZGVjXG4gKlxuICogQGRlcHJlY2F0ZWQgdXNlIGdldENvZGVGcm9tTmFtZSBpbnN0ZWFkLlxuICogQHBhcmFtIHtDb2RlY05hbWV9IG5hbWVcbiAqIEByZXR1cm5zIHtDb2RlY0NvZGV9XG4gKi9cbmZ1bmN0aW9uIGdldE51bWJlciAobmFtZSkge1xuICByZXR1cm4gZ2V0Q29kZUZyb21OYW1lKG5hbWUpXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlIG9mIHRoZSBwcmVmaXhlZCBkYXRhLlxuICpcbiAqIEBkZXByZWNhdGVkIHVzZSBnZXRDb2RlRnJvbURhdGEgaW5zdGVhZC5cbiAqIEBwYXJhbSB7VWludDhBcnJheX0gcHJlZml4ZWREYXRhXG4gKiBAcmV0dXJucyB7Q29kZWNDb2RlfVxuICovXG5mdW5jdGlvbiBnZXRDb2RlIChwcmVmaXhlZERhdGEpIHtcbiAgcmV0dXJuIGdldENvZGVGcm9tRGF0YShwcmVmaXhlZERhdGEpXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlIGFzIHZhcmludCBvZiBhIGNvZGVjIG5hbWUuXG4gKlxuICogQGRlcHJlY2F0ZWQgdXNlIGdldFZhcmludEZyb21OYW1lIGluc3RlYWQuXG4gKiBAcGFyYW0ge0NvZGVjTmFtZX0gbmFtZVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGdldENvZGVWYXJpbnQgKG5hbWUpIHtcbiAgcmV0dXJuIGdldFZhcmludEZyb21OYW1lKG5hbWUpXG59XG5cbi8qKlxuICogR2V0IHRoZSB2YXJpbnQgb2YgYSBjb2RlLlxuICpcbiAqIEBkZXByZWNhdGVkIHVzZSBnZXRWYXJpbnRGcm9tQ29kZSBpbnN0ZWFkLlxuICogQHBhcmFtIHtDb2RlY0NvZGV9IGNvZGVcbiAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn1cbiAqL1xuZnVuY3Rpb24gZ2V0VmFyaW50IChjb2RlKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGdldFZhcmludEZyb21Db2RlKGNvZGUpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRkUHJlZml4LFxuICBybVByZWZpeCxcbiAgZ2V0TmFtZUZyb21EYXRhLFxuICBnZXROYW1lRnJvbUNvZGUsXG4gIGdldENvZGVGcm9tTmFtZSxcbiAgZ2V0Q29kZUZyb21EYXRhLFxuICBnZXRWYXJpbnRGcm9tTmFtZSxcbiAgZ2V0VmFyaW50RnJvbUNvZGUsXG4gIC8vIERlcHJlY2F0ZWRcbiAgZ2V0Q29kZWMsXG4gIGdldE5hbWUsXG4gIGdldE51bWJlcixcbiAgZ2V0Q29kZSxcbiAgZ2V0Q29kZVZhcmludCxcbiAgZ2V0VmFyaW50LFxuICAvLyBNYWtlIHRoZSBjb25zdGFudHMgdG9wLWxldmVsIGNvbnN0YW50c1xuICAuLi5jb25zdGFudFRvQ29kZSxcbiAgLy8gRXhwb3J0IHRoZSBtYXBzXG4gIG5hbWVUb1ZhcmludCxcbiAgbmFtZVRvQ29kZSxcbiAgY29kZVRvTmFtZVxufVxuIiwiLyoqXG4gKiBNdWx0aWhhc2ggaW1wbGVtZW50YXRpb24gaW4gSmF2YVNjcmlwdC5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG11bHRpYmFzZSA9IHJlcXVpcmUoJ211bHRpYmFzZScpXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuY29uc3QgeyBuYW1lcyB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgdWludDhBcnJheVRvU3RyaW5nID0gcmVxdWlyZSgndWludDhhcnJheXMvdG8tc3RyaW5nJylcbmNvbnN0IHVpbnQ4QXJyYXlGcm9tU3RyaW5nID0gcmVxdWlyZSgndWludDhhcnJheXMvZnJvbS1zdHJpbmcnKVxuY29uc3QgdWludDhBcnJheUNvbmNhdCA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL2NvbmNhdCcpXG5cbmNvbnN0IGNvZGVzID0gLyoqIEB0eXBlIHtfX2ltcG9ydF9fKCcuL3R5cGVzJykuQ29kZU5hbWVNYXB9ICovKHt9KVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXG5mb3IgKGNvbnN0IGtleSBpbiBuYW1lcykge1xuICBjb25zdCBuYW1lID0gLyoqIEB0eXBlIHtIYXNoTmFtZX0gKi8oa2V5KVxuICBjb2Rlc1tuYW1lc1tuYW1lXV0gPSBuYW1lXG59XG5PYmplY3QuZnJlZXplKGNvZGVzKVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIG11bHRpaGFzaCB0byBhIGhleCBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGhhc2hcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRvSGV4U3RyaW5nIChoYXNoKSB7XG4gIGlmICghKGhhc2ggaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBiZSBwYXNzZWQgYSBVaW50OEFycmF5JylcbiAgfVxuXG4gIHJldHVybiB1aW50OEFycmF5VG9TdHJpbmcoaGFzaCwgJ2Jhc2UxNicpXG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gaGV4IGVuY29kZWQgc3RyaW5nIHRvIGEgbXVsdGloYXNoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gZnJvbUhleFN0cmluZyAoaGFzaCkge1xuICByZXR1cm4gdWludDhBcnJheUZyb21TdHJpbmcoaGFzaCwgJ2Jhc2UxNicpXG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gbXVsdGloYXNoIHRvIGEgYmFzZTU4IGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gaGFzaFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdG9CNThTdHJpbmcgKGhhc2gpIHtcbiAgaWYgKCEoaGFzaCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IGJlIHBhc3NlZCBhIFVpbnQ4QXJyYXknKVxuICB9XG5cbiAgcmV0dXJuIHVpbnQ4QXJyYXlUb1N0cmluZyhtdWx0aWJhc2UuZW5jb2RlKCdiYXNlNThidGMnLCBoYXNoKSkuc2xpY2UoMSlcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBiYXNlNTggZW5jb2RlZCBzdHJpbmcgdG8gYSBtdWx0aWhhc2guXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8VWludDhBcnJheX0gaGFzaFxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGZyb21CNThTdHJpbmcgKGhhc2gpIHtcbiAgY29uc3QgZW5jb2RlZCA9IGhhc2ggaW5zdGFuY2VvZiBVaW50OEFycmF5XG4gICAgPyB1aW50OEFycmF5VG9TdHJpbmcoaGFzaClcbiAgICA6IGhhc2hcblxuICByZXR1cm4gbXVsdGliYXNlLmRlY29kZSgneicgKyBlbmNvZGVkKVxufVxuXG4vKipcbiAqIERlY29kZSBhIGhhc2ggZnJvbSB0aGUgZ2l2ZW4gbXVsdGloYXNoLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAqIEByZXR1cm5zIHt7Y29kZTogSGFzaENvZGUsIG5hbWU6IEhhc2hOYW1lLCBsZW5ndGg6IG51bWJlciwgZGlnZXN0OiBVaW50OEFycmF5fX0gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGRlY29kZSAoYnl0ZXMpIHtcbiAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVsdGloYXNoIG11c3QgYmUgYSBVaW50OEFycmF5JylcbiAgfVxuXG4gIGlmIChieXRlcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWhhc2ggdG9vIHNob3J0LiBtdXN0IGJlID4gMiBieXRlcy4nKVxuICB9XG5cbiAgY29uc3QgY29kZSA9IC8qKiBAdHlwZSB7SGFzaENvZGV9ICovKHZhcmludC5kZWNvZGUoYnl0ZXMpKVxuICBpZiAoIWlzVmFsaWRDb2RlKGNvZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtdWx0aWhhc2ggdW5rbm93biBmdW5jdGlvbiBjb2RlOiAweCR7Y29kZS50b1N0cmluZygxNil9YClcbiAgfVxuICBieXRlcyA9IGJ5dGVzLnNsaWNlKHZhcmludC5kZWNvZGUuYnl0ZXMpXG5cbiAgY29uc3QgbGVuID0gdmFyaW50LmRlY29kZShieXRlcylcbiAgaWYgKGxlbiA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG11bHRpaGFzaCBpbnZhbGlkIGxlbmd0aDogJHtsZW59YClcbiAgfVxuICBieXRlcyA9IGJ5dGVzLnNsaWNlKHZhcmludC5kZWNvZGUuYnl0ZXMpXG5cbiAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gbGVuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtdWx0aWhhc2ggbGVuZ3RoIGluY29uc2lzdGVudDogMHgke3VpbnQ4QXJyYXlUb1N0cmluZyhieXRlcywgJ2Jhc2UxNicpfWApXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvZGUsXG4gICAgbmFtZTogY29kZXNbY29kZV0sXG4gICAgbGVuZ3RoOiBsZW4sXG4gICAgZGlnZXN0OiBieXRlc1xuICB9XG59XG5cbi8qKlxuICogRW5jb2RlIGEgaGFzaCBkaWdlc3QgYWxvbmcgd2l0aCB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIGNvZGUuXG4gKlxuICogPiAqKk5vdGU6KiogdGhlIGxlbmd0aCBpcyBkZXJpdmVkIGZyb20gdGhlIGxlbmd0aCBvZiB0aGUgZGlnZXN0IGl0c2VsZi5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRpZ2VzdFxuICogQHBhcmFtIHtIYXNoTmFtZSB8IEhhc2hDb2RlfSBjb2RlXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF1cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBlbmNvZGUgKGRpZ2VzdCwgY29kZSwgbGVuZ3RoKSB7XG4gIGlmICghZGlnZXN0IHx8IGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVsdGloYXNoIGVuY29kZSByZXF1aXJlcyBhdCBsZWFzdCB0d28gYXJnczogZGlnZXN0LCBjb2RlJylcbiAgfVxuXG4gIC8vIGVuc3VyZSBpdCdzIGEgaGFzaGZ1bmN0aW9uIGNvZGUuXG4gIGNvbnN0IGhhc2hmbiA9IGNvZXJjZUNvZGUoY29kZSlcblxuICBpZiAoIShkaWdlc3QgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0IHNob3VsZCBiZSBhIFVpbnQ4QXJyYXknKVxuICB9XG5cbiAgaWYgKGxlbmd0aCA9PSBudWxsKSB7XG4gICAgbGVuZ3RoID0gZGlnZXN0Lmxlbmd0aFxuICB9XG5cbiAgaWYgKGxlbmd0aCAmJiBkaWdlc3QubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCBsZW5ndGggc2hvdWxkIGJlIGVxdWFsIHRvIHNwZWNpZmllZCBsZW5ndGguJylcbiAgfVxuXG4gIGNvbnN0IGhhc2ggPSB2YXJpbnQuZW5jb2RlKGhhc2hmbilcbiAgY29uc3QgbGVuID0gdmFyaW50LmVuY29kZShsZW5ndGgpXG4gIHJldHVybiB1aW50OEFycmF5Q29uY2F0KFtoYXNoLCBsZW4sIGRpZ2VzdF0sIGhhc2gubGVuZ3RoICsgbGVuLmxlbmd0aCArIGRpZ2VzdC5sZW5ndGgpXG59XG5cbi8qKlxuICogQ29udmVydHMgYSBoYXNoIGZ1bmN0aW9uIG5hbWUgaW50byB0aGUgbWF0Y2hpbmcgY29kZS5cbiAqIElmIHBhc3NlZCBhIG51bWJlciBpdCB3aWxsIHJldHVybiB0aGUgbnVtYmVyIGlmIGl0J3MgYSB2YWxpZCBjb2RlLlxuICpcbiAqIEBwYXJhbSB7SGFzaE5hbWUgfCBudW1iZXJ9IG5hbWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNvZXJjZUNvZGUgKG5hbWUpIHtcbiAgbGV0IGNvZGUgPSBuYW1lXG5cbiAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgIGlmIChuYW1lc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBoYXNoIGZ1bmN0aW9uIG5hbWVkOiAke25hbWV9YClcbiAgICB9XG4gICAgY29kZSA9IG5hbWVzW25hbWVdXG4gIH1cblxuICBpZiAodHlwZW9mIGNvZGUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBIYXNoIGZ1bmN0aW9uIGNvZGUgc2hvdWxkIGJlIGEgbnVtYmVyLiBHb3Q6ICR7Y29kZX1gKVxuICB9XG5cbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAoY29kZXNbY29kZV0gPT09IHVuZGVmaW5lZCAmJiAhaXNBcHBDb2RlKGNvZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgZnVuY3Rpb24gY29kZTogJHtjb2RlfWApXG4gIH1cblxuICByZXR1cm4gY29kZVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGNvZGUgaXMgcGFydCBvZiB0aGUgYXBwIHJhbmdlXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0FwcENvZGUgKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPiAwICYmIGNvZGUgPCAweDEwXG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBtdWx0aWhhc2ggY29kZSBpcyB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge0hhc2hDb2RlfSBjb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZENvZGUgKGNvZGUpIHtcbiAgaWYgKGlzQXBwQ29kZShjb2RlKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoY29kZXNbY29kZV0pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGJ1ZmZlciBpcyBhIHZhbGlkIG11bHRpaGFzaC4gVGhyb3dzIGFuIGVycm9yIGlmIGl0IGlzIG5vdCB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG11bHRpaGFzaFxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGUgKG11bHRpaGFzaCkge1xuICBkZWNvZGUobXVsdGloYXNoKSAvLyB0aHJvd3MgaWYgYmFkLlxufVxuXG4vKipcbiAqIFJldHVybnMgYSBwcmVmaXggZnJvbSBhIHZhbGlkIG11bHRpaGFzaC4gVGhyb3dzIGFuIGVycm9yIGlmIGl0IGlzIG5vdCB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG11bHRpaGFzaFxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqL1xuZnVuY3Rpb24gcHJlZml4IChtdWx0aWhhc2gpIHtcbiAgdmFsaWRhdGUobXVsdGloYXNoKVxuXG4gIHJldHVybiBtdWx0aWhhc2guc3ViYXJyYXkoMCwgMilcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWVzLFxuICBjb2RlcyxcbiAgdG9IZXhTdHJpbmcsXG4gIGZyb21IZXhTdHJpbmcsXG4gIHRvQjU4U3RyaW5nLFxuICBmcm9tQjU4U3RyaW5nLFxuICBkZWNvZGUsXG4gIGVuY29kZSxcbiAgY29lcmNlQ29kZSxcbiAgaXNBcHBDb2RlLFxuICB2YWxpZGF0ZSxcbiAgcHJlZml4LFxuICBpc1ZhbGlkQ29kZVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHsgX19pbXBvcnRfXyhcIi4vY29uc3RhbnRzXCIpLkhhc2hDb2RlIH0gSGFzaENvZGVcbiAqIEB0eXBlZGVmIHsgX19pbXBvcnRfXyhcIi4vY29uc3RhbnRzXCIpLkhhc2hOYW1lIH0gSGFzaE5hbWVcbiAqL1xuIiwiLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgW211bHRpYmFzZV0oaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9tdWx0aWJhc2UpIHNwZWNpZmljYXRpb24uXG4gKlxuICovXG4ndXNlIHN0cmljdCdcblxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBlbmNvZGVUZXh0LCBkZWNvZGVUZXh0LCBjb25jYXQgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9iYXNlJyl9IEJhc2UgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXyhcIi4vdHlwZXNcIikuQmFzZU5hbWVPckNvZGV9IEJhc2VOYW1lT3JDb2RlICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oXCIuL3R5cGVzXCIpLkJhc2VDb2RlfSBCYXNlQ29kZSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKFwiLi90eXBlc1wiKS5CYXNlTmFtZX0gQmFzZU5hbWUgKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgVWludDhBcnJheSB3aXRoIHRoZSBtdWx0aWJhc2UgdmFyaW50K2NvZGUuXG4gKlxuICogQHBhcmFtIHtCYXNlTmFtZU9yQ29kZX0gbmFtZU9yQ29kZSAtIFRoZSBtdWx0aWJhc2UgbmFtZSBvciBjb2RlIG51bWJlci5cbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIC0gVGhlIGRhdGEgdG8gYmUgcHJlZml4ZWQgd2l0aCBtdWx0aWJhc2UuXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGlmIHRoZSBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkXG4gKi9cbmZ1bmN0aW9uIG11bHRpYmFzZSAobmFtZU9yQ29kZSwgYnVmKSB7XG4gIGlmICghYnVmKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlcyBhbiBlbmNvZGVkIFVpbnQ4QXJyYXknKVxuICB9XG4gIGNvbnN0IHsgbmFtZSwgY29kZUJ1ZiB9ID0gZW5jb2RpbmcobmFtZU9yQ29kZSlcbiAgdmFsaWRFbmNvZGUobmFtZSwgYnVmKVxuXG4gIHJldHVybiBjb25jYXQoW2NvZGVCdWYsIGJ1Zl0sIGNvZGVCdWYubGVuZ3RoICsgYnVmLmxlbmd0aClcbn1cblxuLyoqXG4gKiBFbmNvZGUgZGF0YSB3aXRoIHRoZSBzcGVjaWZpZWQgYmFzZSBhbmQgYWRkIHRoZSBtdWx0aWJhc2UgcHJlZml4LlxuICpcbiAqIEBwYXJhbSB7QmFzZU5hbWVPckNvZGV9IG5hbWVPckNvZGUgLSBUaGUgbXVsdGliYXNlIG5hbWUgb3IgY29kZSBudW1iZXIuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiAtIFRoZSBkYXRhIHRvIGJlIGVuY29kZWQuXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGlmIHRoZSBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkXG4gKlxuICovXG5mdW5jdGlvbiBlbmNvZGUgKG5hbWVPckNvZGUsIGJ1Zikge1xuICBjb25zdCBlbmMgPSBlbmNvZGluZyhuYW1lT3JDb2RlKVxuICBjb25zdCBkYXRhID0gZW5jb2RlVGV4dChlbmMuZW5jb2RlKGJ1ZikpXG5cbiAgcmV0dXJuIGNvbmNhdChbZW5jLmNvZGVCdWYsIGRhdGFdLCBlbmMuY29kZUJ1Zi5sZW5ndGggKyBkYXRhLmxlbmd0aClcbn1cblxuLyoqXG4gKiBUYWtlcyBhIFVpbnQ4QXJyYXkgb3Igc3RyaW5nIGVuY29kZWQgd2l0aCBtdWx0aWJhc2UgaGVhZGVyLCBkZWNvZGVzIGl0IGFuZFxuICogcmV0dXJucyB0aGUgZGVjb2RlZCBidWZmZXJcbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8c3RyaW5nfSBkYXRhXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGlmIHRoZSBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkXG4gKlxuICovXG5mdW5jdGlvbiBkZWNvZGUgKGRhdGEpIHtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgZGF0YSA9IGRlY29kZVRleHQoZGF0YSlcbiAgfVxuICBjb25zdCBwcmVmaXggPSBkYXRhWzBdXG5cbiAgLy8gTWFrZSBhbGwgZW5jb2RpbmdzIGNhc2UtaW5zZW5zaXRpdmUgZXhjZXB0IHRoZSBvbmVzIHRoYXQgaW5jbHVkZSB1cHBlciBhbmQgbG93ZXIgY2hhcnMgaW4gdGhlIGFscGhhYmV0XG4gIGlmIChbJ2YnLCAnRicsICd2JywgJ1YnLCAndCcsICdUJywgJ2InLCAnQicsICdjJywgJ0MnLCAnaCcsICdrJywgJ0snXS5pbmNsdWRlcyhwcmVmaXgpKSB7XG4gICAgZGF0YSA9IGRhdGEudG9Mb3dlckNhc2UoKVxuICB9XG4gIGNvbnN0IGVuYyA9IGVuY29kaW5nKC8qKiBAdHlwZSB7QmFzZUNvZGV9ICovKGRhdGFbMF0pKVxuICByZXR1cm4gZW5jLmRlY29kZShkYXRhLnN1YnN0cmluZygxKSlcbn1cblxuLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gZGF0YSBtdWx0aWJhc2UgZW5jb2RlZD9cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8c3RyaW5nfSBkYXRhXG4gKi9cbmZ1bmN0aW9uIGlzRW5jb2RlZCAoZGF0YSkge1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICBkYXRhID0gZGVjb2RlVGV4dChkYXRhKVxuICB9XG5cbiAgLy8gRW5zdXJlIGJ1Zk9yU3RyaW5nIGlzIGEgc3RyaW5nXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkgIT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGVuYyA9IGVuY29kaW5nKC8qKiBAdHlwZSB7QmFzZUNvZGV9ICovKGRhdGFbMF0pKVxuICAgIHJldHVybiBlbmMubmFtZVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIGVuY29kZWQgZGF0YVxuICpcbiAqIEBwYXJhbSB7QmFzZU5hbWVPckNvZGV9IG5hbWVcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGlmIHRoZSBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkXG4gKi9cbmZ1bmN0aW9uIHZhbGlkRW5jb2RlIChuYW1lLCBidWYpIHtcbiAgY29uc3QgZW5jID0gZW5jb2RpbmcobmFtZSlcbiAgZW5jLmRlY29kZShkZWNvZGVUZXh0KGJ1ZikpXG59XG5cbi8qKlxuICogR2V0IHRoZSBlbmNvZGluZyBieSBuYW1lIG9yIGNvZGVcbiAqXG4gKiBAcGFyYW0ge0Jhc2VOYW1lT3JDb2RlfSBuYW1lT3JDb2RlXG4gKiBAcmV0dXJucyB7QmFzZX1cbiAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGlmIHRoZSBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkXG4gKi9cbmZ1bmN0aW9uIGVuY29kaW5nIChuYW1lT3JDb2RlKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uc3RhbnRzLm5hbWVzLCAvKiogQHR5cGUge0Jhc2VOYW1lfSAqLyhuYW1lT3JDb2RlKSkpIHtcbiAgICByZXR1cm4gY29uc3RhbnRzLm5hbWVzWy8qKiBAdHlwZSB7QmFzZU5hbWV9ICovKG5hbWVPckNvZGUpXVxuICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25zdGFudHMuY29kZXMsIC8qKiBAdHlwZSB7QmFzZUNvZGV9ICovKG5hbWVPckNvZGUpKSkge1xuICAgIHJldHVybiBjb25zdGFudHMuY29kZXNbLyoqIEB0eXBlIHtCYXNlQ29kZX0gKi8obmFtZU9yQ29kZSldXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBlbmNvZGluZzogJHtuYW1lT3JDb2RlfWApXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgZW5jb2RpbmcgZnJvbSBkYXRhXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8VWludDhBcnJheX0gZGF0YVxuICogQHJldHVybnMge0Jhc2V9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBlbmNvZGluZ0Zyb21EYXRhIChkYXRhKSB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIGRhdGEgPSBkZWNvZGVUZXh0KGRhdGEpXG4gIH1cblxuICByZXR1cm4gZW5jb2RpbmcoLyoqIEB0eXBlIHtCYXNlQ29kZX0gKi8oZGF0YVswXSkpXG59XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IG11bHRpYmFzZVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGVcbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlXG5leHBvcnRzLmlzRW5jb2RlZCA9IGlzRW5jb2RlZFxuZXhwb3J0cy5lbmNvZGluZyA9IGVuY29kaW5nXG5leHBvcnRzLmVuY29kaW5nRnJvbURhdGEgPSBlbmNvZGluZ0Zyb21EYXRhXG5jb25zdCBuYW1lcyA9IE9iamVjdC5mcmVlemUoY29uc3RhbnRzLm5hbWVzKVxuY29uc3QgY29kZXMgPSBPYmplY3QuZnJlZXplKGNvbnN0YW50cy5jb2RlcylcbmV4cG9ydHMubmFtZXMgPSBuYW1lc1xuZXhwb3J0cy5jb2RlcyA9IGNvZGVzXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGVuY29kZVxuXG52YXIgTVNCID0gMHg4MFxuICAsIFJFU1QgPSAweDdGXG4gICwgTVNCQUxMID0gflJFU1RcbiAgLCBJTlQgPSBNYXRoLnBvdygyLCAzMSlcblxuZnVuY3Rpb24gZW5jb2RlKG51bSwgb3V0LCBvZmZzZXQpIHtcbiAgb3V0ID0gb3V0IHx8IFtdXG4gIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcblxuICB3aGlsZShudW0gPj0gSU5UKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IChudW0gJiAweEZGKSB8IE1TQlxuICAgIG51bSAvPSAxMjhcbiAgfVxuICB3aGlsZShudW0gJiBNU0JBTEwpIHtcbiAgICBvdXRbb2Zmc2V0KytdID0gKG51bSAmIDB4RkYpIHwgTVNCXG4gICAgbnVtID4+Pj0gN1xuICB9XG4gIG91dFtvZmZzZXRdID0gbnVtIHwgMFxuICBcbiAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0ICsgMVxuICBcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZWFkXG5cbnZhciBNU0IgPSAweDgwXG4gICwgUkVTVCA9IDB4N0ZcblxuZnVuY3Rpb24gcmVhZChidWYsIG9mZnNldCkge1xuICB2YXIgcmVzICAgID0gMFxuICAgICwgb2Zmc2V0ID0gb2Zmc2V0IHx8IDBcbiAgICAsIHNoaWZ0ICA9IDBcbiAgICAsIGNvdW50ZXIgPSBvZmZzZXRcbiAgICAsIGJcbiAgICAsIGwgPSBidWYubGVuZ3RoXG5cbiAgZG8ge1xuICAgIGlmIChjb3VudGVyID49IGwpIHtcbiAgICAgIHJlYWQuYnl0ZXMgPSAwXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ291bGQgbm90IGRlY29kZSB2YXJpbnQnKVxuICAgIH1cbiAgICBiID0gYnVmW2NvdW50ZXIrK11cbiAgICByZXMgKz0gc2hpZnQgPCAyOFxuICAgICAgPyAoYiAmIFJFU1QpIDw8IHNoaWZ0XG4gICAgICA6IChiICYgUkVTVCkgKiBNYXRoLnBvdygyLCBzaGlmdClcbiAgICBzaGlmdCArPSA3XG4gIH0gd2hpbGUgKGIgPj0gTVNCKVxuXG4gIHJlYWQuYnl0ZXMgPSBjb3VudGVyIC0gb2Zmc2V0XG5cbiAgcmV0dXJuIHJlc1xufVxuIiwiXG52YXIgTjEgPSBNYXRoLnBvdygyLCAgNylcbnZhciBOMiA9IE1hdGgucG93KDIsIDE0KVxudmFyIE4zID0gTWF0aC5wb3coMiwgMjEpXG52YXIgTjQgPSBNYXRoLnBvdygyLCAyOClcbnZhciBONSA9IE1hdGgucG93KDIsIDM1KVxudmFyIE42ID0gTWF0aC5wb3coMiwgNDIpXG52YXIgTjcgPSBNYXRoLnBvdygyLCA0OSlcbnZhciBOOCA9IE1hdGgucG93KDIsIDU2KVxudmFyIE45ID0gTWF0aC5wb3coMiwgNjMpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgPCBOMSA/IDFcbiAgOiB2YWx1ZSA8IE4yID8gMlxuICA6IHZhbHVlIDwgTjMgPyAzXG4gIDogdmFsdWUgPCBONCA/IDRcbiAgOiB2YWx1ZSA8IE41ID8gNVxuICA6IHZhbHVlIDwgTjYgPyA2XG4gIDogdmFsdWUgPCBONyA/IDdcbiAgOiB2YWx1ZSA8IE44ID8gOFxuICA6IHZhbHVlIDwgTjkgPyA5XG4gIDogICAgICAgICAgICAgIDEwXG4gIClcbn1cbiIsIi8vIEB0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJhc2VYID0gcmVxdWlyZSgnYmFzZS14JylcbmNvbnN0IEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UuanMnKVxuY29uc3QgcmZjNDY0OCA9IHJlcXVpcmUoJy4vcmZjNDY0OCcpXG5jb25zdCB7IGRlY29kZVRleHQsIGVuY29kZVRleHQgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbmNvbnN0IGlkZW50aXR5ID0gKCkgPT4ge1xuICByZXR1cm4ge1xuICAgIGVuY29kZTogZGVjb2RlVGV4dCxcbiAgICBkZWNvZGU6IGVuY29kZVRleHRcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2Jhc2UnKS5Db2RlY0ZhY3Rvcnl9IENvZGVjRmFjdG9yeVxuICpcbiAqIG5hbWUsIGNvZGUsIGltcGxlbWVudGF0aW9uLCBhbHBoYWJldFxuICogQHR5cGUge0FycmF5PFtzdHJpbmcsIHN0cmluZywgQ29kZWNGYWN0b3J5LCBzdHJpbmddPn1cbiAqL1xuY29uc3QgY29uc3RhbnRzID0gW1xuICBbJ2lkZW50aXR5JywgJ1xceDAwJywgaWRlbnRpdHksICcnXSxcbiAgWydiYXNlMicsICcwJywgcmZjNDY0OCgxKSwgJzAxJ10sXG4gIFsnYmFzZTgnLCAnNycsIHJmYzQ2NDgoMyksICcwMTIzNDU2NyddLFxuICBbJ2Jhc2UxMCcsICc5JywgYmFzZVgsICcwMTIzNDU2Nzg5J10sXG4gIFsnYmFzZTE2JywgJ2YnLCByZmM0NjQ4KDQpLCAnMDEyMzQ1Njc4OWFiY2RlZiddLFxuICBbJ2Jhc2UxNnVwcGVyJywgJ0YnLCByZmM0NjQ4KDQpLCAnMDEyMzQ1Njc4OUFCQ0RFRiddLFxuICBbJ2Jhc2UzMmhleCcsICd2JywgcmZjNDY0OCg1KSwgJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2J10sXG4gIFsnYmFzZTMyaGV4dXBwZXInLCAnVicsIHJmYzQ2NDgoNSksICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVViddLFxuICBbJ2Jhc2UzMmhleHBhZCcsICd0JywgcmZjNDY0OCg1KSwgJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2PSddLFxuICBbJ2Jhc2UzMmhleHBhZHVwcGVyJywgJ1QnLCByZmM0NjQ4KDUpLCAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVY9J10sXG4gIFsnYmFzZTMyJywgJ2InLCByZmM0NjQ4KDUpLCAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjcnXSxcbiAgWydiYXNlMzJ1cHBlcicsICdCJywgcmZjNDY0OCg1KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3J10sXG4gIFsnYmFzZTMycGFkJywgJ2MnLCByZmM0NjQ4KDUpLCAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1Njc9J10sXG4gIFsnYmFzZTMycGFkdXBwZXInLCAnQycsIHJmYzQ2NDgoNSksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2Nz0nXSxcbiAgWydiYXNlMzJ6JywgJ2gnLCByZmM0NjQ4KDUpLCAneWJuZHJmZzhlamttY3BxeG90MXV3aXN6YTM0NWg3NjknXSxcbiAgWydiYXNlMzYnLCAnaycsIGJhc2VYLCAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6J10sXG4gIFsnYmFzZTM2dXBwZXInLCAnSycsIGJhc2VYLCAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJ10sXG4gIFsnYmFzZTU4YnRjJywgJ3onLCBiYXNlWCwgJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXSxcbiAgWydiYXNlNThmbGlja3InLCAnWicsIGJhc2VYLCAnMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWiddLFxuICBbJ2Jhc2U2NCcsICdtJywgcmZjNDY0OCg2KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXSxcbiAgWydiYXNlNjRwYWQnLCAnTScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSddLFxuICBbJ2Jhc2U2NHVybCcsICd1JywgcmZjNDY0OCg2KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nXSxcbiAgWydiYXNlNjR1cmxwYWQnLCAnVScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fPSddXG5dXG5cbmNvbnN0IG5hbWVzID0gY29uc3RhbnRzLnJlZHVjZSgocHJldiwgdHVwcGxlKSA9PiB7XG4gIHByZXZbdHVwcGxlWzBdXSA9IG5ldyBCYXNlKHR1cHBsZVswXSwgdHVwcGxlWzFdLCB0dXBwbGVbMl0sIHR1cHBsZVszXSlcbiAgcmV0dXJuIHByZXZcbn0sIHt9KVxuXG5jb25zdCBjb2RlcyA9IGNvbnN0YW50cy5yZWR1Y2UoKHByZXYsIHR1cHBsZSkgPT4ge1xuICBwcmV2W3R1cHBsZVsxXV0gPSBuYW1lc1t0dXBwbGVbMF1dXG4gIHJldHVybiBwcmV2XG59LCB7fSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWVzLFxuICBjb2Rlc1xufVxuIiwiLy8gQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCB7IFRleHRFbmNvZGVyLCBUZXh0RGVjb2RlciB9ID0gcmVxdWlyZSgnd2ViLWVuY29kaW5nJylcblxuY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld3xBcnJheUJ1ZmZlcn0gYnl0ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGRlY29kZVRleHQgPSAoYnl0ZXMpID0+IHRleHREZWNvZGVyLmRlY29kZShieXRlcylcblxuY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGVuY29kZVRleHQgPSAodGV4dCkgPT4gdGV4dEVuY29kZXIuZW5jb2RlKHRleHQpXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGJ5dGVzXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5jb25zdCBhc0J1ZmZlciA9ICh7IGJ1ZmZlciwgYnl0ZUxlbmd0aCwgYnl0ZU9mZnNldCB9KSA9PlxuICBCdWZmZXIuZnJvbShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpXG5cbm1vZHVsZS5leHBvcnRzID0geyBkZWNvZGVUZXh0LCBlbmNvZGVUZXh0LCBhc0J1ZmZlciB9XG4iLCIvLyBETyBOT1QgQ0hBTkdFIFRISVMgRklMRS4gSVQgSVMgR0VORVJBVEVEIEJZIHRvb2xzL3VwZGF0ZS10YWJsZS5qc1xuLyogZXNsaW50IHF1b3RlLXByb3BzOiBvZmYgKi9cbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEB0eXBlIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLk5hbWVOdW1iZXJNYXB9XG4gKi9cbmNvbnN0IGJhc2VUYWJsZSA9IE9iamVjdC5mcmVlemUoe1xuICAnaWRlbnRpdHknOiAweDAwLFxuICAnY2lkdjEnOiAweDAxLFxuICAnY2lkdjInOiAweDAyLFxuICAnY2lkdjMnOiAweDAzLFxuICAnaXA0JzogMHgwNCxcbiAgJ3RjcCc6IDB4MDYsXG4gICdzaGExJzogMHgxMSxcbiAgJ3NoYTItMjU2JzogMHgxMixcbiAgJ3NoYTItNTEyJzogMHgxMyxcbiAgJ3NoYTMtNTEyJzogMHgxNCxcbiAgJ3NoYTMtMzg0JzogMHgxNSxcbiAgJ3NoYTMtMjU2JzogMHgxNixcbiAgJ3NoYTMtMjI0JzogMHgxNyxcbiAgJ3NoYWtlLTEyOCc6IDB4MTgsXG4gICdzaGFrZS0yNTYnOiAweDE5LFxuICAna2VjY2FrLTIyNCc6IDB4MWEsXG4gICdrZWNjYWstMjU2JzogMHgxYixcbiAgJ2tlY2Nhay0zODQnOiAweDFjLFxuICAna2VjY2FrLTUxMic6IDB4MWQsXG4gICdibGFrZTMnOiAweDFlLFxuICAnZGNjcCc6IDB4MjEsXG4gICdtdXJtdXIzLTEyOCc6IDB4MjIsXG4gICdtdXJtdXIzLTMyJzogMHgyMyxcbiAgJ2lwNic6IDB4MjksXG4gICdpcDZ6b25lJzogMHgyYSxcbiAgJ3BhdGgnOiAweDJmLFxuICAnbXVsdGljb2RlYyc6IDB4MzAsXG4gICdtdWx0aWhhc2gnOiAweDMxLFxuICAnbXVsdGlhZGRyJzogMHgzMixcbiAgJ211bHRpYmFzZSc6IDB4MzMsXG4gICdkbnMnOiAweDM1LFxuICAnZG5zNCc6IDB4MzYsXG4gICdkbnM2JzogMHgzNyxcbiAgJ2Ruc2FkZHInOiAweDM4LFxuICAncHJvdG9idWYnOiAweDUwLFxuICAnY2Jvcic6IDB4NTEsXG4gICdyYXcnOiAweDU1LFxuICAnZGJsLXNoYTItMjU2JzogMHg1NixcbiAgJ3JscCc6IDB4NjAsXG4gICdiZW5jb2RlJzogMHg2MyxcbiAgJ2RhZy1wYic6IDB4NzAsXG4gICdkYWctY2Jvcic6IDB4NzEsXG4gICdsaWJwMnAta2V5JzogMHg3MixcbiAgJ2dpdC1yYXcnOiAweDc4LFxuICAndG9ycmVudC1pbmZvJzogMHg3YixcbiAgJ3RvcnJlbnQtZmlsZSc6IDB4N2MsXG4gICdsZW9mY29pbi1ibG9jayc6IDB4ODEsXG4gICdsZW9mY29pbi10eCc6IDB4ODIsXG4gICdsZW9mY29pbi1wcic6IDB4ODMsXG4gICdzY3RwJzogMHg4NCxcbiAgJ2RhZy1qb3NlJzogMHg4NSxcbiAgJ2RhZy1jb3NlJzogMHg4NixcbiAgJ2V0aC1ibG9jayc6IDB4OTAsXG4gICdldGgtYmxvY2stbGlzdCc6IDB4OTEsXG4gICdldGgtdHgtdHJpZSc6IDB4OTIsXG4gICdldGgtdHgnOiAweDkzLFxuICAnZXRoLXR4LXJlY2VpcHQtdHJpZSc6IDB4OTQsXG4gICdldGgtdHgtcmVjZWlwdCc6IDB4OTUsXG4gICdldGgtc3RhdGUtdHJpZSc6IDB4OTYsXG4gICdldGgtYWNjb3VudC1zbmFwc2hvdCc6IDB4OTcsXG4gICdldGgtc3RvcmFnZS10cmllJzogMHg5OCxcbiAgJ2JpdGNvaW4tYmxvY2snOiAweGIwLFxuICAnYml0Y29pbi10eCc6IDB4YjEsXG4gICdiaXRjb2luLXdpdG5lc3MtY29tbWl0bWVudCc6IDB4YjIsXG4gICd6Y2FzaC1ibG9jayc6IDB4YzAsXG4gICd6Y2FzaC10eCc6IDB4YzEsXG4gICdkb2NpZCc6IDB4Y2UsXG4gICdzdGVsbGFyLWJsb2NrJzogMHhkMCxcbiAgJ3N0ZWxsYXItdHgnOiAweGQxLFxuICAnbWQ0JzogMHhkNCxcbiAgJ21kNSc6IDB4ZDUsXG4gICdibXQnOiAweGQ2LFxuICAnZGVjcmVkLWJsb2NrJzogMHhlMCxcbiAgJ2RlY3JlZC10eCc6IDB4ZTEsXG4gICdpcGxkLW5zJzogMHhlMixcbiAgJ2lwZnMtbnMnOiAweGUzLFxuICAnc3dhcm0tbnMnOiAweGU0LFxuICAnaXBucy1ucyc6IDB4ZTUsXG4gICd6ZXJvbmV0JzogMHhlNixcbiAgJ3NlY3AyNTZrMS1wdWInOiAweGU3LFxuICAnYmxzMTJfMzgxLWcxLXB1Yic6IDB4ZWEsXG4gICdibHMxMl8zODEtZzItcHViJzogMHhlYixcbiAgJ3gyNTUxOS1wdWInOiAweGVjLFxuICAnZWQyNTUxOS1wdWInOiAweGVkLFxuICAnYmxzMTJfMzgxLWcxZzItcHViJzogMHhlZSxcbiAgJ2Rhc2gtYmxvY2snOiAweGYwLFxuICAnZGFzaC10eCc6IDB4ZjEsXG4gICdzd2FybS1tYW5pZmVzdCc6IDB4ZmEsXG4gICdzd2FybS1mZWVkJzogMHhmYixcbiAgJ3VkcCc6IDB4MDExMSxcbiAgJ3AycC13ZWJydGMtc3Rhcic6IDB4MDExMyxcbiAgJ3AycC13ZWJydGMtZGlyZWN0JzogMHgwMTE0LFxuICAncDJwLXN0YXJkdXN0JzogMHgwMTE1LFxuICAncDJwLWNpcmN1aXQnOiAweDAxMjIsXG4gICdkYWctanNvbic6IDB4MDEyOSxcbiAgJ3VkdCc6IDB4MDEyZCxcbiAgJ3V0cCc6IDB4MDEyZSxcbiAgJ3VuaXgnOiAweDAxOTAsXG4gICdwMnAnOiAweDAxYTUsXG4gICdpcGZzJzogMHgwMWE1LFxuICAnaHR0cHMnOiAweDAxYmIsXG4gICdvbmlvbic6IDB4MDFiYyxcbiAgJ29uaW9uMyc6IDB4MDFiZCxcbiAgJ2dhcmxpYzY0JzogMHgwMWJlLFxuICAnZ2FybGljMzInOiAweDAxYmYsXG4gICd0bHMnOiAweDAxYzAsXG4gICdxdWljJzogMHgwMWNjLFxuICAnd3MnOiAweDAxZGQsXG4gICd3c3MnOiAweDAxZGUsXG4gICdwMnAtd2Vic29ja2V0LXN0YXInOiAweDAxZGYsXG4gICdodHRwJzogMHgwMWUwLFxuICAnanNvbic6IDB4MDIwMCxcbiAgJ21lc3NhZ2VwYWNrJzogMHgwMjAxLFxuICAnbGlicDJwLXBlZXItcmVjb3JkJzogMHgwMzAxLFxuICAnc2hhMi0yNTYtdHJ1bmMyNTQtcGFkZGVkJzogMHgxMDEyLFxuICAncmlwZW1kLTEyOCc6IDB4MTA1MixcbiAgJ3JpcGVtZC0xNjAnOiAweDEwNTMsXG4gICdyaXBlbWQtMjU2JzogMHgxMDU0LFxuICAncmlwZW1kLTMyMCc6IDB4MTA1NSxcbiAgJ3gxMSc6IDB4MTEwMCxcbiAgJ3AyNTYtcHViJzogMHgxMjAwLFxuICAncDM4NC1wdWInOiAweDEyMDEsXG4gICdwNTIxLXB1Yic6IDB4MTIwMixcbiAgJ2VkNDQ4LXB1Yic6IDB4MTIwMyxcbiAgJ3g0NDgtcHViJzogMHgxMjA0LFxuICAnZWQyNTUxOS1wcml2JzogMHgxMzAwLFxuICAna2FuZ2Fyb290d2VsdmUnOiAweDFkMDEsXG4gICdzbTMtMjU2JzogMHg1MzRkLFxuICAnYmxha2UyYi04JzogMHhiMjAxLFxuICAnYmxha2UyYi0xNic6IDB4YjIwMixcbiAgJ2JsYWtlMmItMjQnOiAweGIyMDMsXG4gICdibGFrZTJiLTMyJzogMHhiMjA0LFxuICAnYmxha2UyYi00MCc6IDB4YjIwNSxcbiAgJ2JsYWtlMmItNDgnOiAweGIyMDYsXG4gICdibGFrZTJiLTU2JzogMHhiMjA3LFxuICAnYmxha2UyYi02NCc6IDB4YjIwOCxcbiAgJ2JsYWtlMmItNzInOiAweGIyMDksXG4gICdibGFrZTJiLTgwJzogMHhiMjBhLFxuICAnYmxha2UyYi04OCc6IDB4YjIwYixcbiAgJ2JsYWtlMmItOTYnOiAweGIyMGMsXG4gICdibGFrZTJiLTEwNCc6IDB4YjIwZCxcbiAgJ2JsYWtlMmItMTEyJzogMHhiMjBlLFxuICAnYmxha2UyYi0xMjAnOiAweGIyMGYsXG4gICdibGFrZTJiLTEyOCc6IDB4YjIxMCxcbiAgJ2JsYWtlMmItMTM2JzogMHhiMjExLFxuICAnYmxha2UyYi0xNDQnOiAweGIyMTIsXG4gICdibGFrZTJiLTE1Mic6IDB4YjIxMyxcbiAgJ2JsYWtlMmItMTYwJzogMHhiMjE0LFxuICAnYmxha2UyYi0xNjgnOiAweGIyMTUsXG4gICdibGFrZTJiLTE3Nic6IDB4YjIxNixcbiAgJ2JsYWtlMmItMTg0JzogMHhiMjE3LFxuICAnYmxha2UyYi0xOTInOiAweGIyMTgsXG4gICdibGFrZTJiLTIwMCc6IDB4YjIxOSxcbiAgJ2JsYWtlMmItMjA4JzogMHhiMjFhLFxuICAnYmxha2UyYi0yMTYnOiAweGIyMWIsXG4gICdibGFrZTJiLTIyNCc6IDB4YjIxYyxcbiAgJ2JsYWtlMmItMjMyJzogMHhiMjFkLFxuICAnYmxha2UyYi0yNDAnOiAweGIyMWUsXG4gICdibGFrZTJiLTI0OCc6IDB4YjIxZixcbiAgJ2JsYWtlMmItMjU2JzogMHhiMjIwLFxuICAnYmxha2UyYi0yNjQnOiAweGIyMjEsXG4gICdibGFrZTJiLTI3Mic6IDB4YjIyMixcbiAgJ2JsYWtlMmItMjgwJzogMHhiMjIzLFxuICAnYmxha2UyYi0yODgnOiAweGIyMjQsXG4gICdibGFrZTJiLTI5Nic6IDB4YjIyNSxcbiAgJ2JsYWtlMmItMzA0JzogMHhiMjI2LFxuICAnYmxha2UyYi0zMTInOiAweGIyMjcsXG4gICdibGFrZTJiLTMyMCc6IDB4YjIyOCxcbiAgJ2JsYWtlMmItMzI4JzogMHhiMjI5LFxuICAnYmxha2UyYi0zMzYnOiAweGIyMmEsXG4gICdibGFrZTJiLTM0NCc6IDB4YjIyYixcbiAgJ2JsYWtlMmItMzUyJzogMHhiMjJjLFxuICAnYmxha2UyYi0zNjAnOiAweGIyMmQsXG4gICdibGFrZTJiLTM2OCc6IDB4YjIyZSxcbiAgJ2JsYWtlMmItMzc2JzogMHhiMjJmLFxuICAnYmxha2UyYi0zODQnOiAweGIyMzAsXG4gICdibGFrZTJiLTM5Mic6IDB4YjIzMSxcbiAgJ2JsYWtlMmItNDAwJzogMHhiMjMyLFxuICAnYmxha2UyYi00MDgnOiAweGIyMzMsXG4gICdibGFrZTJiLTQxNic6IDB4YjIzNCxcbiAgJ2JsYWtlMmItNDI0JzogMHhiMjM1LFxuICAnYmxha2UyYi00MzInOiAweGIyMzYsXG4gICdibGFrZTJiLTQ0MCc6IDB4YjIzNyxcbiAgJ2JsYWtlMmItNDQ4JzogMHhiMjM4LFxuICAnYmxha2UyYi00NTYnOiAweGIyMzksXG4gICdibGFrZTJiLTQ2NCc6IDB4YjIzYSxcbiAgJ2JsYWtlMmItNDcyJzogMHhiMjNiLFxuICAnYmxha2UyYi00ODAnOiAweGIyM2MsXG4gICdibGFrZTJiLTQ4OCc6IDB4YjIzZCxcbiAgJ2JsYWtlMmItNDk2JzogMHhiMjNlLFxuICAnYmxha2UyYi01MDQnOiAweGIyM2YsXG4gICdibGFrZTJiLTUxMic6IDB4YjI0MCxcbiAgJ2JsYWtlMnMtOCc6IDB4YjI0MSxcbiAgJ2JsYWtlMnMtMTYnOiAweGIyNDIsXG4gICdibGFrZTJzLTI0JzogMHhiMjQzLFxuICAnYmxha2Uycy0zMic6IDB4YjI0NCxcbiAgJ2JsYWtlMnMtNDAnOiAweGIyNDUsXG4gICdibGFrZTJzLTQ4JzogMHhiMjQ2LFxuICAnYmxha2Uycy01Nic6IDB4YjI0NyxcbiAgJ2JsYWtlMnMtNjQnOiAweGIyNDgsXG4gICdibGFrZTJzLTcyJzogMHhiMjQ5LFxuICAnYmxha2Uycy04MCc6IDB4YjI0YSxcbiAgJ2JsYWtlMnMtODgnOiAweGIyNGIsXG4gICdibGFrZTJzLTk2JzogMHhiMjRjLFxuICAnYmxha2Uycy0xMDQnOiAweGIyNGQsXG4gICdibGFrZTJzLTExMic6IDB4YjI0ZSxcbiAgJ2JsYWtlMnMtMTIwJzogMHhiMjRmLFxuICAnYmxha2Uycy0xMjgnOiAweGIyNTAsXG4gICdibGFrZTJzLTEzNic6IDB4YjI1MSxcbiAgJ2JsYWtlMnMtMTQ0JzogMHhiMjUyLFxuICAnYmxha2Uycy0xNTInOiAweGIyNTMsXG4gICdibGFrZTJzLTE2MCc6IDB4YjI1NCxcbiAgJ2JsYWtlMnMtMTY4JzogMHhiMjU1LFxuICAnYmxha2Uycy0xNzYnOiAweGIyNTYsXG4gICdibGFrZTJzLTE4NCc6IDB4YjI1NyxcbiAgJ2JsYWtlMnMtMTkyJzogMHhiMjU4LFxuICAnYmxha2Uycy0yMDAnOiAweGIyNTksXG4gICdibGFrZTJzLTIwOCc6IDB4YjI1YSxcbiAgJ2JsYWtlMnMtMjE2JzogMHhiMjViLFxuICAnYmxha2Uycy0yMjQnOiAweGIyNWMsXG4gICdibGFrZTJzLTIzMic6IDB4YjI1ZCxcbiAgJ2JsYWtlMnMtMjQwJzogMHhiMjVlLFxuICAnYmxha2Uycy0yNDgnOiAweGIyNWYsXG4gICdibGFrZTJzLTI1Nic6IDB4YjI2MCxcbiAgJ3NrZWluMjU2LTgnOiAweGIzMDEsXG4gICdza2VpbjI1Ni0xNic6IDB4YjMwMixcbiAgJ3NrZWluMjU2LTI0JzogMHhiMzAzLFxuICAnc2tlaW4yNTYtMzInOiAweGIzMDQsXG4gICdza2VpbjI1Ni00MCc6IDB4YjMwNSxcbiAgJ3NrZWluMjU2LTQ4JzogMHhiMzA2LFxuICAnc2tlaW4yNTYtNTYnOiAweGIzMDcsXG4gICdza2VpbjI1Ni02NCc6IDB4YjMwOCxcbiAgJ3NrZWluMjU2LTcyJzogMHhiMzA5LFxuICAnc2tlaW4yNTYtODAnOiAweGIzMGEsXG4gICdza2VpbjI1Ni04OCc6IDB4YjMwYixcbiAgJ3NrZWluMjU2LTk2JzogMHhiMzBjLFxuICAnc2tlaW4yNTYtMTA0JzogMHhiMzBkLFxuICAnc2tlaW4yNTYtMTEyJzogMHhiMzBlLFxuICAnc2tlaW4yNTYtMTIwJzogMHhiMzBmLFxuICAnc2tlaW4yNTYtMTI4JzogMHhiMzEwLFxuICAnc2tlaW4yNTYtMTM2JzogMHhiMzExLFxuICAnc2tlaW4yNTYtMTQ0JzogMHhiMzEyLFxuICAnc2tlaW4yNTYtMTUyJzogMHhiMzEzLFxuICAnc2tlaW4yNTYtMTYwJzogMHhiMzE0LFxuICAnc2tlaW4yNTYtMTY4JzogMHhiMzE1LFxuICAnc2tlaW4yNTYtMTc2JzogMHhiMzE2LFxuICAnc2tlaW4yNTYtMTg0JzogMHhiMzE3LFxuICAnc2tlaW4yNTYtMTkyJzogMHhiMzE4LFxuICAnc2tlaW4yNTYtMjAwJzogMHhiMzE5LFxuICAnc2tlaW4yNTYtMjA4JzogMHhiMzFhLFxuICAnc2tlaW4yNTYtMjE2JzogMHhiMzFiLFxuICAnc2tlaW4yNTYtMjI0JzogMHhiMzFjLFxuICAnc2tlaW4yNTYtMjMyJzogMHhiMzFkLFxuICAnc2tlaW4yNTYtMjQwJzogMHhiMzFlLFxuICAnc2tlaW4yNTYtMjQ4JzogMHhiMzFmLFxuICAnc2tlaW4yNTYtMjU2JzogMHhiMzIwLFxuICAnc2tlaW41MTItOCc6IDB4YjMyMSxcbiAgJ3NrZWluNTEyLTE2JzogMHhiMzIyLFxuICAnc2tlaW41MTItMjQnOiAweGIzMjMsXG4gICdza2VpbjUxMi0zMic6IDB4YjMyNCxcbiAgJ3NrZWluNTEyLTQwJzogMHhiMzI1LFxuICAnc2tlaW41MTItNDgnOiAweGIzMjYsXG4gICdza2VpbjUxMi01Nic6IDB4YjMyNyxcbiAgJ3NrZWluNTEyLTY0JzogMHhiMzI4LFxuICAnc2tlaW41MTItNzInOiAweGIzMjksXG4gICdza2VpbjUxMi04MCc6IDB4YjMyYSxcbiAgJ3NrZWluNTEyLTg4JzogMHhiMzJiLFxuICAnc2tlaW41MTItOTYnOiAweGIzMmMsXG4gICdza2VpbjUxMi0xMDQnOiAweGIzMmQsXG4gICdza2VpbjUxMi0xMTInOiAweGIzMmUsXG4gICdza2VpbjUxMi0xMjAnOiAweGIzMmYsXG4gICdza2VpbjUxMi0xMjgnOiAweGIzMzAsXG4gICdza2VpbjUxMi0xMzYnOiAweGIzMzEsXG4gICdza2VpbjUxMi0xNDQnOiAweGIzMzIsXG4gICdza2VpbjUxMi0xNTInOiAweGIzMzMsXG4gICdza2VpbjUxMi0xNjAnOiAweGIzMzQsXG4gICdza2VpbjUxMi0xNjgnOiAweGIzMzUsXG4gICdza2VpbjUxMi0xNzYnOiAweGIzMzYsXG4gICdza2VpbjUxMi0xODQnOiAweGIzMzcsXG4gICdza2VpbjUxMi0xOTInOiAweGIzMzgsXG4gICdza2VpbjUxMi0yMDAnOiAweGIzMzksXG4gICdza2VpbjUxMi0yMDgnOiAweGIzM2EsXG4gICdza2VpbjUxMi0yMTYnOiAweGIzM2IsXG4gICdza2VpbjUxMi0yMjQnOiAweGIzM2MsXG4gICdza2VpbjUxMi0yMzInOiAweGIzM2QsXG4gICdza2VpbjUxMi0yNDAnOiAweGIzM2UsXG4gICdza2VpbjUxMi0yNDgnOiAweGIzM2YsXG4gICdza2VpbjUxMi0yNTYnOiAweGIzNDAsXG4gICdza2VpbjUxMi0yNjQnOiAweGIzNDEsXG4gICdza2VpbjUxMi0yNzInOiAweGIzNDIsXG4gICdza2VpbjUxMi0yODAnOiAweGIzNDMsXG4gICdza2VpbjUxMi0yODgnOiAweGIzNDQsXG4gICdza2VpbjUxMi0yOTYnOiAweGIzNDUsXG4gICdza2VpbjUxMi0zMDQnOiAweGIzNDYsXG4gICdza2VpbjUxMi0zMTInOiAweGIzNDcsXG4gICdza2VpbjUxMi0zMjAnOiAweGIzNDgsXG4gICdza2VpbjUxMi0zMjgnOiAweGIzNDksXG4gICdza2VpbjUxMi0zMzYnOiAweGIzNGEsXG4gICdza2VpbjUxMi0zNDQnOiAweGIzNGIsXG4gICdza2VpbjUxMi0zNTInOiAweGIzNGMsXG4gICdza2VpbjUxMi0zNjAnOiAweGIzNGQsXG4gICdza2VpbjUxMi0zNjgnOiAweGIzNGUsXG4gICdza2VpbjUxMi0zNzYnOiAweGIzNGYsXG4gICdza2VpbjUxMi0zODQnOiAweGIzNTAsXG4gICdza2VpbjUxMi0zOTInOiAweGIzNTEsXG4gICdza2VpbjUxMi00MDAnOiAweGIzNTIsXG4gICdza2VpbjUxMi00MDgnOiAweGIzNTMsXG4gICdza2VpbjUxMi00MTYnOiAweGIzNTQsXG4gICdza2VpbjUxMi00MjQnOiAweGIzNTUsXG4gICdza2VpbjUxMi00MzInOiAweGIzNTYsXG4gICdza2VpbjUxMi00NDAnOiAweGIzNTcsXG4gICdza2VpbjUxMi00NDgnOiAweGIzNTgsXG4gICdza2VpbjUxMi00NTYnOiAweGIzNTksXG4gICdza2VpbjUxMi00NjQnOiAweGIzNWEsXG4gICdza2VpbjUxMi00NzInOiAweGIzNWIsXG4gICdza2VpbjUxMi00ODAnOiAweGIzNWMsXG4gICdza2VpbjUxMi00ODgnOiAweGIzNWQsXG4gICdza2VpbjUxMi00OTYnOiAweGIzNWUsXG4gICdza2VpbjUxMi01MDQnOiAweGIzNWYsXG4gICdza2VpbjUxMi01MTInOiAweGIzNjAsXG4gICdza2VpbjEwMjQtOCc6IDB4YjM2MSxcbiAgJ3NrZWluMTAyNC0xNic6IDB4YjM2MixcbiAgJ3NrZWluMTAyNC0yNCc6IDB4YjM2MyxcbiAgJ3NrZWluMTAyNC0zMic6IDB4YjM2NCxcbiAgJ3NrZWluMTAyNC00MCc6IDB4YjM2NSxcbiAgJ3NrZWluMTAyNC00OCc6IDB4YjM2NixcbiAgJ3NrZWluMTAyNC01Nic6IDB4YjM2NyxcbiAgJ3NrZWluMTAyNC02NCc6IDB4YjM2OCxcbiAgJ3NrZWluMTAyNC03Mic6IDB4YjM2OSxcbiAgJ3NrZWluMTAyNC04MCc6IDB4YjM2YSxcbiAgJ3NrZWluMTAyNC04OCc6IDB4YjM2YixcbiAgJ3NrZWluMTAyNC05Nic6IDB4YjM2YyxcbiAgJ3NrZWluMTAyNC0xMDQnOiAweGIzNmQsXG4gICdza2VpbjEwMjQtMTEyJzogMHhiMzZlLFxuICAnc2tlaW4xMDI0LTEyMCc6IDB4YjM2ZixcbiAgJ3NrZWluMTAyNC0xMjgnOiAweGIzNzAsXG4gICdza2VpbjEwMjQtMTM2JzogMHhiMzcxLFxuICAnc2tlaW4xMDI0LTE0NCc6IDB4YjM3MixcbiAgJ3NrZWluMTAyNC0xNTInOiAweGIzNzMsXG4gICdza2VpbjEwMjQtMTYwJzogMHhiMzc0LFxuICAnc2tlaW4xMDI0LTE2OCc6IDB4YjM3NSxcbiAgJ3NrZWluMTAyNC0xNzYnOiAweGIzNzYsXG4gICdza2VpbjEwMjQtMTg0JzogMHhiMzc3LFxuICAnc2tlaW4xMDI0LTE5Mic6IDB4YjM3OCxcbiAgJ3NrZWluMTAyNC0yMDAnOiAweGIzNzksXG4gICdza2VpbjEwMjQtMjA4JzogMHhiMzdhLFxuICAnc2tlaW4xMDI0LTIxNic6IDB4YjM3YixcbiAgJ3NrZWluMTAyNC0yMjQnOiAweGIzN2MsXG4gICdza2VpbjEwMjQtMjMyJzogMHhiMzdkLFxuICAnc2tlaW4xMDI0LTI0MCc6IDB4YjM3ZSxcbiAgJ3NrZWluMTAyNC0yNDgnOiAweGIzN2YsXG4gICdza2VpbjEwMjQtMjU2JzogMHhiMzgwLFxuICAnc2tlaW4xMDI0LTI2NCc6IDB4YjM4MSxcbiAgJ3NrZWluMTAyNC0yNzInOiAweGIzODIsXG4gICdza2VpbjEwMjQtMjgwJzogMHhiMzgzLFxuICAnc2tlaW4xMDI0LTI4OCc6IDB4YjM4NCxcbiAgJ3NrZWluMTAyNC0yOTYnOiAweGIzODUsXG4gICdza2VpbjEwMjQtMzA0JzogMHhiMzg2LFxuICAnc2tlaW4xMDI0LTMxMic6IDB4YjM4NyxcbiAgJ3NrZWluMTAyNC0zMjAnOiAweGIzODgsXG4gICdza2VpbjEwMjQtMzI4JzogMHhiMzg5LFxuICAnc2tlaW4xMDI0LTMzNic6IDB4YjM4YSxcbiAgJ3NrZWluMTAyNC0zNDQnOiAweGIzOGIsXG4gICdza2VpbjEwMjQtMzUyJzogMHhiMzhjLFxuICAnc2tlaW4xMDI0LTM2MCc6IDB4YjM4ZCxcbiAgJ3NrZWluMTAyNC0zNjgnOiAweGIzOGUsXG4gICdza2VpbjEwMjQtMzc2JzogMHhiMzhmLFxuICAnc2tlaW4xMDI0LTM4NCc6IDB4YjM5MCxcbiAgJ3NrZWluMTAyNC0zOTInOiAweGIzOTEsXG4gICdza2VpbjEwMjQtNDAwJzogMHhiMzkyLFxuICAnc2tlaW4xMDI0LTQwOCc6IDB4YjM5MyxcbiAgJ3NrZWluMTAyNC00MTYnOiAweGIzOTQsXG4gICdza2VpbjEwMjQtNDI0JzogMHhiMzk1LFxuICAnc2tlaW4xMDI0LTQzMic6IDB4YjM5NixcbiAgJ3NrZWluMTAyNC00NDAnOiAweGIzOTcsXG4gICdza2VpbjEwMjQtNDQ4JzogMHhiMzk4LFxuICAnc2tlaW4xMDI0LTQ1Nic6IDB4YjM5OSxcbiAgJ3NrZWluMTAyNC00NjQnOiAweGIzOWEsXG4gICdza2VpbjEwMjQtNDcyJzogMHhiMzliLFxuICAnc2tlaW4xMDI0LTQ4MCc6IDB4YjM5YyxcbiAgJ3NrZWluMTAyNC00ODgnOiAweGIzOWQsXG4gICdza2VpbjEwMjQtNDk2JzogMHhiMzllLFxuICAnc2tlaW4xMDI0LTUwNCc6IDB4YjM5ZixcbiAgJ3NrZWluMTAyNC01MTInOiAweGIzYTAsXG4gICdza2VpbjEwMjQtNTIwJzogMHhiM2ExLFxuICAnc2tlaW4xMDI0LTUyOCc6IDB4YjNhMixcbiAgJ3NrZWluMTAyNC01MzYnOiAweGIzYTMsXG4gICdza2VpbjEwMjQtNTQ0JzogMHhiM2E0LFxuICAnc2tlaW4xMDI0LTU1Mic6IDB4YjNhNSxcbiAgJ3NrZWluMTAyNC01NjAnOiAweGIzYTYsXG4gICdza2VpbjEwMjQtNTY4JzogMHhiM2E3LFxuICAnc2tlaW4xMDI0LTU3Nic6IDB4YjNhOCxcbiAgJ3NrZWluMTAyNC01ODQnOiAweGIzYTksXG4gICdza2VpbjEwMjQtNTkyJzogMHhiM2FhLFxuICAnc2tlaW4xMDI0LTYwMCc6IDB4YjNhYixcbiAgJ3NrZWluMTAyNC02MDgnOiAweGIzYWMsXG4gICdza2VpbjEwMjQtNjE2JzogMHhiM2FkLFxuICAnc2tlaW4xMDI0LTYyNCc6IDB4YjNhZSxcbiAgJ3NrZWluMTAyNC02MzInOiAweGIzYWYsXG4gICdza2VpbjEwMjQtNjQwJzogMHhiM2IwLFxuICAnc2tlaW4xMDI0LTY0OCc6IDB4YjNiMSxcbiAgJ3NrZWluMTAyNC02NTYnOiAweGIzYjIsXG4gICdza2VpbjEwMjQtNjY0JzogMHhiM2IzLFxuICAnc2tlaW4xMDI0LTY3Mic6IDB4YjNiNCxcbiAgJ3NrZWluMTAyNC02ODAnOiAweGIzYjUsXG4gICdza2VpbjEwMjQtNjg4JzogMHhiM2I2LFxuICAnc2tlaW4xMDI0LTY5Nic6IDB4YjNiNyxcbiAgJ3NrZWluMTAyNC03MDQnOiAweGIzYjgsXG4gICdza2VpbjEwMjQtNzEyJzogMHhiM2I5LFxuICAnc2tlaW4xMDI0LTcyMCc6IDB4YjNiYSxcbiAgJ3NrZWluMTAyNC03MjgnOiAweGIzYmIsXG4gICdza2VpbjEwMjQtNzM2JzogMHhiM2JjLFxuICAnc2tlaW4xMDI0LTc0NCc6IDB4YjNiZCxcbiAgJ3NrZWluMTAyNC03NTInOiAweGIzYmUsXG4gICdza2VpbjEwMjQtNzYwJzogMHhiM2JmLFxuICAnc2tlaW4xMDI0LTc2OCc6IDB4YjNjMCxcbiAgJ3NrZWluMTAyNC03NzYnOiAweGIzYzEsXG4gICdza2VpbjEwMjQtNzg0JzogMHhiM2MyLFxuICAnc2tlaW4xMDI0LTc5Mic6IDB4YjNjMyxcbiAgJ3NrZWluMTAyNC04MDAnOiAweGIzYzQsXG4gICdza2VpbjEwMjQtODA4JzogMHhiM2M1LFxuICAnc2tlaW4xMDI0LTgxNic6IDB4YjNjNixcbiAgJ3NrZWluMTAyNC04MjQnOiAweGIzYzcsXG4gICdza2VpbjEwMjQtODMyJzogMHhiM2M4LFxuICAnc2tlaW4xMDI0LTg0MCc6IDB4YjNjOSxcbiAgJ3NrZWluMTAyNC04NDgnOiAweGIzY2EsXG4gICdza2VpbjEwMjQtODU2JzogMHhiM2NiLFxuICAnc2tlaW4xMDI0LTg2NCc6IDB4YjNjYyxcbiAgJ3NrZWluMTAyNC04NzInOiAweGIzY2QsXG4gICdza2VpbjEwMjQtODgwJzogMHhiM2NlLFxuICAnc2tlaW4xMDI0LTg4OCc6IDB4YjNjZixcbiAgJ3NrZWluMTAyNC04OTYnOiAweGIzZDAsXG4gICdza2VpbjEwMjQtOTA0JzogMHhiM2QxLFxuICAnc2tlaW4xMDI0LTkxMic6IDB4YjNkMixcbiAgJ3NrZWluMTAyNC05MjAnOiAweGIzZDMsXG4gICdza2VpbjEwMjQtOTI4JzogMHhiM2Q0LFxuICAnc2tlaW4xMDI0LTkzNic6IDB4YjNkNSxcbiAgJ3NrZWluMTAyNC05NDQnOiAweGIzZDYsXG4gICdza2VpbjEwMjQtOTUyJzogMHhiM2Q3LFxuICAnc2tlaW4xMDI0LTk2MCc6IDB4YjNkOCxcbiAgJ3NrZWluMTAyNC05NjgnOiAweGIzZDksXG4gICdza2VpbjEwMjQtOTc2JzogMHhiM2RhLFxuICAnc2tlaW4xMDI0LTk4NCc6IDB4YjNkYixcbiAgJ3NrZWluMTAyNC05OTInOiAweGIzZGMsXG4gICdza2VpbjEwMjQtMTAwMCc6IDB4YjNkZCxcbiAgJ3NrZWluMTAyNC0xMDA4JzogMHhiM2RlLFxuICAnc2tlaW4xMDI0LTEwMTYnOiAweGIzZGYsXG4gICdza2VpbjEwMjQtMTAyNCc6IDB4YjNlMCxcbiAgJ3Bvc2VpZG9uLWJsczEyXzM4MS1hMi1mYzEnOiAweGI0MDEsXG4gICdwb3NlaWRvbi1ibHMxMl8zODEtYTItZmMxLXNjJzogMHhiNDAyLFxuICAnemVyb3hjZXJ0LWltcHJpbnQtMjU2JzogMHhjZTExLFxuICAnZmlsLWNvbW1pdG1lbnQtdW5zZWFsZWQnOiAweGYxMDEsXG4gICdmaWwtY29tbWl0bWVudC1zZWFsZWQnOiAweGYxMDIsXG4gICdob2xvY2hhaW4tYWRyLXYwJzogMHg4MDcxMjQsXG4gICdob2xvY2hhaW4tYWRyLXYxJzogMHg4MTcxMjQsXG4gICdob2xvY2hhaW4ta2V5LXYwJzogMHg5NDcxMjQsXG4gICdob2xvY2hhaW4ta2V5LXYxJzogMHg5NTcxMjQsXG4gICdob2xvY2hhaW4tc2lnLXYwJzogMHhhMjcxMjQsXG4gICdob2xvY2hhaW4tc2lnLXYxJzogMHhhMzcxMjQsXG4gICdza3luZXQtbnMnOiAweGIxOTkxMFxufSlcblxubW9kdWxlLmV4cG9ydHMgPSB7IGJhc2VUYWJsZSB9XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGVuY29kZVxuXG52YXIgTVNCID0gMHg4MFxuICAsIFJFU1QgPSAweDdGXG4gICwgTVNCQUxMID0gflJFU1RcbiAgLCBJTlQgPSBNYXRoLnBvdygyLCAzMSlcblxuZnVuY3Rpb24gZW5jb2RlKG51bSwgb3V0LCBvZmZzZXQpIHtcbiAgaWYgKE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICYmIG51bSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgZW5jb2RlLmJ5dGVzID0gMFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdDb3VsZCBub3QgZW5jb2RlIHZhcmludCcpXG4gIH1cbiAgb3V0ID0gb3V0IHx8IFtdXG4gIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcblxuICB3aGlsZShudW0gPj0gSU5UKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IChudW0gJiAweEZGKSB8IE1TQlxuICAgIG51bSAvPSAxMjhcbiAgfVxuICB3aGlsZShudW0gJiBNU0JBTEwpIHtcbiAgICBvdXRbb2Zmc2V0KytdID0gKG51bSAmIDB4RkYpIHwgTVNCXG4gICAgbnVtID4+Pj0gN1xuICB9XG4gIG91dFtvZmZzZXRdID0gbnVtIHwgMFxuICBcbiAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0ICsgMVxuICBcbiAgcmV0dXJuIG91dFxufVxuIiwiXG52YXIgTjEgPSBNYXRoLnBvdygyLCAgNylcbnZhciBOMiA9IE1hdGgucG93KDIsIDE0KVxudmFyIE4zID0gTWF0aC5wb3coMiwgMjEpXG52YXIgTjQgPSBNYXRoLnBvdygyLCAyOClcbnZhciBONSA9IE1hdGgucG93KDIsIDM1KVxudmFyIE42ID0gTWF0aC5wb3coMiwgNDIpXG52YXIgTjcgPSBNYXRoLnBvdygyLCA0OSlcbnZhciBOOCA9IE1hdGgucG93KDIsIDU2KVxudmFyIE45ID0gTWF0aC5wb3coMiwgNjMpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgPCBOMSA/IDFcbiAgOiB2YWx1ZSA8IE4yID8gMlxuICA6IHZhbHVlIDwgTjMgPyAzXG4gIDogdmFsdWUgPCBONCA/IDRcbiAgOiB2YWx1ZSA8IE41ID8gNVxuICA6IHZhbHVlIDwgTjYgPyA2XG4gIDogdmFsdWUgPCBONyA/IDdcbiAgOiB2YWx1ZSA8IE44ID8gOFxuICA6IHZhbHVlIDwgTjkgPyA5XG4gIDogICAgICAgICAgICAgIDEwXG4gIClcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVhZFxuXG52YXIgTVNCID0gMHg4MFxuICAsIFJFU1QgPSAweDdGXG5cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIHJlcyAgICA9IDBcbiAgICAsIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gICAgLCBzaGlmdCAgPSAwXG4gICAgLCBjb3VudGVyID0gb2Zmc2V0XG4gICAgLCBiXG4gICAgLCBsID0gYnVmLmxlbmd0aFxuXG4gIGRvIHtcbiAgICBpZiAoY291bnRlciA+PSBsIHx8IHNoaWZ0ID4gNDkpIHtcbiAgICAgIHJlYWQuYnl0ZXMgPSAwXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ291bGQgbm90IGRlY29kZSB2YXJpbnQnKVxuICAgIH1cbiAgICBiID0gYnVmW2NvdW50ZXIrK11cbiAgICByZXMgKz0gc2hpZnQgPCAyOFxuICAgICAgPyAoYiAmIFJFU1QpIDw8IHNoaWZ0XG4gICAgICA6IChiICYgUkVTVCkgKiBNYXRoLnBvdygyLCBzaGlmdClcbiAgICBzaGlmdCArPSA3XG4gIH0gd2hpbGUgKGIgPj0gTVNCKVxuXG4gIHJlYWQuYnl0ZXMgPSBjb3VudGVyIC0gb2Zmc2V0XG5cbiAgcmV0dXJuIHJlc1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgbmFtZXMgfSA9IHJlcXVpcmUoJ211bHRpYmFzZS9zcmMvY29uc3RhbnRzJylcbmNvbnN0IHsgVGV4dEVuY29kZXIgfSA9IHJlcXVpcmUoJ3dlYi1lbmNvZGluZycpXG5jb25zdCB1dGY4RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG5cbi8qKlxuICogSW50ZXJwZXJldHMgZWFjaCBjaGFyYWN0ZXIgaW4gYSBzdHJpbmcgYXMgYSBieXRlIGFuZFxuICogcmV0dXJucyBhIFVpbnQ4QXJyYXkgb2YgdGhvc2UgYnl0ZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHR1cm4gaW50byBhbiBhcnJheVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGFzY2lpU3RyaW5nVG9VaW50OEFycmF5IChzdHJpbmcpIHtcbiAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShzdHJpbmcubGVuZ3RoKVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXlbaV0gPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuICB9XG5cbiAgcmV0dXJuIGFycmF5XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFVpbnQ4QXJyYXlgIGZyb20gdGhlIHBhc3NlZCBzdHJpbmdcbiAqXG4gKiBTdXBwb3J0cyBgdXRmOGAsIGB1dGYtOGAgYW5kIGFueSBlbmNvZGluZyBzdXBwb3J0ZWQgYnkgdGhlIG11bHRpYmFzZSBtb2R1bGUuXG4gKlxuICogQWxzbyBgYXNjaWlgIHdoaWNoIGlzIHNpbWlsYXIgdG8gbm9kZSdzICdiaW5hcnknIGVuY29kaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZW5jb2Rpbmc9dXRmOF0gdXRmOCwgYmFzZTE2LCBiYXNlNjQsIGJhc2U2NHVybHBhZCwgZXRjXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL211bHRpYmFzZXxtdWx0aWJhc2V9IGZvciBzdXBwb3J0ZWQgZW5jb2RpbmdzIG90aGVyIHRoYW4gYHV0ZjhgXG4gKi9cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgaWYgKGVuY29kaW5nID09PSAndXRmOCcgfHwgZW5jb2RpbmcgPT09ICd1dGYtOCcpIHtcbiAgICByZXR1cm4gdXRmOEVuY29kZXIuZW5jb2RlKHN0cmluZylcbiAgfVxuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2FzY2lpJykge1xuICAgIHJldHVybiBhc2NpaVN0cmluZ1RvVWludDhBcnJheShzdHJpbmcpXG4gIH1cblxuICBjb25zdCBjb2RlYyA9IG5hbWVzW2VuY29kaW5nXVxuXG4gIGlmICghY29kZWMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gYmFzZScpXG4gIH1cblxuICByZXR1cm4gY29kZWMuZGVjb2RlKHN0cmluZylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmcm9tU3RyaW5nXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBuYW1lcyB9ID0gcmVxdWlyZSgnbXVsdGliYXNlL3NyYy9jb25zdGFudHMnKVxuY29uc3QgeyBUZXh0RGVjb2RlciB9ID0gcmVxdWlyZSgnd2ViLWVuY29kaW5nJylcbmNvbnN0IHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGY4JylcblxuLyoqXG4gKiBUdXJucyBhIFVpbnQ4QXJyYXkgb2YgYnl0ZXMgaW50byBhIHN0cmluZyB3aXRoIGVhY2hcbiAqIGNoYXJhY3RlciBiZWluZyB0aGUgY2hhciBjb2RlIG9mIHRoZSBjb3JyZXNwb25kaW5nIGJ5dGVcbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byB0dXJuIGludG8gYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHVpbnQ4QXJyYXlUb0FzY2lpU3RyaW5nIChhcnJheSkge1xuICBsZXQgc3RyaW5nID0gJydcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pXG4gIH1cbiAgcmV0dXJuIHN0cmluZ1xufVxuXG4vKipcbiAqIFR1cm5zIGEgYFVpbnQ4QXJyYXlgIGludG8gYSBzdHJpbmcuXG4gKlxuICogU3VwcG9ydHMgYHV0ZjhgLCBgdXRmLThgIGFuZCBhbnkgZW5jb2Rpbmcgc3VwcG9ydGVkIGJ5IHRoZSBtdWx0aWJhc2UgbW9kdWxlLlxuICpcbiAqIEFsc28gYGFzY2lpYCB3aGljaCBpcyBzaW1pbGFyIHRvIG5vZGUncyAnYmluYXJ5JyBlbmNvZGluZy5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byB0dXJuIGludG8gYSBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZW5jb2Rpbmc9dXRmOF0gVGhlIGVuY29kaW5nIHRvIHVzZVxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL211bHRpYmFzZXxtdWx0aWJhc2V9IGZvciBzdXBwb3J0ZWQgZW5jb2RpbmdzIG90aGVyIHRoYW4gYHV0ZjhgXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nIChhcnJheSwgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgaWYgKGVuY29kaW5nID09PSAndXRmOCcgfHwgZW5jb2RpbmcgPT09ICd1dGYtOCcpIHtcbiAgICByZXR1cm4gdXRmOERlY29kZXIuZGVjb2RlKGFycmF5KVxuICB9XG5cbiAgaWYgKGVuY29kaW5nID09PSAnYXNjaWknKSB7XG4gICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0FzY2lpU3RyaW5nKGFycmF5KVxuICB9XG5cbiAgY29uc3QgY29kZWMgPSBuYW1lc1tlbmNvZGluZ11cblxuICBpZiAoIWNvZGVjKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGJhc2UnKVxuICB9XG5cbiAgcmV0dXJuIGNvZGVjLmVuY29kZShhcnJheSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZ1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgV0hJVEVMSVNUID0gW1xuXHQnRVRJTUVET1VUJyxcblx0J0VDT05OUkVTRVQnLFxuXHQnRUFERFJJTlVTRScsXG5cdCdFU09DS0VUVElNRURPVVQnLFxuXHQnRUNPTk5SRUZVU0VEJyxcblx0J0VQSVBFJyxcblx0J0VIT1NUVU5SRUFDSCcsXG5cdCdFQUlfQUdBSU4nXG5dO1xuXG52YXIgQkxBQ0tMSVNUID0gW1xuXHQnRU5PVEZPVU5EJyxcblx0J0VORVRVTlJFQUNIJyxcblxuXHQvLyBTU0wgZXJyb3JzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvZWQzZDhiMTNlZTlhNzA1ZDg5ZjllMDM5N2Q5ZTk2NTE5ZTdlNDdhYy9zcmMvbm9kZV9jcnlwdG8uY2MjTDE5NTBcblx0J1VOQUJMRV9UT19HRVRfSVNTVUVSX0NFUlQnLFxuXHQnVU5BQkxFX1RPX0dFVF9DUkwnLFxuXHQnVU5BQkxFX1RPX0RFQ1JZUFRfQ0VSVF9TSUdOQVRVUkUnLFxuXHQnVU5BQkxFX1RPX0RFQ1JZUFRfQ1JMX1NJR05BVFVSRScsXG5cdCdVTkFCTEVfVE9fREVDT0RFX0lTU1VFUl9QVUJMSUNfS0VZJyxcblx0J0NFUlRfU0lHTkFUVVJFX0ZBSUxVUkUnLFxuXHQnQ1JMX1NJR05BVFVSRV9GQUlMVVJFJyxcblx0J0NFUlRfTk9UX1lFVF9WQUxJRCcsXG5cdCdDRVJUX0hBU19FWFBJUkVEJyxcblx0J0NSTF9OT1RfWUVUX1ZBTElEJyxcblx0J0NSTF9IQVNfRVhQSVJFRCcsXG5cdCdFUlJPUl9JTl9DRVJUX05PVF9CRUZPUkVfRklFTEQnLFxuXHQnRVJST1JfSU5fQ0VSVF9OT1RfQUZURVJfRklFTEQnLFxuXHQnRVJST1JfSU5fQ1JMX0xBU1RfVVBEQVRFX0ZJRUxEJyxcblx0J0VSUk9SX0lOX0NSTF9ORVhUX1VQREFURV9GSUVMRCcsXG5cdCdPVVRfT0ZfTUVNJyxcblx0J0RFUFRIX1pFUk9fU0VMRl9TSUdORURfQ0VSVCcsXG5cdCdTRUxGX1NJR05FRF9DRVJUX0lOX0NIQUlOJyxcblx0J1VOQUJMRV9UT19HRVRfSVNTVUVSX0NFUlRfTE9DQUxMWScsXG5cdCdVTkFCTEVfVE9fVkVSSUZZX0xFQUZfU0lHTkFUVVJFJyxcblx0J0NFUlRfQ0hBSU5fVE9PX0xPTkcnLFxuXHQnQ0VSVF9SRVZPS0VEJyxcblx0J0lOVkFMSURfQ0EnLFxuXHQnUEFUSF9MRU5HVEhfRVhDRUVERUQnLFxuXHQnSU5WQUxJRF9QVVJQT1NFJyxcblx0J0NFUlRfVU5UUlVTVEVEJyxcblx0J0NFUlRfUkVKRUNURUQnXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlcnIpIHtcblx0aWYgKCFlcnIgfHwgIWVyci5jb2RlKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoV0hJVEVMSVNULmluZGV4T2YoZXJyLmNvZGUpICE9PSAtMSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKEJMQUNLTElTVC5pbmRleE9mKGVyci5jb2RlKSAhPT0gLTEpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3NcbiAqXG4gKiBAcGFyYW0geyp9IHBheWxvYWQgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvcywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBeGlvc0Vycm9yKHBheWxvYWQpIHtcbiAgcmV0dXJuICh0eXBlb2YgcGF5bG9hZCA9PT0gJ29iamVjdCcpICYmIChwYXlsb2FkLmlzQXhpb3NFcnJvciA9PT0gdHJ1ZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWwpIHtcbiAgcmV0dXJuICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnKSAmJiAodmFsIGluc3RhbmNlb2YgRm9ybURhdGEpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKHZhbCkgJiYgKHZhbC5idWZmZXIpICYmICh2YWwuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWwpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqIG5hdGl2ZXNjcmlwdFxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdOYXRpdmVTY3JpcHQnIG9yICdOUydcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAobmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05hdGl2ZVNjcmlwdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05TJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXG4gKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxuICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoLyogb2JqMSwgb2JqMiwgb2JqMywgLi4uICovKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChyZXN1bHRba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHt9LCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogUmVtb3ZlIGJ5dGUgb3JkZXIgbWFya2VyLiBUaGlzIGNhdGNoZXMgRUYgQkIgQkYgKHRoZSBVVEYtOCBCT00pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgd2l0aCBCT01cbiAqIEByZXR1cm4ge3N0cmluZ30gY29udGVudCB2YWx1ZSB3aXRob3V0IEJPTVxuICovXG5mdW5jdGlvbiBzdHJpcEJPTShjb250ZW50KSB7XG4gIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBjb250ZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcbiAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhOiBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldzogaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRmlsZTogaXNGaWxlLFxuICBpc0Jsb2I6IGlzQmxvYixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNTdHJlYW06IGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtczogaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzU3RhbmRhcmRCcm93c2VyRW52OiBpc1N0YW5kYXJkQnJvd3NlckVudixcbiAgZm9yRWFjaDogZm9yRWFjaCxcbiAgbWVyZ2U6IG1lcmdlLFxuICBleHRlbmQ6IGV4dGVuZCxcbiAgdHJpbTogdHJpbSxcbiAgc3RyaXBCT006IHN0cmlwQk9NXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcbiAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcbiAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBvYmplY3QgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyBjb25maWcyIHRvIGNvbmZpZzFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcxLCBjb25maWcyKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBjb25maWcyID0gY29uZmlnMiB8fCB7fTtcbiAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gIHZhciB2YWx1ZUZyb21Db25maWcyS2V5cyA9IFsndXJsJywgJ21ldGhvZCcsICdkYXRhJ107XG4gIHZhciBtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cyA9IFsnaGVhZGVycycsICdhdXRoJywgJ3Byb3h5JywgJ3BhcmFtcyddO1xuICB2YXIgZGVmYXVsdFRvQ29uZmlnMktleXMgPSBbXG4gICAgJ2Jhc2VVUkwnLCAndHJhbnNmb3JtUmVxdWVzdCcsICd0cmFuc2Zvcm1SZXNwb25zZScsICdwYXJhbXNTZXJpYWxpemVyJyxcbiAgICAndGltZW91dCcsICd0aW1lb3V0TWVzc2FnZScsICd3aXRoQ3JlZGVudGlhbHMnLCAnYWRhcHRlcicsICdyZXNwb25zZVR5cGUnLCAneHNyZkNvb2tpZU5hbWUnLFxuICAgICd4c3JmSGVhZGVyTmFtZScsICdvblVwbG9hZFByb2dyZXNzJywgJ29uRG93bmxvYWRQcm9ncmVzcycsICdkZWNvbXByZXNzJyxcbiAgICAnbWF4Q29udGVudExlbmd0aCcsICdtYXhCb2R5TGVuZ3RoJywgJ21heFJlZGlyZWN0cycsICd0cmFuc3BvcnQnLCAnaHR0cEFnZW50JyxcbiAgICAnaHR0cHNBZ2VudCcsICdjYW5jZWxUb2tlbicsICdzb2NrZXRQYXRoJywgJ3Jlc3BvbnNlRW5jb2RpbmcnXG4gIF07XG4gIHZhciBkaXJlY3RNZXJnZUtleXMgPSBbJ3ZhbGlkYXRlU3RhdHVzJ107XG5cbiAgZnVuY3Rpb24gZ2V0TWVyZ2VkVmFsdWUodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHRhcmdldCwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHt9LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gc291cmNlLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZURlZXBQcm9wZXJ0aWVzKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICB1dGlscy5mb3JFYWNoKHZhbHVlRnJvbUNvbmZpZzJLZXlzLCBmdW5jdGlvbiB2YWx1ZUZyb21Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cywgbWVyZ2VEZWVwUHJvcGVydGllcyk7XG5cbiAgdXRpbHMuZm9yRWFjaChkZWZhdWx0VG9Db25maWcyS2V5cywgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHV0aWxzLmZvckVhY2goZGlyZWN0TWVyZ2VLZXlzLCBmdW5jdGlvbiBtZXJnZShwcm9wKSB7XG4gICAgaWYgKHByb3AgaW4gY29uZmlnMikge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmIChwcm9wIGluIGNvbmZpZzEpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgYXhpb3NLZXlzID0gdmFsdWVGcm9tQ29uZmlnMktleXNcbiAgICAuY29uY2F0KG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzKVxuICAgIC5jb25jYXQoZGVmYXVsdFRvQ29uZmlnMktleXMpXG4gICAgLmNvbmNhdChkaXJlY3RNZXJnZUtleXMpO1xuXG4gIHZhciBvdGhlcktleXMgPSBPYmplY3RcbiAgICAua2V5cyhjb25maWcxKVxuICAgIC5jb25jYXQoT2JqZWN0LmtleXMoY29uZmlnMikpXG4gICAgLmZpbHRlcihmdW5jdGlvbiBmaWx0ZXJBeGlvc0tleXMoa2V5KSB7XG4gICAgICByZXR1cm4gYXhpb3NLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG4gICAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChvdGhlcktleXMsIG1lcmdlRGVlcFByb3BlcnRpZXMpO1xuXG4gIHJldHVybiBjb25maWc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FuY2VsID0gcmVxdWlyZSgnLi9DYW5jZWwnKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIHJlc29sdmVQcm9taXNlO1xuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vbWVyZ2VDb25maWcnKTtcbnZhciB2YWxpZGF0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ZhbGlkYXRvcicpO1xuXG52YXIgdmFsaWRhdG9ycyA9IHZhbGlkYXRvci52YWxpZGF0b3JzO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcbiAgICBjb25maWcudXJsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgfVxuXG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgLy8gU2V0IGNvbmZpZy5tZXRob2RcbiAgaWYgKGNvbmZpZy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHRoaXMuZGVmYXVsdHMubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IHRoaXMuZGVmYXVsdHMubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLm1ldGhvZCA9ICdnZXQnO1xuICB9XG5cbiAgdmFyIHRyYW5zaXRpb25hbCA9IGNvbmZpZy50cmFuc2l0aW9uYWw7XG5cbiAgaWYgKHRyYW5zaXRpb25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnModHJhbnNpdGlvbmFsLCB7XG4gICAgICBzaWxlbnRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuLCAnMS4wLjAnKSxcbiAgICAgIGZvcmNlZEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4sICcxLjAuMCcpLFxuICAgICAgY2xhcmlmeVRpbWVvdXRFcnJvcjogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuLCAnMS4wLjAnKVxuICAgIH0sIGZhbHNlKTtcbiAgfVxuXG4gIC8vIGZpbHRlciBvdXQgc2tpcHBlZCBpbnRlcmNlcHRvcnNcbiAgdmFyIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluID0gW107XG4gIHZhciBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSB0cnVlO1xuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yLnJ1bldoZW4gPT09ICdmdW5jdGlvbicgJiYgaW50ZXJjZXB0b3IucnVuV2hlbihjb25maWcpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyAmJiBpbnRlcmNlcHRvci5zeW5jaHJvbm91cztcblxuICAgIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHZhciByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdmFyIHByb21pc2U7XG5cbiAgaWYgKCFzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMpIHtcbiAgICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xuXG4gICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoY2hhaW4sIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluKTtcbiAgICBjaGFpbiA9IGNoYWluLmNvbmNhdChyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4pO1xuXG4gICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW4uc2hpZnQoKSwgY2hhaW4uc2hpZnQoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuXG4gIHZhciBuZXdDb25maWcgPSBjb25maWc7XG4gIHdoaWxlIChyZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5sZW5ndGgpIHtcbiAgICB2YXIgb25GdWxmaWxsZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpO1xuICAgIHZhciBvblJlamVjdGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKTtcbiAgICB0cnkge1xuICAgICAgbmV3Q29uZmlnID0gb25GdWxmaWxsZWQobmV3Q29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25SZWplY3RlZChlcnJvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIHByb21pc2UgPSBkaXNwYXRjaFJlcXVlc3QobmV3Q29uZmlnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9XG5cbiAgd2hpbGUgKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5sZW5ndGgpIHtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpLCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbkF4aW9zLnByb3RvdHlwZS5nZXRVcmkgPSBmdW5jdGlvbiBnZXRVcmkoY29uZmlnKSB7XG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gIHJldHVybiBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcikucmVwbGFjZSgvXlxcPy8sICcnKTtcbn07XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IChjb25maWcgfHwge30pLmRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4vaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9jb3JlL2VuaGFuY2VFcnJvcicpO1xuXG52YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XG4gIGlmICghdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiYgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pKSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0QWRhcHRlcigpIHtcbiAgdmFyIGFkYXB0ZXI7XG4gIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIGJyb3dzZXJzIHVzZSBYSFIgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL3hocicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xuICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy9odHRwJyk7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVNhZmVseShyYXdWYWx1ZSwgcGFyc2VyLCBlbmNvZGVyKSB7XG4gIGlmICh1dGlscy5pc1N0cmluZyhyYXdWYWx1ZSkpIHtcbiAgICB0cnkge1xuICAgICAgKHBhcnNlciB8fCBKU09OLnBhcnNlKShyYXdWYWx1ZSk7XG4gICAgICByZXR1cm4gdXRpbHMudHJpbShyYXdWYWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUubmFtZSAhPT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoZW5jb2RlciB8fCBKU09OLnN0cmluZ2lmeSkocmF3VmFsdWUpO1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG5cbiAgdHJhbnNpdGlvbmFsOiB7XG4gICAgc2lsZW50SlNPTlBhcnNpbmc6IHRydWUsXG4gICAgZm9yY2VkSlNPTlBhcnNpbmc6IHRydWUsXG4gICAgY2xhcmlmeVRpbWVvdXRFcnJvcjogZmFsc2VcbiAgfSxcblxuICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdBY2NlcHQnKTtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpIHx8IChoZWFkZXJzICYmIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID09PSAnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlTYWZlbHkoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICB2YXIgdHJhbnNpdGlvbmFsID0gdGhpcy50cmFuc2l0aW9uYWw7XG4gICAgdmFyIHNpbGVudEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5zaWxlbnRKU09OUGFyc2luZztcbiAgICB2YXIgZm9yY2VkSlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLmZvcmNlZEpTT05QYXJzaW5nO1xuICAgIHZhciBzdHJpY3RKU09OUGFyc2luZyA9ICFzaWxlbnRKU09OUGFyc2luZyAmJiB0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nO1xuXG4gICAgaWYgKHN0cmljdEpTT05QYXJzaW5nIHx8IChmb3JjZWRKU09OUGFyc2luZyAmJiB1dGlscy5pc1N0cmluZyhkYXRhKSAmJiBkYXRhLmxlbmd0aCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcpIHtcbiAgICAgICAgICBpZiAoZS5uYW1lID09PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBlbmhhbmNlRXJyb3IoZSwgdGhpcywgJ0VfSlNPTl9QQVJTRScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIC8qKlxuICAgKiBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGFib3J0IGEgcmVxdWVzdC4gSWYgc2V0IHRvIDAgKGRlZmF1bHQpIGFcbiAgICogdGltZW91dCBpcyBub3QgY3JlYXRlZC5cbiAgICovXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuICBtYXhCb2R5TGVuZ3RoOiAtMSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9XG59O1xuXG5kZWZhdWx0cy5oZWFkZXJzID0ge1xuICBjb21tb246IHtcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB1dGlscy5tZXJnZShERUZBVUxUX0NPTlRFTlRfVFlQRSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gVGhpcyBmaWxlIGlzIGltcG9ydGVkIGZyb20gc2VjcDI1NmsxIHYzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL3NlY3AyNTZrMS1ub2RlL2Jsb2IvbWFzdGVyL0xJQ0VOU0Vcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFQ19QUklWS0VZX0VYUE9SVF9ERVJfQ09NUFJFU1NFRCA9IEJ1ZmZlci5mcm9tKFtcbiAgICAvLyBiZWdpblxuICAgIDB4MzAsXG4gICAgMHg4MSxcbiAgICAweGQzLFxuICAgIDB4MDIsXG4gICAgMHgwMSxcbiAgICAweDAxLFxuICAgIDB4MDQsXG4gICAgMHgyMCxcbiAgICAvLyBwcml2YXRlIGtleVxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAvLyBtaWRkbGVcbiAgICAweGEwLFxuICAgIDB4ODEsXG4gICAgMHg4NSxcbiAgICAweDMwLFxuICAgIDB4ODEsXG4gICAgMHg4MixcbiAgICAweDAyLFxuICAgIDB4MDEsXG4gICAgMHgwMSxcbiAgICAweDMwLFxuICAgIDB4MmMsXG4gICAgMHgwNixcbiAgICAweDA3LFxuICAgIDB4MmEsXG4gICAgMHg4NixcbiAgICAweDQ4LFxuICAgIDB4Y2UsXG4gICAgMHgzZCxcbiAgICAweDAxLFxuICAgIDB4MDEsXG4gICAgMHgwMixcbiAgICAweDIxLFxuICAgIDB4MDAsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZSxcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmYyxcbiAgICAweDJmLFxuICAgIDB4MzAsXG4gICAgMHgwNixcbiAgICAweDA0LFxuICAgIDB4MDEsXG4gICAgMHgwMCxcbiAgICAweDA0LFxuICAgIDB4MDEsXG4gICAgMHgwNyxcbiAgICAweDA0LFxuICAgIDB4MjEsXG4gICAgMHgwMixcbiAgICAweDc5LFxuICAgIDB4YmUsXG4gICAgMHg2NixcbiAgICAweDdlLFxuICAgIDB4ZjksXG4gICAgMHhkYyxcbiAgICAweGJiLFxuICAgIDB4YWMsXG4gICAgMHg1NSxcbiAgICAweGEwLFxuICAgIDB4NjIsXG4gICAgMHg5NSxcbiAgICAweGNlLFxuICAgIDB4ODcsXG4gICAgMHgwYixcbiAgICAweDA3LFxuICAgIDB4MDIsXG4gICAgMHg5YixcbiAgICAweGZjLFxuICAgIDB4ZGIsXG4gICAgMHgyZCxcbiAgICAweGNlLFxuICAgIDB4MjgsXG4gICAgMHhkOSxcbiAgICAweDU5LFxuICAgIDB4ZjIsXG4gICAgMHg4MSxcbiAgICAweDViLFxuICAgIDB4MTYsXG4gICAgMHhmOCxcbiAgICAweDE3LFxuICAgIDB4OTgsXG4gICAgMHgwMixcbiAgICAweDIxLFxuICAgIDB4MDAsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZSxcbiAgICAweGJhLFxuICAgIDB4YWUsXG4gICAgMHhkYyxcbiAgICAweGU2LFxuICAgIDB4YWYsXG4gICAgMHg0OCxcbiAgICAweGEwLFxuICAgIDB4M2IsXG4gICAgMHhiZixcbiAgICAweGQyLFxuICAgIDB4NWUsXG4gICAgMHg4YyxcbiAgICAweGQwLFxuICAgIDB4MzYsXG4gICAgMHg0MSxcbiAgICAweDQxLFxuICAgIDB4MDIsXG4gICAgMHgwMSxcbiAgICAweDAxLFxuICAgIDB4YTEsXG4gICAgMHgyNCxcbiAgICAweDAzLFxuICAgIDB4MjIsXG4gICAgMHgwMCxcbiAgICAvLyBwdWJsaWMga2V5XG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG5dKTtcbnZhciBFQ19QUklWS0VZX0VYUE9SVF9ERVJfVU5DT01QUkVTU0VEID0gQnVmZmVyLmZyb20oW1xuICAgIC8vIGJlZ2luXG4gICAgMHgzMCxcbiAgICAweDgyLFxuICAgIDB4MDEsXG4gICAgMHgxMyxcbiAgICAweDAyLFxuICAgIDB4MDEsXG4gICAgMHgwMSxcbiAgICAweDA0LFxuICAgIDB4MjAsXG4gICAgLy8gcHJpdmF0ZSBrZXlcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgLy8gbWlkZGxlXG4gICAgMHhhMCxcbiAgICAweDgxLFxuICAgIDB4YTUsXG4gICAgMHgzMCxcbiAgICAweDgxLFxuICAgIDB4YTIsXG4gICAgMHgwMixcbiAgICAweDAxLFxuICAgIDB4MDEsXG4gICAgMHgzMCxcbiAgICAweDJjLFxuICAgIDB4MDYsXG4gICAgMHgwNyxcbiAgICAweDJhLFxuICAgIDB4ODYsXG4gICAgMHg0OCxcbiAgICAweGNlLFxuICAgIDB4M2QsXG4gICAgMHgwMSxcbiAgICAweDAxLFxuICAgIDB4MDIsXG4gICAgMHgyMSxcbiAgICAweDAwLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmUsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmMsXG4gICAgMHgyZixcbiAgICAweDMwLFxuICAgIDB4MDYsXG4gICAgMHgwNCxcbiAgICAweDAxLFxuICAgIDB4MDAsXG4gICAgMHgwNCxcbiAgICAweDAxLFxuICAgIDB4MDcsXG4gICAgMHgwNCxcbiAgICAweDQxLFxuICAgIDB4MDQsXG4gICAgMHg3OSxcbiAgICAweGJlLFxuICAgIDB4NjYsXG4gICAgMHg3ZSxcbiAgICAweGY5LFxuICAgIDB4ZGMsXG4gICAgMHhiYixcbiAgICAweGFjLFxuICAgIDB4NTUsXG4gICAgMHhhMCxcbiAgICAweDYyLFxuICAgIDB4OTUsXG4gICAgMHhjZSxcbiAgICAweDg3LFxuICAgIDB4MGIsXG4gICAgMHgwNyxcbiAgICAweDAyLFxuICAgIDB4OWIsXG4gICAgMHhmYyxcbiAgICAweGRiLFxuICAgIDB4MmQsXG4gICAgMHhjZSxcbiAgICAweDI4LFxuICAgIDB4ZDksXG4gICAgMHg1OSxcbiAgICAweGYyLFxuICAgIDB4ODEsXG4gICAgMHg1YixcbiAgICAweDE2LFxuICAgIDB4ZjgsXG4gICAgMHgxNyxcbiAgICAweDk4LFxuICAgIDB4NDgsXG4gICAgMHgzYSxcbiAgICAweGRhLFxuICAgIDB4NzcsXG4gICAgMHgyNixcbiAgICAweGEzLFxuICAgIDB4YzQsXG4gICAgMHg2NSxcbiAgICAweDVkLFxuICAgIDB4YTQsXG4gICAgMHhmYixcbiAgICAweGZjLFxuICAgIDB4MGUsXG4gICAgMHgxMSxcbiAgICAweDA4LFxuICAgIDB4YTgsXG4gICAgMHhmZCxcbiAgICAweDE3LFxuICAgIDB4YjQsXG4gICAgMHg0OCxcbiAgICAweGE2LFxuICAgIDB4ODUsXG4gICAgMHg1NCxcbiAgICAweDE5LFxuICAgIDB4OWMsXG4gICAgMHg0NyxcbiAgICAweGQwLFxuICAgIDB4OGYsXG4gICAgMHhmYixcbiAgICAweDEwLFxuICAgIDB4ZDQsXG4gICAgMHhiOCxcbiAgICAweDAyLFxuICAgIDB4MjEsXG4gICAgMHgwMCxcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZlLFxuICAgIDB4YmEsXG4gICAgMHhhZSxcbiAgICAweGRjLFxuICAgIDB4ZTYsXG4gICAgMHhhZixcbiAgICAweDQ4LFxuICAgIDB4YTAsXG4gICAgMHgzYixcbiAgICAweGJmLFxuICAgIDB4ZDIsXG4gICAgMHg1ZSxcbiAgICAweDhjLFxuICAgIDB4ZDAsXG4gICAgMHgzNixcbiAgICAweDQxLFxuICAgIDB4NDEsXG4gICAgMHgwMixcbiAgICAweDAxLFxuICAgIDB4MDEsXG4gICAgMHhhMSxcbiAgICAweDQ0LFxuICAgIDB4MDMsXG4gICAgMHg0MixcbiAgICAweDAwLFxuICAgIC8vIHB1YmxpYyBrZXlcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG5dKTtcbmV4cG9ydHMucHJpdmF0ZUtleUV4cG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBwdWJsaWNLZXksIGNvbXByZXNzZWQpIHtcbiAgICBpZiAoY29tcHJlc3NlZCA9PT0gdm9pZCAwKSB7IGNvbXByZXNzZWQgPSB0cnVlOyB9XG4gICAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5mcm9tKGNvbXByZXNzZWQgPyBFQ19QUklWS0VZX0VYUE9SVF9ERVJfQ09NUFJFU1NFRCA6IEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9VTkNPTVBSRVNTRUQpO1xuICAgIHByaXZhdGVLZXkuY29weShyZXN1bHQsIGNvbXByZXNzZWQgPyA4IDogOSk7XG4gICAgcHVibGljS2V5LmNvcHkocmVzdWx0LCBjb21wcmVzc2VkID8gMTgxIDogMjE0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMucHJpdmF0ZUtleUltcG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgdmFyIGxlbmd0aCA9IHByaXZhdGVLZXkubGVuZ3RoO1xuICAgIC8vIHNlcXVlbmNlIGhlYWRlclxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMSB8fCBwcml2YXRlS2V5W2luZGV4XSAhPT0gMHgzMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaW5kZXggKz0gMTtcbiAgICAvLyBzZXF1ZW5jZSBsZW5ndGggY29uc3RydWN0b3JcbiAgICBpZiAobGVuZ3RoIDwgaW5kZXggKyAxIHx8ICEocHJpdmF0ZUtleVtpbmRleF0gJiAweDgwKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgdmFyIGxlbmIgPSBwcml2YXRlS2V5W2luZGV4XSAmIDB4N2Y7XG4gICAgaW5kZXggKz0gMTtcbiAgICBpZiAobGVuYiA8IDEgfHwgbGVuYiA+IDIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChsZW5ndGggPCBpbmRleCArIGxlbmIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIHNlcXVlbmNlIGxlbmd0aFxuICAgIHZhciBsZW4gPSBwcml2YXRlS2V5W2luZGV4ICsgbGVuYiAtIDFdIHwgKGxlbmIgPiAxID8gcHJpdmF0ZUtleVtpbmRleCArIGxlbmIgLSAyXSA8PCA4IDogMCk7XG4gICAgaW5kZXggKz0gbGVuYjtcbiAgICBpZiAobGVuZ3RoIDwgaW5kZXggKyBsZW4pXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIHNlcXVlbmNlIGVsZW1lbnQgMDogdmVyc2lvbiBudW1iZXIgKD0xKVxuICAgIGlmIChsZW5ndGggPCBpbmRleCArIDMgfHxcbiAgICAgICAgcHJpdmF0ZUtleVtpbmRleF0gIT09IDB4MDIgfHxcbiAgICAgICAgcHJpdmF0ZUtleVtpbmRleCArIDFdICE9PSAweDAxIHx8XG4gICAgICAgIHByaXZhdGVLZXlbaW5kZXggKyAyXSAhPT0gMHgwMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaW5kZXggKz0gMztcbiAgICAvLyBzZXF1ZW5jZSBlbGVtZW50IDE6IG9jdGV0IHN0cmluZywgdXAgdG8gMzIgYnl0ZXNcbiAgICBpZiAobGVuZ3RoIDwgaW5kZXggKyAyIHx8XG4gICAgICAgIHByaXZhdGVLZXlbaW5kZXhdICE9PSAweDA0IHx8XG4gICAgICAgIHByaXZhdGVLZXlbaW5kZXggKyAxXSA+IDB4MjAgfHxcbiAgICAgICAgbGVuZ3RoIDwgaW5kZXggKyAyICsgcHJpdmF0ZUtleVtpbmRleCArIDFdKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcHJpdmF0ZUtleS5zbGljZShpbmRleCArIDIsIGluZGV4ICsgMiArIHByaXZhdGVLZXlbaW5kZXggKyAxXSk7XG59O1xuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnRMYXggPSBmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG4gICAgdmFyIHIgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuICAgIHZhciBzID0gQnVmZmVyLmFsbG9jKDMyLCAwKTtcbiAgICB2YXIgbGVuZ3RoID0gc2lnbmF0dXJlLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIC8vIHNlcXVlbmNlIHRhZyBieXRlXG4gICAgaWYgKHNpZ25hdHVyZVtpbmRleCsrXSAhPT0gMHgzMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gc2VxdWVuY2UgbGVuZ3RoIGJ5dGVcbiAgICB2YXIgbGVuYnl0ZSA9IHNpZ25hdHVyZVtpbmRleCsrXTtcbiAgICBpZiAobGVuYnl0ZSAmIDB4ODApIHtcbiAgICAgICAgaW5kZXggKz0gbGVuYnl0ZSAtIDB4ODA7XG4gICAgICAgIGlmIChpbmRleCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc2VxdWVuY2UgdGFnIGJ5dGUgZm9yIHJcbiAgICBpZiAoc2lnbmF0dXJlW2luZGV4KytdICE9PSAweDAyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBsZW5ndGggZm9yIHJcbiAgICB2YXIgcmxlbiA9IHNpZ25hdHVyZVtpbmRleCsrXTtcbiAgICBpZiAocmxlbiAmIDB4ODApIHtcbiAgICAgICAgbGVuYnl0ZSA9IHJsZW4gLSAweDgwO1xuICAgICAgICBpZiAoaW5kZXggKyBsZW5ieXRlID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgbGVuYnl0ZSA+IDAgJiYgc2lnbmF0dXJlW2luZGV4XSA9PT0gMHgwMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKVxuICAgICAgICAgICAgO1xuICAgICAgICBmb3IgKHJsZW4gPSAwOyBsZW5ieXRlID4gMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKVxuICAgICAgICAgICAgcmxlbiA9IChybGVuIDw8IDgpICsgc2lnbmF0dXJlW2luZGV4XTtcbiAgICB9XG4gICAgaWYgKHJsZW4gPiBsZW5ndGggLSBpbmRleCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHJpbmRleCA9IGluZGV4O1xuICAgIGluZGV4ICs9IHJsZW47XG4gICAgLy8gc2VxdWVuY2UgdGFnIGJ5dGUgZm9yIHNcbiAgICBpZiAoc2lnbmF0dXJlW2luZGV4KytdICE9PSAweDAyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBsZW5ndGggZm9yIHNcbiAgICB2YXIgc2xlbiA9IHNpZ25hdHVyZVtpbmRleCsrXTtcbiAgICBpZiAoc2xlbiAmIDB4ODApIHtcbiAgICAgICAgbGVuYnl0ZSA9IHNsZW4gLSAweDgwO1xuICAgICAgICBpZiAoaW5kZXggKyBsZW5ieXRlID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgbGVuYnl0ZSA+IDAgJiYgc2lnbmF0dXJlW2luZGV4XSA9PT0gMHgwMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKVxuICAgICAgICAgICAgO1xuICAgICAgICBmb3IgKHNsZW4gPSAwOyBsZW5ieXRlID4gMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKVxuICAgICAgICAgICAgc2xlbiA9IChzbGVuIDw8IDgpICsgc2lnbmF0dXJlW2luZGV4XTtcbiAgICB9XG4gICAgaWYgKHNsZW4gPiBsZW5ndGggLSBpbmRleCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHNpbmRleCA9IGluZGV4O1xuICAgIGluZGV4ICs9IHNsZW47XG4gICAgLy8gaWdub3JlIGxlYWRpbmcgemVyb3MgaW4gclxuICAgIGZvciAoOyBybGVuID4gMCAmJiBzaWduYXR1cmVbcmluZGV4XSA9PT0gMHgwMDsgcmxlbiAtPSAxLCByaW5kZXggKz0gMSlcbiAgICAgICAgO1xuICAgIC8vIGNvcHkgciB2YWx1ZVxuICAgIGlmIChybGVuID4gMzIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBydmFsdWUgPSBzaWduYXR1cmUuc2xpY2UocmluZGV4LCByaW5kZXggKyBybGVuKTtcbiAgICBydmFsdWUuY29weShyLCAzMiAtIHJ2YWx1ZS5sZW5ndGgpO1xuICAgIC8vIGlnbm9yZSBsZWFkaW5nIHplcm9zIGluIHNcbiAgICBmb3IgKDsgc2xlbiA+IDAgJiYgc2lnbmF0dXJlW3NpbmRleF0gPT09IDB4MDA7IHNsZW4gLT0gMSwgc2luZGV4ICs9IDEpXG4gICAgICAgIDtcbiAgICAvLyBjb3B5IHMgdmFsdWVcbiAgICBpZiAoc2xlbiA+IDMyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgc3ZhbHVlID0gc2lnbmF0dXJlLnNsaWNlKHNpbmRleCwgc2luZGV4ICsgc2xlbik7XG4gICAgc3ZhbHVlLmNvcHkocywgMzIgLSBzdmFsdWUubGVuZ3RoKTtcbiAgICByZXR1cm4geyByOiByLCBzOiBzIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8gVGhpcyBmaWxlIGlzIGltcG9ydGVkIGZyb20gc2VjcDI1NmsxIHYzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL3NlY3AyNTZrMS1ub2RlL2Jsb2IvbWFzdGVyL0xJQ0VOU0Vcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCTiA9IHJlcXVpcmUoXCJibi5qc1wiKTtcbnZhciBFQyA9IHJlcXVpcmUoJ2VsbGlwdGljJykuZWM7XG52YXIgZWMgPSBuZXcgRUMoJ3NlY3AyNTZrMScpO1xudmFyIGVjcGFyYW1zID0gZWMuY3VydmU7XG5leHBvcnRzLnByaXZhdGVLZXlFeHBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICAgIGlmIChjb21wcmVzc2VkID09PSB2b2lkIDApIHsgY29tcHJlc3NlZCA9IHRydWU7IH1cbiAgICB2YXIgZCA9IG5ldyBCTihwcml2YXRlS2V5KTtcbiAgICBpZiAoZC51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY291bGRuJ3QgZXhwb3J0IHRvIERFUiBmb3JtYXRcIik7XG4gICAgfVxuICAgIHZhciBwb2ludCA9IGVjLmcubXVsKGQpO1xuICAgIHJldHVybiB0b1B1YmxpY0tleShwb2ludC5nZXRYKCksIHBvaW50LmdldFkoKSwgY29tcHJlc3NlZCk7XG59O1xuZXhwb3J0cy5wcml2YXRlS2V5TW9kSW52ZXJzZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgdmFyIGJuID0gbmV3IEJOKHByaXZhdGVLZXkpO1xuICAgIGlmIChibi51Y21wKGVjcGFyYW1zLm4pID49IDAgfHwgYm4uaXNaZXJvKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcml2YXRlIGtleSByYW5nZSBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICAgIHJldHVybiBibi5pbnZtKGVjcGFyYW1zLm4pLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpO1xufTtcbmV4cG9ydHMuc2lnbmF0dXJlSW1wb3J0ID0gZnVuY3Rpb24gKHNpZ09iaikge1xuICAgIHZhciByID0gbmV3IEJOKHNpZ09iai5yKTtcbiAgICBpZiAoci51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICAgICAgciA9IG5ldyBCTigwKTtcbiAgICB9XG4gICAgdmFyIHMgPSBuZXcgQk4oc2lnT2JqLnMpO1xuICAgIGlmIChzLnVjbXAoZWNwYXJhbXMubikgPj0gMCkge1xuICAgICAgICBzID0gbmV3IEJOKDApO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbci50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKSwgcy50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKV0pO1xufTtcbmV4cG9ydHMuZWNkaFVuc2FmZSA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgICBpZiAoY29tcHJlc3NlZCA9PT0gdm9pZCAwKSB7IGNvbXByZXNzZWQgPSB0cnVlOyB9XG4gICAgdmFyIHBvaW50ID0gZWMua2V5RnJvbVB1YmxpYyhwdWJsaWNLZXkpO1xuICAgIHZhciBzY2FsYXIgPSBuZXcgQk4ocHJpdmF0ZUtleSk7XG4gICAgaWYgKHNjYWxhci51Y21wKGVjcGFyYW1zLm4pID49IDAgfHwgc2NhbGFyLmlzWmVybygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2NhbGFyIHdhcyBpbnZhbGlkICh6ZXJvIG9yIG92ZXJmbG93KScpO1xuICAgIH1cbiAgICB2YXIgc2hhcmVkID0gcG9pbnQucHViLm11bChzY2FsYXIpO1xuICAgIHJldHVybiB0b1B1YmxpY0tleShzaGFyZWQuZ2V0WCgpLCBzaGFyZWQuZ2V0WSgpLCBjb21wcmVzc2VkKTtcbn07XG52YXIgdG9QdWJsaWNLZXkgPSBmdW5jdGlvbiAoeCwgeSwgY29tcHJlc3NlZCkge1xuICAgIHZhciBwdWJsaWNLZXk7XG4gICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgcHVibGljS2V5ID0gQnVmZmVyLmFsbG9jKDMzKTtcbiAgICAgICAgcHVibGljS2V5WzBdID0geS5pc09kZCgpID8gMHgwMyA6IDB4MDI7XG4gICAgICAgIHgudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMikuY29weShwdWJsaWNLZXksIDEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHVibGljS2V5ID0gQnVmZmVyLmFsbG9jKDY1KTtcbiAgICAgICAgcHVibGljS2V5WzBdID0gMHgwNDtcbiAgICAgICAgeC50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKS5jb3B5KHB1YmxpY0tleSwgMSk7XG4gICAgICAgIHkudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMikuY29weShwdWJsaWNLZXksIDMzKTtcbiAgICB9XG4gICAgcmV0dXJuIHB1YmxpY0tleTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9sbGluZ0Jsb2NrVHJhY2tlciA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX3JhbmRvbV9pZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJqc29uLXJwYy1yYW5kb20taWRcIikpO1xuY29uc3QgcGlmeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwaWZ5XCIpKTtcbmNvbnN0IEJhc2VCbG9ja1RyYWNrZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VCbG9ja1RyYWNrZXJcIik7XG5jb25zdCBjcmVhdGVSYW5kb21JZCA9IGpzb25fcnBjX3JhbmRvbV9pZF8xLmRlZmF1bHQoKTtcbmNvbnN0IHNlYyA9IDEwMDA7XG5jbGFzcyBQb2xsaW5nQmxvY2tUcmFja2VyIGV4dGVuZHMgQmFzZUJsb2NrVHJhY2tlcl8xLkJhc2VCbG9ja1RyYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgICAgICAvLyBwYXJzZSArIHZhbGlkYXRlIGFyZ3NcbiAgICAgICAgaWYgKCFvcHRzLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvbGxpbmdCbG9ja1RyYWNrZXIgLSBubyBwcm92aWRlciBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgYmxvY2tSZXNldER1cmF0aW9uOiBvcHRzLnBvbGxpbmdJbnRlcnZhbCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNvbmZpZ1xuICAgICAgICB0aGlzLl9wcm92aWRlciA9IG9wdHMucHJvdmlkZXI7XG4gICAgICAgIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCA9IG9wdHMucG9sbGluZ0ludGVydmFsIHx8IDIwICogc2VjO1xuICAgICAgICB0aGlzLl9yZXRyeVRpbWVvdXQgPSBvcHRzLnJldHJ5VGltZW91dCB8fCB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgLyAxMDtcbiAgICAgICAgdGhpcy5fa2VlcEV2ZW50TG9vcEFjdGl2ZSA9IG9wdHMua2VlcEV2ZW50TG9vcEFjdGl2ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdHMua2VlcEV2ZW50TG9vcEFjdGl2ZTtcbiAgICAgICAgdGhpcy5fc2V0U2tpcENhY2hlRmxhZyA9IG9wdHMuc2V0U2tpcENhY2hlRmxhZyB8fCBmYWxzZTtcbiAgICB9XG4gICAgLy8gdHJpZ2dlciBibG9jayBwb2xsaW5nXG4gICAgYXN5bmMgY2hlY2tGb3JMYXRlc3RCbG9jaygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlTGF0ZXN0QmxvY2soKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0TGF0ZXN0QmxvY2soKTtcbiAgICB9XG4gICAgX3N0YXJ0KCkge1xuICAgICAgICB0aGlzLl9zeW5jaHJvbml6ZSgpLmNhdGNoKChlcnIpID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpKTtcbiAgICB9XG4gICAgYXN5bmMgX3N5bmNocm9uaXplKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZUxhdGVzdEJsb2NrKCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGltZW91dCh0aGlzLl9wb2xsaW5nSW50ZXJ2YWwsICF0aGlzLl9rZWVwRXZlbnRMb29wQWN0aXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFcnIgPSBuZXcgRXJyb3IoYFBvbGxpbmdCbG9ja1RyYWNrZXIgLSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBhdHRlbXB0aW5nIHRvIHVwZGF0ZSBsYXRlc3QgYmxvY2s6XFxuJHtlcnIuc3RhY2t9YCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ld0Vycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlbWl0RXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobmV3RXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGltZW91dCh0aGlzLl9yZXRyeVRpbWVvdXQsICF0aGlzLl9rZWVwRXZlbnRMb29wQWN0aXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfdXBkYXRlTGF0ZXN0QmxvY2soKSB7XG4gICAgICAgIC8vIGZldGNoICsgc2V0IGxhdGVzdCBibG9ja1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9jayA9IGF3YWl0IHRoaXMuX2ZldGNoTGF0ZXN0QmxvY2soKTtcbiAgICAgICAgdGhpcy5fbmV3UG90ZW50aWFsTGF0ZXN0KGxhdGVzdEJsb2NrKTtcbiAgICB9XG4gICAgYXN5bmMgX2ZldGNoTGF0ZXN0QmxvY2soKSB7XG4gICAgICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgaWQ6IGNyZWF0ZVJhbmRvbUlkKCksXG4gICAgICAgICAgICBtZXRob2Q6ICdldGhfYmxvY2tOdW1iZXInLFxuICAgICAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX3NldFNraXBDYWNoZUZsYWcpIHtcbiAgICAgICAgICAgIHJlcS5za2lwQ2FjaGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHBpZnlfMS5kZWZhdWx0KChjYikgPT4gdGhpcy5fcHJvdmlkZXIuc2VuZEFzeW5jKHJlcSwgY2IpKSgpO1xuICAgICAgICBpZiAocmVzLmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvbGxpbmdCbG9ja1RyYWNrZXIgLSBlbmNvdW50ZXJlZCBlcnJvciBmZXRjaGluZyBibG9jazpcXG4ke3Jlcy5lcnJvcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLlBvbGxpbmdCbG9ja1RyYWNrZXIgPSBQb2xsaW5nQmxvY2tUcmFja2VyO1xuZnVuY3Rpb24gdGltZW91dChkdXJhdGlvbiwgdW5yZWYpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgdGltZW91dFJlZiA9IHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pO1xuICAgICAgICAvLyBkb24ndCBrZWVwIHByb2Nlc3Mgb3BlblxuICAgICAgICBpZiAodGltZW91dFJlZi51bnJlZiAmJiB1bnJlZikge1xuICAgICAgICAgICAgdGltZW91dFJlZi51bnJlZigpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2xsaW5nQmxvY2tUcmFja2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdWJzY3JpYmVCbG9ja1RyYWNrZXIgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19yYW5kb21faWRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwianNvbi1ycGMtcmFuZG9tLWlkXCIpKTtcbmNvbnN0IEJhc2VCbG9ja1RyYWNrZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VCbG9ja1RyYWNrZXJcIik7XG5jb25zdCBjcmVhdGVSYW5kb21JZCA9IGpzb25fcnBjX3JhbmRvbV9pZF8xLmRlZmF1bHQoKTtcbmNsYXNzIFN1YnNjcmliZUJsb2NrVHJhY2tlciBleHRlbmRzIEJhc2VCbG9ja1RyYWNrZXJfMS5CYXNlQmxvY2tUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgLy8gcGFyc2UgKyB2YWxpZGF0ZSBhcmdzXG4gICAgICAgIGlmICghb3B0cy5wcm92aWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdWJzY3JpYmVCbG9ja1RyYWNrZXIgLSBubyBwcm92aWRlciBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFzZUJsb2NrVHJhY2tlciBjb25zdHJ1Y3RvclxuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgLy8gY29uZmlnXG4gICAgICAgIHRoaXMuX3Byb3ZpZGVyID0gb3B0cy5wcm92aWRlcjtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uSWQgPSBudWxsO1xuICAgIH1cbiAgICBhc3luYyBjaGVja0ZvckxhdGVzdEJsb2NrKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRMYXRlc3RCbG9jaygpO1xuICAgIH1cbiAgICBhc3luYyBfc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdWJzY3JpcHRpb25JZCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3N1YnNjcmlwdGlvbklkID09PSBudWxsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy5fY2FsbCgnZXRoX2Jsb2NrTnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uSWQgPSBhd2FpdCB0aGlzLl9jYWxsKCdldGhfc3Vic2NyaWJlJywgJ25ld0hlYWRzJywge30pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3ZpZGVyLm9uKCdkYXRhJywgdGhpcy5faGFuZGxlU3ViRGF0YS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZXdQb3RlbnRpYWxMYXRlc3QoYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2VuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbklkICE9PSBudWxsICYmIHRoaXMuX3N1YnNjcmlwdGlvbklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2FsbCgnZXRoX3Vuc3Vic2NyaWJlJywgdGhpcy5fc3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbklkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9jYWxsKG1ldGhvZCwgLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcm92aWRlci5zZW5kQXN5bmMoe1xuICAgICAgICAgICAgICAgIGlkOiBjcmVhdGVSYW5kb21JZCgpLCBtZXRob2QsIHBhcmFtcywganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICB9LCAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXMucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9oYW5kbGVTdWJEYXRhKF8sIHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLm1ldGhvZCA9PT0gJ2V0aF9zdWJzY3JpcHRpb24nICYmICgoX2EgPSByZXNwb25zZS5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdWJzY3JpcHRpb24pID09PSB0aGlzLl9zdWJzY3JpcHRpb25JZCkge1xuICAgICAgICAgICAgdGhpcy5fbmV3UG90ZW50aWFsTGF0ZXN0KHJlc3BvbnNlLnBhcmFtcy5yZXN1bHQubnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU3Vic2NyaWJlQmxvY2tUcmFja2VyID0gU3Vic2NyaWJlQmxvY2tUcmFja2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic2NyaWJlQmxvY2tUcmFja2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlQmxvY2tUcmFja2VyID0gdm9pZCAwO1xuY29uc3Qgc2FmZV9ldmVudF9lbWl0dGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBtZXRhbWFzay9zYWZlLWV2ZW50LWVtaXR0ZXJcIikpO1xuY29uc3Qgc2VjID0gMTAwMDtcbmNvbnN0IGNhbGN1bGF0ZVN1bSA9IChhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlKSA9PiBhY2N1bXVsYXRvciArIGN1cnJlbnRWYWx1ZTtcbmNvbnN0IGJsb2NrVHJhY2tlckV2ZW50cyA9IFsnc3luYycsICdsYXRlc3QnXTtcbmNsYXNzIEJhc2VCbG9ja1RyYWNrZXIgZXh0ZW5kcyBzYWZlX2V2ZW50X2VtaXR0ZXJfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gY29uZmlnXG4gICAgICAgIHRoaXMuX2Jsb2NrUmVzZXREdXJhdGlvbiA9IG9wdHMuYmxvY2tSZXNldER1cmF0aW9uIHx8IDIwICogc2VjO1xuICAgICAgICAvLyBzdGF0ZVxuICAgICAgICB0aGlzLl9jdXJyZW50QmxvY2sgPSBudWxsO1xuICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gYmluZCBmdW5jdGlvbnMgZm9yIGludGVybmFsIHVzZVxuICAgICAgICB0aGlzLl9vbk5ld0xpc3RlbmVyID0gdGhpcy5fb25OZXdMaXN0ZW5lci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9vblJlbW92ZUxpc3RlbmVyID0gdGhpcy5fb25SZW1vdmVMaXN0ZW5lci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZXNldEN1cnJlbnRCbG9jayA9IHRoaXMuX3Jlc2V0Q3VycmVudEJsb2NrLmJpbmQodGhpcyk7XG4gICAgICAgIC8vIGxpc3RlbiBmb3IgaGFuZGxlciBjaGFuZ2VzXG4gICAgICAgIHRoaXMuX3NldHVwSW50ZXJuYWxFdmVudHMoKTtcbiAgICB9XG4gICAgaXNSdW5uaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNSdW5uaW5nO1xuICAgIH1cbiAgICBnZXRDdXJyZW50QmxvY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50QmxvY2s7XG4gICAgfVxuICAgIGFzeW5jIGdldExhdGVzdEJsb2NrKCkge1xuICAgICAgICAvLyByZXR1cm4gaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50QmxvY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50QmxvY2s7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2FpdCBmb3IgYSBuZXcgbGF0ZXN0IGJsb2NrXG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NrID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHRoaXMub25jZSgnbGF0ZXN0JywgcmVzb2x2ZSkpO1xuICAgICAgICAvLyByZXR1cm4gbmV3bHkgc2V0IGN1cnJlbnQgYmxvY2tcbiAgICAgICAgcmV0dXJuIGxhdGVzdEJsb2NrO1xuICAgIH1cbiAgICAvLyBkb250IGFsbG93IG1vZHVsZSBjb25zdW1lciB0byByZW1vdmUgb3VyIGludGVybmFsIGV2ZW50IGxpc3RlbmVyc1xuICAgIHJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICAgICAgLy8gcGVyZm9ybSBkZWZhdWx0IGJlaGF2aW9yLCBwcmVzZXJ2ZSBmbiBhcml0eVxuICAgICAgICBpZiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBzdXBlci5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlLWFkZCBpbnRlcm5hbCBldmVudHNcbiAgICAgICAgdGhpcy5fc2V0dXBJbnRlcm5hbEV2ZW50cygpO1xuICAgICAgICAvLyB0cmlnZ2VyIHN0b3AgY2hlY2sganVzdCBpbiBjYXNlXG4gICAgICAgIHRoaXMuX29uUmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzLlxuICAgICAqL1xuICAgIF9zdGFydCgpIHtcbiAgICAgICAgLy8gZGVmYXVsdCBiZWhhdmlvciBpcyBub29wXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzLlxuICAgICAqL1xuICAgIF9lbmQoKSB7XG4gICAgICAgIC8vIGRlZmF1bHQgYmVoYXZpb3IgaXMgbm9vcFxuICAgIH1cbiAgICBfc2V0dXBJbnRlcm5hbEV2ZW50cygpIHtcbiAgICAgICAgLy8gZmlyc3QgcmVtb3ZlIGxpc3RlbmVycyBmb3IgaWRlbXBvdGVuY2VcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignbmV3TGlzdGVuZXInLCB0aGlzLl9vbk5ld0xpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVtb3ZlTGlzdGVuZXInLCB0aGlzLl9vblJlbW92ZUxpc3RlbmVyKTtcbiAgICAgICAgLy8gdGhlbiBhZGQgdGhlbVxuICAgICAgICB0aGlzLm9uKCduZXdMaXN0ZW5lcicsIHRoaXMuX29uTmV3TGlzdGVuZXIpO1xuICAgICAgICB0aGlzLm9uKCdyZW1vdmVMaXN0ZW5lcicsIHRoaXMuX29uUmVtb3ZlTGlzdGVuZXIpO1xuICAgIH1cbiAgICBfb25OZXdMaXN0ZW5lcihldmVudE5hbWUpIHtcbiAgICAgICAgLy8gYG5ld0xpc3RlbmVyYCBpcyBjYWxsZWQgKmJlZm9yZSogdGhlIGxpc3RlbmVyIGlzIGFkZGVkXG4gICAgICAgIGlmIChibG9ja1RyYWNrZXJFdmVudHMuaW5jbHVkZXMoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fbWF5YmVTdGFydCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9vblJlbW92ZUxpc3RlbmVyKCkge1xuICAgICAgICAvLyBgcmVtb3ZlTGlzdGVuZXJgIGlzIGNhbGxlZCAqYWZ0ZXIqIHRoZSBsaXN0ZW5lciBpcyByZW1vdmVkXG4gICAgICAgIGlmICh0aGlzLl9nZXRCbG9ja1RyYWNrZXJFdmVudENvdW50KCkgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWF5YmVFbmQoKTtcbiAgICB9XG4gICAgX21heWJlU3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSB0cnVlO1xuICAgICAgICAvLyBjYW5jZWwgc2V0dGluZyBsYXRlc3QgYmxvY2sgdG8gc3RhbGVcbiAgICAgICAgdGhpcy5fY2FuY2VsQmxvY2tSZXNldFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5fc3RhcnQoKTtcbiAgICB9XG4gICAgX21heWJlRW5kKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzUnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zZXR1cEJsb2NrUmVzZXRUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuX2VuZCgpO1xuICAgIH1cbiAgICBfZ2V0QmxvY2tUcmFja2VyRXZlbnRDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrVHJhY2tlckV2ZW50c1xuICAgICAgICAgICAgLm1hcCgoZXZlbnROYW1lKSA9PiB0aGlzLmxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSlcbiAgICAgICAgICAgIC5yZWR1Y2UoY2FsY3VsYXRlU3VtKTtcbiAgICB9XG4gICAgX25ld1BvdGVudGlhbExhdGVzdChuZXdCbG9jaykge1xuICAgICAgICBjb25zdCBjdXJyZW50QmxvY2sgPSB0aGlzLl9jdXJyZW50QmxvY2s7XG4gICAgICAgIC8vIG9ubHkgdXBkYXRlIGlmIGJsb2sgbnVtYmVyIGlzIGhpZ2hlclxuICAgICAgICBpZiAoY3VycmVudEJsb2NrICYmIChoZXhUb0ludChuZXdCbG9jaykgPD0gaGV4VG9JbnQoY3VycmVudEJsb2NrKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRDdXJyZW50QmxvY2sobmV3QmxvY2spO1xuICAgIH1cbiAgICBfc2V0Q3VycmVudEJsb2NrKG5ld0Jsb2NrKSB7XG4gICAgICAgIGNvbnN0IG9sZEJsb2NrID0gdGhpcy5fY3VycmVudEJsb2NrO1xuICAgICAgICB0aGlzLl9jdXJyZW50QmxvY2sgPSBuZXdCbG9jaztcbiAgICAgICAgdGhpcy5lbWl0KCdsYXRlc3QnLCBuZXdCbG9jayk7XG4gICAgICAgIHRoaXMuZW1pdCgnc3luYycsIHsgb2xkQmxvY2ssIG5ld0Jsb2NrIH0pO1xuICAgIH1cbiAgICBfc2V0dXBCbG9ja1Jlc2V0VGltZW91dCgpIHtcbiAgICAgICAgLy8gY2xlYXIgYW55IGV4aXN0aW5nIHRpbWVvdXRcbiAgICAgICAgdGhpcy5fY2FuY2VsQmxvY2tSZXNldFRpbWVvdXQoKTtcbiAgICAgICAgLy8gY2xlYXIgbGF0ZXN0IGJsb2NrIHdoZW4gc3RhbGVcbiAgICAgICAgdGhpcy5fYmxvY2tSZXNldFRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX3Jlc2V0Q3VycmVudEJsb2NrLCB0aGlzLl9ibG9ja1Jlc2V0RHVyYXRpb24pO1xuICAgICAgICAvLyBub2RlanMgLSBkb250IGhvbGQgcHJvY2VzcyBvcGVuXG4gICAgICAgIGlmICh0aGlzLl9ibG9ja1Jlc2V0VGltZW91dC51bnJlZikge1xuICAgICAgICAgICAgdGhpcy5fYmxvY2tSZXNldFRpbWVvdXQudW5yZWYoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY2FuY2VsQmxvY2tSZXNldFRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9ibG9ja1Jlc2V0VGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcmVzZXRDdXJyZW50QmxvY2soKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCbG9jayA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlQmxvY2tUcmFja2VyID0gQmFzZUJsb2NrVHJhY2tlcjtcbmZ1bmN0aW9uIGhleFRvSW50KGhleEludCkge1xuICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQoaGV4SW50LCAxNik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlQmxvY2tUcmFja2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5FbnVtX1Rlem9zQmFsbG90VHlwZSA9IGV4cG9ydHMuRW51bV9UZXpvc0NvbnRyYWN0VHlwZSA9IGV4cG9ydHMuRW51bV9TdGVsbGFyU2lnbmVyVHlwZSA9IGV4cG9ydHMuRW51bV9TdGVsbGFyTWVtb1R5cGUgPSBleHBvcnRzLkVudW1fU3RlbGxhckFzc2V0VHlwZSA9IGV4cG9ydHMuRW51bV9ORU1JbXBvcnRhbmNlVHJhbnNmZXJNb2RlID0gZXhwb3J0cy5FbnVtX05FTU1vZGlmaWNhdGlvblR5cGUgPSBleHBvcnRzLkVudW1fTkVNU3VwcGx5Q2hhbmdlVHlwZSA9IGV4cG9ydHMuRW51bV9ORU1Nb3NhaWNMZXZ5ID0gZXhwb3J0cy5FbnVtX1dvcmRSZXF1ZXN0VHlwZSA9IGV4cG9ydHMuRW51bV9SZWNvdmVyeURldmljZVR5cGUgPSBleHBvcnRzLkVudW1fU2RQcm90ZWN0T3BlcmF0aW9uVHlwZSA9IGV4cG9ydHMuRW51bV9DYXBhYmlsaXR5ID0gZXhwb3J0cy5FbnVtX1NhZmV0eUNoZWNrTGV2ZWwgPSBleHBvcnRzLkVudW1fRXRoZXJldW1EYXRhVHlwZSA9IGV4cG9ydHMuRW51bV9CYWNrdXBUeXBlID0gZXhwb3J0cy5FbnVtX0RlYnVnU3dpcGVEaXJlY3Rpb24gPSBleHBvcnRzLkVudW1fUGluTWF0cml4UmVxdWVzdFR5cGUgPSBleHBvcnRzLkVudW1fQnV0dG9uUmVxdWVzdFR5cGUgPSBleHBvcnRzLkVudW1fRmFpbHVyZVR5cGUgPSBleHBvcnRzLkVudW1fQ2FyZGFub1R4V2l0bmVzc1R5cGUgPSBleHBvcnRzLkVudW1fQ2FyZGFub1R4U2lnbmluZ01vZGUgPSBleHBvcnRzLkVudW1fQ2FyZGFub1R4QXV4aWxpYXJ5RGF0YVN1cHBsZW1lbnRUeXBlID0gZXhwb3J0cy5FbnVtX0NhcmRhbm9Qb29sUmVsYXlUeXBlID0gZXhwb3J0cy5FbnVtX0NhcmRhbm9DZXJ0aWZpY2F0ZVR5cGUgPSBleHBvcnRzLkVudW1fQ2FyZGFub05hdGl2ZVNjcmlwdEhhc2hEaXNwbGF5Rm9ybWF0ID0gZXhwb3J0cy5FbnVtX0NhcmRhbm9OYXRpdmVTY3JpcHRUeXBlID0gZXhwb3J0cy5FbnVtX0NhcmRhbm9BZGRyZXNzVHlwZSA9IGV4cG9ydHMuRW51bV9DYXJkYW5vRGVyaXZhdGlvblR5cGUgPSBleHBvcnRzLkVudW1fUmVxdWVzdFR5cGUgPSBleHBvcnRzLkVudW1fQW1vdW50VW5pdCA9IGV4cG9ydHMuRW51bV9EZWNyZWRTdGFraW5nU3BlbmRUeXBlID0gZXhwb3J0cy5FbnVtX091dHB1dFNjcmlwdFR5cGUgPSBleHBvcnRzLkVudW1fSW5wdXRTY3JpcHRUeXBlID0gZXhwb3J0cy5FbnVtX0JpbmFuY2VUaW1lSW5Gb3JjZSA9IGV4cG9ydHMuRW51bV9CaW5hbmNlT3JkZXJTaWRlID0gZXhwb3J0cy5FbnVtX0JpbmFuY2VPcmRlclR5cGUgPSB2b2lkIDA7XG4vLyBUaGlzIGZpbGUgaXMgYXV0byBnZW5lcmF0ZWQgZnJvbSBkYXRhL21lc3NhZ2VzL21lc3NhZ2UuanNvblxuLy8gQmluYW5jZUdldEFkZHJlc3Ncbi8vIEJpbmFuY2VBZGRyZXNzXG4vLyBCaW5hbmNlR2V0UHVibGljS2V5XG4vLyBCaW5hbmNlUHVibGljS2V5XG4vLyBCaW5hbmNlU2lnblR4XG4vLyBCaW5hbmNlVHhSZXF1ZXN0XG4vLyBCaW5hbmNlVHJhbnNmZXJNc2dcbnZhciBFbnVtX0JpbmFuY2VPcmRlclR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgT1RfVU5LTk9XTjogMCxcbiAgTUFSS0VUOiAxLFxuICBMSU1JVDogMixcbiAgT1RfUkVTRVJWRUQ6IDNcbn0pO1xuZXhwb3J0cy5FbnVtX0JpbmFuY2VPcmRlclR5cGUgPSBFbnVtX0JpbmFuY2VPcmRlclR5cGU7XG52YXIgRW51bV9CaW5hbmNlT3JkZXJTaWRlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFNJREVfVU5LTk9XTjogMCxcbiAgQlVZOiAxLFxuICBTRUxMOiAyXG59KTtcbmV4cG9ydHMuRW51bV9CaW5hbmNlT3JkZXJTaWRlID0gRW51bV9CaW5hbmNlT3JkZXJTaWRlO1xudmFyIEVudW1fQmluYW5jZVRpbWVJbkZvcmNlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFRJRl9VTktOT1dOOiAwLFxuICBHVEU6IDEsXG4gIFRJRl9SRVNFUlZFRDogMixcbiAgSU9DOiAzXG59KTtcbmV4cG9ydHMuRW51bV9CaW5hbmNlVGltZUluRm9yY2UgPSBFbnVtX0JpbmFuY2VUaW1lSW5Gb3JjZTtcbnZhciBFbnVtX0lucHV0U2NyaXB0VHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBTUEVOREFERFJFU1M6IDAsXG4gIFNQRU5ETVVMVElTSUc6IDEsXG4gIEVYVEVSTkFMOiAyLFxuICBTUEVORFdJVE5FU1M6IDMsXG4gIFNQRU5EUDJTSFdJVE5FU1M6IDQsXG4gIFNQRU5EVEFQUk9PVDogNVxufSk7XG5leHBvcnRzLkVudW1fSW5wdXRTY3JpcHRUeXBlID0gRW51bV9JbnB1dFNjcmlwdFR5cGU7XG52YXIgRW51bV9PdXRwdXRTY3JpcHRUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFBBWVRPQUREUkVTUzogMCxcbiAgUEFZVE9TQ1JJUFRIQVNIOiAxLFxuICBQQVlUT01VTFRJU0lHOiAyLFxuICBQQVlUT09QUkVUVVJOOiAzLFxuICBQQVlUT1dJVE5FU1M6IDQsXG4gIFBBWVRPUDJTSFdJVE5FU1M6IDUsXG4gIFBBWVRPVEFQUk9PVDogNlxufSk7XG5leHBvcnRzLkVudW1fT3V0cHV0U2NyaXB0VHlwZSA9IEVudW1fT3V0cHV0U2NyaXB0VHlwZTtcbnZhciBFbnVtX0RlY3JlZFN0YWtpbmdTcGVuZFR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgU1NHZW46IDAsXG4gIFNTUlRYOiAxXG59KTtcbmV4cG9ydHMuRW51bV9EZWNyZWRTdGFraW5nU3BlbmRUeXBlID0gRW51bV9EZWNyZWRTdGFraW5nU3BlbmRUeXBlO1xudmFyIEVudW1fQW1vdW50VW5pdCA9IE9iamVjdC5mcmVlemUoe1xuICBCSVRDT0lOOiAwLFxuICBNSUxMSUJJVENPSU46IDEsXG4gIE1JQ1JPQklUQ09JTjogMixcbiAgU0FUT1NISTogM1xufSk7XG5leHBvcnRzLkVudW1fQW1vdW50VW5pdCA9IEVudW1fQW1vdW50VW5pdDtcbnZhciBFbnVtX1JlcXVlc3RUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFRYSU5QVVQ6IDAsXG4gIFRYT1VUUFVUOiAxLFxuICBUWE1FVEE6IDIsXG4gIFRYRklOSVNIRUQ6IDMsXG4gIFRYRVhUUkFEQVRBOiA0LFxuICBUWE9SSUdJTlBVVDogNSxcbiAgVFhPUklHT1VUUFVUOiA2XG59KTtcbmV4cG9ydHMuRW51bV9SZXF1ZXN0VHlwZSA9IEVudW1fUmVxdWVzdFR5cGU7XG52YXIgRW51bV9DYXJkYW5vRGVyaXZhdGlvblR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgTEVER0VSOiAwLFxuICBJQ0FSVVM6IDEsXG4gIElDQVJVU19UUkVaT1I6IDJcbn0pO1xuZXhwb3J0cy5FbnVtX0NhcmRhbm9EZXJpdmF0aW9uVHlwZSA9IEVudW1fQ2FyZGFub0Rlcml2YXRpb25UeXBlO1xudmFyIEVudW1fQ2FyZGFub0FkZHJlc3NUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEJBU0U6IDAsXG4gIEJBU0VfU0NSSVBUX0tFWTogMSxcbiAgQkFTRV9LRVlfU0NSSVBUOiAyLFxuICBCQVNFX1NDUklQVF9TQ1JJUFQ6IDMsXG4gIFBPSU5URVI6IDQsXG4gIFBPSU5URVJfU0NSSVBUOiA1LFxuICBFTlRFUlBSSVNFOiA2LFxuICBFTlRFUlBSSVNFX1NDUklQVDogNyxcbiAgQllST046IDgsXG4gIFJFV0FSRDogMTQsXG4gIFJFV0FSRF9TQ1JJUFQ6IDE1XG59KTtcbmV4cG9ydHMuRW51bV9DYXJkYW5vQWRkcmVzc1R5cGUgPSBFbnVtX0NhcmRhbm9BZGRyZXNzVHlwZTtcbnZhciBFbnVtX0NhcmRhbm9OYXRpdmVTY3JpcHRUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFBVQl9LRVk6IDAsXG4gIEFMTDogMSxcbiAgQU5ZOiAyLFxuICBOX09GX0s6IDMsXG4gIElOVkFMSURfQkVGT1JFOiA0LFxuICBJTlZBTElEX0hFUkVBRlRFUjogNVxufSk7XG5leHBvcnRzLkVudW1fQ2FyZGFub05hdGl2ZVNjcmlwdFR5cGUgPSBFbnVtX0NhcmRhbm9OYXRpdmVTY3JpcHRUeXBlO1xudmFyIEVudW1fQ2FyZGFub05hdGl2ZVNjcmlwdEhhc2hEaXNwbGF5Rm9ybWF0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEhJREU6IDAsXG4gIEJFQ0gzMjogMSxcbiAgUE9MSUNZX0lEOiAyXG59KTtcbmV4cG9ydHMuRW51bV9DYXJkYW5vTmF0aXZlU2NyaXB0SGFzaERpc3BsYXlGb3JtYXQgPSBFbnVtX0NhcmRhbm9OYXRpdmVTY3JpcHRIYXNoRGlzcGxheUZvcm1hdDtcbnZhciBFbnVtX0NhcmRhbm9DZXJ0aWZpY2F0ZVR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgU1RBS0VfUkVHSVNUUkFUSU9OOiAwLFxuICBTVEFLRV9ERVJFR0lTVFJBVElPTjogMSxcbiAgU1RBS0VfREVMRUdBVElPTjogMixcbiAgU1RBS0VfUE9PTF9SRUdJU1RSQVRJT046IDNcbn0pO1xuZXhwb3J0cy5FbnVtX0NhcmRhbm9DZXJ0aWZpY2F0ZVR5cGUgPSBFbnVtX0NhcmRhbm9DZXJ0aWZpY2F0ZVR5cGU7XG52YXIgRW51bV9DYXJkYW5vUG9vbFJlbGF5VHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBTSU5HTEVfSE9TVF9JUDogMCxcbiAgU0lOR0xFX0hPU1RfTkFNRTogMSxcbiAgTVVMVElQTEVfSE9TVF9OQU1FOiAyXG59KTtcbmV4cG9ydHMuRW51bV9DYXJkYW5vUG9vbFJlbGF5VHlwZSA9IEVudW1fQ2FyZGFub1Bvb2xSZWxheVR5cGU7XG52YXIgRW51bV9DYXJkYW5vVHhBdXhpbGlhcnlEYXRhU3VwcGxlbWVudFR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgTk9ORTogMCxcbiAgQ0FUQUxZU1RfUkVHSVNUUkFUSU9OX1NJR05BVFVSRTogMVxufSk7XG5leHBvcnRzLkVudW1fQ2FyZGFub1R4QXV4aWxpYXJ5RGF0YVN1cHBsZW1lbnRUeXBlID0gRW51bV9DYXJkYW5vVHhBdXhpbGlhcnlEYXRhU3VwcGxlbWVudFR5cGU7XG52YXIgRW51bV9DYXJkYW5vVHhTaWduaW5nTW9kZSA9IE9iamVjdC5mcmVlemUoe1xuICBPUkRJTkFSWV9UUkFOU0FDVElPTjogMCxcbiAgUE9PTF9SRUdJU1RSQVRJT05fQVNfT1dORVI6IDEsXG4gIE1VTFRJU0lHX1RSQU5TQUNUSU9OOiAyXG59KTtcbmV4cG9ydHMuRW51bV9DYXJkYW5vVHhTaWduaW5nTW9kZSA9IEVudW1fQ2FyZGFub1R4U2lnbmluZ01vZGU7XG52YXIgRW51bV9DYXJkYW5vVHhXaXRuZXNzVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBCWVJPTl9XSVRORVNTOiAwLFxuICBTSEVMTEVZX1dJVE5FU1M6IDFcbn0pO1xuZXhwb3J0cy5FbnVtX0NhcmRhbm9UeFdpdG5lc3NUeXBlID0gRW51bV9DYXJkYW5vVHhXaXRuZXNzVHlwZTtcbnZhciBFbnVtX0ZhaWx1cmVUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEZhaWx1cmVfVW5leHBlY3RlZE1lc3NhZ2U6IDEsXG4gIEZhaWx1cmVfQnV0dG9uRXhwZWN0ZWQ6IDIsXG4gIEZhaWx1cmVfRGF0YUVycm9yOiAzLFxuICBGYWlsdXJlX0FjdGlvbkNhbmNlbGxlZDogNCxcbiAgRmFpbHVyZV9QaW5FeHBlY3RlZDogNSxcbiAgRmFpbHVyZV9QaW5DYW5jZWxsZWQ6IDYsXG4gIEZhaWx1cmVfUGluSW52YWxpZDogNyxcbiAgRmFpbHVyZV9JbnZhbGlkU2lnbmF0dXJlOiA4LFxuICBGYWlsdXJlX1Byb2Nlc3NFcnJvcjogOSxcbiAgRmFpbHVyZV9Ob3RFbm91Z2hGdW5kczogMTAsXG4gIEZhaWx1cmVfTm90SW5pdGlhbGl6ZWQ6IDExLFxuICBGYWlsdXJlX1Bpbk1pc21hdGNoOiAxMixcbiAgRmFpbHVyZV9XaXBlQ29kZU1pc21hdGNoOiAxMyxcbiAgRmFpbHVyZV9JbnZhbGlkU2Vzc2lvbjogMTQsXG4gIEZhaWx1cmVfRmlybXdhcmVFcnJvcjogOTlcbn0pO1xuZXhwb3J0cy5FbnVtX0ZhaWx1cmVUeXBlID0gRW51bV9GYWlsdXJlVHlwZTtcbnZhciBFbnVtX0J1dHRvblJlcXVlc3RUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEJ1dHRvblJlcXVlc3RfT3RoZXI6IDEsXG4gIEJ1dHRvblJlcXVlc3RfRmVlT3ZlclRocmVzaG9sZDogMixcbiAgQnV0dG9uUmVxdWVzdF9Db25maXJtT3V0cHV0OiAzLFxuICBCdXR0b25SZXF1ZXN0X1Jlc2V0RGV2aWNlOiA0LFxuICBCdXR0b25SZXF1ZXN0X0NvbmZpcm1Xb3JkOiA1LFxuICBCdXR0b25SZXF1ZXN0X1dpcGVEZXZpY2U6IDYsXG4gIEJ1dHRvblJlcXVlc3RfUHJvdGVjdENhbGw6IDcsXG4gIEJ1dHRvblJlcXVlc3RfU2lnblR4OiA4LFxuICBCdXR0b25SZXF1ZXN0X0Zpcm13YXJlQ2hlY2s6IDksXG4gIEJ1dHRvblJlcXVlc3RfQWRkcmVzczogMTAsXG4gIEJ1dHRvblJlcXVlc3RfUHVibGljS2V5OiAxMSxcbiAgQnV0dG9uUmVxdWVzdF9NbmVtb25pY1dvcmRDb3VudDogMTIsXG4gIEJ1dHRvblJlcXVlc3RfTW5lbW9uaWNJbnB1dDogMTMsXG4gIF9EZXByZWNhdGVkX0J1dHRvblJlcXVlc3RfUGFzc3BocmFzZVR5cGU6IDE0LFxuICBCdXR0b25SZXF1ZXN0X1Vua25vd25EZXJpdmF0aW9uUGF0aDogMTUsXG4gIEJ1dHRvblJlcXVlc3RfUmVjb3ZlcnlIb21lcGFnZTogMTYsXG4gIEJ1dHRvblJlcXVlc3RfU3VjY2VzczogMTcsXG4gIEJ1dHRvblJlcXVlc3RfV2FybmluZzogMTgsXG4gIEJ1dHRvblJlcXVlc3RfUGFzc3BocmFzZUVudHJ5OiAxOSxcbiAgQnV0dG9uUmVxdWVzdF9QaW5FbnRyeTogMjBcbn0pO1xuZXhwb3J0cy5FbnVtX0J1dHRvblJlcXVlc3RUeXBlID0gRW51bV9CdXR0b25SZXF1ZXN0VHlwZTtcbnZhciBFbnVtX1Bpbk1hdHJpeFJlcXVlc3RUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFBpbk1hdHJpeFJlcXVlc3RUeXBlX0N1cnJlbnQ6IDEsXG4gIFBpbk1hdHJpeFJlcXVlc3RUeXBlX05ld0ZpcnN0OiAyLFxuICBQaW5NYXRyaXhSZXF1ZXN0VHlwZV9OZXdTZWNvbmQ6IDMsXG4gIFBpbk1hdHJpeFJlcXVlc3RUeXBlX1dpcGVDb2RlRmlyc3Q6IDQsXG4gIFBpbk1hdHJpeFJlcXVlc3RUeXBlX1dpcGVDb2RlU2Vjb25kOiA1XG59KTtcbmV4cG9ydHMuRW51bV9QaW5NYXRyaXhSZXF1ZXN0VHlwZSA9IEVudW1fUGluTWF0cml4UmVxdWVzdFR5cGU7XG52YXIgRW51bV9EZWJ1Z1N3aXBlRGlyZWN0aW9uID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFVQOiAwLFxuICBET1dOOiAxLFxuICBMRUZUOiAyLFxuICBSSUdIVDogM1xufSk7XG5leHBvcnRzLkVudW1fRGVidWdTd2lwZURpcmVjdGlvbiA9IEVudW1fRGVidWdTd2lwZURpcmVjdGlvbjtcbnZhciBFbnVtX0JhY2t1cFR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgQmlwMzk6IDAsXG4gIFNsaXAzOV9CYXNpYzogMSxcbiAgU2xpcDM5X0FkdmFuY2VkOiAyXG59KTtcbmV4cG9ydHMuRW51bV9CYWNrdXBUeXBlID0gRW51bV9CYWNrdXBUeXBlO1xudmFyIEVudW1fRXRoZXJldW1EYXRhVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBVSU5UOiAxLFxuICBJTlQ6IDIsXG4gIEJZVEVTOiAzLFxuICBTVFJJTkc6IDQsXG4gIEJPT0w6IDUsXG4gIEFERFJFU1M6IDYsXG4gIEFSUkFZOiA3LFxuICBTVFJVQ1Q6IDhcbn0pO1xuZXhwb3J0cy5FbnVtX0V0aGVyZXVtRGF0YVR5cGUgPSBFbnVtX0V0aGVyZXVtRGF0YVR5cGU7XG52YXIgRW51bV9TYWZldHlDaGVja0xldmVsID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFN0cmljdDogMCxcbiAgUHJvbXB0QWx3YXlzOiAxLFxuICBQcm9tcHRUZW1wb3JhcmlseTogMlxufSk7XG5leHBvcnRzLkVudW1fU2FmZXR5Q2hlY2tMZXZlbCA9IEVudW1fU2FmZXR5Q2hlY2tMZXZlbDtcbnZhciBFbnVtX0NhcGFiaWxpdHkgPSBPYmplY3QuZnJlZXplKHtcbiAgQ2FwYWJpbGl0eV9CaXRjb2luOiAxLFxuICBDYXBhYmlsaXR5X0JpdGNvaW5fbGlrZTogMixcbiAgQ2FwYWJpbGl0eV9CaW5hbmNlOiAzLFxuICBDYXBhYmlsaXR5X0NhcmRhbm86IDQsXG4gIENhcGFiaWxpdHlfQ3J5cHRvOiA1LFxuICBDYXBhYmlsaXR5X0VPUzogNixcbiAgQ2FwYWJpbGl0eV9FdGhlcmV1bTogNyxcbiAgQ2FwYWJpbGl0eV9MaXNrOiA4LFxuICBDYXBhYmlsaXR5X01vbmVybzogOSxcbiAgQ2FwYWJpbGl0eV9ORU06IDEwLFxuICBDYXBhYmlsaXR5X1JpcHBsZTogMTEsXG4gIENhcGFiaWxpdHlfU3RlbGxhcjogMTIsXG4gIENhcGFiaWxpdHlfVGV6b3M6IDEzLFxuICBDYXBhYmlsaXR5X1UyRjogMTQsXG4gIENhcGFiaWxpdHlfU2hhbWlyOiAxNSxcbiAgQ2FwYWJpbGl0eV9TaGFtaXJHcm91cHM6IDE2LFxuICBDYXBhYmlsaXR5X1Bhc3NwaHJhc2VFbnRyeTogMTdcbn0pO1xuZXhwb3J0cy5FbnVtX0NhcGFiaWxpdHkgPSBFbnVtX0NhcGFiaWxpdHk7XG52YXIgRW51bV9TZFByb3RlY3RPcGVyYXRpb25UeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIERJU0FCTEU6IDAsXG4gIEVOQUJMRTogMSxcbiAgUkVGUkVTSDogMlxufSk7XG5leHBvcnRzLkVudW1fU2RQcm90ZWN0T3BlcmF0aW9uVHlwZSA9IEVudW1fU2RQcm90ZWN0T3BlcmF0aW9uVHlwZTtcbnZhciBFbnVtX1JlY292ZXJ5RGV2aWNlVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBSZWNvdmVyeURldmljZVR5cGVfU2NyYW1ibGVkV29yZHM6IDAsXG4gIFJlY292ZXJ5RGV2aWNlVHlwZV9NYXRyaXg6IDFcbn0pO1xuZXhwb3J0cy5FbnVtX1JlY292ZXJ5RGV2aWNlVHlwZSA9IEVudW1fUmVjb3ZlcnlEZXZpY2VUeXBlO1xudmFyIEVudW1fV29yZFJlcXVlc3RUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFdvcmRSZXF1ZXN0VHlwZV9QbGFpbjogMCxcbiAgV29yZFJlcXVlc3RUeXBlX01hdHJpeDk6IDEsXG4gIFdvcmRSZXF1ZXN0VHlwZV9NYXRyaXg2OiAyXG59KTtcbmV4cG9ydHMuRW51bV9Xb3JkUmVxdWVzdFR5cGUgPSBFbnVtX1dvcmRSZXF1ZXN0VHlwZTtcbnZhciBFbnVtX05FTU1vc2FpY0xldnkgPSBPYmplY3QuZnJlZXplKHtcbiAgTW9zYWljTGV2eV9BYnNvbHV0ZTogMSxcbiAgTW9zYWljTGV2eV9QZXJjZW50aWxlOiAyXG59KTtcbmV4cG9ydHMuRW51bV9ORU1Nb3NhaWNMZXZ5ID0gRW51bV9ORU1Nb3NhaWNMZXZ5O1xudmFyIEVudW1fTkVNU3VwcGx5Q2hhbmdlVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBTdXBwbHlDaGFuZ2VfSW5jcmVhc2U6IDEsXG4gIFN1cHBseUNoYW5nZV9EZWNyZWFzZTogMlxufSk7XG5leHBvcnRzLkVudW1fTkVNU3VwcGx5Q2hhbmdlVHlwZSA9IEVudW1fTkVNU3VwcGx5Q2hhbmdlVHlwZTtcbnZhciBFbnVtX05FTU1vZGlmaWNhdGlvblR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgQ29zaWduYXRvcnlNb2RpZmljYXRpb25fQWRkOiAxLFxuICBDb3NpZ25hdG9yeU1vZGlmaWNhdGlvbl9EZWxldGU6IDJcbn0pO1xuZXhwb3J0cy5FbnVtX05FTU1vZGlmaWNhdGlvblR5cGUgPSBFbnVtX05FTU1vZGlmaWNhdGlvblR5cGU7XG52YXIgRW51bV9ORU1JbXBvcnRhbmNlVHJhbnNmZXJNb2RlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEltcG9ydGFuY2VUcmFuc2Zlcl9BY3RpdmF0ZTogMSxcbiAgSW1wb3J0YW5jZVRyYW5zZmVyX0RlYWN0aXZhdGU6IDJcbn0pO1xuZXhwb3J0cy5FbnVtX05FTUltcG9ydGFuY2VUcmFuc2Zlck1vZGUgPSBFbnVtX05FTUltcG9ydGFuY2VUcmFuc2Zlck1vZGU7XG52YXIgRW51bV9TdGVsbGFyQXNzZXRUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIE5BVElWRTogMCxcbiAgQUxQSEFOVU00OiAxLFxuICBBTFBIQU5VTTEyOiAyXG59KTtcbmV4cG9ydHMuRW51bV9TdGVsbGFyQXNzZXRUeXBlID0gRW51bV9TdGVsbGFyQXNzZXRUeXBlO1xudmFyIEVudW1fU3RlbGxhck1lbW9UeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIE5PTkU6IDAsXG4gIFRFWFQ6IDEsXG4gIElEOiAyLFxuICBIQVNIOiAzLFxuICBSRVRVUk46IDRcbn0pO1xuZXhwb3J0cy5FbnVtX1N0ZWxsYXJNZW1vVHlwZSA9IEVudW1fU3RlbGxhck1lbW9UeXBlO1xudmFyIEVudW1fU3RlbGxhclNpZ25lclR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgQUNDT1VOVDogMCxcbiAgUFJFX0FVVEg6IDEsXG4gIEhBU0g6IDJcbn0pO1xuZXhwb3J0cy5FbnVtX1N0ZWxsYXJTaWduZXJUeXBlID0gRW51bV9TdGVsbGFyU2lnbmVyVHlwZTtcbnZhciBFbnVtX1Rlem9zQ29udHJhY3RUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEltcGxpY2l0OiAwLFxuICBPcmlnaW5hdGVkOiAxXG59KTtcbmV4cG9ydHMuRW51bV9UZXpvc0NvbnRyYWN0VHlwZSA9IEVudW1fVGV6b3NDb250cmFjdFR5cGU7XG52YXIgRW51bV9UZXpvc0JhbGxvdFR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgWWF5OiAwLFxuICBOYXk6IDEsXG4gIFBhc3M6IDJcbn0pO1xuZXhwb3J0cy5FbnVtX1Rlem9zQmFsbG90VHlwZSA9IEVudW1fVGV6b3NCYWxsb3RUeXBlOyIsInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mLmpzXCIpO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiKTtcblxudmFyIGlzTmF0aXZlRnVuY3Rpb24gPSByZXF1aXJlKFwiLi9pc05hdGl2ZUZ1bmN0aW9uLmpzXCIpO1xuXG52YXIgY29uc3RydWN0ID0gcmVxdWlyZShcIi4vY29uc3RydWN0LmpzXCIpO1xuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcblxuICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcblxuICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgIHJldHVybiBjb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3dyYXBOYXRpdmVTdXBlcjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuY3JlYXRlQXN5bmMgPSBjcmVhdGVBc3luYztcbmV4cG9ydHMucmVzb2x2ZVRpbWVvdXRQcm9taXNlID0gcmVzb2x2ZVRpbWVvdXRQcm9taXNlO1xuZXhwb3J0cy5yZWplY3RUaW1lb3V0UHJvbWlzZSA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZShhcmcsIGRldmljZSkge1xuICB2YXIgbG9jYWxSZXNvbHZlID0gZnVuY3Rpb24gbG9jYWxSZXNvbHZlKF90KSB7fTtcblxuICB2YXIgbG9jYWxSZWplY3QgPSBmdW5jdGlvbiBsb2NhbFJlamVjdChfZSkge307XG5cbiAgdmFyIGlkOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXN5bmMtcHJvbWlzZS1leGVjdXRvclxuXG4gIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGxvY2FsUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgIGxvY2FsUmVqZWN0ID0gcmVqZWN0O1xuXG4gICAgICAgICAgICAgIGlmICghKHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDM7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICByZXR1cm4gYXJnKCk7XG5cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gODtcbiAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDMpO1xuICAgICAgICAgICAgICByZWplY3QoX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIGlkID0gYXJnO1xuXG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1szLCA4XV0pO1xuICAgIH0pKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoX3gsIF94Mikge1xuICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KCkpO1xuICByZXR1cm4ge1xuICAgIGlkOiBpZCxcbiAgICBkZXZpY2U6IGRldmljZSxcbiAgICByZXNvbHZlOiBsb2NhbFJlc29sdmUsXG4gICAgcmVqZWN0OiBsb2NhbFJlamVjdCxcbiAgICBwcm9taXNlOiBwcm9taXNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jKGlubmVyRm4pIHtcbiAgdmFyIGxvY2FsUmVzb2x2ZSA9IGZ1bmN0aW9uIGxvY2FsUmVzb2x2ZShfdCkge307XG5cbiAgdmFyIGxvY2FsUmVqZWN0ID0gZnVuY3Rpb24gbG9jYWxSZWplY3QoX2UpIHt9O1xuXG4gIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGxvY2FsUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgbG9jYWxSZWplY3QgPSByZWplY3Q7XG4gIH0pO1xuXG4gIHZhciBpbm5lciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIGlubmVyRm4oKTtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW5uZXIoKSB7XG4gICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KCk7XG5cbiAgcmV0dXJuIHtcbiAgICByZXNvbHZlOiBsb2NhbFJlc29sdmUsXG4gICAgcmVqZWN0OiBsb2NhbFJlamVjdCxcbiAgICBwcm9taXNlOiBwcm9taXNlLFxuICAgIHJ1bjogZnVuY3Rpb24gcnVuKCkge1xuICAgICAgaW5uZXIoKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRpbWVvdXRQcm9taXNlKGRlbGF5LCByZXN1bHQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSwgZGVsYXkpO1xuICB9KTtcbn1cblxudmFyIHJlamVjdFRpbWVvdXRQcm9taXNlID0gZnVuY3Rpb24gcmVqZWN0VGltZW91dFByb21pc2UoZGVsYXksIGVycm9yKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgIH0sIGRlbGF5KTtcbiAgfSk7XG59O1xuXG5leHBvcnRzLnJlamVjdFRpbWVvdXRQcm9taXNlID0gcmVqZWN0VGltZW91dFByb21pc2U7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5nZXRPcmlnaW4gPSBleHBvcnRzLmh0dHBSZXF1ZXN0ID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxucmVxdWlyZShcIndoYXR3Zy1mZXRjaFwiKTtcblxudmFyIGh0dHBSZXF1ZXN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWYgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSh1cmwsIHR5cGUpIHtcbiAgICB2YXIgcmVzcG9uc2UsIHR4dDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICB0eXBlID0gJ3RleHQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiBmZXRjaCh1cmwsIHtcbiAgICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghKHR5cGUgPT09ICdqc29uJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgdHh0ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgSlNPTi5wYXJzZSh0eHQpKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBpZiAoISh0eXBlID09PSAnYmluYXJ5JykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJlc3BvbnNlLnRleHQoKSk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaHR0cFJlcXVlc3QgZXJyb3I6IFwiICsgdXJsICsgXCIgXCIgKyByZXNwb25zZS5zdGF0dXNUZXh0KTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGh0dHBSZXF1ZXN0KF94LCBfeDIpIHtcbiAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSgpO1xuXG5leHBvcnRzLmh0dHBSZXF1ZXN0ID0gaHR0cFJlcXVlc3Q7XG5cbnZhciBnZXRPcmlnaW4gPSBmdW5jdGlvbiBnZXRPcmlnaW4odXJsKSB7XG4gIGlmICh1cmwuaW5kZXhPZignZmlsZTovLycpID09PSAwKSByZXR1cm4gJ2ZpbGU6Ly8nOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcblxuICB2YXIgcGFydHMgPSB1cmwubWF0Y2goL14uK1xcOlxcL1xcL1teXFwvXSsvKTtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkocGFydHMpICYmIHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICd1bmtub3duJztcbn07XG5cbmV4cG9ydHMuZ2V0T3JpZ2luID0gZ2V0T3JpZ2luOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG52YXIgY3NzID0gJy50cmV6b3Jjb25uZWN0LWNvbnRhaW5lcntwb3NpdGlvbjpmaXhlZCFpbXBvcnRhbnQ7ZGlzcGxheTotd2Via2l0LWJveCFpbXBvcnRhbnQ7ZGlzcGxheTotd2Via2l0LWZsZXghaW1wb3J0YW50O2Rpc3BsYXk6LW1zLWZsZXhib3ghaW1wb3J0YW50O2Rpc3BsYXk6ZmxleCFpbXBvcnRhbnQ7LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsIWltcG9ydGFudDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsIWltcG9ydGFudDstd2Via2l0LWZsZXgtZGlyZWN0aW9uOmNvbHVtbiFpbXBvcnRhbnQ7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbiFpbXBvcnRhbnQ7ZmxleC1kaXJlY3Rpb246Y29sdW1uIWltcG9ydGFudDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXIhaW1wb3J0YW50Oy13ZWJraXQtYWxpZ24taXRlbXM6Y2VudGVyIWltcG9ydGFudDstbXMtZmxleC1hbGlnbjpjZW50ZXIhaW1wb3J0YW50O2FsaWduLWl0ZW1zOmNlbnRlciFpbXBvcnRhbnQ7ei1pbmRleDoxMDAwMCFpbXBvcnRhbnQ7d2lkdGg6MTAwJSFpbXBvcnRhbnQ7aGVpZ2h0OjEwMCUhaW1wb3J0YW50O3RvcDowIWltcG9ydGFudDtsZWZ0OjAhaW1wb3J0YW50O2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuMzUpIWltcG9ydGFudDtvdmVyZmxvdzphdXRvIWltcG9ydGFudDtwYWRkaW5nOjIwcHghaW1wb3J0YW50O21hcmdpbjowIWltcG9ydGFudH0udHJlem9yY29ubmVjdC1jb250YWluZXIgLnRyZXpvcmNvbm5lY3Qtd2luZG93e3Bvc2l0aW9uOnJlbGF0aXZlIWltcG9ydGFudDtkaXNwbGF5OmJsb2NrIWltcG9ydGFudDt3aWR0aDozNzBweCFpbXBvcnRhbnQ7Zm9udC1mYW1pbHk6LWFwcGxlLXN5c3RlbSxCbGlua01hY1N5c3RlbUZvbnQsXCJTZWdvZSBVSVwiLFJvYm90byxcIkhlbHZldGljYSBOZXVlXCIsQXJpYWwsc2Fucy1zZXJpZiFpbXBvcnRhbnQ7bWFyZ2luOmF1dG8haW1wb3J0YW50O2JvcmRlci1yYWRpdXM6M3B4IWltcG9ydGFudDtiYWNrZ3JvdW5kLWNvbG9yOiNmZmYhaW1wb3J0YW50O3RleHQtYWxpZ246Y2VudGVyIWltcG9ydGFudDtvdmVyZmxvdzpoaWRkZW4haW1wb3J0YW50fS50cmV6b3Jjb25uZWN0LWNvbnRhaW5lciAudHJlem9yY29ubmVjdC13aW5kb3cgLnRyZXpvcmNvbm5lY3QtaGVhZHt0ZXh0LWFsaWduOmxlZnQ7cGFkZGluZzoxMnB4IDI0cHghaW1wb3J0YW50O2Rpc3BsYXk6LXdlYmtpdC1ib3ghaW1wb3J0YW50O2Rpc3BsYXk6LXdlYmtpdC1mbGV4IWltcG9ydGFudDtkaXNwbGF5Oi1tcy1mbGV4Ym94IWltcG9ydGFudDtkaXNwbGF5OmZsZXghaW1wb3J0YW50Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlciFpbXBvcnRhbnQ7LXdlYmtpdC1hbGlnbi1pdGVtczpjZW50ZXIhaW1wb3J0YW50Oy1tcy1mbGV4LWFsaWduOmNlbnRlciFpbXBvcnRhbnQ7YWxpZ24taXRlbXM6Y2VudGVyIWltcG9ydGFudH0udHJlem9yY29ubmVjdC1jb250YWluZXIgLnRyZXpvcmNvbm5lY3Qtd2luZG93IC50cmV6b3Jjb25uZWN0LWhlYWQgLnRyZXpvcmNvbm5lY3QtbG9nb3std2Via2l0LWJveC1mbGV4OjE7LXdlYmtpdC1mbGV4OjE7LW1zLWZsZXg6MTtmbGV4OjF9LnRyZXpvcmNvbm5lY3QtY29udGFpbmVyIC50cmV6b3Jjb25uZWN0LXdpbmRvdyAudHJlem9yY29ubmVjdC1oZWFkIC50cmV6b3Jjb25uZWN0LWNsb3Nle2N1cnNvcjpwb2ludGVyIWltcG9ydGFudDtoZWlnaHQ6MjRweCFpbXBvcnRhbnR9LnRyZXpvcmNvbm5lY3QtY29udGFpbmVyIC50cmV6b3Jjb25uZWN0LXdpbmRvdyAudHJlem9yY29ubmVjdC1oZWFkIC50cmV6b3Jjb25uZWN0LWNsb3NlIHN2Z3tmaWxsOiM3NTc1NzU7LXdlYmtpdC10cmFuc2l0aW9uOmZpbGwgLjNzIGVhc2UtaW4tb3V0IWltcG9ydGFudDt0cmFuc2l0aW9uOmZpbGwgLjNzIGVhc2UtaW4tb3V0IWltcG9ydGFudH0udHJlem9yY29ubmVjdC1jb250YWluZXIgLnRyZXpvcmNvbm5lY3Qtd2luZG93IC50cmV6b3Jjb25uZWN0LWhlYWQgLnRyZXpvcmNvbm5lY3QtY2xvc2U6aG92ZXIgc3Zne2ZpbGw6IzQ5NDk0OX0udHJlem9yY29ubmVjdC1jb250YWluZXIgLnRyZXpvcmNvbm5lY3Qtd2luZG93IC50cmV6b3Jjb25uZWN0LWJvZHl7cGFkZGluZzoyNHB4IDI0cHggMzJweCFpbXBvcnRhbnQ7YmFja2dyb3VuZDojRkJGQkZCIWltcG9ydGFudDtib3JkZXItdG9wOjFweCBzb2xpZCAjRUJFQkVCfS50cmV6b3Jjb25uZWN0LWNvbnRhaW5lciAudHJlem9yY29ubmVjdC13aW5kb3cgLnRyZXpvcmNvbm5lY3QtYm9keSBoM3tjb2xvcjojNTA1MDUwIWltcG9ydGFudDtmb250LXNpemU6MTZweCFpbXBvcnRhbnQ7Zm9udC13ZWlnaHQ6NTAwIWltcG9ydGFudH0udHJlem9yY29ubmVjdC1jb250YWluZXIgLnRyZXpvcmNvbm5lY3Qtd2luZG93IC50cmV6b3Jjb25uZWN0LWJvZHkgcHttYXJnaW46OHB4IDAgMjRweCFpbXBvcnRhbnQ7Zm9udC13ZWlnaHQ6NDAwIWltcG9ydGFudDtjb2xvcjojQTlBOUE5IWltcG9ydGFudDtmb250LXNpemU6MTJweCFpbXBvcnRhbnR9LnRyZXpvcmNvbm5lY3QtY29udGFpbmVyIC50cmV6b3Jjb25uZWN0LXdpbmRvdyAudHJlem9yY29ubmVjdC1ib2R5IGJ1dHRvbnt3aWR0aDoxMDAlIWltcG9ydGFudDtwYWRkaW5nOjEycHggMjRweCFpbXBvcnRhbnQ7bWFyZ2luOjAhaW1wb3J0YW50O2JvcmRlci1yYWRpdXM6M3B4IWltcG9ydGFudDtmb250LXNpemU6MTRweCFpbXBvcnRhbnQ7Zm9udC13ZWlnaHQ6MzAwIWltcG9ydGFudDtjdXJzb3I6cG9pbnRlciFpbXBvcnRhbnQ7YmFja2dyb3VuZDojMDFCNzU3IWltcG9ydGFudDtjb2xvcjojZmZmIWltcG9ydGFudDtib3JkZXI6MCFpbXBvcnRhbnQ7LXdlYmtpdC10cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjNzIGVhc2UtaW4tb3V0IWltcG9ydGFudDt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjNzIGVhc2UtaW4tb3V0IWltcG9ydGFudH0udHJlem9yY29ubmVjdC1jb250YWluZXIgLnRyZXpvcmNvbm5lY3Qtd2luZG93IC50cmV6b3Jjb25uZWN0LWJvZHkgYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzAwQUI1MSFpbXBvcnRhbnR9LnRyZXpvcmNvbm5lY3QtY29udGFpbmVyIC50cmV6b3Jjb25uZWN0LXdpbmRvdyAudHJlem9yY29ubmVjdC1ib2R5IGJ1dHRvbjphY3RpdmV7YmFja2dyb3VuZC1jb2xvcjojMDA5NTQ2IWltcG9ydGFudH0vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW1sdWNIVjBJaXdpSkhOMFpHbHVJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSkJRV05CTEhsQ1FVTkpMRk5CUVVFc1owSkJRMEVzVVVGQlFTeHpRa0ZEUVN4UlFVRkJMSFZDUVVOQkxGRkJRVUVzYzBKQlJVRXNVVUZCUVN4bFFVTkJMRzFDUVVGQkxHMUNRVU5CTEhOQ1FVRkJMR2xDUVVOQkxIVkNRVUZCTEdsQ1FVTkJMRzFDUVVGQkxHbENRVU5CTEdWQlFVRXNhVUpCUlVFc2EwSkJRVUVzYVVKQlEwRXNiMEpCUVVFc2FVSkJRMEVzWlVGQlFTeHBRa05tVFN4WlFVRmhMR2xDUkVGeVFpeFJRVUZUTEdkQ1FXdENTQ3hOUVVGQkxHVkJRMEVzVDBGQlFTeGxRVU5CTEVsQlFVRXNXVUZEUVN4TFFVRkJMRmxCUTBFc1YwRkJRU3d3UWtGRFFTeFRRVUZCTEdWQlEwRXNVVUZCUVN4bFFVTkJMRTlCUVVFc1dVTmtVaXdyUTBSWVJTeFRRVUZWTEcxQ1FUWkNRU3hSUVVGQkxHZENRVU5CTEUxQlFVRXNaMEpCUTBFc1dVRkJRU3hqUVVGQkxHMUNRVUZCTEZkQlFVRXNUMEZCUVN4cFFrRkJRU3hOUVVGQkxIRkNRVU5CTEU5QlFVRXNaVU5tVml4alFVRmxMR05FYWtKbUxHbENRV2xDUlN4bFFXdENXU3hYUVVGQkxHbENRMlprTEZOQlFWVXNhVUpFYlVKSkxHMUZRVU5CTEZkQlFVRXNTME5vUW1Rc1VVRkJVeXhMUVVGTExHVkVlRUprTEZGQlFWTXNjMEpCTUVOVExGRkJRVUVzZFVKQlEwRXNVVUZCUVN4elFrTm1iRUlzVVVGQlV5eGxSR2xDU3l4clFrRTFRbG9zYVVKQk9FSnZRaXh2UWtGQlFTeHBRa05vUW14Q0xHVkJRV2RDTEdsQ1JDOUNXaXhaUVdsQ1RpeHBRa0Z6UTFFc2RVWkJRMEVzYVVKQlFVRXNSVU53UWxZc1lVRkJZeXhGUkhCRFZpeFRRVUZWTEVWQk1rUkJMRXRCUVVFc1JVRkZRU3gzUmtOd1FtUXNUMEZCVVN4clFrUjZRMUlzVDBGQlVTeGxRV2xGVFN3MFJrRkRRU3hMUVVGQkxGRkJRMEVzYlVKQlFVRXNTMEZCUVN4SlFVRkJMSE5DUTNCQ1pDeFhRVUZaTEV0QlFVc3NTVUZCU3l4elFrUjNRbElzYTBkQlEwRXNTMEZCUVN4UlFVVkJMRzFGUVVOQkxGRkJRVUVzUzBGQlFTeExRVUZCTEdWQlEwRXNWMEZCUVN4clFrRkRRU3hYUVVGQkxFbEJRVUVzVFVGQlFTeFJRVVZCTEhORlFVTkJMRTFCUVVFc2EwSkJRMEVzVlVGQlFTeGxRM0pDWkN4WlFVRmhMR05FZDBKTExIRkZRM0pDYkVJc1QwRkJVU3hKUVVGSkxFVkJRVWtzWlVSM1FrWXNXVUZCUVN4alFVTkpMRTFCUVVFc2EwSkRkRUpzUWl4VlFVRlhMR1ZCUldJc01FVkJRMFVzVFVGQlR5eGxRVU5RTEZGQlFWTXNTMEZCU3l4bFFVTmtMRTlCUVZFc1dVRkRVaXhqUVVGbExHTkJRMllzVlVGQlZ5eGxRVU5ZTEZsQlFXRXNZMEZEWWl4UFFVRlJMR3RDUVVOU0xGZEJRVmtzYTBKQlExb3NUVUZCVHl4bFFVTlFMRTlCUVZFc1dVRkRVaXh0UWtGQmIwSXNhVUpCUVdsQ0xFbEJRVXNzYzBKQlF6RkRMRmRCUVZrc2FVSkJRV2xDTEVsQlFVc3NjMEpCUlhCRExHZEdRVU5GTEdsQ1FVRnJRaXhyUWtGRmNFSXNhVVpCUTBVc2FVSkJRV3RDSW4wPSAqLyc7XG52YXIgX2RlZmF1bHQgPSBjc3M7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5zaG93UG9wdXBSZXF1ZXN0ID0gdm9pZCAwO1xudmFyIExBWUVSX0lEID0gJ1RyZXpvckNvbm5lY3RJbnRlcmFjdGlvbkxheWVyJztcbnZhciBIVE1MID0gXCJcXG4gICAgPGRpdiBjbGFzcz1cXFwidHJlem9yY29ubmVjdC1jb250YWluZXJcXFwiIGlkPVxcXCJcIiArIExBWUVSX0lEICsgXCJcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidHJlem9yY29ubmVjdC13aW5kb3dcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRyZXpvcmNvbm5lY3QtaGVhZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxzdmcgY2xhc3M9XFxcInRyZXpvcmNvbm5lY3QtbG9nb1xcXCIgeD1cXFwiMHB4XFxcIiB5PVxcXCIwcHhcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNjMuNyA0MS45XFxcIiB3aWR0aD1cXFwiNzhweFxcXCIgaGVpZ2h0PVxcXCIyMHB4XFxcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVxcXCJ4TWluWU1pbiBtZWV0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxwb2x5Z29uIHBvaW50cz1cXFwiMTAxLjEsMTIuOCAxMTguMiwxMi44IDExOC4yLDE3LjMgMTA4LjksMjkuOSAxMTguMiwyOS45IDExOC4yLDM1LjIgMTAxLjEsMzUuMiAxMDEuMSwzMC43IDExMC40LDE4LjEgMTAxLjEsMTguMVxcXCIvPlxcbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cXFwiTTE1OC44LDI2LjljMi4xLTAuOCw0LjMtMi45LDQuMy02LjZjMC00LjUtMy4xLTcuNC03LjctNy40aC0xMC41djIyLjNoNS44di03LjVoMi4ybDQuMSw3LjVoNi43TDE1OC44LDI2Ljl6IE0xNTQuNywyMi41IGgtNFYxOGg0YzEuNSwwLDIuNSwwLjksMi41LDIuMkMxNTcuMiwyMS42LDE1Ni4yLDIyLjUsMTU0LjcsMjIuNXpcXFwiLz5cXG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XFxcIk0xMzAuOCwxMi41Yy02LjgsMC0xMS42LDQuOS0xMS42LDExLjVzNC45LDExLjUsMTEuNiwxMS41czExLjctNC45LDExLjctMTEuNVMxMzcuNiwxMi41LDEzMC44LDEyLjV6IE0xMzAuOCwzMC4zIGMtMy40LDAtNS43LTIuNi01LjctNi4zYzAtMy44LDIuMy02LjMsNS43LTYuM2MzLjQsMCw1LjgsMi42LDUuOCw2LjNDMTM2LjYsMjcuNywxMzQuMiwzMC4zLDEzMC44LDMwLjN6XFxcIi8+XFxuICAgICAgICAgICAgICAgICAgICA8cG9seWdvbiBwb2ludHM9XFxcIjgyLjEsMTIuOCA5OC4zLDEyLjggOTguMywxOCA4Ny45LDE4IDg3LjksMjEuMyA5OCwyMS4zIDk4LDI2LjQgODcuOSwyNi40IDg3LjksMzAgOTguMywzMCA5OC4zLDM1LjIgODIuMSwzNS4yIFxcXCIvPlxcbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cXFwiTTI0LjYsOS43QzI0LjYsNC40LDIwLDAsMTQuNCwwUzQuMiw0LjQsNC4yLDkuN3YzLjFIMHYyMi4zaDBsMTQuNCw2LjdsMTQuNC02LjdoMFYxMi45aC00LjJWOS43eiBNOS40LDkuNyBjMC0yLjUsMi4yLTQuNSw1LTQuNXM1LDIsNSw0LjV2My4xSDkuNFY5Ljd6IE0yMywzMS41bC04LjYsNGwtOC42LTRWMTguMUgyM1YzMS41elxcXCIvPlxcbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cXFwiTTc5LjQsMjAuM2MwLTQuNS0zLjEtNy40LTcuNy03LjRINjEuMnYyMi4zSDY3di03LjVoMi4ybDQuMSw3LjVIODBsLTQuOS04LjNDNzcuMiwyNi4xLDc5LjQsMjQsNzkuNCwyMC4zeiBNNzEsMjIuNWgtNFYxOCBoNGMxLjUsMCwyLjUsMC45LDIuNSwyLjJDNzMuNSwyMS42LDcyLjUsMjIuNSw3MSwyMi41elxcXCIvPlxcbiAgICAgICAgICAgICAgICAgICAgPHBvbHlnb24gcG9pbnRzPVxcXCI0MC41LDEyLjggNTguNiwxMi44IDU4LjYsMTguMSA1Mi40LDE4LjEgNTIuNCwzNS4yIDQ2LjYsMzUuMiA0Ni42LDE4LjEgNDAuNSwxOC4xIFxcXCIvPlxcbiAgICAgICAgICAgICAgICA8L3N2Zz5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidHJlem9yY29ubmVjdC1jbG9zZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8c3ZnIHg9XFxcIjBweFxcXCIgeT1cXFwiMHB4XFxcIiB2aWV3Qm94PVxcXCIyNCAyNCA2MCA2MFxcXCIgd2lkdGg9XFxcIjI0cHhcXFwiIGhlaWdodD1cXFwiMjRweFxcXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cXFwieE1pbllNaW4gbWVldFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHBvbHlnb24gY2xhc3M9XFxcInN0MFxcXCIgcG9pbnRzPVxcXCI0MCw2Ny45IDQyLjEsNzAgNTUsNTcuMSA2Ny45LDcwIDcwLDY3LjkgNTcuMSw1NSA3MCw0Mi4xIDY3LjksNDAgNTUsNTIuOSA0Mi4xLDQwIDQwLDQyLjEgNTIuOSw1NSBcXFwiLz5cXG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0cmV6b3Jjb25uZWN0LWJvZHlcXFwiPlxcbiAgICAgICAgICAgICAgICA8aDM+UG9wdXAgd2FzIGJsb2NrZWQ8L2gzPlxcbiAgICAgICAgICAgICAgICA8cD5QbGVhc2UgY2xpY2sgdG8gXFx1MjAxQ0NvbnRpbnVlXFx1MjAxRCB0byBvcGVuIHBvcHVwIG1hbnVhbGx5PC9wPlxcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJ0cmV6b3Jjb25uZWN0LW9wZW5cXFwiPkNvbnRpbnVlPC9idXR0b24+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXCI7XG5cbnZhciBzaG93UG9wdXBSZXF1ZXN0ID0gZnVuY3Rpb24gc2hvd1BvcHVwUmVxdWVzdChvcGVuLCBjYW5jZWwpIHtcbiAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKExBWUVSX0lEKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlkID0gTEFZRVJfSUQ7XG4gIGRpdi5jbGFzc05hbWUgPSAndHJlem9yY29ubmVjdC1jb250YWluZXInO1xuICBkaXYuaW5uZXJIVE1MID0gSFRNTDtcblxuICBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgfVxuXG4gIHZhciBidXR0b24gPSBkaXYuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgndHJlem9yY29ubmVjdC1vcGVuJylbMF07XG5cbiAgYnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgb3BlbigpO1xuXG4gICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNsb3NlID0gZGl2LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3RyZXpvcmNvbm5lY3QtY2xvc2UnKVswXTtcblxuICBjbG9zZS5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGNhbmNlbCgpO1xuXG4gICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnRzLnNob3dQb3B1cFJlcXVlc3QgPSBzaG93UG9wdXBSZXF1ZXN0OyIsIid1c2Ugc3RyaWN0J1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIga2VjY2FrU3RhdGUgPSByZXF1aXJlKCcuL2tlY2Nhay1zdGF0ZS11bnJvbGwnKVxuXG5mdW5jdGlvbiBLZWNjYWsgKCkge1xuICAvLyBtdWNoIGZhc3RlciB0aGFuIGBuZXcgQXJyYXkoNTApYFxuICB0aGlzLnN0YXRlID0gW1xuICAgIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMFxuICBdXG5cbiAgdGhpcy5ibG9ja1NpemUgPSBudWxsXG4gIHRoaXMuY291bnQgPSAwXG4gIHRoaXMuc3F1ZWV6aW5nID0gZmFsc2Vcbn1cblxuS2VjY2FrLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKHJhdGUsIGNhcGFjaXR5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNTA7ICsraSkgdGhpcy5zdGF0ZVtpXSA9IDBcbiAgdGhpcy5ibG9ja1NpemUgPSByYXRlIC8gOFxuICB0aGlzLmNvdW50ID0gMFxuICB0aGlzLnNxdWVlemluZyA9IGZhbHNlXG59XG5cbktlY2Nhay5wcm90b3R5cGUuYWJzb3JiID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgdGhpcy5zdGF0ZVt+fih0aGlzLmNvdW50IC8gNCldIF49IGRhdGFbaV0gPDwgKDggKiAodGhpcy5jb3VudCAlIDQpKVxuICAgIHRoaXMuY291bnQgKz0gMVxuICAgIGlmICh0aGlzLmNvdW50ID09PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAga2VjY2FrU3RhdGUucDE2MDAodGhpcy5zdGF0ZSlcbiAgICAgIHRoaXMuY291bnQgPSAwXG4gICAgfVxuICB9XG59XG5cbktlY2Nhay5wcm90b3R5cGUuYWJzb3JiTGFzdEZld0JpdHMgPSBmdW5jdGlvbiAoYml0cykge1xuICB0aGlzLnN0YXRlW35+KHRoaXMuY291bnQgLyA0KV0gXj0gYml0cyA8PCAoOCAqICh0aGlzLmNvdW50ICUgNCkpXG4gIGlmICgoYml0cyAmIDB4ODApICE9PSAwICYmIHRoaXMuY291bnQgPT09ICh0aGlzLmJsb2NrU2l6ZSAtIDEpKSBrZWNjYWtTdGF0ZS5wMTYwMCh0aGlzLnN0YXRlKVxuICB0aGlzLnN0YXRlW35+KCh0aGlzLmJsb2NrU2l6ZSAtIDEpIC8gNCldIF49IDB4ODAgPDwgKDggKiAoKHRoaXMuYmxvY2tTaXplIC0gMSkgJSA0KSlcbiAga2VjY2FrU3RhdGUucDE2MDAodGhpcy5zdGF0ZSlcbiAgdGhpcy5jb3VudCA9IDBcbiAgdGhpcy5zcXVlZXppbmcgPSB0cnVlXG59XG5cbktlY2Nhay5wcm90b3R5cGUuc3F1ZWV6ZSA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgaWYgKCF0aGlzLnNxdWVlemluZykgdGhpcy5hYnNvcmJMYXN0RmV3Qml0cygweDAxKVxuXG4gIHZhciBvdXRwdXQgPSBCdWZmZXIuYWxsb2MobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgb3V0cHV0W2ldID0gKHRoaXMuc3RhdGVbfn4odGhpcy5jb3VudCAvIDQpXSA+Pj4gKDggKiAodGhpcy5jb3VudCAlIDQpKSkgJiAweGZmXG4gICAgdGhpcy5jb3VudCArPSAxXG4gICAgaWYgKHRoaXMuY291bnQgPT09IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgICBrZWNjYWtTdGF0ZS5wMTYwMCh0aGlzLnN0YXRlKVxuICAgICAgdGhpcy5jb3VudCA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0XG59XG5cbktlY2Nhay5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNTA7ICsraSkgZGVzdC5zdGF0ZVtpXSA9IHRoaXMuc3RhdGVbaV1cbiAgZGVzdC5ibG9ja1NpemUgPSB0aGlzLmJsb2NrU2l6ZVxuICBkZXN0LmNvdW50ID0gdGhpcy5jb3VudFxuICBkZXN0LnNxdWVlemluZyA9IHRoaXMuc3F1ZWV6aW5nXG59XG5cbm1vZHVsZS5leHBvcnRzID0gS2VjY2FrXG4iLCIndXNlIHN0cmljdCdcbnZhciBjcmVhdGVLZWNjYWsgPSByZXF1aXJlKCcuL2tlY2NhaycpXG52YXIgY3JlYXRlU2hha2UgPSByZXF1aXJlKCcuL3NoYWtlJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS2VjY2FrU3RhdGUpIHtcbiAgdmFyIEtlY2NhayA9IGNyZWF0ZUtlY2NhayhLZWNjYWtTdGF0ZSlcbiAgdmFyIFNoYWtlID0gY3JlYXRlU2hha2UoS2VjY2FrU3RhdGUpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChhbGdvcml0aG0sIG9wdGlvbnMpIHtcbiAgICB2YXIgaGFzaCA9IHR5cGVvZiBhbGdvcml0aG0gPT09ICdzdHJpbmcnID8gYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCkgOiBhbGdvcml0aG1cbiAgICBzd2l0Y2ggKGhhc2gpIHtcbiAgICAgIGNhc2UgJ2tlY2NhazIyNCc6IHJldHVybiBuZXcgS2VjY2FrKDExNTIsIDQ0OCwgbnVsbCwgMjI0LCBvcHRpb25zKVxuICAgICAgY2FzZSAna2VjY2FrMjU2JzogcmV0dXJuIG5ldyBLZWNjYWsoMTA4OCwgNTEyLCBudWxsLCAyNTYsIG9wdGlvbnMpXG4gICAgICBjYXNlICdrZWNjYWszODQnOiByZXR1cm4gbmV3IEtlY2Nhayg4MzIsIDc2OCwgbnVsbCwgMzg0LCBvcHRpb25zKVxuICAgICAgY2FzZSAna2VjY2FrNTEyJzogcmV0dXJuIG5ldyBLZWNjYWsoNTc2LCAxMDI0LCBudWxsLCA1MTIsIG9wdGlvbnMpXG5cbiAgICAgIGNhc2UgJ3NoYTMtMjI0JzogcmV0dXJuIG5ldyBLZWNjYWsoMTE1MiwgNDQ4LCAweDA2LCAyMjQsIG9wdGlvbnMpXG4gICAgICBjYXNlICdzaGEzLTI1Nic6IHJldHVybiBuZXcgS2VjY2FrKDEwODgsIDUxMiwgMHgwNiwgMjU2LCBvcHRpb25zKVxuICAgICAgY2FzZSAnc2hhMy0zODQnOiByZXR1cm4gbmV3IEtlY2Nhayg4MzIsIDc2OCwgMHgwNiwgMzg0LCBvcHRpb25zKVxuICAgICAgY2FzZSAnc2hhMy01MTInOiByZXR1cm4gbmV3IEtlY2Nhayg1NzYsIDEwMjQsIDB4MDYsIDUxMiwgb3B0aW9ucylcblxuICAgICAgY2FzZSAnc2hha2UxMjgnOiByZXR1cm4gbmV3IFNoYWtlKDEzNDQsIDI1NiwgMHgxZiwgb3B0aW9ucylcbiAgICAgIGNhc2UgJ3NoYWtlMjU2JzogcmV0dXJuIG5ldyBTaGFrZSgxMDg4LCA1MTIsIDB4MWYsIG9wdGlvbnMpXG5cbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignSW52YWxkIGFsZ29yaXRobTogJyArIGFsZ29yaXRobSlcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSGV4UHJlZml4ZWQgPSByZXF1aXJlKCdpcy1oZXgtcHJlZml4ZWQnKTtcbnZhciBzdHJpcEhleFByZWZpeCA9IHJlcXVpcmUoJ3N0cmlwLWhleC1wcmVmaXgnKTtcblxuLyoqXG4gKiBQYWRzIGEgYFN0cmluZ2AgdG8gaGF2ZSBhbiBldmVuIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IG91dHB1dFxuICovXG5mdW5jdGlvbiBwYWRUb0V2ZW4odmFsdWUpIHtcbiAgdmFyIGEgPSB2YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmICh0eXBlb2YgYSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSB3aGlsZSBwYWRkaW5nIHRvIGV2ZW4sIHZhbHVlIG11c3QgYmUgc3RyaW5nLCBpcyBjdXJyZW50bHkgJyArIHR5cGVvZiBhICsgJywgd2hpbGUgcGFkVG9FdmVuLicpO1xuICB9XG5cbiAgaWYgKGEubGVuZ3RoICUgMikge1xuICAgIGEgPSAnMCcgKyBhO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBgTnVtYmVyYCBpbnRvIGEgaGV4IGBTdHJpbmdgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBpbnRUb0hleChpKSB7XG4gIHZhciBoZXggPSBpLnRvU3RyaW5nKDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIHJldHVybiAnMHgnICsgaGV4O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIGBOdW1iZXJgIHRvIGEgYEJ1ZmZlcmBcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGludFRvQnVmZmVyKGkpIHtcbiAgdmFyIGhleCA9IGludFRvSGV4KGkpO1xuXG4gIHJldHVybiBuZXcgQnVmZmVyKHBhZFRvRXZlbihoZXguc2xpY2UoMikpLCAnaGV4Jyk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBiaW5hcnkgc2l6ZSBvZiBhIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRCaW5hcnlTaXplKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSB3aGlsZSBnZXR0aW5nIGJpbmFyeSBzaXplLCBtZXRob2QgZ2V0QmluYXJ5U2l6ZSByZXF1aXJlcyBpbnB1dCBcXCdzdHJcXCcgdG8gYmUgdHlwZSBTdHJpbmcsIGdvdCBcXCcnICsgdHlwZW9mIHN0ciArICdcXCcuJyk7XG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyLCAndXRmOCcpO1xufVxuXG4vKipcbiAqIFJldHVybnMgVFJVRSBpZiB0aGUgZmlyc3Qgc3BlY2lmaWVkIGFycmF5IGNvbnRhaW5zIGFsbCBlbGVtZW50c1xuICogZnJvbSB0aGUgc2Vjb25kIG9uZS4gRkFMU0Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IHN1cGVyc2V0XG4gKiBAcGFyYW0ge2FycmF5fSBzdWJzZXRcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYXJyYXlDb250YWluc0FycmF5KHN1cGVyc2V0LCBzdWJzZXQsIHNvbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3VwZXJzZXQpICE9PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGFycmF5Q29udGFpbnNBcnJheSByZXF1aXJlcyBpbnB1dCBcXCdzdXBlcnNldFxcJyB0byBiZSBhbiBhcnJheSBnb3QgdHlwZSBcXCcnICsgdHlwZW9mIHN1cGVyc2V0ICsgJ1xcJycpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHN1YnNldCkgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgYXJyYXlDb250YWluc0FycmF5IHJlcXVpcmVzIGlucHV0IFxcJ3N1YnNldFxcJyB0byBiZSBhbiBhcnJheSBnb3QgdHlwZSBcXCcnICsgdHlwZW9mIHN1YnNldCArICdcXCcnKTtcbiAgfVxuXG4gIHJldHVybiBzdWJzZXRbQm9vbGVhbihzb21lKSAmJiAnc29tZScgfHwgJ2V2ZXJ5J10oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN1cGVyc2V0LmluZGV4T2YodmFsdWUpID49IDA7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IHV0ZjggZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgdG9VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b1V0ZjgoaGV4KSB7XG4gIHZhciBidWZmZXJWYWx1ZSA9IG5ldyBCdWZmZXIocGFkVG9FdmVuKHN0cmlwSGV4UHJlZml4KGhleCkucmVwbGFjZSgvXjArfDArJC9nLCAnJykpLCAnaGV4Jyk7XG5cbiAgcmV0dXJuIGJ1ZmZlclZhbHVlLnRvU3RyaW5nKCd1dGY4Jyk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgYXNjaWkgZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgdG9Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9Bc2NpaShoZXgpIHtcbiAgdmFyIHN0ciA9ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIHZhciBpID0gMCxcbiAgICAgIGwgPSBoZXgubGVuZ3RoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgaWYgKGhleC5zdWJzdHJpbmcoMCwgMikgPT09ICcweCcpIHtcbiAgICBpID0gMjtcbiAgfVxuXG4gIGZvciAoOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgdmFyIGNvZGUgPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNik7XG4gICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIHV0Zjggc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmcm9tVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZnJvbVV0Zjgoc3RyaW5nVmFsdWUpIHtcbiAgdmFyIHN0ciA9IG5ldyBCdWZmZXIoc3RyaW5nVmFsdWUsICd1dGY4Jyk7XG5cbiAgcmV0dXJuICcweCcgKyBwYWRUb0V2ZW4oc3RyLnRvU3RyaW5nKCdoZXgnKSkucmVwbGFjZSgvXjArfDArJC9nLCAnJyk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgYXNjaWkgc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmcm9tQXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21Bc2NpaShzdHJpbmdWYWx1ZSkge1xuICB2YXIgaGV4ID0gJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgY29kZSA9IHN0cmluZ1ZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgdmFyIG4gPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgICBoZXggKz0gbi5sZW5ndGggPCAyID8gJzAnICsgbiA6IG47XG4gIH1cblxuICByZXR1cm4gJzB4JyArIGhleDtcbn1cblxuLyoqXG4gKiBnZXRLZXlzKFt7YTogMSwgYjogMn0sIHthOiAzLCBiOiA0fV0sICdhJykgPT4gWzEsIDNdXG4gKlxuICogQG1ldGhvZCBnZXRLZXlzIGdldCBzcGVjaWZpYyBrZXkgZnJvbSBpbm5lciBvYmplY3QgYXJyYXkgb2Ygb2JqZWN0c1xuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtc1xuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtCb29sZWFufSBhbGxvd0VtcHR5XG4gKiBAcmV0dXJucyB7QXJyYXl9IG91dHB1dCBqdXN0IGEgc2ltcGxlIGFycmF5IG9mIG91dHB1dCBrZXlzXG4gKi9cbmZ1bmN0aW9uIGdldEtleXMocGFyYW1zLCBrZXksIGFsbG93RW1wdHkpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgZ2V0S2V5cyBleHBlY3RpbmcgdHlwZSBBcnJheSBhcyBcXCdwYXJhbXNcXCcgaW5wdXQsIGdvdCBcXCcnICsgdHlwZW9mIHBhcmFtcyArICdcXCcnKTtcbiAgfVxuICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgZ2V0S2V5cyBleHBlY3RpbmcgdHlwZSBTdHJpbmcgZm9yIGlucHV0IFxcJ2tleVxcJyBnb3QgXFwnJyArIHR5cGVvZiBrZXkgKyAnXFwnLicpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIHZhbHVlID0gcGFyYW1zW2ldW2tleV07IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBpZiAoYWxsb3dFbXB0eSAmJiAhdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWJpJyk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogSXMgdGhlIHN0cmluZyBhIGhleCBzdHJpbmcuXG4gKlxuICogQG1ldGhvZCBjaGVjayBpZiBzdHJpbmcgaXMgaGV4IHN0cmluZyBvZiBzcGVjaWZpYyBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICogQHJldHVybnMge0Jvb2xlYW59IG91dHB1dCB0aGUgc3RyaW5nIGlzIGEgaGV4IHN0cmluZ1xuICovXG5mdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhcnJheUNvbnRhaW5zQXJyYXk6IGFycmF5Q29udGFpbnNBcnJheSxcbiAgaW50VG9CdWZmZXI6IGludFRvQnVmZmVyLFxuICBnZXRCaW5hcnlTaXplOiBnZXRCaW5hcnlTaXplLFxuICBpc0hleFByZWZpeGVkOiBpc0hleFByZWZpeGVkLFxuICBzdHJpcEhleFByZWZpeDogc3RyaXBIZXhQcmVmaXgsXG4gIHBhZFRvRXZlbjogcGFkVG9FdmVuLFxuICBpbnRUb0hleDogaW50VG9IZXgsXG4gIGZyb21Bc2NpaTogZnJvbUFzY2lpLFxuICBmcm9tVXRmODogZnJvbVV0ZjgsXG4gIHRvQXNjaWk6IHRvQXNjaWksXG4gIHRvVXRmODogdG9VdGY4LFxuICBnZXRLZXlzOiBnZXRLZXlzLFxuICBpc0hleFN0cmluZzogaXNIZXhTdHJpbmdcbn07IiwiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2FwaScpKHJlcXVpcmUoJy4vbGliL2tlY2NhaycpKVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdXNlbGVzcy1lc2NhcGUgKi9cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJylcbmNvbnN0IEJOID0gcmVxdWlyZSgnYm4uanMnKVxuXG52YXIgQUJJID0gZnVuY3Rpb24gKCkge1xufVxuXG4vLyBDb252ZXJ0IGZyb20gc2hvcnQgdG8gY2Fub25pY2FsIG5hbWVzXG4vLyBGSVhNRTogb3B0aW1pc2Ugb3IgbWFrZSB0aGlzIG5pY2VyP1xuZnVuY3Rpb24gZWxlbWVudGFyeU5hbWUgKG5hbWUpIHtcbiAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnaW50WycpKSB7XG4gICAgcmV0dXJuICdpbnQyNTYnICsgbmFtZS5zbGljZSgzKVxuICB9IGVsc2UgaWYgKG5hbWUgPT09ICdpbnQnKSB7XG4gICAgcmV0dXJuICdpbnQyNTYnXG4gIH0gZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCd1aW50WycpKSB7XG4gICAgcmV0dXJuICd1aW50MjU2JyArIG5hbWUuc2xpY2UoNClcbiAgfSBlbHNlIGlmIChuYW1lID09PSAndWludCcpIHtcbiAgICByZXR1cm4gJ3VpbnQyNTYnXG4gIH0gZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCdmaXhlZFsnKSkge1xuICAgIHJldHVybiAnZml4ZWQxMjh4MTI4JyArIG5hbWUuc2xpY2UoNSlcbiAgfSBlbHNlIGlmIChuYW1lID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuICdmaXhlZDEyOHgxMjgnXG4gIH0gZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCd1Zml4ZWRbJykpIHtcbiAgICByZXR1cm4gJ3VmaXhlZDEyOHgxMjgnICsgbmFtZS5zbGljZSg2KVxuICB9IGVsc2UgaWYgKG5hbWUgPT09ICd1Zml4ZWQnKSB7XG4gICAgcmV0dXJuICd1Zml4ZWQxMjh4MTI4J1xuICB9XG4gIHJldHVybiBuYW1lXG59XG5cbkFCSS5ldmVudElEID0gZnVuY3Rpb24gKG5hbWUsIHR5cGVzKSB7XG4gIC8vIEZJWE1FOiB1c2Ugbm9kZS5qcyB1dGlsLmZvcm1hdD9cbiAgdmFyIHNpZyA9IG5hbWUgKyAnKCcgKyB0eXBlcy5tYXAoZWxlbWVudGFyeU5hbWUpLmpvaW4oJywnKSArICcpJ1xuICByZXR1cm4gdXRpbHMua2VjY2FrMjU2KEJ1ZmZlci5mcm9tKHNpZykpXG59XG5cbkFCSS5tZXRob2RJRCA9IGZ1bmN0aW9uIChuYW1lLCB0eXBlcykge1xuICByZXR1cm4gQUJJLmV2ZW50SUQobmFtZSwgdHlwZXMpLnNsaWNlKDAsIDQpXG59XG5cbi8vIFBhcnNlIE4gZnJvbSB0eXBlPE4+XG5mdW5jdGlvbiBwYXJzZVR5cGVOICh0eXBlKSB7XG4gIHJldHVybiBwYXJzZUludCgvXlxcRCsoXFxkKykkLy5leGVjKHR5cGUpWzFdLCAxMClcbn1cblxuLy8gUGFyc2UgTixNIGZyb20gdHlwZTxOPng8TT5cbmZ1bmN0aW9uIHBhcnNlVHlwZU54TSAodHlwZSkge1xuICB2YXIgdG1wID0gL15cXEQrKFxcZCspeChcXGQrKSQvLmV4ZWModHlwZSlcbiAgcmV0dXJuIFsgcGFyc2VJbnQodG1wWzFdLCAxMCksIHBhcnNlSW50KHRtcFsyXSwgMTApIF1cbn1cblxuLy8gUGFyc2UgTiBpbiB0eXBlWzxOPl0gd2hlcmUgXCJ0eXBlXCIgY2FuIGl0c2VsZiBiZSBhbiBhcnJheSB0eXBlLlxuZnVuY3Rpb24gcGFyc2VUeXBlQXJyYXkgKHR5cGUpIHtcbiAgdmFyIHRtcCA9IHR5cGUubWF0Y2goLyguKilcXFsoLio/KVxcXSQvKVxuICBpZiAodG1wKSB7XG4gICAgcmV0dXJuIHRtcFsyXSA9PT0gJycgPyAnZHluYW1pYycgOiBwYXJzZUludCh0bXBbMl0sIDEwKVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIHBhcnNlTnVtYmVyIChhcmcpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnXG4gIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmICh1dGlscy5pc0hleFByZWZpeGVkKGFyZykpIHtcbiAgICAgIHJldHVybiBuZXcgQk4odXRpbHMuc3RyaXBIZXhQcmVmaXgoYXJnKSwgMTYpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgQk4oYXJnLCAxMClcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbmV3IEJOKGFyZylcbiAgfSBlbHNlIGlmIChhcmcudG9BcnJheSkge1xuICAgIC8vIGFzc3VtZSB0aGlzIGlzIGEgQk4gZm9yIHRoZSBtb21lbnQsIHJlcGxhY2Ugd2l0aCBCTi5pc0JOIHNvb25cbiAgICByZXR1cm4gYXJnXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCBpcyBub3QgYSBudW1iZXInKVxuICB9XG59XG5cbi8vIHNvbWVNZXRob2QoYnl0ZXMsdWludClcbi8vIHNvbWVNZXRob2QoYnl0ZXMsdWludCk6KGJvb2xlYW4pXG5mdW5jdGlvbiBwYXJzZVNpZ25hdHVyZSAoc2lnKSB7XG4gIHZhciB0bXAgPSAvXihcXHcrKVxcKCguKilcXCkkLy5leGVjKHNpZylcblxuICBpZiAodG1wLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2Qgc2lnbmF0dXJlJylcbiAgfVxuXG4gIHZhciBhcmdzID0gL14oLispXFwpOlxcKCguKykkLy5leGVjKHRtcFsyXSlcblxuICBpZiAoYXJncyAhPT0gbnVsbCAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiB7XG4gICAgICBtZXRob2Q6IHRtcFsxXSxcbiAgICAgIGFyZ3M6IGFyZ3NbMV0uc3BsaXQoJywnKSxcbiAgICAgIHJldGFyZ3M6IGFyZ3NbMl0uc3BsaXQoJywnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFyYW1zID0gdG1wWzJdLnNwbGl0KCcsJylcbiAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSAmJiBwYXJhbXNbMF0gPT09ICcnKSB7XG4gICAgICAvLyBTcGVjaWFsLWNhc2UgKHBvc3NpYmx5IG5haXZlKSBmaXh1cCBmb3IgZnVuY3Rpb25zIHRoYXQgdGFrZSBubyBhcmd1bWVudHMuXG4gICAgICAvLyBUT0RPOiBzcGVjaWFsIGNhc2VzIGFyZSBhbHdheXMgYmFkLCBidXQgdGhpcyBtYWtlcyB0aGUgZnVuY3Rpb24gcmV0dXJuXG4gICAgICAvLyBtYXRjaCB3aGF0IHRoZSBjYWxsaW5nIGZ1bmN0aW9ucyBleHBlY3RcbiAgICAgIHBhcmFtcyA9IFtdXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtZXRob2Q6IHRtcFsxXSxcbiAgICAgIGFyZ3M6IHBhcmFtc1xuICAgIH1cbiAgfVxufVxuXG4vLyBFbmNvZGVzIGEgc2luZ2xlIGl0ZW0gKGNhbiBiZSBkeW5hbWljIGFycmF5KVxuLy8gQHJldHVybnM6IEJ1ZmZlclxuZnVuY3Rpb24gZW5jb2RlU2luZ2xlICh0eXBlLCBhcmcpIHtcbiAgdmFyIHNpemUsIG51bSwgcmV0LCBpXG5cbiAgaWYgKHR5cGUgPT09ICdhZGRyZXNzJykge1xuICAgIHJldHVybiBlbmNvZGVTaW5nbGUoJ3VpbnQxNjAnLCBwYXJzZU51bWJlcihhcmcpKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdib29sJykge1xuICAgIHJldHVybiBlbmNvZGVTaW5nbGUoJ3VpbnQ4JywgYXJnID8gMSA6IDApXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZW5jb2RlU2luZ2xlKCdieXRlcycsIEJ1ZmZlci5mcm9tKGFyZywgJ3V0ZjgnKSlcbiAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgLy8gdGhpcyBwYXJ0IGhhbmRsZXMgZml4ZWQtbGVuZ3RoIChbMl0pIGFuZCB2YXJpYWJsZSBsZW5ndGggKFtdKSBhcnJheXNcbiAgICAvLyBOT1RFOiB3ZSBjYXRjaCBoZXJlIGFsbCBjYWxscyB0byBhcnJheXMsIHRoYXQgc2ltcGxpZmllcyB0aGUgcmVzdFxuICAgIGlmICh0eXBlb2YgYXJnLmxlbmd0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGFuIGFycmF5PycpXG4gICAgfVxuICAgIHNpemUgPSBwYXJzZVR5cGVBcnJheSh0eXBlKVxuICAgIGlmIChzaXplICE9PSAnZHluYW1pYycgJiYgc2l6ZSAhPT0gMCAmJiBhcmcubGVuZ3RoID4gc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50cyBleGNlZWQgYXJyYXkgc2l6ZTogJyArIHNpemUpXG4gICAgfVxuICAgIHJldCA9IFtdXG4gICAgdHlwZSA9IHR5cGUuc2xpY2UoMCwgdHlwZS5sYXN0SW5kZXhPZignWycpKVxuICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgYXJnID0gSlNPTi5wYXJzZShhcmcpXG4gICAgfVxuICAgIGZvciAoaSBpbiBhcmcpIHtcbiAgICAgIHJldC5wdXNoKGVuY29kZVNpbmdsZSh0eXBlLCBhcmdbaV0pKVxuICAgIH1cbiAgICBpZiAoc2l6ZSA9PT0gJ2R5bmFtaWMnKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZW5jb2RlU2luZ2xlKCd1aW50MjU2JywgYXJnLmxlbmd0aClcbiAgICAgIHJldC51bnNoaWZ0KGxlbmd0aClcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQocmV0KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdieXRlcycpIHtcbiAgICBhcmcgPSBCdWZmZXIuZnJvbShhcmcpXG5cbiAgICByZXQgPSBCdWZmZXIuY29uY2F0KFsgZW5jb2RlU2luZ2xlKCd1aW50MjU2JywgYXJnLmxlbmd0aCksIGFyZyBdKVxuXG4gICAgaWYgKChhcmcubGVuZ3RoICUgMzIpICE9PSAwKSB7XG4gICAgICByZXQgPSBCdWZmZXIuY29uY2F0KFsgcmV0LCB1dGlscy56ZXJvcygzMiAtIChhcmcubGVuZ3RoICUgMzIpKSBdKVxuICAgIH1cblxuICAgIHJldHVybiByZXRcbiAgfSBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykpIHtcbiAgICBzaXplID0gcGFyc2VUeXBlTih0eXBlKVxuICAgIGlmIChzaXplIDwgMSB8fCBzaXplID4gMzIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlczxOPiB3aWR0aDogJyArIHNpemUpXG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWxzLnNldExlbmd0aFJpZ2h0KGFyZywgMzIpXG4gIH0gZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCd1aW50JykpIHtcbiAgICBzaXplID0gcGFyc2VUeXBlTih0eXBlKVxuICAgIGlmICgoc2l6ZSAlIDgpIHx8IChzaXplIDwgOCkgfHwgKHNpemUgPiAyNTYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdWludDxOPiB3aWR0aDogJyArIHNpemUpXG4gICAgfVxuXG4gICAgbnVtID0gcGFyc2VOdW1iZXIoYXJnKVxuICAgIGlmIChudW0uYml0TGVuZ3RoKCkgPiBzaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBsaWVkIHVpbnQgZXhjZWVkcyB3aWR0aDogJyArIHNpemUgKyAnIHZzICcgKyBudW0uYml0TGVuZ3RoKCkpXG4gICAgfVxuXG4gICAgaWYgKG51bSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgdWludCBpcyBuZWdhdGl2ZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG51bS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKVxuICB9IGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgnaW50JykpIHtcbiAgICBzaXplID0gcGFyc2VUeXBlTih0eXBlKVxuICAgIGlmICgoc2l6ZSAlIDgpIHx8IChzaXplIDwgOCkgfHwgKHNpemUgPiAyNTYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50PE4+IHdpZHRoOiAnICsgc2l6ZSlcbiAgICB9XG5cbiAgICBudW0gPSBwYXJzZU51bWJlcihhcmcpXG4gICAgaWYgKG51bS5iaXRMZW5ndGgoKSA+IHNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgaW50IGV4Y2VlZHMgd2lkdGg6ICcgKyBzaXplICsgJyB2cyAnICsgbnVtLmJpdExlbmd0aCgpKVxuICAgIH1cblxuICAgIHJldHVybiBudW0udG9Ud29zKDI1NikudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMilcbiAgfSBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ3VmaXhlZCcpKSB7XG4gICAgc2l6ZSA9IHBhcnNlVHlwZU54TSh0eXBlKVxuXG4gICAgbnVtID0gcGFyc2VOdW1iZXIoYXJnKVxuXG4gICAgaWYgKG51bSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgdWZpeGVkIGlzIG5lZ2F0aXZlJylcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jb2RlU2luZ2xlKCd1aW50MjU2JywgbnVtLm11bChuZXcgQk4oMikucG93KG5ldyBCTihzaXplWzFdKSkpKVxuICB9IGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgnZml4ZWQnKSkge1xuICAgIHNpemUgPSBwYXJzZVR5cGVOeE0odHlwZSlcblxuICAgIHJldHVybiBlbmNvZGVTaW5nbGUoJ2ludDI1NicsIHBhcnNlTnVtYmVyKGFyZykubXVsKG5ldyBCTigyKS5wb3cobmV3IEJOKHNpemVbMV0pKSkpXG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG9yIGludmFsaWQgdHlwZTogJyArIHR5cGUpXG59XG5cbi8vIERlY29kZXMgYSBzaW5nbGUgaXRlbSAoY2FuIGJlIGR5bmFtaWMgYXJyYXkpXG4vLyBAcmV0dXJuczogYXJyYXlcbi8vIEZJWE1FOiB0aGlzIG1ldGhvZCB3aWxsIG5lZWQgYSBsb3Qgb2YgYXR0ZW50aW9uIGF0IGNoZWNraW5nIGxpbWl0cyBhbmQgdmFsaWRhdGlvblxuZnVuY3Rpb24gZGVjb2RlU2luZ2xlIChwYXJzZWRUeXBlLCBkYXRhLCBvZmZzZXQpIHtcbiAgaWYgKHR5cGVvZiBwYXJzZWRUeXBlID09PSAnc3RyaW5nJykge1xuICAgIHBhcnNlZFR5cGUgPSBwYXJzZVR5cGUocGFyc2VkVHlwZSlcbiAgfVxuICB2YXIgc2l6ZSwgbnVtLCByZXQsIGlcblxuICBpZiAocGFyc2VkVHlwZS5uYW1lID09PSAnYWRkcmVzcycpIHtcbiAgICByZXR1cm4gZGVjb2RlU2luZ2xlKHBhcnNlZFR5cGUucmF3VHlwZSwgZGF0YSwgb2Zmc2V0KS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDIwKS50b1N0cmluZygnaGV4JylcbiAgfSBlbHNlIGlmIChwYXJzZWRUeXBlLm5hbWUgPT09ICdib29sJykge1xuICAgIHJldHVybiBkZWNvZGVTaW5nbGUocGFyc2VkVHlwZS5yYXdUeXBlLCBkYXRhLCBvZmZzZXQpLnRvU3RyaW5nKCkgPT09IG5ldyBCTigxKS50b1N0cmluZygpXG4gIH0gZWxzZSBpZiAocGFyc2VkVHlwZS5uYW1lID09PSAnc3RyaW5nJykge1xuICAgIHZhciBieXRlcyA9IGRlY29kZVNpbmdsZShwYXJzZWRUeXBlLnJhd1R5cGUsIGRhdGEsIG9mZnNldClcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMsICd1dGY4JykudG9TdHJpbmcoKVxuICB9IGVsc2UgaWYgKHBhcnNlZFR5cGUuaXNBcnJheSkge1xuICAgIC8vIHRoaXMgcGFydCBoYW5kbGVzIGZpeGVkLWxlbmd0aCBhcnJheXMgKFsyXSkgYW5kIHZhcmlhYmxlIGxlbmd0aCAoW10pIGFycmF5c1xuICAgIC8vIE5PVEU6IHdlIGNhdGNoIGhlcmUgYWxsIGNhbGxzIHRvIGFycmF5cywgdGhhdCBzaW1wbGlmaWVzIHRoZSByZXN0XG4gICAgcmV0ID0gW11cbiAgICBzaXplID0gcGFyc2VkVHlwZS5zaXplXG5cbiAgICBpZiAocGFyc2VkVHlwZS5zaXplID09PSAnZHluYW1pYycpIHtcbiAgICAgIG9mZnNldCA9IGRlY29kZVNpbmdsZSgndWludDI1NicsIGRhdGEsIG9mZnNldCkudG9OdW1iZXIoKVxuICAgICAgc2l6ZSA9IGRlY29kZVNpbmdsZSgndWludDI1NicsIGRhdGEsIG9mZnNldCkudG9OdW1iZXIoKVxuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgMzJcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgdmFyIGRlY29kZWQgPSBkZWNvZGVTaW5nbGUocGFyc2VkVHlwZS5zdWJBcnJheSwgZGF0YSwgb2Zmc2V0KVxuICAgICAgcmV0LnB1c2goZGVjb2RlZClcbiAgICAgIG9mZnNldCArPSBwYXJzZWRUeXBlLnN1YkFycmF5Lm1lbW9yeVVzYWdlXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfSBlbHNlIGlmIChwYXJzZWRUeXBlLm5hbWUgPT09ICdieXRlcycpIHtcbiAgICBvZmZzZXQgPSBkZWNvZGVTaW5nbGUoJ3VpbnQyNTYnLCBkYXRhLCBvZmZzZXQpLnRvTnVtYmVyKClcbiAgICBzaXplID0gZGVjb2RlU2luZ2xlKCd1aW50MjU2JywgZGF0YSwgb2Zmc2V0KS50b051bWJlcigpXG4gICAgcmV0dXJuIGRhdGEuc2xpY2Uob2Zmc2V0ICsgMzIsIG9mZnNldCArIDMyICsgc2l6ZSlcbiAgfSBlbHNlIGlmIChwYXJzZWRUeXBlLm5hbWUuc3RhcnRzV2l0aCgnYnl0ZXMnKSkge1xuICAgIHJldHVybiBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgcGFyc2VkVHlwZS5zaXplKVxuICB9IGVsc2UgaWYgKHBhcnNlZFR5cGUubmFtZS5zdGFydHNXaXRoKCd1aW50JykpIHtcbiAgICBudW0gPSBuZXcgQk4oZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIDMyKSwgMTYsICdiZScpXG4gICAgaWYgKG51bS5iaXRMZW5ndGgoKSA+IHBhcnNlZFR5cGUuc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGVkIGludCBleGNlZWRzIHdpZHRoOiAnICsgcGFyc2VkVHlwZS5zaXplICsgJyB2cyAnICsgbnVtLmJpdExlbmd0aCgpKVxuICAgIH1cbiAgICByZXR1cm4gbnVtXG4gIH0gZWxzZSBpZiAocGFyc2VkVHlwZS5uYW1lLnN0YXJ0c1dpdGgoJ2ludCcpKSB7XG4gICAgbnVtID0gbmV3IEJOKGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyAzMiksIDE2LCAnYmUnKS5mcm9tVHdvcygyNTYpXG4gICAgaWYgKG51bS5iaXRMZW5ndGgoKSA+IHBhcnNlZFR5cGUuc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGVkIHVpbnQgZXhjZWVkcyB3aWR0aDogJyArIHBhcnNlZFR5cGUuc2l6ZSArICcgdnMgJyArIG51bS5iaXRMZW5ndGgoKSlcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtXG4gIH0gZWxzZSBpZiAocGFyc2VkVHlwZS5uYW1lLnN0YXJ0c1dpdGgoJ3VmaXhlZCcpKSB7XG4gICAgc2l6ZSA9IG5ldyBCTigyKS5wb3cobmV3IEJOKHBhcnNlZFR5cGUuc2l6ZVsxXSkpXG4gICAgbnVtID0gZGVjb2RlU2luZ2xlKCd1aW50MjU2JywgZGF0YSwgb2Zmc2V0KVxuICAgIGlmICghbnVtLm1vZChzaXplKS5pc1plcm8oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNpbWFscyBub3Qgc3VwcG9ydGVkIHlldCcpXG4gICAgfVxuICAgIHJldHVybiBudW0uZGl2KHNpemUpXG4gIH0gZWxzZSBpZiAocGFyc2VkVHlwZS5uYW1lLnN0YXJ0c1dpdGgoJ2ZpeGVkJykpIHtcbiAgICBzaXplID0gbmV3IEJOKDIpLnBvdyhuZXcgQk4ocGFyc2VkVHlwZS5zaXplWzFdKSlcbiAgICBudW0gPSBkZWNvZGVTaW5nbGUoJ2ludDI1NicsIGRhdGEsIG9mZnNldClcbiAgICBpZiAoIW51bS5tb2Qoc2l6ZSkuaXNaZXJvKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGVjaW1hbHMgbm90IHN1cHBvcnRlZCB5ZXQnKVxuICAgIH1cbiAgICByZXR1cm4gbnVtLmRpdihzaXplKVxuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgb3IgaW52YWxpZCB0eXBlOiAnICsgcGFyc2VkVHlwZS5uYW1lKVxufVxuXG4vLyBQYXJzZSB0aGUgZ2l2ZW4gdHlwZVxuLy8gQHJldHVybnM6IHt9IGNvbnRhaW5pbmcgdGhlIHR5cGUgaXRzZWxmLCBtZW1vcnkgdXNhZ2UgYW5kIChpbmNsdWRpbmcgc2l6ZSBhbmQgc3ViQXJyYXkgaWYgYXBwbGljYWJsZSlcbmZ1bmN0aW9uIHBhcnNlVHlwZSAodHlwZSkge1xuICB2YXIgc2l6ZVxuICB2YXIgcmV0XG4gIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgc2l6ZSA9IHBhcnNlVHlwZUFycmF5KHR5cGUpXG4gICAgdmFyIHN1YkFycmF5ID0gdHlwZS5zbGljZSgwLCB0eXBlLmxhc3RJbmRleE9mKCdbJykpXG4gICAgc3ViQXJyYXkgPSBwYXJzZVR5cGUoc3ViQXJyYXkpXG4gICAgcmV0ID0ge1xuICAgICAgaXNBcnJheTogdHJ1ZSxcbiAgICAgIG5hbWU6IHR5cGUsXG4gICAgICBzaXplOiBzaXplLFxuICAgICAgbWVtb3J5VXNhZ2U6IHNpemUgPT09ICdkeW5hbWljJyA/IDMyIDogc3ViQXJyYXkubWVtb3J5VXNhZ2UgKiBzaXplLFxuICAgICAgc3ViQXJyYXk6IHN1YkFycmF5XG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmF3VHlwZVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICAgIHJhd1R5cGUgPSAndWludDE2MCdcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICByYXdUeXBlID0gJ3VpbnQ4J1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmF3VHlwZSA9ICdieXRlcydcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgcmV0ID0ge1xuICAgICAgcmF3VHlwZTogcmF3VHlwZSxcbiAgICAgIG5hbWU6IHR5cGUsXG4gICAgICBtZW1vcnlVc2FnZTogMzJcbiAgICB9XG5cbiAgICBpZiAoKHR5cGUuc3RhcnRzV2l0aCgnYnl0ZXMnKSAmJiB0eXBlICE9PSAnYnl0ZXMnKSB8fCB0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSB8fCB0eXBlLnN0YXJ0c1dpdGgoJ2ludCcpKSB7XG4gICAgICByZXQuc2l6ZSA9IHBhcnNlVHlwZU4odHlwZSlcbiAgICB9IGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgndWZpeGVkJykgfHwgdHlwZS5zdGFydHNXaXRoKCdmaXhlZCcpKSB7XG4gICAgICByZXQuc2l6ZSA9IHBhcnNlVHlwZU54TSh0eXBlKVxuICAgIH1cblxuICAgIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykgJiYgdHlwZSAhPT0gJ2J5dGVzJyAmJiAocmV0LnNpemUgPCAxIHx8IHJldC5zaXplID4gMzIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZXM8Tj4gd2lkdGg6ICcgKyByZXQuc2l6ZSlcbiAgICB9XG4gICAgaWYgKCh0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSB8fCB0eXBlLnN0YXJ0c1dpdGgoJ2ludCcpKSAmJiAocmV0LnNpemUgJSA4IHx8IHJldC5zaXplIDwgOCB8fCByZXQuc2l6ZSA+IDI1NikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnQvdWludDxOPiB3aWR0aDogJyArIHJldC5zaXplKVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuLy8gSXMgYSB0eXBlIGR5bmFtaWM/XG5mdW5jdGlvbiBpc0R5bmFtaWMgKHR5cGUpIHtcbiAgLy8gRklYTUU6IGhhbmRsZSBhbGwgdHlwZXM/IEkgZG9uJ3QgdGhpbmsgYW55dGhpbmcgaXMgbWlzc2luZyBub3dcbiAgcmV0dXJuICh0eXBlID09PSAnc3RyaW5nJykgfHwgKHR5cGUgPT09ICdieXRlcycpIHx8IChwYXJzZVR5cGVBcnJheSh0eXBlKSA9PT0gJ2R5bmFtaWMnKVxufVxuXG4vLyBJcyBhIHR5cGUgYW4gYXJyYXk/XG5mdW5jdGlvbiBpc0FycmF5ICh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmxhc3RJbmRleE9mKCddJykgPT09IHR5cGUubGVuZ3RoIC0gMVxufVxuXG4vLyBFbmNvZGUgYSBtZXRob2QvZXZlbnQgd2l0aCBhcmd1bWVudHNcbi8vIEB0eXBlcyBhbiBhcnJheSBvZiBzdHJpbmcgdHlwZSBuYW1lc1xuLy8gQGFyZ3MgIGFuIGFycmF5IG9mIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbkFCSS5yYXdFbmNvZGUgPSBmdW5jdGlvbiAodHlwZXMsIHZhbHVlcykge1xuICB2YXIgb3V0cHV0ID0gW11cbiAgdmFyIGRhdGEgPSBbXVxuXG4gIHZhciBoZWFkTGVuZ3RoID0gMFxuXG4gIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgdmFyIHNpemUgPSBwYXJzZVR5cGVBcnJheSh0eXBlKVxuXG4gICAgICBpZiAoc2l6ZSAhPT0gJ2R5bmFtaWMnKSB7XG4gICAgICAgIGhlYWRMZW5ndGggKz0gMzIgKiBzaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFkTGVuZ3RoICs9IDMyXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWRMZW5ndGggKz0gMzJcbiAgICB9XG4gIH0pXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0eXBlID0gZWxlbWVudGFyeU5hbWUodHlwZXNbaV0pXG4gICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldXG4gICAgdmFyIGN1ciA9IGVuY29kZVNpbmdsZSh0eXBlLCB2YWx1ZSlcblxuICAgIC8vIFVzZSB0aGUgaGVhZC90YWlsIG1ldGhvZCBmb3Igc3RvcmluZyBkeW5hbWljIGRhdGFcbiAgICBpZiAoaXNEeW5hbWljKHR5cGUpKSB7XG4gICAgICBvdXRwdXQucHVzaChlbmNvZGVTaW5nbGUoJ3VpbnQyNTYnLCBoZWFkTGVuZ3RoKSlcbiAgICAgIGRhdGEucHVzaChjdXIpXG4gICAgICBoZWFkTGVuZ3RoICs9IGN1ci5sZW5ndGhcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goY3VyKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dHB1dC5jb25jYXQoZGF0YSkpXG59XG5cbkFCSS5yYXdEZWNvZGUgPSBmdW5jdGlvbiAodHlwZXMsIGRhdGEpIHtcbiAgdmFyIHJldCA9IFtdXG4gIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKVxuICB2YXIgb2Zmc2V0ID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50YXJ5TmFtZSh0eXBlc1tpXSlcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VUeXBlKHR5cGUsIGRhdGEsIG9mZnNldClcbiAgICB2YXIgZGVjb2RlZCA9IGRlY29kZVNpbmdsZShwYXJzZWQsIGRhdGEsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gcGFyc2VkLm1lbW9yeVVzYWdlXG4gICAgcmV0LnB1c2goZGVjb2RlZClcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkFCSS5zaW1wbGVFbmNvZGUgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5zbGljZSgxKVxuICB2YXIgc2lnID0gcGFyc2VTaWduYXR1cmUobWV0aG9kKVxuXG4gIC8vIEZJWE1FOiB2YWxpZGF0ZS9jb252ZXJ0IGFyZ3VtZW50c1xuICBpZiAoYXJncy5sZW5ndGggIT09IHNpZy5hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgY291bnQgbWlzbWF0Y2gnKVxuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoWyBBQkkubWV0aG9kSUQoc2lnLm1ldGhvZCwgc2lnLmFyZ3MpLCBBQkkucmF3RW5jb2RlKHNpZy5hcmdzLCBhcmdzKSBdKVxufVxuXG5BQkkuc2ltcGxlRGVjb2RlID0gZnVuY3Rpb24gKG1ldGhvZCwgZGF0YSkge1xuICB2YXIgc2lnID0gcGFyc2VTaWduYXR1cmUobWV0aG9kKVxuXG4gIC8vIEZJWE1FOiB2YWxpZGF0ZS9jb252ZXJ0IGFyZ3VtZW50c1xuICBpZiAoIXNpZy5yZXRhcmdzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXR1cm4gdmFsdWVzIGluIG1ldGhvZCcpXG4gIH1cblxuICByZXR1cm4gQUJJLnJhd0RlY29kZShzaWcucmV0YXJncywgZGF0YSlcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5ICh0eXBlLCB2YWx1ZSkge1xuICBpZiAodHlwZS5zdGFydHNXaXRoKCdhZGRyZXNzJykgfHwgdHlwZS5zdGFydHNXaXRoKCdieXRlcycpKSB7XG4gICAgcmV0dXJuICcweCcgKyB2YWx1ZS50b1N0cmluZygnaGV4JylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKVxuICB9XG59XG5cbkFCSS5zdHJpbmdpZnkgPSBmdW5jdGlvbiAodHlwZXMsIHZhbHVlcykge1xuICB2YXIgcmV0ID0gW11cblxuICBmb3IgKHZhciBpIGluIHR5cGVzKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlc1tpXVxuICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXVxuXG4gICAgLy8gaWYgaXQgaXMgYW4gYXJyYXkgdHlwZSwgY29uY2F0IHRoZSBpdGVtc1xuICAgIGlmICgvXlteXFxbXStcXFsuKlxcXSQvLnRlc3QodHlwZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkodHlwZSwgaXRlbSlcbiAgICAgIH0pLmpvaW4oJywgJylcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBzdHJpbmdpZnkodHlwZSwgdmFsdWUpXG4gICAgfVxuXG4gICAgcmV0LnB1c2godmFsdWUpXG4gIH1cblxuICByZXR1cm4gcmV0XG59XG5cbkFCSS5zb2xpZGl0eVBhY2sgPSBmdW5jdGlvbiAodHlwZXMsIHZhbHVlcykge1xuICBpZiAodHlwZXMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgb2YgdHlwZXMgYXJlIG5vdCBtYXRjaGluZyB0aGUgdmFsdWVzJylcbiAgfVxuXG4gIHZhciBzaXplLCBudW1cbiAgdmFyIHJldCA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0eXBlID0gZWxlbWVudGFyeU5hbWUodHlwZXNbaV0pXG4gICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldXG5cbiAgICBpZiAodHlwZSA9PT0gJ2J5dGVzJykge1xuICAgICAgcmV0LnB1c2godmFsdWUpXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0LnB1c2goQnVmZmVyLmZyb20odmFsdWUsICd1dGY4JykpXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgIHJldC5wdXNoKEJ1ZmZlci5mcm9tKHZhbHVlID8gJzAxJyA6ICcwMCcsICdoZXgnKSlcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdhZGRyZXNzJykge1xuICAgICAgcmV0LnB1c2godXRpbHMuc2V0TGVuZ3RoTGVmdCh2YWx1ZSwgMjApKVxuICAgIH0gZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdieXRlcycpKSB7XG4gICAgICBzaXplID0gcGFyc2VUeXBlTih0eXBlKVxuICAgICAgaWYgKHNpemUgPCAxIHx8IHNpemUgPiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZXM8Tj4gd2lkdGg6ICcgKyBzaXplKVxuICAgICAgfVxuXG4gICAgICByZXQucHVzaCh1dGlscy5zZXRMZW5ndGhSaWdodCh2YWx1ZSwgc2l6ZSkpXG4gICAgfSBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSkge1xuICAgICAgc2l6ZSA9IHBhcnNlVHlwZU4odHlwZSlcbiAgICAgIGlmICgoc2l6ZSAlIDgpIHx8IChzaXplIDwgOCkgfHwgKHNpemUgPiAyNTYpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1aW50PE4+IHdpZHRoOiAnICsgc2l6ZSlcbiAgICAgIH1cblxuICAgICAgbnVtID0gcGFyc2VOdW1iZXIodmFsdWUpXG4gICAgICBpZiAobnVtLmJpdExlbmd0aCgpID4gc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBsaWVkIHVpbnQgZXhjZWVkcyB3aWR0aDogJyArIHNpemUgKyAnIHZzICcgKyBudW0uYml0TGVuZ3RoKCkpXG4gICAgICB9XG5cbiAgICAgIHJldC5wdXNoKG51bS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIHNpemUgLyA4KSlcbiAgICB9IGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgnaW50JykpIHtcbiAgICAgIHNpemUgPSBwYXJzZVR5cGVOKHR5cGUpXG4gICAgICBpZiAoKHNpemUgJSA4KSB8fCAoc2l6ZSA8IDgpIHx8IChzaXplID4gMjU2KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50PE4+IHdpZHRoOiAnICsgc2l6ZSlcbiAgICAgIH1cblxuICAgICAgbnVtID0gcGFyc2VOdW1iZXIodmFsdWUpXG4gICAgICBpZiAobnVtLmJpdExlbmd0aCgpID4gc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBsaWVkIGludCBleGNlZWRzIHdpZHRoOiAnICsgc2l6ZSArICcgdnMgJyArIG51bS5iaXRMZW5ndGgoKSlcbiAgICAgIH1cblxuICAgICAgcmV0LnB1c2gobnVtLnRvVHdvcyhzaXplKS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIHNpemUgLyA4KSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRklYTUU6IHN1cHBvcnQgYWxsIG90aGVyIHR5cGVzXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG9yIGludmFsaWQgdHlwZTogJyArIHR5cGUpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQocmV0KVxufVxuXG5BQkkuc29saWRpdHlTSEEzID0gZnVuY3Rpb24gKHR5cGVzLCB2YWx1ZXMpIHtcbiAgcmV0dXJuIHV0aWxzLmtlY2NhazI1NihBQkkuc29saWRpdHlQYWNrKHR5cGVzLCB2YWx1ZXMpKVxufVxuXG5BQkkuc29saWRpdHlTSEEyNTYgPSBmdW5jdGlvbiAodHlwZXMsIHZhbHVlcykge1xuICByZXR1cm4gdXRpbHMuc2hhMjU2KEFCSS5zb2xpZGl0eVBhY2sodHlwZXMsIHZhbHVlcykpXG59XG5cbkFCSS5zb2xpZGl0eVJJUEVNRDE2MCA9IGZ1bmN0aW9uICh0eXBlcywgdmFsdWVzKSB7XG4gIHJldHVybiB1dGlscy5yaXBlbWQxNjAoQUJJLnNvbGlkaXR5UGFjayh0eXBlcywgdmFsdWVzKSwgdHJ1ZSlcbn1cblxuLy8gU2VycGVudCdzIHVzZXJzIGFyZSBmYW1pbGlhciB3aXRoIHRoaXMgZW5jb2Rpbmdcbi8vIC0gczogc3RyaW5nXG4vLyAtIGI6IGJ5dGVzXG4vLyAtIGI8Tj46IGJ5dGVzPE4+XG4vLyAtIGk6IGludDI1NlxuLy8gLSBhOiBpbnQyNTZbXVxuXG5mdW5jdGlvbiBpc051bWVyaWMgKGMpIHtcbiAgLy8gRklYTUU6IGlzIHRoaXMgY29ycmVjdD8gU2VlbXMgdG8gd29ya1xuICByZXR1cm4gKGMgPj0gJzAnKSAmJiAoYyA8PSAnOScpXG59XG5cbi8vIEZvciBhIFwiZG9jdW1lbnRhdGlvblwiIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9zZXJwZW50L2Jsb2IvZGV2ZWxvcC9wcmVwcm9jZXNzLmNwcFxuQUJJLmZyb21TZXJwZW50ID0gZnVuY3Rpb24gKHNpZykge1xuICB2YXIgcmV0ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWcubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHlwZSA9IHNpZ1tpXVxuICAgIGlmICh0eXBlID09PSAncycpIHtcbiAgICAgIHJldC5wdXNoKCdieXRlcycpXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnYicpIHtcbiAgICAgIHZhciB0bXAgPSAnYnl0ZXMnXG4gICAgICB2YXIgaiA9IGkgKyAxXG4gICAgICB3aGlsZSAoKGogPCBzaWcubGVuZ3RoKSAmJiBpc051bWVyaWMoc2lnW2pdKSkge1xuICAgICAgICB0bXAgKz0gc2lnW2pdIC0gJzAnXG4gICAgICAgIGorK1xuICAgICAgfVxuICAgICAgaSA9IGogLSAxXG4gICAgICByZXQucHVzaCh0bXApXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnaScpIHtcbiAgICAgIHJldC5wdXNoKCdpbnQyNTYnKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2EnKSB7XG4gICAgICByZXQucHVzaCgnaW50MjU2W10nKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG9yIGludmFsaWQgdHlwZTogJyArIHR5cGUpXG4gICAgfVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQUJJLnRvU2VycGVudCA9IGZ1bmN0aW9uICh0eXBlcykge1xuICB2YXIgcmV0ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0eXBlID0gdHlwZXNbaV1cbiAgICBpZiAodHlwZSA9PT0gJ2J5dGVzJykge1xuICAgICAgcmV0LnB1c2goJ3MnKVxuICAgIH0gZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdieXRlcycpKSB7XG4gICAgICByZXQucHVzaCgnYicgKyBwYXJzZVR5cGVOKHR5cGUpKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2ludDI1NicpIHtcbiAgICAgIHJldC5wdXNoKCdpJylcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpbnQyNTZbXScpIHtcbiAgICAgIHJldC5wdXNoKCdhJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvciBpbnZhbGlkIHR5cGU6ICcgKyB0eXBlKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0LmpvaW4oJycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQUJJXG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJlY2gzMm0gPSBleHBvcnRzLmJlY2gzMiA9IHZvaWQgMDtcbmNvbnN0IEFMUEhBQkVUID0gJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJztcbmNvbnN0IEFMUEhBQkVUX01BUCA9IHt9O1xuZm9yIChsZXQgeiA9IDA7IHogPCBBTFBIQUJFVC5sZW5ndGg7IHorKykge1xuICAgIGNvbnN0IHggPSBBTFBIQUJFVC5jaGFyQXQoeik7XG4gICAgQUxQSEFCRVRfTUFQW3hdID0gejtcbn1cbmZ1bmN0aW9uIHBvbHltb2RTdGVwKHByZSkge1xuICAgIGNvbnN0IGIgPSBwcmUgPj4gMjU7XG4gICAgcmV0dXJuICgoKHByZSAmIDB4MWZmZmZmZikgPDwgNSkgXlxuICAgICAgICAoLSgoYiA+PiAwKSAmIDEpICYgMHgzYjZhNTdiMikgXlxuICAgICAgICAoLSgoYiA+PiAxKSAmIDEpICYgMHgyNjUwOGU2ZCkgXlxuICAgICAgICAoLSgoYiA+PiAyKSAmIDEpICYgMHgxZWExMTlmYSkgXlxuICAgICAgICAoLSgoYiA+PiAzKSAmIDEpICYgMHgzZDQyMzNkZCkgXlxuICAgICAgICAoLSgoYiA+PiA0KSAmIDEpICYgMHgyYTE0NjJiMykpO1xufVxuZnVuY3Rpb24gcHJlZml4Q2hrKHByZWZpeCkge1xuICAgIGxldCBjaGsgPSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KVxuICAgICAgICAgICAgcmV0dXJuICdJbnZhbGlkIHByZWZpeCAoJyArIHByZWZpeCArICcpJztcbiAgICAgICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKSBeIChjID4+IDUpO1xuICAgIH1cbiAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHYgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKSBeICh2ICYgMHgxZik7XG4gICAgfVxuICAgIHJldHVybiBjaGs7XG59XG5mdW5jdGlvbiBjb252ZXJ0KGRhdGEsIGluQml0cywgb3V0Qml0cywgcGFkKSB7XG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICBsZXQgYml0cyA9IDA7XG4gICAgY29uc3QgbWF4ViA9ICgxIDw8IG91dEJpdHMpIC0gMTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgPDwgaW5CaXRzKSB8IGRhdGFbaV07XG4gICAgICAgIGJpdHMgKz0gaW5CaXRzO1xuICAgICAgICB3aGlsZSAoYml0cyA+PSBvdXRCaXRzKSB7XG4gICAgICAgICAgICBiaXRzIC09IG91dEJpdHM7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgodmFsdWUgPj4gYml0cykgJiBtYXhWKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFkKSB7XG4gICAgICAgIGlmIChiaXRzID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHZhbHVlIDw8IChvdXRCaXRzIC0gYml0cykpICYgbWF4Vik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChiaXRzID49IGluQml0cylcbiAgICAgICAgICAgIHJldHVybiAnRXhjZXNzIHBhZGRpbmcnO1xuICAgICAgICBpZiAoKHZhbHVlIDw8IChvdXRCaXRzIC0gYml0cykpICYgbWF4VilcbiAgICAgICAgICAgIHJldHVybiAnTm9uLXplcm8gcGFkZGluZyc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b1dvcmRzKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGNvbnZlcnQoYnl0ZXMsIDgsIDUsIHRydWUpO1xufVxuZnVuY3Rpb24gZnJvbVdvcmRzVW5zYWZlKHdvcmRzKSB7XG4gICAgY29uc3QgcmVzID0gY29udmVydCh3b3JkcywgNSwgOCwgZmFsc2UpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlcykpXG4gICAgICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBmcm9tV29yZHMod29yZHMpIHtcbiAgICBjb25zdCByZXMgPSBjb252ZXJ0KHdvcmRzLCA1LCA4LCBmYWxzZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzKSlcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgRXJyb3IocmVzKTtcbn1cbmZ1bmN0aW9uIGdldExpYnJhcnlGcm9tRW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgICBsZXQgRU5DT0RJTkdfQ09OU1Q7XG4gICAgaWYgKGVuY29kaW5nID09PSAnYmVjaDMyJykge1xuICAgICAgICBFTkNPRElOR19DT05TVCA9IDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBFTkNPRElOR19DT05TVCA9IDB4MmJjODMwYTM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZShwcmVmaXgsIHdvcmRzLCBMSU1JVCkge1xuICAgICAgICBMSU1JVCA9IExJTUlUIHx8IDkwO1xuICAgICAgICBpZiAocHJlZml4Lmxlbmd0aCArIDcgKyB3b3Jkcy5sZW5ndGggPiBMSU1JVClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4Y2VlZHMgbGVuZ3RoIGxpbWl0Jyk7XG4gICAgICAgIHByZWZpeCA9IHByZWZpeC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBkZXRlcm1pbmUgY2hrIG1vZFxuICAgICAgICBsZXQgY2hrID0gcHJlZml4Q2hrKHByZWZpeCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2hrID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihjaGspO1xuICAgICAgICBsZXQgcmVzdWx0ID0gcHJlZml4ICsgJzEnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gd29yZHNbaV07XG4gICAgICAgICAgICBpZiAoeCA+PiA1ICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uIDUtYml0IHdvcmQnKTtcbiAgICAgICAgICAgIGNoayA9IHBvbHltb2RTdGVwKGNoaykgXiB4O1xuICAgICAgICAgICAgcmVzdWx0ICs9IEFMUEhBQkVULmNoYXJBdCh4KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7ICsraSkge1xuICAgICAgICAgICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKTtcbiAgICAgICAgfVxuICAgICAgICBjaGsgXj0gRU5DT0RJTkdfQ09OU1Q7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gKGNoayA+PiAoKDUgLSBpKSAqIDUpKSAmIDB4MWY7XG4gICAgICAgICAgICByZXN1bHQgKz0gQUxQSEFCRVQuY2hhckF0KHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9fZGVjb2RlKHN0ciwgTElNSVQpIHtcbiAgICAgICAgTElNSVQgPSBMSU1JVCB8fCA5MDtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCA4KVxuICAgICAgICAgICAgcmV0dXJuIHN0ciArICcgdG9vIHNob3J0JztcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPiBMSU1JVClcbiAgICAgICAgICAgIHJldHVybiAnRXhjZWVkcyBsZW5ndGggbGltaXQnO1xuICAgICAgICAvLyBkb24ndCBhbGxvdyBtaXhlZCBjYXNlXG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgdXBwZXJlZCA9IHN0ci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoc3RyICE9PSBsb3dlcmVkICYmIHN0ciAhPT0gdXBwZXJlZClcbiAgICAgICAgICAgIHJldHVybiAnTWl4ZWQtY2FzZSBzdHJpbmcgJyArIHN0cjtcbiAgICAgICAgc3RyID0gbG93ZXJlZDtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBzdHIubGFzdEluZGV4T2YoJzEnKTtcbiAgICAgICAgaWYgKHNwbGl0ID09PSAtMSlcbiAgICAgICAgICAgIHJldHVybiAnTm8gc2VwYXJhdG9yIGNoYXJhY3RlciBmb3IgJyArIHN0cjtcbiAgICAgICAgaWYgKHNwbGl0ID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuICdNaXNzaW5nIHByZWZpeCBmb3IgJyArIHN0cjtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gc3RyLnNsaWNlKDAsIHNwbGl0KTtcbiAgICAgICAgY29uc3Qgd29yZENoYXJzID0gc3RyLnNsaWNlKHNwbGl0ICsgMSk7XG4gICAgICAgIGlmICh3b3JkQ2hhcnMubGVuZ3RoIDwgNilcbiAgICAgICAgICAgIHJldHVybiAnRGF0YSB0b28gc2hvcnQnO1xuICAgICAgICBsZXQgY2hrID0gcHJlZml4Q2hrKHByZWZpeCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2hrID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBjaGs7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZENoYXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gd29yZENoYXJzLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBBTFBIQUJFVF9NQVBbY107XG4gICAgICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiAnVW5rbm93biBjaGFyYWN0ZXIgJyArIGM7XG4gICAgICAgICAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4gdjtcbiAgICAgICAgICAgIC8vIG5vdCBpbiB0aGUgY2hlY2tzdW0/XG4gICAgICAgICAgICBpZiAoaSArIDYgPj0gd29yZENoYXJzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHdvcmRzLnB1c2godik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoayAhPT0gRU5DT0RJTkdfQ09OU1QpXG4gICAgICAgICAgICByZXR1cm4gJ0ludmFsaWQgY2hlY2tzdW0gZm9yICcgKyBzdHI7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlVW5zYWZlKHN0ciwgTElNSVQpIHtcbiAgICAgICAgY29uc3QgcmVzID0gX19kZWNvZGUoc3RyLCBMSU1JVCk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZShzdHIsIExJTUlUKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IF9fZGVjb2RlKHN0ciwgTElNSVQpO1xuICAgICAgICBpZiAodHlwZW9mIHJlcyA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVjb2RlVW5zYWZlLFxuICAgICAgICBkZWNvZGUsXG4gICAgICAgIGVuY29kZSxcbiAgICAgICAgdG9Xb3JkcyxcbiAgICAgICAgZnJvbVdvcmRzVW5zYWZlLFxuICAgICAgICBmcm9tV29yZHMsXG4gICAgfTtcbn1cbmV4cG9ydHMuYmVjaDMyID0gZ2V0TGlicmFyeUZyb21FbmNvZGluZygnYmVjaDMyJyk7XG5leHBvcnRzLmJlY2gzMm0gPSBnZXRMaWJyYXJ5RnJvbUVuY29kaW5nKCdiZWNoMzJtJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIG51bGwgIT09IG9iaiAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsImZ1bmN0aW9uIEFnZW50KCkge1xuICB0aGlzLl9kZWZhdWx0cyA9IFtdO1xufVxuXG5bXCJ1c2VcIiwgXCJvblwiLCBcIm9uY2VcIiwgXCJzZXRcIiwgXCJxdWVyeVwiLCBcInR5cGVcIiwgXCJhY2NlcHRcIiwgXCJhdXRoXCIsIFwid2l0aENyZWRlbnRpYWxzXCIsIFwic29ydFF1ZXJ5XCIsIFwicmV0cnlcIiwgXCJva1wiLCBcInJlZGlyZWN0c1wiLFxuIFwidGltZW91dFwiLCBcImJ1ZmZlclwiLCBcInNlcmlhbGl6ZVwiLCBcInBhcnNlXCIsIFwiY2FcIiwgXCJrZXlcIiwgXCJwZnhcIiwgXCJjZXJ0XCJdLmZvckVhY2goZnVuY3Rpb24oZm4pIHtcbiAgLyoqIERlZmF1bHQgc2V0dGluZyBmb3IgYWxsIHJlcXVlc3RzIGZyb20gdGhpcyBhZ2VudCAqL1xuICBBZ2VudC5wcm90b3R5cGVbZm5dID0gZnVuY3Rpb24oLyp2YXJhcmdzKi8pIHtcbiAgICB0aGlzLl9kZWZhdWx0cy5wdXNoKHtmbjpmbiwgYXJndW1lbnRzOmFyZ3VtZW50c30pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuQWdlbnQucHJvdG90eXBlLl9zZXREZWZhdWx0cyA9IGZ1bmN0aW9uKHJlcSkge1xuICAgIHRoaXMuX2RlZmF1bHRzLmZvckVhY2goZnVuY3Rpb24oZGVmKSB7XG4gICAgICByZXFbZGVmLmZuXS5hcHBseShyZXEsIGRlZi5hcmd1bWVudHMpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZ2VudDtcbiIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIGV2ZW50IHNwZWNpZmljIGFycmF5cyBmb3IgZXZlbnQgdHlwZXMgdGhhdCBub1xyXG4gIC8vIG9uZSBpcyBzdWJzY3JpYmVkIGZvciB0byBhdm9pZCBtZW1vcnkgbGVhay5cclxuICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBvZiBtaXhlZC1pbiBmdW5jdGlvbnMgc2hhcmVkIGJldHdlZW4gbm9kZSBhbmQgY2xpZW50IGNvZGVcbiAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pcy1vYmplY3QnKTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlcXVlc3RCYXNlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RCYXNlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlcXVlc3RCYXNlYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlcXVlc3RCYXNlKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn1cblxuLyoqXG4gKiBNaXhpbiB0aGUgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBSZXF1ZXN0QmFzZS5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IFJlcXVlc3RCYXNlLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogQ2xlYXIgcHJldmlvdXMgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uIF9jbGVhclRpbWVvdXQoKXtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyKTtcbiAgZGVsZXRlIHRoaXMuX3RpbWVyO1xuICBkZWxldGUgdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXI7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBkZWZhdWx0IHJlc3BvbnNlIGJvZHkgcGFyc2VyXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBjb252ZXJ0IGluY29taW5nIGRhdGEgaW50byByZXF1ZXN0LmJvZHlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShmbil7XG4gIHRoaXMuX3BhcnNlciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IGZvcm1hdCBvZiBiaW5hcnkgcmVzcG9uc2UgYm9keS5cbiAqIEluIGJyb3dzZXIgdmFsaWQgZm9ybWF0cyBhcmUgJ2Jsb2InIGFuZCAnYXJyYXlidWZmZXInLFxuICogd2hpY2ggcmV0dXJuIEJsb2IgYW5kIEFycmF5QnVmZmVyLCByZXNwZWN0aXZlbHkuXG4gKlxuICogSW4gTm9kZSBhbGwgdmFsdWVzIHJlc3VsdCBpbiBCdWZmZXIuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAucmVzcG9uc2VUeXBlKCdibG9iJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJlc3BvbnNlVHlwZSA9IGZ1bmN0aW9uKHZhbCl7XG4gIHRoaXMuX3Jlc3BvbnNlVHlwZSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGRlZmF1bHQgcmVxdWVzdCBib2R5IHNlcmlhbGl6ZXJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHRvIGNvbnZlcnQgZGF0YSBzZXQgdmlhIC5zZW5kIG9yIC5hdHRhY2ggaW50byBwYXlsb2FkIHRvIHNlbmRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKGZuKXtcbiAgdGhpcy5fc2VyaWFsaXplciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRpbWVvdXRzLlxuICpcbiAqIC0gcmVzcG9uc2UgdGltZW91dCBpcyB0aW1lIGJldHdlZW4gc2VuZGluZyByZXF1ZXN0IGFuZCByZWNlaXZpbmcgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIHJlc3BvbnNlLiBJbmNsdWRlcyBETlMgYW5kIGNvbm5lY3Rpb24gdGltZS5cbiAqIC0gZGVhZGxpbmUgaXMgdGhlIHRpbWUgZnJvbSBzdGFydCBvZiB0aGUgcmVxdWVzdCB0byByZWNlaXZpbmcgcmVzcG9uc2UgYm9keSBpbiBmdWxsLiBJZiB0aGUgZGVhZGxpbmUgaXMgdG9vIHNob3J0IGxhcmdlIGZpbGVzIG1heSBub3QgbG9hZCBhdCBhbGwgb24gc2xvdyBjb25uZWN0aW9ucy5cbiAqXG4gKiBWYWx1ZSBvZiAwIG9yIGZhbHNlIG1lYW5zIG5vIHRpbWVvdXQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBtcyBvciB7cmVzcG9uc2UsIGRlYWRsaW5lfVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gdGltZW91dChvcHRpb25zKXtcbiAgaWYgKCFvcHRpb25zIHx8ICdvYmplY3QnICE9PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zO1xuICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmb3IodmFyIG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgc3dpdGNoKG9wdGlvbikge1xuICAgICAgY2FzZSAnZGVhZGxpbmUnOlxuICAgICAgICB0aGlzLl90aW1lb3V0ID0gb3B0aW9ucy5kZWFkbGluZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZXNwb25zZSc6XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dCA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biB0aW1lb3V0IG9wdGlvblwiLCBvcHRpb24pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IG51bWJlciBvZiByZXRyeSBhdHRlbXB0cyBvbiBlcnJvci5cbiAqXG4gKiBGYWlsZWQgcmVxdWVzdHMgd2lsbCBiZSByZXRyaWVkICdjb3VudCcgdGltZXMgaWYgdGltZW91dCBvciBlcnIuY29kZSA+PSA1MDAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJldHJ5ID0gZnVuY3Rpb24gcmV0cnkoY291bnQsIGZuKXtcbiAgLy8gRGVmYXVsdCB0byAxIGlmIG5vIGNvdW50IHBhc3NlZCBvciB0cnVlXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IGNvdW50ID09PSB0cnVlKSBjb3VudCA9IDE7XG4gIGlmIChjb3VudCA8PSAwKSBjb3VudCA9IDA7XG4gIHRoaXMuX21heFJldHJpZXMgPSBjb3VudDtcbiAgdGhpcy5fcmV0cmllcyA9IDA7XG4gIHRoaXMuX3JldHJ5Q2FsbGJhY2sgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG52YXIgRVJST1JfQ09ERVMgPSBbXG4gICdFQ09OTlJFU0VUJyxcbiAgJ0VUSU1FRE9VVCcsXG4gICdFQUREUklORk8nLFxuICAnRVNPQ0tFVFRJTUVET1VUJ1xuXTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSByZXF1ZXN0IHNob3VsZCBiZSByZXRyaWVkLlxuICogKEJvcnJvd2VkIGZyb20gc2VnbWVudGlvL3N1cGVyYWdlbnQtcmV0cnkpXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSBbcmVzXVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fc2hvdWxkUmV0cnkgPSBmdW5jdGlvbihlcnIsIHJlcykge1xuICBpZiAoIXRoaXMuX21heFJldHJpZXMgfHwgdGhpcy5fcmV0cmllcysrID49IHRoaXMuX21heFJldHJpZXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRoaXMuX3JldHJ5Q2FsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgdmFyIG92ZXJyaWRlID0gdGhpcy5fcmV0cnlDYWxsYmFjayhlcnIsIHJlcyk7XG4gICAgICBpZiAob3ZlcnJpZGUgPT09IHRydWUpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKG92ZXJyaWRlID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gdW5kZWZpbmVkIGZhbGxzIGJhY2sgdG8gZGVmYXVsdHNcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGlmIChyZXMgJiYgcmVzLnN0YXR1cyAmJiByZXMuc3RhdHVzID49IDUwMCAmJiByZXMuc3RhdHVzICE9IDUwMSkgcmV0dXJuIHRydWU7XG4gIGlmIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgJiYgfkVSUk9SX0NPREVTLmluZGV4T2YoZXJyLmNvZGUpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBTdXBlcmFnZW50IHRpbWVvdXRcbiAgICBpZiAoZXJyLnRpbWVvdXQgJiYgZXJyLmNvZGUgPT0gJ0VDT05OQUJPUlRFRCcpIHJldHVybiB0cnVlO1xuICAgIGlmIChlcnIuY3Jvc3NEb21haW4pIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0cnkgcmVxdWVzdFxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9yZXRyeSA9IGZ1bmN0aW9uKCkge1xuXG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG5cbiAgLy8gbm9kZVxuICBpZiAodGhpcy5yZXEpIHtcbiAgICB0aGlzLnJlcSA9IG51bGw7XG4gICAgdGhpcy5yZXEgPSB0aGlzLnJlcXVlc3QoKTtcbiAgfVxuXG4gIHRoaXMuX2Fib3J0ZWQgPSBmYWxzZTtcbiAgdGhpcy50aW1lZG91dCA9IGZhbHNlO1xuXG4gIHJldHVybiB0aGlzLl9lbmQoKTtcbn07XG5cbi8qKlxuICogUHJvbWlzZSBzdXBwb3J0XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlamVjdF1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiB0aGVuKHJlc29sdmUsIHJlamVjdCkge1xuICBpZiAoIXRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLl9lbmRDYWxsZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IHN1cGVyYWdlbnQgcmVxdWVzdCB3YXMgc2VudCB0d2ljZSwgYmVjYXVzZSBib3RoIC5lbmQoKSBhbmQgLnRoZW4oKSB3ZXJlIGNhbGxlZC4gTmV2ZXIgY2FsbCAuZW5kKCkgaWYgeW91IHVzZSBwcm9taXNlc1wiKTtcbiAgICB9XG4gICAgdGhpcy5fZnVsbGZpbGxlZFByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihpbm5lclJlc29sdmUsIGlubmVyUmVqZWN0KSB7XG4gICAgICBzZWxmLmVuZChmdW5jdGlvbihlcnIsIHJlcykge1xuICAgICAgICBpZiAoZXJyKSBpbm5lclJlamVjdChlcnIpO1xuICAgICAgICBlbHNlIGlubmVyUmVzb2x2ZShyZXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uKGNiKSB7XG4gIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBjYik7XG59O1xuXG4vKipcbiAqIEFsbG93IGZvciBleHRlbnNpb25cbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZuKSB7XG4gIGZuKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5vayA9IGZ1bmN0aW9uKGNiKSB7XG4gIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgY2IpIHRocm93IEVycm9yKFwiQ2FsbGJhY2sgcmVxdWlyZWRcIik7XG4gIHRoaXMuX29rQ2FsbGJhY2sgPSBjYjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2lzUmVzcG9uc2VPSyA9IGZ1bmN0aW9uKHJlcykge1xuICBpZiAoIXJlcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl9va0NhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX29rQ2FsbGJhY2socmVzKTtcbiAgfVxuXG4gIHJldHVybiByZXMuc3RhdHVzID49IDIwMCAmJiByZXMuc3RhdHVzIDwgMzAwO1xufTtcblxuLyoqXG4gKiBHZXQgcmVxdWVzdCBoZWFkZXIgYGZpZWxkYC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihmaWVsZCl7XG4gIHJldHVybiB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGhlYWRlciBgZmllbGRgIHZhbHVlLlxuICogVGhpcyBpcyBhIGRlcHJlY2F0ZWQgaW50ZXJuYWwgQVBJLiBVc2UgYC5nZXQoZmllbGQpYCBpbnN0ZWFkLlxuICpcbiAqIChnZXRIZWFkZXIgaXMgbm8gbG9uZ2VyIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgc3VwZXJhZ2VudCBjb2RlIGJhc2UpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBkZXByZWNhdGVkXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmdldEhlYWRlciA9IFJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXQ7XG5cbi8qKlxuICogU2V0IGhlYWRlciBgZmllbGRgIHRvIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0LlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuc2V0KCdYLUFQSS1LZXknLCAnZm9vYmFyJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoeyBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJywgJ1gtQVBJLUtleSc6ICdmb29iYXInIH0pXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihmaWVsZCwgdmFsKXtcbiAgaWYgKGlzT2JqZWN0KGZpZWxkKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBmaWVsZCkge1xuICAgICAgdGhpcy5zZXQoa2V5LCBmaWVsZFtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldID0gdmFsO1xuICB0aGlzLmhlYWRlcltmaWVsZF0gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgaGVhZGVyIGBmaWVsZGAuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAudW5zZXQoJ1VzZXItQWdlbnQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbihmaWVsZCl7XG4gIGRlbGV0ZSB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG4gIGRlbGV0ZSB0aGlzLmhlYWRlcltmaWVsZF07XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXcml0ZSB0aGUgZmllbGQgYG5hbWVgIGFuZCBgdmFsYCwgb3IgbXVsdGlwbGUgZmllbGRzIHdpdGggb25lIG9iamVjdFxuICogZm9yIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiIHJlcXVlc3QgYm9kaWVzLlxuICpcbiAqIGBgYCBqc1xuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmZpZWxkKCdmb28nLCAnYmFyJylcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmZpZWxkKHsgZm9vOiAnYmFyJywgYmF6OiAncXV4JyB9KVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd8QmxvYnxGaWxlfEJ1ZmZlcnxmcy5SZWFkU3RyZWFtfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLmZpZWxkID0gZnVuY3Rpb24obmFtZSwgdmFsKSB7XG4gIC8vIG5hbWUgc2hvdWxkIGJlIGVpdGhlciBhIHN0cmluZyBvciBhbiBvYmplY3QuXG4gIGlmIChudWxsID09PSBuYW1lIHx8IHVuZGVmaW5lZCA9PT0gbmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignLmZpZWxkKG5hbWUsIHZhbCkgbmFtZSBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICBpZiAodGhpcy5fZGF0YSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCIuZmllbGQoKSBjYW4ndCBiZSB1c2VkIGlmIC5zZW5kKCkgaXMgdXNlZC4gUGxlYXNlIHVzZSBvbmx5IC5zZW5kKCkgb3Igb25seSAuZmllbGQoKSAmIC5hdHRhY2goKVwiKTtcbiAgfVxuXG4gIGlmIChpc09iamVjdChuYW1lKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG4gICAgICB0aGlzLmZpZWxkKGtleSwgbmFtZVtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgZm9yICh2YXIgaSBpbiB2YWwpIHtcbiAgICAgIHRoaXMuZmllbGQobmFtZSwgdmFsW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB2YWwgc2hvdWxkIGJlIGRlZmluZWQgbm93XG4gIGlmIChudWxsID09PSB2YWwgfHwgdW5kZWZpbmVkID09PSB2YWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJy5maWVsZChuYW1lLCB2YWwpIHZhbCBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gIH1cbiAgaWYgKCdib29sZWFuJyA9PT0gdHlwZW9mIHZhbCkge1xuICAgIHZhbCA9ICcnICsgdmFsO1xuICB9XG4gIHRoaXMuX2dldEZvcm1EYXRhKCkuYXBwZW5kKG5hbWUsIHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBYm9ydCB0aGUgcmVxdWVzdCwgYW5kIGNsZWFyIHBvdGVudGlhbCB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuX2Fib3J0ZWQgPSB0cnVlO1xuICB0aGlzLnhociAmJiB0aGlzLnhoci5hYm9ydCgpOyAvLyBicm93c2VyXG4gIHRoaXMucmVxICYmIHRoaXMucmVxLmFib3J0KCk7IC8vIG5vZGVcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgdGhpcy5lbWl0KCdhYm9ydCcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fYXV0aCA9IGZ1bmN0aW9uKHVzZXIsIHBhc3MsIG9wdGlvbnMsIGJhc2U2NEVuY29kZXIpIHtcbiAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICBjYXNlICdiYXNpYyc6XG4gICAgICB0aGlzLnNldCgnQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgYmFzZTY0RW5jb2Rlcih1c2VyICsgJzonICsgcGFzcykpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhdXRvJzpcbiAgICAgIHRoaXMudXNlcm5hbWUgPSB1c2VyO1xuICAgICAgdGhpcy5wYXNzd29yZCA9IHBhc3M7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JlYXJlcic6IC8vIHVzYWdlIHdvdWxkIGJlIC5hdXRoKGFjY2Vzc1Rva2VuLCB7IHR5cGU6ICdiZWFyZXInIH0pXG4gICAgICB0aGlzLnNldCgnQXV0aG9yaXphdGlvbicsICdCZWFyZXIgJyArIHVzZXIpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuYWJsZSB0cmFuc21pc3Npb24gb2YgY29va2llcyB3aXRoIHgtZG9tYWluIHJlcXVlc3RzLlxuICpcbiAqIE5vdGUgdGhhdCBmb3IgdGhpcyB0byB3b3JrIHRoZSBvcmlnaW4gbXVzdCBub3QgYmVcbiAqIHVzaW5nIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCIgd2l0aCBhIHdpbGRjYXJkLFxuICogYW5kIGFsc28gbXVzdCBzZXQgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsc1wiXG4gKiB0byBcInRydWVcIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS53aXRoQ3JlZGVudGlhbHMgPSBmdW5jdGlvbihvbikge1xuICAvLyBUaGlzIGlzIGJyb3dzZXItb25seSBmdW5jdGlvbmFsaXR5LiBOb2RlIHNpZGUgaXMgbm8tb3AuXG4gIGlmIChvbiA9PSB1bmRlZmluZWQpIG9uID0gdHJ1ZTtcbiAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gb247XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heCByZWRpcmVjdHMgdG8gYG5gLiBEb2VzIG5vdGluZyBpbiBicm93c2VyIFhIUiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZWRpcmVjdHMgPSBmdW5jdGlvbihuKXtcbiAgdGhpcy5fbWF4UmVkaXJlY3RzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1heGltdW0gc2l6ZSBvZiBidWZmZXJlZCByZXNwb25zZSBib2R5LCBpbiBieXRlcy4gQ291bnRzIHVuY29tcHJlc3NlZCBzaXplLlxuICogRGVmYXVsdCAyMDBNQi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5tYXhSZXNwb25zZVNpemUgPSBmdW5jdGlvbihuKXtcbiAgaWYgKCdudW1iZXInICE9PSB0eXBlb2Ygbikge1xuICAgIHRocm93IFR5cGVFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIik7XG4gIH1cbiAgdGhpcy5fbWF4UmVzcG9uc2VTaXplID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdG8gYSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdCAobm90IEpTT04gc3RyaW5nKSBvZiBzY2FsYXIgcHJvcGVydGllcy5cbiAqIE5vdGUgYXMgdGhpcyBtZXRob2QgaXMgZGVzaWduZWQgdG8gcmV0dXJuIGEgdXNlZnVsIG5vbi10aGlzIHZhbHVlLFxuICogaXQgY2Fubm90IGJlIGNoYWluZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBkZXNjcmliaW5nIG1ldGhvZCwgdXJsLCBhbmQgZGF0YSBvZiB0aGlzIHJlcXVlc3RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgdXJsOiB0aGlzLnVybCxcbiAgICBkYXRhOiB0aGlzLl9kYXRhLFxuICAgIGhlYWRlcnM6IHRoaXMuX2hlYWRlcixcbiAgfTtcbn07XG5cbi8qKlxuICogU2VuZCBgZGF0YWAgYXMgdGhlIHJlcXVlc3QgYm9keSwgZGVmYXVsdGluZyB0aGUgYC50eXBlKClgIHRvIFwianNvblwiIHdoZW5cbiAqIGFuIG9iamVjdCBpcyBnaXZlbi5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgICAvLyBtYW51YWwganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdqc29uJylcbiAqICAgICAgICAgLnNlbmQoJ3tcIm5hbWVcIjpcInRqXCJ9JylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIGpzb25cbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBtYW51YWwgeC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCgnbmFtZT10aicpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGRlZmF1bHRzIHRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCgnbmFtZT10b2JpJylcbiAqICAgICAgICAuc2VuZCgnc3BlY2llcz1mZXJyZXQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKXtcbiAgdmFyIGlzT2JqID0gaXNPYmplY3QoZGF0YSk7XG4gIHZhciB0eXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcblxuICBpZiAodGhpcy5fZm9ybURhdGEpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiLnNlbmQoKSBjYW4ndCBiZSB1c2VkIGlmIC5hdHRhY2goKSBvciAuZmllbGQoKSBpcyB1c2VkLiBQbGVhc2UgdXNlIG9ubHkgLnNlbmQoKSBvciBvbmx5IC5maWVsZCgpICYgLmF0dGFjaCgpXCIpO1xuICB9XG5cbiAgaWYgKGlzT2JqICYmICF0aGlzLl9kYXRhKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc0hvc3QoZGF0YSkpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB7fTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGF0YSAmJiB0aGlzLl9kYXRhICYmIHRoaXMuX2lzSG9zdCh0aGlzLl9kYXRhKSkge1xuICAgIHRocm93IEVycm9yKFwiQ2FuJ3QgbWVyZ2UgdGhlc2Ugc2VuZCBjYWxsc1wiKTtcbiAgfVxuXG4gIC8vIG1lcmdlXG4gIGlmIChpc09iaiAmJiBpc09iamVjdCh0aGlzLl9kYXRhKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhW2tleV0gPSBkYXRhW2tleV07XG4gICAgfVxuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBkYXRhKSB7XG4gICAgLy8gZGVmYXVsdCB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAgICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnZm9ybScpO1xuICAgIHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICAgIGlmICgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyA9PSB0eXBlKSB7XG4gICAgICB0aGlzLl9kYXRhID0gdGhpcy5fZGF0YVxuICAgICAgICA/IHRoaXMuX2RhdGEgKyAnJicgKyBkYXRhXG4gICAgICAgIDogZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGF0YSA9ICh0aGlzLl9kYXRhIHx8ICcnKSArIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9XG5cbiAgaWYgKCFpc09iaiB8fCB0aGlzLl9pc0hvc3QoZGF0YSkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGRlZmF1bHQgdG8ganNvblxuICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnanNvbicpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU29ydCBgcXVlcnlzdHJpbmdgIGJ5IHRoZSBzb3J0IGZ1bmN0aW9uXG4gKlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgIC8vIGRlZmF1bHQgb3JkZXJcbiAqICAgICAgIHJlcXVlc3QuZ2V0KCcvdXNlcicpXG4gKiAgICAgICAgIC5xdWVyeSgnbmFtZT1OaWNrJylcbiAqICAgICAgICAgLnF1ZXJ5KCdzZWFyY2g9TWFubnknKVxuICogICAgICAgICAuc29ydFF1ZXJ5KClcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBjdXN0b21pemVkIHNvcnQgZnVuY3Rpb25cbiAqICAgICAgIHJlcXVlc3QuZ2V0KCcvdXNlcicpXG4gKiAgICAgICAgIC5xdWVyeSgnbmFtZT1OaWNrJylcbiAqICAgICAgICAgLnF1ZXJ5KCdzZWFyY2g9TWFubnknKVxuICogICAgICAgICAuc29ydFF1ZXJ5KGZ1bmN0aW9uKGEsIGIpe1xuICogICAgICAgICAgIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICogICAgICAgICB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzb3J0XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNvcnRRdWVyeSA9IGZ1bmN0aW9uKHNvcnQpIHtcbiAgLy8gX3NvcnQgZGVmYXVsdCB0byB0cnVlIGJ1dCBvdGhlcndpc2UgY2FuIGJlIGEgZnVuY3Rpb24gb3IgYm9vbGVhblxuICB0aGlzLl9zb3J0ID0gdHlwZW9mIHNvcnQgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IHNvcnQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb21wb3NlIHF1ZXJ5c3RyaW5nIHRvIGFwcGVuZCB0byByZXEudXJsXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fZmluYWxpemVRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBxdWVyeSA9IHRoaXMuX3F1ZXJ5LmpvaW4oJyYnKTtcbiAgaWYgKHF1ZXJ5KSB7XG4gICAgdGhpcy51cmwgKz0gKHRoaXMudXJsLmluZGV4T2YoJz8nKSA+PSAwID8gJyYnIDogJz8nKSArIHF1ZXJ5O1xuICB9XG4gIHRoaXMuX3F1ZXJ5Lmxlbmd0aCA9IDA7IC8vIE1ha2VzIHRoZSBjYWxsIGlkZW1wb3RlbnRcblxuICBpZiAodGhpcy5fc29ydCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMudXJsLmluZGV4T2YoJz8nKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIHF1ZXJ5QXJyID0gdGhpcy51cmwuc3Vic3RyaW5nKGluZGV4ICsgMSkuc3BsaXQoJyYnKTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdGhpcy5fc29ydCkge1xuICAgICAgICBxdWVyeUFyci5zb3J0KHRoaXMuX3NvcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnlBcnIuc29ydCgpO1xuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSB0aGlzLnVybC5zdWJzdHJpbmcoMCwgaW5kZXgpICsgJz8nICsgcXVlcnlBcnIuam9pbignJicpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRm9yIGJhY2t3YXJkcyBjb21wYXQgb25seVxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9hcHBlbmRRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKCkge2NvbnNvbGUudHJhY2UoXCJVbnN1cHBvcnRlZFwiKTt9XG5cbi8qKlxuICogSW52b2tlIGNhbGxiYWNrIHdpdGggdGltZW91dCBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3RpbWVvdXRFcnJvciA9IGZ1bmN0aW9uKHJlYXNvbiwgdGltZW91dCwgZXJybm8pe1xuICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZXJyID0gbmV3IEVycm9yKHJlYXNvbiArIHRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnKTtcbiAgZXJyLnRpbWVvdXQgPSB0aW1lb3V0O1xuICBlcnIuY29kZSA9ICdFQ09OTkFCT1JURUQnO1xuICBlcnIuZXJybm8gPSBlcnJubztcbiAgdGhpcy50aW1lZG91dCA9IHRydWU7XG4gIHRoaXMuYWJvcnQoKTtcbiAgdGhpcy5jYWxsYmFjayhlcnIpO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9zZXRUaW1lb3V0cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gZGVhZGxpbmVcbiAgaWYgKHRoaXMuX3RpbWVvdXQgJiYgIXRoaXMuX3RpbWVyKSB7XG4gICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBzZWxmLl90aW1lb3V0RXJyb3IoJ1RpbWVvdXQgb2YgJywgc2VsZi5fdGltZW91dCwgJ0VUSU1FJyk7XG4gICAgfSwgdGhpcy5fdGltZW91dCk7XG4gIH1cbiAgLy8gcmVzcG9uc2UgdGltZW91dFxuICBpZiAodGhpcy5fcmVzcG9uc2VUaW1lb3V0ICYmICF0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lcikge1xuICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgc2VsZi5fdGltZW91dEVycm9yKCdSZXNwb25zZSB0aW1lb3V0IG9mICcsIHNlbGYuX3Jlc3BvbnNlVGltZW91dCwgJ0VUSU1FRE9VVCcpO1xuICAgIH0sIHRoaXMuX3Jlc3BvbnNlVGltZW91dCk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogRXhwb3NlIGBSZXNwb25zZUJhc2VgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVzcG9uc2VCYXNlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlQmFzZWAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXNwb25zZUJhc2Uob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufVxuXG4vKipcbiAqIE1peGluIHRoZSBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIFJlc3BvbnNlQmFzZS5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IFJlc3BvbnNlQmFzZS5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGBmaWVsZGAgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlc3BvbnNlQmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIHRoaXMuaGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBTZXQgaGVhZGVyIHJlbGF0ZWQgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYC50eXBlYCB0aGUgY29udGVudCB0eXBlIHdpdGhvdXQgcGFyYW1zXG4gKlxuICogQSByZXNwb25zZSBvZiBcIkNvbnRlbnQtVHlwZTogdGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gKiB3aWxsIHByb3ZpZGUgeW91IHdpdGggYSBgLnR5cGVgIG9mIFwidGV4dC9wbGFpblwiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlQmFzZS5wcm90b3R5cGUuX3NldEhlYWRlclByb3BlcnRpZXMgPSBmdW5jdGlvbihoZWFkZXIpe1xuICAgIC8vIFRPRE86IG1vYXIhXG4gICAgLy8gVE9ETzogbWFrZSB0aGlzIGEgdXRpbFxuXG4gICAgLy8gY29udGVudC10eXBlXG4gICAgdmFyIGN0ID0gaGVhZGVyWydjb250ZW50LXR5cGUnXSB8fCAnJztcbiAgICB0aGlzLnR5cGUgPSB1dGlscy50eXBlKGN0KTtcblxuICAgIC8vIHBhcmFtc1xuICAgIHZhciBwYXJhbXMgPSB1dGlscy5wYXJhbXMoY3QpO1xuICAgIGZvciAodmFyIGtleSBpbiBwYXJhbXMpIHRoaXNba2V5XSA9IHBhcmFtc1trZXldO1xuXG4gICAgdGhpcy5saW5rcyA9IHt9O1xuXG4gICAgLy8gbGlua3NcbiAgICB0cnkge1xuICAgICAgICBpZiAoaGVhZGVyLmxpbmspIHtcbiAgICAgICAgICAgIHRoaXMubGlua3MgPSB1dGlscy5wYXJzZUxpbmtzKGhlYWRlci5saW5rKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCBmbGFncyBzdWNoIGFzIGAub2tgIGJhc2VkIG9uIGBzdGF0dXNgLlxuICpcbiAqIEZvciBleGFtcGxlIGEgMnh4IHJlc3BvbnNlIHdpbGwgZ2l2ZSB5b3UgYSBgLm9rYCBvZiBfX3RydWVfX1xuICogd2hlcmVhcyA1eHggd2lsbCBiZSBfX2ZhbHNlX18gYW5kIGAuZXJyb3JgIHdpbGwgYmUgX190cnVlX18uIFRoZVxuICogYC5jbGllbnRFcnJvcmAgYW5kIGAuc2VydmVyRXJyb3JgIGFyZSBhbHNvIGF2YWlsYWJsZSB0byBiZSBtb3JlXG4gKiBzcGVjaWZpYywgYW5kIGAuc3RhdHVzVHlwZWAgaXMgdGhlIGNsYXNzIG9mIGVycm9yIHJhbmdpbmcgZnJvbSAxLi41XG4gKiBzb21ldGltZXMgdXNlZnVsIGZvciBtYXBwaW5nIHJlc3BvbmQgY29sb3JzIGV0Yy5cbiAqXG4gKiBcInN1Z2FyXCIgcHJvcGVydGllcyBhcmUgYWxzbyBkZWZpbmVkIGZvciBjb21tb24gY2FzZXMuIEN1cnJlbnRseSBwcm92aWRpbmc6XG4gKlxuICogICAtIC5ub0NvbnRlbnRcbiAqICAgLSAuYmFkUmVxdWVzdFxuICogICAtIC51bmF1dGhvcml6ZWRcbiAqICAgLSAubm90QWNjZXB0YWJsZVxuICogICAtIC5ub3RGb3VuZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlQmFzZS5wcm90b3R5cGUuX3NldFN0YXR1c1Byb3BlcnRpZXMgPSBmdW5jdGlvbihzdGF0dXMpe1xuICAgIHZhciB0eXBlID0gc3RhdHVzIC8gMTAwIHwgMDtcblxuICAgIC8vIHN0YXR1cyAvIGNsYXNzXG4gICAgdGhpcy5zdGF0dXMgPSB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXM7XG4gICAgdGhpcy5zdGF0dXNUeXBlID0gdHlwZTtcblxuICAgIC8vIGJhc2ljc1xuICAgIHRoaXMuaW5mbyA9IDEgPT0gdHlwZTtcbiAgICB0aGlzLm9rID0gMiA9PSB0eXBlO1xuICAgIHRoaXMucmVkaXJlY3QgPSAzID09IHR5cGU7XG4gICAgdGhpcy5jbGllbnRFcnJvciA9IDQgPT0gdHlwZTtcbiAgICB0aGlzLnNlcnZlckVycm9yID0gNSA9PSB0eXBlO1xuICAgIHRoaXMuZXJyb3IgPSAoNCA9PSB0eXBlIHx8IDUgPT0gdHlwZSlcbiAgICAgICAgPyB0aGlzLnRvRXJyb3IoKVxuICAgICAgICA6IGZhbHNlO1xuXG4gICAgLy8gc3VnYXJcbiAgICB0aGlzLmNyZWF0ZWQgPSAyMDEgPT0gc3RhdHVzO1xuICAgIHRoaXMuYWNjZXB0ZWQgPSAyMDIgPT0gc3RhdHVzO1xuICAgIHRoaXMubm9Db250ZW50ID0gMjA0ID09IHN0YXR1cztcbiAgICB0aGlzLmJhZFJlcXVlc3QgPSA0MDAgPT0gc3RhdHVzO1xuICAgIHRoaXMudW5hdXRob3JpemVkID0gNDAxID09IHN0YXR1cztcbiAgICB0aGlzLm5vdEFjY2VwdGFibGUgPSA0MDYgPT0gc3RhdHVzO1xuICAgIHRoaXMuZm9yYmlkZGVuID0gNDAzID09IHN0YXR1cztcbiAgICB0aGlzLm5vdEZvdW5kID0gNDA0ID09IHN0YXR1cztcbiAgICB0aGlzLnVucHJvY2Vzc2FibGVFbnRpdHkgPSA0MjIgPT0gc3RhdHVzO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy54b3IgPSBleHBvcnRzLnhub3IgPSBleHBvcnRzLnRvU3RyaW5nID0gZXhwb3J0cy50b0Jvb2xlYW4gPSBleHBvcnRzLnJlZHVjZVhvciA9IGV4cG9ydHMucmVkdWNlWG5vciA9IGV4cG9ydHMucmVkdWNlT3IgPSBleHBvcnRzLnJlZHVjZU5vciA9IGV4cG9ydHMucmVkdWNlTmFuZCA9IGV4cG9ydHMucmVkdWNlQW5kID0gZXhwb3J0cy5vciA9IGV4cG9ydHMubm90ID0gZXhwb3J0cy5ub3IgPSBleHBvcnRzLm5hbmQgPSBleHBvcnRzLmNpcmN1bGFyU2hpZnRSaWdodCA9IGV4cG9ydHMuY2lyY3VsYXJTaGlmdExlZnQgPSBleHBvcnRzLmFuZCA9IHZvaWQgMDtcbnZhciBhbmRfMSA9IHJlcXVpcmUoXCIuL2FuZFwiKTtcbmV4cG9ydHMuYW5kID0gYW5kXzEuZGVmYXVsdDtcbnZhciBjaXJjdWxhcl9zaGlmdF9sZWZ0XzEgPSByZXF1aXJlKFwiLi9jaXJjdWxhci1zaGlmdC1sZWZ0XCIpO1xuZXhwb3J0cy5jaXJjdWxhclNoaWZ0TGVmdCA9IGNpcmN1bGFyX3NoaWZ0X2xlZnRfMS5kZWZhdWx0O1xudmFyIGNpcmN1bGFyX3NoaWZ0X3JpZ2h0XzEgPSByZXF1aXJlKFwiLi9jaXJjdWxhci1zaGlmdC1yaWdodFwiKTtcbmV4cG9ydHMuY2lyY3VsYXJTaGlmdFJpZ2h0ID0gY2lyY3VsYXJfc2hpZnRfcmlnaHRfMS5kZWZhdWx0O1xudmFyIG5hbmRfMSA9IHJlcXVpcmUoXCIuL25hbmRcIik7XG5leHBvcnRzLm5hbmQgPSBuYW5kXzEuZGVmYXVsdDtcbnZhciBub3JfMSA9IHJlcXVpcmUoXCIuL25vclwiKTtcbmV4cG9ydHMubm9yID0gbm9yXzEuZGVmYXVsdDtcbnZhciBub3RfMSA9IHJlcXVpcmUoXCIuL25vdFwiKTtcbmV4cG9ydHMubm90ID0gbm90XzEuZGVmYXVsdDtcbnZhciBvcl8xID0gcmVxdWlyZShcIi4vb3JcIik7XG5leHBvcnRzLm9yID0gb3JfMS5kZWZhdWx0O1xudmFyIHJlZHVjZV9hbmRfMSA9IHJlcXVpcmUoXCIuL3JlZHVjZS1hbmRcIik7XG5leHBvcnRzLnJlZHVjZUFuZCA9IHJlZHVjZV9hbmRfMS5kZWZhdWx0O1xudmFyIHJlZHVjZV9uYW5kXzEgPSByZXF1aXJlKFwiLi9yZWR1Y2UtbmFuZFwiKTtcbmV4cG9ydHMucmVkdWNlTmFuZCA9IHJlZHVjZV9uYW5kXzEuZGVmYXVsdDtcbnZhciByZWR1Y2Vfbm9yXzEgPSByZXF1aXJlKFwiLi9yZWR1Y2Utbm9yXCIpO1xuZXhwb3J0cy5yZWR1Y2VOb3IgPSByZWR1Y2Vfbm9yXzEuZGVmYXVsdDtcbnZhciByZWR1Y2Vfb3JfMSA9IHJlcXVpcmUoXCIuL3JlZHVjZS1vclwiKTtcbmV4cG9ydHMucmVkdWNlT3IgPSByZWR1Y2Vfb3JfMS5kZWZhdWx0O1xudmFyIHJlZHVjZV94bm9yXzEgPSByZXF1aXJlKFwiLi9yZWR1Y2UteG5vclwiKTtcbmV4cG9ydHMucmVkdWNlWG5vciA9IHJlZHVjZV94bm9yXzEuZGVmYXVsdDtcbnZhciByZWR1Y2VfeG9yXzEgPSByZXF1aXJlKFwiLi9yZWR1Y2UteG9yXCIpO1xuZXhwb3J0cy5yZWR1Y2VYb3IgPSByZWR1Y2VfeG9yXzEuZGVmYXVsdDtcbnZhciB0b19ib29sZWFuXzEgPSByZXF1aXJlKFwiLi90by1ib29sZWFuXCIpO1xuZXhwb3J0cy50b0Jvb2xlYW4gPSB0b19ib29sZWFuXzEuZGVmYXVsdDtcbnZhciB0b19zdHJpbmdfMSA9IHJlcXVpcmUoXCIuL3RvLXN0cmluZ1wiKTtcbmV4cG9ydHMudG9TdHJpbmcgPSB0b19zdHJpbmdfMS5kZWZhdWx0O1xudmFyIHhub3JfMSA9IHJlcXVpcmUoXCIuL3hub3JcIik7XG5leHBvcnRzLnhub3IgPSB4bm9yXzEuZGVmYXVsdDtcbnZhciB4b3JfMSA9IHJlcXVpcmUoXCIuL3hvclwiKTtcbmV4cG9ydHMueG9yID0geG9yXzEuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBhbmQ6IGFuZF8xLmRlZmF1bHQsXG4gICAgY2lyY3VsYXJTaGlmdExlZnQ6IGNpcmN1bGFyX3NoaWZ0X2xlZnRfMS5kZWZhdWx0LFxuICAgIGNpcmN1bGFyU2hpZnRSaWdodDogY2lyY3VsYXJfc2hpZnRfcmlnaHRfMS5kZWZhdWx0LFxuICAgIG5hbmQ6IG5hbmRfMS5kZWZhdWx0LFxuICAgIG5vcjogbm9yXzEuZGVmYXVsdCxcbiAgICBub3Q6IG5vdF8xLmRlZmF1bHQsXG4gICAgb3I6IG9yXzEuZGVmYXVsdCxcbiAgICByZWR1Y2VBbmQ6IHJlZHVjZV9hbmRfMS5kZWZhdWx0LFxuICAgIHJlZHVjZU5hbmQ6IHJlZHVjZV9uYW5kXzEuZGVmYXVsdCxcbiAgICByZWR1Y2VOb3I6IHJlZHVjZV9ub3JfMS5kZWZhdWx0LFxuICAgIHJlZHVjZU9yOiByZWR1Y2Vfb3JfMS5kZWZhdWx0LFxuICAgIHJlZHVjZVhub3I6IHJlZHVjZV94bm9yXzEuZGVmYXVsdCxcbiAgICByZWR1Y2VYb3I6IHJlZHVjZV94b3JfMS5kZWZhdWx0LFxuICAgIHRvQm9vbGVhbjogdG9fYm9vbGVhbl8xLmRlZmF1bHQsXG4gICAgdG9TdHJpbmc6IHRvX3N0cmluZ18xLmRlZmF1bHQsXG4gICAgeG5vcjogeG5vcl8xLmRlZmF1bHQsXG4gICAgeG9yOiB4b3JfMS5kZWZhdWx0LFxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b2dnbGVCaXQgPSBleHBvcnRzLnNldEJpdCA9IGV4cG9ydHMuZ2V0Qml0ID0gdm9pZCAwO1xudmFyIGdldF9iaXRfMSA9IHJlcXVpcmUoXCIuL2dldC1iaXRcIik7XG5leHBvcnRzLmdldEJpdCA9IGdldF9iaXRfMS5kZWZhdWx0O1xudmFyIHNldF9iaXRfMSA9IHJlcXVpcmUoXCIuL3NldC1iaXRcIik7XG5leHBvcnRzLnNldEJpdCA9IHNldF9iaXRfMS5kZWZhdWx0O1xudmFyIHRvZ2dsZV9iaXRfMSA9IHJlcXVpcmUoXCIuL3RvZ2dsZS1iaXRcIik7XG5leHBvcnRzLnRvZ2dsZUJpdCA9IHRvZ2dsZV9iaXRfMS5kZWZhdWx0O1xuZXhwb3J0cy5kZWZhdWx0ID0geyBnZXRCaXQ6IGdldF9iaXRfMS5kZWZhdWx0LCBzZXRCaXQ6IHNldF9iaXRfMS5kZWZhdWx0LCB0b2dnbGVCaXQ6IHRvZ2dsZV9iaXRfMS5kZWZhdWx0IH07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud3JpdGUgPSBleHBvcnRzLnJlYWQgPSB2b2lkIDA7XG52YXIgcmVhZF8xID0gcmVxdWlyZShcIi4vcmVhZFwiKTtcbmV4cG9ydHMucmVhZCA9IHJlYWRfMS5kZWZhdWx0O1xudmFyIHdyaXRlXzEgPSByZXF1aXJlKFwiLi93cml0ZVwiKTtcbmV4cG9ydHMud3JpdGUgPSB3cml0ZV8xLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSB7IHJlYWQ6IHJlYWRfMS5kZWZhdWx0LCB3cml0ZTogd3JpdGVfMS5kZWZhdWx0IH07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9CaXRzID0gdm9pZCAwO1xudmFyIHRvX2JpdHNfMSA9IHJlcXVpcmUoXCIuL3RvLWJpdHNcIik7XG5leHBvcnRzLnRvQml0cyA9IHRvX2JpdHNfMS5kZWZhdWx0O1xuZXhwb3J0cy5kZWZhdWx0ID0geyB0b0JpdHM6IHRvX2JpdHNfMS5kZWZhdWx0IH07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud3JpdGUgPSBleHBvcnRzLnJlYWQgPSB2b2lkIDA7XG52YXIgcmVhZF8xID0gcmVxdWlyZShcIi4vcmVhZFwiKTtcbmV4cG9ydHMucmVhZCA9IHJlYWRfMS5kZWZhdWx0O1xudmFyIHdyaXRlXzEgPSByZXF1aXJlKFwiLi93cml0ZVwiKTtcbmV4cG9ydHMud3JpdGUgPSB3cml0ZV8xLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSB7IHJlYWQ6IHJlYWRfMS5kZWZhdWx0LCB3cml0ZTogd3JpdGVfMS5kZWZhdWx0IH07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMueG9yID0gZXhwb3J0cy54bm9yID0gZXhwb3J0cy5yZWFkVUludCA9IGV4cG9ydHMucmVhZEludCA9IGV4cG9ydHMucmVhZCA9IGV4cG9ydHMub3IgPSBleHBvcnRzLm5vdCA9IGV4cG9ydHMubm9yID0gZXhwb3J0cy5uYW5kID0gZXhwb3J0cy5tb2RpZnkgPSBleHBvcnRzLmNyZWF0ZSA9IGV4cG9ydHMuYW5kID0gdm9pZCAwO1xudmFyIGFuZF8xID0gcmVxdWlyZShcIi4vYW5kXCIpO1xuZXhwb3J0cy5hbmQgPSBhbmRfMS5kZWZhdWx0O1xudmFyIGNyZWF0ZV8xID0gcmVxdWlyZShcIi4vY3JlYXRlXCIpO1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGVfMS5kZWZhdWx0O1xudmFyIG1vZGlmeV8xID0gcmVxdWlyZShcIi4vbW9kaWZ5XCIpO1xuZXhwb3J0cy5tb2RpZnkgPSBtb2RpZnlfMS5kZWZhdWx0O1xudmFyIG5hbmRfMSA9IHJlcXVpcmUoXCIuL25hbmRcIik7XG5leHBvcnRzLm5hbmQgPSBuYW5kXzEuZGVmYXVsdDtcbnZhciBub3JfMSA9IHJlcXVpcmUoXCIuL25vclwiKTtcbmV4cG9ydHMubm9yID0gbm9yXzEuZGVmYXVsdDtcbnZhciBub3RfMSA9IHJlcXVpcmUoXCIuL25vdFwiKTtcbmV4cG9ydHMubm90ID0gbm90XzEuZGVmYXVsdDtcbnZhciBvcl8xID0gcmVxdWlyZShcIi4vb3JcIik7XG5leHBvcnRzLm9yID0gb3JfMS5kZWZhdWx0O1xudmFyIHJlYWRfMSA9IHJlcXVpcmUoXCIuL3JlYWRcIik7XG5leHBvcnRzLnJlYWQgPSByZWFkXzEuZGVmYXVsdDtcbnZhciByZWFkX2ludF8xID0gcmVxdWlyZShcIi4vcmVhZC1pbnRcIik7XG5leHBvcnRzLnJlYWRJbnQgPSByZWFkX2ludF8xLmRlZmF1bHQ7XG52YXIgcmVhZF91X2ludF8xID0gcmVxdWlyZShcIi4vcmVhZC11LWludFwiKTtcbmV4cG9ydHMucmVhZFVJbnQgPSByZWFkX3VfaW50XzEuZGVmYXVsdDtcbnZhciB4bm9yXzEgPSByZXF1aXJlKFwiLi94bm9yXCIpO1xuZXhwb3J0cy54bm9yID0geG5vcl8xLmRlZmF1bHQ7XG52YXIgeG9yXzEgPSByZXF1aXJlKFwiLi94b3JcIik7XG5leHBvcnRzLnhvciA9IHhvcl8xLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgYW5kOiBhbmRfMS5kZWZhdWx0LFxuICAgIGNyZWF0ZTogY3JlYXRlXzEuZGVmYXVsdCxcbiAgICBtb2RpZnk6IG1vZGlmeV8xLmRlZmF1bHQsXG4gICAgbmFuZDogbmFuZF8xLmRlZmF1bHQsXG4gICAgbm9yOiBub3JfMS5kZWZhdWx0LFxuICAgIG5vdDogbm90XzEuZGVmYXVsdCxcbiAgICBvcjogb3JfMS5kZWZhdWx0LFxuICAgIHJlYWQ6IHJlYWRfMS5kZWZhdWx0LFxuICAgIHJlYWRJbnQ6IHJlYWRfaW50XzEuZGVmYXVsdCxcbiAgICByZWFkVUludDogcmVhZF91X2ludF8xLmRlZmF1bHQsXG4gICAgeG5vcjogeG5vcl8xLmRlZmF1bHQsXG4gICAgeG9yOiB4b3JfMS5kZWZhdWx0LFxufTtcbiIsIjsoZnVuY3Rpb24gKGdsb2JhbE9iamVjdCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbi8qXHJcbiAqICAgICAgYmlnbnVtYmVyLmpzIHY5LjAuMVxyXG4gKiAgICAgIEEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBhcmJpdHJhcnktcHJlY2lzaW9uIGFyaXRobWV0aWMuXHJcbiAqICAgICAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnbnVtYmVyLmpzXHJcbiAqICAgICAgQ29weXJpZ2h0IChjKSAyMDIwIE1pY2hhZWwgTWNsYXVnaGxpbiA8TThjaDg4bEBnbWFpbC5jb20+XHJcbiAqICAgICAgTUlUIExpY2Vuc2VkLlxyXG4gKlxyXG4gKiAgICAgIEJpZ051bWJlci5wcm90b3R5cGUgbWV0aG9kcyAgICAgfCAgQmlnTnVtYmVyIG1ldGhvZHNcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBhYnNvbHV0ZVZhbHVlICAgICAgICAgICAgYWJzICAgIHwgIGNsb25lXHJcbiAqICAgICAgY29tcGFyZWRUbyAgICAgICAgICAgICAgICAgICAgICB8ICBjb25maWcgICAgICAgICAgICAgICBzZXRcclxuICogICAgICBkZWNpbWFsUGxhY2VzICAgICAgICAgICAgZHAgICAgIHwgICAgICBERUNJTUFMX1BMQUNFU1xyXG4gKiAgICAgIGRpdmlkZWRCeSAgICAgICAgICAgICAgICBkaXYgICAgfCAgICAgIFJPVU5ESU5HX01PREVcclxuICogICAgICBkaXZpZGVkVG9JbnRlZ2VyQnkgICAgICAgaWRpdiAgIHwgICAgICBFWFBPTkVOVElBTF9BVFxyXG4gKiAgICAgIGV4cG9uZW50aWF0ZWRCeSAgICAgICAgICBwb3cgICAgfCAgICAgIFJBTkdFXHJcbiAqICAgICAgaW50ZWdlclZhbHVlICAgICAgICAgICAgICAgICAgICB8ICAgICAgQ1JZUFRPXHJcbiAqICAgICAgaXNFcXVhbFRvICAgICAgICAgICAgICAgIGVxICAgICB8ICAgICAgTU9EVUxPX01PREVcclxuICogICAgICBpc0Zpbml0ZSAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICBQT1dfUFJFQ0lTSU9OXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbiAgICAgICAgICAgIGd0ICAgICB8ICAgICAgRk9STUFUXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyAgIGd0ZSAgICB8ICAgICAgQUxQSEFCRVRcclxuICogICAgICBpc0ludGVnZXIgICAgICAgICAgICAgICAgICAgICAgIHwgIGlzQmlnTnVtYmVyXHJcbiAqICAgICAgaXNMZXNzVGhhbiAgICAgICAgICAgICAgIGx0ICAgICB8ICBtYXhpbXVtICAgICAgICAgICAgICBtYXhcclxuICogICAgICBpc0xlc3NUaGFuT3JFcXVhbFRvICAgICAgbHRlICAgIHwgIG1pbmltdW0gICAgICAgICAgICAgIG1pblxyXG4gKiAgICAgIGlzTmFOICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgcmFuZG9tXHJcbiAqICAgICAgaXNOZWdhdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8ICBzdW1cclxuICogICAgICBpc1Bvc2l0aXZlICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBpc1plcm8gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtaW51cyAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtb2R1bG8gICAgICAgICAgICAgICAgICAgbW9kICAgIHxcclxuICogICAgICBtdWx0aXBsaWVkQnkgICAgICAgICAgICAgdGltZXMgIHxcclxuICogICAgICBuZWdhdGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwbHVzICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwcmVjaXNpb24gICAgICAgICAgICAgICAgc2QgICAgIHxcclxuICogICAgICBzaGlmdGVkQnkgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBzcXVhcmVSb290ICAgICAgICAgICAgICAgc3FydCAgIHxcclxuICogICAgICB0b0V4cG9uZW50aWFsICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZpeGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0Zvcm1hdCAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZyYWN0aW9uICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0pTT04gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b051bWJlciAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1ByZWNpc2lvbiAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1N0cmluZyAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB2YWx1ZU9mICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICpcclxuICovXHJcblxyXG5cclxuICB2YXIgQmlnTnVtYmVyLFxyXG4gICAgaXNOdW1lcmljID0gL14tPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzplWystXT9cXGQrKT8kL2ksXHJcbiAgICBtYXRoY2VpbCA9IE1hdGguY2VpbCxcclxuICAgIG1hdGhmbG9vciA9IE1hdGguZmxvb3IsXHJcblxyXG4gICAgYmlnbnVtYmVyRXJyb3IgPSAnW0JpZ051bWJlciBFcnJvcl0gJyxcclxuICAgIHRvb01hbnlEaWdpdHMgPSBiaWdudW1iZXJFcnJvciArICdOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiAnLFxyXG5cclxuICAgIEJBU0UgPSAxZTE0LFxyXG4gICAgTE9HX0JBU0UgPSAxNCxcclxuICAgIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmLCAgICAgICAgIC8vIDJeNTMgLSAxXHJcbiAgICAvLyBNQVhfSU5UMzIgPSAweDdmZmZmZmZmLCAgICAgICAgICAgICAgICAgICAvLyAyXjMxIC0gMVxyXG4gICAgUE9XU19URU4gPSBbMSwgMTAsIDEwMCwgMWUzLCAxZTQsIDFlNSwgMWU2LCAxZTcsIDFlOCwgMWU5LCAxZTEwLCAxZTExLCAxZTEyLCAxZTEzXSxcclxuICAgIFNRUlRfQkFTRSA9IDFlNyxcclxuXHJcbiAgICAvLyBFRElUQUJMRVxyXG4gICAgLy8gVGhlIGxpbWl0IG9uIHRoZSB2YWx1ZSBvZiBERUNJTUFMX1BMQUNFUywgVE9fRVhQX05FRywgVE9fRVhQX1BPUywgTUlOX0VYUCwgTUFYX0VYUCwgYW5kXHJcbiAgICAvLyB0aGUgYXJndW1lbnRzIHRvIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0LCBhbmQgdG9QcmVjaXNpb24uXHJcbiAgICBNQVggPSAxRTk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWF9JTlQzMlxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIEJpZ051bWJlciBjb25zdHJ1Y3Rvci5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjbG9uZShjb25maWdPYmplY3QpIHtcclxuICAgIHZhciBkaXYsIGNvbnZlcnRCYXNlLCBwYXJzZU51bWVyaWMsXHJcbiAgICAgIFAgPSBCaWdOdW1iZXIucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQmlnTnVtYmVyLCB0b1N0cmluZzogbnVsbCwgdmFsdWVPZjogbnVsbCB9LFxyXG4gICAgICBPTkUgPSBuZXcgQmlnTnVtYmVyKDEpLFxyXG5cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRURJVEFCTEUgQ09ORklHIERFRkFVTFRTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZXMgYmVsb3cgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZXMgc3RhdGVkLlxyXG4gICAgICAvLyBUaGUgdmFsdWVzIGNhbiBhbHNvIGJlIGNoYW5nZWQgYXQgcnVuLXRpbWUgdXNpbmcgQmlnTnVtYmVyLnNldC5cclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3Igb3BlcmF0aW9ucyBpbnZvbHZpbmcgZGl2aXNpb24uXHJcbiAgICAgIERFQ0lNQUxfUExBQ0VTID0gMjAsICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFRoZSByb3VuZGluZyBtb2RlIHVzZWQgd2hlbiByb3VuZGluZyB0byB0aGUgYWJvdmUgZGVjaW1hbCBwbGFjZXMsIGFuZCB3aGVuIHVzaW5nXHJcbiAgICAgIC8vIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0IGFuZCB0b1ByZWNpc2lvbiwgYW5kIHJvdW5kIChkZWZhdWx0IHZhbHVlKS5cclxuICAgICAgLy8gVVAgICAgICAgICAwIEF3YXkgZnJvbSB6ZXJvLlxyXG4gICAgICAvLyBET1dOICAgICAgIDEgVG93YXJkcyB6ZXJvLlxyXG4gICAgICAvLyBDRUlMICAgICAgIDIgVG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgIC8vIEZMT09SICAgICAgMyBUb3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgLy8gSEFMRl9VUCAgICA0IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB1cC5cclxuICAgICAgLy8gSEFMRl9ET1dOICA1IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCBkb3duLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gIDYgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgZXZlbiBuZWlnaGJvdXIuXHJcbiAgICAgIC8vIEhBTEZfQ0VJTCAgNyBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfRkxPT1IgOCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIFJPVU5ESU5HX01PREUgPSA0LCAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA4XHJcblxyXG4gICAgICAvLyBFWFBPTkVOVElBTF9BVCA6IFtUT19FWFBfTkVHICwgVE9fRVhQX1BPU11cclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYmVuZWF0aCB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTdcclxuICAgICAgVE9fRVhQX05FRyA9IC03LCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIC1NQVhcclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYWJvdmUgd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IDIxXHJcbiAgICAgIFRPX0VYUF9QT1MgPSAyMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFJBTkdFIDogW01JTl9FWFAsIE1BWF9FWFBdXHJcblxyXG4gICAgICAvLyBUaGUgbWluaW11bSBleHBvbmVudCB2YWx1ZSwgYmVuZWF0aCB3aGljaCB1bmRlcmZsb3cgdG8gemVybyBvY2N1cnMuXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAtMzI0ICAoNWUtMzI0KVxyXG4gICAgICBNSU5fRVhQID0gLTFlNywgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0xIHRvIC1NQVhcclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIGV4cG9uZW50IHZhbHVlLCBhYm92ZSB3aGljaCBvdmVyZmxvdyB0byBJbmZpbml0eSBvY2N1cnMuXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAgMzA4ICAoMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpXHJcbiAgICAgIC8vIEZvciBNQVhfRVhQID4gMWU3LCBlLmcuIG5ldyBCaWdOdW1iZXIoJzFlMTAwMDAwMDAwJykucGx1cygxKSBtYXkgYmUgc2xvdy5cclxuICAgICAgTUFYX0VYUCA9IDFlNywgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxIHRvIE1BWFxyXG5cclxuICAgICAgLy8gV2hldGhlciB0byB1c2UgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiwgaWYgYXZhaWxhYmxlLlxyXG4gICAgICBDUllQVE8gPSBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgb3IgZmFsc2VcclxuXHJcbiAgICAgIC8vIFRoZSBtb2R1bG8gbW9kZSB1c2VkIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG1vZHVsdXM6IGEgbW9kIG4uXHJcbiAgICAgIC8vIFRoZSBxdW90aWVudCAocSA9IGEgLyBuKSBpcyBjYWxjdWxhdGVkIGFjY29yZGluZyB0byB0aGUgY29ycmVzcG9uZGluZyByb3VuZGluZyBtb2RlLlxyXG4gICAgICAvLyBUaGUgcmVtYWluZGVyIChyKSBpcyBjYWxjdWxhdGVkIGFzOiByID0gYSAtIG4gKiBxLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBVUCAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cclxuICAgICAgLy8gRE9XTiAgICAgIDEgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aWRlbmQuXHJcbiAgICAgIC8vICAgICAgICAgICAgIFRoaXMgbW9kdWxvIG1vZGUgaXMgY29tbW9ubHkga25vd24gYXMgJ3RydW5jYXRlZCBkaXZpc2lvbicgYW5kIGlzXHJcbiAgICAgIC8vICAgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gKGEgJSBuKSBpbiBKYXZhU2NyaXB0LlxyXG4gICAgICAvLyBGTE9PUiAgICAgMyBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpc29yIChQeXRob24gJSkuXHJcbiAgICAgIC8vIEhBTEZfRVZFTiA2IFRoaXMgbW9kdWxvIG1vZGUgaW1wbGVtZW50cyB0aGUgSUVFRSA3NTQgcmVtYWluZGVyIGZ1bmN0aW9uLlxyXG4gICAgICAvLyBFVUNMSUQgICAgOSBFdWNsaWRpYW4gZGl2aXNpb24uIHEgPSBzaWduKG4pICogZmxvb3IoYSAvIGFicyhuKSkuXHJcbiAgICAgIC8vICAgICAgICAgICAgIFRoZSByZW1haW5kZXIgaXMgYWx3YXlzIHBvc2l0aXZlLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBUaGUgdHJ1bmNhdGVkIGRpdmlzaW9uLCBmbG9vcmVkIGRpdmlzaW9uLCBFdWNsaWRpYW4gZGl2aXNpb24gYW5kIElFRUUgNzU0IHJlbWFpbmRlclxyXG4gICAgICAvLyBtb2RlcyBhcmUgY29tbW9ubHkgdXNlZCBmb3IgdGhlIG1vZHVsdXMgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBBbHRob3VnaCB0aGUgb3RoZXIgcm91bmRpbmcgbW9kZXMgY2FuIGFsc28gYmUgdXNlZCwgdGhleSBtYXkgbm90IGdpdmUgdXNlZnVsIHJlc3VsdHMuXHJcbiAgICAgIE1PRFVMT19NT0RFID0gMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5XHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSByZXN1bHQgb2YgdGhlIGV4cG9uZW50aWF0ZWRCeSBvcGVyYXRpb24uXHJcbiAgICAgIC8vIElmIFBPV19QUkVDSVNJT04gaXMgMCwgdGhlcmUgd2lsbCBiZSB1bmxpbWl0ZWQgc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICBQT1dfUFJFQ0lTSU9OID0gMCwgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZm9ybWF0IHNwZWNpZmljYXRpb24gdXNlZCBieSB0aGUgQmlnTnVtYmVyLnByb3RvdHlwZS50b0Zvcm1hdCBtZXRob2QuXHJcbiAgICAgIEZPUk1BVCA9IHtcclxuICAgICAgICBwcmVmaXg6ICcnLFxyXG4gICAgICAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAgICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgICBzdWZmaXg6ICcnXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBUaGUgYWxwaGFiZXQgdXNlZCBmb3IgYmFzZSBjb252ZXJzaW9uLiBJdCBtdXN0IGJlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyBsb25nLCB3aXRoIG5vICcrJyxcclxuICAgICAgLy8gJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgLy8gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF8nXHJcbiAgICAgIEFMUEhBQkVUID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eic7XHJcblxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgQmlnTnVtYmVyIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cclxuICAgICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmlnTnVtYmVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiB2IHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gQSBudW1lcmljIHZhbHVlLlxyXG4gICAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIHYuIEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQmlnTnVtYmVyKHYsIGIpIHtcclxuICAgICAgdmFyIGFscGhhYmV0LCBjLCBjYXNlQ2hhbmdlZCwgZSwgaSwgaXNOdW0sIGxlbiwgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBgbmV3YC5cclxuICAgICAgaWYgKCEoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikpIHJldHVybiBuZXcgQmlnTnVtYmVyKHYsIGIpO1xyXG5cclxuICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodiAmJiB2Ll9pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgeC5zID0gdi5zO1xyXG5cclxuICAgICAgICAgIGlmICghdi5jIHx8IHYuZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodi5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4LmUgPSB2LmU7XHJcbiAgICAgICAgICAgIHguYyA9IHYuYy5zbGljZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykgJiYgdiAqIDAgPT0gMCkge1xyXG5cclxuICAgICAgICAgIC8vIFVzZSBgMSAvIG5gIHRvIGhhbmRsZSBtaW51cyB6ZXJvIGFsc28uXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAodiA9IC12LCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgaW50ZWdlcnMsIHdoZXJlIG4gPCAyMTQ3NDgzNjQ4ICgyKiozMSkuXHJcbiAgICAgICAgICBpZiAodiA9PT0gfn52KSB7XHJcbiAgICAgICAgICAgIGZvciAoZSA9IDAsIGkgPSB2OyBpID49IDEwOyBpIC89IDEwLCBlKyspO1xyXG5cclxuICAgICAgICAgICAgaWYgKGUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgICAgIHguYyA9IFt2XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGlmICghaXNOdW1lcmljLnRlc3Qoc3RyID0gU3RyaW5nKHYpKSkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xyXG4gICAgICAgIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgICAgIGlmIChlIDwgMCkgZSA9IGk7XHJcbiAgICAgICAgICBlICs9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgICAgIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcblxyXG4gICAgICAgIC8vIEFsbG93IGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGJlIHVzZWQgd2l0aCBiYXNlIDEwIGFyZ3VtZW50LCB3aGlsZVxyXG4gICAgICAgIC8vIGFsc28gcm91bmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYXMgd2l0aCBvdGhlciBiYXNlcy5cclxuICAgICAgICBpZiAoYiA9PSAxMCkge1xyXG4gICAgICAgICAgeCA9IG5ldyBCaWdOdW1iZXIodik7XHJcbiAgICAgICAgICByZXR1cm4gcm91bmQoeCwgREVDSU1BTF9QTEFDRVMgKyB4LmUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuXHJcbiAgICAgICAgaWYgKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpIHtcclxuXHJcbiAgICAgICAgICAvLyBBdm9pZCBwb3RlbnRpYWwgaW50ZXJwcmV0YXRpb24gb2YgSW5maW5pdHkgYW5kIE5hTiBhcyBiYXNlIDQ0KyB2YWx1ZXMuXHJcbiAgICAgICAgICBpZiAodiAqIDAgIT0gMCkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtLCBiKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHICYmIHN0ci5yZXBsYWNlKC9eMFxcLjAqfFxcLi8sICcnKS5sZW5ndGggPiAxNSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyB2KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFscGhhYmV0ID0gQUxQSEFCRVQuc2xpY2UoMCwgYik7XHJcbiAgICAgICAgZSA9IGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBDaGVjayB0aGF0IHN0ciBpcyBhIHZhbGlkIGJhc2UgYiBudW1iZXIuXHJcbiAgICAgICAgLy8gRG9uJ3QgdXNlIFJlZ0V4cCwgc28gYWxwaGFiZXQgY2FuIGNvbnRhaW4gc3BlY2lhbCBjaGFyYWN0ZXJzLlxyXG4gICAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoYWxwaGFiZXQuaW5kZXhPZihjID0gc3RyLmNoYXJBdChpKSkgPCAwKSB7XHJcbiAgICAgICAgICAgIGlmIChjID09ICcuJykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiAnLicgaXMgbm90IHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGl0IGhhcyBub3QgYmUgZm91bmQgYmVmb3JlLlxyXG4gICAgICAgICAgICAgIGlmIChpID4gZSkge1xyXG4gICAgICAgICAgICAgICAgZSA9IGxlbjtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICghY2FzZUNoYW5nZWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQWxsb3cgZS5nLiBoZXhhZGVjaW1hbCAnRkYnIGFzIHdlbGwgYXMgJ2ZmJy5cclxuICAgICAgICAgICAgICBpZiAoc3RyID09IHN0ci50b1VwcGVyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9Mb3dlckNhc2UoKSkgfHxcclxuICAgICAgICAgICAgICAgICAgc3RyID09IHN0ci50b0xvd2VyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9VcHBlckNhc2UoKSkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2VDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGkgPSAtMTtcclxuICAgICAgICAgICAgICAgIGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljKHgsIFN0cmluZyh2KSwgaXNOdW0sIGIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUHJldmVudCBsYXRlciBjaGVjayBmb3IgbGVuZ3RoIG9uIGNvbnZlcnRlZCBudW1iZXIuXHJcbiAgICAgICAgaXNOdW0gPSBmYWxzZTtcclxuICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZShzdHIsIGIsIDEwLCB4LnMpO1xyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgIGVsc2UgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSAwOyBzdHIuY2hhckNvZGVBdChpKSA9PT0gNDg7IGkrKyk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgc3RyLmNoYXJDb2RlQXQoLS1sZW4pID09PSA0ODspO1xyXG5cclxuICAgICAgaWYgKHN0ciA9IHN0ci5zbGljZShpLCArK2xlbikpIHtcclxuICAgICAgICBsZW4gLT0gaTtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICBpZiAoaXNOdW0gJiYgQmlnTnVtYmVyLkRFQlVHICYmXHJcbiAgICAgICAgICBsZW4gPiAxNSAmJiAodiA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdiAhPT0gbWF0aGZsb29yKHYpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyAoeC5zICogdikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICAgIGlmICgoZSA9IGUgLSBpIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgTUlOX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICB4LmMgPSBbXTtcclxuXHJcbiAgICAgICAgICAvLyBUcmFuc2Zvcm0gYmFzZVxyXG5cclxuICAgICAgICAgIC8vIGUgaXMgdGhlIGJhc2UgMTAgZXhwb25lbnQuXHJcbiAgICAgICAgICAvLyBpIGlzIHdoZXJlIHRvIHNsaWNlIHN0ciB0byBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGNvZWZmaWNpZW50IGFycmF5LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChlIDwgMCkgaSArPSBMT0dfQkFTRTsgIC8vIGkgPCAxXHJcblxyXG4gICAgICAgICAgaWYgKGkgPCBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKGkpIHguYy5wdXNoKCtzdHIuc2xpY2UoMCwgaSkpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZW4gLT0gTE9HX0JBU0U7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICAgICAgeC5jLnB1c2goK3N0ci5zbGljZShpLCBpICs9IExPR19CQVNFKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGkgPSBMT0dfQkFTRSAtIChzdHIgPSBzdHIuc2xpY2UoaSkpLmxlbmd0aDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgLT0gbGVuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgeC5jLnB1c2goK3N0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBDT05TVFJVQ1RPUiBQUk9QRVJUSUVTXHJcblxyXG5cclxuICAgIEJpZ051bWJlci5jbG9uZSA9IGNsb25lO1xyXG5cclxuICAgIEJpZ051bWJlci5ST1VORF9VUCA9IDA7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfRE9XTiA9IDE7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfQ0VJTCA9IDI7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfRkxPT1IgPSAzO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfVVAgPSA0O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRE9XTiA9IDU7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9FVkVOID0gNjtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0NFSUwgPSA3O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRkxPT1IgPSA4O1xyXG4gICAgQmlnTnVtYmVyLkVVQ0xJRCA9IDk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBDb25maWd1cmUgaW5mcmVxdWVudGx5LWNoYW5naW5nIGxpYnJhcnktd2lkZSBzZXR0aW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBBY2NlcHQgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBvcHRpb25hbCBwcm9wZXJ0aWVzIChpZiB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpc1xyXG4gICAgICogYSBudW1iZXIsIGl0IG11c3QgYmUgYW4gaW50ZWdlciB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZSBzdGF0ZWQpOlxyXG4gICAgICpcclxuICAgICAqICAgREVDSU1BTF9QTEFDRVMgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgICAqICAgUk9VTkRJTkdfTU9ERSAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA4XHJcbiAgICAgKiAgIEVYUE9ORU5USUFMX0FUICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYICBvciAgWy1NQVggdG8gMCwgMCB0byBNQVhdXHJcbiAgICAgKiAgIFJBTkdFICAgICAgICAgICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYIChub3QgemVybykgIG9yICBbLU1BWCB0byAtMSwgMSB0byBNQVhdXHJcbiAgICAgKiAgIENSWVBUTyAgICAgICAgICAge2Jvb2xlYW59ICAgICAgICAgIHRydWUgb3IgZmFsc2VcclxuICAgICAqICAgTU9EVUxPX01PREUgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA5XHJcbiAgICAgKiAgIFBPV19QUkVDSVNJT04gICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIEFMUEhBQkVUICAgICAgICAge3N0cmluZ30gICAgICAgICAgIEEgc3RyaW5nIG9mIHR3byBvciBtb3JlIHVuaXF1ZSBjaGFyYWN0ZXJzIHdoaWNoIGRvZXNcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IGNvbnRhaW4gJy4nLlxyXG4gICAgICogICBGT1JNQVQgICAgICAgICAgIHtvYmplY3R9ICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBzb21lIG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgICAqICAgICBwcmVmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZ3JvdXBTaXplICAgICAgICAgICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIHNlY29uZGFyeUdyb3VwU2l6ZSAgICAge251bWJlcn1cclxuICAgICAqICAgICBncm91cFNlcGFyYXRvciAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZGVjaW1hbFNlcGFyYXRvciAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGZyYWN0aW9uR3JvdXBTaXplICAgICAge251bWJlcn1cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgc3VmZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICpcclxuICAgICAqIChUaGUgdmFsdWVzIGFzc2lnbmVkIHRvIHRoZSBhYm92ZSBGT1JNQVQgb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdCBjaGVja2VkIGZvciB2YWxpZGl0eS4pXHJcbiAgICAgKlxyXG4gICAgICogRS5nLlxyXG4gICAgICogQmlnTnVtYmVyLmNvbmZpZyh7IERFQ0lNQUxfUExBQ0VTIDogMjAsIFJPVU5ESU5HX01PREUgOiA0IH0pXHJcbiAgICAgKlxyXG4gICAgICogSWdub3JlIHByb3BlcnRpZXMvcGFyYW1ldGVycyBzZXQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGV4Y2VwdCBmb3IgQUxQSEFCRVQuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIGN1cnJlbnQgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuY29uZmlnID0gQmlnTnVtYmVyLnNldCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgdmFyIHAsIHY7XHJcblxyXG4gICAgICBpZiAob2JqICE9IG51bGwpIHtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgICAgICAvLyBERUNJTUFMX1BMQUNFUyB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gREVDSU1BTF9QTEFDRVMge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0RFQ0lNQUxfUExBQ0VTJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgREVDSU1BTF9QTEFDRVMgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJPVU5ESU5HX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBST1VORElOR19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdST1VORElOR19NT0RFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgOCwgcCk7XHJcbiAgICAgICAgICAgIFJPVU5ESU5HX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEVYUE9ORU5USUFMX0FUIHtudW1iZXJ8bnVtYmVyW119XHJcbiAgICAgICAgICAvLyBJbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gMCBpbmNsdXNpdmUsIDAgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRVhQT05FTlRJQUxfQVQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0VYUE9ORU5USUFMX0FUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAwLCBwKTtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSB2WzBdO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9QT1MgPSB2WzFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IC0oVE9fRVhQX1BPUyA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJBTkdFIHtudW1iZXJ8bnVtYmVyW119IE5vbi16ZXJvIGludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAtMSBpbmNsdXNpdmUsIGludGVnZXIgMSB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBSQU5HRSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V8Y2Fubm90IGJlIHplcm99OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUkFOR0UnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIC0xLCBwKTtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAxLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIE1JTl9FWFAgPSB2WzBdO1xyXG4gICAgICAgICAgICAgIE1BWF9FWFAgPSB2WzFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIE1JTl9FWFAgPSAtKE1BWF9FWFAgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgY2Fubm90IGJlIHplcm86ICcgKyB2KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDUllQVE8ge2Jvb2xlYW59IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQ1JZUFRPIG5vdCB0cnVlIG9yIGZhbHNlOiB7dn0nXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0NSWVBUTycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ID09PSAhIXYpIHtcclxuICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvICYmXHJcbiAgICAgICAgICAgICAgICAgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgfHwgY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gIXY7XHJcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCB0cnVlIG9yIGZhbHNlOiAnICsgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBNT0RVTE9fTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDkgaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE1PRFVMT19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdNT0RVTE9fTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDksIHApO1xyXG4gICAgICAgICAgICBNT0RVTE9fTU9ERSA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUE9XX1BSRUNJU0lPTiB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUE9XX1BSRUNJU0lPTiB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUE9XX1BSRUNJU0lPTicpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIFBPV19QUkVDSVNJT04gPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEZPUk1BVCB7b2JqZWN0fVxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEZPUk1BVCBub3QgYW4gb2JqZWN0OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRk9STUFUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdvYmplY3QnKSBGT1JNQVQgPSB2O1xyXG4gICAgICAgICAgICBlbHNlIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgYW4gb2JqZWN0OiAnICsgdik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQUxQSEFCRVQge3N0cmluZ31cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBBTFBIQUJFVCBpbnZhbGlkOiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQUxQSEFCRVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG5cclxuICAgICAgICAgICAgLy8gRGlzYWxsb3cgaWYgbGVzcyB0aGFuIHR3byBjaGFyYWN0ZXJzLFxyXG4gICAgICAgICAgICAvLyBvciBpZiBpdCBjb250YWlucyAnKycsICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciBhIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdzdHJpbmcnICYmICEvXi4/JHxbK1xcLS5cXHNdfCguKS4qXFwxLy50ZXN0KHYpKSB7XHJcbiAgICAgICAgICAgICAgQUxQSEFCRVQgPSB2O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGludmFsaWQ6ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBPYmplY3QgZXhwZWN0ZWQ6IHt2fSdcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ09iamVjdCBleHBlY3RlZDogJyArIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIERFQ0lNQUxfUExBQ0VTOiBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICBST1VORElOR19NT0RFOiBST1VORElOR19NT0RFLFxyXG4gICAgICAgIEVYUE9ORU5USUFMX0FUOiBbVE9fRVhQX05FRywgVE9fRVhQX1BPU10sXHJcbiAgICAgICAgUkFOR0U6IFtNSU5fRVhQLCBNQVhfRVhQXSxcclxuICAgICAgICBDUllQVE86IENSWVBUTyxcclxuICAgICAgICBNT0RVTE9fTU9ERTogTU9EVUxPX01PREUsXHJcbiAgICAgICAgUE9XX1BSRUNJU0lPTjogUE9XX1BSRUNJU0lPTixcclxuICAgICAgICBGT1JNQVQ6IEZPUk1BVCxcclxuICAgICAgICBBTFBIQUJFVDogQUxQSEFCRVRcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB2IGlzIGEgQmlnTnVtYmVyIGluc3RhbmNlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICpcclxuICAgICAqIElmIEJpZ051bWJlci5ERUJVRyBpcyB0cnVlLCB0aHJvdyBpZiBhIEJpZ051bWJlciBpbnN0YW5jZSBpcyBub3Qgd2VsbC1mb3JtZWQuXHJcbiAgICAgKlxyXG4gICAgICogdiB7YW55fVxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBJbnZhbGlkIEJpZ051bWJlcjoge3Z9J1xyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuaXNCaWdOdW1iZXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICBpZiAoIXYgfHwgdi5faXNCaWdOdW1iZXIgIT09IHRydWUpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKCFCaWdOdW1iZXIuREVCVUcpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgdmFyIGksIG4sXHJcbiAgICAgICAgYyA9IHYuYyxcclxuICAgICAgICBlID0gdi5lLFxyXG4gICAgICAgIHMgPSB2LnM7XHJcblxyXG4gICAgICBvdXQ6IGlmICh7fS50b1N0cmluZy5jYWxsKGMpID09ICdbb2JqZWN0IEFycmF5XScpIHtcclxuXHJcbiAgICAgICAgaWYgKChzID09PSAxIHx8IHMgPT09IC0xKSAmJiBlID49IC1NQVggJiYgZSA8PSBNQVggJiYgZSA9PT0gbWF0aGZsb29yKGUpKSB7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGVsZW1lbnQgaXMgemVybywgdGhlIEJpZ051bWJlciB2YWx1ZSBtdXN0IGJlIHplcm8uXHJcbiAgICAgICAgICBpZiAoY1swXSA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoZSA9PT0gMCAmJiBjLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyB0aGF0IGNbMF0gc2hvdWxkIGhhdmUsIGJhc2VkIG9uIHRoZSBleHBvbmVudC5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoaSA8IDEpIGkgKz0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgICAgIC8vaWYgKE1hdGguY2VpbChNYXRoLmxvZyhjWzBdICsgMSkgLyBNYXRoLkxOMTApID09IGkpIHtcclxuICAgICAgICAgIGlmIChTdHJpbmcoY1swXSkubGVuZ3RoID09IGkpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgbiA9IGNbaV07XHJcbiAgICAgICAgICAgICAgaWYgKG4gPCAwIHx8IG4gPj0gQkFTRSB8fCBuICE9PSBtYXRoZmxvb3IobikpIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTGFzdCBlbGVtZW50IGNhbm5vdCBiZSB6ZXJvLCB1bmxlc3MgaXQgaXMgdGhlIG9ubHkgZWxlbWVudC5cclxuICAgICAgICAgICAgaWYgKG4gIT09IDApIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluZmluaXR5L05hTlxyXG4gICAgICB9IGVsc2UgaWYgKGMgPT09IG51bGwgJiYgZSA9PT0gbnVsbCAmJiAocyA9PT0gbnVsbCB8fCBzID09PSAxIHx8IHMgPT09IC0xKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgIChiaWdudW1iZXJFcnJvciArICdJbnZhbGlkIEJpZ051bWJlcjogJyArIHYpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1heGltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIubWF4aW11bSA9IEJpZ051bWJlci5tYXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIFAubHQpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1pbmltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIubWluaW11bSA9IEJpZ051bWJlci5taW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIFAuZ3QpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2l0aCBhIHJhbmRvbSB2YWx1ZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMCBhbmQgbGVzcyB0aGFuIDEsXHJcbiAgICAgKiBhbmQgd2l0aCBkcCwgb3IgREVDSU1BTF9QTEFDRVMgaWYgZHAgaXMgb21pdHRlZCwgZGVjaW1hbCBwbGFjZXMgKG9yIGxlc3MgaWYgdHJhaWxpbmdcclxuICAgICAqIHplcm9zIGFyZSBwcm9kdWNlZCkuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB9J1xyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnJhbmRvbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBwb3cyXzUzID0gMHgyMDAwMDAwMDAwMDAwMDtcclxuXHJcbiAgICAgIC8vIFJldHVybiBhIDUzIGJpdCBpbnRlZ2VyIG4sIHdoZXJlIDAgPD0gbiA8IDkwMDcxOTkyNTQ3NDA5OTIuXHJcbiAgICAgIC8vIENoZWNrIGlmIE1hdGgucmFuZG9tKCkgcHJvZHVjZXMgbW9yZSB0aGFuIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cclxuICAgICAgLy8gSWYgaXQgZG9lcywgYXNzdW1lIGF0IGxlYXN0IDUzIGJpdHMgYXJlIHByb2R1Y2VkLCBvdGhlcndpc2UgYXNzdW1lIGF0IGxlYXN0IDMwIGJpdHMuXHJcbiAgICAgIC8vIDB4NDAwMDAwMDAgaXMgMl4zMCwgMHg4MDAwMDAgaXMgMl4yMywgMHgxZmZmZmYgaXMgMl4yMSAtIDEuXHJcbiAgICAgIHZhciByYW5kb201M2JpdEludCA9IChNYXRoLnJhbmRvbSgpICogcG93Ml81MykgJiAweDFmZmZmZlxyXG4gICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpOyB9XHJcbiAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICgoTWF0aC5yYW5kb20oKSAqIDB4NDAwMDAwMDAgfCAwKSAqIDB4ODAwMDAwKSArXHJcbiAgICAgICAgIChNYXRoLnJhbmRvbSgpICogMHg4MDAwMDAgfCAwKTsgfTtcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZHApIHtcclxuICAgICAgICB2YXIgYSwgYiwgZSwgaywgdixcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgYyA9IFtdLFxyXG4gICAgICAgICAgcmFuZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgICAgaWYgKGRwID09IG51bGwpIGRwID0gREVDSU1BTF9QTEFDRVM7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKGRwIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICBpZiAoQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgLy8gQnJvd3NlcnMgc3VwcG9ydGluZyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLlxyXG4gICAgICAgICAgaWYgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcclxuXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShrICo9IDIpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gNTMgYml0czpcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpICogTWF0aC5wb3coMiwgMjEpKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwXHJcbiAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSA+Pj4gMTEpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAweDIwMDAwIGlzIDJeMjEuXHJcbiAgICAgICAgICAgICAgdiA9IGFbaV0gKiAweDIwMDAwICsgKGFbaSArIDFdID4+PiAxMSk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFJlamVjdGlvbiBzYW1wbGluZzpcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgLy8gUHJvYmFiaWxpdHkgdGhhdCB2ID49IDllMTUsIGlzXHJcbiAgICAgICAgICAgICAgLy8gNzE5OTI1NDc0MDk5MiAvIDkwMDcxOTkyNTQ3NDA5OTIgfj0gMC4wMDA4LCBpLmUuIDEgaW4gMTI1MVxyXG4gICAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgyKSk7XHJcbiAgICAgICAgICAgICAgICBhW2ldID0gYlswXTtcclxuICAgICAgICAgICAgICAgIGFbaSArIDFdID0gYlsxXTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gdiA8PSA4OTk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBrIC8gMjtcclxuXHJcbiAgICAgICAgICAvLyBOb2RlLmpzIHN1cHBvcnRpbmcgY3J5cHRvLnJhbmRvbUJ5dGVzLlxyXG4gICAgICAgICAgfSBlbHNlIGlmIChjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJ1ZmZlclxyXG4gICAgICAgICAgICBhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGsgKj0gNyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwMDAwMCBpcyAyXjQ4LCAweDEwMDAwMDAwMDAwIGlzIDJeNDBcclxuICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMCBpcyAyXjMyLCAweDEwMDAwMDAgaXMgMl4yNFxyXG4gICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgIHYgPSAoKGFbaV0gJiAzMSkgKiAweDEwMDAwMDAwMDAwMDApICsgKGFbaSArIDFdICogMHgxMDAwMDAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgIChhW2kgKyAyXSAqIDB4MTAwMDAwMDAwKSArIChhW2kgKyAzXSAqIDB4MTAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgIChhW2kgKyA0XSA8PCAxNikgKyAoYVtpICsgNV0gPDwgOCkgKyBhW2kgKyA2XTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgY3J5cHRvLnJhbmRvbUJ5dGVzKDcpLmNvcHkoYSwgaSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDc7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBrIC8gNztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIENSWVBUTyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXNlIE1hdGgucmFuZG9tLlxyXG4gICAgICAgIGlmICghQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG4gICAgICAgICAgICB2ID0gcmFuZG9tNTNiaXRJbnQoKTtcclxuICAgICAgICAgICAgaWYgKHYgPCA5ZTE1KSBjW2krK10gPSB2ICUgMWUxNDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGsgPSBjWy0taV07XHJcbiAgICAgICAgZHAgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdHJhaWxpbmcgZGlnaXRzIHRvIHplcm9zIGFjY29yZGluZyB0byBkcC5cclxuICAgICAgICBpZiAoayAmJiBkcCkge1xyXG4gICAgICAgICAgdiA9IFBPV1NfVEVOW0xPR19CQVNFIC0gZHBdO1xyXG4gICAgICAgICAgY1tpXSA9IG1hdGhmbG9vcihrIC8gdikgKiB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvLlxyXG4gICAgICAgIGZvciAoOyBjW2ldID09PSAwOyBjLnBvcCgpLCBpLS0pO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgYyA9IFtlID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVybyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgZm9yIChlID0gLTEgOyBjWzBdID09PSAwOyBjLnNwbGljZSgwLCAxKSwgZSAtPSBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgLy8gQ291bnQgdGhlIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiBjIHRvIGRldGVybWluZSBsZWFkaW5nIHplcm9zLCBhbmQuLi5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgIC8vIGFkanVzdCB0aGUgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBpZiAoaSA8IExPR19CQVNFKSBlIC09IExPR19CQVNFIC0gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJhbmQuZSA9IGU7XHJcbiAgICAgICAgcmFuZC5jID0gYztcclxuICAgICAgICByZXR1cm4gcmFuZDtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHN1bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5zdW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBpID0gMSxcclxuICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxyXG4gICAgICAgIHN1bSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7KSBzdW0gPSBzdW0ucGx1cyhhcmdzW2krK10pO1xyXG4gICAgICByZXR1cm4gc3VtO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLy8gUFJJVkFURSBGVU5DVElPTlNcclxuXHJcblxyXG4gICAgLy8gQ2FsbGVkIGJ5IEJpZ051bWJlciBhbmQgQmlnTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZy5cclxuICAgIGNvbnZlcnRCYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGRlY2ltYWwgPSAnMDEyMzQ1Njc4OSc7XHJcblxyXG4gICAgICAvKlxyXG4gICAgICAgKiBDb252ZXJ0IHN0cmluZyBvZiBiYXNlSW4gdG8gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBiYXNlT3V0LlxyXG4gICAgICAgKiBFZy4gdG9CYXNlT3V0KCcyNTUnLCAxMCwgMTYpIHJldHVybnMgWzE1LCAxNV0uXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJ2ZmJywgMTYsIDEwKSByZXR1cm5zIFsyLCA1LCA1XS5cclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgYWxwaGFiZXQpIHtcclxuICAgICAgICB2YXIgaixcclxuICAgICAgICAgIGFyciA9IFswXSxcclxuICAgICAgICAgIGFyckwsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgZm9yIChhcnJMID0gYXJyLmxlbmd0aDsgYXJyTC0tOyBhcnJbYXJyTF0gKj0gYmFzZUluKTtcclxuXHJcbiAgICAgICAgICBhcnJbMF0gKz0gYWxwaGFiZXQuaW5kZXhPZihzdHIuY2hhckF0KGkrKykpO1xyXG5cclxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChhcnJbal0gPiBiYXNlT3V0IC0gMSkge1xyXG4gICAgICAgICAgICAgIGlmIChhcnJbaiArIDFdID09IG51bGwpIGFycltqICsgMV0gPSAwO1xyXG4gICAgICAgICAgICAgIGFycltqICsgMV0gKz0gYXJyW2pdIC8gYmFzZU91dCB8IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2pdICU9IGJhc2VPdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcnIucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZUluIHRvIGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyB0b1N0cmluZywgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlIDEwIHRvIGJhc2VPdXQuXHJcbiAgICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgQmlnTnVtYmVyLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2VJbiB0byBiYXNlIDEwLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHN0ciwgYmFzZUluLCBiYXNlT3V0LCBzaWduLCBjYWxsZXJJc1RvU3RyaW5nKSB7XHJcbiAgICAgICAgdmFyIGFscGhhYmV0LCBkLCBlLCBrLCByLCB4LCB4YywgeSxcclxuICAgICAgICAgIGkgPSBzdHIuaW5kZXhPZignLicpLFxyXG4gICAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICAgIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuXHJcbiAgICAgICAgLy8gTm9uLWludGVnZXIuXHJcbiAgICAgICAgaWYgKGkgPj0gMCkge1xyXG4gICAgICAgICAgayA9IFBPV19QUkVDSVNJT047XHJcblxyXG4gICAgICAgICAgLy8gVW5saW1pdGVkIHByZWNpc2lvbi5cclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSAwO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihiYXNlSW4pO1xyXG4gICAgICAgICAgeCA9IHkucG93KHN0ci5sZW5ndGggLSBpKTtcclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSBrO1xyXG5cclxuICAgICAgICAgIC8vIENvbnZlcnQgc3RyIGFzIGlmIGFuIGludGVnZXIsIHRoZW4gcmVzdG9yZSB0aGUgZnJhY3Rpb24gcGFydCBieSBkaXZpZGluZyB0aGVcclxuICAgICAgICAgIC8vIHJlc3VsdCBieSBpdHMgYmFzZSByYWlzZWQgdG8gYSBwb3dlci5cclxuXHJcbiAgICAgICAgICB5LmMgPSB0b0Jhc2VPdXQodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcoeC5jKSwgeC5lLCAnMCcpLFxyXG4gICAgICAgICAgIDEwLCBiYXNlT3V0LCBkZWNpbWFsKTtcclxuICAgICAgICAgIHkuZSA9IHkuYy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBudW1iZXIgYXMgaW50ZWdlci5cclxuXHJcbiAgICAgICAgeGMgPSB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGNhbGxlcklzVG9TdHJpbmdcclxuICAgICAgICAgPyAoYWxwaGFiZXQgPSBBTFBIQUJFVCwgZGVjaW1hbClcclxuICAgICAgICAgOiAoYWxwaGFiZXQgPSBkZWNpbWFsLCBBTFBIQUJFVCkpO1xyXG5cclxuICAgICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgYXMgYW4gaW50ZWdlciBhbmQgY29udmVydGVkIHRvIGJhc2VPdXQuIGUgaXMgdGhlIGV4cG9uZW50LlxyXG4gICAgICAgIGUgPSBrID0geGMubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICg7IHhjWy0ta10gPT0gMDsgeGMucG9wKCkpO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0pIHJldHVybiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcblxyXG4gICAgICAgIC8vIERvZXMgc3RyIHJlcHJlc2VudCBhbiBpbnRlZ2VyPyBJZiBzbywgbm8gbmVlZCBmb3IgdGhlIGRpdmlzaW9uLlxyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgLS1lO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmMgPSB4YztcclxuICAgICAgICAgIHguZSA9IGU7XHJcblxyXG4gICAgICAgICAgLy8gVGhlIHNpZ24gaXMgbmVlZGVkIGZvciBjb3JyZWN0IHJvdW5kaW5nLlxyXG4gICAgICAgICAgeC5zID0gc2lnbjtcclxuICAgICAgICAgIHggPSBkaXYoeCwgeSwgZHAsIHJtLCBiYXNlT3V0KTtcclxuICAgICAgICAgIHhjID0geC5jO1xyXG4gICAgICAgICAgciA9IHgucjtcclxuICAgICAgICAgIGUgPSB4LmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgY29udmVydGVkIHRvIGJhc2VPdXQuXHJcblxyXG4gICAgICAgIC8vIFRIZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgZCA9IGUgKyBkcCArIDE7XHJcblxyXG4gICAgICAgIC8vIFRoZSByb3VuZGluZyBkaWdpdDogdGhlIGRpZ2l0IHRvIHRoZSByaWdodCBvZiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICBpID0geGNbZF07XHJcblxyXG4gICAgICAgIC8vIExvb2sgYXQgdGhlIHJvdW5kaW5nIGRpZ2l0cyBhbmQgbW9kZSB0byBkZXRlcm1pbmUgd2hldGhlciB0byByb3VuZCB1cC5cclxuXHJcbiAgICAgICAgayA9IGJhc2VPdXQgLyAyO1xyXG4gICAgICAgIHIgPSByIHx8IGQgPCAwIHx8IHhjW2QgKyAxXSAhPSBudWxsO1xyXG5cclxuICAgICAgICByID0gcm0gPCA0ID8gKGkgIT0gbnVsbCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICAgICA6IGkgPiBrIHx8IGkgPT0gayAmJihybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJiB4Y1tkIC0gMV0gJiAxIHx8XHJcbiAgICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBub3QgZ3JlYXRlciB0aGFuIHplcm8sIG9yIHhjIHJlcHJlc2VudHNcclxuICAgICAgICAvLyB6ZXJvLCB0aGVuIHRoZSByZXN1bHQgb2YgdGhlIGJhc2UgY29udmVyc2lvbiBpcyB6ZXJvIG9yLCBpZiByb3VuZGluZyB1cCwgYSB2YWx1ZVxyXG4gICAgICAgIC8vIHN1Y2ggYXMgMC4wMDAwMS5cclxuICAgICAgICBpZiAoZCA8IDEgfHwgIXhjWzBdKSB7XHJcblxyXG4gICAgICAgICAgLy8gMV4tZHAgb3IgMFxyXG4gICAgICAgICAgc3RyID0gciA/IHRvRml4ZWRQb2ludChhbHBoYWJldC5jaGFyQXQoMSksIC1kcCwgYWxwaGFiZXQuY2hhckF0KDApKSA6IGFscGhhYmV0LmNoYXJBdCgwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFRydW5jYXRlIHhjIHRvIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICB4Yy5sZW5ndGggPSBkO1xyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFJvdW5kaW5nIHVwIG1heSBtZWFuIHRoZSBwcmV2aW91cyBkaWdpdCBoYXMgdG8gYmUgcm91bmRlZCB1cCBhbmQgc28gb24uXHJcbiAgICAgICAgICAgIGZvciAoLS1iYXNlT3V0OyArK3hjWy0tZF0gPiBiYXNlT3V0Oykge1xyXG4gICAgICAgICAgICAgIHhjW2RdID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKCFkKSB7XHJcbiAgICAgICAgICAgICAgICArK2U7XHJcbiAgICAgICAgICAgICAgICB4YyA9IFsxXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgIGZvciAoayA9IHhjLmxlbmd0aDsgIXhjWy0ta107KTtcclxuXHJcbiAgICAgICAgICAvLyBFLmcuIFs0LCAxMSwgMTVdIGJlY29tZXMgNGJmLlxyXG4gICAgICAgICAgZm9yIChpID0gMCwgc3RyID0gJyc7IGkgPD0gazsgc3RyICs9IGFscGhhYmV0LmNoYXJBdCh4Y1tpKytdKSk7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVyb3MsIGRlY2ltYWwgcG9pbnQgYW5kIHRyYWlsaW5nIHplcm9zIGFzIHJlcXVpcmVkLlxyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgYWxwaGFiZXQuY2hhckF0KDApKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSBjYWxsZXIgd2lsbCBhZGQgdGhlIHNpZ24uXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8vIFBlcmZvcm0gZGl2aXNpb24gaW4gdGhlIHNwZWNpZmllZCBiYXNlLiBDYWxsZWQgYnkgZGl2IGFuZCBjb252ZXJ0QmFzZS5cclxuICAgIGRpdiA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAvLyBBc3N1bWUgbm9uLXplcm8geCBhbmQgay5cclxuICAgICAgZnVuY3Rpb24gbXVsdGlwbHkoeCwgaywgYmFzZSkge1xyXG4gICAgICAgIHZhciBtLCB0ZW1wLCB4bG8sIHhoaSxcclxuICAgICAgICAgIGNhcnJ5ID0gMCxcclxuICAgICAgICAgIGkgPSB4Lmxlbmd0aCxcclxuICAgICAgICAgIGtsbyA9IGsgJSBTUVJUX0JBU0UsXHJcbiAgICAgICAgICBraGkgPSBrIC8gU1FSVF9CQVNFIHwgMDtcclxuXHJcbiAgICAgICAgZm9yICh4ID0geC5zbGljZSgpOyBpLS07KSB7XHJcbiAgICAgICAgICB4bG8gPSB4W2ldICUgU1FSVF9CQVNFO1xyXG4gICAgICAgICAgeGhpID0geFtpXSAvIFNRUlRfQkFTRSB8IDA7XHJcbiAgICAgICAgICBtID0ga2hpICogeGxvICsgeGhpICoga2xvO1xyXG4gICAgICAgICAgdGVtcCA9IGtsbyAqIHhsbyArICgobSAlIFNRUlRfQkFTRSkgKiBTUVJUX0JBU0UpICsgY2Fycnk7XHJcbiAgICAgICAgICBjYXJyeSA9ICh0ZW1wIC8gYmFzZSB8IDApICsgKG0gLyBTUVJUX0JBU0UgfCAwKSArIGtoaSAqIHhoaTtcclxuICAgICAgICAgIHhbaV0gPSB0ZW1wICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjYXJyeSkgeCA9IFtjYXJyeV0uY29uY2F0KHgpO1xyXG5cclxuICAgICAgICByZXR1cm4geDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY29tcGFyZShhLCBiLCBhTCwgYkwpIHtcclxuICAgICAgICB2YXIgaSwgY21wO1xyXG5cclxuICAgICAgICBpZiAoYUwgIT0gYkwpIHtcclxuICAgICAgICAgIGNtcCA9IGFMID4gYkwgPyAxIDogLTE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICBmb3IgKGkgPSBjbXAgPSAwOyBpIDwgYUw7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFbaV0gIT0gYltpXSkge1xyXG4gICAgICAgICAgICAgIGNtcCA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBhTCwgYmFzZSkge1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgYiBmcm9tIGEuXHJcbiAgICAgICAgZm9yICg7IGFMLS07KSB7XHJcbiAgICAgICAgICBhW2FMXSAtPSBpO1xyXG4gICAgICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcclxuICAgICAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICg7ICFhWzBdICYmIGEubGVuZ3RoID4gMTsgYS5zcGxpY2UoMCwgMSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4OiBkaXZpZGVuZCwgeTogZGl2aXNvci5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5LCBkcCwgcm0sIGJhc2UpIHtcclxuICAgICAgICB2YXIgY21wLCBlLCBpLCBtb3JlLCBuLCBwcm9kLCBwcm9kTCwgcSwgcWMsIHJlbSwgcmVtTCwgcmVtMCwgeGksIHhMLCB5YzAsXHJcbiAgICAgICAgICB5TCwgeXosXHJcbiAgICAgICAgICBzID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBOYU4sIEluZmluaXR5IG9yIDA/XHJcbiAgICAgICAgaWYgKCF4YyB8fCAheGNbMF0gfHwgIXljIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKFxyXG5cclxuICAgICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBOYU4sIG9yIGJvdGggSW5maW5pdHkgb3IgMC5cclxuICAgICAgICAgICAheC5zIHx8ICF5LnMgfHwgKHhjID8geWMgJiYgeGNbMF0gPT0geWNbMF0gOiAheWMpID8gTmFOIDpcclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgeCBpcyDCsTAgb3IgeSBpcyDCsUluZmluaXR5LCBvciByZXR1cm4gwrFJbmZpbml0eSBhcyB5IGlzIMKxMC5cclxuICAgICAgICAgICAgeGMgJiYgeGNbMF0gPT0gMCB8fCAheWMgPyBzICogMCA6IHMgLyAwXHJcbiAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBxID0gbmV3IEJpZ051bWJlcihzKTtcclxuICAgICAgICBxYyA9IHEuYyA9IFtdO1xyXG4gICAgICAgIGUgPSB4LmUgLSB5LmU7XHJcbiAgICAgICAgcyA9IGRwICsgZSArIDE7XHJcblxyXG4gICAgICAgIGlmICghYmFzZSkge1xyXG4gICAgICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpIC0gYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICAgICAgcyA9IHMgLyBMT0dfQkFTRSB8IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXN1bHQgZXhwb25lbnQgbWF5IGJlIG9uZSBsZXNzIHRoZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgZS5cclxuICAgICAgICAvLyBUaGUgY29lZmZpY2llbnRzIG9mIHRoZSBCaWdOdW1iZXJzIGZyb20gY29udmVydEJhc2UgbWF5IGhhdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yIChpID0gMDsgeWNbaV0gPT0gKHhjW2ldIHx8IDApOyBpKyspO1xyXG5cclxuICAgICAgICBpZiAoeWNbaV0gPiAoeGNbaV0gfHwgMCkpIGUtLTtcclxuXHJcbiAgICAgICAgaWYgKHMgPCAwKSB7XHJcbiAgICAgICAgICBxYy5wdXNoKDEpO1xyXG4gICAgICAgICAgbW9yZSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgIHMgKz0gMjtcclxuXHJcbiAgICAgICAgICAvLyBOb3JtYWxpc2UgeGMgYW5kIHljIHNvIGhpZ2hlc3Qgb3JkZXIgZGlnaXQgb2YgeWMgaXMgPj0gYmFzZSAvIDIuXHJcblxyXG4gICAgICAgICAgbiA9IG1hdGhmbG9vcihiYXNlIC8gKHljWzBdICsgMSkpO1xyXG5cclxuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBoYW5kbGUgb2RkIGJhc2VzIHdoZXJlIHljWzBdID09IChiYXNlIC8gMikgLSAxLlxyXG4gICAgICAgICAgLy8gaWYgKG4gPiAxIHx8IG4rKyA9PSAxICYmIHljWzBdIDwgYmFzZSAvIDIpIHtcclxuICAgICAgICAgIGlmIChuID4gMSkge1xyXG4gICAgICAgICAgICB5YyA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeGMgPSBtdWx0aXBseSh4YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB4aSA9IHlMO1xyXG4gICAgICAgICAgcmVtID0geGMuc2xpY2UoMCwgeUwpO1xyXG4gICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIHplcm9zIHRvIG1ha2UgcmVtYWluZGVyIGFzIGxvbmcgYXMgZGl2aXNvci5cclxuICAgICAgICAgIGZvciAoOyByZW1MIDwgeUw7IHJlbVtyZW1MKytdID0gMCk7XHJcbiAgICAgICAgICB5eiA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICB5eiA9IFswXS5jb25jYXQoeXopO1xyXG4gICAgICAgICAgeWMwID0geWNbMF07XHJcbiAgICAgICAgICBpZiAoeWNbMV0gPj0gYmFzZSAvIDIpIHljMCsrO1xyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIHByZXZlbnQgdHJpYWwgZGlnaXQgbiA+IGJhc2UsIHdoZW4gdXNpbmcgYmFzZSAzLlxyXG4gICAgICAgICAgLy8gZWxzZSBpZiAoYmFzZSA9PSAzICYmIHljMCA9PSAxKSB5YzAgPSAxICsgMWUtMTU7XHJcblxyXG4gICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBuID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBjbXAgPSBjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0cmlhbCBkaWdpdCwgbi5cclxuXHJcbiAgICAgICAgICAgICAgcmVtMCA9IHJlbVswXTtcclxuICAgICAgICAgICAgICBpZiAoeUwgIT0gcmVtTCkgcmVtMCA9IHJlbTAgKiBiYXNlICsgKHJlbVsxXSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gbiBpcyBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gdGhlIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIG4gPSBtYXRoZmxvb3IocmVtMCAvIHljMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vICBBbGdvcml0aG06XHJcbiAgICAgICAgICAgICAgLy8gIHByb2R1Y3QgPSBkaXZpc29yIG11bHRpcGxpZWQgYnkgdHJpYWwgZGlnaXQgKG4pLlxyXG4gICAgICAgICAgICAgIC8vICBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCBpcyBncmVhdGVyIHRoYW4gcmVtYWluZGVyOlxyXG4gICAgICAgICAgICAgIC8vICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LCBkZWNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgLy8gIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gIElmIHByb2R1Y3Qgd2FzIGxlc3MgdGhhbiByZW1haW5kZXIgYXQgdGhlIGxhc3QgY29tcGFyZTpcclxuICAgICAgICAgICAgICAvLyAgICBDb21wYXJlIG5ldyByZW1haW5kZXIgYW5kIGRpdmlzb3IuXHJcbiAgICAgICAgICAgICAgLy8gICAgSWYgcmVtYWluZGVyIGlzIGdyZWF0ZXIgdGhhbiBkaXZpc29yOlxyXG4gICAgICAgICAgICAgIC8vICAgICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlciwgaW5jcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG5cclxuICAgICAgICAgICAgICBpZiAobiA+IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuIG1heSBiZSA+IGJhc2Ugb25seSB3aGVuIGJhc2UgaXMgMy5cclxuICAgICAgICAgICAgICAgIGlmIChuID49IGJhc2UpIG4gPSBiYXNlIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3QgPiByZW1haW5kZXIgdGhlbiB0cmlhbCBkaWdpdCBuIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBoaWdoIGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgaXMgbm90IGtub3duIHRvIGhhdmVcclxuICAgICAgICAgICAgICAgIC8vIGV2ZXIgYmVlbiBtb3JlIHRoYW4gMSB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHByb2QsIHJlbSwgcHJvZEwsIHJlbUwpID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgbi0tO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHByb2QsIHlMIDwgcHJvZEwgPyB5eiA6IHljLCBwcm9kTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDAgb3IgMSwgY21wIGlzIC0xLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAwLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNvbXBhcmUgeWMgYW5kIHJlbSBhZ2FpbiBiZWxvdyxcclxuICAgICAgICAgICAgICAgIC8vIHNvIGNoYW5nZSBjbXAgdG8gMSB0byBhdm9pZCBpdC5cclxuICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMSwgbGVhdmUgY21wIGFzIC0xLCBzbyB5YyBhbmQgcmVtIGFyZSBjb21wYXJlZCBhZ2Fpbi5cclxuICAgICAgICAgICAgICAgIGlmIChuID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIGRpdmlzb3IgPCByZW1haW5kZXIsIHNvIG4gbXVzdCBiZSBhdCBsZWFzdCAxLlxyXG4gICAgICAgICAgICAgICAgICBjbXAgPSBuID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvclxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKHByb2RMIDwgcmVtTCkgcHJvZCA9IFswXS5jb25jYXQocHJvZCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCBwcm9kLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3Qgd2FzIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIG5ldyByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgbmV3IHJlbWFpbmRlciwgc3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIFRyaWFsIGRpZ2l0IG4gdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gbG93IGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgdmVyeSByYXJlbHkgMiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICBuKys7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHlMIDwgcmVtTCA/IHl6IDogeWMsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgbisrO1xyXG4gICAgICAgICAgICAgIHJlbSA9IFswXTtcclxuICAgICAgICAgICAgfSAvLyBlbHNlIGNtcCA9PT0gMSBhbmQgbiB3aWxsIGJlIDBcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV4dCBkaWdpdCwgbiwgdG8gdGhlIHJlc3VsdCBhcnJheS5cclxuICAgICAgICAgICAgcWNbaSsrXSA9IG47XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKHJlbVswXSkge1xyXG4gICAgICAgICAgICAgIHJlbVtyZW1MKytdID0geGNbeGldIHx8IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmVtID0gW3hjW3hpXV07XHJcbiAgICAgICAgICAgICAgcmVtTCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gd2hpbGUgKCh4aSsrIDwgeEwgfHwgcmVtWzBdICE9IG51bGwpICYmIHMtLSk7XHJcblxyXG4gICAgICAgICAgbW9yZSA9IHJlbVswXSAhPSBudWxsO1xyXG5cclxuICAgICAgICAgIC8vIExlYWRpbmcgemVybz9cclxuICAgICAgICAgIGlmICghcWNbMF0pIHFjLnNwbGljZSgwLCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChiYXNlID09IEJBU0UpIHtcclxuXHJcbiAgICAgICAgICAvLyBUbyBjYWxjdWxhdGUgcS5lLCBmaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgcWNbMF0uXHJcbiAgICAgICAgICBmb3IgKGkgPSAxLCBzID0gcWNbMF07IHMgPj0gMTA7IHMgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgcm91bmQocSwgZHAgKyAocS5lID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpICsgMSwgcm0sIG1vcmUpO1xyXG5cclxuICAgICAgICAvLyBDYWxsZXIgaXMgY29udmVydEJhc2UuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHEuZSA9IGU7XHJcbiAgICAgICAgICBxLnIgPSArbW9yZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBxO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIEJpZ051bWJlciBuIGluIGZpeGVkLXBvaW50IG9yIGV4cG9uZW50aWFsXHJcbiAgICAgKiBub3RhdGlvbiByb3VuZGVkIHRvIHRoZSBzcGVjaWZpZWQgZGVjaW1hbCBwbGFjZXMgb3Igc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICpcclxuICAgICAqIG46IGEgQmlnTnVtYmVyLlxyXG4gICAgICogaTogdGhlIGluZGV4IG9mIHRoZSBsYXN0IGRpZ2l0IHJlcXVpcmVkIChpLmUuIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwKS5cclxuICAgICAqIHJtOiB0aGUgcm91bmRpbmcgbW9kZS5cclxuICAgICAqIGlkOiAxICh0b0V4cG9uZW50aWFsKSBvciAyICh0b1ByZWNpc2lvbikuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZvcm1hdChuLCBpLCBybSwgaWQpIHtcclxuICAgICAgdmFyIGMwLCBlLCBuZSwgbGVuLCBzdHI7XHJcblxyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgIGlmICghbi5jKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgYzAgPSBuLmNbMF07XHJcbiAgICAgIG5lID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGkgPT0gbnVsbCkge1xyXG4gICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgICBzdHIgPSBpZCA9PSAxIHx8IGlkID09IDIgJiYgKG5lIDw9IFRPX0VYUF9ORUcgfHwgbmUgPj0gVE9fRVhQX1BPUylcclxuICAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgbmUpXHJcbiAgICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgbmUsICcwJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIGksIHJtKTtcclxuXHJcbiAgICAgICAgLy8gbi5lIG1heSBoYXZlIGNoYW5nZWQgaWYgdGhlIHZhbHVlIHdhcyByb3VuZGVkIHVwLlxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyB0b1ByZWNpc2lvbiByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgICAgLy8gc3BlY2lmaWVkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyXHJcbiAgICAgICAgLy8gcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24uXHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAgIGlmIChpZCA9PSAxIHx8IGlkID09IDIgJiYgKGkgPD0gZSB8fCBlIDw9IFRPX0VYUF9ORUcpKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgZm9yICg7IGxlbiA8IGk7IHN0ciArPSAnMCcsIGxlbisrKTtcclxuICAgICAgICAgIHN0ciA9IHRvRXhwb25lbnRpYWwoc3RyLCBlKTtcclxuXHJcbiAgICAgICAgLy8gRml4ZWQtcG9pbnQgbm90YXRpb24uXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGkgLT0gbmU7XHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICAgIGlmIChlICsgMSA+IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoLS1pID4gMCkgZm9yIChzdHIgKz0gJy4nOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSArPSBlIC0gbGVuO1xyXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICBpZiAoZSArIDEgPT0gbGVuKSBzdHIgKz0gJy4nO1xyXG4gICAgICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCAmJiBjMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIEJpZ051bWJlci5tYXggYW5kIEJpZ051bWJlci5taW4uXHJcbiAgICBmdW5jdGlvbiBtYXhPck1pbihhcmdzLCBtZXRob2QpIHtcclxuICAgICAgdmFyIG4sXHJcbiAgICAgICAgaSA9IDEsXHJcbiAgICAgICAgbSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcblxyXG4gICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBuID0gbmV3IEJpZ051bWJlcihhcmdzW2ldKTtcclxuXHJcbiAgICAgICAgLy8gSWYgYW55IG51bWJlciBpcyBOYU4sIHJldHVybiBOYU4uXHJcbiAgICAgICAgaWYgKCFuLnMpIHtcclxuICAgICAgICAgIG0gPSBuO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QuY2FsbChtLCBuKSkge1xyXG4gICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFN0cmlwIHRyYWlsaW5nIHplcm9zLCBjYWxjdWxhdGUgYmFzZSAxMCBleHBvbmVudCBhbmQgY2hlY2sgYWdhaW5zdCBNSU5fRVhQIGFuZCBNQVhfRVhQLlxyXG4gICAgICogQ2FsbGVkIGJ5IG1pbnVzLCBwbHVzIGFuZCB0aW1lcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbm9ybWFsaXNlKG4sIGMsIGUpIHtcclxuICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgIGogPSBjLmxlbmd0aDtcclxuXHJcbiAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoOyAhY1stLWpdOyBjLnBvcCgpKTtcclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYmFzZSAxMCBleHBvbmVudC4gRmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIGNbMF0uXHJcbiAgICAgIGZvciAoaiA9IGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgaWYgKChlID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICBuLmMgPSBuLmUgPSBudWxsO1xyXG5cclxuICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgbi5jID0gW24uZSA9IDBdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4uZSA9IGU7XHJcbiAgICAgICAgbi5jID0gYztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEhhbmRsZSB2YWx1ZXMgdGhhdCBmYWlsIHRoZSB2YWxpZGl0eSB0ZXN0IGluIEJpZ051bWJlci5cclxuICAgIHBhcnNlTnVtZXJpYyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaSxcclxuICAgICAgICBkb3RBZnRlciA9IC9eKFteLl0rKVxcLiQvLFxyXG4gICAgICAgIGRvdEJlZm9yZSA9IC9eXFwuKFteLl0rKSQvLFxyXG4gICAgICAgIGlzSW5maW5pdHlPck5hTiA9IC9eLT8oSW5maW5pdHl8TmFOKSQvLFxyXG4gICAgICAgIHdoaXRlc3BhY2VPclBsdXMgPSAvXlxccypcXCsoPz1bXFx3Ll0pfF5cXHMrfFxccyskL2c7XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHN0ciwgaXNOdW0sIGIpIHtcclxuICAgICAgICB2YXIgYmFzZSxcclxuICAgICAgICAgIHMgPSBpc051bSA/IHN0ciA6IHN0ci5yZXBsYWNlKHdoaXRlc3BhY2VPclBsdXMsICcnKTtcclxuXHJcbiAgICAgICAgLy8gTm8gZXhjZXB0aW9uIG9uIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICAgIGlmIChpc0luZmluaXR5T3JOYU4udGVzdChzKSkge1xyXG4gICAgICAgICAgeC5zID0gaXNOYU4ocykgPyBudWxsIDogcyA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmICghaXNOdW0pIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pXHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoYmFzZVByZWZpeCwgZnVuY3Rpb24gKG0sIHAxLCBwMikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSAocDIgPSBwMi50b0xvd2VyQ2FzZSgpKSA9PSAneCcgPyAxNiA6IHAyID09ICdiJyA/IDIgOiA4O1xyXG4gICAgICAgICAgICAgIHJldHVybiAhYiB8fCBiID09IGJhc2UgPyBwMSA6IG07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGIpIHtcclxuICAgICAgICAgICAgICBiYXNlID0gYjtcclxuXHJcbiAgICAgICAgICAgICAgLy8gRS5nLiAnMS4nIHRvICcxJywgJy4xJyB0byAnMC4xJ1xyXG4gICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoZG90QWZ0ZXIsICckMScpLnJlcGxhY2UoZG90QmVmb3JlLCAnMC4kMScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RyICE9IHMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHMsIGJhc2UpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBudW1iZXI6IHtufSdcclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBiYXNlIHtifSBudW1iZXI6IHtufSdcclxuICAgICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnTm90IGEnICsgKGIgPyAnIGJhc2UgJyArIGIgOiAnJykgKyAnIG51bWJlcjogJyArIHN0cik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTmFOXHJcbiAgICAgICAgICB4LnMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJvdW5kIHggdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0uIENoZWNrIGZvciBvdmVyL3VuZGVyLWZsb3cuXHJcbiAgICAgKiBJZiByIGlzIHRydXRoeSwgaXQgaXMga25vd24gdGhhdCB0aGVyZSBhcmUgbW9yZSBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByb3VuZCh4LCBzZCwgcm0sIHIpIHtcclxuICAgICAgdmFyIGQsIGksIGosIGssIG4sIG5pLCByZCxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICBwb3dzMTAgPSBQT1dTX1RFTjtcclxuXHJcbiAgICAgIC8vIGlmIHggaXMgbm90IEluZmluaXR5IG9yIE5hTi4uLlxyXG4gICAgICBpZiAoeGMpIHtcclxuXHJcbiAgICAgICAgLy8gcmQgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICAvLyBuIGlzIGEgYmFzZSAxZTE0IG51bWJlciwgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IG9mIGFycmF5IHguYyBjb250YWluaW5nIHJkLlxyXG4gICAgICAgIC8vIG5pIGlzIHRoZSBpbmRleCBvZiBuIHdpdGhpbiB4LmMuXHJcbiAgICAgICAgLy8gZCBpcyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgIC8vIGkgaXMgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuIGluY2x1ZGluZyBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIC8vIGogaXMgdGhlIGFjdHVhbCBpbmRleCBvZiByZCB3aXRoaW4gbiAoaWYgPCAwLCByZCBpcyBhIGxlYWRpbmcgemVybykuXHJcbiAgICAgICAgb3V0OiB7XHJcblxyXG4gICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLlxyXG4gICAgICAgICAgZm9yIChkID0gMSwgayA9IHhjWzBdOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG4gICAgICAgICAgaSA9IHNkIC0gZDtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgICBpICs9IExPR19CQVNFO1xyXG4gICAgICAgICAgICBqID0gc2Q7XHJcbiAgICAgICAgICAgIG4gPSB4Y1tuaSA9IDBdO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgIHJkID0gbiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTAgfCAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmkgPSBtYXRoY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5pID49IHhjLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5lZWRlZCBieSBzcXJ0LlxyXG4gICAgICAgICAgICAgICAgZm9yICg7IHhjLmxlbmd0aCA8PSBuaTsgeGMucHVzaCgwKSk7XHJcbiAgICAgICAgICAgICAgICBuID0gcmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZCA9IDE7XHJcbiAgICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG4gICAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIDE7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbiA9IGsgPSB4Y1tuaV07XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgICAgICAgIGZvciAoZCA9IDE7IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4uXHJcbiAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiwgYWRqdXN0ZWQgZm9yIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4gaXMgZ2l2ZW4gYnkgTE9HX0JBU0UgLSBkLlxyXG4gICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyBkO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgICByZCA9IGogPCAwID8gMCA6IG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwIHwgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHIgPSByIHx8IHNkIDwgMCB8fFxyXG5cclxuICAgICAgICAgIC8vIEFyZSB0aGVyZSBhbnkgbm9uLXplcm8gZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdD9cclxuICAgICAgICAgIC8vIFRoZSBleHByZXNzaW9uICBuICUgcG93czEwW2QgLSBqIC0gMV0gIHJldHVybnMgYWxsIGRpZ2l0cyBvZiBuIHRvIHRoZSByaWdodFxyXG4gICAgICAgICAgLy8gb2YgdGhlIGRpZ2l0IGF0IGosIGUuZy4gaWYgbiBpcyA5MDg3MTQgYW5kIGogaXMgMiwgdGhlIGV4cHJlc3Npb24gZ2l2ZXMgNzE0LlxyXG4gICAgICAgICAgIHhjW25pICsgMV0gIT0gbnVsbCB8fCAoaiA8IDAgPyBuIDogbiAlIHBvd3MxMFtkIC0gaiAtIDFdKTtcclxuXHJcbiAgICAgICAgICByID0gcm0gPCA0XHJcbiAgICAgICAgICAgPyAocmQgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgOiByZCA+IDUgfHwgcmQgPT0gNSAmJiAocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiZcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRpZ2l0IHRvIHRoZSBsZWZ0IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBvZGQuXHJcbiAgICAgICAgICAgICgoaSA+IDAgPyBqID4gMCA/IG4gLyBwb3dzMTBbZCAtIGpdIDogMCA6IHhjW25pIC0gMV0pICUgMTApICYgMSB8fFxyXG4gICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICAgIGlmIChzZCA8IDEgfHwgIXhjWzBdKSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHNkIHRvIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgICAgIHNkIC09IHguZSArIDE7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDEsIDAuMSwgMC4wMSwgMC4wMDEsIDAuMDAwMSBldGMuXHJcbiAgICAgICAgICAgICAgeGNbMF0gPSBwb3dzMTBbKExPR19CQVNFIC0gc2QgJSBMT0dfQkFTRSkgJSBMT0dfQkFTRV07XHJcbiAgICAgICAgICAgICAgeC5lID0gLXNkIHx8IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgICAgeGNbMF0gPSB4LmUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgZXhjZXNzIGRpZ2l0cy5cclxuICAgICAgICAgIGlmIChpID09IDApIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gbmk7XHJcbiAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICBuaS0tO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gbmkgKyAxO1xyXG4gICAgICAgICAgICBrID0gcG93czEwW0xPR19CQVNFIC0gaV07XHJcblxyXG4gICAgICAgICAgICAvLyBFLmcuIDU2NzAwIGJlY29tZXMgNTYwMDAgaWYgNyBpcyB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgIC8vIGogPiAwIG1lYW5zIGkgPiBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuLlxyXG4gICAgICAgICAgICB4Y1tuaV0gPSBqID4gMCA/IG1hdGhmbG9vcihuIC8gcG93czEwW2QgLSBqXSAlIHBvd3MxMFtqXSkgKiBrIDogMDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiB0aGUgZGlnaXQgdG8gYmUgcm91bmRlZCB1cCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgICAgIGlmIChuaSA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaSB3aWxsIGJlIHRoZSBsZW5ndGggb2YgeGNbMF0gYmVmb3JlIGsgaXMgYWRkZWQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBqID0geGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcbiAgICAgICAgICAgICAgICBqID0geGNbMF0gKz0gaztcclxuICAgICAgICAgICAgICAgIGZvciAoayA9IDE7IGogPj0gMTA7IGogLz0gMTAsIGsrKyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgaSAhPSBrIHRoZSBsZW5ndGggaGFzIGluY3JlYXNlZC5cclxuICAgICAgICAgICAgICAgIGlmIChpICE9IGspIHtcclxuICAgICAgICAgICAgICAgICAgeC5lKys7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh4Y1swXSA9PSBCQVNFKSB4Y1swXSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHhjW25pXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhjW25pXSAhPSBCQVNFKSBicmVhaztcclxuICAgICAgICAgICAgICAgIHhjW25pLS1dID0gMDtcclxuICAgICAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgIGZvciAoaSA9IHhjLmxlbmd0aDsgeGNbLS1pXSA9PT0gMDsgeGMucG9wKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3ZlcmZsb3c/IEluZmluaXR5LlxyXG4gICAgICAgIGlmICh4LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBVbmRlcmZsb3c/IFplcm8uXHJcbiAgICAgICAgfSBlbHNlIGlmICh4LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdmFsdWVPZihuKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgIGlmIChlID09PSBudWxsKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG5cclxuICAgICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIGUpXHJcbiAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgcmV0dXJuIG4ucyA8IDAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIFBST1RPVFlQRS9JTlNUQU5DRSBNRVRIT0RTXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlci5cclxuICAgICAqL1xyXG4gICAgUC5hYnNvbHV0ZVZhbHVlID0gUC5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgaWYgKHgucyA8IDApIHgucyA9IDE7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVyblxyXG4gICAgICogICAxIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqICAgLTEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAwIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZSxcclxuICAgICAqICAgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgZWl0aGVyIGlzIE5hTi5cclxuICAgICAqL1xyXG4gICAgUC5jb21wYXJlZFRvID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogSWYgZHAgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb2YgdGhlXHJcbiAgICAgKiB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgKlxyXG4gICAgICogT3RoZXJ3aXNlLCBpZiBkcCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIGRwIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlczogaW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLmRlY2ltYWxQbGFjZXMgPSBQLmRwID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICB2YXIgYywgbiwgdixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIGRwICsgeC5lICsgMSwgcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICAgIG4gPSAoKHYgPSBjLmxlbmd0aCAtIDEpIC0gYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpKSAqIExPR19CQVNFO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBudW1iZXIuXHJcbiAgICAgIGlmICh2ID0gY1t2XSkgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG4gICAgICBpZiAobiA8IDApIG4gPSAwO1xyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gLyAwID0gSVxyXG4gICAgICogIG4gLyBOID0gTlxyXG4gICAgICogIG4gLyBJID0gMFxyXG4gICAgICogIDAgLyBuID0gMFxyXG4gICAgICogIDAgLyAwID0gTlxyXG4gICAgICogIDAgLyBOID0gTlxyXG4gICAgICogIDAgLyBJID0gMFxyXG4gICAgICogIE4gLyBuID0gTlxyXG4gICAgICogIE4gLyAwID0gTlxyXG4gICAgICogIE4gLyBOID0gTlxyXG4gICAgICogIE4gLyBJID0gTlxyXG4gICAgICogIEkgLyBuID0gSVxyXG4gICAgICogIEkgLyAwID0gSVxyXG4gICAgICogIEkgLyBOID0gTlxyXG4gICAgICogIEkgLyBJID0gTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGRpdmlkZWQgYnkgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRCeSA9IFAuZGl2ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCBERUNJTUFMX1BMQUNFUywgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgaW50ZWdlciBwYXJ0IG9mIGRpdmlkaW5nIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgYnkgdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5kaXZpZGVkVG9JbnRlZ2VyQnkgPSBQLmlkaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIDAsIDEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZXhwb25lbnRpYXRlZCBieSBuLlxyXG4gICAgICpcclxuICAgICAqIElmIG0gaXMgcHJlc2VudCwgcmV0dXJuIHRoZSByZXN1bHQgbW9kdWxvIG0uXHJcbiAgICAgKiBJZiBuIGlzIG5lZ2F0aXZlIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqIElmIFBPV19QUkVDSVNJT04gaXMgbm9uLXplcm8gYW5kIG0gaXMgbm90IHByZXNlbnQsIHJvdW5kIHRvIFBPV19QUkVDSVNJT04gdXNpbmcgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgbW9kdWxhciBwb3dlciBvcGVyYXRpb24gd29ya3MgZWZmaWNpZW50bHkgd2hlbiB4LCBuLCBhbmQgbSBhcmUgaW50ZWdlcnMsIG90aGVyd2lzZSBpdFxyXG4gICAgICogaXMgZXF1aXZhbGVudCB0byBjYWxjdWxhdGluZyB4LmV4cG9uZW50aWF0ZWRCeShuKS5tb2R1bG8obSkgd2l0aCBhIFBPV19QUkVDSVNJT04gb2YgMC5cclxuICAgICAqXHJcbiAgICAgKiBuIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIGV4cG9uZW50LiBBbiBpbnRlZ2VyLlxyXG4gICAgICogW21dIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIG1vZHVsdXMuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEV4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiB7bn0nXHJcbiAgICAgKi9cclxuICAgIFAuZXhwb25lbnRpYXRlZEJ5ID0gUC5wb3cgPSBmdW5jdGlvbiAobiwgbSkge1xyXG4gICAgICB2YXIgaGFsZiwgaXNNb2RFeHAsIGksIGssIG1vcmUsIG5Jc0JpZywgbklzTmVnLCBuSXNPZGQsIHksXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihuKTtcclxuXHJcbiAgICAgIC8vIEFsbG93IE5hTiBhbmQgwrFJbmZpbml0eSwgYnV0IG5vdCBvdGhlciBub24taW50ZWdlcnMuXHJcbiAgICAgIGlmIChuLmMgJiYgIW4uaXNJbnRlZ2VyKCkpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0V4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiAnICsgdmFsdWVPZihuKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChtICE9IG51bGwpIG0gPSBuZXcgQmlnTnVtYmVyKG0pO1xyXG5cclxuICAgICAgLy8gRXhwb25lbnQgb2YgTUFYX1NBRkVfSU5URUdFUiBpcyAxNS5cclxuICAgICAgbklzQmlnID0gbi5lID4gMTQ7XHJcblxyXG4gICAgICAvLyBJZiB4IGlzIE5hTiwgwrFJbmZpbml0eSwgwrEwIG9yIMKxMSwgb3IgbiBpcyDCsUluZmluaXR5LCBOYU4gb3IgwrEwLlxyXG4gICAgICBpZiAoIXguYyB8fCAheC5jWzBdIHx8IHguY1swXSA9PSAxICYmICF4LmUgJiYgeC5jLmxlbmd0aCA9PSAxIHx8ICFuLmMgfHwgIW4uY1swXSkge1xyXG5cclxuICAgICAgICAvLyBUaGUgc2lnbiBvZiB0aGUgcmVzdWx0IG9mIHBvdyB3aGVuIHggaXMgbmVnYXRpdmUgZGVwZW5kcyBvbiB0aGUgZXZlbm5lc3Mgb2Ygbi5cclxuICAgICAgICAvLyBJZiArbiBvdmVyZmxvd3MgdG8gwrFJbmZpbml0eSwgdGhlIGV2ZW5uZXNzIG9mIG4gd291bGQgYmUgbm90IGJlIGtub3duLlxyXG4gICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE1hdGgucG93KCt2YWx1ZU9mKHgpLCBuSXNCaWcgPyAyIC0gaXNPZGQobikgOiArdmFsdWVPZihuKSkpO1xyXG4gICAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBuSXNOZWcgPSBuLnMgPCAwO1xyXG5cclxuICAgICAgaWYgKG0pIHtcclxuXHJcbiAgICAgICAgLy8geCAlIG0gcmV0dXJucyBOYU4gaWYgYWJzKG0pIGlzIHplcm8sIG9yIG0gaXMgTmFOLlxyXG4gICAgICAgIGlmIChtLmMgPyAhbS5jWzBdIDogIW0ucykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgICAgaXNNb2RFeHAgPSAhbklzTmVnICYmIHguaXNJbnRlZ2VyKCkgJiYgbS5pc0ludGVnZXIoKTtcclxuXHJcbiAgICAgICAgaWYgKGlzTW9kRXhwKSB4ID0geC5tb2QobSk7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdyB0byDCsUluZmluaXR5OiA+PTIqKjFlMTAgb3IgPj0xLjAwMDAwMjQqKjFlMTUuXHJcbiAgICAgIC8vIFVuZGVyZmxvdyB0byDCsTA6IDw9MC43OSoqMWUxMCBvciA8PTAuOTk5OTk3NSoqMWUxNS5cclxuICAgICAgfSBlbHNlIGlmIChuLmUgPiA5ICYmICh4LmUgPiAwIHx8IHguZSA8IC0xIHx8ICh4LmUgPT0gMFxyXG4gICAgICAgIC8vIFsxLCAyNDAwMDAwMDBdXHJcbiAgICAgICAgPyB4LmNbMF0gPiAxIHx8IG5Jc0JpZyAmJiB4LmNbMV0gPj0gMjRlN1xyXG4gICAgICAgIC8vIFs4MDAwMDAwMDAwMDAwMF0gIFs5OTk5OTc1MDAwMDAwMF1cclxuICAgICAgICA6IHguY1swXSA8IDhlMTMgfHwgbklzQmlnICYmIHguY1swXSA8PSA5OTk5OTc1ZTcpKSkge1xyXG5cclxuICAgICAgICAvLyBJZiB4IGlzIG5lZ2F0aXZlIGFuZCBuIGlzIG9kZCwgayA9IC0wLCBlbHNlIGsgPSAwLlxyXG4gICAgICAgIGsgPSB4LnMgPCAwICYmIGlzT2RkKG4pID8gLTAgOiAwO1xyXG5cclxuICAgICAgICAvLyBJZiB4ID49IDEsIGsgPSDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICh4LmUgPiAtMSkgayA9IDEgLyBrO1xyXG5cclxuICAgICAgICAvLyBJZiBuIGlzIG5lZ2F0aXZlIHJldHVybiDCsTAsIGVsc2UgcmV0dXJuIMKxSW5maW5pdHkuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIobklzTmVnID8gMSAvIGsgOiBrKTtcclxuXHJcbiAgICAgIH0gZWxzZSBpZiAoUE9XX1BSRUNJU0lPTikge1xyXG5cclxuICAgICAgICAvLyBUcnVuY2F0aW5nIGVhY2ggY29lZmZpY2llbnQgYXJyYXkgdG8gYSBsZW5ndGggb2YgayBhZnRlciBlYWNoIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgLy8gZXF1YXRlcyB0byB0cnVuY2F0aW5nIHNpZ25pZmljYW50IGRpZ2l0cyB0byBQT1dfUFJFQ0lTSU9OICsgWzI4LCA0MV0sXHJcbiAgICAgICAgLy8gaS5lLiB0aGVyZSB3aWxsIGJlIGEgbWluaW11bSBvZiAyOCBndWFyZCBkaWdpdHMgcmV0YWluZWQuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKFBPV19QUkVDSVNJT04gLyBMT0dfQkFTRSArIDIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobklzQmlnKSB7XHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoMC41KTtcclxuICAgICAgICBpZiAobklzTmVnKSBuLnMgPSAxO1xyXG4gICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGkgPSBNYXRoLmFicygrdmFsdWVPZihuKSk7XHJcbiAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAvLyBQZXJmb3JtcyA1NCBsb29wIGl0ZXJhdGlvbnMgZm9yIG4gb2YgOTAwNzE5OTI1NDc0MDk5MS5cclxuICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgaWYgKG5Jc09kZCkge1xyXG4gICAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgICBpZiAoIXkuYykgYnJlYWs7XHJcblxyXG4gICAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgICAgaWYgKHkuYy5sZW5ndGggPiBrKSB5LmMubGVuZ3RoID0gaztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgICAgeSA9IHkubW9kKG0pOyAgICAvL3kgPSB5Lm1pbnVzKGRpdih5LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGkpIHtcclxuICAgICAgICAgIGkgPSBtYXRoZmxvb3IoaSAvIDIpO1xyXG4gICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBuLnRpbWVzKGhhbGYpO1xyXG4gICAgICAgICAgcm91bmQobiwgbi5lICsgMSwgMSk7XHJcblxyXG4gICAgICAgICAgaWYgKG4uZSA+IDE0KSB7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSA9ICt2YWx1ZU9mKG4pO1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeCA9IHgudGltZXMoeCk7XHJcblxyXG4gICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICBpZiAoeC5jICYmIHguYy5sZW5ndGggPiBrKSB4LmMubGVuZ3RoID0gaztcclxuICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICB4ID0geC5tb2QobSk7ICAgIC8veCA9IHgubWludXMoZGl2KHgsIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNNb2RFeHApIHJldHVybiB5O1xyXG4gICAgICBpZiAobklzTmVnKSB5ID0gT05FLmRpdih5KTtcclxuXHJcbiAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiBrID8gcm91bmQoeSwgUE9XX1BSRUNJU0lPTiwgUk9VTkRJTkdfTU9ERSwgbW9yZSkgOiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYW4gaW50ZWdlclxyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3JtfSdcclxuICAgICAqL1xyXG4gICAgUC5pbnRlZ2VyVmFsdWUgPSBmdW5jdGlvbiAocm0pIHtcclxuICAgICAgdmFyIG4gPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuICAgICAgcmV0dXJuIHJvdW5kKG4sIG4uZSArIDEsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNFcXVhbFRvID0gUC5lcSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhIGZpbml0ZSBudW1iZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNGaW5pdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW4gPSBQLmd0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IDEgfHwgYiA9PT0gMDtcclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGFuIGludGVnZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNJbnRlZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpID4gdGhpcy5jLmxlbmd0aCAtIDI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTGVzc1RoYW5PckVxdWFsVG8gPSBQLmx0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAtMSB8fCBiID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBOYU4sIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOYU4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhdGhpcy5zO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc05lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgcG9zaXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIDAgb3IgLTAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgdGhpcy5jWzBdID09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gLSAwID0gblxyXG4gICAgICogIG4gLSBOID0gTlxyXG4gICAgICogIG4gLSBJID0gLUlcclxuICAgICAqICAwIC0gbiA9IC1uXHJcbiAgICAgKiAgMCAtIDAgPSAwXHJcbiAgICAgKiAgMCAtIE4gPSBOXHJcbiAgICAgKiAgMCAtIEkgPSAtSVxyXG4gICAgICogIE4gLSBuID0gTlxyXG4gICAgICogIE4gLSAwID0gTlxyXG4gICAgICogIE4gLSBOID0gTlxyXG4gICAgICogIE4gLSBJID0gTlxyXG4gICAgICogIEkgLSBuID0gSVxyXG4gICAgICogIEkgLSAwID0gSVxyXG4gICAgICogIEkgLSBOID0gTlxyXG4gICAgICogIEkgLSBJID0gTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1pbnVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLm1pbnVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGksIGosIHQsIHhMVHksXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgucGx1cyh5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIHhjID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeWMgPyB4IDogTmFOKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICAgIHJldHVybiB5Y1swXSA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6XHJcblxyXG4gICAgICAgICAgIC8vIElFRUUgNzU0ICgyMDA4KSA2LjM6IG4gLSBuID0gLTAgd2hlbiByb3VuZGluZyB0byAtSW5maW5pdHlcclxuICAgICAgICAgICBST1VORElOR19NT0RFID09IDMgPyAtMCA6IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG5cclxuICAgICAgICBpZiAoeExUeSA9IGEgPCAwKSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgICAgICAgZm9yIChiID0gYTsgYi0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudHMgZXF1YWwuIENoZWNrIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgICAgIGogPSAoeExUeSA9IChhID0geGMubGVuZ3RoKSA8IChiID0geWMubGVuZ3RoKSkgPyBhIDogYjtcclxuXHJcbiAgICAgICAgZm9yIChhID0gYiA9IDA7IGIgPCBqOyBiKyspIHtcclxuXHJcbiAgICAgICAgICBpZiAoeGNbYl0gIT0geWNbYl0pIHtcclxuICAgICAgICAgICAgeExUeSA9IHhjW2JdIDwgeWNbYl07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geCA8IHk/IFBvaW50IHhjIHRvIHRoZSBhcnJheSBvZiB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgaWYgKHhMVHkpIHQgPSB4YywgeGMgPSB5YywgeWMgPSB0LCB5LnMgPSAteS5zO1xyXG5cclxuICAgICAgYiA9IChqID0geWMubGVuZ3RoKSAtIChpID0geGMubGVuZ3RoKTtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLlxyXG4gICAgICAvLyBObyBuZWVkIHRvIGFkZCB6ZXJvcyB0byB5YyBpZiBzaG9ydGVyIGFzIHN1YnRyYWN0IG9ubHkgbmVlZHMgdG8gc3RhcnQgYXQgeWMubGVuZ3RoLlxyXG4gICAgICBpZiAoYiA+IDApIGZvciAoOyBiLS07IHhjW2krK10gPSAwKTtcclxuICAgICAgYiA9IEJBU0UgLSAxO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgeWMgZnJvbSB4Yy5cclxuICAgICAgZm9yICg7IGogPiBhOykge1xyXG5cclxuICAgICAgICBpZiAoeGNbLS1qXSA8IHljW2pdKSB7XHJcbiAgICAgICAgICBmb3IgKGkgPSBqOyBpICYmICF4Y1stLWldOyB4Y1tpXSA9IGIpO1xyXG4gICAgICAgICAgLS14Y1tpXTtcclxuICAgICAgICAgIHhjW2pdICs9IEJBU0U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4Y1tqXSAtPSB5Y1tqXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MgYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgZm9yICg7IHhjWzBdID09IDA7IHhjLnNwbGljZSgwLCAxKSwgLS15ZSk7XHJcblxyXG4gICAgICAvLyBaZXJvP1xyXG4gICAgICBpZiAoIXhjWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIEZvbGxvd2luZyBJRUVFIDc1NCAoMjAwOCkgNi4zLFxyXG4gICAgICAgIC8vIG4gLSBuID0gKzAgIGJ1dCAgbiAtIG4gPSAtMCAgd2hlbiByb3VuZGluZyB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgICB5LnMgPSBST1VORElOR19NT0RFID09IDMgPyAtMSA6IDE7XHJcbiAgICAgICAgeS5jID0gW3kuZSA9IDBdO1xyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciBJbmZpbml0eSBhcyAreCAtICt5ICE9IEluZmluaXR5ICYmIC14IC0gLXkgIT0gSW5maW5pdHlcclxuICAgICAgLy8gZm9yIGZpbml0ZSB4IGFuZCB5LlxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogICBuICUgMCA9ICBOXHJcbiAgICAgKiAgIG4gJSBOID0gIE5cclxuICAgICAqICAgbiAlIEkgPSAgblxyXG4gICAgICogICAwICUgbiA9ICAwXHJcbiAgICAgKiAgLTAgJSBuID0gLTBcclxuICAgICAqICAgMCAlIDAgPSAgTlxyXG4gICAgICogICAwICUgTiA9ICBOXHJcbiAgICAgKiAgIDAgJSBJID0gIDBcclxuICAgICAqICAgTiAlIG4gPSAgTlxyXG4gICAgICogICBOICUgMCA9ICBOXHJcbiAgICAgKiAgIE4gJSBOID0gIE5cclxuICAgICAqICAgTiAlIEkgPSAgTlxyXG4gICAgICogICBJICUgbiA9ICBOXHJcbiAgICAgKiAgIEkgJSAwID0gIE5cclxuICAgICAqICAgSSAlIE4gPSAgTlxyXG4gICAgICogICBJICUgSSA9ICBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbW9kdWxvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLiBUaGUgcmVzdWx0IGRlcGVuZHMgb24gdGhlIHZhbHVlIG9mIE1PRFVMT19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLm1vZHVsbyA9IFAubW9kID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHEsIHMsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgeCBpcyBJbmZpbml0eSBvciBOYU4sIG9yIHkgaXMgTmFOIG9yIHplcm8uXHJcbiAgICAgIGlmICgheC5jIHx8ICF5LnMgfHwgeS5jICYmICF5LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIHggaWYgeSBpcyBJbmZpbml0eSBvciB4IGlzIHplcm8uXHJcbiAgICAgIH0gZWxzZSBpZiAoIXkuYyB8fCB4LmMgJiYgIXguY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoTU9EVUxPX01PREUgPT0gOSkge1xyXG5cclxuICAgICAgICAvLyBFdWNsaWRpYW4gZGl2aXNpb246IHEgPSBzaWduKHkpICogZmxvb3IoeCAvIGFicyh5KSlcclxuICAgICAgICAvLyByID0geCAtIHF5ICAgIHdoZXJlICAwIDw9IHIgPCBhYnMoeSlcclxuICAgICAgICBzID0geS5zO1xyXG4gICAgICAgIHkucyA9IDE7XHJcbiAgICAgICAgcSA9IGRpdih4LCB5LCAwLCAzKTtcclxuICAgICAgICB5LnMgPSBzO1xyXG4gICAgICAgIHEucyAqPSBzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgTU9EVUxPX01PREUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB5ID0geC5taW51cyhxLnRpbWVzKHkpKTtcclxuXHJcbiAgICAgIC8vIFRvIG1hdGNoIEphdmFTY3JpcHQgJSwgZW5zdXJlIHNpZ24gb2YgemVybyBpcyBzaWduIG9mIGRpdmlkZW5kLlxyXG4gICAgICBpZiAoIXkuY1swXSAmJiBNT0RVTE9fTU9ERSA9PSAxKSB5LnMgPSB4LnM7XHJcblxyXG4gICAgICByZXR1cm4geTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAqIDAgPSAwXHJcbiAgICAgKiAgbiAqIE4gPSBOXHJcbiAgICAgKiAgbiAqIEkgPSBJXHJcbiAgICAgKiAgMCAqIG4gPSAwXHJcbiAgICAgKiAgMCAqIDAgPSAwXHJcbiAgICAgKiAgMCAqIE4gPSBOXHJcbiAgICAgKiAgMCAqIEkgPSBOXHJcbiAgICAgKiAgTiAqIG4gPSBOXHJcbiAgICAgKiAgTiAqIDAgPSBOXHJcbiAgICAgKiAgTiAqIE4gPSBOXHJcbiAgICAgKiAgTiAqIEkgPSBOXHJcbiAgICAgKiAgSSAqIG4gPSBJXHJcbiAgICAgKiAgSSAqIDAgPSBOXHJcbiAgICAgKiAgSSAqIE4gPSBOXHJcbiAgICAgKiAgSSAqIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbXVsdGlwbGllZCBieSB0aGUgdmFsdWVcclxuICAgICAqIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5tdWx0aXBsaWVkQnkgPSBQLnRpbWVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGMsIGUsIGksIGosIGssIG0sIHhjTCwgeGxvLCB4aGksIHljTCwgeWxvLCB5aGksIHpjLFxyXG4gICAgICAgIGJhc2UsIHNxcnRCYXNlLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0gKHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpKS5jO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTiwgwrFJbmZpbml0eSBvciDCsTA/XHJcbiAgICAgIGlmICgheGMgfHwgIXljIHx8ICF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLCBvciBvbmUgaXMgMCBhbmQgdGhlIG90aGVyIGlzIEluZmluaXR5LlxyXG4gICAgICAgIGlmICgheC5zIHx8ICF5LnMgfHwgeGMgJiYgIXhjWzBdICYmICF5YyB8fCB5YyAmJiAheWNbMF0gJiYgIXhjKSB7XHJcbiAgICAgICAgICB5LmMgPSB5LmUgPSB5LnMgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5LnMgKj0geC5zO1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciBpcyDCsUluZmluaXR5LlxyXG4gICAgICAgICAgaWYgKCF4YyB8fCAheWMpIHtcclxuICAgICAgICAgICAgeS5jID0geS5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIGVpdGhlciBpcyDCsTAuXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB5LmMgPSBbMF07XHJcbiAgICAgICAgICAgIHkuZSA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSArIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgeS5zICo9IHgucztcclxuICAgICAgeGNMID0geGMubGVuZ3RoO1xyXG4gICAgICB5Y0wgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBFbnN1cmUgeGMgcG9pbnRzIHRvIGxvbmdlciBhcnJheSBhbmQgeGNMIHRvIGl0cyBsZW5ndGguXHJcbiAgICAgIGlmICh4Y0wgPCB5Y0wpIHpjID0geGMsIHhjID0geWMsIHljID0gemMsIGkgPSB4Y0wsIHhjTCA9IHljTCwgeWNMID0gaTtcclxuXHJcbiAgICAgIC8vIEluaXRpYWxpc2UgdGhlIHJlc3VsdCBhcnJheSB3aXRoIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSB4Y0wgKyB5Y0wsIHpjID0gW107IGktLTsgemMucHVzaCgwKSk7XHJcblxyXG4gICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgc3FydEJhc2UgPSBTUVJUX0JBU0U7XHJcblxyXG4gICAgICBmb3IgKGkgPSB5Y0w7IC0taSA+PSAwOykge1xyXG4gICAgICAgIGMgPSAwO1xyXG4gICAgICAgIHlsbyA9IHljW2ldICUgc3FydEJhc2U7XHJcbiAgICAgICAgeWhpID0geWNbaV0gLyBzcXJ0QmFzZSB8IDA7XHJcblxyXG4gICAgICAgIGZvciAoayA9IHhjTCwgaiA9IGkgKyBrOyBqID4gaTspIHtcclxuICAgICAgICAgIHhsbyA9IHhjWy0ta10gJSBzcXJ0QmFzZTtcclxuICAgICAgICAgIHhoaSA9IHhjW2tdIC8gc3FydEJhc2UgfCAwO1xyXG4gICAgICAgICAgbSA9IHloaSAqIHhsbyArIHhoaSAqIHlsbztcclxuICAgICAgICAgIHhsbyA9IHlsbyAqIHhsbyArICgobSAlIHNxcnRCYXNlKSAqIHNxcnRCYXNlKSArIHpjW2pdICsgYztcclxuICAgICAgICAgIGMgPSAoeGxvIC8gYmFzZSB8IDApICsgKG0gLyBzcXJ0QmFzZSB8IDApICsgeWhpICogeGhpO1xyXG4gICAgICAgICAgemNbai0tXSA9IHhsbyAlIGJhc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB6Y1tqXSA9IGM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjKSB7XHJcbiAgICAgICAgKytlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHpjLnNwbGljZSgwLCAxKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB6YywgZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbmVnYXRlZCxcclxuICAgICAqIGkuZS4gbXVsdGlwbGllZCBieSAtMS5cclxuICAgICAqL1xyXG4gICAgUC5uZWdhdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIHgucyA9IC14LnMgfHwgbnVsbDtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gKyAwID0gblxyXG4gICAgICogIG4gKyBOID0gTlxyXG4gICAgICogIG4gKyBJID0gSVxyXG4gICAgICogIDAgKyBuID0gblxyXG4gICAgICogIDAgKyAwID0gMFxyXG4gICAgICogIDAgKyBOID0gTlxyXG4gICAgICogIDAgKyBJID0gSVxyXG4gICAgICogIE4gKyBuID0gTlxyXG4gICAgICogIE4gKyAwID0gTlxyXG4gICAgICogIE4gKyBOID0gTlxyXG4gICAgICogIE4gKyBJID0gTlxyXG4gICAgICogIEkgKyBuID0gSVxyXG4gICAgICogIEkgKyAwID0gSVxyXG4gICAgICogIEkgKyBOID0gTlxyXG4gICAgICogIEkgKyBJID0gSVxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHBsdXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAucGx1cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciB0LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgICAgYiA9IHkucztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgIGlmIChhICE9IGIpIHtcclxuICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICByZXR1cm4geC5taW51cyh5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gbmV3IEJpZ051bWJlcihhIC8gMCk7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSByZXR1cm4geWNbMF0gPyB5IDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOiBhICogMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuIEZhc3RlciB0byB1c2UgcmV2ZXJzZSB0aGVuIGRvIHVuc2hpZnRzLlxyXG4gICAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuICAgICAgICBpZiAoYSA+IDApIHtcclxuICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICAgIGZvciAoOyBhLS07IHQucHVzaCgwKSk7XHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGEgPSB4Yy5sZW5ndGg7XHJcbiAgICAgIGIgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBQb2ludCB4YyB0byB0aGUgbG9uZ2VyIGFycmF5LCBhbmQgYiB0byB0aGUgc2hvcnRlciBsZW5ndGguXHJcbiAgICAgIGlmIChhIC0gYiA8IDApIHQgPSB5YywgeWMgPSB4YywgeGMgPSB0LCBiID0gYTtcclxuXHJcbiAgICAgIC8vIE9ubHkgc3RhcnQgYWRkaW5nIGF0IHljLmxlbmd0aCAtIDEgYXMgdGhlIGZ1cnRoZXIgZGlnaXRzIG9mIHhjIGNhbiBiZSBpZ25vcmVkLlxyXG4gICAgICBmb3IgKGEgPSAwOyBiOykge1xyXG4gICAgICAgIGEgPSAoeGNbLS1iXSA9IHhjW2JdICsgeWNbYl0gKyBhKSAvIEJBU0UgfCAwO1xyXG4gICAgICAgIHhjW2JdID0gQkFTRSA9PT0geGNbYl0gPyAwIDogeGNbYl0gJSBCQVNFO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYSkge1xyXG4gICAgICAgIHhjID0gW2FdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgKyt5ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgemVybywgYXMgK3ggKyAreSAhPSAwICYmIC14ICsgLXkgIT0gMFxyXG4gICAgICAvLyB5ZSA9IE1BWF9FWFAgKyAxIHBvc3NpYmxlXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBzZCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2ZcclxuICAgICAqIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgKiBJZiBzZCBpcyB0cnVlIGluY2x1ZGUgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zIGluIHRoZSBjb3VudC5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIHNkIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2Ygc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogc2Qge251bWJlcnxib29sZWFufSBudW1iZXI6IHNpZ25pZmljYW50IGRpZ2l0czogaW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICBib29sZWFuOiB3aGV0aGVyIHRvIGNvdW50IGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvczogdHJ1ZSBvciBmYWxzZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgICB2YXIgYywgbiwgdixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChzZCAhPSBudWxsICYmIHNkICE9PSAhIXNkKSB7XHJcbiAgICAgICAgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIHNkLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgdiA9IGMubGVuZ3RoIC0gMTtcclxuICAgICAgbiA9IHYgKiBMT0dfQkFTRSArIDE7XHJcblxyXG4gICAgICBpZiAodiA9IGNbdl0pIHtcclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBlbGVtZW50LlxyXG4gICAgICAgIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50LlxyXG4gICAgICAgIGZvciAodiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIG4rKyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZCAmJiB4LmUgKyAxID4gbikgbiA9IHguZSArIDE7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBzaGlmdGVkIGJ5IGsgcGxhY2VzXHJcbiAgICAgKiAocG93ZXJzIG9mIDEwKS4gU2hpZnQgdG8gdGhlIHJpZ2h0IGlmIG4gPiAwLCBhbmQgdG8gdGhlIGxlZnQgaWYgbiA8IDAuXHJcbiAgICAgKlxyXG4gICAgICogayB7bnVtYmVyfSBJbnRlZ2VyLCAtTUFYX1NBRkVfSU5URUdFUiB0byBNQVhfU0FGRV9JTlRFR0VSIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2t9J1xyXG4gICAgICovXHJcbiAgICBQLnNoaWZ0ZWRCeSA9IGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgIGludENoZWNrKGssIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKTtcclxuICAgICAgcmV0dXJuIHRoaXMudGltZXMoJzFlJyArIGspO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBzcXJ0KC1uKSA9ICBOXHJcbiAgICAgKiAgc3FydChOKSA9ICBOXHJcbiAgICAgKiAgc3FydCgtSSkgPSAgTlxyXG4gICAgICogIHNxcnQoSSkgPSAgSVxyXG4gICAgICogIHNxcnQoMCkgPSAgMFxyXG4gICAgICogIHNxcnQoLTApID0gLTBcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsXHJcbiAgICAgKiByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5zcXVhcmVSb290ID0gUC5zcXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgbSwgbiwgciwgcmVwLCB0LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGMgPSB4LmMsXHJcbiAgICAgICAgcyA9IHgucyxcclxuICAgICAgICBlID0geC5lLFxyXG4gICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMgKyA0LFxyXG4gICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKCcwLjUnKTtcclxuXHJcbiAgICAgIC8vIE5lZ2F0aXZlL05hTi9JbmZpbml0eS96ZXJvP1xyXG4gICAgICBpZiAocyAhPT0gMSB8fCAhYyB8fCAhY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCFzIHx8IHMgPCAwICYmICghYyB8fCBjWzBdKSA/IE5hTiA6IGMgPyB4IDogMSAvIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJbml0aWFsIGVzdGltYXRlLlxyXG4gICAgICBzID0gTWF0aC5zcXJ0KCt2YWx1ZU9mKHgpKTtcclxuXHJcbiAgICAgIC8vIE1hdGguc3FydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgICAgIC8vIFBhc3MgeCB0byBNYXRoLnNxcnQgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIGV4cG9uZW50IG9mIHRoZSByZXN1bHQuXHJcbiAgICAgIGlmIChzID09IDAgfHwgcyA9PSAxIC8gMCkge1xyXG4gICAgICAgIG4gPSBjb2VmZlRvU3RyaW5nKGMpO1xyXG4gICAgICAgIGlmICgobi5sZW5ndGggKyBlKSAlIDIgPT0gMCkgbiArPSAnMCc7XHJcbiAgICAgICAgcyA9IE1hdGguc3FydCgrbik7XHJcbiAgICAgICAgZSA9IGJpdEZsb29yKChlICsgMSkgLyAyKSAtIChlIDwgMCB8fCBlICUgMik7XHJcblxyXG4gICAgICAgIGlmIChzID09IDEgLyAwKSB7XHJcbiAgICAgICAgICBuID0gJzVlJyArIGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcclxuICAgICAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZignZScpICsgMSkgKyBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIobik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIocyArICcnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgZm9yIHplcm8uXHJcbiAgICAgIC8vIHIgY291bGQgYmUgemVybyBpZiBNSU5fRVhQIGlzIGNoYW5nZWQgYWZ0ZXIgdGhlIHRoaXMgdmFsdWUgd2FzIGNyZWF0ZWQuXHJcbiAgICAgIC8vIFRoaXMgd291bGQgY2F1c2UgYSBkaXZpc2lvbiBieSB6ZXJvICh4L3QpIGFuZCBoZW5jZSBJbmZpbml0eSBiZWxvdywgd2hpY2ggd291bGQgY2F1c2VcclxuICAgICAgLy8gY29lZmZUb1N0cmluZyB0byB0aHJvdy5cclxuICAgICAgaWYgKHIuY1swXSkge1xyXG4gICAgICAgIGUgPSByLmU7XHJcbiAgICAgICAgcyA9IGUgKyBkcDtcclxuICAgICAgICBpZiAocyA8IDMpIHMgPSAwO1xyXG5cclxuICAgICAgICAvLyBOZXd0b24tUmFwaHNvbiBpdGVyYXRpb24uXHJcbiAgICAgICAgZm9yICg7IDspIHtcclxuICAgICAgICAgIHQgPSByO1xyXG4gICAgICAgICAgciA9IGhhbGYudGltZXModC5wbHVzKGRpdih4LCB0LCBkcCwgMSkpKTtcclxuXHJcbiAgICAgICAgICBpZiAoY29lZmZUb1N0cmluZyh0LmMpLnNsaWNlKDAsIHMpID09PSAobiA9IGNvZWZmVG9TdHJpbmcoci5jKSkuc2xpY2UoMCwgcykpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBleHBvbmVudCBvZiByIG1heSBoZXJlIGJlIG9uZSBsZXNzIHRoYW4gdGhlIGZpbmFsIHJlc3VsdCBleHBvbmVudCxcclxuICAgICAgICAgICAgLy8gZS5nIDAuMDAwOTk5OSAoZS00KSAtLSA+IDAuMDAxIChlLTMpLCBzbyBhZGp1c3QgcyBzbyB0aGUgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgIC8vIGFyZSBpbmRleGVkIGNvcnJlY3RseS5cclxuICAgICAgICAgICAgaWYgKHIuZSA8IGUpIC0tcztcclxuICAgICAgICAgICAgbiA9IG4uc2xpY2UocyAtIDMsIHMgKyAxKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSA0dGggcm91bmRpbmcgZGlnaXQgbWF5IGJlIGluIGVycm9yIGJ5IC0xIHNvIGlmIHRoZSA0IHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAvLyBhcmUgOTk5OSBvciA0OTk5IChpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnkpIGNvbnRpbnVlIHRoZVxyXG4gICAgICAgICAgICAvLyBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgIGlmIChuID09ICc5OTk5JyB8fCAhcmVwICYmIG4gPT0gJzQ5OTknKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIE9uIHRoZSBmaXJzdCBpdGVyYXRpb24gb25seSwgY2hlY2sgdG8gc2VlIGlmIHJvdW5kaW5nIHVwIGdpdmVzIHRoZVxyXG4gICAgICAgICAgICAgIC8vIGV4YWN0IHJlc3VsdCBhcyB0aGUgbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxyXG4gICAgICAgICAgICAgIGlmICghcmVwKSB7XHJcbiAgICAgICAgICAgICAgICByb3VuZCh0LCB0LmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0LnRpbWVzKHQpLmVxKHgpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHIgPSB0O1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGRwICs9IDQ7XHJcbiAgICAgICAgICAgICAgcyArPSA0O1xyXG4gICAgICAgICAgICAgIHJlcCA9IDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHJvdW5kaW5nIGRpZ2l0cyBhcmUgbnVsbCwgMHswLDR9IG9yIDUwezAsM30sIGNoZWNrIGZvciBleGFjdFxyXG4gICAgICAgICAgICAgIC8vIHJlc3VsdC4gSWYgbm90LCB0aGVuIHRoZXJlIGFyZSBmdXJ0aGVyIGRpZ2l0cyBhbmQgbSB3aWxsIGJlIHRydXRoeS5cclxuICAgICAgICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSAnNScpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICByb3VuZChyLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDEpO1xyXG4gICAgICAgICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLmVxKHgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByb3VuZChyLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDEsIFJPVU5ESU5HX01PREUsIG0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uIGFuZFxyXG4gICAgICogcm91bmRlZCB1c2luZyBST1VORElOR19NT0RFIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGRwKys7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0sIDEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kaW5nXHJcbiAgICAgKiB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogYXMgd2l0aCBKYXZhU2NyaXB0J3MgbnVtYmVyIHR5cGUsICgtMCkudG9GaXhlZCgwKSBpcyAnMCcsXHJcbiAgICAgKiBidXQgZS5nLiAoLTAuMDAwMDEpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9GaXhlZCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBkcCA9IGRwICsgdGhpcy5lICsgMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRlZFxyXG4gICAgICogdXNpbmcgcm0gb3IgUk9VTkRJTkdfTU9ERSB0byBkcCBkZWNpbWFsIHBsYWNlcywgYW5kIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHByb3BlcnRpZXNcclxuICAgICAqIG9mIHRoZSBmb3JtYXQgb3IgRk9STUFUIG9iamVjdCAoc2VlIEJpZ051bWJlci5zZXQpLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBmb3JtYXR0aW5nIG9iamVjdCBtYXkgY29udGFpbiBzb21lIG9yIGFsbCBvZiB0aGUgcHJvcGVydGllcyBzaG93biBiZWxvdy5cclxuICAgICAqXHJcbiAgICAgKiBGT1JNQVQgPSB7XHJcbiAgICAgKiAgIHByZWZpeDogJycsXHJcbiAgICAgKiAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAqICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICogICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAgICogICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgKiAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICogICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICogICBzdWZmaXg6ICcnXHJcbiAgICAgKiB9O1xyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqIFtmb3JtYXRdIHtvYmplY3R9IEZvcm1hdHRpbmcgb3B0aW9ucy4gU2VlIEZPUk1BVCBwYmplY3QgYWJvdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQgbm90IGFuIG9iamVjdDoge2Zvcm1hdH0nXHJcbiAgICAgKi9cclxuICAgIFAudG9Gb3JtYXQgPSBmdW5jdGlvbiAoZHAsIHJtLCBmb3JtYXQpIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChkcCAhPSBudWxsICYmIHJtICYmIHR5cGVvZiBybSA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgZm9ybWF0ID0gcm07XHJcbiAgICAgICAgICBybSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkcCAmJiB0eXBlb2YgZHAgPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgIGZvcm1hdCA9IGRwO1xyXG4gICAgICAgICAgZHAgPSBybSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZvcm1hdCA9IEZPUk1BVDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvcm1hdCAhPSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgbm90IGFuIG9iamVjdDogJyArIGZvcm1hdCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0ciA9IHgudG9GaXhlZChkcCwgcm0pO1xyXG5cclxuICAgICAgaWYgKHguYykge1xyXG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcuJyksXHJcbiAgICAgICAgICBnMSA9ICtmb3JtYXQuZ3JvdXBTaXplLFxyXG4gICAgICAgICAgZzIgPSArZm9ybWF0LnNlY29uZGFyeUdyb3VwU2l6ZSxcclxuICAgICAgICAgIGdyb3VwU2VwYXJhdG9yID0gZm9ybWF0Lmdyb3VwU2VwYXJhdG9yIHx8ICcnLFxyXG4gICAgICAgICAgaW50UGFydCA9IGFyclswXSxcclxuICAgICAgICAgIGZyYWN0aW9uUGFydCA9IGFyclsxXSxcclxuICAgICAgICAgIGlzTmVnID0geC5zIDwgMCxcclxuICAgICAgICAgIGludERpZ2l0cyA9IGlzTmVnID8gaW50UGFydC5zbGljZSgxKSA6IGludFBhcnQsXHJcbiAgICAgICAgICBsZW4gPSBpbnREaWdpdHMubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoZzIpIGkgPSBnMSwgZzEgPSBnMiwgZzIgPSBpLCBsZW4gLT0gaTtcclxuXHJcbiAgICAgICAgaWYgKGcxID4gMCAmJiBsZW4gPiAwKSB7XHJcbiAgICAgICAgICBpID0gbGVuICUgZzEgfHwgZzE7XHJcbiAgICAgICAgICBpbnRQYXJ0ID0gaW50RGlnaXRzLnN1YnN0cigwLCBpKTtcclxuICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpICs9IGcxKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnN1YnN0cihpLCBnMSk7XHJcbiAgICAgICAgICBpZiAoZzIgPiAwKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnNsaWNlKGkpO1xyXG4gICAgICAgICAgaWYgKGlzTmVnKSBpbnRQYXJ0ID0gJy0nICsgaW50UGFydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IGZyYWN0aW9uUGFydFxyXG4gICAgICAgICA/IGludFBhcnQgKyAoZm9ybWF0LmRlY2ltYWxTZXBhcmF0b3IgfHwgJycpICsgKChnMiA9ICtmb3JtYXQuZnJhY3Rpb25Hcm91cFNpemUpXHJcbiAgICAgICAgICA/IGZyYWN0aW9uUGFydC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxkeycgKyBnMiArICd9XFxcXEInLCAnZycpLFxyXG4gICAgICAgICAgICckJicgKyAoZm9ybWF0LmZyYWN0aW9uR3JvdXBTZXBhcmF0b3IgfHwgJycpKVxyXG4gICAgICAgICAgOiBmcmFjdGlvblBhcnQpXHJcbiAgICAgICAgIDogaW50UGFydDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIChmb3JtYXQucHJlZml4IHx8ICcnKSArIHN0ciArIChmb3JtYXQuc3VmZml4IHx8ICcnKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgdHdvIEJpZ051bWJlcnMgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBhcyBhIHNpbXBsZVxyXG4gICAgICogZnJhY3Rpb24gd2l0aCBhbiBpbnRlZ2VyIG51bWVyYXRvciBhbmQgYW4gaW50ZWdlciBkZW5vbWluYXRvci5cclxuICAgICAqIFRoZSBkZW5vbWluYXRvciB3aWxsIGJlIGEgcG9zaXRpdmUgbm9uLXplcm8gdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWRcclxuICAgICAqIG1heGltdW0gZGVub21pbmF0b3IuIElmIGEgbWF4aW11bSBkZW5vbWluYXRvciBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgZGVub21pbmF0b3Igd2lsbCBiZVxyXG4gICAgICogdGhlIGxvd2VzdCB2YWx1ZSBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBudW1iZXIgZXhhY3RseS5cclxuICAgICAqXHJcbiAgICAgKiBbbWRdIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gSW50ZWdlciA+PSAxLCBvciBJbmZpbml0eS4gVGhlIG1heGltdW0gZGVub21pbmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9IDoge21kfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24gKG1kKSB7XHJcbiAgICAgIHZhciBkLCBkMCwgZDEsIGQyLCBlLCBleHAsIG4sIG4wLCBuMSwgcSwgciwgcyxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYztcclxuXHJcbiAgICAgIGlmIChtZCAhPSBudWxsKSB7XHJcbiAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobWQpO1xyXG5cclxuICAgICAgICAvLyBUaHJvdyBpZiBtZCBpcyBsZXNzIHRoYW4gb25lIG9yIGlzIG5vdCBhbiBpbnRlZ2VyLCB1bmxlc3MgaXQgaXMgSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCFuLmlzSW50ZWdlcigpICYmIChuLmMgfHwgbi5zICE9PSAxKSB8fCBuLmx0KE9ORSkpIHtcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCAnICtcclxuICAgICAgICAgICAgICAobi5pc0ludGVnZXIoKSA/ICdvdXQgb2YgcmFuZ2U6ICcgOiAnbm90IGFuIGludGVnZXI6ICcpICsgdmFsdWVPZihuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXhjKSByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuXHJcbiAgICAgIGQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIG4xID0gZDAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIGQxID0gbjAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIHMgPSBjb2VmZlRvU3RyaW5nKHhjKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSBpbml0aWFsIGRlbm9taW5hdG9yLlxyXG4gICAgICAvLyBkIGlzIGEgcG93ZXIgb2YgMTAgYW5kIHRoZSBtaW5pbXVtIG1heCBkZW5vbWluYXRvciB0aGF0IHNwZWNpZmllcyB0aGUgdmFsdWUgZXhhY3RseS5cclxuICAgICAgZSA9IGQuZSA9IHMubGVuZ3RoIC0geC5lIC0gMTtcclxuICAgICAgZC5jWzBdID0gUE9XU19URU5bKGV4cCA9IGUgJSBMT0dfQkFTRSkgPCAwID8gTE9HX0JBU0UgKyBleHAgOiBleHBdO1xyXG4gICAgICBtZCA9ICFtZCB8fCBuLmNvbXBhcmVkVG8oZCkgPiAwID8gKGUgPiAwID8gZCA6IG4xKSA6IG47XHJcblxyXG4gICAgICBleHAgPSBNQVhfRVhQO1xyXG4gICAgICBNQVhfRVhQID0gMSAvIDA7XHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG5cclxuICAgICAgLy8gbjAgPSBkMSA9IDBcclxuICAgICAgbjAuY1swXSA9IDA7XHJcblxyXG4gICAgICBmb3IgKDsgOykgIHtcclxuICAgICAgICBxID0gZGl2KG4sIGQsIDAsIDEpO1xyXG4gICAgICAgIGQyID0gZDAucGx1cyhxLnRpbWVzKGQxKSk7XHJcbiAgICAgICAgaWYgKGQyLmNvbXBhcmVkVG8obWQpID09IDEpIGJyZWFrO1xyXG4gICAgICAgIGQwID0gZDE7XHJcbiAgICAgICAgZDEgPSBkMjtcclxuICAgICAgICBuMSA9IG4wLnBsdXMocS50aW1lcyhkMiA9IG4xKSk7XHJcbiAgICAgICAgbjAgPSBkMjtcclxuICAgICAgICBkID0gbi5taW51cyhxLnRpbWVzKGQyID0gZCkpO1xyXG4gICAgICAgIG4gPSBkMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZDIgPSBkaXYobWQubWludXMoZDApLCBkMSwgMCwgMSk7XHJcbiAgICAgIG4wID0gbjAucGx1cyhkMi50aW1lcyhuMSkpO1xyXG4gICAgICBkMCA9IGQwLnBsdXMoZDIudGltZXMoZDEpKTtcclxuICAgICAgbjAucyA9IG4xLnMgPSB4LnM7XHJcbiAgICAgIGUgPSBlICogMjtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBmcmFjdGlvbiBpcyBjbG9zZXIgdG8geCwgbjAvZDAgb3IgbjEvZDFcclxuICAgICAgciA9IGRpdihuMSwgZDEsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpLmNvbXBhcmVkVG8oXHJcbiAgICAgICAgICBkaXYobjAsIGQwLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKSkgPCAxID8gW24xLCBkMV0gOiBbbjAsIGQwXTtcclxuXHJcbiAgICAgIE1BWF9FWFAgPSBleHA7XHJcblxyXG4gICAgICByZXR1cm4gcjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGNvbnZlcnRlZCB0byBhIG51bWJlciBwcmltaXRpdmUuXHJcbiAgICAgKi9cclxuICAgIFAudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiArdmFsdWVPZih0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSBvciBST1VORElOR19NT0RFLiBJZiBzZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHNcclxuICAgICAqIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXIgcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24sIHRoZW4gdXNlXHJcbiAgICAgKiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvUHJlY2lzaW9uID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgICBpZiAoc2QgIT0gbnVsbCkgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgc2QsIHJtLCAyKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBiYXNlIGIsIG9yIGJhc2UgMTAgaWYgYiBpc1xyXG4gICAgICogb21pdHRlZC4gSWYgYSBiYXNlIGlzIHNwZWNpZmllZCwgaW5jbHVkaW5nIGJhc2UgMTAsIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmRcclxuICAgICAqIFJPVU5ESU5HX01PREUuIElmIGEgYmFzZSBpcyBub3Qgc3BlY2lmaWVkLCBhbmQgdGhpcyBCaWdOdW1iZXIgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnRcclxuICAgICAqIHRoYXQgaXMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIFRPX0VYUF9QT1MsIG9yIGEgbmVnYXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuXHJcbiAgICAgKiBUT19FWFBfTkVHLCByZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogW2JdIHtudW1iZXJ9IEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICAgKi9cclxuICAgIFAudG9TdHJpbmcgPSBmdW5jdGlvbiAoYikge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIG4gPSB0aGlzLFxyXG4gICAgICAgIHMgPSBuLnMsXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgIC8vIEluZmluaXR5IG9yIE5hTj9cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHtcclxuICAgICAgICBpZiAocykge1xyXG4gICAgICAgICAgc3RyID0gJ0luZmluaXR5JztcclxuICAgICAgICAgIGlmIChzIDwgMCkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdHIgPSAnTmFOJztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICAgICAgID8gdG9FeHBvbmVudGlhbChjb2VmZlRvU3RyaW5nKG4uYyksIGUpXHJcbiAgICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMTApIHtcclxuICAgICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBERUNJTUFMX1BMQUNFUyArIGUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIG4uZSwgJzAnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG4gICAgICAgICAgc3RyID0gY29udmVydEJhc2UodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKSwgMTAsIGIsIHMsIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHMgPCAwICYmIG4uY1swXSkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc3RyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhcyB0b1N0cmluZywgYnV0IGRvIG5vdCBhY2NlcHQgYSBiYXNlIGFyZ3VtZW50LCBhbmQgaW5jbHVkZSB0aGUgbWludXMgc2lnbiBmb3JcclxuICAgICAqIG5lZ2F0aXZlIHplcm8uXHJcbiAgICAgKi9cclxuICAgIFAudmFsdWVPZiA9IFAudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdmFsdWVPZih0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFAuX2lzQmlnTnVtYmVyID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAoY29uZmlnT2JqZWN0ICE9IG51bGwpIEJpZ051bWJlci5zZXQoY29uZmlnT2JqZWN0KTtcclxuXHJcbiAgICByZXR1cm4gQmlnTnVtYmVyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFBSSVZBVEUgSEVMUEVSIEZVTkNUSU9OU1xyXG5cclxuICAvLyBUaGVzZSBmdW5jdGlvbnMgZG9uJ3QgbmVlZCBhY2Nlc3MgdG8gdmFyaWFibGVzLFxyXG4gIC8vIGUuZy4gREVDSU1BTF9QTEFDRVMsIGluIHRoZSBzY29wZSBvZiB0aGUgYGNsb25lYCBmdW5jdGlvbiBhYm92ZS5cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGJpdEZsb29yKG4pIHtcclxuICAgIHZhciBpID0gbiB8IDA7XHJcbiAgICByZXR1cm4gbiA+IDAgfHwgbiA9PT0gaSA/IGkgOiBpIC0gMTtcclxuICB9XHJcblxyXG5cclxuICAvLyBSZXR1cm4gYSBjb2VmZmljaWVudCBhcnJheSBhcyBhIHN0cmluZyBvZiBiYXNlIDEwIGRpZ2l0cy5cclxuICBmdW5jdGlvbiBjb2VmZlRvU3RyaW5nKGEpIHtcclxuICAgIHZhciBzLCB6LFxyXG4gICAgICBpID0gMSxcclxuICAgICAgaiA9IGEubGVuZ3RoLFxyXG4gICAgICByID0gYVswXSArICcnO1xyXG5cclxuICAgIGZvciAoOyBpIDwgajspIHtcclxuICAgICAgcyA9IGFbaSsrXSArICcnO1xyXG4gICAgICB6ID0gTE9HX0JBU0UgLSBzLmxlbmd0aDtcclxuICAgICAgZm9yICg7IHotLTsgcyA9ICcwJyArIHMpO1xyXG4gICAgICByICs9IHM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChqID0gci5sZW5ndGg7IHIuY2hhckNvZGVBdCgtLWopID09PSA0ODspO1xyXG5cclxuICAgIHJldHVybiByLnNsaWNlKDAsIGogKyAxIHx8IDEpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIENvbXBhcmUgdGhlIHZhbHVlIG9mIEJpZ051bWJlcnMgeCBhbmQgeS5cclxuICBmdW5jdGlvbiBjb21wYXJlKHgsIHkpIHtcclxuICAgIHZhciBhLCBiLFxyXG4gICAgICB4YyA9IHguYyxcclxuICAgICAgeWMgPSB5LmMsXHJcbiAgICAgIGkgPSB4LnMsXHJcbiAgICAgIGogPSB5LnMsXHJcbiAgICAgIGsgPSB4LmUsXHJcbiAgICAgIGwgPSB5LmU7XHJcblxyXG4gICAgLy8gRWl0aGVyIE5hTj9cclxuICAgIGlmICghaSB8fCAhaikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgYSA9IHhjICYmICF4Y1swXTtcclxuICAgIGIgPSB5YyAmJiAheWNbMF07XHJcblxyXG4gICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICBpZiAoYSB8fCBiKSByZXR1cm4gYSA/IGIgPyAwIDogLWogOiBpO1xyXG5cclxuICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgIGlmIChpICE9IGopIHJldHVybiBpO1xyXG5cclxuICAgIGEgPSBpIDwgMDtcclxuICAgIGIgPSBrID09IGw7XHJcblxyXG4gICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBiID8gMCA6ICF4YyBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgICBpZiAoIWIpIHJldHVybiBrID4gbCBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgaiA9IChrID0geGMubGVuZ3RoKSA8IChsID0geWMubGVuZ3RoKSA/IGsgOiBsO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgajsgaSsrKSBpZiAoeGNbaV0gIT0geWNbaV0pIHJldHVybiB4Y1tpXSA+IHljW2ldIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAvLyBDb21wYXJlIGxlbmd0aHMuXHJcbiAgICByZXR1cm4gayA9PSBsID8gMCA6IGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIENoZWNrIHRoYXQgbiBpcyBhIHByaW1pdGl2ZSBudW1iZXIsIGFuIGludGVnZXIsIGFuZCBpbiByYW5nZSwgb3RoZXJ3aXNlIHRocm93LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGludENoZWNrKG4sIG1pbiwgbWF4LCBuYW1lKSB7XHJcbiAgICBpZiAobiA8IG1pbiB8fCBuID4gbWF4IHx8IG4gIT09IG1hdGhmbG9vcihuKSkge1xyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgKGJpZ251bWJlckVycm9yICsgKG5hbWUgfHwgJ0FyZ3VtZW50JykgKyAodHlwZW9mIG4gPT0gJ251bWJlcidcclxuICAgICAgICAgPyBuIDwgbWluIHx8IG4gPiBtYXggPyAnIG91dCBvZiByYW5nZTogJyA6ICcgbm90IGFuIGludGVnZXI6ICdcclxuICAgICAgICAgOiAnIG5vdCBhIHByaW1pdGl2ZSBudW1iZXI6ICcpICsgU3RyaW5nKG4pKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvLyBBc3N1bWVzIGZpbml0ZSBuLlxyXG4gIGZ1bmN0aW9uIGlzT2RkKG4pIHtcclxuICAgIHZhciBrID0gbi5jLmxlbmd0aCAtIDE7XHJcbiAgICByZXR1cm4gYml0Rmxvb3Iobi5lIC8gTE9HX0JBU0UpID09IGsgJiYgbi5jW2tdICUgMiAhPSAwO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHRvRXhwb25lbnRpYWwoc3RyLCBlKSB7XHJcbiAgICByZXR1cm4gKHN0ci5sZW5ndGggPiAxID8gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKSA6IHN0cikgK1xyXG4gICAgIChlIDwgMCA/ICdlJyA6ICdlKycpICsgZTtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCB6KSB7XHJcbiAgICB2YXIgbGVuLCB6cztcclxuXHJcbiAgICAvLyBOZWdhdGl2ZSBleHBvbmVudD9cclxuICAgIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcy5cclxuICAgICAgZm9yICh6cyA9IHogKyAnLic7ICsrZTsgenMgKz0geik7XHJcbiAgICAgIHN0ciA9IHpzICsgc3RyO1xyXG5cclxuICAgIC8vIFBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gQXBwZW5kIHplcm9zLlxyXG4gICAgICBpZiAoKytlID4gbGVuKSB7XHJcbiAgICAgICAgZm9yICh6cyA9IHosIGUgLT0gbGVuOyAtLWU7IHpzICs9IHopO1xyXG4gICAgICAgIHN0ciArPSB6cztcclxuICAgICAgfSBlbHNlIGlmIChlIDwgbGVuKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIGUpICsgJy4nICsgc3RyLnNsaWNlKGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0cjtcclxuICB9XHJcblxyXG5cclxuICAvLyBFWFBPUlRcclxuXHJcblxyXG4gIEJpZ051bWJlciA9IGNsb25lKCk7XHJcbiAgQmlnTnVtYmVyWydkZWZhdWx0J10gPSBCaWdOdW1iZXIuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG5cclxuICAvLyBBTUQuXHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gQmlnTnVtYmVyOyB9KTtcclxuXHJcbiAgLy8gTm9kZS5qcyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cy5cclxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gQmlnTnVtYmVyO1xyXG5cclxuICAvLyBCcm93c2VyLlxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoIWdsb2JhbE9iamVjdCkge1xyXG4gICAgICBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmID8gc2VsZiA6IHdpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICBnbG9iYWxPYmplY3QuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG4gIH1cclxufSkodGhpcyk7XHJcbiIsImNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXIvJykuQnVmZmVyXG4vKipcbiAqIFJMUCBFbmNvZGluZyBiYXNlZCBvbjogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS8lNUJFbmdsaXNoJTVELVJMUFxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBpbiBhIGRhdGEsIGNvbnZlcnQgaXQgdG8gYnVmZmVyIGlmIG5vdCwgYW5kIGEgbGVuZ3RoIGZvciByZWN1cnNpb25cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcixTdHJpbmcsSW50ZWdlcixBcnJheX0gZGF0YSAtIHdpbGwgYmUgY29udmVydGVkIHRvIGJ1ZmZlclxuICogQHJldHVybnMge0J1ZmZlcn0gLSByZXR1cm5zIGJ1ZmZlciBvZiBlbmNvZGVkIGRhdGFcbiAqKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdmFyIG91dHB1dCA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgb3V0cHV0LnB1c2goZXhwb3J0cy5lbmNvZGUoaW5wdXRbaV0pKVxuICAgIH1cbiAgICB2YXIgYnVmID0gQnVmZmVyLmNvbmNhdChvdXRwdXQpXG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2VuY29kZUxlbmd0aChidWYubGVuZ3RoLCAxOTIpLCBidWZdKVxuICB9IGVsc2Uge1xuICAgIGlucHV0ID0gdG9CdWZmZXIoaW5wdXQpXG4gICAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMSAmJiBpbnB1dFswXSA8IDEyOCkge1xuICAgICAgcmV0dXJuIGlucHV0XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtlbmNvZGVMZW5ndGgoaW5wdXQubGVuZ3RoLCAxMjgpLCBpbnB1dF0pXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVQYXJzZUludCAodiwgYmFzZSkge1xuICBpZiAodi5zbGljZSgwLCAyKSA9PT0gJzAwJykge1xuICAgIHRocm93IChuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiBleHRyYSB6ZXJvcycpKVxuICB9XG5cbiAgcmV0dXJuIHBhcnNlSW50KHYsIGJhc2UpXG59XG5cbmZ1bmN0aW9uIGVuY29kZUxlbmd0aCAobGVuLCBvZmZzZXQpIHtcbiAgaWYgKGxlbiA8IDU2KSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoW2xlbiArIG9mZnNldF0pXG4gIH0gZWxzZSB7XG4gICAgdmFyIGhleExlbmd0aCA9IGludFRvSGV4KGxlbilcbiAgICB2YXIgbExlbmd0aCA9IGhleExlbmd0aC5sZW5ndGggLyAyXG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGludFRvSGV4KG9mZnNldCArIDU1ICsgbExlbmd0aClcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihmaXJzdEJ5dGUgKyBoZXhMZW5ndGgsICdoZXgnKVxuICB9XG59XG5cbi8qKlxuICogUkxQIERlY29kaW5nIGJhc2VkIG9uOiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS8lNUJFbmdsaXNoJTVELVJMUHxSTFB9XG4gKiBAcGFyYW0ge0J1ZmZlcixTdHJpbmcsSW50ZWdlcixBcnJheX0gZGF0YSAtIHdpbGwgYmUgY29udmVydGVkIHRvIGJ1ZmZlclxuICogQHJldHVybnMge0FycmF5fSAtIHJldHVybnMgZGVjb2RlIEFycmF5IG9mIEJ1ZmZlcnMgY29udGFpbmcgdGhlIG9yaWdpbmFsIG1lc3NhZ2VcbiAqKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGlucHV0LCBzdHJlYW0pIHtcbiAgaWYgKCFpbnB1dCB8fCBpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihbXSlcbiAgfVxuXG4gIGlucHV0ID0gdG9CdWZmZXIoaW5wdXQpXG4gIHZhciBkZWNvZGVkID0gX2RlY29kZShpbnB1dClcblxuICBpZiAoc3RyZWFtKSB7XG4gICAgcmV0dXJuIGRlY29kZWRcbiAgfVxuXG4gIGFzc2VydC5lcXVhbChkZWNvZGVkLnJlbWFpbmRlci5sZW5ndGgsIDAsICdpbnZhbGlkIHJlbWFpbmRlcicpXG4gIHJldHVybiBkZWNvZGVkLmRhdGFcbn1cblxuZXhwb3J0cy5nZXRMZW5ndGggPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgaWYgKCFpbnB1dCB8fCBpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihbXSlcbiAgfVxuXG4gIGlucHV0ID0gdG9CdWZmZXIoaW5wdXQpXG4gIHZhciBmaXJzdEJ5dGUgPSBpbnB1dFswXVxuICBpZiAoZmlyc3RCeXRlIDw9IDB4N2YpIHtcbiAgICByZXR1cm4gaW5wdXQubGVuZ3RoXG4gIH0gZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4YjcpIHtcbiAgICByZXR1cm4gZmlyc3RCeXRlIC0gMHg3ZlxuICB9IGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGJmKSB7XG4gICAgcmV0dXJuIGZpcnN0Qnl0ZSAtIDB4YjZcbiAgfSBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhmNykge1xuICAgIC8vIGEgbGlzdCBiZXR3ZWVuICAwLTU1IGJ5dGVzIGxvbmdcbiAgICByZXR1cm4gZmlyc3RCeXRlIC0gMHhiZlxuICB9IGVsc2Uge1xuICAgIC8vIGEgbGlzdCAgb3ZlciA1NSBieXRlcyBsb25nXG4gICAgdmFyIGxsZW5ndGggPSBmaXJzdEJ5dGUgLSAweGY2XG4gICAgdmFyIGxlbmd0aCA9IHNhZmVQYXJzZUludChpbnB1dC5zbGljZSgxLCBsbGVuZ3RoKS50b1N0cmluZygnaGV4JyksIDE2KVxuICAgIHJldHVybiBsbGVuZ3RoICsgbGVuZ3RoXG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlY29kZSAoaW5wdXQpIHtcbiAgdmFyIGxlbmd0aCwgbGxlbmd0aCwgZGF0YSwgaW5uZXJSZW1haW5kZXIsIGRcbiAgdmFyIGRlY29kZWQgPSBbXVxuICB2YXIgZmlyc3RCeXRlID0gaW5wdXRbMF1cblxuICBpZiAoZmlyc3RCeXRlIDw9IDB4N2YpIHtcbiAgICAvLyBhIHNpbmdsZSBieXRlIHdob3NlIHZhbHVlIGlzIGluIHRoZSBbMHgwMCwgMHg3Zl0gcmFuZ2UsIHRoYXQgYnl0ZSBpcyBpdHMgb3duIFJMUCBlbmNvZGluZy5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogaW5wdXQuc2xpY2UoMCwgMSksXG4gICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKDEpXG4gICAgfVxuICB9IGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGI3KSB7XG4gICAgLy8gc3RyaW5nIGlzIDAtNTUgYnl0ZXMgbG9uZy4gQSBzaW5nbGUgYnl0ZSB3aXRoIHZhbHVlIDB4ODAgcGx1cyB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgZm9sbG93ZWQgYnkgdGhlIHN0cmluZ1xuICAgIC8vIFRoZSByYW5nZSBvZiB0aGUgZmlyc3QgYnl0ZSBpcyBbMHg4MCwgMHhiN11cbiAgICBsZW5ndGggPSBmaXJzdEJ5dGUgLSAweDdmXG5cbiAgICAvLyBzZXQgMHg4MCBudWxsIHRvIDBcbiAgICBpZiAoZmlyc3RCeXRlID09PSAweDgwKSB7XG4gICAgICBkYXRhID0gbmV3IEJ1ZmZlcihbXSlcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IGlucHV0LnNsaWNlKDEsIGxlbmd0aClcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoID09PSAyICYmIGRhdGFbMF0gPCAweDgwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmxwIGVuY29kaW5nOiBieXRlIG11c3QgYmUgbGVzcyAweDgwJylcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UobGVuZ3RoKVxuICAgIH1cbiAgfSBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhiZikge1xuICAgIGxsZW5ndGggPSBmaXJzdEJ5dGUgLSAweGI2XG4gICAgbGVuZ3RoID0gc2FmZVBhcnNlSW50KGlucHV0LnNsaWNlKDEsIGxsZW5ndGgpLnRvU3RyaW5nKCdoZXgnKSwgMTYpXG4gICAgZGF0YSA9IGlucHV0LnNsaWNlKGxsZW5ndGgsIGxlbmd0aCArIGxsZW5ndGgpXG4gICAgaWYgKGRhdGEubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICB0aHJvdyAobmV3IEVycm9yKCdpbnZhbGlkIFJMUCcpKVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZShsZW5ndGggKyBsbGVuZ3RoKVxuICAgIH1cbiAgfSBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhmNykge1xuICAgIC8vIGEgbGlzdCBiZXR3ZWVuICAwLTU1IGJ5dGVzIGxvbmdcbiAgICBsZW5ndGggPSBmaXJzdEJ5dGUgLSAweGJmXG4gICAgaW5uZXJSZW1haW5kZXIgPSBpbnB1dC5zbGljZSgxLCBsZW5ndGgpXG4gICAgd2hpbGUgKGlubmVyUmVtYWluZGVyLmxlbmd0aCkge1xuICAgICAgZCA9IF9kZWNvZGUoaW5uZXJSZW1haW5kZXIpXG4gICAgICBkZWNvZGVkLnB1c2goZC5kYXRhKVxuICAgICAgaW5uZXJSZW1haW5kZXIgPSBkLnJlbWFpbmRlclxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBkZWNvZGVkLFxuICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZShsZW5ndGgpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGEgbGlzdCAgb3ZlciA1NSBieXRlcyBsb25nXG4gICAgbGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4ZjZcbiAgICBsZW5ndGggPSBzYWZlUGFyc2VJbnQoaW5wdXQuc2xpY2UoMSwgbGxlbmd0aCkudG9TdHJpbmcoJ2hleCcpLCAxNilcbiAgICB2YXIgdG90YWxMZW5ndGggPSBsbGVuZ3RoICsgbGVuZ3RoXG4gICAgaWYgKHRvdGFsTGVuZ3RoID4gaW5wdXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmxwOiB0b3RhbCBsZW5ndGggaXMgbGFyZ2VyIHRoYW4gdGhlIGRhdGEnKVxuICAgIH1cblxuICAgIGlubmVyUmVtYWluZGVyID0gaW5wdXQuc2xpY2UobGxlbmd0aCwgdG90YWxMZW5ndGgpXG4gICAgaWYgKGlubmVyUmVtYWluZGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJscCwgTGlzdCBoYXMgYSBpbnZhbGlkIGxlbmd0aCcpXG4gICAgfVxuXG4gICAgd2hpbGUgKGlubmVyUmVtYWluZGVyLmxlbmd0aCkge1xuICAgICAgZCA9IF9kZWNvZGUoaW5uZXJSZW1haW5kZXIpXG4gICAgICBkZWNvZGVkLnB1c2goZC5kYXRhKVxuICAgICAgaW5uZXJSZW1haW5kZXIgPSBkLnJlbWFpbmRlclxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogZGVjb2RlZCxcbiAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UodG90YWxMZW5ndGgpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzSGV4UHJlZml4ZWQgKHN0cikge1xuICByZXR1cm4gc3RyLnNsaWNlKDAsIDIpID09PSAnMHgnXG59XG5cbi8vIFJlbW92ZXMgMHggZnJvbSBhIGdpdmVuIFN0cmluZ1xuZnVuY3Rpb24gc3RyaXBIZXhQcmVmaXggKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RyXG4gIH1cbiAgcmV0dXJuIGlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ci5zbGljZSgyKSA6IHN0clxufVxuXG5mdW5jdGlvbiBpbnRUb0hleCAoaSkge1xuICB2YXIgaGV4ID0gaS50b1N0cmluZygxNilcbiAgaWYgKGhleC5sZW5ndGggJSAyKSB7XG4gICAgaGV4ID0gJzAnICsgaGV4XG4gIH1cblxuICByZXR1cm4gaGV4XG59XG5cbmZ1bmN0aW9uIHBhZFRvRXZlbiAoYSkge1xuICBpZiAoYS5sZW5ndGggJSAyKSBhID0gJzAnICsgYVxuICByZXR1cm4gYVxufVxuXG5mdW5jdGlvbiBpbnRUb0J1ZmZlciAoaSkge1xuICB2YXIgaGV4ID0gaW50VG9IZXgoaSlcbiAgcmV0dXJuIG5ldyBCdWZmZXIoaGV4LCAnaGV4Jylcbn1cblxuZnVuY3Rpb24gdG9CdWZmZXIgKHYpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodikpIHtcbiAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoaXNIZXhQcmVmaXhlZCh2KSkge1xuICAgICAgICB2ID0gbmV3IEJ1ZmZlcihwYWRUb0V2ZW4oc3RyaXBIZXhQcmVmaXgodikpLCAnaGV4JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYgPSBuZXcgQnVmZmVyKHYpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmICghdikge1xuICAgICAgICB2ID0gbmV3IEJ1ZmZlcihbXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYgPSBpbnRUb0J1ZmZlcih2KVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHYgPSBuZXcgQnVmZmVyKFtdKVxuICAgIH0gZWxzZSBpZiAodi50b0FycmF5KSB7XG4gICAgICAvLyBjb252ZXJ0cyBhIEJOIHRvIGEgQnVmZmVyXG4gICAgICB2ID0gbmV3IEJ1ZmZlcih2LnRvQXJyYXkoKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUnKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdlxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZXRoZXJzID0gcmVxdWlyZSgnZXRoZXJzJyk7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xuXG52YXIgVHlwZWREYXRhVXRpbHMgPSB7XHJcbiAgICBlbmNvZGVEaWdlc3Q6IGZ1bmN0aW9uICh0eXBlZERhdGEpIHtcclxuICAgICAgICB2YXIgZWlwMTkxSGVhZGVyID0gZXRoZXJzLmV0aGVycy51dGlscy5hcnJheWlmeSgnMHgxOTAxJyk7XHJcbiAgICAgICAgdmFyIGRvbWFpbkhhc2ggPSBUeXBlZERhdGFVdGlscy5oYXNoU3RydWN0KHR5cGVkRGF0YSwgJ0VJUDcxMkRvbWFpbicsIHR5cGVkRGF0YS5kb21haW4pO1xyXG4gICAgICAgIHZhciBtZXNzYWdlSGFzaCA9IFR5cGVkRGF0YVV0aWxzLmhhc2hTdHJ1Y3QodHlwZWREYXRhLCB0eXBlZERhdGEucHJpbWFyeVR5cGUsIHR5cGVkRGF0YS5tZXNzYWdlKTtcclxuICAgICAgICB2YXIgcGFjayA9IGV0aGVycy5ldGhlcnMudXRpbHMuc29saWRpdHlQYWNrKFsnYnl0ZXMnLCAnYnl0ZXMzMicsICdieXRlczMyJ10sIFtlaXAxOTFIZWFkZXIsIHplcm9QYWQoZG9tYWluSGFzaCwgMzIpLCB6ZXJvUGFkKG1lc3NhZ2VIYXNoLCAzMildKTtcclxuICAgICAgICB2YXIgaGFzaFBhY2sgPSBldGhlcnMuZXRoZXJzLnV0aWxzLmtlY2NhazI1NihwYWNrKTtcclxuICAgICAgICByZXR1cm4gZXRoZXJzLmV0aGVycy51dGlscy5hcnJheWlmeShoYXNoUGFjayk7XHJcbiAgICB9LFxyXG4gICAgZW5jb2RlRGF0YTogZnVuY3Rpb24gKHR5cGVkRGF0YSwgcHJpbWFyeVR5cGUsIGRhdGEpIHtcclxuICAgICAgICB2YXIgdHlwZXMgPSB0eXBlZERhdGEudHlwZXM7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSB0eXBlc1twcmltYXJ5VHlwZV07XHJcbiAgICAgICAgaWYgKCFhcmdzIHx8IGFyZ3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGVkRGF0YVV0aWxzOiBcIiArIHR5cGVkRGF0YS5wcmltYXJ5VHlwZSArIFwiIHR5cGUgaXMgbm90IHVua25vd25cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhYmlDb2RlciA9IG5ldyBldGhlcnMuZXRoZXJzLnV0aWxzLkFiaUNvZGVyKCk7XHJcbiAgICAgICAgdmFyIGFiaVR5cGVzID0gW107XHJcbiAgICAgICAgdmFyIGFiaVZhbHVlcyA9IFtdO1xyXG4gICAgICAgIHZhciB0eXBlSGFzaCA9IFR5cGVkRGF0YVV0aWxzLnR5cGVIYXNoKHR5cGVkRGF0YS50eXBlcywgcHJpbWFyeVR5cGUpO1xyXG4gICAgICAgIGFiaVR5cGVzLnB1c2goJ2J5dGVzMzInKTtcclxuICAgICAgICBhYmlWYWx1ZXMucHVzaCh6ZXJvUGFkKHR5cGVIYXNoLCAzMikpO1xyXG4gICAgICAgIHZhciBlbmNvZGVGaWVsZCA9IGZ1bmN0aW9uIChuYW1lLCB0eXBlLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZXNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsIGV0aGVycy5ldGhlcnMudXRpbHMuYXJyYXlpZnkoZXRoZXJzLmV0aGVycy51dGlscy5rZWNjYWsyNTYoVHlwZWREYXRhVXRpbHMuZW5jb2RlRGF0YSh0eXBlZERhdGEsIHR5cGUsIHZhbHVlKSkpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2J5dGVzJyB8fCB0eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICB2ID0gZXRoZXJzLmV0aGVycy51dGlscy50b1V0ZjhCeXRlcyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2ID0gZXRoZXJzLmV0aGVycy51dGlscy5hcnJheWlmeSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWydieXRlczMyJywgZXRoZXJzLmV0aGVycy51dGlscy5hcnJheWlmeShldGhlcnMuZXRoZXJzLnV0aWxzLmhleFplcm9QYWQoZXRoZXJzLmV0aGVycy51dGlscy5rZWNjYWsyNTYodiksIDMyKSldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUubGFzdEluZGV4T2YoJ1snKSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciB0XzEgPSB0eXBlLnNsaWNlKDAsIHR5cGUubGFzdEluZGV4T2YoJ1snKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHZhbHVlLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gZW5jb2RlRmllbGQobmFtZSwgdF8xLCBpdGVtKTsgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWydieXRlczMyJywgZXRoZXJzLmV0aGVycy51dGlscy5hcnJheWlmeShldGhlcnMuZXRoZXJzLnV0aWxzLmtlY2NhazI1NihldGhlcnMuZXRoZXJzLnV0aWxzLmFycmF5aWZ5KGFiaUNvZGVyLmVuY29kZSh2Lm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR0ID0gX2FbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0dDtcclxuICAgICAgICAgICAgICAgICAgICB9KSwgdi5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2diA9IF9hWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdnY7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpKSkpXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0eXBlLCB2YWx1ZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgYXJnc18xID0gYXJnczsgX2kgPCBhcmdzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IGFyZ3NfMVtfaV07XHJcbiAgICAgICAgICAgIHZhciBfYSA9IGVuY29kZUZpZWxkKGZpZWxkLm5hbWUsIGZpZWxkLnR5cGUsIGRhdGFbZmllbGQubmFtZV0pLCB0eXBlID0gX2FbMF0sIHZhbHVlID0gX2FbMV07XHJcbiAgICAgICAgICAgIGFiaVR5cGVzLnB1c2godHlwZSk7XHJcbiAgICAgICAgICAgIGFiaVZhbHVlcy5wdXNoKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV0aGVycy5ldGhlcnMudXRpbHMuYXJyYXlpZnkoYWJpQ29kZXIuZW5jb2RlKGFiaVR5cGVzLCBhYmlWYWx1ZXMpKTtcclxuICAgIH0sXHJcbiAgICBoYXNoU3RydWN0OiBmdW5jdGlvbiAodHlwZWREYXRhLCBwcmltYXJ5VHlwZSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBldGhlcnMuZXRoZXJzLnV0aWxzLmFycmF5aWZ5KGV0aGVycy5ldGhlcnMudXRpbHMua2VjY2FrMjU2KFR5cGVkRGF0YVV0aWxzLmVuY29kZURhdGEodHlwZWREYXRhLCBwcmltYXJ5VHlwZSwgZGF0YSkpKTtcclxuICAgIH0sXHJcbiAgICB0eXBlSGFzaDogZnVuY3Rpb24gKHR5cGVkRGF0YVR5cGVzLCBwcmltYXJ5VHlwZSkge1xyXG4gICAgICAgIHJldHVybiBldGhlcnMuZXRoZXJzLnV0aWxzLmFycmF5aWZ5KGV0aGVycy5ldGhlcnMudXRpbHMua2VjY2FrMjU2KGV0aGVycy5ldGhlcnMudXRpbHMudG9VdGY4Qnl0ZXMoVHlwZWREYXRhVXRpbHMuZW5jb2RlVHlwZSh0eXBlZERhdGFUeXBlcywgcHJpbWFyeVR5cGUpKSkpO1xyXG4gICAgfSxcclxuICAgIGVuY29kZVR5cGU6IGZ1bmN0aW9uICh0eXBlZERhdGFUeXBlcywgcHJpbWFyeVR5cGUpIHtcclxuICAgICAgICB2YXIgYXJncyA9IHR5cGVkRGF0YVR5cGVzW3ByaW1hcnlUeXBlXTtcclxuICAgICAgICBpZiAoIWFyZ3MgfHwgYXJncy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHlwZWREYXRhVXRpbHM6IFwiICsgcHJpbWFyeVR5cGUgKyBcIiB0eXBlIGlzIG5vdCBkZWZpbmVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3ViVHlwZXMgPSBbXTtcclxuICAgICAgICB2YXIgcyA9IHByaW1hcnlUeXBlICsgJygnO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYXJnID0gYXJnc1tpXTtcclxuICAgICAgICAgICAgdmFyIGFycmF5QXJnID0gYXJnLnR5cGUuaW5kZXhPZignWycpO1xyXG4gICAgICAgICAgICB2YXIgYXJnVHlwZSA9IGFycmF5QXJnIDwgMCA/IGFyZy50eXBlIDogYXJnLnR5cGUuc2xpY2UoMCwgYXJyYXlBcmcpO1xyXG4gICAgICAgICAgICBpZiAodHlwZWREYXRhVHlwZXNbYXJnVHlwZV0gJiYgdHlwZWREYXRhVHlwZXNbYXJnVHlwZV0ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNldCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBzdWJUeXBlcy5sZW5ndGg7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJUeXBlc1t4XSA9PT0gYXJnVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViVHlwZXMucHVzaChhcmdUeXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzICs9IGFyZy50eXBlICsgJyAnICsgYXJnLm5hbWU7XHJcbiAgICAgICAgICAgIGlmIChpIDwgYXJncy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICBzICs9ICcsJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzICs9ICcpJztcclxuICAgICAgICBzdWJUeXBlcy5zb3J0KCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJUeXBlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc3ViRW5jb2RlVHlwZSA9IFR5cGVkRGF0YVV0aWxzLmVuY29kZVR5cGUodHlwZWREYXRhVHlwZXMsIHN1YlR5cGVzW2ldKTtcclxuICAgICAgICAgICAgcyArPSBzdWJFbmNvZGVUeXBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH0sXHJcbiAgICBkb21haW5UeXBlOiBmdW5jdGlvbiAoZG9tYWluKSB7XHJcbiAgICAgICAgdmFyIHR5cGUgPSBbXTtcclxuICAgICAgICBpZiAoZG9tYWluLm5hbWUpIHtcclxuICAgICAgICAgICAgdHlwZS5wdXNoKHsgbmFtZTogJ25hbWUnLCB0eXBlOiAnc3RyaW5nJyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRvbWFpbi52ZXJzaW9uKSB7XHJcbiAgICAgICAgICAgIHR5cGUucHVzaCh7IG5hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ3N0cmluZycgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkb21haW4uY2hhaW5JZCkge1xyXG4gICAgICAgICAgICB0eXBlLnB1c2goeyBuYW1lOiAnY2hhaW5JZCcsIHR5cGU6ICd1aW50MjU2JyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCkge1xyXG4gICAgICAgICAgICB0eXBlLnB1c2goeyBuYW1lOiAndmVyaWZ5aW5nQ29udHJhY3QnLCB0eXBlOiAnYWRkcmVzcycgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkb21haW4uc2FsdCkge1xyXG4gICAgICAgICAgICB0eXBlLnB1c2goeyBuYW1lOiAnc2FsdCcsIHR5cGU6ICdieXRlczMyJyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHR5cGU7XHJcbiAgICB9LFxyXG4gICAgYnVpbGRUeXBlZERhdGE6IGZ1bmN0aW9uIChkb21haW4sIG1lc3NhZ2VUeXBlcywgcHJpbWFyeVR5cGUsIG1lc3NhZ2UpIHtcclxuICAgICAgICB2YXIgZG9tYWluVHlwZSA9IFR5cGVkRGF0YVV0aWxzLmRvbWFpblR5cGUoZG9tYWluKTtcclxuICAgICAgICB2YXIgdHlwZWREYXRhID0ge1xyXG4gICAgICAgICAgICBkb21haW46IGRvbWFpbixcclxuICAgICAgICAgICAgdHlwZXM6IF9fYXNzaWduKHsgJ0VJUDcxMkRvbWFpbic6IGRvbWFpblR5cGUgfSwgbWVzc2FnZVR5cGVzKSxcclxuICAgICAgICAgICAgcHJpbWFyeVR5cGU6IHByaW1hcnlUeXBlLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdHlwZWREYXRhO1xyXG4gICAgfVxyXG59O1xyXG52YXIgZW5jb2RlVHlwZWREYXRhRGlnZXN0ID0gZnVuY3Rpb24gKHR5cGVkRGF0YSkge1xyXG4gICAgcmV0dXJuIFR5cGVkRGF0YVV0aWxzLmVuY29kZURpZ2VzdCh0eXBlZERhdGEpO1xyXG59O1xyXG52YXIgYnVpbGRUeXBlZERhdGEgPSBmdW5jdGlvbiAoZG9tYWluLCBtZXNzYWdlVHlwZXMsIHByaW1hcnlUeXBlLCBtZXNzYWdlKSB7XHJcbiAgICByZXR1cm4gVHlwZWREYXRhVXRpbHMuYnVpbGRUeXBlZERhdGEoZG9tYWluLCBtZXNzYWdlVHlwZXMsIHByaW1hcnlUeXBlLCBtZXNzYWdlKTtcclxufTtcclxudmFyIGRvbWFpblR5cGUgPSBmdW5jdGlvbiAoZG9tYWluKSB7XHJcbiAgICByZXR1cm4gVHlwZWREYXRhVXRpbHMuZG9tYWluVHlwZShkb21haW4pO1xyXG59O1xyXG4vLyB6ZXJvUGFkIGlzIGltcGxlbWVudGVkIGFzIGEgY29tcGF0IGxheWVyIGJldHdlZW4gZXRoZXJzIHY0IGFuZCBldGhlcnMgdjVcclxudmFyIHplcm9QYWQgPSBmdW5jdGlvbiAodmFsdWUsIGxlbmd0aCkge1xyXG4gICAgcmV0dXJuIGV0aGVycy5ldGhlcnMudXRpbHMuYXJyYXlpZnkoZXRoZXJzLmV0aGVycy51dGlscy5oZXhaZXJvUGFkKGV0aGVycy5ldGhlcnMudXRpbHMuaGV4bGlmeSh2YWx1ZSksIGxlbmd0aCkpO1xyXG59O1xuXG5leHBvcnRzLlR5cGVkRGF0YVV0aWxzID0gVHlwZWREYXRhVXRpbHM7XG5leHBvcnRzLmJ1aWxkVHlwZWREYXRhID0gYnVpbGRUeXBlZERhdGE7XG5leHBvcnRzLmRvbWFpblR5cGUgPSBkb21haW5UeXBlO1xuZXhwb3J0cy5lbmNvZGVUeXBlZERhdGFEaWdlc3QgPSBlbmNvZGVUeXBlZERhdGFEaWdlc3Q7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJykocmVxdWlyZSgnLi9saWIvZWxsaXB0aWMnKSlcbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBleHBvcnRzLkNvbW1lbnRlZCA9IHJlcXVpcmUoJy4vY29tbWVudGVkJylcbmV4cG9ydHMuRGlhZ25vc2UgPSByZXF1aXJlKCcuL2RpYWdub3NlJylcbmV4cG9ydHMuRGVjb2RlciA9IHJlcXVpcmUoJy4vZGVjb2RlcicpXG5leHBvcnRzLkVuY29kZXIgPSByZXF1aXJlKCcuL2VuY29kZXInKVxuZXhwb3J0cy5TaW1wbGUgPSByZXF1aXJlKCcuL3NpbXBsZScpXG5leHBvcnRzLlRhZ2dlZCA9IHJlcXVpcmUoJy4vdGFnZ2VkJylcblxuLy8gZXhwb3J0cy5jb21tZW50ID0gZXhwb3J0cy5Db21tZW50ZWQuY29tbWVudFxuZXhwb3J0cy5kZWNvZGVBbGwgPSBleHBvcnRzLkRlY29kZXIuZGVjb2RlQWxsXG5leHBvcnRzLmRlY29kZUZpcnN0ID0gZXhwb3J0cy5EZWNvZGVyLmRlY29kZUZpcnN0XG5leHBvcnRzLmRpYWdub3NlID0gZXhwb3J0cy5EaWFnbm9zZS5kaWFnbm9zZVxuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLkVuY29kZXIuZW5jb2RlXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMuRGVjb2Rlci5kZWNvZGVcblxuZXhwb3J0cy5sZXZlbGRiID0ge1xuICBkZWNvZGU6IGV4cG9ydHMuRGVjb2Rlci5kZWNvZGVBbGwsXG4gIGVuY29kZTogZXhwb3J0cy5FbmNvZGVyLmVuY29kZSxcbiAgYnVmZmVyOiB0cnVlLFxuICBuYW1lOiAnY2Jvcidcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlQ29udHJvbGxlciA9IHZvaWQgMDtcbi8qKlxuICogQ29udHJvbGxlciBjbGFzcyB0aGF0IHByb3ZpZGVzIGNvbmZpZ3VyYXRpb24sIHN0YXRlIG1hbmFnZW1lbnQsIGFuZCBzdWJzY3JpcHRpb25zXG4gKi9cbmNsYXNzIEJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgQmFzZUNvbnRyb2xsZXIgaW5zdGFuY2UuIEJvdGggaW5pdGlhbCBzdGF0ZSBhbmQgaW5pdGlhbFxuICAgICAqIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBhcmUgbWVyZ2VkIHdpdGggZGVmYXVsdHMgdXBvbiBpbml0aWFsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30sIHN0YXRlID0ge30pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBzdGF0ZSBzZXQgb24gdGhpcyBjb250cm9sbGVyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiBsaXN0ZW5lcnMgYXJlIG5vdGlmaWVkIG9mIHN0YXRlIGNoYW5nZXNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnQmFzZUNvbnRyb2xsZXInO1xuICAgICAgICB0aGlzLmludGVybmFsQ29uZmlnID0gdGhpcy5kZWZhdWx0Q29uZmlnO1xuICAgICAgICB0aGlzLmludGVybmFsU3RhdGUgPSB0aGlzLmRlZmF1bHRTdGF0ZTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbExpc3RlbmVycyA9IFtdO1xuICAgICAgICAvLyBVc2UgYXNzaWduIHNpbmNlIGdlbmVyaWNzIGNhbid0IGJlIHNwcmVhZDogaHR0cHM6Ly9naXQuaW8vdnBSaFlcbiAgICAgICAgdGhpcy5pbml0aWFsU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5pbml0aWFsQ29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSBjb250cm9sbGVyLiBUaGlzIHNldHMgZWFjaCBjb25maWcgb3B0aW9uIGFzIGEgbWVtYmVyXG4gICAgICogdmFyaWFibGUgb24gdGhpcyBpbnN0YW5jZSBhbmQgdHJpZ2dlcnMgYW55IGRlZmluZWQgc2V0dGVycy4gVGhpc1xuICAgICAqIGFsc28gc2V0cyBpbml0aWFsIHN0YXRlIGFuZCB0cmlnZ2VycyBhbnkgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBUaGlzIGNvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLmludGVybmFsU3RhdGUgPSB0aGlzLmRlZmF1bHRTdGF0ZTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbENvbmZpZyA9IHRoaXMuZGVmYXVsdENvbmZpZztcbiAgICAgICAgdGhpcy5jb25maWd1cmUodGhpcy5pbml0aWFsQ29uZmlnKTtcbiAgICAgICAgdGhpcy51cGRhdGUodGhpcy5pbml0aWFsU3RhdGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGN1cnJlbnQgY29udHJvbGxlciBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gQ3VycmVudCBjb25maWd1cmF0aW9uXG4gICAgICovXG4gICAgZ2V0IGNvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxDb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBjdXJyZW50IGNvbnRyb2xsZXIgc3RhdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gQ3VycmVudCBzdGF0ZVxuICAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjb250cm9sbGVyIGNvbmZpZ3VyYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBOZXcgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAgICogQHBhcmFtIG92ZXJ3cml0ZSAtIE92ZXJ3cml0ZSBjb25maWcgaW5zdGVhZCBvZiBtZXJnaW5nXG4gICAgICogQHBhcmFtIGZ1bGxVcGRhdGUgLSBCb29sZWFuIHRoYXQgZGVmaW5lcyBpZiB0aGUgdXBkYXRlIGlzIHBhcnRpYWwgb3Igbm90XG4gICAgICovXG4gICAgY29uZmlndXJlKGNvbmZpZywgb3ZlcndyaXRlID0gZmFsc2UsIGZ1bGxVcGRhdGUgPSB0cnVlKSB7XG4gICAgICAgIGlmIChmdWxsVXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsQ29uZmlnID0gb3ZlcndyaXRlXG4gICAgICAgICAgICAgICAgPyBjb25maWdcbiAgICAgICAgICAgICAgICA6IE9iamVjdC5hc3NpZ24odGhpcy5pbnRlcm5hbENvbmZpZywgY29uZmlnKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuaW50ZXJuYWxDb25maWcpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuaW50ZXJuYWxDb25maWdba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gdGhpcy5pbnRlcm5hbENvbmZpZ1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmludGVybmFsQ29uZmlnW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxDb25maWdba2V5XSA9IGNvbmZpZ1trZXldO1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBjb25maWdba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgYWxsIHN1YnNjcmliZWQgbGlzdGVuZXJzIG9mIGN1cnJlbnQgc3RhdGVcbiAgICAgKi9cbiAgICBub3RpZnkoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnRlcm5hbExpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXIodGhpcy5pbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgbmV3IGxpc3RlbmVyIHRvIGJlIG5vdGlmaWVkIG9mIHN0YXRlIGNoYW5nZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIENhbGxiYWNrIHRyaWdnZXJlZCB3aGVuIHN0YXRlIGNoYW5nZXNcbiAgICAgKi9cbiAgICBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBleGlzdGluZyBsaXN0ZW5lciBmcm9tIHJlY2VpdmluZyBzdGF0ZSBjaGFuZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBDYWxsYmFjayB0byByZW1vdmVcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgYSBsaXN0ZW5lciBpcyBmb3VuZCBhbmQgdW5zdWJzY3JpYmVkXG4gICAgICovXG4gICAgdW5zdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmludGVybmFsTGlzdGVuZXJzLmZpbmRJbmRleCgoY2IpID0+IGxpc3RlbmVyID09PSBjYik7XG4gICAgICAgIGluZGV4ID4gLTEgJiYgdGhpcy5pbnRlcm5hbExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICByZXR1cm4gaW5kZXggPiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjb250cm9sbGVyIHN0YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBOZXcgc3RhdGVcbiAgICAgKiBAcGFyYW0gb3ZlcndyaXRlIC0gT3ZlcndyaXRlIHN0YXRlIGluc3RlYWQgb2YgbWVyZ2luZ1xuICAgICAqL1xuICAgIHVwZGF0ZShzdGF0ZSwgb3ZlcndyaXRlID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFN0YXRlID0gb3ZlcndyaXRlXG4gICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKVxuICAgICAgICAgICAgOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmludGVybmFsU3RhdGUsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoKTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VDb250cm9sbGVyID0gQmFzZUNvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2VDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db250cm9sbGVyTWVzc2VuZ2VyID0gZXhwb3J0cy5SZXN0cmljdGVkQ29udHJvbGxlck1lc3NlbmdlciA9IHZvaWQgMDtcbi8qKlxuICogQSByZXN0cmljdGVkIGNvbnRyb2xsZXIgbWVzc2VuZ2VyLlxuICpcbiAqIFRoaXMgYWN0cyBhcyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBjb250cm9sbGVyIG1lc3NlbmdlciBpbnN0YW5jZSB0aGF0IHJlc3RyaWN0cyBhY2Nlc3MgdG8gYWN0aW9uc1xuICogYW5kIGV2ZW50cy5cbiAqXG4gKiBAdGVtcGxhdGUgTiAtIFRoZSBuYW1lc3BhY2UgZm9yIHRoaXMgbWVzc2VuZ2VyLiBUeXBpY2FsbHkgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgY29udHJvbGxlciBvclxuICogICBtb2R1bGUgdGhhdCB0aGlzIG1lc3NlbmdlciBoYXMgYmVlbiBjcmVhdGVkIGZvci4gVGhlIGF1dGhvcml0eSB0byBwdWJsaXNoIGV2ZW50cyBhbmQgcmVnaXN0ZXJcbiAqICAgYWN0aW9ucyB1bmRlciB0aGlzIG5hbWVzcGFjZSBpcyBncmFudGVkIHRvIHRoaXMgcmVzdHJpY3RlZCBtZXNzZW5nZXIgaW5zdGFuY2UuXG4gKiBAdGVtcGxhdGUgQWN0aW9uIC0gQSB0eXBlIHVuaW9uIG9mIGFsbCBBY3Rpb24gdHlwZXMuXG4gKiBAdGVtcGxhdGUgRXZlbnQgLSBBIHR5cGUgdW5pb24gb2YgYWxsIEV2ZW50IHR5cGVzLlxuICogQHRlbXBsYXRlIEFsbG93ZWRBY3Rpb24gLSBBIHR5cGUgdW5pb24gb2YgdGhlICd0eXBlJyBzdHJpbmcgZm9yIGFueSBhbGxvd2VkIGFjdGlvbnMuXG4gKiBAdGVtcGxhdGUgQWxsb3dlZEV2ZW50IC0gQSB0eXBlIHVuaW9uIG9mIHRoZSAndHlwZScgc3RyaW5nIGZvciBhbnkgYWxsb3dlZCBldmVudHMuXG4gKi9cbmNsYXNzIFJlc3RyaWN0ZWRDb250cm9sbGVyTWVzc2VuZ2VyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgcmVzdHJpY3RlZCBjb250cm9sbGVyIG1lc3NlbmdlclxuICAgICAqXG4gICAgICogVGhlIHByb3ZpZGVkIGFsbG93bGlzdHMgZ3JhbnQgdGhlIGFiaWxpdHkgdG8gY2FsbCB0aGUgbGlzdGVkIGFjdGlvbnMgYW5kIHN1YnNjcmliZSB0byB0aGVcbiAgICAgKiBsaXN0ZWQgZXZlbnRzLiBUaGUgXCJuYW1lXCIgcHJvdmlkZWQgZ3JhbnRzIG93bmVyc2hpcCBvZiBhbnkgYWN0aW9ucyBhbmQgZXZlbnRzIHVuZGVyIHRoYXRcbiAgICAgKiBuYW1lc3BhY2UuIE93bmVyc2hpcCBhbGxvd3MgcmVnaXN0ZXJpbmcgYWN0aW9ucyBhbmQgcHVibGlzaGluZyBldmVudHMsIGFzIHdlbGwgYXNcbiAgICAgKiB1bnJlZ2lzdGVyaW5nIGFjdGlvbnMgYW5kIGNsZWFyaW5nIGV2ZW50IHN1YnNjcmlwdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvbnRyb2xsZXJNZXNzZW5nZXIgLSBUaGUgY29udHJvbGxlciBtZXNzZW5nZXIgaW5zdGFuY2UgdGhhdCBpcyBiZWluZyB3cmFwcGVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdGhpbmcgdGhpcyBtZXNzZW5nZXIgd2lsbCBiZSBoYW5kZWQgdG8gKGUuZy4gdGhlXG4gICAgICogICBjb250cm9sbGVyIG5hbWUpLiBUaGlzIGdyYW50cyBcIm93bmVyc2hpcFwiIG9mIGFjdGlvbnMgYW5kIGV2ZW50cyB1bmRlciB0aGlzIG5hbWVzcGFjZSB0byB0aGVcbiAgICAgKiAgIHJlc3RyaWN0ZWQgY29udHJvbGxlciBtZXNzZW5nZXIgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWxsb3dlZEFjdGlvbnMgLSBUaGUgbGlzdCBvZiBhY3Rpb25zIHRoYXQgdGhpcyByZXN0cmljdGVkIGNvbnRyb2xsZXIgbWVzc2VuZ2VyXG4gICAgICogICBzaG91bGQgYmUgYWxvd2VkIHRvIGNhbGwuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWxsb3dlZEV2ZW50cyAtIFRoZSBsaXN0IG9mIGV2ZW50cyB0aGF0IHRoaXMgcmVzdHJpY3RlZCBjb250cm9sbGVyIG1lc3NlbmdlclxuICAgICAqICAgc2hvdWxkIGJlIGFsbG93ZWQgdG8gc3Vic2NyaWJlIHRvLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgY29udHJvbGxlck1lc3NlbmdlciwgbmFtZSwgYWxsb3dlZEFjdGlvbnMsIGFsbG93ZWRFdmVudHMsIH0pIHtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyID0gY29udHJvbGxlck1lc3NlbmdlcjtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyTmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYWxsb3dlZEFjdGlvbnMgPSBhbGxvd2VkQWN0aW9ucyB8fCBudWxsO1xuICAgICAgICB0aGlzLmFsbG93ZWRFdmVudHMgPSBhbGxvd2VkRXZlbnRzIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGFuIGFjdGlvbiBoYW5kbGVyLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIG1ha2UgdGhlIHJlZ2lzdGVyZWQgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGNhbGwgdmlhIHRoZSBgY2FsbGAgbWV0aG9kLlxuICAgICAqXG4gICAgICogVGhlIGFjdGlvbiB0eXBlIHRoaXMgaGFuZGxlciBpcyByZWdpc3RlcmVkIHVuZGVyICptdXN0KiBiZSBpbiB0aGUgY3VycmVudCBuYW1lc3BhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWN0aW9uVHlwZSAtIFRoZSBhY3Rpb24gdHlwZS4gVGhpcyBpcyBhIHVucWl1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0gaGFuZGxlci0gVGhlIGFjdGlvbiBoYW5kbGVyLiBUaGlzIGZ1bmN0aW9uIGdldHMgY2FsbGVkIHdoZW4gdGhlIGBjYWxsYCBtZXRob2QgaXNcbiAgICAgKiAgIGludm9rZWQgd2l0aCB0aGUgZ2l2ZW4gYWN0aW9uIHR5cGUuXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IHdoZW4gYSBoYW5kbGVyIGhhcyBiZWVuIHJlZ2lzdGVyZWQgZm9yIHRoaXMgYWN0aW9uIHR5cGUgYWxyZWFkeS5cbiAgICAgKiBAdGVtcGxhdGUgVCAtIEEgdHlwZSB1bmlvbiBvZiBBY3Rpb24gdHlwZSBzdHJpbmdzIHRoYXQgYXJlIG5hbWVzcGFjZWQgYnkgTi5cbiAgICAgKi9cbiAgICByZWdpc3RlckFjdGlvbkhhbmRsZXIoYWN0aW9uLCBoYW5kbGVyKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyBCcmFuY2ggdW5yZWFjaGFibGUgd2l0aCB2YWxpZCB0eXBlc1xuICAgICAgICBpZiAoIWFjdGlvbi5zdGFydHNXaXRoKGAke3RoaXMuY29udHJvbGxlck5hbWV9OmApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9ubHkgYWxsb3dlZCByZWdpc3RlcmluZyBhY3Rpb24gaGFuZGxlcnMgcHJlZml4ZWQgYnkgJyR7dGhpcy5jb250cm9sbGVyTmFtZX06J2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGFjdGlvbiwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXIgYW4gYWN0aW9uIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgcHJldmVudCB0aGlzIGFjdGlvbiBmcm9tIGJlaW5nIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIFRoZSBhY3Rpb24gdHlwZSBiZWluZyB1bnJlZ2lzdGVyZWQgKm11c3QqIGJlIGluIHRoZSBjdXJyZW50IG5hbWVzcGFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3Rpb25UeXBlIC0gVGhlIGFjdGlvbiB0eXBlLiBUaGlzIGlzIGEgdW5xaXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgYWN0aW9uLlxuICAgICAqIEB0ZW1wbGF0ZSBUIC0gQSB0eXBlIHVuaW9uIG9mIEFjdGlvbiB0eXBlIHN0cmluZ3MgdGhhdCBhcmUgbmFtZXNwYWNlZCBieSBOLlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGFjdGlvbikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gQnJhbmNoIHVucmVhY2hhYmxlIHdpdGggdmFsaWQgdHlwZXNcbiAgICAgICAgaWYgKCFhY3Rpb24uc3RhcnRzV2l0aChgJHt0aGlzLmNvbnRyb2xsZXJOYW1lfTpgKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPbmx5IGFsbG93ZWQgdW5yZWdpc3RlcmluZyBhY3Rpb24gaGFuZGxlcnMgcHJlZml4ZWQgYnkgJyR7dGhpcy5jb250cm9sbGVyTmFtZX06J2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIudW5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCBhbiBhY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgY2FsbCB0aGUgYWN0aW9uIGhhbmRsZXIgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gYWN0aW9uIHR5cGUsIHBhc3NpbmdcbiAgICAgKiBhbG9uZyBhbnkgcGFyYW1ldGVycyBnaXZlbi5cbiAgICAgKlxuICAgICAqIFRoZSBhY3Rpb24gdHlwZSBiZWluZyBjYWxsZWQgbXVzdCBiZSBvbiB0aGUgYWN0aW9uIGFsbG93bGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3Rpb25UeXBlIC0gVGhlIGFjdGlvbiB0eXBlLiBUaGlzIGlzIGEgdW5xaXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgYWN0aW9uLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgYWN0aW9uIHBhcmFtZXRlcnMuIFRoZXNlIG11c3QgbWF0Y2ggdGhlIHR5cGUgb2YgdGhlIHBhcmFtZXRlcnMgb2YgdGhlXG4gICAgICogICByZWdpc3RlcmVkIGFjdGlvbiBoYW5kbGVyLlxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyB3aGVuIG5vIGhhbmRsZXIgaGFzIGJlZW4gcmVnaXN0ZXJlZCBmb3IgdGhlIGdpdmVuIHR5cGUuXG4gICAgICogQHRlbXBsYXRlIFQgLSBBIHR5cGUgdW5pb24gb2YgYWxsb3dlZCBBY3Rpb24gdHlwZSBzdHJpbmdzLlxuICAgICAqL1xuICAgIGNhbGwoYWN0aW9uLCAuLi5wYXJhbXMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gLy8gQnJhbmNoZXMgdW5yZWFjaGFibGUgd2l0aCB2YWxpZCB0eXBlc1xuICAgICAgICBpZiAodGhpcy5hbGxvd2VkQWN0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY3Rpb25zIGFsbG93ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5hbGxvd2VkQWN0aW9ucy5pbmNsdWRlcyhhY3Rpb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFjdGlvbiBtaXNzaW5nIGZyb20gYWxsb3cgbGlzdDogJHthY3Rpb259YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5jYWxsKGFjdGlvbiwgLi4ucGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGlzaCBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIFB1Ymxpc2hlcyB0aGUgZ2l2ZW4gcGF5bG9hZCB0byBhbGwgc3Vic2NyaWJlcnMgb2YgdGhlIGdpdmVuIGV2ZW50IHR5cGUuXG4gICAgICpcbiAgICAgKiBUaGUgZXZlbnQgdHlwZSBiZWluZyBwdWJsaXNoZWQgKm11c3QqIGJlIGluIHRoZSBjdXJyZW50IG5hbWVzcGFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBUaGUgZXZlbnQgdHlwZS4gVGhpcyBpcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGV2ZW50LlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIGV2ZW50IHBheWxvYWQuIFRoZSB0eXBlIG9mIHRoZSBwYXJhbWV0ZXJzIGZvciBlYWNoIGV2ZW50IGhhbmRsZXIgbXVzdFxuICAgICAqICAgbWF0Y2ggdGhlIHR5cGUgb2YgdGhpcyBwYXlsb2FkLlxuICAgICAqIEB0ZW1wbGF0ZSBFIC0gQSB0eXBlIHVuaW9uIG9mIEV2ZW50IHR5cGUgc3RyaW5ncyB0aGF0IGFyZSBuYW1lc3BhY2VkIGJ5IE4uXG4gICAgICovXG4gICAgcHVibGlzaChldmVudCwgLi4ucGF5bG9hZCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gQnJhbmNoIHVucmVhY2hhYmxlIHdpdGggdmFsaWQgdHlwZXNcbiAgICAgICAgaWYgKCFldmVudC5zdGFydHNXaXRoKGAke3RoaXMuY29udHJvbGxlck5hbWV9OmApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9ubHkgYWxsb3dlZCBwdWJsaXNoaW5nIGV2ZW50cyBwcmVmaXhlZCBieSAnJHt0aGlzLmNvbnRyb2xsZXJOYW1lfTonYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5wdWJsaXNoKGV2ZW50LCAuLi5wYXlsb2FkKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKGV2ZW50LCBoYW5kbGVyLCBzZWxlY3Rvcikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyAvLyBCcmFuY2hlcyB1bnJlYWNoYWJsZSB3aXRoIHZhbGlkIHR5cGVzXG4gICAgICAgIGlmICh0aGlzLmFsbG93ZWRFdmVudHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXZlbnRzIGFsbG93ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5hbGxvd2VkRXZlbnRzLmluY2x1ZGVzKGV2ZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFdmVudCBtaXNzaW5nIGZyb20gYWxsb3cgbGlzdDogJHtldmVudH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuc3Vic2NyaWJlKGV2ZW50LCBoYW5kbGVyLCBzZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUoZXZlbnQsIGhhbmRsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZSBmcm9tIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogVW5yZWdpc3RlcnMgdGhlIGdpdmVuIGZ1bmN0aW9uIGFzIGFuIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBldmVudC5cbiAgICAgKlxuICAgICAqIFRoZSBldmVudCB0eXBlIGJlaW5nIHVuc3Vic2NyaWJlZCB0byBtdXN0IGJlIG9uIHRoZSBldmVudCBhbGxvd2xpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gVGhlIGV2ZW50IHR5cGUuIFRoaXMgaXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBldmVudC5cbiAgICAgKiBAcGFyYW0gaGFuZGxlciAtIFRoZSBldmVudCBoYW5kbGVyIHRvIHVucmVnaXN0ZXIuXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IHdoZW4gdGhlIGdpdmVuIGV2ZW50IGhhbmRsZXIgaXMgbm90IHJlZ2lzdGVyZWQgZm9yIHRoaXMgZXZlbnQuXG4gICAgICogQHRlbXBsYXRlIFQgLSBBIHR5cGUgdW5pb24gb2YgYWxsb3dlZCBFdmVudCB0eXBlIHN0cmluZ3MuXG4gICAgICovXG4gICAgdW5zdWJzY3JpYmUoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gLy8gQnJhbmNoZXMgdW5yZWFjaGFibGUgd2l0aCB2YWxpZCB0eXBlc1xuICAgICAgICBpZiAodGhpcy5hbGxvd2VkRXZlbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV2ZW50cyBhbGxvd2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuYWxsb3dlZEV2ZW50cy5pbmNsdWRlcyhldmVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXZlbnQgbWlzc2luZyBmcm9tIGFsbG93IGxpc3Q6ICR7ZXZlbnR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci51bnN1YnNjcmliZShldmVudCwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIHN1YnNjcmlwdGlvbnMgZm9yIGEgc3BlY2lmaWMgZXZlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgcmVtb3ZlIGFsbCBzdWJzY3JpYmVkIGhhbmRsZXJzIGZvciB0aGlzIGV2ZW50LlxuICAgICAqXG4gICAgICogVGhlIGV2ZW50IHR5cGUgYmVpbmcgY2xlYXJlZCAqbXVzdCogYmUgaW4gdGhlIGN1cnJlbnQgbmFtZXNwYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSAtIFRoZSBldmVudCB0eXBlLiBUaGlzIGlzIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgZXZlbnQuXG4gICAgICogQHRlbXBsYXRlIEUgLSBBIHR5cGUgdW5pb24gb2YgRXZlbnQgdHlwZSBzdHJpbmdzIHRoYXQgYXJlIG5hbWVzcGFjZWQgYnkgTi5cbiAgICAgKi9cbiAgICBjbGVhckV2ZW50U3Vic2NyaXB0aW9ucyhldmVudCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gQnJhbmNoIHVucmVhY2hhYmxlIHdpdGggdmFsaWQgdHlwZXNcbiAgICAgICAgaWYgKCFldmVudC5zdGFydHNXaXRoKGAke3RoaXMuY29udHJvbGxlck5hbWV9OmApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9ubHkgYWxsb3dlZCBjbGVhcmluZyBldmVudHMgcHJlZml4ZWQgYnkgJyR7dGhpcy5jb250cm9sbGVyTmFtZX06J2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuY2xlYXJFdmVudFN1YnNjcmlwdGlvbnMoZXZlbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzdHJpY3RlZENvbnRyb2xsZXJNZXNzZW5nZXIgPSBSZXN0cmljdGVkQ29udHJvbGxlck1lc3Nlbmdlcjtcbi8qKlxuICogQSBtZXNzYWdpbmcgc3lzdGVtIGZvciBjb250cm9sbGVycy5cbiAqXG4gKiBUaGUgY29udHJvbGxlciBtZXNzZW5nZXIgYWxsb3dzIHJlZ2lzdGVyaW5nIGZ1bmN0aW9ucyBhcyAnYWN0aW9ucycgdGhhdCBjYW4gYmUgY2FsbGVkIGVsc2V3aGVyZSxcbiAqIGFuZCBpdCBhbGxvd3MgcHVibGlzaGluZyBhbmQgc3Vic2NyaWJpbmcgdG8gZXZlbnRzLiBCb3RoIGFjdGlvbnMgYW5kIGV2ZW50cyBhcmUgaWRlbnRpZmllZCBieVxuICogdW5pcXVlIHN0cmluZ3MuXG4gKlxuICogQHRlbXBsYXRlIEFjdGlvbiAtIEEgdHlwZSB1bmlvbiBvZiBhbGwgQWN0aW9uIHR5cGVzLlxuICogQHRlbXBsYXRlIEV2ZW50IC0gQSB0eXBlIHVuaW9uIG9mIGFsbCBFdmVudCB0eXBlcy5cbiAqL1xuY2xhc3MgQ29udHJvbGxlck1lc3NlbmdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhY2hlIG9mIHNlbGVjdG9yIHJldHVybiB2YWx1ZXMgZm9yIHRoZWlyIHJlc3BlY3RpdmUgaGFuZGxlcnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV2ZW50UGF5bG9hZENhY2hlID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhbiBhY3Rpb24gaGFuZGxlci5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBtYWtlIHRoZSByZWdpc3RlcmVkIGZ1bmN0aW9uIGF2YWlsYWJsZSB0byBjYWxsIHZpYSB0aGUgYGNhbGxgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3Rpb25UeXBlIC0gVGhlIGFjdGlvbiB0eXBlLiBUaGlzIGlzIGEgdW5xaXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgYWN0aW9uLlxuICAgICAqIEBwYXJhbSBoYW5kbGVyLSBUaGUgYWN0aW9uIGhhbmRsZXIuIFRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgd2hlbiB0aGUgYGNhbGxgIG1ldGhvZCBpc1xuICAgICAqICAgaW52b2tlZCB3aXRoIHRoZSBnaXZlbiBhY3Rpb24gdHlwZS5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgd2hlbiBhIGhhbmRsZXIgaGFzIGJlZW4gcmVnaXN0ZXJlZCBmb3IgdGhpcyBhY3Rpb24gdHlwZSBhbHJlYWR5LlxuICAgICAqIEB0ZW1wbGF0ZSBUIC0gQSB0eXBlIHVuaW9uIG9mIEFjdGlvbiB0eXBlIHN0cmluZ3MuXG4gICAgICovXG4gICAgcmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGFjdGlvblR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aW9ucy5oYXMoYWN0aW9uVHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQSBoYW5kbGVyIGZvciAke2FjdGlvblR5cGV9IGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aW9ucy5zZXQoYWN0aW9uVHlwZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXIgYW4gYWN0aW9uIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgcHJldmVudCB0aGlzIGFjdGlvbiBmcm9tIGJlaW5nIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3Rpb25UeXBlIC0gVGhlIGFjdGlvbiB0eXBlLiBUaGlzIGlzIGEgdW5xaXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgYWN0aW9uLlxuICAgICAqIEB0ZW1wbGF0ZSBUIC0gQSB0eXBlIHVuaW9uIG9mIEFjdGlvbiB0eXBlIHN0cmluZ3MuXG4gICAgICovXG4gICAgdW5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYWN0aW9uVHlwZSkge1xuICAgICAgICB0aGlzLmFjdGlvbnMuZGVsZXRlKGFjdGlvblR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVyIGFsbCBhY3Rpb24gaGFuZGxlcnMuXG4gICAgICpcbiAgICAgKiBUaGlzIHByZXZlbnRzIGFsbCBhY3Rpb25zIGZyb20gYmVpbmcgY2FsbGVkLlxuICAgICAqL1xuICAgIGNsZWFyQWN0aW9ucygpIHtcbiAgICAgICAgdGhpcy5hY3Rpb25zLmNsZWFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgYW4gYWN0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGNhbGwgdGhlIGFjdGlvbiBoYW5kbGVyIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGFjdGlvbiB0eXBlLCBwYXNzaW5nXG4gICAgICogYWxvbmcgYW55IHBhcmFtZXRlcnMgZ2l2ZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWN0aW9uVHlwZSAtIFRoZSBhY3Rpb24gdHlwZS4gVGhpcyBpcyBhIHVucWl1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIGFjdGlvbiBwYXJhbWV0ZXJzLiBUaGVzZSBtdXN0IG1hdGNoIHRoZSB0eXBlIG9mIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZVxuICAgICAqICAgcmVnaXN0ZXJlZCBhY3Rpb24gaGFuZGxlci5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgd2hlbiBubyBoYW5kbGVyIGhhcyBiZWVuIHJlZ2lzdGVyZWQgZm9yIHRoZSBnaXZlbiB0eXBlLlxuICAgICAqIEB0ZW1wbGF0ZSBUIC0gQSB0eXBlIHVuaW9uIG9mIEFjdGlvbiB0eXBlIHN0cmluZ3MuXG4gICAgICovXG4gICAgY2FsbChhY3Rpb25UeXBlLCAuLi5wYXJhbXMpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuYWN0aW9ucy5nZXQoYWN0aW9uVHlwZSk7XG4gICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGhhbmRsZXIgZm9yICR7YWN0aW9uVHlwZX0gaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWRgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlciguLi5wYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogUHVibGlzaGVzIHRoZSBnaXZlbiBwYXlsb2FkIHRvIGFsbCBzdWJzY3JpYmVycyBvZiB0aGUgZ2l2ZW4gZXZlbnQgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBUaGUgZXZlbnQgdHlwZS4gVGhpcyBpcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGV2ZW50LlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIGV2ZW50IHBheWxvYWQuIFRoZSB0eXBlIG9mIHRoZSBwYXJhbWV0ZXJzIGZvciBlYWNoIGV2ZW50IGhhbmRsZXIgbXVzdFxuICAgICAqICAgbWF0Y2ggdGhlIHR5cGUgb2YgdGhpcyBwYXlsb2FkLlxuICAgICAqIEB0ZW1wbGF0ZSBFIC0gQSB0eXBlIHVuaW9uIG9mIEV2ZW50IHR5cGUgc3RyaW5ncy5cbiAgICAgKi9cbiAgICBwdWJsaXNoKGV2ZW50VHlwZSwgLi4ucGF5bG9hZCkge1xuICAgICAgICBjb25zdCBzdWJzY3JpYmVycyA9IHRoaXMuZXZlbnRzLmdldChldmVudFR5cGUpO1xuICAgICAgICBpZiAoc3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2hhbmRsZXIsIHNlbGVjdG9yXSBvZiBzdWJzY3JpYmVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHRoaXMuZXZlbnRQYXlsb2FkQ2FjaGUuZ2V0KGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHNlbGVjdG9yKC4uLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IHByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRQYXlsb2FkQ2FjaGUuc2V0KGhhbmRsZXIsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIobmV3VmFsdWUsIHByZXZpb3VzVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKC4uLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJzY3JpYmUoZXZlbnRUeXBlLCBoYW5kbGVyLCBzZWxlY3Rvcikge1xuICAgICAgICBsZXQgc3Vic2NyaWJlcnMgPSB0aGlzLmV2ZW50cy5nZXQoZXZlbnRUeXBlKTtcbiAgICAgICAgaWYgKCFzdWJzY3JpYmVycykge1xuICAgICAgICAgICAgc3Vic2NyaWJlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5zZXQoZXZlbnRUeXBlLCBzdWJzY3JpYmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlcnMuc2V0KGhhbmRsZXIsIHNlbGVjdG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmUgZnJvbSBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIFVucmVnaXN0ZXJzIHRoZSBnaXZlbiBmdW5jdGlvbiBhcyBhbiBldmVudCBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gVGhlIGV2ZW50IHR5cGUuIFRoaXMgaXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBldmVudC5cbiAgICAgKiBAcGFyYW0gaGFuZGxlciAtIFRoZSBldmVudCBoYW5kbGVyIHRvIHVucmVnaXN0ZXIuXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IHdoZW4gdGhlIGdpdmVuIGV2ZW50IGhhbmRsZXIgaXMgbm90IHJlZ2lzdGVyZWQgZm9yIHRoaXMgZXZlbnQuXG4gICAgICogQHRlbXBsYXRlIEUgLSBBIHR5cGUgdW5pb24gb2YgRXZlbnQgdHlwZSBzdHJpbmdzLlxuICAgICAqL1xuICAgIHVuc3Vic2NyaWJlKGV2ZW50VHlwZSwgaGFuZGxlcikge1xuICAgICAgICBjb25zdCBzdWJzY3JpYmVycyA9IHRoaXMuZXZlbnRzLmdldChldmVudFR5cGUpO1xuICAgICAgICBpZiAoIXN1YnNjcmliZXJzIHx8ICFzdWJzY3JpYmVycy5oYXMoaGFuZGxlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3Vic2NyaXB0aW9uIG5vdCBmb3VuZCBmb3IgZXZlbnQ6ICR7ZXZlbnRUeXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gc3Vic2NyaWJlcnMuZ2V0KGhhbmRsZXIpO1xuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRQYXlsb2FkQ2FjaGUuZGVsZXRlKGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXJzLmRlbGV0ZShoYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgc3Vic2NyaXB0aW9ucyBmb3IgYSBzcGVjaWZpYyBldmVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCByZW1vdmUgYWxsIHN1YnNjcmliZWQgaGFuZGxlcnMgZm9yIHRoaXMgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gVGhlIGV2ZW50IHR5cGUuIFRoaXMgaXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBldmVudC5cbiAgICAgKiBAdGVtcGxhdGUgRSAtIEEgdHlwZSB1bmlvbiBvZiBFdmVudCB0eXBlIHN0cmluZ3MuXG4gICAgICovXG4gICAgY2xlYXJFdmVudFN1YnNjcmlwdGlvbnMoZXZlbnRUeXBlKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzLmRlbGV0ZShldmVudFR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgc3Vic2NyaXB0aW9ucy5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCByZW1vdmUgYWxsIHN1YnNjcmliZWQgaGFuZGxlcnMgZm9yIGFsbCBldmVudHMuXG4gICAgICovXG4gICAgY2xlYXJTdWJzY3JpcHRpb25zKCkge1xuICAgICAgICB0aGlzLmV2ZW50cy5jbGVhcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSByZXN0cmljdGVkIGNvbnRyb2xsZXIgbWVzc2VuZ2VyXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGEgd3JhcHBlciBhcm91bmQgdGhlIGNvbnRyb2xsZXIgbWVzc2VuZ2VyIGluc3RhbmNlIHRoYXQgcmVzdHJpY3RzIGFjY2VzcyB0byBhY3Rpb25zXG4gICAgICogYW5kIGV2ZW50cy4gVGhlIHByb3ZpZGVkIGFsbG93bGlzdHMgZ3JhbnQgdGhlIGFiaWxpdHkgdG8gY2FsbCB0aGUgbGlzdGVkIGFjdGlvbnMgYW5kIHN1YnNjcmliZVxuICAgICAqIHRvIHRoZSBsaXN0ZWQgZXZlbnRzLiBUaGUgXCJuYW1lXCIgcHJvdmlkZWQgZ3JhbnRzIG93bmVyc2hpcCBvZiBhbnkgYWN0aW9ucyBhbmQgZXZlbnRzIHVuZGVyXG4gICAgICogdGhhdCBuYW1lc3BhY2UuIE93bmVyc2hpcCBhbGxvd3MgcmVnaXN0ZXJpbmcgYWN0aW9ucyBhbmQgcHVibGlzaGluZyBldmVudHMsIGFzIHdlbGwgYXNcbiAgICAgKiB1bnJlZ2lzdGVyaW5nIGFjdGlvbnMgYW5kIGNsZWFyaW5nIGV2ZW50IHN1YnNjcmlwdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdGhpbmcgdGhpcyBtZXNzZW5nZXIgd2lsbCBiZSBoYW5kZWQgdG8gKGUuZy4gdGhlXG4gICAgICogICBjb250cm9sbGVyIG5hbWUpLiBUaGlzIGdyYW50cyBcIm93bmVyc2hpcFwiIG9mIGFjdGlvbnMgYW5kIGV2ZW50cyB1bmRlciB0aGlzIG5hbWVzcGFjZSB0byB0aGVcbiAgICAgKiAgIHJlc3RyaWN0ZWQgY29udHJvbGxlciBtZXNzZW5nZXIgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWxsb3dlZEFjdGlvbnMgLSBUaGUgbGlzdCBvZiBhY3Rpb25zIHRoYXQgdGhpcyByZXN0cmljdGVkIGNvbnRyb2xsZXIgbWVzc2VuZ2VyXG4gICAgICogICBzaG91bGQgYmUgYWxvd2VkIHRvIGNhbGwuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWxsb3dlZEV2ZW50cyAtIFRoZSBsaXN0IG9mIGV2ZW50cyB0aGF0IHRoaXMgcmVzdHJpY3RlZCBjb250cm9sbGVyIG1lc3NlbmdlclxuICAgICAqICAgc2hvdWxkIGJlIGFsbG93ZWQgdG8gc3Vic2NyaWJlIHRvLlxuICAgICAqIEB0ZW1wbGF0ZSBOIC0gVGhlIG5hbWVzcGFjZSBmb3IgdGhpcyBtZXNzZW5nZXIuIFR5cGljYWxseSB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBjb250cm9sbGVyIG9yXG4gICAgICogICBtb2R1bGUgdGhhdCB0aGlzIG1lc3NlbmdlciBoYXMgYmVlbiBjcmVhdGVkIGZvci4gVGhlIGF1dGhvcml0eSB0byBwdWJsaXNoIGV2ZW50cyBhbmQgcmVnaXN0ZXJcbiAgICAgKiAgIGFjdGlvbnMgdW5kZXIgdGhpcyBuYW1lc3BhY2UgaXMgZ3JhbnRlZCB0byB0aGlzIHJlc3RyaWN0ZWQgbWVzc2VuZ2VyIGluc3RhbmNlLlxuICAgICAqIEB0ZW1wbGF0ZSBBbGxvd2VkQWN0aW9uIC0gQSB0eXBlIHVuaW9uIG9mIHRoZSAndHlwZScgc3RyaW5nIGZvciBhbnkgYWxsb3dlZCBhY3Rpb25zLlxuICAgICAqIEB0ZW1wbGF0ZSBBbGxvd2VkRXZlbnQgLSBBIHR5cGUgdW5pb24gb2YgdGhlICd0eXBlJyBzdHJpbmcgZm9yIGFueSBhbGxvd2VkIGV2ZW50cy5cbiAgICAgKi9cbiAgICBnZXRSZXN0cmljdGVkKHsgbmFtZSwgYWxsb3dlZEFjdGlvbnMsIGFsbG93ZWRFdmVudHMsIH0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN0cmljdGVkQ29udHJvbGxlck1lc3Nlbmdlcih7XG4gICAgICAgICAgICBjb250cm9sbGVyTWVzc2VuZ2VyOiB0aGlzLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGFsbG93ZWRBY3Rpb25zLFxuICAgICAgICAgICAgYWxsb3dlZEV2ZW50cyxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db250cm9sbGVyTWVzc2VuZ2VyID0gQ29udHJvbGxlck1lc3Nlbmdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbnRyb2xsZXJNZXNzZW5nZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbXBvc2FibGVDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VDb250cm9sbGVyXCIpO1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gY29tcG9zZSBtdWx0aXBsZSBjb250cm9sbGVycyB0b2dldGhlclxuICovXG5jbGFzcyBDb21wb3NhYmxlQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBDb21wb3NhYmxlQ29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyb2xsZXJzIC0gTWFwIG9mIG5hbWVzIHRvIGNvbnRyb2xsZXIgaW5zdGFuY2VzXG4gICAgICogQHBhcmFtIG1lc3NlbmdlciAtIFRoZSBjb250cm9sbGVyIG1lc3NhZ2luZyBzeXN0ZW0sIHVzZWQgZm9yIGNvbW11bmljYXRpbmcgd2l0aCBCYXNlQ29udHJvbGxlclYyIGNvbnRyb2xsZXJzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udHJvbGxlcnMsIG1lc3Nlbmdlcikge1xuICAgICAgICBzdXBlcih1bmRlZmluZWQsIGNvbnRyb2xsZXJzLnJlZHVjZSgoc3RhdGUsIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICAgIHN0YXRlW2NvbnRyb2xsZXIubmFtZV0gPSBjb250cm9sbGVyLnN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9LCB7fSkpO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXJzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ0NvbXBvc2FibGVDb250cm9sbGVyJztcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlcnMgPSBjb250cm9sbGVycztcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0gPSBtZXNzZW5nZXI7XG4gICAgICAgIHRoaXMuY29udHJvbGxlcnMuZm9yRWFjaCgoY29udHJvbGxlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lIH0gPSBjb250cm9sbGVyO1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuc3Vic2NyaWJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLnN1YnNjcmliZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBbbmFtZV06IHN0YXRlIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tZXNzYWdpbmdTeXN0ZW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5zdWJzY3JpYmUoYCR7bmFtZX06c3RhdGVDaGFuZ2VgLCAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBbbmFtZV06IHN0YXRlIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXNzYWdpbmcgc3lzdGVtIHJlcXVpcmVkIGlmIGFueSBCYXNlQ29udHJvbGxlclYyIGNvbnRyb2xsZXJzIGFyZSB1c2VkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbGF0IHN0YXRlIHJlcHJlc2VudGF0aW9uLCBvbmUgdGhhdCBpc24ndCBrZXllZFxuICAgICAqIG9mIGNvbnRyb2xsZXIgbmFtZS4gSW5zdGVhZCwgYWxsIGNoaWxkIGNvbnRyb2xsZXIgc3RhdGUgaXMgbWVyZ2VkXG4gICAgICogdG9nZXRoZXIgaW50byBhIHNpbmdsZSwgZmxhdCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIE1lcmdlZCBzdGF0ZSByZXByZXNlbnRhdGlvbiBvZiBhbGwgY2hpbGQgY29udHJvbGxlcnNcbiAgICAgKi9cbiAgICBnZXQgZmxhdFN0YXRlKCkge1xuICAgICAgICBsZXQgZmxhdFN0YXRlID0ge307XG4gICAgICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiB0aGlzLmNvbnRyb2xsZXJzKSB7XG4gICAgICAgICAgICBmbGF0U3RhdGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZsYXRTdGF0ZSksIGNvbnRyb2xsZXIuc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGF0U3RhdGU7XG4gICAgfVxufVxuZXhwb3J0cy5Db21wb3NhYmxlQ29udHJvbGxlciA9IENvbXBvc2FibGVDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ29tcG9zYWJsZUNvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21wb3NhYmxlQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWRkcmVzc0Jvb2tDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgbWFuYWdlcyBhIGxpc3Qgb2YgcmVjaXBpZW50IGFkZHJlc3NlcyBhc3NvY2lhdGVkIHdpdGggbmlja25hbWVzXG4gKi9cbmNsYXNzIEFkZHJlc3NCb29rQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gQWRkcmVzc0Jvb2tDb250cm9sbGVyIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzdGF0ZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ0FkZHJlc3NCb29rQ29udHJvbGxlcic7XG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXRlID0geyBhZGRyZXNzQm9vazoge30gfTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgY29udHJhY3QgZW50cmllc1xuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IGFkZHJlc3NCb29rOiB7fSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgY29udHJhY3QgZW50cnkgYnkgYWRkcmVzc1xuICAgICAqXG4gICAgICogQHBhcmFtIGNoYWluSWQgLSBDaGFpbiBpZCBpZGVudGlmaWVzIHRoZSBjdXJyZW50IGNoYWluXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBSZWNpcGllbnQgYWRkcmVzcyB0byBkZWxldGVcbiAgICAgKi9cbiAgICBkZWxldGUoY2hhaW5JZCwgYWRkcmVzcykge1xuICAgICAgICBhZGRyZXNzID0gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBpZiAoIXV0aWxfMS5pc1ZhbGlkSGV4QWRkcmVzcyhhZGRyZXNzKSB8fFxuICAgICAgICAgICAgIXRoaXMuc3RhdGUuYWRkcmVzc0Jvb2tbY2hhaW5JZF0gfHxcbiAgICAgICAgICAgICF0aGlzLnN0YXRlLmFkZHJlc3NCb29rW2NoYWluSWRdW2FkZHJlc3NdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzc0Jvb2sgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlLmFkZHJlc3NCb29rKTtcbiAgICAgICAgZGVsZXRlIGFkZHJlc3NCb29rW2NoYWluSWRdW2FkZHJlc3NdO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoYWRkcmVzc0Jvb2tbY2hhaW5JZF0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIGFkZHJlc3NCb29rW2NoYWluSWRdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKHsgYWRkcmVzc0Jvb2sgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgb3IgdXBkYXRlIGEgY29udGFjdCBlbnRyeSBieSBhZGRyZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIFJlY2lwaWVudCBhZGRyZXNzIHRvIGFkZCBvciB1cGRhdGVcbiAgICAgKiBAcGFyYW0gbmFtZSAtIE5pY2tuYW1lIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgYWRkcmVzc1xuICAgICAqIEBwYXJhbSBjaGFpbklkIC0gQ2hhaW4gaWQgaWRlbnRpZmllcyB0aGUgY3VycmVudCBjaGFpblxuICAgICAqIEBwYXJhbSBtZW1vIC0gVXNlcidzIG5vdGUgYWJvdXQgYWRkcmVzc1xuICAgICAqIEByZXR1cm5zIC0gQm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBhZGRyZXNzIHdhcyBzdWNjZXNzZnVsbHkgc2V0XG4gICAgICovXG4gICAgc2V0KGFkZHJlc3MsIG5hbWUsIGNoYWluSWQgPSAnMScsIG1lbW8gPSAnJykge1xuICAgICAgICBhZGRyZXNzID0gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBpZiAoIXV0aWxfMS5pc1ZhbGlkSGV4QWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICBpc0VuczogZmFsc2UsXG4gICAgICAgICAgICBtZW1vLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZW5zTmFtZSA9IHV0aWxfMS5ub3JtYWxpemVFbnNOYW1lKG5hbWUpO1xuICAgICAgICBpZiAoZW5zTmFtZSkge1xuICAgICAgICAgICAgZW50cnkubmFtZSA9IGVuc05hbWU7XG4gICAgICAgICAgICBlbnRyeS5pc0VucyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgYWRkcmVzc0Jvb2s6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZS5hZGRyZXNzQm9vayksIHsgW2NoYWluSWRdOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUuYWRkcmVzc0Jvb2tbY2hhaW5JZF0pLCB7IFthZGRyZXNzXTogZW50cnkgfSkgfSksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLkFkZHJlc3NCb29rQ29udHJvbGxlciA9IEFkZHJlc3NCb29rQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IEFkZHJlc3NCb29rQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFkZHJlc3NCb29rQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc3NldHNEZXRlY3Rpb25Db250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuY29uc3QgREVGQVVMVF9JTlRFUlZBTCA9IDE4MDAwMDtcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IHBhc3NpdmVseSBwb2xscyBvbiBhIHNldCBpbnRlcnZhbCBmb3IgYXNzZXRzIGF1dG8gZGV0ZWN0aW9uXG4gKi9cbmNsYXNzIEFzc2V0c0RldGVjdGlvbkNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlcl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgQXNzZXRzRGV0ZWN0aW9uQ29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vbkNvbGxlY3RpYmxlc1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIGFzc2V0cyBjb250cm9sbGVyIHN0YXRlIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vblRva2Vuc1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIHRva2VucyBjb250cm9sbGVyIHN0YXRlIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UgLSBBbGxvd3Mgc3Vic2NyaWJpbmcgdG8gcHJlZmVyZW5jZXMgY29udHJvbGxlciBzdGF0ZSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25OZXR3b3JrU3RhdGVDaGFuZ2UgLSBBbGxvd3Mgc3Vic2NyaWJpbmcgdG8gbmV0d29yayBjb250cm9sbGVyIHN0YXRlIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRPcGVuU2VhQXBpS2V5IC0gR2V0cyB0aGUgT3BlblNlYSBBUEkga2V5LCBpZiBvbmUgaXMgc2V0XG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0QmFsYW5jZXNJblNpbmdsZUNhbGwgLSBHZXRzIHRoZSBiYWxhbmNlcyBvZiBhIGxpc3Qgb2YgdG9rZW5zIGZvciB0aGUgZ2l2ZW4gYWRkcmVzc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmFkZFRva2VucyAtIEFkZCBhIGxpc3Qgb2YgdG9rZW5zXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWRkQ29sbGVjdGlibGUgLSBBZGQgYSBjb2xsZWN0aWJsZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldENvbGxlY3RpYmxlc1N0YXRlIC0gR2V0cyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgQXNzZXRzIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRUb2tlbkxpc3RTdGF0ZSAtIEdldHMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIFRva2VuTGlzdCBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0VG9rZW5zU3RhdGUgLSBHZXRzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBUb2tlbnMgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBvblRva2Vuc1N0YXRlQ2hhbmdlLCBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UsIG9uTmV0d29ya1N0YXRlQ2hhbmdlLCBnZXRPcGVuU2VhQXBpS2V5LCBnZXRCYWxhbmNlc0luU2luZ2xlQ2FsbCwgYWRkVG9rZW5zLCBhZGRDb2xsZWN0aWJsZSwgZ2V0Q29sbGVjdGlibGVzU3RhdGUsIGdldFRva2VuTGlzdFN0YXRlLCBnZXRUb2tlbnNTdGF0ZSwgfSwgY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXNzZXRzRGV0ZWN0aW9uQ29udHJvbGxlcic7XG4gICAgICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgICAgICAgIGludGVydmFsOiBERUZBVUxUX0lOVEVSVkFMLFxuICAgICAgICAgICAgbmV0d29ya1R5cGU6IGNvbnN0YW50c18xLk1BSU5ORVQsXG4gICAgICAgICAgICBzZWxlY3RlZEFkZHJlc3M6ICcnLFxuICAgICAgICAgICAgdG9rZW5zOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuZ2V0Q29sbGVjdGlibGVzU3RhdGUgPSBnZXRDb2xsZWN0aWJsZXNTdGF0ZTtcbiAgICAgICAgdGhpcy5nZXRUb2tlbnNTdGF0ZSA9IGdldFRva2Vuc1N0YXRlO1xuICAgICAgICB0aGlzLmdldFRva2VuTGlzdFN0YXRlID0gZ2V0VG9rZW5MaXN0U3RhdGU7XG4gICAgICAgIHRoaXMuYWRkVG9rZW5zID0gYWRkVG9rZW5zO1xuICAgICAgICBvblRva2Vuc1N0YXRlQ2hhbmdlKCh7IHRva2VucyB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IHRva2VucyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZSgoeyBzZWxlY3RlZEFkZHJlc3MgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWN0dWFsU2VsZWN0ZWRBZGRyZXNzID0gdGhpcy5jb25maWcuc2VsZWN0ZWRBZGRyZXNzO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkQWRkcmVzcyAhPT0gYWN0dWFsU2VsZWN0ZWRBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmUoeyBzZWxlY3RlZEFkZHJlc3MgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRlY3RBc3NldHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlKCh7IHByb3ZpZGVyIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJlKHsgbmV0d29ya1R5cGU6IHByb3ZpZGVyLnR5cGUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdldE9wZW5TZWFBcGlLZXkgPSBnZXRPcGVuU2VhQXBpS2V5O1xuICAgICAgICB0aGlzLmdldEJhbGFuY2VzSW5TaW5nbGVDYWxsID0gZ2V0QmFsYW5jZXNJblNpbmdsZUNhbGw7XG4gICAgICAgIHRoaXMuYWRkQ29sbGVjdGlibGUgPSBhZGRDb2xsZWN0aWJsZTtcbiAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfVxuICAgIGdldE93bmVyQ29sbGVjdGlibGVzQXBpKGFkZHJlc3MsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gYGh0dHBzOi8vYXBpLm9wZW5zZWEuaW8vYXBpL3YxL2Fzc2V0cz9vd25lcj0ke2FkZHJlc3N9Jm9mZnNldD0ke29mZnNldH0mbGltaXQ9NTBgO1xuICAgIH1cbiAgICBnZXRPd25lckNvbGxlY3RpYmxlcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBzZWxlY3RlZEFkZHJlc3MgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAgICAgbGV0IGNvbGxlY3RpYmxlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgb3BlblNlYUFwaUtleSA9IHRoaXMuZ2V0T3BlblNlYUFwaUtleSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgcGFnaW5nRmluaXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcGkgPSB0aGlzLmdldE93bmVyQ29sbGVjdGlibGVzQXBpKHNlbGVjdGVkQWRkcmVzcywgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB5aWVsZCB1dGlsXzEudGltZW91dEZldGNoKGFwaSwgb3BlblNlYUFwaUtleSA/IHsgaGVhZGVyczogeyAnWC1BUEktS0VZJzogb3BlblNlYUFwaUtleSB9IH0gOiB7fSwgMTUwMDApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xsZWN0aWJsZXNBcnJheSA9IHlpZWxkIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICAgICAgKChfYSA9IGNvbGxlY3RpYmxlc0FycmF5LmFzc2V0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgIT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKGNvbGxlY3RpYmxlcyA9IFsuLi5jb2xsZWN0aWJsZXMsIC4uLmNvbGxlY3RpYmxlc0FycmF5LmFzc2V0c10pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChwYWdpbmdGaW5pc2ggPSB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDUwO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKCFwYWdpbmdGaW5pc2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aWJsZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBuZXcgcG9sbGluZyBpbnRlcnZhbFxuICAgICAqXG4gICAgICogQHBhcmFtIGludGVydmFsIC0gUG9sbGluZyBpbnRlcnZhbCB1c2VkIHRvIGF1dG8gZGV0ZWN0IGFzc2V0c1xuICAgICAqL1xuICAgIHBvbGwoaW50ZXJ2YWwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGludGVydmFsICYmIHRoaXMuY29uZmlndXJlKHsgaW50ZXJ2YWwgfSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlICYmIGNsZWFyVGltZW91dCh0aGlzLmhhbmRsZSk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmRldGVjdEFzc2V0cygpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvbGwodGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfSwgdGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgbmV0d29yayBpcyBtYWlubmV0IG9yIG5vdFxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBXaGV0aGVyIGN1cnJlbnQgbmV0d29yayBpcyBtYWlubmV0XG4gICAgICovXG4gICAgaXNNYWlubmV0KCkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcubmV0d29ya1R5cGUgIT09IGNvbnN0YW50c18xLk1BSU5ORVQgfHwgdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgYXNzZXRzIG93bmVkIGJ5IGN1cnJlbnQgYWNjb3VudCBvbiBtYWlubmV0XG4gICAgICovXG4gICAgZGV0ZWN0QXNzZXRzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNNYWlubmV0KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRldGVjdFRva2VucygpO1xuICAgICAgICAgICAgdGhpcy5kZXRlY3RDb2xsZWN0aWJsZXMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGFzc2V0IEVSQzIwIHRva2VuIGF1dG8gZGV0ZWN0aW9uIGZvciBlYWNoIGNvbnRyYWN0IGFkZHJlc3MgaW4gY29udHJhY3QgbWV0YWRhdGEgb24gbWFpbm5ldFxuICAgICAqL1xuICAgIGRldGVjdFRva2VucygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzTWFpbm5ldCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9rZW5zQWRkcmVzc2VzID0gdGhpcy5jb25maWcudG9rZW5zLm1hcChcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0Ki8gKHRva2VuKSA9PiB0b2tlbi5hZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgY29uc3QgeyB0b2tlbkxpc3QgfSA9IHRoaXMuZ2V0VG9rZW5MaXN0U3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHRva2Vuc1RvRGV0ZWN0ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFkZHJlc3MgaW4gdG9rZW5MaXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbnNBZGRyZXNzZXMuaW5jbHVkZXMoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zVG9EZXRlY3QucHVzaChhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzbGljZU9mVG9rZW5zVG9EZXRlY3QgPSBbXTtcbiAgICAgICAgICAgIHNsaWNlT2ZUb2tlbnNUb0RldGVjdFswXSA9IHRva2Vuc1RvRGV0ZWN0LnNsaWNlKDAsIDEwMDApO1xuICAgICAgICAgICAgc2xpY2VPZlRva2Vuc1RvRGV0ZWN0WzFdID0gdG9rZW5zVG9EZXRlY3Quc2xpY2UoMTAwMCwgdG9rZW5zVG9EZXRlY3QubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBjb25zdCB7IHNlbGVjdGVkQWRkcmVzcyB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRva2Vuc1NsaWNlIG9mIHNsaWNlT2ZUb2tlbnNUb0RldGVjdCkge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbnNTbGljZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZXMgPSB5aWVsZCB0aGlzLmdldEJhbGFuY2VzSW5TaW5nbGVDYWxsKHNlbGVjdGVkQWRkcmVzcywgdG9rZW5zU2xpY2UpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbnNUb0FkZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuQWRkcmVzcyBpbiBiYWxhbmNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlnbm9yZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBpZ25vcmVkVG9rZW5zIH0gPSB0aGlzLmdldFRva2Vuc1N0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlZFRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVkID0gaWdub3JlZFRva2Vucy5maW5kKChpZ25vcmVkVG9rZW5BZGRyZXNzKSA9PiBpZ25vcmVkVG9rZW5BZGRyZXNzID09PSB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3ModG9rZW5BZGRyZXNzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXNlSW5zZW5zaXRpdmVUb2tlbktleSA9IE9iamVjdC5rZXlzKHRva2VuTGlzdCkuZmluZCgoaSkgPT4gaS50b0xvd2VyQ2FzZSgpID09PSB0b2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKSkgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zVG9BZGQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRva2VuQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IHRva2VuTGlzdFtjYXNlSW5zZW5zaXRpdmVUb2tlbktleV0uZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbDogdG9rZW5MaXN0W2Nhc2VJbnNlbnNpdGl2ZVRva2VuS2V5XS5zeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2Vuc1RvQWRkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5hZGRUb2tlbnModG9rZW5zVG9BZGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYXNzZXQgRVJDNzIxIHRva2VuIGF1dG8gZGV0ZWN0aW9uIG9uIG1haW5uZXRcbiAgICAgKiBhZGRpbmcgbmV3IGNvbGxlY3RpYmxlcyBhbmQgcmVtb3Zpbmcgbm90IG93bmVkIGNvbGxlY3RpYmxlc1xuICAgICAqL1xuICAgIGRldGVjdENvbGxlY3RpYmxlcygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzTWFpbm5ldCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdGVkU2VsZWN0ZWRBZGRyZXNzID0gdGhpcy5jb25maWcuc2VsZWN0ZWRBZGRyZXNzO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICghcmVxdWVzdGVkU2VsZWN0ZWRBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgdXRpbF8xLnNhZmVseUV4ZWN1dGUoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwaUNvbGxlY3RpYmxlcyA9IHlpZWxkIHRoaXMuZ2V0T3duZXJDb2xsZWN0aWJsZXMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRDb2xsZWN0aWJsZXNQcm9taXNlcyA9IGFwaUNvbGxlY3RpYmxlcy5tYXAoKGNvbGxlY3RpYmxlKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9rZW5faWQsIG51bV9zYWxlcywgYmFja2dyb3VuZF9jb2xvciwgaW1hZ2VfdXJsLCBpbWFnZV9wcmV2aWV3X3VybCwgaW1hZ2VfdGh1bWJuYWlsX3VybCwgaW1hZ2Vfb3JpZ2luYWxfdXJsLCBhbmltYXRpb25fdXJsLCBhbmltYXRpb25fb3JpZ2luYWxfdXJsLCBuYW1lLCBkZXNjcmlwdGlvbiwgZXh0ZXJuYWxfbGluaywgY3JlYXRvciwgYXNzZXRfY29udHJhY3Q6IHsgYWRkcmVzcyB9LCBsYXN0X3NhbGUsIH0gPSBjb2xsZWN0aWJsZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlnbm9yZWQ7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaWdub3JlZENvbGxlY3RpYmxlcyB9ID0gdGhpcy5nZXRDb2xsZWN0aWJsZXNTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlZENvbGxlY3RpYmxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZWQgPSBpZ25vcmVkQ29sbGVjdGlibGVzLmZpbmQoKGMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoYy5hZGRyZXNzID09PSB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy50b2tlbklkID09PSBOdW1iZXIodG9rZW5faWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgICAgIGlmICghaWdub3JlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGVkU2VsZWN0ZWRBZGRyZXNzID09PSB0aGlzLmNvbmZpZy5zZWxlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xsZWN0aWJsZU1ldGFkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgeyBuYW1lIH0sIGNyZWF0b3IgJiYgeyBjcmVhdG9yIH0sIGRlc2NyaXB0aW9uICYmIHsgZGVzY3JpcHRpb24gfSwgaW1hZ2VfdXJsICYmIHsgaW1hZ2U6IGltYWdlX3VybCB9LCBudW1fc2FsZXMgJiYgeyBudW1iZXJPZlNhbGVzOiBudW1fc2FsZXMgfSwgYmFja2dyb3VuZF9jb2xvciAmJiB7IGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZF9jb2xvciB9LCBpbWFnZV9wcmV2aWV3X3VybCAmJiB7IGltYWdlUHJldmlldzogaW1hZ2VfcHJldmlld191cmwgfSwgaW1hZ2VfdGh1bWJuYWlsX3VybCAmJiB7IGltYWdlVGh1bWJuYWlsOiBpbWFnZV90aHVtYm5haWxfdXJsIH0sIGltYWdlX29yaWdpbmFsX3VybCAmJiB7IGltYWdlT3JpZ2luYWw6IGltYWdlX29yaWdpbmFsX3VybCB9LCBhbmltYXRpb25fdXJsICYmIHsgYW5pbWF0aW9uOiBhbmltYXRpb25fdXJsIH0sIGFuaW1hdGlvbl9vcmlnaW5hbF91cmwgJiYge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbk9yaWdpbmFsOiBhbmltYXRpb25fb3JpZ2luYWxfdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZXh0ZXJuYWxfbGluayAmJiB7IGV4dGVybmFsTGluazogZXh0ZXJuYWxfbGluayB9LCBsYXN0X3NhbGUgJiYgeyBsYXN0U2FsZTogbGFzdF9zYWxlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5hZGRDb2xsZWN0aWJsZShhZGRyZXNzLCBOdW1iZXIodG9rZW5faWQpLCBjb2xsZWN0aWJsZU1ldGFkYXRhLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChhZGRDb2xsZWN0aWJsZXNQcm9taXNlcyk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNzZXRzRGV0ZWN0aW9uQ29udHJvbGxlciA9IEFzc2V0c0RldGVjdGlvbkNvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBBc3NldHNEZXRlY3Rpb25Db250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXNzZXRzRGV0ZWN0aW9uQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJlZmVyZW5jZXNDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgc3RvcmVzIHNoYXJlZCBzZXR0aW5ncyBhbmQgZXhwb3NlcyBjb252ZW5pZW5jZSBtZXRob2RzXG4gKi9cbmNsYXNzIFByZWZlcmVuY2VzQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnUHJlZmVyZW5jZXNDb250cm9sbGVyJztcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XG4gICAgICAgICAgICBmZWF0dXJlRmxhZ3M6IHt9LFxuICAgICAgICAgICAgZnJlcXVlbnRScGNMaXN0OiBbXSxcbiAgICAgICAgICAgIGlkZW50aXRpZXM6IHt9LFxuICAgICAgICAgICAgaXBmc0dhdGV3YXk6ICdodHRwczovL2lwZnMuaW8vaXBmcy8nLFxuICAgICAgICAgICAgbG9zdElkZW50aXRpZXM6IHt9LFxuICAgICAgICAgICAgc2VsZWN0ZWRBZGRyZXNzOiAnJyxcbiAgICAgICAgICAgIHVzZVN0YXRpY1Rva2VuTGlzdDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGlkZW50aXRpZXMgdG8gc3RhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzZXMgLSBMaXN0IG9mIGFkZHJlc3NlcyB0byB1c2UgdG8gZ2VuZXJhdGUgbmV3IGlkZW50aXRpZXNcbiAgICAgKi9cbiAgICBhZGRJZGVudGl0aWVzKGFkZHJlc3Nlcykge1xuICAgICAgICBjb25zdCB7IGlkZW50aXRpZXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGFkZHJlc3Nlcy5mb3JFYWNoKChhZGRyZXNzKSA9PiB7XG4gICAgICAgICAgICBhZGRyZXNzID0gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAgICAgaWYgKGlkZW50aXRpZXNbYWRkcmVzc10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpZGVudGl0eUNvdW50ID0gT2JqZWN0LmtleXMoaWRlbnRpdGllcykubGVuZ3RoO1xuICAgICAgICAgICAgaWRlbnRpdGllc1thZGRyZXNzXSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBgQWNjb3VudCAke2lkZW50aXR5Q291bnQgKyAxfWAsXG4gICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBpbXBvcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlKHsgaWRlbnRpdGllczogT2JqZWN0LmFzc2lnbih7fSwgaWRlbnRpdGllcykgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gaWRlbnRpdHkgZnJvbSBzdGF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBBZGRyZXNzIG9mIHRoZSBpZGVudGl0eSB0byByZW1vdmVcbiAgICAgKi9cbiAgICByZW1vdmVJZGVudGl0eShhZGRyZXNzKSB7XG4gICAgICAgIGFkZHJlc3MgPSB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IHsgaWRlbnRpdGllcyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKCFpZGVudGl0aWVzW2FkZHJlc3NdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGlkZW50aXRpZXNbYWRkcmVzc107XG4gICAgICAgIHRoaXMudXBkYXRlKHsgaWRlbnRpdGllczogT2JqZWN0LmFzc2lnbih7fSwgaWRlbnRpdGllcykgfSk7XG4gICAgICAgIGlmIChhZGRyZXNzID09PSB0aGlzLnN0YXRlLnNlbGVjdGVkQWRkcmVzcykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBzZWxlY3RlZEFkZHJlc3M6IE9iamVjdC5rZXlzKGlkZW50aXRpZXMpWzBdIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc29jaWF0ZXMgYSBuZXcgbGFiZWwgd2l0aCBhbiBpZGVudGl0eVxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBBZGRyZXNzIG9mIHRoZSBpZGVudGl0eSB0byBhc3NvY2lhdGVcbiAgICAgKiBAcGFyYW0gbGFiZWwgLSBOZXcgbGFiZWwgdG8gYXNzaWduXG4gICAgICovXG4gICAgc2V0QWNjb3VudExhYmVsKGFkZHJlc3MsIGxhYmVsKSB7XG4gICAgICAgIGFkZHJlc3MgPSB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IHsgaWRlbnRpdGllcyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWRlbnRpdGllc1thZGRyZXNzXSA9IGlkZW50aXRpZXNbYWRkcmVzc10gfHwge307XG4gICAgICAgIGlkZW50aXRpZXNbYWRkcmVzc10ubmFtZSA9IGxhYmVsO1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IGlkZW50aXRpZXM6IE9iamVjdC5hc3NpZ24oe30sIGlkZW50aXRpZXMpIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBhIHNwZWNpZmljIGZlYXR1cmUgZmxhZ1xuICAgICAqXG4gICAgICogQHBhcmFtIGZlYXR1cmUgLSBGZWF0dXJlIHRvIHRvZ2dsZVxuICAgICAqIEBwYXJhbSBhY3RpdmF0ZWQgLSBWYWx1ZSB0byBhc3NpZ25cbiAgICAgKi9cbiAgICBzZXRGZWF0dXJlRmxhZyhmZWF0dXJlLCBhY3RpdmF0ZWQpIHtcbiAgICAgICAgY29uc3Qgb2xkRmVhdHVyZUZsYWdzID0gdGhpcy5zdGF0ZS5mZWF0dXJlRmxhZ3M7XG4gICAgICAgIGNvbnN0IGZlYXR1cmVGbGFncyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb2xkRmVhdHVyZUZsYWdzKSwgeyBbZmVhdHVyZV06IGFjdGl2YXRlZCB9KTtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBmZWF0dXJlRmxhZ3M6IE9iamVjdC5hc3NpZ24oe30sIGZlYXR1cmVGbGFncykgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmNocm9uaXplcyB0aGUgY3VycmVudCBpZGVudGl0eSBsaXN0IHdpdGggbmV3IGlkZW50aXRpZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzZXMgLSBMaXN0IG9mIGFkZHJlc3NlcyBjb3JyZXNwb25kaW5nIHRvIGlkZW50aXRpZXMgdG8gc3luY1xuICAgICAqIEByZXR1cm5zIC0gTmV3bHktc2VsZWN0ZWQgYWRkcmVzcyBhZnRlciBzeW5jaW5nXG4gICAgICovXG4gICAgc3luY0lkZW50aXRpZXMoYWRkcmVzc2VzKSB7XG4gICAgICAgIGFkZHJlc3NlcyA9IGFkZHJlc3Nlcy5tYXAoKGFkZHJlc3MpID0+IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKSk7XG4gICAgICAgIGNvbnN0IHsgaWRlbnRpdGllcywgbG9zdElkZW50aXRpZXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IG5ld2x5TG9zdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGlkZW50aXR5IGluIGlkZW50aXRpZXMpIHtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzZXMuaW5kZXhPZihpZGVudGl0eSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbmV3bHlMb3N0W2lkZW50aXR5XSA9IGlkZW50aXRpZXNbaWRlbnRpdHldO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpZGVudGl0aWVzW2lkZW50aXR5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobmV3bHlMb3N0KS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdseUxvc3QpIHtcbiAgICAgICAgICAgICAgICBsb3N0SWRlbnRpdGllc1trZXldID0gbmV3bHlMb3N0W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgaWRlbnRpdGllczogT2JqZWN0LmFzc2lnbih7fSwgaWRlbnRpdGllcyksXG4gICAgICAgICAgICBsb3N0SWRlbnRpdGllczogT2JqZWN0LmFzc2lnbih7fSwgbG9zdElkZW50aXRpZXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGRJZGVudGl0aWVzKGFkZHJlc3Nlcyk7XG4gICAgICAgIGlmIChhZGRyZXNzZXMuaW5kZXhPZih0aGlzLnN0YXRlLnNlbGVjdGVkQWRkcmVzcykgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHNlbGVjdGVkQWRkcmVzczogYWRkcmVzc2VzWzBdIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGVkQWRkcmVzcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuZCBzdG9yZXMgYSBuZXcgbGlzdCBvZiBzdG9yZWQgaWRlbnRpdGllcyBiYXNlZCBvbiBhZGRyZXNzLiBJZiB0aGUgc2VsZWN0ZWQgYWRkcmVzc1xuICAgICAqIGlzIHVuc2V0LCBvciBpZiBpdCByZWZlcnMgdG8gYW4gaWRlbnRpdHkgdGhhdCB3YXMgcmVtb3ZlZCwgaXQgd2lsbCBiZSBzZXQgdG8gdGhlIGZpcnN0XG4gICAgICogaWRlbnRpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzc2VzIC0gTGlzdCBvZiBhZGRyZXNzZXMgdG8gdXNlIGFzIGEgYmFzaXMgZm9yIGVhY2ggaWRlbnRpdHlcbiAgICAgKi9cbiAgICB1cGRhdGVJZGVudGl0aWVzKGFkZHJlc3Nlcykge1xuICAgICAgICBhZGRyZXNzZXMgPSBhZGRyZXNzZXMubWFwKChhZGRyZXNzKSA9PiB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcykpO1xuICAgICAgICBjb25zdCBvbGRJZGVudGl0aWVzID0gdGhpcy5zdGF0ZS5pZGVudGl0aWVzO1xuICAgICAgICBjb25zdCBpZGVudGl0aWVzID0gYWRkcmVzc2VzLnJlZHVjZSgoaWRzLCBhZGRyZXNzLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWRzW2FkZHJlc3NdID0gb2xkSWRlbnRpdGllc1thZGRyZXNzXSB8fCB7XG4gICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBuYW1lOiBgQWNjb3VudCAke2luZGV4ICsgMX1gLFxuICAgICAgICAgICAgICAgIGltcG9ydFRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGlkcztcbiAgICAgICAgfSwge30pO1xuICAgICAgICBsZXQgeyBzZWxlY3RlZEFkZHJlc3MgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGlmICghT2JqZWN0LmtleXMoaWRlbnRpdGllcykuaW5jbHVkZXMoc2VsZWN0ZWRBZGRyZXNzKSkge1xuICAgICAgICAgICAgc2VsZWN0ZWRBZGRyZXNzID0gT2JqZWN0LmtleXMoaWRlbnRpdGllcylbMF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoeyBpZGVudGl0aWVzOiBPYmplY3QuYXNzaWduKHt9LCBpZGVudGl0aWVzKSwgc2VsZWN0ZWRBZGRyZXNzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGN1c3RvbSBSUEMgVVJMIHRvIHN0YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIC0gQ3VzdG9tIFJQQyBVUkxcbiAgICAgKiBAcGFyYW0gY2hhaW5JZD8gLSBOZXR3b3JrIElEIGFzIHBlciBFSVAtMTU1XG4gICAgICogQHBhcmFtIHRpY2tlcj8gLSBDdXJyZW5jeSB0aWNrZXJcbiAgICAgKiBAcGFyYW0gbmlja25hbWU/IC0gUGVyc29uYWxpemVkIG5ldHdvcmsgbmFtZVxuICAgICAqIEBwYXJhbSBycGNQcmVmcz8gLSBQZXJzb25hbGl6ZWQgcHJlZmVyZW5jZXNcbiAgICAgKlxuICAgICAqL1xuICAgIGFkZFRvRnJlcXVlbnRScGNMaXN0KHVybCwgY2hhaW5JZCwgdGlja2VyLCBuaWNrbmFtZSwgcnBjUHJlZnMpIHtcbiAgICAgICAgY29uc3QgeyBmcmVxdWVudFJwY0xpc3QgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZnJlcXVlbnRScGNMaXN0LmZpbmRJbmRleCgoeyBycGNVcmwgfSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJwY1VybCA9PT0gdXJsO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgZnJlcXVlbnRScGNMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3RnJlcXVlc3RScGMgPSB7XG4gICAgICAgICAgICBycGNVcmw6IHVybCxcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICB0aWNrZXIsXG4gICAgICAgICAgICBuaWNrbmFtZSxcbiAgICAgICAgICAgIHJwY1ByZWZzLFxuICAgICAgICB9O1xuICAgICAgICBmcmVxdWVudFJwY0xpc3QucHVzaChuZXdGcmVxdWVzdFJwYyk7XG4gICAgICAgIHRoaXMudXBkYXRlKHsgZnJlcXVlbnRScGNMaXN0OiBbLi4uZnJlcXVlbnRScGNMaXN0XSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBjdXN0b20gUlBDIFVSTCBmcm9tIHN0YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIC0gQ3VzdG9tIFJQQyBVUkxcbiAgICAgKi9cbiAgICByZW1vdmVGcm9tRnJlcXVlbnRScGNMaXN0KHVybCkge1xuICAgICAgICBjb25zdCB7IGZyZXF1ZW50UnBjTGlzdCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBmcmVxdWVudFJwY0xpc3QuZmluZEluZGV4KCh7IHJwY1VybCB9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcnBjVXJsID09PSB1cmw7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBmcmVxdWVudFJwY0xpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSh7IGZyZXF1ZW50UnBjTGlzdDogWy4uLmZyZXF1ZW50UnBjTGlzdF0gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgc2VsZWN0ZWQgYWRkcmVzc1xuICAgICAqXG4gICAgICogQHBhcmFtIHNlbGVjdGVkQWRkcmVzcyAtIEV0aGVyZXVtIGFkZHJlc3NcbiAgICAgKi9cbiAgICBzZXRTZWxlY3RlZEFkZHJlc3Moc2VsZWN0ZWRBZGRyZXNzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKHsgc2VsZWN0ZWRBZGRyZXNzOiB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3Moc2VsZWN0ZWRBZGRyZXNzKSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBuZXcgSVBGUyBnYXRld2F5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXBmc0dhdGV3YXkgLSBJUEZTIGdhdGV3YXkgc3RyaW5nXG4gICAgICovXG4gICAgc2V0SXBmc0dhdGV3YXkoaXBmc0dhdGV3YXkpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBpcGZzR2F0ZXdheSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRoZSB0b2tlbiBkZXRlY3Rpb24gc2V0dGluZyB0byB1c2UgZHluYW1pYyB0b2tlbiBsaXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlU3RhdGljVG9rZW5MaXN0IC0gSVBGUyBnYXRld2F5IHN0cmluZ1xuICAgICAqL1xuICAgIHNldFVzZVN0YXRpY1Rva2VuTGlzdCh1c2VTdGF0aWNUb2tlbkxpc3QpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoeyB1c2VTdGF0aWNUb2tlbkxpc3QgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5QcmVmZXJlbmNlc0NvbnRyb2xsZXIgPSBQcmVmZXJlbmNlc0NvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBQcmVmZXJlbmNlc0NvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QcmVmZXJlbmNlc0NvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5vdGlmaWNhdGlvbkNvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuY29uc3QgZGVmYXVsdFN0YXRlID0ge1xuICAgIG5vdGlmaWNhdGlvbnM6IHt9LFxufTtcbi8qKlxuICogQ29udHJvbGxlciBmb3IgbWFuYWdpbmcgaW4tYXBwIGFubm91bmNlbWVudCBub3RpZmljYXRpb25zLlxuICovXG5jbGFzcyBOb3RpZmljYXRpb25Db250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE5vdGlmaWNhdGlvbkNvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlIHx8IGRlZmF1bHRTdGF0ZSk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLl9hZGROb3RpZmljYXRpb25zKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHRoZSBub3RpZmljYXRpb25zIGluIHN0YXRlIHdpdGggdGhlIG5vdGlmaWNhdGlvbnMgZnJvbSBmaWxlXG4gICAgICogdG8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBuZXcgbm90aWZpY2F0aW9ucy9hbm5vdW5jZW1lbnRzXG4gICAgICogaWYgeWVzLCB0aGUgbmV3IG5vdGlmaWNhdGlvbiB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzdGF0ZSB3aXRoIGEgZmxhZyBpbmRpY2F0aW5nXG4gICAgICogdGhhdCB0aGUgbm90aWZpY2F0aW9uIGlzIG5vdCBzZWVuIGJ5IHRoZSB1c2VyLlxuICAgICAqXG4gICAgICogIEBwYXJhbSBhbGxOb3RpZmljYXRpb25zXG4gICAgICovXG4gICAgX2FkZE5vdGlmaWNhdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IG5ld05vdGlmaWNhdGlvbnMgPSB7fTtcbiAgICAgICAgY29uc3QgeyBhbGxOb3RpZmljYXRpb25zIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhhbGxOb3RpZmljYXRpb25zKS5mb3JFYWNoKChub3RpZmljYXRpb24pID0+IHtcbiAgICAgICAgICAgIG5ld05vdGlmaWNhdGlvbnNbbm90aWZpY2F0aW9uLmlkXSA9IHRoaXMuc3RhdGUubm90aWZpY2F0aW9uc1tub3RpZmljYXRpb24uaWRdXG4gICAgICAgICAgICAgICAgPyB0aGlzLnN0YXRlLm5vdGlmaWNhdGlvbnNbbm90aWZpY2F0aW9uLmlkXVxuICAgICAgICAgICAgICAgIDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBub3RpZmljYXRpb24pLCB7IGlzU2hvd246IGZhbHNlIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBub3RpZmljYXRpb25zOiBuZXdOb3RpZmljYXRpb25zIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBzdGF0dXMgb2YgdGhlIHN0YXR1cyBvZiB0aGUgc3BlY2lmaWVkIG5vdGlmaWNhdGlvbnNcbiAgICAgKiBvbmNlIGl0IGlzIHJlYWQgYnkgdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmlld2VkSWRzXG4gICAgICovXG4gICAgdXBkYXRlVmlld2VkKHZpZXdlZElkcykge1xuICAgICAgICBjb25zdCBzdGF0ZU5vdGlmaWNhdGlvbnMgPSB0aGlzLnN0YXRlLm5vdGlmaWNhdGlvbnM7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgT2JqZWN0LmtleXModmlld2VkSWRzKS5tYXAoTnVtYmVyKSkge1xuICAgICAgICAgICAgc3RhdGVOb3RpZmljYXRpb25zW2lkXS5pc1Nob3duID0gdmlld2VkSWRzW2lkXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSh7IG5vdGlmaWNhdGlvbnM6IHN0YXRlTm90aWZpY2F0aW9ucyB9LCB0cnVlKTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvbkNvbnRyb2xsZXIgPSBOb3RpZmljYXRpb25Db250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm90aWZpY2F0aW9uQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ub2tlblJhdGVzQ29udHJvbGxlciA9IHZvaWQgMDtcbmNvbnN0IEJhc2VDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbmNvbnN0IGNyeXB0b19jb21wYXJlXzEgPSByZXF1aXJlKFwiLi4vYXBpcy9jcnlwdG8tY29tcGFyZVwiKTtcbmNvbnN0IENvaW5HZWNrb0FwaSA9IHtcbiAgICBCQVNFX1VSTDogJ2h0dHBzOi8vYXBpLmNvaW5nZWNrby5jb20vYXBpL3YzJyxcbiAgICBnZXRUb2tlblByaWNlVVJMKGNoYWluU2x1ZywgcXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuQkFTRV9VUkx9L3NpbXBsZS90b2tlbl9wcmljZS8ke2NoYWluU2x1Z30/JHtxdWVyeX1gO1xuICAgIH0sXG4gICAgZ2V0UGxhdGZvcm1zVVJMKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5CQVNFX1VSTH0vYXNzZXRfcGxhdGZvcm1zYDtcbiAgICB9LFxuICAgIGdldFN1cHBvcnRlZFZzQ3VycmVuY2llcygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuQkFTRV9VUkx9L3NpbXBsZS9zdXBwb3J0ZWRfdnNfY3VycmVuY2llc2A7XG4gICAgfSxcbn07XG4vKipcbiAqIEZpbmRzIHRoZSBjaGFpbiBzbHVnIGluIHRoZSBkYXRhIGFycmF5IGdpdmVuIGEgY2hhaW5JZFxuICpcbiAqIEBwYXJhbSBjaGFpbklkIGN1cnJlbnQgY2hhaW5JZFxuICogQHBhcmFtIGRhdGEgQXJyYXkgb2Ygc3VwcG9ydGVkIHBsYXRmb3JtcyBmcm9tIENvaW5HZWNrbyBBUElcbiAqIEByZXR1cm5zIFNsdWcgb2YgY2hhaW5JZFxuICovXG5mdW5jdGlvbiBmaW5kQ2hhaW5TbHVnKGNoYWluSWQsIGRhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjaGFpbiA9IChfYSA9IGRhdGEuZmluZCgoeyBjaGFpbl9pZGVudGlmaWVyIH0pID0+IGNoYWluX2lkZW50aWZpZXIgIT09IG51bGwgJiYgU3RyaW5nKGNoYWluX2lkZW50aWZpZXIpID09PSBjaGFpbklkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICByZXR1cm4gKGNoYWluID09PSBudWxsIHx8IGNoYWluID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFpbi5pZCkgfHwgbnVsbDtcbn1cbi8qKlxuICogQ29udHJvbGxlciB0aGF0IHBhc3NpdmVseSBwb2xscyBvbiBhIHNldCBpbnRlcnZhbCBmb3IgdG9rZW4tdG8tZmlhdCBleGNoYW5nZSByYXRlc1xuICogZm9yIHRva2VucyBzdG9yZWQgaW4gdGhlIFRva2Vuc0NvbnRyb2xsZXJcbiAqL1xuY2xhc3MgVG9rZW5SYXRlc0NvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlcl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVG9rZW5SYXRlc0NvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25Bc3NldHNTdGF0ZUNoYW5nZSAtIEFsbG93cyBzdWJzY3JpYmluZyB0byBhc3NldHMgY29udHJvbGxlciBzdGF0ZSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25DdXJyZW5jeVJhdGVTdGF0ZUNoYW5nZSAtIEFsbG93cyBzdWJzY3JpYmluZyB0byBjdXJyZW5jeSByYXRlIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlc1xuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBvblRva2Vuc1N0YXRlQ2hhbmdlLCBvbkN1cnJlbmN5UmF0ZVN0YXRlQ2hhbmdlLCBvbk5ldHdvcmtTdGF0ZUNoYW5nZSwgfSwgY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgdGhpcy50b2tlbkxpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5zdXBwb3J0ZWRDaGFpbnMgPSB7XG4gICAgICAgICAgICB0aW1lc3RhbXA6IDAsXG4gICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN1cHBvcnRlZFZzQ3VycmVuY2llcyA9IHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogMCxcbiAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdUb2tlblJhdGVzQ29udHJvbGxlcic7XG4gICAgICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgICAgICAgIGRpc2FibGVkOiB0cnVlLFxuICAgICAgICAgICAgaW50ZXJ2YWw6IDMgKiA2MCAqIDEwMDAsXG4gICAgICAgICAgICBuYXRpdmVDdXJyZW5jeTogJ2V0aCcsXG4gICAgICAgICAgICBjaGFpbklkOiAnJyxcbiAgICAgICAgICAgIHRva2VuczogW10sXG4gICAgICAgICAgICB0aHJlc2hvbGQ6IDYgKiA2MCAqIDYwICogMTAwMCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XG4gICAgICAgICAgICBjb250cmFjdEV4Y2hhbmdlUmF0ZXM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmUoeyBkaXNhYmxlZDogZmFsc2UgfSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgb25Ub2tlbnNTdGF0ZUNoYW5nZSgodG9rZW5zU3RhdGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJlKHsgdG9rZW5zOiB0b2tlbnNTdGF0ZS50b2tlbnMgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvbkN1cnJlbmN5UmF0ZVN0YXRlQ2hhbmdlKChjdXJyZW5jeVJhdGVTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmUoeyBuYXRpdmVDdXJyZW5jeTogY3VycmVuY3lSYXRlU3RhdGUubmF0aXZlQ3VycmVuY3kgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZSgoeyBwcm92aWRlciB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNoYWluSWQgfSA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBjb250cmFjdEV4Y2hhbmdlUmF0ZXM6IHt9IH0pO1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmUoeyBjaGFpbklkIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBuZXcgcG9sbGluZyBpbnRlcnZhbFxuICAgICAqXG4gICAgICogQHBhcmFtIGludGVydmFsIC0gUG9sbGluZyBpbnRlcnZhbCB1c2VkIHRvIGZldGNoIG5ldyB0b2tlbiByYXRlc1xuICAgICAqL1xuICAgIHBvbGwoaW50ZXJ2YWwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGludGVydmFsICYmIHRoaXMuY29uZmlndXJlKHsgaW50ZXJ2YWwgfSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlICYmIGNsZWFyVGltZW91dCh0aGlzLmhhbmRsZSk7XG4gICAgICAgICAgICB5aWVsZCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSgoKSA9PiB0aGlzLnVwZGF0ZUV4Y2hhbmdlUmF0ZXMoKSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucG9sbCh0aGlzLmNvbmZpZy5pbnRlcnZhbCk7XG4gICAgICAgICAgICB9LCB0aGlzLmNvbmZpZy5pbnRlcnZhbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbmV3IGNoYWluSWRcbiAgICAgKlxuICAgICAqIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIGEgbWV0aG9kXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhaW5JZCBjdXJyZW50IGNoYWluSWRcbiAgICAgKi9cbiAgICBzZXQgY2hhaW5JZChfY2hhaW5JZCkge1xuICAgICAgICAhdGhpcy5kaXNhYmxlZCAmJiB1dGlsXzEuc2FmZWx5RXhlY3V0ZSgoKSA9PiB0aGlzLnVwZGF0ZUV4Y2hhbmdlUmF0ZXMoKSk7XG4gICAgfVxuICAgIGdldCBjaGFpbklkKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IG9ubHkgdXNlZCBmb3Igc2V0dGluZycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbmV3IHRva2VuIGxpc3QgdG8gdHJhY2sgcHJpY2VzXG4gICAgICpcbiAgICAgKiBUT0RPOiBSZXBsYWNlIHRoaXMgd2l0aCBhIG1ldGhvZFxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VucyAtIExpc3Qgb2YgdG9rZW5zIHRvIHRyYWNrIGV4Y2hhbmdlIHJhdGVzIGZvclxuICAgICAqL1xuICAgIHNldCB0b2tlbnModG9rZW5zKSB7XG4gICAgICAgIHRoaXMudG9rZW5MaXN0ID0gdG9rZW5zO1xuICAgICAgICAhdGhpcy5kaXNhYmxlZCAmJiB1dGlsXzEuc2FmZWx5RXhlY3V0ZSgoKSA9PiB0aGlzLnVwZGF0ZUV4Y2hhbmdlUmF0ZXMoKSk7XG4gICAgfVxuICAgIGdldCB0b2tlbnMoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgb25seSB1c2VkIGZvciBzZXR0aW5nJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBwYWlycyBvZiB0b2tlbiBhZGRyZXNzIGFuZCBuYXRpdmUgY3VycmVuY3lcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFpblNsdWcgLSBDaGFpbiBzdHJpbmcgaWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB2c0N1cnJlbmN5IC0gdGhlIHZzQ3VycmVuY3kgdXNlZCB0byBxdWVyeSB0b2tlbiBleGNoYW5nZSByYXRlcyBhZ2FpbnN0LlxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gZXhjaGFuZ2UgcmF0ZXMgZm9yIGdpdmVuIHBhaXJzXG4gICAgICovXG4gICAgZmV0Y2hFeGNoYW5nZVJhdGUoY2hhaW5TbHVnLCB2c0N1cnJlbmN5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlblBhaXJzID0gdGhpcy50b2tlbkxpc3QubWFwKCh0b2tlbikgPT4gdG9rZW4uYWRkcmVzcykuam9pbignLCcpO1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBgY29udHJhY3RfYWRkcmVzc2VzPSR7dG9rZW5QYWlyc30mdnNfY3VycmVuY2llcz0ke3ZzQ3VycmVuY3kudG9Mb3dlckNhc2UoKX1gO1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5oYW5kbGVGZXRjaChDb2luR2Vja29BcGkuZ2V0VG9rZW5QcmljZVVSTChjaGFpblNsdWcsIHF1ZXJ5KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgbmF0aXZlIGN1cnJlbmN5IGlzIGEgc3VwcG9ydGVkIHZzIGN1cnJlbmN5IHRvIHVzZVxuICAgICAqIHRvIHF1ZXJ5IGZvciB0b2tlbiBleGNoYW5nZSByYXRlc1xuICAgICAqXG4gICAgICogQHBhcmFtIG5hdGl2ZUN1cnJlbmN5IC0gdGhlIG5hdGl2ZSBjdXJyZW5jeSBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBuZXR3b3JrXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGl0J3MgYSBzdXBwb3J0ZWQgdnNDdXJyZW5jeVxuICAgICAqL1xuICAgIGNoZWNrSXNTdXBwb3J0ZWRWc0N1cnJlbmN5KG5hdGl2ZUN1cnJlbmN5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHRocmVzaG9sZCB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICBjb25zdCB7IHRpbWVzdGFtcCwgZGF0YSB9ID0gdGhpcy5zdXBwb3J0ZWRWc0N1cnJlbmNpZXM7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgaWYgKG5vdyAtIHRpbWVzdGFtcCA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbmNpZXMgPSB5aWVsZCB1dGlsXzEuaGFuZGxlRmV0Y2goQ29pbkdlY2tvQXBpLmdldFN1cHBvcnRlZFZzQ3VycmVuY2llcygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1cHBvcnRlZFZzQ3VycmVuY2llcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3VycmVuY2llcyxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbmNpZXMuaW5jbHVkZXMobmF0aXZlQ3VycmVuY3kudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5pbmNsdWRlcyhuYXRpdmVDdXJyZW5jeS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgY3VycmVudCBjaGFpbklkIHNsdWcgZnJvbSBjYWNoZWQgc3VwcG9ydGVkIHBsYXRmb3JtcyBDb2luR2Vja28gQVBJIHJlc3BvbnNlLlxuICAgICAqIElmIGNhY2hlZCBzdXBwb3J0ZWQgcGxhdGZvcm1zIHJlc3BvbnNlIGlzIHN0YWxlLCBmZXRjaGVzIGFuZCB1cGRhdGVzIGl0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgY3VycmVudCBjaGFpbklkXG4gICAgICovXG4gICAgZ2V0Q2hhaW5TbHVnKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyB0aHJlc2hvbGQsIGNoYWluSWQgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCB0aW1lc3RhbXAgfSA9IHRoaXMuc3VwcG9ydGVkQ2hhaW5zO1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGlmIChub3cgLSB0aW1lc3RhbXAgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwbGF0Zm9ybXMgPSB5aWVsZCB1dGlsXzEuaGFuZGxlRmV0Y2goQ29pbkdlY2tvQXBpLmdldFBsYXRmb3Jtc1VSTCgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1cHBvcnRlZENoYWlucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogcGxhdGZvcm1zLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluZENoYWluU2x1ZyhjaGFpbklkLCBwbGF0Zm9ybXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbmRDaGFpblNsdWcoY2hhaW5JZCwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGV4Y2hhbmdlIHJhdGVzIGZvciBhbGwgdG9rZW5zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoaXMgb3BlcmF0aW9uIGNvbXBsZXRlc1xuICAgICAqL1xuICAgIHVwZGF0ZUV4Y2hhbmdlUmF0ZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50b2tlbkxpc3QubGVuZ3RoID09PSAwIHx8IHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzbHVnID0geWllbGQgdGhpcy5nZXRDaGFpblNsdWcoKTtcbiAgICAgICAgICAgIGxldCBuZXdDb250cmFjdEV4Y2hhbmdlUmF0ZXMgPSB7fTtcbiAgICAgICAgICAgIGlmICghc2x1Zykge1xuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5MaXN0LmZvckVhY2goKHRva2VuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3ModG9rZW4uYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRyYWN0RXhjaGFuZ2VSYXRlc1thZGRyZXNzXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbmF0aXZlQ3VycmVuY3kgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgICAgICAgIG5ld0NvbnRyYWN0RXhjaGFuZ2VSYXRlcyA9IHlpZWxkIHRoaXMuZmV0Y2hBbmRNYXBFeGNoYW5nZVJhdGVzKG5hdGl2ZUN1cnJlbmN5LCBzbHVnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgY29udHJhY3RFeGNoYW5nZVJhdGVzOiBuZXdDb250cmFjdEV4Y2hhbmdlUmF0ZXMgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGFjdGl2ZSBuZXR3b3JrJ3MgbmF0aXZlIGN1cnJlbmN5IGlzIHN1cHBvcnRlZCBieSB0aGUgY29pbmdlY2tvIEFQSVxuICAgICAqIElmIHN1cHBvcnRlZC4gZmV0Y2hlcyBhbmQgbWFwcyBjb250cmFjdEV4Y2hhbmdlIHJhdGVzIGluIGZvcm1hdCB0byBiZSBjb25zdW1lZCBieSBVSVxuICAgICAqIElmIG5vdCBzdXBwb3J0ZWQgZmV0Y2hlcyBjb250cmFjdEV4Y2hhbmdlIHJhdGVzIGFuZCBtYXBzIGZyb20gZnJvbSB0b2tlbi9mYWxsYmFjay1jdXJyZW5jeSB0byB0b2tlbi9uYXRpdmVDdXJyZW5jeVxuICAgICAqXG4gICAgICogQHBhcmFtIG5hdGl2ZUN1cnJlbmN5IC0gdGhlIG5hdGl2ZSBjdXJyZW5jeSBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBuZXR3b3JrXG4gICAgICogQHBhcmFtIHNsdWcgLSB0aGUgdW5pcXVlIHNsdWcgdXNlZCB0byBpZCB0aGUgY2hhaW4gYnkgdGhlIGNvaW5nZWNrbyBhcGlcbiAgICAgKiBzaG91bGQgYmUgdXNlZCB0byBxdWVyeSB0b2tlbiBleGNoYW5nZSByYXRlc1xuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIGNvbnZlcnNpb24gcmF0ZXMgZm9yIGVhY2ggdG9rZW5cbiAgICAgKiByZWxhdGVkIHRvIHRoZSBuZXR3b3JrJ3MgbmF0aXZlIGN1cnJlbmN5XG4gICAgICovXG4gICAgZmV0Y2hBbmRNYXBFeGNoYW5nZVJhdGVzKG5hdGl2ZUN1cnJlbmN5LCBzbHVnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdEV4Y2hhbmdlUmF0ZXMgPSB7fTtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIG5hdGl2ZSBjdXJyZW5jeSBpcyBzdXBwb3J0ZWQgYXMgYSB2c19jdXJyZW5jeSBieSB0aGUgQVBJXG4gICAgICAgICAgICBjb25zdCBuYXRpdmVDdXJyZW5jeVN1cHBvcnRlZCA9IHlpZWxkIHRoaXMuY2hlY2tJc1N1cHBvcnRlZFZzQ3VycmVuY3kobmF0aXZlQ3VycmVuY3kpO1xuICAgICAgICAgICAgaWYgKG5hdGl2ZUN1cnJlbmN5U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgd2UgY2FuIGRvIGEgc2ltcGxlIGZldGNoIGFnYWluc3QgdGhlIENvaW5HZWNrbyBBUElcbiAgICAgICAgICAgICAgICBjb25zdCBwcmljZXMgPSB5aWVsZCB0aGlzLmZldGNoRXhjaGFuZ2VSYXRlKHNsdWcsIG5hdGl2ZUN1cnJlbmN5KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2VuTGlzdC5mb3JFYWNoKCh0b2tlbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmljZSA9IHByaWNlc1t0b2tlbi5hZGRyZXNzLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgICAgICAgICBjb250cmFjdEV4Y2hhbmdlUmF0ZXNbdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKHRva2VuLmFkZHJlc3MpXSA9IHByaWNlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHByaWNlW25hdGl2ZUN1cnJlbmN5LnRvTG93ZXJDYXNlKCldXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBuYXRpdmUgY3VycmVuY3kgaXMgbm90IHN1cHBvcnRlZCB3ZSBuZWVkIHRvIHVzZSBhIGZhbGxiYWNrIHZzQ3VycmVuY3ksIGdldCB0aGUgZXhjaGFuZ2UgcmF0ZXNcbiAgICAgICAgICAgICAgICAvLyBpbiB0b2tlbi9mYWxsYmFjay1jdXJyZW5jeSBmb3JtYXQgYW5kIGNvbnZlcnQgdGhlbSB0byBleHBlY3RlZCB0b2tlbi9uYXRpdmVDdXJyZW5jeSBmb3JtYXQuXG4gICAgICAgICAgICAgICAgbGV0IHRva2VuRXhjaGFuZ2VSYXRlcztcbiAgICAgICAgICAgICAgICBsZXQgdnNDdXJyZW5jeVRvTmF0aXZlQ3VycmVuY3lDb252ZXJzaW9uUmF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5FeGNoYW5nZVJhdGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBjb252ZXJzaW9uUmF0ZTogdnNDdXJyZW5jeVRvTmF0aXZlQ3VycmVuY3lDb252ZXJzaW9uUmF0ZSB9LFxuICAgICAgICAgICAgICAgICAgICBdID0geWllbGQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mZXRjaEV4Y2hhbmdlUmF0ZShzbHVnLCBjb25zdGFudHNfMS5GQUxMX0JBQ0tfVlNfQ1VSUkVOQ1kpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3J5cHRvX2NvbXBhcmVfMS5mZXRjaEV4Y2hhbmdlUmF0ZShuYXRpdmVDdXJyZW5jeSwgY29uc3RhbnRzXzEuRkFMTF9CQUNLX1ZTX0NVUlJFTkNZLCBmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ21hcmtldCBkb2VzIG5vdCBleGlzdCBmb3IgdGhpcyBjb2luIHBhaXInKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFt0b2tlbkFkZHJlc3MsIGNvbnZlcnNpb25dIG9mIE9iamVjdC5lbnRyaWVzKHRva2VuRXhjaGFuZ2VSYXRlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5Ub1ZzQ3VycmVuY3lDb252ZXJzaW9uUmF0ZSA9IGNvbnZlcnNpb25bY29uc3RhbnRzXzEuRkFMTF9CQUNLX1ZTX0NVUlJFTkNZLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgICAgICAgICBjb250cmFjdEV4Y2hhbmdlUmF0ZXNbdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKHRva2VuQWRkcmVzcyldID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuVG9Wc0N1cnJlbmN5Q29udmVyc2lvblJhdGUgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZzQ3VycmVuY3lUb05hdGl2ZUN1cnJlbmN5Q29udmVyc2lvblJhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0RXhjaGFuZ2VSYXRlcztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ub2tlblJhdGVzQ29udHJvbGxlciA9IFRva2VuUmF0ZXNDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gVG9rZW5SYXRlc0NvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ub2tlblJhdGVzQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UGVyc2lzdGVudFN0YXRlID0gZXhwb3J0cy5nZXRBbm9ueW1pemVkU3RhdGUgPSBleHBvcnRzLkJhc2VDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgaW1tZXJfMSA9IHJlcXVpcmUoXCJpbW1lclwiKTtcbmltbWVyXzEuZW5hYmxlUGF0Y2hlcygpO1xuLyoqXG4gKiBDb250cm9sbGVyIGNsYXNzIHRoYXQgcHJvdmlkZXMgc3RhdGUgbWFuYWdlbWVudCwgc3Vic2NyaXB0aW9ucywgYW5kIHN0YXRlIG1ldGFkYXRhXG4gKi9cbmNsYXNzIEJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgQmFzZUNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLm1lc3NlbmdlciAtIENvbnRyb2xsZXIgbWVzc2FnaW5nIHN5c3RlbVxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1ldGFkYXRhIC0gU3RhdGUgbWV0YWRhdGEsIGRlc2NyaWJpbmcgaG93IHRvIFwiYW5vbnltaXplXCIgdGhlIHN0YXRlLCBhbmQgd2hpY2hcbiAgICAgKiAgIHBhcnRzIHNob3VsZCBiZSBwZXJzaXN0ZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjb250cm9sbGVyLCB1c2VkIGFzIGEgbmFtZXNwYWNlIGZvciBldmVudHMgYW5kIGFjdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdGF0ZSAtIEluaXRpYWwgY29udHJvbGxlciBzdGF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2VuZ2VyLCBtZXRhZGF0YSwgbmFtZSwgc3RhdGUsIH0pIHtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0gPSBtZXNzZW5nZXI7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxTdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtuYW1lfTpnZXRTdGF0ZWAsICgpID0+IHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgY3VycmVudCBjb250cm9sbGVyIHN0YXRlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIEN1cnJlbnQgc3RhdGVcbiAgICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsU3RhdGU7XG4gICAgfVxuICAgIHNldCBzdGF0ZShfKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udHJvbGxlciBzdGF0ZSBjYW5ub3QgYmUgZGlyZWN0bHkgbXV0YXRlZDsgdXNlICd1cGRhdGUnIG1ldGhvZCBpbnN0ZWFkLmApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNvbnRyb2xsZXIgc3RhdGUuIEFjY2VwdHMgYSBjYWxsYmFjayB0aGF0IGlzIHBhc3NlZCBhIGRyYWZ0IGNvcHlcbiAgICAgKiBvZiB0aGUgY29udHJvbGxlciBzdGF0ZS4gSWYgYSB2YWx1ZSBpcyByZXR1cm5lZCwgaXQgaXMgc2V0IGFzIHRoZSBuZXdcbiAgICAgKiBzdGF0ZS4gT3RoZXJ3aXNlLCBhbnkgY2hhbmdlcyBtYWRlIHdpdGhpbiB0aGF0IGNhbGxiYWNrIHRvIHRoZSBkcmFmdCBhcmVcbiAgICAgKiBhcHBsaWVkIHRvIHRoZSBjb250cm9sbGVyIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gQ2FsbGJhY2sgZm9yIHVwZGF0aW5nIHN0YXRlLCBwYXNzZWQgYSBkcmFmdCBzdGF0ZVxuICAgICAqICAgb2JqZWN0LiBSZXR1cm4gYSBuZXcgc3RhdGUgb2JqZWN0IG9yIG11dGF0ZSB0aGUgZHJhZnQgdG8gdXBkYXRlIHN0YXRlLlxuICAgICAqL1xuICAgIHVwZGF0ZShjYWxsYmFjaykge1xuICAgICAgICAvLyBXZSBydW4gaW50byB0czI1ODksIFwiaW5maW5pdGUgdHlwZSBkZXB0aFwiLCBpZiB3ZSBkb24ndCBjYXN0XG4gICAgICAgIC8vIHByb2R1Y2VXaXRoUGF0Y2hlcyBoZXJlLlxuICAgICAgICAvLyBUaGUgZmluYWwsIG9taXR0ZWQgbWVtYmVyIG9mIHRoZSByZXR1cm5lZCB0dXBsZSBhcmUgdGhlIGludmVyc2UgcGF0Y2hlcy5cbiAgICAgICAgY29uc3QgW25leHRTdGF0ZSwgcGF0Y2hlc10gPSBpbW1lcl8xLnByb2R1Y2VXaXRoUGF0Y2hlcyh0aGlzLmludGVybmFsU3RhdGUsIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5wdWJsaXNoKGAke3RoaXMubmFtZX06c3RhdGVDaGFuZ2VgLCBuZXh0U3RhdGUsIHBhdGNoZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyB0aGUgY29udHJvbGxlciBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLiBUaGlzIHNob3VsZCBiZSBleHRlbmRlZFxuICAgICAqIGJ5IGFueSBzdWJjbGFzc2VzIHRvIGNsZWFuIHVwIGFueSBhZGRpdGlvbmFsIGNvbm5lY3Rpb25zIG9yIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIFRoZSBvbmx5IGNsZWFudXAgcGVyZm9ybWVkIGhlcmUgaXMgdG8gcmVtb3ZlIGxpc3RlbmVycy4gV2hpbGUgdGVjaG5pY2FsbHlcbiAgICAgKiB0aGlzIGlzIG5vdCByZXF1aXJlZCB0byBlbnN1cmUgdGhpcyBpbnN0YW5jZSBpcyBnYXJiYWdlIGNvbGxlY3RlZCwgaXQgYXRcbiAgICAgKiBsZWFzdCBlbnN1cmVzIHRoaXMgaW5zdGFuY2Ugd29uJ3QgYmUgcmVzcG9uc2libGUgZm9yIHByZXZlbnRpbmcgdGhlXG4gICAgICogbGlzdGVuZXJzIGZyb20gYmVpbmcgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0uY2xlYXJFdmVudFN1YnNjcmlwdGlvbnMoYCR7dGhpcy5uYW1lfTpzdGF0ZUNoYW5nZWApO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUNvbnRyb2xsZXIgPSBCYXNlQ29udHJvbGxlcjtcbi8qKlxuICogUmV0dXJucyBhbiBhbm9ueW1pemVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb250cm9sbGVyIHN0YXRlLlxuICpcbiAqIEJ5IFwiYW5vbnltaXplZFwiIHdlIG1lYW4gdGhhdCBpdCBzaG91bGQgbm90IGNvbnRhaW4gYW55IGluZm9ybWF0aW9uIHRoYXQgY291bGQgYmUgcGVyc29uYWxseVxuICogaWRlbnRpZmlhYmxlLlxuICpcbiAqIEBwYXJhbSBzdGF0ZSAtIFRoZSBjb250cm9sbGVyIHN0YXRlXG4gKiBAcGFyYW0gbWV0YWRhdGEgLSBUaGUgY29udHJvbGxlciBzdGF0ZSBtZXRhZGF0YSwgd2hpY2ggZGVzY3JpYmVzIGhvdyB0byBkZXJpdmUgdGhlXG4gKiAgIGFub255bWl6ZWQgc3RhdGVcbiAqIEByZXR1cm5zIFRoZSBhbm9ueW1pemVkIGNvbnRyb2xsZXIgc3RhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0QW5vbnltaXplZFN0YXRlKHN0YXRlLCBtZXRhZGF0YSkge1xuICAgIHJldHVybiBkZXJpdmVTdGF0ZUZyb21NZXRhZGF0YShzdGF0ZSwgbWV0YWRhdGEsICdhbm9ueW1vdXMnKTtcbn1cbmV4cG9ydHMuZ2V0QW5vbnltaXplZFN0YXRlID0gZ2V0QW5vbnltaXplZFN0YXRlO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdWJzZXQgb2Ygc3RhdGUgdGhhdCBzaG91bGQgYmUgcGVyc2lzdGVkXG4gKlxuICogQHBhcmFtIHN0YXRlIC0gVGhlIGNvbnRyb2xsZXIgc3RhdGVcbiAqIEBwYXJhbSBtZXRhZGF0YSAtIFRoZSBjb250cm9sbGVyIHN0YXRlIG1ldGFkYXRhLCB3aGljaCBkZXNjcmliZXMgd2hpY2ggcGllY2VzIG9mIHN0YXRlIHNob3VsZCBiZSBwZXJzaXN0ZWRcbiAqIEByZXR1cm5zIFRoZSBzdWJzZXQgb2YgY29udHJvbGxlciBzdGF0ZSB0aGF0IHNob3VsZCBiZSBwZXJzaXN0ZWRcbiAqL1xuZnVuY3Rpb24gZ2V0UGVyc2lzdGVudFN0YXRlKHN0YXRlLCBtZXRhZGF0YSkge1xuICAgIHJldHVybiBkZXJpdmVTdGF0ZUZyb21NZXRhZGF0YShzdGF0ZSwgbWV0YWRhdGEsICdwZXJzaXN0Jyk7XG59XG5leHBvcnRzLmdldFBlcnNpc3RlbnRTdGF0ZSA9IGdldFBlcnNpc3RlbnRTdGF0ZTtcbmZ1bmN0aW9uIGRlcml2ZVN0YXRlRnJvbU1ldGFkYXRhKHN0YXRlLCBtZXRhZGF0YSwgbWV0YWRhdGFQcm9wZXJ0eSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzdGF0ZSkucmVkdWNlKChwZXJzaXN0ZWRTdGF0ZSwga2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5TWV0YWRhdGEgPSBtZXRhZGF0YVtrZXldW21ldGFkYXRhUHJvcGVydHldO1xuICAgICAgICBjb25zdCBzdGF0ZVByb3BlcnR5ID0gc3RhdGVba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eU1ldGFkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBwZXJzaXN0ZWRTdGF0ZVtrZXldID0gcHJvcGVydHlNZXRhZGF0YShzdGF0ZVByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9wZXJ0eU1ldGFkYXRhKSB7XG4gICAgICAgICAgICBwZXJzaXN0ZWRTdGF0ZVtrZXldID0gc3RhdGVQcm9wZXJ0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGVyc2lzdGVkU3RhdGU7XG4gICAgfSwge30pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZUNvbnRyb2xsZXJWMi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc3NldHNDb250cmFjdENvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCB3ZWIzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIndlYjNcIikpO1xuY29uc3QgaHVtYW5fc3RhbmRhcmRfdG9rZW5fYWJpXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImh1bWFuLXN0YW5kYXJkLXRva2VuLWFiaVwiKSk7XG5jb25zdCBodW1hbl9zdGFuZGFyZF9jb2xsZWN0aWJsZV9hYmlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaHVtYW4tc3RhbmRhcmQtY29sbGVjdGlibGUtYWJpXCIpKTtcbmNvbnN0IHNpbmdsZV9jYWxsX2JhbGFuY2VfY2hlY2tlcl9hYmlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwic2luZ2xlLWNhbGwtYmFsYW5jZS1jaGVja2VyLWFiaVwiKSk7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuY29uc3QgRVJDNzIxTUVUQURBVEFfSU5URVJGQUNFX0lEID0gJzB4NWI1ZTEzOWYnO1xuY29uc3QgRVJDNzIxRU5VTUVSQUJMRV9JTlRFUkZBQ0VfSUQgPSAnMHg3ODBlOWQ2Myc7XG5jb25zdCBTSU5HTEVfQ0FMTF9CQUxBTkNFU19BRERSRVNTID0gJzB4YjFmOGU1NWM3ZjY0ZDIwM2MxNDAwYjlkODU1NWQwNTBmOTRhZGYzOSc7XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCBpbnRlcmFjdHMgd2l0aCBjb250cmFjdHMgb24gbWFpbm5ldCB0aHJvdWdoIHdlYjNcbiAqL1xuY2xhc3MgQXNzZXRzQ29udHJhY3RDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEFzc2V0c0NvbnRyYWN0Q29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdBc3NldHNDb250cmFjdENvbnRyb2xsZXInO1xuICAgICAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgICAgICBwcm92aWRlcjogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBRdWVyeSBpZiBhIGNvbnRyYWN0IGltcGxlbWVudHMgYW4gaW50ZXJmYWNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEFzc2V0IGNvbnRyYWN0IGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gaW50ZXJmYWNlSWQgLSBJbnRlcmZhY2UgaWRlbnRpZmllclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gd2hldGhlciB0aGUgY29udHJhY3QgaW1wbGVtZW50cyBgaW50ZXJmYWNlSURgXG4gICAgICovXG4gICAgY29udHJhY3RTdXBwb3J0c0ludGVyZmFjZShhZGRyZXNzLCBpbnRlcmZhY2VJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSB0aGlzLndlYjMuZXRoLmNvbnRyYWN0KGh1bWFuX3N0YW5kYXJkX2NvbGxlY3RpYmxlX2FiaV8xLmRlZmF1bHQpLmF0KGFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb250cmFjdC5zdXBwb3J0c0ludGVyZmFjZShpbnRlcmZhY2VJZCwgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBuZXcgcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIFRPRE86IFJlcGxhY2UgdGhpcyB3dGggYSBtZXRob2RcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwcm92aWRlciAtIFByb3ZpZGVyIHVzZWQgdG8gY3JlYXRlIGEgbmV3IHVuZGVybHlpbmcgV2ViMyBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNldCBwcm92aWRlcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLndlYjMgPSBuZXcgd2ViM18xLmRlZmF1bHQocHJvdmlkZXIpO1xuICAgIH1cbiAgICBnZXQgcHJvdmlkZXIoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgb25seSB1c2VkIGZvciBzZXR0aW5nJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGlmIGNvbnRyYWN0IGltcGxlbWVudHMgRVJDNzIxTWV0YWRhdGEgaW50ZXJmYWNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEVSQzcyMSBhc3NldCBjb250cmFjdCBhZGRyZXNzXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB3aGV0aGVyIHRoZSBjb250cmFjdCBpbXBsZW1lbnRzIEVSQzcyMU1ldGFkYXRhIGludGVyZmFjZVxuICAgICAqL1xuICAgIGNvbnRyYWN0U3VwcG9ydHNNZXRhZGF0YUludGVyZmFjZShhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cmFjdFN1cHBvcnRzSW50ZXJmYWNlKGFkZHJlc3MsIEVSQzcyMU1FVEFEQVRBX0lOVEVSRkFDRV9JRCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBpZiBjb250cmFjdCBpbXBsZW1lbnRzIEVSQzcyMUVudW1lcmFibGUgaW50ZXJmYWNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEVSQzcyMSBhc3NldCBjb250cmFjdCBhZGRyZXNzXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB3aGV0aGVyIHRoZSBjb250cmFjdCBpbXBsZW1lbnRzIEVSQzcyMUVudW1lcmFibGUgaW50ZXJmYWNlXG4gICAgICovXG4gICAgY29udHJhY3RTdXBwb3J0c0VudW1lcmFibGVJbnRlcmZhY2UoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJhY3RTdXBwb3J0c0ludGVyZmFjZShhZGRyZXNzLCBFUkM3MjFFTlVNRVJBQkxFX0lOVEVSRkFDRV9JRCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYmFsYW5jZSBvciBjb3VudCBmb3IgY3VycmVudCBhY2NvdW50IG9uIHNwZWNpZmljIGFzc2V0IGNvbnRyYWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEFzc2V0IGNvbnRyYWN0IGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gc2VsZWN0ZWRBZGRyZXNzIC0gQ3VycmVudCBhY2NvdW50IHB1YmxpYyBhZGRyZXNzXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byBCTiBvYmplY3QgY29udGFpbmluZyBiYWxhbmNlIGZvciBjdXJyZW50IGFjY291bnQgb24gc3BlY2lmaWMgYXNzZXQgY29udHJhY3RcbiAgICAgKi9cbiAgICBnZXRCYWxhbmNlT2YoYWRkcmVzcywgc2VsZWN0ZWRBZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IHRoaXMud2ViMy5ldGguY29udHJhY3QoaHVtYW5fc3RhbmRhcmRfdG9rZW5fYWJpXzEuZGVmYXVsdCkuYXQoYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0LmJhbGFuY2VPZihzZWxlY3RlZEFkZHJlc3MsIChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnVtZXJhdGUgYXNzZXRzIGFzc2lnbmVkIHRvIGFuIG93bmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEVSQzcyMSBhc3NldCBjb250cmFjdCBhZGRyZXNzXG4gICAgICogQHBhcmFtIHNlbGVjdGVkQWRkcmVzcyAtIEN1cnJlbnQgYWNjb3VudCBwdWJsaWMgYWRkcmVzc1xuICAgICAqIEBwYXJhbSBpbmRleCAtIEEgY29sbGVjdGlibGUgY291bnRlciBsZXNzIHRoYW4gYGJhbGFuY2VPZihzZWxlY3RlZEFkZHJlc3MpYFxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdG9rZW4gaWRlbnRpZmllciBmb3IgdGhlICdpbmRleCd0aCBhc3NldCBhc3NpZ25lZCB0byAnc2VsZWN0ZWRBZGRyZXNzJ1xuICAgICAqL1xuICAgIGdldENvbGxlY3RpYmxlVG9rZW5JZChhZGRyZXNzLCBzZWxlY3RlZEFkZHJlc3MsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gdGhpcy53ZWIzLmV0aC5jb250cmFjdChodW1hbl9zdGFuZGFyZF9jb2xsZWN0aWJsZV9hYmlfMS5kZWZhdWx0KS5hdChhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnRyYWN0LnRva2VuT2ZPd25lckJ5SW5kZXgoc2VsZWN0ZWRBZGRyZXNzLCBpbmRleCwgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdC50b051bWJlcigpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgZm9yIHRva2VuVVJJIGZvciBhIGdpdmVuIGFzc2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEVSQzcyMSBhc3NldCBjb250cmFjdCBhZGRyZXNzXG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBFUkM3MjEgYXNzZXQgaWRlbnRpZmllclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlICd0b2tlblVSSSdcbiAgICAgKi9cbiAgICBnZXRDb2xsZWN0aWJsZVRva2VuVVJJKGFkZHJlc3MsIHRva2VuSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1cHBvcnRzTWV0YWRhdGEgPSB5aWVsZCB0aGlzLmNvbnRyYWN0U3VwcG9ydHNNZXRhZGF0YUludGVyZmFjZShhZGRyZXNzKTtcbiAgICAgICAgICAgIGlmICghc3VwcG9ydHNNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gdGhpcy53ZWIzLmV0aC5jb250cmFjdChodW1hbl9zdGFuZGFyZF9jb2xsZWN0aWJsZV9hYmlfMS5kZWZhdWx0KS5hdChhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29udHJhY3QudG9rZW5VUkkodG9rZW5JZCwgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGZvciBuYW1lIGZvciBhIGdpdmVuIEVSQzIwIGFzc2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEVSQzIwIGFzc2V0IGNvbnRyYWN0IGFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSAnZGVjaW1hbHMnXG4gICAgICovXG4gICAgZ2V0VG9rZW5EZWNpbWFscyhhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IHRoaXMud2ViMy5ldGguY29udHJhY3QoaHVtYW5fc3RhbmRhcmRfdG9rZW5fYWJpXzEuZGVmYXVsdCkuYXQoYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0LmRlY2ltYWxzKChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBmb3IgbmFtZSBmb3IgYSBnaXZlbiBhc3NldFxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBFUkM3MjEgb3IgRVJDMjAgYXNzZXQgY29udHJhY3QgYWRkcmVzc1xuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlICduYW1lJ1xuICAgICAqL1xuICAgIGdldEFzc2V0TmFtZShhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IHRoaXMud2ViMy5ldGguY29udHJhY3QoaHVtYW5fc3RhbmRhcmRfY29sbGVjdGlibGVfYWJpXzEuZGVmYXVsdCkuYXQoYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0Lm5hbWUoKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGZvciBzeW1ib2wgZm9yIGEgZ2l2ZW4gYXNzZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gRVJDNzIxIG9yIEVSQzIwIGFzc2V0IGNvbnRyYWN0IGFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSAnc3ltYm9sJ1xuICAgICAqL1xuICAgIGdldEFzc2V0U3ltYm9sKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gdGhpcy53ZWIzLmV0aC5jb250cmFjdChodW1hbl9zdGFuZGFyZF9jb2xsZWN0aWJsZV9hYmlfMS5kZWZhdWx0KS5hdChhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29udHJhY3Quc3ltYm9sKChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBmb3Igb3duZXIgZm9yIGEgZ2l2ZW4gRVJDNzIxIGFzc2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEVSQzcyMSBhc3NldCBjb250cmFjdCBhZGRyZXNzXG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBFUkM3MjEgYXNzZXQgaWRlbnRpZmllclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIG93bmVyIGFkZHJlc3NcbiAgICAgKi9cbiAgICBnZXRPd25lck9mKGFkZHJlc3MsIHRva2VuSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gdGhpcy53ZWIzLmV0aC5jb250cmFjdChodW1hbl9zdGFuZGFyZF9jb2xsZWN0aWJsZV9hYmlfMS5kZWZhdWx0KS5hdChhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29udHJhY3Qub3duZXJPZih0b2tlbklkLCAoZXJyb3IsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250cmFjdCBpbnN0YW5jZSBvZlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgJ3Rva2VuVVJJJ1xuICAgICAqL1xuICAgIGdldEJhbGFuY2VzSW5TaW5nbGVDYWxsKHNlbGVjdGVkQWRkcmVzcywgdG9rZW5zVG9EZXRlY3QpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gdGhpcy53ZWIzLmV0aFxuICAgICAgICAgICAgICAgIC5jb250cmFjdChzaW5nbGVfY2FsbF9iYWxhbmNlX2NoZWNrZXJfYWJpXzEuZGVmYXVsdClcbiAgICAgICAgICAgICAgICAuYXQoU0lOR0xFX0NBTExfQkFMQU5DRVNfQUREUkVTUyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0LmJhbGFuY2VzKFtzZWxlY3RlZEFkZHJlc3NdLCB0b2tlbnNUb0RldGVjdCwgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub25aZXJvQmFsYW5jZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnNUb0RldGVjdC5mb3JFYWNoKCh0b2tlbkFkZHJlc3MsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IHJlc3VsdFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJhbGFuY2UuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uWmVyb0JhbGFuY2VzW3Rva2VuQWRkcmVzc10gPSBiYWxhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobm9uWmVyb0JhbGFuY2VzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkFzc2V0c0NvbnRyYWN0Q29udHJvbGxlciA9IEFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IEFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzc2V0c0NvbnRyYWN0Q29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BY2NvdW50VHJhY2tlckNvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBldGhfcXVlcnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXRoLXF1ZXJ5XCIpKTtcbmNvbnN0IGFzeW5jX211dGV4XzEgPSByZXF1aXJlKFwiYXN5bmMtbXV0ZXhcIik7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCB0cmFja3MgaW5mb3JtYXRpb24gZm9yIGFsbCBhY2NvdW50cyBpbiB0aGUgY3VycmVudCBrZXljaGFpblxuICovXG5jbGFzcyBBY2NvdW50VHJhY2tlckNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlcl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIEFjY291bnRUcmFja2VyIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZSAtIEFsbG93cyBzdWJzY3JpYmluZyB0byBwcmVmZXJlbmNlIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldElkZW50aXRpZXMgLSBHZXRzIHRoZSBpZGVudGl0aWVzIGZyb20gdGhlIFByZWZlcmVuY2VzIHN0b3JlXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IG9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZSwgZ2V0SWRlbnRpdGllcywgfSwgY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5tdXRleCA9IG5ldyBhc3luY19tdXRleF8xLk11dGV4KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ0FjY291bnRUcmFja2VyQ29udHJvbGxlcic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZyZXNoZXMgYWxsIGFjY291bnRzIGluIHRoZSBjdXJyZW50IGtleWNoYWluXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlZnJlc2ggPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN5bmNBY2NvdW50cygpO1xuICAgICAgICAgICAgY29uc3QgeyBhY2NvdW50cyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWRkcmVzcyBpbiBhY2NvdW50cykge1xuICAgICAgICAgICAgICAgIHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlV2l0aFRpbWVvdXQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWxhbmNlID0geWllbGQgdXRpbF8xLnF1ZXJ5KHRoaXMuZXRoUXVlcnksICdnZXRCYWxhbmNlJywgW2FkZHJlc3NdKTtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudHNbYWRkcmVzc10gPSB7IGJhbGFuY2U6IHV0aWxfMS5CTlRvSGV4KGJhbGFuY2UpIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgYWNjb3VudHM6IE9iamVjdC5hc3NpZ24oe30sIGFjY291bnRzKSB9KTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgICAgICBpbnRlcnZhbDogMTAwMDAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXRlID0geyBhY2NvdW50czoge30gfTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuZ2V0SWRlbnRpdGllcyA9IGdldElkZW50aXRpZXM7XG4gICAgICAgIG9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucG9sbCgpO1xuICAgIH1cbiAgICBzeW5jQWNjb3VudHMoKSB7XG4gICAgICAgIGNvbnN0IHsgYWNjb3VudHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IE9iamVjdC5rZXlzKHRoaXMuZ2V0SWRlbnRpdGllcygpKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBPYmplY3Qua2V5cyhhY2NvdW50cyk7XG4gICAgICAgIGNvbnN0IG5ld0FkZHJlc3NlcyA9IGFkZHJlc3Nlcy5maWx0ZXIoKGFkZHJlc3MpID0+IGV4aXN0aW5nLmluZGV4T2YoYWRkcmVzcykgPT09IC0xKTtcbiAgICAgICAgY29uc3Qgb2xkQWRkcmVzc2VzID0gZXhpc3RpbmcuZmlsdGVyKChhZGRyZXNzKSA9PiBhZGRyZXNzZXMuaW5kZXhPZihhZGRyZXNzKSA9PT0gLTEpO1xuICAgICAgICBuZXdBZGRyZXNzZXMuZm9yRWFjaCgoYWRkcmVzcykgPT4ge1xuICAgICAgICAgICAgYWNjb3VudHNbYWRkcmVzc10gPSB7IGJhbGFuY2U6ICcweDAnIH07XG4gICAgICAgIH0pO1xuICAgICAgICBvbGRBZGRyZXNzZXMuZm9yRWFjaCgoYWRkcmVzcykgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIGFjY291bnRzW2FkZHJlc3NdO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBhY2NvdW50czogT2JqZWN0LmFzc2lnbih7fSwgYWNjb3VudHMpIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbmV3IHByb3ZpZGVyXG4gICAgICpcbiAgICAgKiBUT0RPOiBSZXBsYWNlIHRoaXMgd3RoIGEgbWV0aG9kXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvdmlkZXIgLSBQcm92aWRlciB1c2VkIHRvIGNyZWF0ZSBhIG5ldyB1bmRlcmx5aW5nIEV0aFF1ZXJ5IGluc3RhbmNlXG4gICAgICovXG4gICAgc2V0IHByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuZXRoUXVlcnkgPSBuZXcgZXRoX3F1ZXJ5XzEuZGVmYXVsdChwcm92aWRlcik7XG4gICAgfVxuICAgIGdldCBwcm92aWRlcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBvbmx5IHVzZWQgZm9yIHNldHRpbmcnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgbmV3IHBvbGxpbmcgaW50ZXJ2YWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnRlcnZhbCAtIFBvbGxpbmcgaW50ZXJ2YWwgdHJpZ2dlciBhICdyZWZyZXNoJ1xuICAgICAqL1xuICAgIHBvbGwoaW50ZXJ2YWwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VMb2NrID0geWllbGQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgICAgICBpbnRlcnZhbCAmJiB0aGlzLmNvbmZpZ3VyZSh7IGludGVydmFsIH0sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZSAmJiBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2xsKHRoaXMuY29uZmlnLmludGVydmFsKTtcbiAgICAgICAgICAgIH0sIHRoaXMuY29uZmlnLmludGVydmFsKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5BY2NvdW50VHJhY2tlckNvbnRyb2xsZXIgPSBBY2NvdW50VHJhY2tlckNvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBBY2NvdW50VHJhY2tlckNvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BY2NvdW50VHJhY2tlckNvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFwcHJvdmFsQ29udHJvbGxlciA9IHZvaWQgMDtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG5jb25zdCBuYW5vaWRfMSA9IHJlcXVpcmUoXCJuYW5vaWRcIik7XG5jb25zdCBCYXNlQ29udHJvbGxlclYyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJWMlwiKTtcbmNvbnN0IGNvbnRyb2xsZXJOYW1lID0gJ0FwcHJvdmFsQ29udHJvbGxlcic7XG5jb25zdCBzdGF0ZU1ldGFkYXRhID0ge1xuICAgIHBlbmRpbmdBcHByb3ZhbHM6IHsgcGVyc2lzdDogZmFsc2UsIGFub255bW91czogdHJ1ZSB9LFxuICAgIHBlbmRpbmdBcHByb3ZhbENvdW50OiB7IHBlcnNpc3Q6IGZhbHNlLCBhbm9ueW1vdXM6IGZhbHNlIH0sXG59O1xuY29uc3QgZ2V0QWxyZWFkeVBlbmRpbmdNZXNzYWdlID0gKG9yaWdpbiwgdHlwZSkgPT4gYFJlcXVlc3Qgb2YgdHlwZSAnJHt0eXBlfScgYWxyZWFkeSBwZW5kaW5nIGZvciBvcmlnaW4gJHtvcmlnaW59LiBQbGVhc2Ugd2FpdC5gO1xuY29uc3QgZ2V0RGVmYXVsdFN0YXRlID0gKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHBlbmRpbmdBcHByb3ZhbHM6IHt9LFxuICAgICAgICBwZW5kaW5nQXBwcm92YWxDb3VudDogMCxcbiAgICB9O1xufTtcbi8qKlxuICogQ29udHJvbGxlciBmb3IgbWFuYWdpbmcgcmVxdWVzdHMgdGhhdCByZXF1aXJlIHVzZXIgYXBwcm92YWwuXG4gKlxuICogRW5hYmxlcyBsaW1pdGluZyB0aGUgbnVtYmVyIG9mIHBlbmRpbmcgcmVxdWVzdHMgYnkgb3JpZ2luIGFuZCB0eXBlLCBjb3VudGluZ1xuICogcGVuZGluZyByZXF1ZXN0cywgYW5kIG1vcmUuXG4gKlxuICogQWRkaW5nIGEgcmVxdWVzdCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9yIHJlamVjdHMgd2hlbiB0aGUgcmVxdWVzdFxuICogaXMgYXBwcm92ZWQgb3IgZGVuaWVkLCByZXNwZWN0aXZlbHkuXG4gKi9cbmNsYXNzIEFwcHJvdmFsQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyVjJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25zIGJhZ1xuICAgICAqIEBwYXJhbSBvcHRzLnNob3dBcHByb3ZhbFJlcXVlc3QgLSBGdW5jdGlvbiBmb3Igb3BlbmluZyB0aGUgVUkgc3VjaCB0aGF0XG4gICAgICogdGhlIHJlcXVlc3QgY2FuIGJlIGRpc3BsYXllZCB0byB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IG1lc3Nlbmdlciwgc2hvd0FwcHJvdmFsUmVxdWVzdCwgc3RhdGUgPSB7fSwgfSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBuYW1lOiBjb250cm9sbGVyTmFtZSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBzdGF0ZU1ldGFkYXRhLFxuICAgICAgICAgICAgbWVzc2VuZ2VyLFxuICAgICAgICAgICAgc3RhdGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZ2V0RGVmYXVsdFN0YXRlKCkpLCBzdGF0ZSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9hcHByb3ZhbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX29yaWdpbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3Nob3dBcHByb3ZhbFJlcXVlc3QgPSBzaG93QXBwcm92YWxSZXF1ZXN0O1xuICAgICAgICB0aGlzLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGhlbHBlciBmb3IgcmVnaXN0ZXJpbmcgdGhpcyBjb250cm9sbGVyJ3MgbWVzc2FnaW5nIHN5c3RlbVxuICAgICAqIGFjdGlvbnMuXG4gICAgICovXG4gICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcnMoKSB7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06Y2xlYXJSZXF1ZXN0c2AsIHRoaXMuY2xlYXIuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06YWRkUmVxdWVzdGAsIChvcHRzLCBzaG91bGRTaG93UmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNob3VsZFNob3dSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkQW5kU2hvd0FwcHJvdmFsUmVxdWVzdChvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvcHRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06aGFzUmVxdWVzdGAsIHRoaXMuaGFzLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7Y29udHJvbGxlck5hbWV9OmFjY2VwdFJlcXVlc3RgLCB0aGlzLmFjY2VwdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTpyZWplY3RSZXF1ZXN0YCwgdGhpcy5yZWplY3QuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gYXBwcm92YWwgcmVxdWVzdCBwZXIgdGhlIGdpdmVuIGFyZ3VtZW50cywgY2FsbHMgdGhlIHNob3cgYXBwcm92YWxcbiAgICAgKiByZXF1ZXN0IGZ1bmN0aW9uLCBhbmQgcmV0dXJucyB0aGUgYXNzb2NpYXRlZCBhcHByb3ZhbCBwcm9taXNlLlxuICAgICAqXG4gICAgICogVGhlcmUgY2FuIG9ubHkgYmUgb25lIGFwcHJvdmFsIHBlciBvcmlnaW4gYW5kIHR5cGUuIEFuIGVycm9yIGlzIHRocm93biBpZlxuICAgICAqIGF0dGVtcHRpbmcgdG8gYWRkIGFuIGludmFsaWQgb3IgZHVwbGljYXRlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgYmFnLlxuICAgICAqIEBwYXJhbSBvcHRzLmlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LiBBIHJhbmRvbSBpZCB3aWxsIGJlXG4gICAgICogZ2VuZXJhdGVkIGlmIG5vbmUgaXMgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIG9wdHMub3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gb3B0cy50eXBlIC0gVGhlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcHRzLnJlcXVlc3REYXRhIC0gQWRkaXRpb25hbCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVxdWVzdCxcbiAgICAgKiBpZiBhbnkuXG4gICAgICogQHJldHVybnMgVGhlIGFwcHJvdmFsIHByb21pc2UuXG4gICAgICovXG4gICAgYWRkQW5kU2hvd0FwcHJvdmFsUmVxdWVzdChvcHRzKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLl9hZGQob3B0cy5vcmlnaW4sIG9wdHMudHlwZSwgb3B0cy5pZCwgb3B0cy5yZXF1ZXN0RGF0YSk7XG4gICAgICAgIHRoaXMuX3Nob3dBcHByb3ZhbFJlcXVlc3QoKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gYXBwcm92YWwgcmVxdWVzdCBwZXIgdGhlIGdpdmVuIGFyZ3VtZW50cyBhbmQgcmV0dXJucyB0aGUgYXBwcm92YWxcbiAgICAgKiBwcm9taXNlLlxuICAgICAqXG4gICAgICogVGhlcmUgY2FuIG9ubHkgYmUgb25lIGFwcHJvdmFsIHBlciBvcmlnaW4gYW5kIHR5cGUuIEFuIGVycm9yIGlzIHRocm93biBpZlxuICAgICAqIGF0dGVtcHRpbmcgdG8gYWRkIGFuIGludmFsaWQgb3IgZHVwbGljYXRlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgYmFnLlxuICAgICAqIEBwYXJhbSBvcHRzLmlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LiBBIHJhbmRvbSBpZCB3aWxsIGJlXG4gICAgICogZ2VuZXJhdGVkIGlmIG5vbmUgaXMgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIG9wdHMub3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gb3B0cy50eXBlIC0gVGhlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcHRzLnJlcXVlc3REYXRhIC0gQWRkaXRpb25hbCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVxdWVzdCxcbiAgICAgKiBpZiBhbnkuXG4gICAgICogQHJldHVybnMgVGhlIGFwcHJvdmFsIHByb21pc2UuXG4gICAgICovXG4gICAgYWRkKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZChvcHRzLm9yaWdpbiwgb3B0cy50eXBlLCBvcHRzLmlkLCBvcHRzLnJlcXVlc3REYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5mbyBmb3IgdGhlIGFwcHJvdmFsIHJlcXVlc3Qgd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMgVGhlIGFwcHJvdmFsIHJlcXVlc3QgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGlkLlxuICAgICAqL1xuICAgIGdldChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5wZW5kaW5nQXBwcm92YWxzW2lkXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHBlbmRpbmcgYXBwcm92YWxzLCBieSBvcmlnaW4gYW5kL29yIHR5cGUuXG4gICAgICpcbiAgICAgKiBJZiBvbmx5IGBvcmlnaW5gIGlzIHNwZWNpZmllZCwgYWxsIGFwcHJvdmFscyBmb3IgdGhhdCBvcmlnaW4gd2lsbCBiZVxuICAgICAqIGNvdW50ZWQsIHJlZ2FyZGxlc3Mgb2YgdHlwZS5cbiAgICAgKiBJZiBvbmx5IGB0eXBlYCBpcyBzcGVjaWZpZWQsIGFsbCBhcHByb3ZhbHMgZm9yIHRoYXQgdHlwZSB3aWxsIGJlIGNvdW50ZWQsXG4gICAgICogcmVnYXJkbGVzcyBvZiBvcmlnaW4uXG4gICAgICogSWYgYm90aCBgb3JpZ2luYCBhbmQgYHR5cGVgIGFyZSBzcGVjaWZpZWQsIDAgb3IgMSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMub3JpZ2luIC0gQW4gYXBwcm92YWwgb3JpZ2luLlxuICAgICAqIEBwYXJhbSBvcHRzLnR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBhcHByb3ZhbCByZXF1ZXN0IGNvdW50IGZvciB0aGUgZ2l2ZW4gb3JpZ2luIGFuZC9vclxuICAgICAqIHR5cGUuXG4gICAgICovXG4gICAgZ2V0QXBwcm92YWxDb3VudChvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCFvcHRzLm9yaWdpbiAmJiAhb3B0cy50eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSBvcmlnaW4sIHR5cGUsIG9yIGJvdGguJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvcmlnaW4sIHR5cGU6IF90eXBlIH0gPSBvcHRzO1xuICAgICAgICBpZiAob3JpZ2luICYmIF90eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKEJvb2xlYW4oKF9hID0gdGhpcy5fb3JpZ2lucy5nZXQob3JpZ2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhcyhfdHlwZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgICByZXR1cm4gKChfYiA9IHRoaXMuX29yaWdpbnMuZ2V0KG9yaWdpbikpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zaXplKSB8fCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgXCJ0eXBlXCIgd2FzIHNwZWNpZmllZFxuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGFwcHJvdmFsIG9mIE9iamVjdC52YWx1ZXModGhpcy5zdGF0ZS5wZW5kaW5nQXBwcm92YWxzKSkge1xuICAgICAgICAgICAgaWYgKGFwcHJvdmFsLnR5cGUgPT09IF90eXBlKSB7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHRvdGFsIGFwcHJvdmFsIHJlcXVlc3QgY291bnQsIGZvciBhbGwgdHlwZXMgYW5kXG4gICAgICogb3JpZ2lucy5cbiAgICAgKi9cbiAgICBnZXRUb3RhbEFwcHJvdmFsQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnBlbmRpbmdBcHByb3ZhbENvdW50O1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC91bmlmaWVkLXNpZ25hdHVyZXMgKi9cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlcmUncyBhIHBlbmRpbmcgYXBwcm92YWwgcmVxdWVzdCBwZXIgdGhlIGdpdmVuIHBhcmFtZXRlcnMuXG4gICAgICogQXQgbGVhc3Qgb25lIHBhcmFtZXRlciBtdXN0IGJlIHNwZWNpZmllZC4gQW4gZXJyb3Igd2lsbCBiZSB0aHJvd24gaWYgdGhlXG4gICAgICogcGFyYW1ldGVycyBhcmUgaW52YWxpZC5cbiAgICAgKlxuICAgICAqIElmIGBpZGAgaXMgc3BlY2lmaWVkLCBhbGwgb3RoZXIgcGFyYW1ldGVycyB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICogSWYgYGlkYCBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgbWV0aG9kIHdpbGwgY2hlY2sgZm9yIHJlcXVlc3RzIHRoYXQgbWF0Y2hcbiAgICAgKiBhbGwgb2YgdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25zIGJhZy5cbiAgICAgKiBAcGFyYW0gb3B0cy5pZCAtIFRoZSBJRCB0byBjaGVjayBmb3IuXG4gICAgICogQHBhcmFtIG9wdHMub3JpZ2luIC0gVGhlIG9yaWdpbiB0byBjaGVjayBmb3IuXG4gICAgICogQHBhcmFtIG9wdHMudHlwZSAtIFRoZSB0eXBlIHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYSBtYXRjaGluZyBhcHByb3ZhbCBpcyBmb3VuZCwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGhhcyhvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IGlkLCBvcmlnaW4sIHR5cGU6IF90eXBlIH0gPSBvcHRzO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXkgbm90IHNwZWNpZnkgbm9uLXN0cmluZyBpZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcHByb3ZhbHMuaGFzKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3R5cGUgJiYgdHlwZW9mIF90eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXkgbm90IHNwZWNpZnkgbm9uLXN0cmluZyB0eXBlLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWF5IG5vdCBzcGVjaWZ5IG5vbi1zdHJpbmcgb3JpZ2luLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgb3JpZ2luIGFuZCB0eXBlIHBhaXIgaWYgdHlwZSBhbHNvIHNwZWNpZmllZFxuICAgICAgICAgICAgaWYgKF90eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oKF9hID0gdGhpcy5fb3JpZ2lucy5nZXQob3JpZ2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhcyhfdHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbnMuaGFzKG9yaWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90eXBlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFwcHJvdmFsIG9mIE9iamVjdC52YWx1ZXModGhpcy5zdGF0ZS5wZW5kaW5nQXBwcm92YWxzKSkge1xuICAgICAgICAgICAgICAgIGlmIChhcHByb3ZhbC50eXBlID09PSBfdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNwZWNpZnkgYSB2YWxpZCBjb21iaW5hdGlvbiBvZiBpZCwgb3JpZ2luLCBhbmQgdHlwZS4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdGhlIHByb21pc2Ugb2YgdGhlIGFwcHJvdmFsIHdpdGggdGhlIGdpdmVuIGlkLCBhbmQgZGVsZXRlcyB0aGVcbiAgICAgKiBhcHByb3ZhbC4gVGhyb3dzIGFuIGVycm9yIGlmIG5vIHN1Y2ggYXBwcm92YWwgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZXNvbHZlIHRoZSBhcHByb3ZhbCBwcm9taXNlIHdpdGguXG4gICAgICovXG4gICAgYWNjZXB0KGlkLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9kZWxldGVBcHByb3ZhbEFuZEdldENhbGxiYWNrcyhpZCkucmVzb2x2ZSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlamVjdHMgdGhlIHByb21pc2Ugb2YgdGhlIGFwcHJvdmFsIHdpdGggdGhlIGdpdmVuIGlkLCBhbmQgZGVsZXRlcyB0aGVcbiAgICAgKiBhcHByb3ZhbC4gVGhyb3dzIGFuIGVycm9yIGlmIG5vIHN1Y2ggYXBwcm92YWwgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciB0byByZWplY3QgdGhlIGFwcHJvdmFsIHByb21pc2Ugd2l0aC5cbiAgICAgKi9cbiAgICByZWplY3QoaWQsIGVycm9yKSB7XG4gICAgICAgIHRoaXMuX2RlbGV0ZUFwcHJvdmFsQW5kR2V0Q2FsbGJhY2tzKGlkKS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWplY3RzIGFuZCBkZWxldGVzIGFsbCBhcHByb3ZhbCByZXF1ZXN0cy5cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgY29uc3QgcmVqZWN0aW9uRXJyb3IgPSBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMucmVzb3VyY2VVbmF2YWlsYWJsZSgnVGhlIHJlcXVlc3Qgd2FzIHJlamVjdGVkOyBwbGVhc2UgdHJ5IGFnYWluLicpO1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIHRoaXMuX2FwcHJvdmFscy5rZXlzKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0KGlkLCByZWplY3Rpb25FcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3JpZ2lucy5jbGVhcigpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgoKSA9PiBnZXREZWZhdWx0U3RhdGUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGF0aW9uIG9mIGFkZCBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHJlcXVlc3REYXRhIC0gVGhlIHJlcXVlc3QgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMgVGhlIGFwcHJvdmFsIHByb21pc2UuXG4gICAgICovXG4gICAgX2FkZChvcmlnaW4sIHR5cGUsIGlkID0gbmFub2lkXzEubmFub2lkKCksIHJlcXVlc3REYXRhKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVBZGRQYXJhbXMoaWQsIG9yaWdpbiwgdHlwZSwgcmVxdWVzdERhdGEpO1xuICAgICAgICBpZiAoKF9hID0gdGhpcy5fb3JpZ2lucy5nZXQob3JpZ2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhcyh0eXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLnJlc291cmNlVW5hdmFpbGFibGUoZ2V0QWxyZWFkeVBlbmRpbmdNZXNzYWdlKG9yaWdpbiwgdHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBwZW5kaW5nIGFwcHJvdmFsXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hcHByb3ZhbHMuc2V0KGlkLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgICAgICAgIHRoaXMuX2FkZFBlbmRpbmdBcHByb3ZhbE9yaWdpbihvcmlnaW4sIHR5cGUpO1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9TdG9yZShpZCwgb3JpZ2luLCB0eXBlLCByZXF1ZXN0RGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgcGFyYW1ldGVycyB0byB0aGUgYWRkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdERhdGEgLSBUaGUgcmVxdWVzdCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBfdmFsaWRhdGVBZGRQYXJhbXMoaWQsIG9yaWdpbiwgdHlwZSwgcmVxdWVzdERhdGEpIHtcbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIGlmICghaWQgfHwgdHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gJ011c3Qgc3BlY2lmeSBub24tZW1wdHkgc3RyaW5nIGlkLic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fYXBwcm92YWxzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGBBcHByb3ZhbCByZXF1ZXN0IHdpdGggaWQgJyR7aWR9JyBhbHJlYWR5IGV4aXN0cy5gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFvcmlnaW4gfHwgdHlwZW9mIG9yaWdpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdNdXN0IHNwZWNpZnkgbm9uLWVtcHR5IHN0cmluZyBvcmlnaW4uJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdHlwZSB8fCB0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdNdXN0IHNwZWNpZnkgbm9uLWVtcHR5IHN0cmluZyB0eXBlLic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVxdWVzdERhdGEgJiZcbiAgICAgICAgICAgICh0eXBlb2YgcmVxdWVzdERhdGEgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkocmVxdWVzdERhdGEpKSkge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gJ1JlcXVlc3QgZGF0YSBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0IGlmIHNwZWNpZmllZC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbChlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZW50cnkgdG8gX29yaWdpbnMuXG4gICAgICogUGVyZm9ybXMgbm8gdmFsaWRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqL1xuICAgIF9hZGRQZW5kaW5nQXBwcm92YWxPcmlnaW4ob3JpZ2luLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpblNldCA9IHRoaXMuX29yaWdpbnMuZ2V0KG9yaWdpbikgfHwgbmV3IFNldCgpO1xuICAgICAgICBvcmlnaW5TZXQuYWRkKHR5cGUpO1xuICAgICAgICBpZiAoIXRoaXMuX29yaWdpbnMuaGFzKG9yaWdpbikpIHtcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbnMuc2V0KG9yaWdpbiwgb3JpZ2luU2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGVudHJ5IHRvIHRoZSBzdG9yZS5cbiAgICAgKiBQZXJmb3JtcyBubyB2YWxpZGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSByZXF1ZXN0RGF0YSAtIFRoZSByZXF1ZXN0IGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqL1xuICAgIF9hZGRUb1N0b3JlKGlkLCBvcmlnaW4sIHR5cGUsIHJlcXVlc3REYXRhKSB7XG4gICAgICAgIGNvbnN0IGFwcHJvdmFsID0ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHJlcXVlc3REYXRhOiByZXF1ZXN0RGF0YSB8fCBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZSgoZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgLy8gVHlwZWNhc3Q6IHRzKDI1ODkpXG4gICAgICAgICAgICBkcmFmdFN0YXRlLnBlbmRpbmdBcHByb3ZhbHNbaWRdID0gYXBwcm92YWw7XG4gICAgICAgICAgICBkcmFmdFN0YXRlLnBlbmRpbmdBcHByb3ZhbENvdW50ID0gT2JqZWN0LmtleXMoZHJhZnRTdGF0ZS5wZW5kaW5nQXBwcm92YWxzKS5sZW5ndGg7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBhcHByb3ZhbCB3aXRoIHRoZSBnaXZlbiBpZC4gVGhlIGFwcHJvdmFsIHByb21pc2UgbXVzdCBiZVxuICAgICAqIHJlc29sdmVkIG9yIHJlamVjdCBiZWZvcmUgdGhpcyBtZXRob2QgaXMgY2FsbGVkLlxuICAgICAqIERlbGV0aW9uIGlzIGFuIGludGVybmFsIG9wZXJhdGlvbiBiZWNhdXNlIGFwcHJvdmFsIHN0YXRlIGlzIHNvbGVseVxuICAgICAqIG1hbmFnZWQgYnkgdGhpcyBjb250cm9sbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0IHRvIGJlIGRlbGV0ZWQuXG4gICAgICovXG4gICAgX2RlbGV0ZShpZCkge1xuICAgICAgICB0aGlzLl9hcHByb3ZhbHMuZGVsZXRlKGlkKTtcbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgb25seSBjYWxsZWQgYWZ0ZXIgdmVyaWZ5aW5nIHRoYXQgdGhlIGFwcHJvdmFsIHdpdGggdGhlXG4gICAgICAgIC8vIHNwZWNpZmllZCBpZCBleGlzdHMuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGNvbnN0IHsgb3JpZ2luLCB0eXBlIH0gPSB0aGlzLnN0YXRlLnBlbmRpbmdBcHByb3ZhbHNbaWRdO1xuICAgICAgICB0aGlzLl9vcmlnaW5zLmdldChvcmlnaW4pLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzRW1wdHlPcmlnaW4ob3JpZ2luKSkge1xuICAgICAgICAgICAgdGhpcy5fb3JpZ2lucy5kZWxldGUob3JpZ2luKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSgoZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIGRyYWZ0U3RhdGUucGVuZGluZ0FwcHJvdmFsc1tpZF07XG4gICAgICAgICAgICBkcmFmdFN0YXRlLnBlbmRpbmdBcHByb3ZhbENvdW50ID0gT2JqZWN0LmtleXMoZHJhZnRTdGF0ZS5wZW5kaW5nQXBwcm92YWxzKS5sZW5ndGg7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcHByb3ZhbCBjYWxsYmFja3MgZm9yIHRoZSBnaXZlbiBpZCwgZGVsZXRlcyB0aGUgZW50cnksIGFuZCB0aGVuXG4gICAgICogcmV0dXJucyB0aGUgY2FsbGJhY2tzIGZvciBwcm9taXNlIHJlc29sdXRpb24uXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIG5vIGFwcHJvdmFsIGlzIGZvdW5kIGZvciB0aGUgZ2l2ZW4gaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMgVGhlIHByb21pc2UgY2FsbGJhY2tzIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBfZGVsZXRlQXBwcm92YWxBbmRHZXRDYWxsYmFja3MoaWQpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5fYXBwcm92YWxzLmdldChpZCk7XG4gICAgICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFwcHJvdmFsIHJlcXVlc3Qgd2l0aCBpZCAnJHtpZH0nIG5vdCBmb3VuZC5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZWxldGUoaWQpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2tzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGVyZSBhcmUgYW55IGFwcHJvdmFscyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuXG4gICAgICogb3JpZ2luLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgb3JpZ2luIGhhcyBubyBhcHByb3ZhbHMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBfaXNFbXB0eU9yaWdpbihvcmlnaW4pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gISgoX2EgPSB0aGlzLl9vcmlnaW5zLmdldChvcmlnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2l6ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5BcHByb3ZhbENvbnRyb2xsZXIgPSBBcHByb3ZhbENvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBBcHByb3ZhbENvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcHByb3ZhbENvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ3VycmVuY3lSYXRlQ29udHJvbGxlciA9IHZvaWQgMDtcbmNvbnN0IGFzeW5jX211dGV4XzEgPSByZXF1aXJlKFwiYXN5bmMtbXV0ZXhcIik7XG5jb25zdCBCYXNlQ29udHJvbGxlclYyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJWMlwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgY3J5cHRvX2NvbXBhcmVfMSA9IHJlcXVpcmUoXCIuLi9hcGlzL2NyeXB0by1jb21wYXJlXCIpO1xuY29uc3QgbmFtZSA9ICdDdXJyZW5jeVJhdGVDb250cm9sbGVyJztcbmNvbnN0IG1ldGFkYXRhID0ge1xuICAgIGNvbnZlcnNpb25EYXRlOiB7IHBlcnNpc3Q6IHRydWUsIGFub255bW91czogdHJ1ZSB9LFxuICAgIGNvbnZlcnNpb25SYXRlOiB7IHBlcnNpc3Q6IHRydWUsIGFub255bW91czogdHJ1ZSB9LFxuICAgIGN1cnJlbnRDdXJyZW5jeTogeyBwZXJzaXN0OiB0cnVlLCBhbm9ueW1vdXM6IHRydWUgfSxcbiAgICBuYXRpdmVDdXJyZW5jeTogeyBwZXJzaXN0OiB0cnVlLCBhbm9ueW1vdXM6IHRydWUgfSxcbiAgICBwZW5kaW5nQ3VycmVudEN1cnJlbmN5OiB7IHBlcnNpc3Q6IGZhbHNlLCBhbm9ueW1vdXM6IHRydWUgfSxcbiAgICBwZW5kaW5nTmF0aXZlQ3VycmVuY3k6IHsgcGVyc2lzdDogZmFsc2UsIGFub255bW91czogdHJ1ZSB9LFxuICAgIHVzZENvbnZlcnNpb25SYXRlOiB7IHBlcnNpc3Q6IHRydWUsIGFub255bW91czogdHJ1ZSB9LFxufTtcbmNvbnN0IGRlZmF1bHRTdGF0ZSA9IHtcbiAgICBjb252ZXJzaW9uRGF0ZTogMCxcbiAgICBjb252ZXJzaW9uUmF0ZTogMCxcbiAgICBjdXJyZW50Q3VycmVuY3k6ICd1c2QnLFxuICAgIG5hdGl2ZUN1cnJlbmN5OiAnRVRIJyxcbiAgICBwZW5kaW5nQ3VycmVudEN1cnJlbmN5OiBudWxsLFxuICAgIHBlbmRpbmdOYXRpdmVDdXJyZW5jeTogbnVsbCxcbiAgICB1c2RDb252ZXJzaW9uUmF0ZTogbnVsbCxcbn07XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCBwYXNzaXZlbHkgcG9sbHMgb24gYSBzZXQgaW50ZXJ2YWwgZm9yIGFuIGV4Y2hhbmdlIHJhdGUgZnJvbSB0aGUgY3VycmVudCBiYXNlXG4gKiBhc3NldCB0byB0aGUgY3VycmVudCBjdXJyZW5jeVxuICovXG5jbGFzcyBDdXJyZW5jeVJhdGVDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJWMl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgQ3VycmVuY3lSYXRlQ29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBDb25zdHJ1Y3RvciBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaW5jbHVkZVVzZFJhdGUgLSBLZWVwIHRyYWNrIG9mIHRoZSBVU0QgcmF0ZSBpbiBhZGRpdGlvbiB0byB0aGUgY3VycmVudCBjdXJyZW5jeSByYXRlXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaW50ZXJ2YWwgLSBUaGUgcG9sbGluZyBpbnRlcnZhbCwgaW4gbWlsbGlzZWNvbmRzXG4gICAgICogQHBhcmFtIG9wdGlvbnMubWVzc2VuZ2VyIC0gQSByZWZlcmVuY2UgdG8gdGhlIG1lc3NhZ2luZyBzeXN0ZW1cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSBvcHRpb25zLmZldGNoRXhjaGFuZ2VSYXRlIC0gRmV0Y2hlcyB0aGUgZXhjaGFuZ2UgcmF0ZSBmcm9tIGFuIGV4dGVybmFsIEFQSS4gVGhpcyBvcHRpb24gaXMgcHJpbWFyaWx5IG1lYW50IGZvciB1c2UgaW4gdW5pdCB0ZXN0cy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGluY2x1ZGVVc2RSYXRlID0gZmFsc2UsIGludGVydmFsID0gMTgwMDAwLCBtZXNzZW5nZXIsIHN0YXRlLCBmZXRjaEV4Y2hhbmdlUmF0ZSA9IGNyeXB0b19jb21wYXJlXzEuZmV0Y2hFeGNoYW5nZVJhdGUsIH0pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgbWVzc2VuZ2VyLFxuICAgICAgICAgICAgc3RhdGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFN0YXRlKSwgc3RhdGUpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tdXRleCA9IG5ldyBhc3luY19tdXRleF8xLk11dGV4KCk7XG4gICAgICAgIHRoaXMuaW5jbHVkZVVzZFJhdGUgPSBpbmNsdWRlVXNkUmF0ZTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbERlbGF5ID0gaW50ZXJ2YWw7XG4gICAgICAgIHRoaXMuZmV0Y2hFeGNoYW5nZVJhdGUgPSBmZXRjaEV4Y2hhbmdlUmF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgcG9sbGluZyBmb3IgdGhlIGN1cnJlbmN5IHJhdGVcbiAgICAgKi9cbiAgICBzdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuc3RhcnRQb2xsaW5nKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHBvbGxpbmcgZm9yIHRoZSBjdXJyZW5jeSByYXRlXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5zdG9wUG9sbGluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRvIGRpc2NhcmQgdGhpcyBjb250cm9sbGVyLlxuICAgICAqXG4gICAgICogVGhpcyBzdG9wcyBhbnkgYWN0aXZlIHBvbGxpbmcuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBjdXJyZW5jeSB0byB0cmFja1xuICAgICAqXG4gICAgICogQHBhcmFtIGN1cnJlbnRDdXJyZW5jeSAtIElTTyA0MjE3IGN1cnJlbmN5IGNvZGVcbiAgICAgKi9cbiAgICBzZXRDdXJyZW50Q3VycmVuY3koY3VycmVudEN1cnJlbmN5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5wZW5kaW5nQ3VycmVudEN1cnJlbmN5ID0gY3VycmVudEN1cnJlbmN5O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnVwZGF0ZUV4Y2hhbmdlUmF0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG5ldyBuYXRpdmUgY3VycmVuY3lcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzeW1ib2wgLSBTeW1ib2wgZm9yIHRoZSBiYXNlIGFzc2V0XG4gICAgICovXG4gICAgc2V0TmF0aXZlQ3VycmVuY3koc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5wZW5kaW5nTmF0aXZlQ3VycmVuY3kgPSBzeW1ib2w7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMudXBkYXRlRXhjaGFuZ2VSYXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdG9wUG9sbGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhIG5ldyBwb2xsaW5nIGludGVydmFsXG4gICAgICovXG4gICAgc3RhcnRQb2xsaW5nKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wUG9sbGluZygpO1xuICAgICAgICAgICAgLy8gVE9ETzogRXhwb3NlIHBvbGxpbmcgY3VycmVuY3kgcmF0ZSB1cGRhdGUgZXJyb3JzXG4gICAgICAgICAgICB5aWVsZCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSgoKSA9PiB0aGlzLnVwZGF0ZUV4Y2hhbmdlUmF0ZSgpKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSgoKSA9PiB0aGlzLnVwZGF0ZUV4Y2hhbmdlUmF0ZSgpKTtcbiAgICAgICAgICAgIH0pLCB0aGlzLmludGVydmFsRGVsYXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBleGNoYW5nZSByYXRlIGZvciB0aGUgY3VycmVudCBjdXJyZW5jeVxuICAgICAqL1xuICAgIHVwZGF0ZUV4Y2hhbmdlUmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VMb2NrID0geWllbGQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgICAgICBjb25zdCB7IGN1cnJlbnRDdXJyZW5jeTogc3RhdGVDdXJyZW50Q3VycmVuY3ksIG5hdGl2ZUN1cnJlbmN5OiBzdGF0ZU5hdGl2ZUN1cnJlbmN5LCBwZW5kaW5nQ3VycmVudEN1cnJlbmN5LCBwZW5kaW5nTmF0aXZlQ3VycmVuY3ksIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgY29udmVyc2lvbkRhdGUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICAgICAgICAgIGxldCBjb252ZXJzaW9uUmF0ZSA9IG51bGw7XG4gICAgICAgICAgICBsZXQgdXNkQ29udmVyc2lvblJhdGUgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEN1cnJlbmN5ID0gcGVuZGluZ0N1cnJlbnRDdXJyZW5jeSAhPT0gbnVsbCAmJiBwZW5kaW5nQ3VycmVudEN1cnJlbmN5ICE9PSB2b2lkIDAgPyBwZW5kaW5nQ3VycmVudEN1cnJlbmN5IDogc3RhdGVDdXJyZW50Q3VycmVuY3k7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVDdXJyZW5jeSA9IHBlbmRpbmdOYXRpdmVDdXJyZW5jeSAhPT0gbnVsbCAmJiBwZW5kaW5nTmF0aXZlQ3VycmVuY3kgIT09IHZvaWQgMCA/IHBlbmRpbmdOYXRpdmVDdXJyZW5jeSA6IHN0YXRlTmF0aXZlQ3VycmVuY3k7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q3VycmVuY3kgJiZcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlQ3VycmVuY3kgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgZWl0aGVyIGN1cnJlbmN5IGlzIGFuIGVtcHR5IHN0cmluZyB3ZSBjYW4gc2tpcCB0aGUgY29tcGFyaXNvblxuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGl0IHdpbGwgcmVzdWx0IGluIGFuIGVycm9yIGZyb20gdGhlIGFwaSBhbmQgdWx0aW1hdGVseVxuICAgICAgICAgICAgICAgICAgICAvLyBhIG51bGwgY29udmVyc2lvblJhdGUgZWl0aGVyIHdheS5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEN1cnJlbmN5ICE9PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICBuYXRpdmVDdXJyZW5jeSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgKHsgY29udmVyc2lvblJhdGUsIHVzZENvbnZlcnNpb25SYXRlIH0gPSB5aWVsZCB0aGlzLmZldGNoRXhjaGFuZ2VSYXRlKGN1cnJlbnRDdXJyZW5jeSwgbmF0aXZlQ3VycmVuY3ksIHRoaXMuaW5jbHVkZVVzZFJhdGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ21hcmtldCBkb2VzIG5vdCBleGlzdCBmb3IgdGhpcyBjb2luIHBhaXInKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnNpb25EYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnNpb25SYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGN1cnJlbnRseSBhbGxvdyBhbmQgaGFuZGxlIGFuIGVtcHR5IHN0cmluZyBhcyBhIHZhbGlkIG5hdGl2ZUN1cnJlbmN5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gY2FzZXMgd2hlcmUgYSB1c2VyIGhhcyBub3QgZW50ZXJlZCBhIG5hdGl2ZSB0aWNrZXIgc3ltYm9sIGZvciBhIGN1c3RvbSBuZXR3b3JrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudEN1cnJlbmN5IGlzIG5vdCBmcm9tIHVzZXIgaW5wdXQgYnV0IHRoaXMgcHJvdGVjdHMgdXMgZnJvbSB1bmV4cGVjdGVkIGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlQ3VycmVuY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEN1cnJlbmN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdDdXJyZW50Q3VycmVuY3k6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ05hdGl2ZUN1cnJlbmN5OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZENvbnZlcnNpb25SYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICByZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIgPSBDdXJyZW5jeVJhdGVDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ3VycmVuY3lSYXRlQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lc3NhZ2VNYW5hZ2VyID0gdm9pZCAwO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IEFic3RyYWN0TWVzc2FnZU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0TWVzc2FnZU1hbmFnZXJcIik7XG4vKipcbiAqIENvbnRyb2xsZXIgaW4gY2hhcmdlIG9mIG1hbmFnaW5nIC0gc3RvcmluZywgYWRkaW5nLCByZW1vdmluZywgdXBkYXRpbmcgLSBNZXNzYWdlcy5cbiAqL1xuY2xhc3MgTWVzc2FnZU1hbmFnZXIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VNYW5hZ2VyXzEuQWJzdHJhY3RNZXNzYWdlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ01lc3NhZ2VNYW5hZ2VyJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBNZXNzYWdlIHdpdGggYW4gJ3VuYXBwcm92ZWQnIHN0YXR1cyB1c2luZyB0aGUgcGFzc2VkIG1lc3NhZ2VQYXJhbXMuXG4gICAgICogdGhpcy5hZGRNZXNzYWdlIGlzIGNhbGxlZCB0byBhZGQgdGhlIG5ldyBNZXNzYWdlIHRvIHRoaXMubWVzc2FnZXMsIGFuZCB0byBzYXZlIHRoZSB1bmFwcHJvdmVkIE1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBUaGUgcGFyYW1zIGZvciB0aGUgZXRoX3NpZ24gY2FsbCB0byBiZSBtYWRlIGFmdGVyIHRoZSBtZXNzYWdlIGlzIGFwcHJvdmVkXG4gICAgICogQHBhcmFtIHJlcT8gLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3QgcG9zc2libHkgY29udGFpbmluZyB0aGUgb3JpZ2luXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgcmF3IGRhdGEgb2YgdGhlIHNpZ25hdHVyZSByZXF1ZXN0XG4gICAgICovXG4gICAgYWRkVW5hcHByb3ZlZE1lc3NhZ2VBc3luYyhtZXNzYWdlUGFyYW1zLCByZXEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHV0aWxfMS52YWxpZGF0ZVNpZ25NZXNzYWdlRGF0YShtZXNzYWdlUGFyYW1zKTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VJZCA9IHRoaXMuYWRkVW5hcHByb3ZlZE1lc3NhZ2UobWVzc2FnZVBhcmFtcywgcmVxKTtcbiAgICAgICAgICAgIHRoaXMuaHViLm9uY2UoYCR7bWVzc2FnZUlkfTpmaW5pc2hlZGAsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChkYXRhLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZGF0YS5yYXdTaWcpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTWV0YU1hc2sgTWVzc2FnZSBTaWduYXR1cmU6IFVzZXIgZGVuaWVkIG1lc3NhZ2Ugc2lnbmF0dXJlLicpKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGBNZXRhTWFzayBNZXNzYWdlIFNpZ25hdHVyZTogVW5rbm93biBwcm9ibGVtOiAke0pTT04uc3RyaW5naWZ5KG1lc3NhZ2VQYXJhbXMpfWApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgTWVzc2FnZSB3aXRoIGFuICd1bmFwcHJvdmVkJyBzdGF0dXMgdXNpbmcgdGhlIHBhc3NlZCBtZXNzYWdlUGFyYW1zLlxuICAgICAqIHRoaXMuYWRkTWVzc2FnZSBpcyBjYWxsZWQgdG8gYWRkIHRoZSBuZXcgTWVzc2FnZSB0byB0aGlzLm1lc3NhZ2VzLCBhbmQgdG8gc2F2ZSB0aGVcbiAgICAgKiB1bmFwcHJvdmVkIE1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBUaGUgcGFyYW1zIGZvciB0aGUgZXRoX3NpZ24gY2FsbCB0byBiZSBtYWRlIGFmdGVyIHRoZSBtZXNzYWdlXG4gICAgICogaXMgYXBwcm92ZWRcbiAgICAgKiBAcGFyYW0gcmVxPyAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0IG9iamVjdCBwb3NzaWJseSBjb250YWluaW5nIHRoZSBvcmlnaW5cbiAgICAgKiBAcmV0dXJucyAtIFRoZSBpZCBvZiB0aGUgbmV3bHkgY3JlYXRlZCBtZXNzYWdlXG4gICAgICovXG4gICAgYWRkVW5hcHByb3ZlZE1lc3NhZ2UobWVzc2FnZVBhcmFtcywgcmVxKSB7XG4gICAgICAgIGlmIChyZXEpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMub3JpZ2luID0gcmVxLm9yaWdpbjtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlUGFyYW1zLmRhdGEgPSB1dGlsXzEubm9ybWFsaXplTWVzc2FnZURhdGEobWVzc2FnZVBhcmFtcy5kYXRhKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZUlkID0gdXVpZF8xLnYxKCk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VEYXRhID0ge1xuICAgICAgICAgICAgaWQ6IG1lc3NhZ2VJZCxcbiAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMsXG4gICAgICAgICAgICBzdGF0dXM6ICd1bmFwcHJvdmVkJyxcbiAgICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICB0eXBlOiAnZXRoX3NpZ24nLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZE1lc3NhZ2UobWVzc2FnZURhdGEpO1xuICAgICAgICB0aGlzLmh1Yi5lbWl0KGB1bmFwcHJvdmVkTWVzc2FnZWAsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWVzc2FnZVBhcmFtcyksIHsgbWV0YW1hc2tJZDogbWVzc2FnZUlkIH0pKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbWV0YW1hc2tJZCBwcm9wZXJ0eSBmcm9tIHBhc3NlZCBtZXNzYWdlUGFyYW1zIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB3aGljaFxuICAgICAqIHJlc29sdmVzIHRoZSB1cGRhdGVkIG1lc3NhZ2VQYXJhbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlUGFyYW1zIC0gVGhlIG1lc3NhZ2VQYXJhbXMgdG8gbW9kaWZ5XG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgbWVzc2FnZVBhcmFtcyB3aXRoIHRoZSBtZXRhbWFza0lkIHByb3BlcnR5IHJlbW92ZWRcbiAgICAgKi9cbiAgICBwcmVwTWVzc2FnZUZvclNpZ25pbmcobWVzc2FnZVBhcmFtcykge1xuICAgICAgICBkZWxldGUgbWVzc2FnZVBhcmFtcy5tZXRhbWFza0lkO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1lc3NhZ2VQYXJhbXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVzc2FnZU1hbmFnZXIgPSBNZXNzYWdlTWFuYWdlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IE1lc3NhZ2VNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzc2FnZU1hbmFnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVG9rZW5CYWxhbmNlc0NvbnRyb2xsZXIgPSBleHBvcnRzLkJOID0gdm9pZCAwO1xuY29uc3QgZXRoZXJldW1qc191dGlsXzEgPSByZXF1aXJlKFwiZXRoZXJldW1qcy11dGlsXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQk5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV0aGVyZXVtanNfdXRpbF8xLkJOOyB9IH0pO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgcGFzc2l2ZWx5IHBvbGxzIG9uIGEgc2V0IGludGVydmFsIHRva2VuIGJhbGFuY2VzXG4gKiBmb3IgdG9rZW5zIHN0b3JlZCBpbiB0aGUgVG9rZW5zQ29udHJvbGxlclxuICovXG5jbGFzcyBUb2tlbkJhbGFuY2VzQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBUb2tlbkJhbGFuY2VzQ29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vblRva2Vuc1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIGFzc2V0cyBjb250cm9sbGVyIHN0YXRlIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRTZWxlY3RlZEFkZHJlc3MgLSBHZXRzIHRoZSBjdXJyZW50IHNlbGVjdGVkIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRCYWxhbmNlT2YgLSBHZXRzIHRoZSBiYWxhbmNlIG9mIHRoZSBnaXZlbiBhY2NvdW50IGF0IHRoZSBnaXZlbiBjb250cmFjdCBhZGRyZXNzXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IG9uVG9rZW5zU3RhdGVDaGFuZ2UsIGdldFNlbGVjdGVkQWRkcmVzcywgZ2V0QmFsYW5jZU9mLCB9LCBjb25maWcsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdUb2tlbkJhbGFuY2VzQ29udHJvbGxlcic7XG4gICAgICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgICAgICAgIGludGVydmFsOiAxODAwMDAsXG4gICAgICAgICAgICB0b2tlbnM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHsgY29udHJhY3RCYWxhbmNlczoge30gfTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIG9uVG9rZW5zU3RhdGVDaGFuZ2UoKHsgdG9rZW5zIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJlKHsgdG9rZW5zIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCYWxhbmNlcygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nZXRTZWxlY3RlZEFkZHJlc3MgPSBnZXRTZWxlY3RlZEFkZHJlc3M7XG4gICAgICAgIHRoaXMuZ2V0QmFsYW5jZU9mID0gZ2V0QmFsYW5jZU9mO1xuICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgbmV3IHBvbGxpbmcgaW50ZXJ2YWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnRlcnZhbCAtIFBvbGxpbmcgaW50ZXJ2YWwgdXNlZCB0byBmZXRjaCBuZXcgdG9rZW4gYmFsYW5jZXNcbiAgICAgKi9cbiAgICBwb2xsKGludGVydmFsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpbnRlcnZhbCAmJiB0aGlzLmNvbmZpZ3VyZSh7IGludGVydmFsIH0sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZSAmJiBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xuICAgICAgICAgICAgeWllbGQgdXRpbF8xLnNhZmVseUV4ZWN1dGUoKCkgPT4gdGhpcy51cGRhdGVCYWxhbmNlcygpKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2xsKHRoaXMuY29uZmlnLmludGVydmFsKTtcbiAgICAgICAgICAgIH0sIHRoaXMuY29uZmlnLmludGVydmFsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYmFsYW5jZXMgZm9yIGFsbCB0b2tlbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhpcyBvcGVyYXRpb24gY29tcGxldGVzXG4gICAgICovXG4gICAgdXBkYXRlQmFsYW5jZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdG9rZW5zIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRyYWN0QmFsYW5jZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBpbiB0b2tlbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGFkZHJlc3MgfSA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250cmFjdEJhbGFuY2VzW2FkZHJlc3NdID0geWllbGQgdGhpcy5nZXRCYWxhbmNlT2YoYWRkcmVzcywgdGhpcy5nZXRTZWxlY3RlZEFkZHJlc3MoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1tpXS5iYWxhbmNlRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udHJhY3RCYWxhbmNlc1thZGRyZXNzXSA9IG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTigwKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zW2ldLmJhbGFuY2VFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgY29udHJhY3RCYWxhbmNlczogbmV3Q29udHJhY3RCYWxhbmNlcyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ub2tlbkJhbGFuY2VzQ29udHJvbGxlciA9IFRva2VuQmFsYW5jZXNDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gVG9rZW5CYWxhbmNlc0NvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ub2tlbkJhbGFuY2VzQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGVyc29uYWxNZXNzYWdlTWFuYWdlciA9IHZvaWQgMDtcbmNvbnN0IHV1aWRfMSA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBBYnN0cmFjdE1lc3NhZ2VNYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9BYnN0cmFjdE1lc3NhZ2VNYW5hZ2VyXCIpO1xuLyoqXG4gKiBDb250cm9sbGVyIGluIGNoYXJnZSBvZiBtYW5hZ2luZyAtIHN0b3JpbmcsIGFkZGluZywgcmVtb3ZpbmcsIHVwZGF0aW5nIC0gTWVzc2FnZXMuXG4gKi9cbmNsYXNzIFBlcnNvbmFsTWVzc2FnZU1hbmFnZXIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VNYW5hZ2VyXzEuQWJzdHJhY3RNZXNzYWdlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ1BlcnNvbmFsTWVzc2FnZU1hbmFnZXInO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE1lc3NhZ2Ugd2l0aCBhbiAndW5hcHByb3ZlZCcgc3RhdHVzIHVzaW5nIHRoZSBwYXNzZWQgbWVzc2FnZVBhcmFtcy5cbiAgICAgKiB0aGlzLmFkZE1lc3NhZ2UgaXMgY2FsbGVkIHRvIGFkZCB0aGUgbmV3IE1lc3NhZ2UgdG8gdGhpcy5tZXNzYWdlcywgYW5kIHRvIHNhdmUgdGhlIHVuYXBwcm92ZWQgTWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVBhcmFtcyAtIFRoZSBwYXJhbXMgZm9yIHRoZSBwZXJzb25hbF9zaWduIGNhbGwgdG8gYmUgbWFkZSBhZnRlciB0aGUgbWVzc2FnZSBpcyBhcHByb3ZlZFxuICAgICAqIEBwYXJhbSByZXE/IC0gVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0IHBvc3NpYmx5IGNvbnRhaW5pbmcgdGhlIG9yaWdpblxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHJhdyBkYXRhIG9mIHRoZSBzaWduYXR1cmUgcmVxdWVzdFxuICAgICAqL1xuICAgIGFkZFVuYXBwcm92ZWRNZXNzYWdlQXN5bmMobWVzc2FnZVBhcmFtcywgcmVxKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB1dGlsXzEudmFsaWRhdGVTaWduTWVzc2FnZURhdGEobWVzc2FnZVBhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlSWQgPSB0aGlzLmFkZFVuYXBwcm92ZWRNZXNzYWdlKG1lc3NhZ2VQYXJhbXMsIHJlcSk7XG4gICAgICAgICAgICB0aGlzLmh1Yi5vbmNlKGAke21lc3NhZ2VJZH06ZmluaXNoZWRgLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGF0YS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2lnbmVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGRhdGEucmF3U2lnKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVqZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ01ldGFNYXNrIFBlcnNvbmFsIE1lc3NhZ2UgU2lnbmF0dXJlOiBVc2VyIGRlbmllZCBtZXNzYWdlIHNpZ25hdHVyZS4nKSk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihgTWV0YU1hc2sgUGVyc29uYWwgTWVzc2FnZSBTaWduYXR1cmU6IFVua25vd24gcHJvYmxlbTogJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlUGFyYW1zKX1gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE1lc3NhZ2Ugd2l0aCBhbiAndW5hcHByb3ZlZCcgc3RhdHVzIHVzaW5nIHRoZSBwYXNzZWQgbWVzc2FnZVBhcmFtcy5cbiAgICAgKiB0aGlzLmFkZE1lc3NhZ2UgaXMgY2FsbGVkIHRvIGFkZCB0aGUgbmV3IE1lc3NhZ2UgdG8gdGhpcy5tZXNzYWdlcywgYW5kIHRvIHNhdmUgdGhlXG4gICAgICogdW5hcHByb3ZlZCBNZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlUGFyYW1zIC0gVGhlIHBhcmFtcyBmb3IgdGhlIHBlcnNvbmFsX3NpZ24gY2FsbCB0byBiZSBtYWRlIGFmdGVyIHRoZSBtZXNzYWdlXG4gICAgICogaXMgYXBwcm92ZWRcbiAgICAgKiBAcGFyYW0gcmVxPyAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0IG9iamVjdCBwb3NzaWJseSBjb250YWluaW5nIHRoZSBvcmlnaW5cbiAgICAgKiBAcmV0dXJucyAtIFRoZSBpZCBvZiB0aGUgbmV3bHkgY3JlYXRlZCBtZXNzYWdlXG4gICAgICovXG4gICAgYWRkVW5hcHByb3ZlZE1lc3NhZ2UobWVzc2FnZVBhcmFtcywgcmVxKSB7XG4gICAgICAgIGlmIChyZXEpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMub3JpZ2luID0gcmVxLm9yaWdpbjtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlUGFyYW1zLmRhdGEgPSB1dGlsXzEubm9ybWFsaXplTWVzc2FnZURhdGEobWVzc2FnZVBhcmFtcy5kYXRhKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZUlkID0gdXVpZF8xLnYxKCk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VEYXRhID0ge1xuICAgICAgICAgICAgaWQ6IG1lc3NhZ2VJZCxcbiAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMsXG4gICAgICAgICAgICBzdGF0dXM6ICd1bmFwcHJvdmVkJyxcbiAgICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICB0eXBlOiAncGVyc29uYWxfc2lnbicsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkTWVzc2FnZShtZXNzYWdlRGF0YSk7XG4gICAgICAgIHRoaXMuaHViLmVtaXQoYHVuYXBwcm92ZWRNZXNzYWdlYCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtZXNzYWdlUGFyYW1zKSwgeyBtZXRhbWFza0lkOiBtZXNzYWdlSWQgfSkpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZUlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBtZXRhbWFza0lkIHByb3BlcnR5IGZyb20gcGFzc2VkIG1lc3NhZ2VQYXJhbXMgYW5kIHJldHVybnMgYSBwcm9taXNlIHdoaWNoXG4gICAgICogcmVzb2x2ZXMgdGhlIHVwZGF0ZWQgbWVzc2FnZVBhcmFtc1xuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBUaGUgbWVzc2FnZVBhcmFtcyB0byBtb2RpZnlcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBtZXNzYWdlUGFyYW1zIHdpdGggdGhlIG1ldGFtYXNrSWQgcHJvcGVydHkgcmVtb3ZlZFxuICAgICAqL1xuICAgIHByZXBNZXNzYWdlRm9yU2lnbmluZyhtZXNzYWdlUGFyYW1zKSB7XG4gICAgICAgIGRlbGV0ZSBtZXNzYWdlUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWVzc2FnZVBhcmFtcyk7XG4gICAgfVxufVxuZXhwb3J0cy5QZXJzb25hbE1lc3NhZ2VNYW5hZ2VyID0gUGVyc29uYWxNZXNzYWdlTWFuYWdlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IFBlcnNvbmFsTWVzc2FnZU1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QZXJzb25hbE1lc3NhZ2VNYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UeXBlZE1lc3NhZ2VNYW5hZ2VyID0gdm9pZCAwO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IEFic3RyYWN0TWVzc2FnZU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0TWVzc2FnZU1hbmFnZXJcIik7XG4vKipcbiAqIENvbnRyb2xsZXIgaW4gY2hhcmdlIG9mIG1hbmFnaW5nIC0gc3RvcmluZywgYWRkaW5nLCByZW1vdmluZywgdXBkYXRpbmcgLSBUeXBlZE1lc3NhZ2VzLlxuICovXG5jbGFzcyBUeXBlZE1lc3NhZ2VNYW5hZ2VyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlTWFuYWdlcl8xLkFic3RyYWN0TWVzc2FnZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdUeXBlZE1lc3NhZ2VNYW5hZ2VyJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUeXBlZE1lc3NhZ2Ugd2l0aCBhbiAndW5hcHByb3ZlZCcgc3RhdHVzIHVzaW5nIHRoZSBwYXNzZWQgbWVzc2FnZVBhcmFtcy5cbiAgICAgKiB0aGlzLmFkZE1lc3NhZ2UgaXMgY2FsbGVkIHRvIGFkZCB0aGUgbmV3IFR5cGVkTWVzc2FnZSB0byB0aGlzLm1lc3NhZ2VzLCBhbmQgdG8gc2F2ZSB0aGUgdW5hcHByb3ZlZCBUeXBlZE1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBUaGUgcGFyYW1zIGZvciB0aGUgZXRoX3NpZ25UeXBlZERhdGEgY2FsbCB0byBiZSBtYWRlIGFmdGVyIHRoZSBtZXNzYWdlIGlzIGFwcHJvdmVkXG4gICAgICogQHBhcmFtIHZlcnNpb24gLSBDb21wYXRpYmlsaXR5IHZlcnNpb24gRUlQNzEyXG4gICAgICogQHBhcmFtIHJlcT8gLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3QgcG9zc2libHkgY29udGFpbmluZyB0aGUgb3JpZ2luXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgcmF3IGRhdGEgb2YgdGhlIHNpZ25hdHVyZSByZXF1ZXN0XG4gICAgICovXG4gICAgYWRkVW5hcHByb3ZlZE1lc3NhZ2VBc3luYyhtZXNzYWdlUGFyYW1zLCB2ZXJzaW9uLCByZXEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAnVjEnKSB7XG4gICAgICAgICAgICAgICAgdXRpbF8xLnZhbGlkYXRlVHlwZWRTaWduTWVzc2FnZURhdGFWMShtZXNzYWdlUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAnVjMnKSB7XG4gICAgICAgICAgICAgICAgdXRpbF8xLnZhbGlkYXRlVHlwZWRTaWduTWVzc2FnZURhdGFWMyhtZXNzYWdlUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VJZCA9IHRoaXMuYWRkVW5hcHByb3ZlZE1lc3NhZ2UobWVzc2FnZVBhcmFtcywgdmVyc2lvbiwgcmVxKTtcbiAgICAgICAgICAgIHRoaXMuaHViLm9uY2UoYCR7bWVzc2FnZUlkfTpmaW5pc2hlZGAsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChkYXRhLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZGF0YS5yYXdTaWcpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTWV0YU1hc2sgVHlwZWQgTWVzc2FnZSBTaWduYXR1cmU6IFVzZXIgZGVuaWVkIG1lc3NhZ2Ugc2lnbmF0dXJlLicpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXJyb3JlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihgTWV0YU1hc2sgVHlwZWQgTWVzc2FnZSBTaWduYXR1cmU6ICR7ZGF0YS5lcnJvcn1gKSk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihgTWV0YU1hc2sgVHlwZWQgTWVzc2FnZSBTaWduYXR1cmU6IFVua25vd24gcHJvYmxlbTogJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlUGFyYW1zKX1gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFR5cGVkTWVzc2FnZSB3aXRoIGFuICd1bmFwcHJvdmVkJyBzdGF0dXMgdXNpbmcgdGhlIHBhc3NlZCBtZXNzYWdlUGFyYW1zLlxuICAgICAqIHRoaXMuYWRkTWVzc2FnZSBpcyBjYWxsZWQgdG8gYWRkIHRoZSBuZXcgVHlwZWRNZXNzYWdlIHRvIHRoaXMubWVzc2FnZXMsIGFuZCB0byBzYXZlIHRoZVxuICAgICAqIHVuYXBwcm92ZWQgVHlwZWRNZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlUGFyYW1zIC0gVGhlIHBhcmFtcyBmb3IgdGhlICdldGhfc2lnblR5cGVkRGF0YScgY2FsbCB0byBiZSBtYWRlIGFmdGVyIHRoZSBtZXNzYWdlXG4gICAgICogaXMgYXBwcm92ZWRcbiAgICAgKiBAcGFyYW0gdmVyc2lvbiAtIENvbXBhdGliaWxpdHkgdmVyc2lvbiBFSVA3MTJcbiAgICAgKiBAcGFyYW0gcmVxPyAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0IG9iamVjdCBwb3NzaWJseSBjb250YWluaW5nIHRoZSBvcmlnaW5cbiAgICAgKiBAcmV0dXJucyAtIFRoZSBpZCBvZiB0aGUgbmV3bHkgY3JlYXRlZCBUeXBlZE1lc3NhZ2VcbiAgICAgKi9cbiAgICBhZGRVbmFwcHJvdmVkTWVzc2FnZShtZXNzYWdlUGFyYW1zLCB2ZXJzaW9uLCByZXEpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZUlkID0gdXVpZF8xLnYxKCk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VQYXJhbXNNZXRhbWFzayA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWVzc2FnZVBhcmFtcyksIHsgbWV0YW1hc2tJZDogbWVzc2FnZUlkLCB2ZXJzaW9uIH0pO1xuICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgICBtZXNzYWdlUGFyYW1zLm9yaWdpbiA9IHJlcS5vcmlnaW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZURhdGEgPSB7XG4gICAgICAgICAgICBpZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyxcbiAgICAgICAgICAgIHN0YXR1czogJ3VuYXBwcm92ZWQnLFxuICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHR5cGU6ICdldGhfc2lnblR5cGVkRGF0YScsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkTWVzc2FnZShtZXNzYWdlRGF0YSk7XG4gICAgICAgIHRoaXMuaHViLmVtaXQoYHVuYXBwcm92ZWRNZXNzYWdlYCwgbWVzc2FnZVBhcmFtc01ldGFtYXNrKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIFR5cGVkTWVzc2FnZSBzdGF0dXMgdG8gJ2Vycm9yZWQnIHZpYSBhIGNhbGwgdG8gdGhpcy5zZXRNZXNzYWdlU3RhdHVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VJZCAtIFRoZSBpZCBvZiB0aGUgVHlwZWRNZXNzYWdlIHRvIGVycm9yXG4gICAgICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIHRvIGJlIGluY2x1ZGVkIGluIFR5cGVkTWVzc2FnZVxuICAgICAqL1xuICAgIHNldE1lc3NhZ2VTdGF0dXNFcnJvcmVkKG1lc3NhZ2VJZCwgZXJyb3IpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuZ2V0TWVzc2FnZShtZXNzYWdlSWQpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZS5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLnVwZGF0ZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuc2V0TWVzc2FnZVN0YXR1cyhtZXNzYWdlSWQsICdlcnJvcmVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIG1ldGFtYXNrSWQgYW5kIHZlcnNpb24gcHJvcGVydGllcyBmcm9tIHBhc3NlZCBtZXNzYWdlUGFyYW1zIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB3aGljaFxuICAgICAqIHJlc29sdmVzIHRoZSB1cGRhdGVkIG1lc3NhZ2VQYXJhbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlUGFyYW1zIC0gVGhlIG1lc3NhZ2VQYXJhbXMgdG8gbW9kaWZ5XG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgbWVzc2FnZVBhcmFtcyB3aXRoIHRoZSBtZXRhbWFza0lkIGFuZCB2ZXJzaW9uIHByb3BlcnRpZXMgcmVtb3ZlZFxuICAgICAqL1xuICAgIHByZXBNZXNzYWdlRm9yU2lnbmluZyhtZXNzYWdlUGFyYW1zKSB7XG4gICAgICAgIGRlbGV0ZSBtZXNzYWdlUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgICAgIGRlbGV0ZSBtZXNzYWdlUGFyYW1zLnZlcnNpb247XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWVzc2FnZVBhcmFtcyk7XG4gICAgfVxufVxuZXhwb3J0cy5UeXBlZE1lc3NhZ2VNYW5hZ2VyID0gVHlwZWRNZXNzYWdlTWFuYWdlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IFR5cGVkTWVzc2FnZU1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UeXBlZE1lc3NhZ2VNYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbGxlY3RpYmxlc0NvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBhc3luY19tdXRleF8xID0gcmVxdWlyZShcImFzeW5jLW11dGV4XCIpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuY29uc3QgYXNzZXRzVXRpbF8xID0gcmVxdWlyZShcIi4vYXNzZXRzVXRpbFwiKTtcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IHN0b3JlcyBhc3NldHMgYW5kIGV4cG9zZXMgY29udmVuaWVuY2UgbWV0aG9kc1xuICovXG5jbGFzcyBDb2xsZWN0aWJsZXNDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIENvbGxlY3RpYmxlc0NvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIHByZWZlcmVuY2UgY29udHJvbGxlciBzdGF0ZSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25OZXR3b3JrU3RhdGVDaGFuZ2UgLSBBbGxvd3Mgc3Vic2NyaWJpbmcgdG8gbmV0d29yayBjb250cm9sbGVyIHN0YXRlIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRBc3NldE5hbWUgLSBHZXRzIHRoZSBuYW1lIG9mIHRoZSBhc3NldCBhdCB0aGUgZ2l2ZW4gYWRkcmVzc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldEFzc2V0U3ltYm9sIC0gR2V0cyB0aGUgc3ltYm9sIG9mIHRoZSBhc3NldCBhdCB0aGUgZ2l2ZW4gYWRkcmVzc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldENvbGxlY3RpYmxlVG9rZW5VUkkgLSBHZXRzIHRoZSBVUkkgb2YgdGhlIE5GVCBhdCB0aGUgZ2l2ZW4gYWRkcmVzcywgd2l0aCB0aGUgZ2l2ZW4gSURcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlLCBvbk5ldHdvcmtTdGF0ZUNoYW5nZSwgZ2V0QXNzZXROYW1lLCBnZXRBc3NldFN5bWJvbCwgZ2V0Q29sbGVjdGlibGVUb2tlblVSSSwgfSwgY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5tdXRleCA9IG5ldyBhc3luY19tdXRleF8xLk11dGV4KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudEVtaXR0ZXIgaW5zdGFuY2UgdXNlZCB0byBsaXN0ZW4gdG8gc3BlY2lmaWMgRUlQNzQ3IGV2ZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5odWIgPSBuZXcgZXZlbnRzXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ0NvbGxlY3RpYmxlc0NvbnRyb2xsZXInO1xuICAgICAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgICAgICBuZXR3b3JrVHlwZTogY29uc3RhbnRzXzEuTUFJTk5FVCxcbiAgICAgICAgICAgIHNlbGVjdGVkQWRkcmVzczogJycsXG4gICAgICAgICAgICBjaGFpbklkOiAnJyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XG4gICAgICAgICAgICBhbGxDb2xsZWN0aWJsZUNvbnRyYWN0czoge30sXG4gICAgICAgICAgICBhbGxDb2xsZWN0aWJsZXM6IHt9LFxuICAgICAgICAgICAgY29sbGVjdGlibGVDb250cmFjdHM6IFtdLFxuICAgICAgICAgICAgY29sbGVjdGlibGVzOiBbXSxcbiAgICAgICAgICAgIGlnbm9yZWRDb2xsZWN0aWJsZXM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5nZXRBc3NldE5hbWUgPSBnZXRBc3NldE5hbWU7XG4gICAgICAgIHRoaXMuZ2V0QXNzZXRTeW1ib2wgPSBnZXRBc3NldFN5bWJvbDtcbiAgICAgICAgdGhpcy5nZXRDb2xsZWN0aWJsZVRva2VuVVJJID0gZ2V0Q29sbGVjdGlibGVUb2tlblVSSTtcbiAgICAgICAgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlKCh7IHNlbGVjdGVkQWRkcmVzcyB9KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3QgeyBhbGxDb2xsZWN0aWJsZUNvbnRyYWN0cywgYWxsQ29sbGVjdGlibGVzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgeyBjaGFpbklkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJlKHsgc2VsZWN0ZWRBZGRyZXNzIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgIGNvbGxlY3RpYmxlQ29udHJhY3RzOiAoKF9hID0gYWxsQ29sbGVjdGlibGVDb250cmFjdHNbc2VsZWN0ZWRBZGRyZXNzXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2NoYWluSWRdKSB8fCBbXSxcbiAgICAgICAgICAgICAgICBjb2xsZWN0aWJsZXM6ICgoX2IgPSBhbGxDb2xsZWN0aWJsZXNbc2VsZWN0ZWRBZGRyZXNzXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2NoYWluSWRdKSB8fCBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2UoKHsgcHJvdmlkZXIgfSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IHsgYWxsQ29sbGVjdGlibGVDb250cmFjdHMsIGFsbENvbGxlY3RpYmxlcyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0ZWRBZGRyZXNzIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gcHJvdmlkZXI7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IGNoYWluSWQgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlibGVDb250cmFjdHM6ICgoX2EgPSBhbGxDb2xsZWN0aWJsZUNvbnRyYWN0c1tzZWxlY3RlZEFkZHJlc3NdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbY2hhaW5JZF0pIHx8IFtdLFxuICAgICAgICAgICAgICAgIGNvbGxlY3RpYmxlczogKChfYiA9IGFsbENvbGxlY3RpYmxlc1tzZWxlY3RlZEFkZHJlc3NdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbY2hhaW5JZF0pIHx8IFtdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb2xsZWN0aWJsZUFwaShjb250cmFjdEFkZHJlc3MsIHRva2VuSWQpIHtcbiAgICAgICAgcmV0dXJuIGBodHRwczovL2FwaS5vcGVuc2VhLmlvL2FwaS92MS9hc3NldC8ke2NvbnRyYWN0QWRkcmVzc30vJHt0b2tlbklkfWA7XG4gICAgfVxuICAgIGdldENvbGxlY3RpYmxlQ29udHJhY3RJbmZvcm1hdGlvbkFwaShjb250cmFjdEFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIGBodHRwczovL2FwaS5vcGVuc2VhLmlvL2FwaS92MS9hc3NldF9jb250cmFjdC8ke2NvbnRyYWN0QWRkcmVzc31gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGluZGl2aWR1YWwgY29sbGVjdGlibGUgaW5mb3JtYXRpb24gZnJvbSBPcGVuU2VhIGFwaVxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdFxuICAgICAqIEBwYXJhbSB0b2tlbklkIC0gVGhlIGNvbGxlY3RpYmxlIGlkZW50aWZpZXJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjdXJyZW50IGNvbGxlY3RpYmxlIG5hbWUgYW5kIGltYWdlXG4gICAgICovXG4gICAgZ2V0Q29sbGVjdGlibGVJbmZvcm1hdGlvbkZyb21BcGkoY29udHJhY3RBZGRyZXNzLCB0b2tlbklkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlblVSSSA9IHRoaXMuZ2V0Q29sbGVjdGlibGVBcGkoY29udHJhY3RBZGRyZXNzLCB0b2tlbklkKTtcbiAgICAgICAgICAgIGxldCBjb2xsZWN0aWJsZUluZm9ybWF0aW9uO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5vcGVuU2VhQXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlibGVJbmZvcm1hdGlvbiA9IHlpZWxkIHV0aWxfMS5oYW5kbGVGZXRjaCh0b2tlblVSSSwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdYLUFQSS1LRVknOiB0aGlzLm9wZW5TZWFBcGlLZXkgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbGxlY3RpYmxlSW5mb3JtYXRpb24gPSB5aWVsZCB1dGlsXzEuaGFuZGxlRmV0Y2godG9rZW5VUkkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBudW1fc2FsZXMsIGJhY2tncm91bmRfY29sb3IsIGltYWdlX3VybCwgaW1hZ2VfcHJldmlld191cmwsIGltYWdlX3RodW1ibmFpbF91cmwsIGltYWdlX29yaWdpbmFsX3VybCwgYW5pbWF0aW9uX3VybCwgYW5pbWF0aW9uX29yaWdpbmFsX3VybCwgbmFtZSwgZGVzY3JpcHRpb24sIGV4dGVybmFsX2xpbmssIGNyZWF0b3IsIGxhc3Rfc2FsZSwgfSA9IGNvbGxlY3RpYmxlSW5mb3JtYXRpb247XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgY29uc3QgY29sbGVjdGlibGVNZXRhZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIHsgbmFtZSB9LCBjcmVhdG9yICYmIHsgY3JlYXRvciB9LCBkZXNjcmlwdGlvbiAmJiB7IGRlc2NyaXB0aW9uIH0sIGltYWdlX3VybCAmJiB7IGltYWdlOiBpbWFnZV91cmwgfSwgbnVtX3NhbGVzICYmIHsgbnVtYmVyT2ZTYWxlczogbnVtX3NhbGVzIH0sIGJhY2tncm91bmRfY29sb3IgJiYgeyBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRfY29sb3IgfSwgaW1hZ2VfcHJldmlld191cmwgJiYgeyBpbWFnZVByZXZpZXc6IGltYWdlX3ByZXZpZXdfdXJsIH0sIGltYWdlX3RodW1ibmFpbF91cmwgJiYgeyBpbWFnZVRodW1ibmFpbDogaW1hZ2VfdGh1bWJuYWlsX3VybCB9LCBpbWFnZV9vcmlnaW5hbF91cmwgJiYgeyBpbWFnZU9yaWdpbmFsOiBpbWFnZV9vcmlnaW5hbF91cmwgfSwgYW5pbWF0aW9uX3VybCAmJiB7IGFuaW1hdGlvbjogYW5pbWF0aW9uX3VybCB9LCBhbmltYXRpb25fb3JpZ2luYWxfdXJsICYmIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25PcmlnaW5hbDogYW5pbWF0aW9uX29yaWdpbmFsX3VybCxcbiAgICAgICAgICAgIH0sIGV4dGVybmFsX2xpbmsgJiYgeyBleHRlcm5hbExpbms6IGV4dGVybmFsX2xpbmsgfSwgbGFzdF9zYWxlICYmIHsgbGFzdFNhbGU6IGxhc3Rfc2FsZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aWJsZU1ldGFkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBpbmRpdmlkdWFsIGNvbGxlY3RpYmxlIGluZm9ybWF0aW9uIGZyb20gY29udHJhY3RzIHRoYXQgZm9sbG93cyBNZXRhZGF0YSBJbnRlcmZhY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgY29sbGVjdGlibGUgY29udHJhY3RcbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIFRoZSBjb2xsZWN0aWJsZSBpZGVudGlmaWVyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3VycmVudCBjb2xsZWN0aWJsZSBuYW1lIGFuZCBpbWFnZVxuICAgICAqL1xuICAgIGdldENvbGxlY3RpYmxlSW5mb3JtYXRpb25Gcm9tVG9rZW5VUkkoY29udHJhY3RBZGRyZXNzLCB0b2tlbklkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlblVSSSA9IHlpZWxkIHRoaXMuZ2V0Q29sbGVjdGlibGVUb2tlblVSSShjb250cmFjdEFkZHJlc3MsIHRva2VuSWQpO1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0geWllbGQgdXRpbF8xLmhhbmRsZUZldGNoKHRva2VuVVJJKTtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ2ltYWdlJylcbiAgICAgICAgICAgICAgICA/ICdpbWFnZSdcbiAgICAgICAgICAgICAgICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovICdpbWFnZV91cmwnO1xuICAgICAgICAgICAgcmV0dXJuIHsgaW1hZ2U6IG9iamVjdFtpbWFnZV0sIG5hbWU6IG9iamVjdC5uYW1lIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGluZGl2aWR1YWwgY29sbGVjdGlibGUgaW5mb3JtYXRpb24gKG5hbWUsIGltYWdlIHVybCBhbmQgZGVzY3JpcHRpb24pXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0XG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBUaGUgY29sbGVjdGlibGUgaWRlbnRpZmllclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGN1cnJlbnQgY29sbGVjdGlibGUgbmFtZSBhbmQgaW1hZ2VcbiAgICAgKi9cbiAgICBnZXRDb2xsZWN0aWJsZUluZm9ybWF0aW9uKGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IGluZm9ybWF0aW9uO1xuICAgICAgICAgICAgLy8gRmlyc3QgdHJ5IHdpdGggT3BlblNlYVxuICAgICAgICAgICAgaW5mb3JtYXRpb24gPSB5aWVsZCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZ2V0Q29sbGVjdGlibGVJbmZvcm1hdGlvbkZyb21BcGkoY29udHJhY3RBZGRyZXNzLCB0b2tlbklkKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChpbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmZvcm1hdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZW4gZm9sbG93aW5nIEVSQzcyMSBzdGFuZGFyZFxuICAgICAgICAgICAgaW5mb3JtYXRpb24gPSB5aWVsZCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZ2V0Q29sbGVjdGlibGVJbmZvcm1hdGlvbkZyb21Ub2tlblVSSShjb250cmFjdEFkZHJlc3MsIHRva2VuSWQpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmIChpbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmZvcm1hdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGNvbGxlY3RpYmxlIGNvbnRyYWN0IGluZm9ybWF0aW9uIGZyb20gT3BlblNlYSBhcGlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgY29sbGVjdGlibGUgY29udHJhY3RcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjdXJyZW50IGNvbGxlY3RpYmxlIG5hbWUgYW5kIGltYWdlXG4gICAgICovXG4gICAgZ2V0Q29sbGVjdGlibGVDb250cmFjdEluZm9ybWF0aW9uRnJvbUFwaShjb250cmFjdEFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFwaSA9IHRoaXMuZ2V0Q29sbGVjdGlibGVDb250cmFjdEluZm9ybWF0aW9uQXBpKGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgICAgICAgICBsZXQgYXBpQ29sbGVjdGlibGVDb250cmFjdE9iamVjdDtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMub3BlblNlYUFwaUtleSkge1xuICAgICAgICAgICAgICAgIGFwaUNvbGxlY3RpYmxlQ29udHJhY3RPYmplY3QgPSB5aWVsZCB1dGlsXzEuaGFuZGxlRmV0Y2goYXBpLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ1gtQVBJLUtFWSc6IHRoaXMub3BlblNlYUFwaUtleSB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXBpQ29sbGVjdGlibGVDb250cmFjdE9iamVjdCA9IHlpZWxkIHV0aWxfMS5oYW5kbGVGZXRjaChhcGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFwaUNvbGxlY3RpYmxlQ29udHJhY3RPYmplY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGNvbGxlY3RpYmxlIGNvbnRyYWN0IGluZm9ybWF0aW9uIGZyb20gdGhlIGNvbnRyYWN0IGl0c2VsZlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdFxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGN1cnJlbnQgY29sbGVjdGlibGUgbmFtZSBhbmQgaW1hZ2VcbiAgICAgKi9cbiAgICBnZXRDb2xsZWN0aWJsZUNvbnRyYWN0SW5mb3JtYXRpb25Gcm9tQ29udHJhY3QoY29udHJhY3RBZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0geWllbGQgdGhpcy5nZXRBc3NldE5hbWUoY29udHJhY3RBZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IHlpZWxkIHRoaXMuZ2V0QXNzZXRTeW1ib2woY29udHJhY3RBZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBzeW1ib2wsXG4gICAgICAgICAgICAgICAgYWRkcmVzczogY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFzc2V0X2NvbnRyYWN0X3R5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgY3JlYXRlZF9kYXRlOiBudWxsLFxuICAgICAgICAgICAgICAgIHNjaGVtYV9uYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgIHRvdGFsX3N1cHBseTogbnVsbCxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBleHRlcm5hbF9saW5rOiBudWxsLFxuICAgICAgICAgICAgICAgIGltYWdlX3VybDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGNvbGxlY3RpYmxlIGNvbnRyYWN0IGluZm9ybWF0aW9uIGZyb20gT3BlblNlYSBhcGlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgY29sbGVjdGlibGUgY29udHJhY3RcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdCBuYW1lLCBpbWFnZSBhbmQgZGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBnZXRDb2xsZWN0aWJsZUNvbnRyYWN0SW5mb3JtYXRpb24oY29udHJhY3RBZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgaW5mb3JtYXRpb247XG4gICAgICAgICAgICAvLyBGaXJzdCB0cnkgd2l0aCBPcGVuU2VhXG4gICAgICAgICAgICBpbmZvcm1hdGlvbiA9IHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5nZXRDb2xsZWN0aWJsZUNvbnRyYWN0SW5mb3JtYXRpb25Gcm9tQXBpKGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5mb3JtYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGVuIGZvbGxvd2luZyBFUkM3MjEgc3RhbmRhcmRcbiAgICAgICAgICAgIGluZm9ybWF0aW9uID0geWllbGQgdXRpbF8xLnNhZmVseUV4ZWN1dGUoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmdldENvbGxlY3RpYmxlQ29udHJhY3RJbmZvcm1hdGlvbkZyb21Db250cmFjdChjb250cmFjdEFkZHJlc3MpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKGluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZm9ybWF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFzc2V0X2NvbnRyYWN0X3R5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgY3JlYXRlZF9kYXRlOiBudWxsLFxuICAgICAgICAgICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgc2NoZW1hX25hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgc3ltYm9sOiBudWxsLFxuICAgICAgICAgICAgICAgIHRvdGFsX3N1cHBseTogbnVsbCxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBleHRlcm5hbF9saW5rOiBudWxsLFxuICAgICAgICAgICAgICAgIGltYWdlX3VybDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGluZGl2aWR1YWwgY29sbGVjdGlibGUgdG8gdGhlIHN0b3JlZCBjb2xsZWN0aWJsZSBsaXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdFxuICAgICAqIEBwYXJhbSB0b2tlbklkIC0gVGhlIGNvbGxlY3RpYmxlIGlkZW50aWZpZXJcbiAgICAgKiBAcGFyYW0gb3B0cyAtIENvbGxlY3RpYmxlIG9wdGlvbmFsIGluZm9ybWF0aW9uIChuYW1lLCBpbWFnZSBhbmQgZGVzY3JpcHRpb24pXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3VycmVudCBjb2xsZWN0aWJsZSBsaXN0XG4gICAgICovXG4gICAgYWRkSW5kaXZpZHVhbENvbGxlY3RpYmxlKGFkZHJlc3MsIHRva2VuSWQsIGNvbGxlY3RpYmxlTWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VMb2NrID0geWllbGQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGFkZHJlc3MgPSB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhbGxDb2xsZWN0aWJsZXMsIGNvbGxlY3RpYmxlcyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNoYWluSWQsIHNlbGVjdGVkQWRkcmVzcyB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdFbnRyeSA9IGNvbGxlY3RpYmxlcy5maW5kKChjb2xsZWN0aWJsZSkgPT4gY29sbGVjdGlibGUuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlibGUudG9rZW5JZCA9PT0gdG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICBjb2xsZWN0aWJsZU1ldGFkYXRhID1cbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlibGVNZXRhZGF0YSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHlpZWxkIHRoaXMuZ2V0Q29sbGVjdGlibGVJbmZvcm1hdGlvbihhZGRyZXNzLCB0b2tlbklkKSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlmZmVyZW50TWV0YWRhdGEgPSBhc3NldHNVdGlsXzEuY29tcGFyZUNvbGxlY3RpYmxlc01ldGFkYXRhKGNvbGxlY3RpYmxlTWV0YWRhdGEsIGV4aXN0aW5nRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZmVyZW50TWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4VG9SZW1vdmUgPSBjb2xsZWN0aWJsZXMuZmluZEluZGV4KChjb2xsZWN0aWJsZSkgPT4gY29sbGVjdGlibGUuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aWJsZS50b2tlbklkID09PSB0b2tlbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhUb1JlbW92ZSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aWJsZXMuc3BsaWNlKGluZGV4VG9SZW1vdmUsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RpYmxlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFbnRyeSA9IE9iamVjdC5hc3NpZ24oeyBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbklkIH0sIGNvbGxlY3RpYmxlTWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NvbGxlY3RpYmxlcyA9IFsuLi5jb2xsZWN0aWJsZXMsIG5ld0VudHJ5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzQ29sbGVjdGlibGVzID0gYWxsQ29sbGVjdGlibGVzW3NlbGVjdGVkQWRkcmVzc107XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3QWRkcmVzc0NvbGxlY3RpYmxlcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWRkcmVzc0NvbGxlY3RpYmxlcyksIHsgW2NoYWluSWRdOiBuZXdDb2xsZWN0aWJsZXMgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3QWxsQ29sbGVjdGlibGVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhbGxDb2xsZWN0aWJsZXMpLCB7IFtzZWxlY3RlZEFkZHJlc3NdOiBuZXdBZGRyZXNzQ29sbGVjdGlibGVzIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgYWxsQ29sbGVjdGlibGVzOiBuZXdBbGxDb2xsZWN0aWJsZXMsXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3RpYmxlczogbmV3Q29sbGVjdGlibGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdDb2xsZWN0aWJsZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNvbGxlY3RpYmxlIGNvbnRyYWN0IHRvIHRoZSBzdG9yZWQgY29sbGVjdGlibGUgY29udHJhY3RzIGxpc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0XG4gICAgICogQHBhcmFtIGRldGVjdGlvbj8gLSBXaGV0aGVyIHRoZSBjb2xsZWN0aWJsZSBpcyBtYW51YWxseSBhZGRlZCBvciBhdXRvLWRldGVjdGVkXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3VycmVudCBjb2xsZWN0aWJsZSBjb250cmFjdHMgbGlzdFxuICAgICAqL1xuICAgIGFkZENvbGxlY3RpYmxlQ29udHJhY3QoYWRkcmVzcywgZGV0ZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWxlYXNlTG9jayA9IHlpZWxkIHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYWxsQ29sbGVjdGlibGVDb250cmFjdHMsIGNvbGxlY3RpYmxlQ29udHJhY3RzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZCwgc2VsZWN0ZWRBZGRyZXNzIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0VudHJ5ID0gY29sbGVjdGlibGVDb250cmFjdHMuZmluZCgoY29sbGVjdGlibGVDb250cmFjdCkgPT4gY29sbGVjdGlibGVDb250cmFjdC5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RpYmxlQ29udHJhY3RzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb250cmFjdEluZm9ybWF0aW9uID0geWllbGQgdGhpcy5nZXRDb2xsZWN0aWJsZUNvbnRyYWN0SW5mb3JtYXRpb24oYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhc3NldF9jb250cmFjdF90eXBlLCBjcmVhdGVkX2RhdGUsIG5hbWUsIHNjaGVtYV9uYW1lLCBzeW1ib2wsIHRvdGFsX3N1cHBseSwgZGVzY3JpcHRpb24sIGV4dGVybmFsX2xpbmssIGltYWdlX3VybCwgfSA9IGNvbnRyYWN0SW5mb3JtYXRpb247XG4gICAgICAgICAgICAgICAgLy8gSWYgYmVpbmcgYXV0by1kZXRlY3RlZCBvcGVuc2VhIGluZm9ybWF0aW9uIGlzIGV4cGVjdGVkXG4gICAgICAgICAgICAgICAgLy8gT2hlcndpc2UgYXQgbGVhc3QgbmFtZSBhbmQgc3ltYm9sIGZyb20gY29udHJhY3QgaXMgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKChkZXRlY3Rpb24gJiYgIWltYWdlX3VybCkgfHxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udHJhY3RJbmZvcm1hdGlvbikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aWJsZUNvbnRyYWN0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFbnRyeSA9IE9iamVjdC5hc3NpZ24oe30sIHsgYWRkcmVzcyB9LCBkZXNjcmlwdGlvbiAmJiB7IGRlc2NyaXB0aW9uIH0sIG5hbWUgJiYgeyBuYW1lIH0sIGltYWdlX3VybCAmJiB7IGxvZ286IGltYWdlX3VybCB9LCBzeW1ib2wgJiYgeyBzeW1ib2wgfSwgdG90YWxfc3VwcGx5ICE9PSBudWxsICYmIHsgdG90YWxTdXBwbHk6IHRvdGFsX3N1cHBseSB9LCBhc3NldF9jb250cmFjdF90eXBlICYmIHsgYXNzZXRDb250cmFjdFR5cGU6IGFzc2V0X2NvbnRyYWN0X3R5cGUgfSwgY3JlYXRlZF9kYXRlICYmIHsgY3JlYXRlZERhdGU6IGNyZWF0ZWRfZGF0ZSB9LCBzY2hlbWFfbmFtZSAmJiB7IHNjaGVtYU5hbWU6IHNjaGVtYV9uYW1lIH0sIGV4dGVybmFsX2xpbmsgJiYgeyBleHRlcm5hbExpbms6IGV4dGVybmFsX2xpbmsgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q29sbGVjdGlibGVDb250cmFjdHMgPSBbLi4uY29sbGVjdGlibGVDb250cmFjdHMsIG5ld0VudHJ5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzQ29sbGVjdGlibGVDb250cmFjdHMgPSBhbGxDb2xsZWN0aWJsZUNvbnRyYWN0c1tzZWxlY3RlZEFkZHJlc3NdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0FkZHJlc3NDb2xsZWN0aWJsZUNvbnRyYWN0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWRkcmVzc0NvbGxlY3RpYmxlQ29udHJhY3RzKSwgeyBbY2hhaW5JZF06IG5ld0NvbGxlY3RpYmxlQ29udHJhY3RzIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0FsbENvbGxlY3RpYmxlQ29udHJhY3RzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhbGxDb2xsZWN0aWJsZUNvbnRyYWN0cyksIHsgW3NlbGVjdGVkQWRkcmVzc106IG5ld0FkZHJlc3NDb2xsZWN0aWJsZUNvbnRyYWN0cyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGFsbENvbGxlY3RpYmxlQ29udHJhY3RzOiBuZXdBbGxDb2xsZWN0aWJsZUNvbnRyYWN0cyxcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlibGVDb250cmFjdHM6IG5ld0NvbGxlY3RpYmxlQ29udHJhY3RzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdDb2xsZWN0aWJsZUNvbnRyYWN0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGluZGl2aWR1YWwgY29sbGVjdGlibGUgZnJvbSB0aGUgc3RvcmVkIHRva2VuIGxpc3QgYW5kIHNhdmVzIGl0IGluIGlnbm9yZWQgY29sbGVjdGlibGVzIGxpc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0XG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBUb2tlbiBpZGVudGlmaWVyIG9mIHRoZSBjb2xsZWN0aWJsZVxuICAgICAqL1xuICAgIHJlbW92ZUFuZElnbm9yZUluZGl2aWR1YWxDb2xsZWN0aWJsZShhZGRyZXNzLCB0b2tlbklkKSB7XG4gICAgICAgIGFkZHJlc3MgPSB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IHsgYWxsQ29sbGVjdGlibGVzLCBjb2xsZWN0aWJsZXMsIGlnbm9yZWRDb2xsZWN0aWJsZXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5JZCwgc2VsZWN0ZWRBZGRyZXNzIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgY29uc3QgbmV3SWdub3JlZENvbGxlY3RpYmxlcyA9IFsuLi5pZ25vcmVkQ29sbGVjdGlibGVzXTtcbiAgICAgICAgY29uc3QgbmV3Q29sbGVjdGlibGVzID0gY29sbGVjdGlibGVzLmZpbHRlcigoY29sbGVjdGlibGUpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2xsZWN0aWJsZS5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSAmJlxuICAgICAgICAgICAgICAgIGNvbGxlY3RpYmxlLnRva2VuSWQgPT09IHRva2VuSWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbHJlYWR5SWdub3JlZCA9IG5ld0lnbm9yZWRDb2xsZWN0aWJsZXMuZmluZCgoYykgPT4gYy5hZGRyZXNzID09PSBhZGRyZXNzICYmIGMudG9rZW5JZCA9PT0gdG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgIWFscmVhZHlJZ25vcmVkICYmIG5ld0lnbm9yZWRDb2xsZWN0aWJsZXMucHVzaChjb2xsZWN0aWJsZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhZGRyZXNzQ29sbGVjdGlibGVzID0gYWxsQ29sbGVjdGlibGVzW3NlbGVjdGVkQWRkcmVzc107XG4gICAgICAgIGNvbnN0IG5ld0FkZHJlc3NDb2xsZWN0aWJsZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFkZHJlc3NDb2xsZWN0aWJsZXMpLCB7IFtjaGFpbklkXTogbmV3Q29sbGVjdGlibGVzIH0pO1xuICAgICAgICBjb25zdCBuZXdBbGxDb2xsZWN0aWJsZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFsbENvbGxlY3RpYmxlcyksIHsgW3NlbGVjdGVkQWRkcmVzc106IG5ld0FkZHJlc3NDb2xsZWN0aWJsZXMgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgIGFsbENvbGxlY3RpYmxlczogbmV3QWxsQ29sbGVjdGlibGVzLFxuICAgICAgICAgICAgY29sbGVjdGlibGVzOiBuZXdDb2xsZWN0aWJsZXMsXG4gICAgICAgICAgICBpZ25vcmVkQ29sbGVjdGlibGVzOiBuZXdJZ25vcmVkQ29sbGVjdGlibGVzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBpbmRpdmlkdWFsIGNvbGxlY3RpYmxlIGZyb20gdGhlIHN0b3JlZCB0b2tlbiBsaXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdFxuICAgICAqIEBwYXJhbSB0b2tlbklkIC0gVG9rZW4gaWRlbnRpZmllciBvZiB0aGUgY29sbGVjdGlibGVcbiAgICAgKi9cbiAgICByZW1vdmVJbmRpdmlkdWFsQ29sbGVjdGlibGUoYWRkcmVzcywgdG9rZW5JZCkge1xuICAgICAgICBhZGRyZXNzID0gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBjb25zdCB7IGFsbENvbGxlY3RpYmxlcywgY29sbGVjdGlibGVzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IGNoYWluSWQsIHNlbGVjdGVkQWRkcmVzcyB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgIGNvbnN0IG5ld0NvbGxlY3RpYmxlcyA9IGNvbGxlY3RpYmxlcy5maWx0ZXIoKGNvbGxlY3RpYmxlKSA9PiAhKGNvbGxlY3RpYmxlLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpICYmXG4gICAgICAgICAgICBjb2xsZWN0aWJsZS50b2tlbklkID09PSB0b2tlbklkKSk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3NDb2xsZWN0aWJsZXMgPSBhbGxDb2xsZWN0aWJsZXNbc2VsZWN0ZWRBZGRyZXNzXTtcbiAgICAgICAgY29uc3QgbmV3QWRkcmVzc0NvbGxlY3RpYmxlcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWRkcmVzc0NvbGxlY3RpYmxlcyksIHsgW2NoYWluSWRdOiBuZXdDb2xsZWN0aWJsZXMgfSk7XG4gICAgICAgIGNvbnN0IG5ld0FsbENvbGxlY3RpYmxlcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWxsQ29sbGVjdGlibGVzKSwgeyBbc2VsZWN0ZWRBZGRyZXNzXTogbmV3QWRkcmVzc0NvbGxlY3RpYmxlcyB9KTtcbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgYWxsQ29sbGVjdGlibGVzOiBuZXdBbGxDb2xsZWN0aWJsZXMsXG4gICAgICAgICAgICBjb2xsZWN0aWJsZXM6IG5ld0NvbGxlY3RpYmxlcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjb2xsZWN0aWJsZSBjb250cmFjdCB0byB0aGUgc3RvcmVkIGNvbGxlY3RpYmxlIGNvbnRyYWN0cyBsaXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdFxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGN1cnJlbnQgY29sbGVjdGlibGUgY29udHJhY3RzIGxpc3RcbiAgICAgKi9cbiAgICByZW1vdmVDb2xsZWN0aWJsZUNvbnRyYWN0KGFkZHJlc3MpIHtcbiAgICAgICAgYWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgY29uc3QgeyBhbGxDb2xsZWN0aWJsZUNvbnRyYWN0cywgY29sbGVjdGlibGVDb250cmFjdHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5JZCwgc2VsZWN0ZWRBZGRyZXNzIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgY29uc3QgbmV3Q29sbGVjdGlibGVDb250cmFjdHMgPSBjb2xsZWN0aWJsZUNvbnRyYWN0cy5maWx0ZXIoKGNvbGxlY3RpYmxlQ29udHJhY3QpID0+ICEoY29sbGVjdGlibGVDb250cmFjdC5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICBjb25zdCBhZGRyZXNzQ29sbGVjdGlibGVDb250cmFjdHMgPSBhbGxDb2xsZWN0aWJsZUNvbnRyYWN0c1tzZWxlY3RlZEFkZHJlc3NdO1xuICAgICAgICBjb25zdCBuZXdBZGRyZXNzQ29sbGVjdGlibGVDb250cmFjdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFkZHJlc3NDb2xsZWN0aWJsZUNvbnRyYWN0cyksIHsgW2NoYWluSWRdOiBuZXdDb2xsZWN0aWJsZUNvbnRyYWN0cyB9KTtcbiAgICAgICAgY29uc3QgbmV3QWxsQ29sbGVjdGlibGVDb250cmFjdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFsbENvbGxlY3RpYmxlQ29udHJhY3RzKSwgeyBbc2VsZWN0ZWRBZGRyZXNzXTogbmV3QWRkcmVzc0NvbGxlY3RpYmxlQ29udHJhY3RzIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICBhbGxDb2xsZWN0aWJsZUNvbnRyYWN0czogbmV3QWxsQ29sbGVjdGlibGVDb250cmFjdHMsXG4gICAgICAgICAgICBjb2xsZWN0aWJsZUNvbnRyYWN0czogbmV3Q29sbGVjdGlibGVDb250cmFjdHMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3Q29sbGVjdGlibGVDb250cmFjdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYW4gT3BlblNlYSBBUEkga2V5IHRvIHJldHJpZXZlIGNvbGxlY3RpYmxlIGluZm9ybWF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3BlblNlYUFwaUtleSAtIE9wZW5TZWEgQVBJIGtleVxuICAgICAqL1xuICAgIHNldEFwaUtleShvcGVuU2VhQXBpS2V5KSB7XG4gICAgICAgIHRoaXMub3BlblNlYUFwaUtleSA9IG9wZW5TZWFBcGlLZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBjb2xsZWN0aWJsZSBhbmQgcmVzcGVjdGl2ZSBjb2xsZWN0aWJsZSBjb250cmFjdCB0byB0aGUgc3RvcmVkIGNvbGxlY3RpYmxlIGFuZCBjb2xsZWN0aWJsZSBjb250cmFjdHMgbGlzdHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0XG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBUaGUgY29sbGVjdGlibGUgaWRlbnRpZmllclxuICAgICAqIEBwYXJhbSBjb2xsZWN0aWJsZU1ldGFkYXRhIC0gQ29sbGVjdGlibGUgb3B0aW9uYWwgbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gZGV0ZWN0aW9uPyAtIFdoZXRoZXIgdGhlIGNvbGxlY3RpYmxlIGlzIG1hbnVhbGx5IGFkZGVkIG9yIGF1dG9kZXRlY3RlZFxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGN1cnJlbnQgY29sbGVjdGlibGUgbGlzdFxuICAgICAqL1xuICAgIGFkZENvbGxlY3RpYmxlKGFkZHJlc3MsIHRva2VuSWQsIGNvbGxlY3RpYmxlTWV0YWRhdGEsIGRldGVjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgYWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbGxlY3RpYmxlQ29udHJhY3RzID0geWllbGQgdGhpcy5hZGRDb2xsZWN0aWJsZUNvbnRyYWN0KGFkZHJlc3MsIGRldGVjdGlvbik7XG4gICAgICAgICAgICBjb2xsZWN0aWJsZU1ldGFkYXRhID1cbiAgICAgICAgICAgICAgICBjb2xsZWN0aWJsZU1ldGFkYXRhIHx8XG4gICAgICAgICAgICAgICAgICAgICh5aWVsZCB0aGlzLmdldENvbGxlY3RpYmxlSW5mb3JtYXRpb24oYWRkcmVzcywgdG9rZW5JZCkpO1xuICAgICAgICAgICAgLy8gSWYgY29sbGVjdGlibGUgY29udHJhY3Qgd2FzIG5vdCBhZGRlZCwgZG8gbm90IGFkZCBpbmRpdmlkdWFsIGNvbGxlY3RpYmxlXG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0aWJsZUNvbnRyYWN0ID0gbmV3Q29sbGVjdGlibGVDb250cmFjdHMuZmluZCgoY29udHJhY3QpID0+IGNvbnRyYWN0LmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIC8vIElmIGNvbGxlY3RpYmxlIGNvbnRyYWN0IGluZm9ybWF0aW9uLCBhZGQgaW5kaXZpZHVhbCBjb2xsZWN0aWJsZVxuICAgICAgICAgICAgaWYgKGNvbGxlY3RpYmxlQ29udHJhY3QpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmFkZEluZGl2aWR1YWxDb2xsZWN0aWJsZShhZGRyZXNzLCB0b2tlbklkLCBjb2xsZWN0aWJsZU1ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjb2xsZWN0aWJsZSBmcm9tIHRoZSBzdG9yZWQgdG9rZW4gbGlzdFxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgY29sbGVjdGlibGUgY29udHJhY3RcbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIFRva2VuIGlkZW50aWZpZXIgb2YgdGhlIGNvbGxlY3RpYmxlXG4gICAgICovXG4gICAgcmVtb3ZlQ29sbGVjdGlibGUoYWRkcmVzcywgdG9rZW5JZCkge1xuICAgICAgICBhZGRyZXNzID0gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICB0aGlzLnJlbW92ZUluZGl2aWR1YWxDb2xsZWN0aWJsZShhZGRyZXNzLCB0b2tlbklkKTtcbiAgICAgICAgY29uc3QgeyBjb2xsZWN0aWJsZXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ0NvbGxlY3RpYmxlID0gY29sbGVjdGlibGVzLmZpbmQoKGNvbGxlY3RpYmxlKSA9PiBjb2xsZWN0aWJsZS5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmICghcmVtYWluaW5nQ29sbGVjdGlibGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29sbGVjdGlibGVDb250cmFjdChhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY29sbGVjdGlibGUgZnJvbSB0aGUgc3RvcmVkIHRva2VuIGxpc3QgYW5kIHNhdmVzIGl0IGluIGlnbm9yZWQgY29sbGVjdGlibGVzIGxpc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0XG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBUb2tlbiBpZGVudGlmaWVyIG9mIHRoZSBjb2xsZWN0aWJsZVxuICAgICAqL1xuICAgIHJlbW92ZUFuZElnbm9yZUNvbGxlY3RpYmxlKGFkZHJlc3MsIHRva2VuSWQpIHtcbiAgICAgICAgYWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbmRJZ25vcmVJbmRpdmlkdWFsQ29sbGVjdGlibGUoYWRkcmVzcywgdG9rZW5JZCk7XG4gICAgICAgIGNvbnN0IHsgY29sbGVjdGlibGVzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCByZW1haW5pbmdDb2xsZWN0aWJsZSA9IGNvbGxlY3RpYmxlcy5maW5kKChjb2xsZWN0aWJsZSkgPT4gY29sbGVjdGlibGUuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAoIXJlbWFpbmluZ0NvbGxlY3RpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNvbGxlY3RpYmxlQ29udHJhY3QoYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgY29sbGVjdGlibGVzIGZyb20gdGhlIGlnbm9yZWQgbGlzdFxuICAgICAqL1xuICAgIGNsZWFySWdub3JlZENvbGxlY3RpYmxlcygpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBpZ25vcmVkQ29sbGVjdGlibGVzOiBbXSB9KTtcbiAgICB9XG59XG5leHBvcnRzLkNvbGxlY3RpYmxlc0NvbnRyb2xsZXIgPSBDb2xsZWN0aWJsZXNDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ29sbGVjdGlibGVzQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbGxlY3RpYmxlc0NvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR2FzRmVlQ29udHJvbGxlciA9IGV4cG9ydHMuR0FTX0VTVElNQVRFX1RZUEVTID0gZXhwb3J0cy5MRUdBQ1lfR0FTX1BSSUNFU19BUElfVVJMID0gdm9pZCAwO1xuY29uc3QgZXRoX3F1ZXJ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImV0aC1xdWVyeVwiKSk7XG5jb25zdCB1dWlkXzEgPSByZXF1aXJlKFwidXVpZFwiKTtcbmNvbnN0IGV0aGVyZXVtanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKTtcbmNvbnN0IEJhc2VDb250cm9sbGVyVjJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclYyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBnYXNfdXRpbF8xID0gcmVxdWlyZShcIi4vZ2FzLXV0aWxcIik7XG5jb25zdCBHQVNfRkVFX0FQSSA9ICdodHRwczovL21vY2stZ2FzLXNlcnZlci5oZXJva3VhcHAuY29tLyc7XG5leHBvcnRzLkxFR0FDWV9HQVNfUFJJQ0VTX0FQSV9VUkwgPSBgaHR0cHM6Ly9hcGkubWV0YXN3YXAuY29kZWZpLm5ldHdvcmsvZ2FzUHJpY2VzYDtcbi8qKlxuICogSW5kaWNhdGVzIHdoaWNoIHR5cGUgb2YgZ2FzRXN0aW1hdGUgdGhlIGNvbnRyb2xsZXIgaXMgY3VycmVudGx5IHJldHVybmluZy5cbiAqIFRoaXMgaXMgdXNlZnVsIGFzIGEgd2F5IG9mIGFzc2VydGluZyB0aGF0IHRoZSBzaGFwZSBvZiBnYXNFc3RpbWF0ZXMgbWF0Y2hlc1xuICogZXhwZWN0YXRpb25zLiBOT05FIGlzIGEgc3BlY2lhbCBjYXNlIGluZGljYXRpbmcgdGhhdCBubyBwcmV2aW91cyBnYXNFc3RpbWF0ZVxuICogaGFzIGJlZW4gZmV0Y2hlZC5cbiAqL1xuZXhwb3J0cy5HQVNfRVNUSU1BVEVfVFlQRVMgPSB7XG4gICAgRkVFX01BUktFVDogJ2ZlZS1tYXJrZXQnLFxuICAgIExFR0FDWTogJ2xlZ2FjeScsXG4gICAgRVRIX0dBU1BSSUNFOiAnZXRoX2dhc1ByaWNlJyxcbiAgICBOT05FOiAnbm9uZScsXG59O1xuY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgZ2FzRmVlRXN0aW1hdGVzOiB7IHBlcnNpc3Q6IHRydWUsIGFub255bW91czogZmFsc2UgfSxcbiAgICBlc3RpbWF0ZWRHYXNGZWVUaW1lQm91bmRzOiB7IHBlcnNpc3Q6IHRydWUsIGFub255bW91czogZmFsc2UgfSxcbiAgICBnYXNFc3RpbWF0ZVR5cGU6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiBmYWxzZSB9LFxufTtcbmNvbnN0IG5hbWUgPSAnR2FzRmVlQ29udHJvbGxlcic7XG5jb25zdCBkZWZhdWx0U3RhdGUgPSB7XG4gICAgZ2FzRmVlRXN0aW1hdGVzOiB7fSxcbiAgICBlc3RpbWF0ZWRHYXNGZWVUaW1lQm91bmRzOiB7fSxcbiAgICBnYXNFc3RpbWF0ZVR5cGU6IGV4cG9ydHMuR0FTX0VTVElNQVRFX1RZUEVTLk5PTkUsXG59O1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgcmV0cmlldmVzIGdhcyBmZWUgZXN0aW1hdGUgZGF0YSBhbmQgcG9sbHMgZm9yIHVwZGF0ZWQgZGF0YSBvbiBhIHNldCBpbnRlcnZhbFxuICovXG5jbGFzcyBHYXNGZWVDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJWMl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgR2FzRmVlQ29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBpbnRlcnZhbCA9IDE1MDAwLCBtZXNzZW5nZXIsIHN0YXRlLCBmZXRjaEdhc0VzdGltYXRlcyA9IGdhc191dGlsXzEuZmV0Y2hHYXNFc3RpbWF0ZXMsIGZldGNoRXRoR2FzUHJpY2VFc3RpbWF0ZSA9IGdhc191dGlsXzEuZmV0Y2hFdGhHYXNQcmljZUVzdGltYXRlLCBmZXRjaExlZ2FjeUdhc1ByaWNlRXN0aW1hdGVzID0gZ2FzX3V0aWxfMS5mZXRjaExlZ2FjeUdhc1ByaWNlRXN0aW1hdGVzLCBnZXRDdXJyZW50TmV0d29ya0VJUDE1NTlDb21wYXRpYmlsaXR5LCBnZXRDdXJyZW50QWNjb3VudEVJUDE1NTlDb21wYXRpYmlsaXR5LCBnZXRDaGFpbklkLCBnZXRDdXJyZW50TmV0d29ya0xlZ2FjeUdhc0FQSUNvbXBhdGliaWxpdHksIGdldFByb3ZpZGVyLCBvbk5ldHdvcmtTdGF0ZUNoYW5nZSwgbGVnYWN5QVBJRW5kcG9pbnQgPSBleHBvcnRzLkxFR0FDWV9HQVNfUFJJQ0VTX0FQSV9VUkwsIEVJUDE1NTlBUElFbmRwb2ludCA9IEdBU19GRUVfQVBJLCBjbGllbnRJZCwgfSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICBtZXNzZW5nZXIsXG4gICAgICAgICAgICBzdGF0ZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0U3RhdGUpLCBzdGF0ZSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmludGVydmFsRGVsYXkgPSBpbnRlcnZhbDtcbiAgICAgICAgdGhpcy5mZXRjaEdhc0VzdGltYXRlcyA9IGZldGNoR2FzRXN0aW1hdGVzO1xuICAgICAgICB0aGlzLmZldGNoRXRoR2FzUHJpY2VFc3RpbWF0ZSA9IGZldGNoRXRoR2FzUHJpY2VFc3RpbWF0ZTtcbiAgICAgICAgdGhpcy5mZXRjaExlZ2FjeUdhc1ByaWNlRXN0aW1hdGVzID0gZmV0Y2hMZWdhY3lHYXNQcmljZUVzdGltYXRlcztcbiAgICAgICAgdGhpcy5wb2xsVG9rZW5zID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmdldEN1cnJlbnROZXR3b3JrRUlQMTU1OUNvbXBhdGliaWxpdHkgPSBnZXRDdXJyZW50TmV0d29ya0VJUDE1NTlDb21wYXRpYmlsaXR5O1xuICAgICAgICB0aGlzLmdldEN1cnJlbnROZXR3b3JrTGVnYWN5R2FzQVBJQ29tcGF0aWJpbGl0eSA9IGdldEN1cnJlbnROZXR3b3JrTGVnYWN5R2FzQVBJQ29tcGF0aWJpbGl0eTtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50QWNjb3VudEVJUDE1NTlDb21wYXRpYmlsaXR5ID0gZ2V0Q3VycmVudEFjY291bnRFSVAxNTU5Q29tcGF0aWJpbGl0eTtcbiAgICAgICAgdGhpcy5FSVAxNTU5QVBJRW5kcG9pbnQgPSBFSVAxNTU5QVBJRW5kcG9pbnQ7XG4gICAgICAgIHRoaXMubGVnYWN5QVBJRW5kcG9pbnQgPSBsZWdhY3lBUElFbmRwb2ludDtcbiAgICAgICAgdGhpcy5nZXRDaGFpbklkID0gZ2V0Q2hhaW5JZDtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2hhaW5JZCA9IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKCk7XG4gICAgICAgIHRoaXMuZXRoUXVlcnkgPSBuZXcgZXRoX3F1ZXJ5XzEuZGVmYXVsdChwcm92aWRlcik7XG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2UoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbmV3UHJvdmlkZXIgPSBnZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hhaW5JZCA9IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgICAgICAgICAgdGhpcy5ldGhRdWVyeSA9IG5ldyBldGhfcXVlcnlfMS5kZWZhdWx0KG5ld1Byb3ZpZGVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGFpbklkICE9PSBuZXdDaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hhaW5JZCA9IG5ld0NoYWluSWQ7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5yZXNldFBvbGxpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXNldFBvbGxpbmcoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb2xsVG9rZW5zLnNpemUgIT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbnMgPSBBcnJheS5mcm9tKHRoaXMucG9sbFRva2Vucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wUG9sbGluZygpO1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0R2FzRmVlRXN0aW1hdGVzQW5kU3RhcnRQb2xsaW5nKHRva2Vuc1swXSk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnNsaWNlKDEpLmZvckVhY2goKHRva2VuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9sbFRva2Vucy5hZGQodG9rZW4pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmV0Y2hHYXNGZWVFc3RpbWF0ZXMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuX2ZldGNoR2FzRmVlRXN0aW1hdGVEYXRhKG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0R2FzRmVlRXN0aW1hdGVzQW5kU3RhcnRQb2xsaW5nKHBvbGxUb2tlbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgX3BvbGxUb2tlbiA9IHBvbGxUb2tlbiB8fCB1dWlkXzEudjEoKTtcbiAgICAgICAgICAgIHRoaXMucG9sbFRva2Vucy5hZGQoX3BvbGxUb2tlbik7XG4gICAgICAgICAgICBpZiAodGhpcy5wb2xsVG9rZW5zLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLl9mZXRjaEdhc0ZlZUVzdGltYXRlRGF0YSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcG9sbFRva2VuO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbmQgc2V0cyBnYXNGZWVFc3RpbWF0ZXMgaW4gc3RhdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEdhc0ZlZUVzdGltYXRlc1xuICAgICAqL1xuICAgIF9mZXRjaEdhc0ZlZUVzdGltYXRlRGF0YShvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2hvdWxkVXBkYXRlU3RhdGUgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgbGV0IGlzRUlQMTU1OUNvbXBhdGlibGU7XG4gICAgICAgICAgICBjb25zdCBpc0xlZ2FjeUdhc0FQSUNvbXBhdGlibGUgPSB0aGlzLmdldEN1cnJlbnROZXR3b3JrTGVnYWN5R2FzQVBJQ29tcGF0aWJpbGl0eSgpO1xuICAgICAgICAgICAgbGV0IGNoYWluSWQgPSB0aGlzLmdldENoYWluSWQoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhaW5JZCA9PT0gJ3N0cmluZycgJiYgZXRoZXJldW1qc191dGlsXzEuaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gcGFyc2VJbnQoY2hhaW5JZCwgMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpc0VJUDE1NTlDb21wYXRpYmxlID0geWllbGQgdGhpcy5nZXRFSVAxNTU5Q29tcGF0aWJpbGl0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIGlzRUlQMTU1OUNvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBnYXNGZWVFc3RpbWF0ZXM6IHt9LFxuICAgICAgICAgICAgICAgIGVzdGltYXRlZEdhc0ZlZVRpbWVCb3VuZHM6IHt9LFxuICAgICAgICAgICAgICAgIGdhc0VzdGltYXRlVHlwZTogZXhwb3J0cy5HQVNfRVNUSU1BVEVfVFlQRVMuTk9ORSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChpc0VJUDE1NTlDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlcyA9IHlpZWxkIHRoaXMuZmV0Y2hHYXNFc3RpbWF0ZXModGhpcy5FSVAxNTU5QVBJRW5kcG9pbnQucmVwbGFjZSgnPGNoYWluX2lkPicsIGAke2NoYWluSWR9YCksIHRoaXMuY2xpZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHN1Z2dlc3RlZE1heFByaW9yaXR5RmVlUGVyR2FzLCBzdWdnZXN0ZWRNYXhGZWVQZXJHYXMsIH0gPSBlc3RpbWF0ZXMubWVkaXVtO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlc3RpbWF0ZWRHYXNGZWVUaW1lQm91bmRzID0gdGhpcy5nZXRUaW1lRXN0aW1hdGUoc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMsIHN1Z2dlc3RlZE1heEZlZVBlckdhcyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2FzRmVlRXN0aW1hdGVzOiBlc3RpbWF0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlc3RpbWF0ZWRHYXNGZWVUaW1lQm91bmRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FzRXN0aW1hdGVUeXBlOiBleHBvcnRzLkdBU19FU1RJTUFURV9UWVBFUy5GRUVfTUFSS0VULFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0xlZ2FjeUdhc0FQSUNvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXN0aW1hdGVzID0geWllbGQgdGhpcy5mZXRjaExlZ2FjeUdhc1ByaWNlRXN0aW1hdGVzKHRoaXMubGVnYWN5QVBJRW5kcG9pbnQucmVwbGFjZSgnPGNoYWluX2lkPicsIGAke2NoYWluSWR9YCksIHRoaXMuY2xpZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhc0ZlZUVzdGltYXRlczogZXN0aW1hdGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXN0aW1hdGVkR2FzRmVlVGltZUJvdW5kczoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXNFc3RpbWF0ZVR5cGU6IGV4cG9ydHMuR0FTX0VTVElNQVRFX1RZUEVTLkxFR0FDWSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFpbiBnYXMgZmVlL3ByaWNlIGVzdGltYXRpb24gZmFpbGVkLiBVc2UgZmFsbGJhY2snKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlc3RpbWF0ZXMgPSB5aWVsZCB0aGlzLmZldGNoRXRoR2FzUHJpY2VFc3RpbWF0ZSh0aGlzLmV0aFF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnYXNGZWVFc3RpbWF0ZXM6IGVzdGltYXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVzdGltYXRlZEdhc0ZlZVRpbWVCb3VuZHM6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FzRXN0aW1hdGVUeXBlOiBleHBvcnRzLkdBU19FU1RJTUFURV9UWVBFUy5FVEhfR0FTUFJJQ0UsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdhcyBmZWUvcHJpY2UgZXN0aW1hdGlvbiBmYWlsZWQuIE1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlU3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgcG9sbCB0b2tlbiwgYW5kIHN0b3AgcG9sbGluZyBpZiB0aGUgc2V0IG9mIHBvbGwgdG9rZW5zIGlzIGVtcHR5XG4gICAgICovXG4gICAgZGlzY29ubmVjdFBvbGxlcihwb2xsVG9rZW4pIHtcbiAgICAgICAgdGhpcy5wb2xsVG9rZW5zLmRlbGV0ZShwb2xsVG9rZW4pO1xuICAgICAgICBpZiAodGhpcy5wb2xsVG9rZW5zLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFBvbGxpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wUG9sbGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9sbFRva2Vucy5jbGVhcigpO1xuICAgICAgICB0aGlzLnJlc2V0U3RhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB0byBkaXNjYXJkIHRoaXMgY29udHJvbGxlci5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RvcHMgYW55IGFjdGl2ZSBwb2xsaW5nLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5zdG9wUG9sbGluZygpO1xuICAgIH1cbiAgICBfcG9sbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IHRoaXMuX2ZldGNoR2FzRmVlRXN0aW1hdGVEYXRhKCkpO1xuICAgICAgICB9KSwgdGhpcy5pbnRlcnZhbERlbGF5KTtcbiAgICB9XG4gICAgcmVzZXRTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTdGF0ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEVJUDE1NTlDb21wYXRpYmlsaXR5KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudE5ldHdvcmtJc0VJUDE1NTlDb21wYXRpYmxlID0geWllbGQgdGhpcy5nZXRDdXJyZW50TmV0d29ya0VJUDE1NTlDb21wYXRpYmlsaXR5KCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50QWNjb3VudElzRUlQMTU1OUNvbXBhdGlibGUgPSAoX2IgPSAoX2EgPSB0aGlzLmdldEN1cnJlbnRBY2NvdW50RUlQMTU1OUNvbXBhdGliaWxpdHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIChjdXJyZW50TmV0d29ya0lzRUlQMTU1OUNvbXBhdGlibGUgJiYgY3VycmVudEFjY291bnRJc0VJUDE1NTlDb21wYXRpYmxlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFRpbWVFc3RpbWF0ZShtYXhQcmlvcml0eUZlZVBlckdhcywgbWF4RmVlUGVyR2FzKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS5nYXNGZWVFc3RpbWF0ZXMgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZ2FzRXN0aW1hdGVUeXBlICE9PSBleHBvcnRzLkdBU19FU1RJTUFURV9UWVBFUy5GRUVfTUFSS0VUKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdhc191dGlsXzEuY2FsY3VsYXRlVGltZUVzdGltYXRlKG1heFByaW9yaXR5RmVlUGVyR2FzLCBtYXhGZWVQZXJHYXMsIHRoaXMuc3RhdGUuZ2FzRmVlRXN0aW1hdGVzKTtcbiAgICB9XG59XG5leHBvcnRzLkdhc0ZlZUNvbnRyb2xsZXIgPSBHYXNGZWVDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gR2FzRmVlQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdhc0ZlZUNvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVNaW5pbXVtSW5jcmVhc2UgPSBleHBvcnRzLmlzR2FzUHJpY2VWYWx1ZSA9IGV4cG9ydHMuaXNGZWVNYXJrZXRFSVAxNTU5VmFsdWVzID0gZXhwb3J0cy52YWxpZGF0ZUdhc1ZhbHVlcyA9IGV4cG9ydHMuZ2V0SW5jcmVhc2VkUHJpY2VGcm9tRXhpc3RpbmcgPSBleHBvcnRzLmdldEluY3JlYXNlZFByaWNlSGV4ID0gZXhwb3J0cy5jb252ZXJ0UHJpY2VUb0RlY2ltYWwgPSBleHBvcnRzLmlzRUlQMTU1OVRyYW5zYWN0aW9uID0gZXhwb3J0cy5xdWVyeSA9IGV4cG9ydHMubm9ybWFsaXplRW5zTmFtZSA9IGV4cG9ydHMudGltZW91dEZldGNoID0gZXhwb3J0cy5oYW5kbGVGZXRjaCA9IGV4cG9ydHMuc3VjY2Vzc2Z1bEZldGNoID0gZXhwb3J0cy5pc1NtYXJ0Q29udHJhY3RDb2RlID0gZXhwb3J0cy52YWxpZGF0ZVRva2VuVG9XYXRjaCA9IGV4cG9ydHMudmFsaWRhdGVUeXBlZFNpZ25NZXNzYWdlRGF0YVYzID0gZXhwb3J0cy52YWxpZGF0ZVR5cGVkU2lnbk1lc3NhZ2VEYXRhVjEgPSBleHBvcnRzLnZhbGlkYXRlU2lnbk1lc3NhZ2VEYXRhID0gZXhwb3J0cy5ub3JtYWxpemVNZXNzYWdlRGF0YSA9IGV4cG9ydHMudmFsaWRhdGVUcmFuc2FjdGlvbiA9IGV4cG9ydHMuaXNWYWxpZEhleEFkZHJlc3MgPSBleHBvcnRzLnRvQ2hlY2tzdW1IZXhBZGRyZXNzID0gZXhwb3J0cy5zYWZlbHlFeGVjdXRlV2l0aFRpbWVvdXQgPSBleHBvcnRzLnNhZmVseUV4ZWN1dGUgPSBleHBvcnRzLm5vcm1hbGl6ZVRyYW5zYWN0aW9uID0gZXhwb3J0cy5oZXhUb1RleHQgPSBleHBvcnRzLmhleFRvQk4gPSBleHBvcnRzLmhhbmRsZVRyYW5zYWN0aW9uRmV0Y2ggPSBleHBvcnRzLmdldEV0aGVyc2NhbkFwaVVybCA9IGV4cG9ydHMuZ2V0QnV5VVJMID0gZXhwb3J0cy53ZWlIZXhUb0d3ZWlEZWMgPSBleHBvcnRzLmd3ZWlEZWNUb1dFSUJOID0gZXhwb3J0cy5mcmFjdGlvbkJOID0gZXhwb3J0cy5CTlRvSGV4ID0gdm9pZCAwO1xuY29uc3QgZXRoZXJldW1qc191dGlsXzEgPSByZXF1aXJlKFwiZXRoZXJldW1qcy11dGlsXCIpO1xuY29uc3QgZXRoanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGpzLXV0aWxcIik7XG5jb25zdCBldGhqc191bml0XzEgPSByZXF1aXJlKFwiZXRoanMtdW5pdFwiKTtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG5jb25zdCBldGhfZW5zX25hbWVoYXNoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImV0aC1lbnMtbmFtZWhhc2hcIikpO1xuY29uc3QgZXRoX3NpZ191dGlsXzEgPSByZXF1aXJlKFwiZXRoLXNpZy11dGlsXCIpO1xuY29uc3QganNvbnNjaGVtYV8xID0gcmVxdWlyZShcImpzb25zY2hlbWFcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGhleFJlID0gL15bMC05QS1GYS1mXSskL2d1O1xuY29uc3QgTk9STUFMSVpFUlMgPSB7XG4gICAgZGF0YTogKGRhdGEpID0+IGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeChkYXRhKSxcbiAgICBmcm9tOiAoZnJvbSkgPT4gZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KGZyb20pLnRvTG93ZXJDYXNlKCksXG4gICAgZ2FzOiAoZ2FzKSA9PiBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgoZ2FzKSxcbiAgICBnYXNQcmljZTogKGdhc1ByaWNlKSA9PiBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgoZ2FzUHJpY2UpLFxuICAgIG5vbmNlOiAobm9uY2UpID0+IGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeChub25jZSksXG4gICAgdG86ICh0bykgPT4gZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KHRvKS50b0xvd2VyQ2FzZSgpLFxuICAgIHZhbHVlOiAodmFsdWUpID0+IGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeCh2YWx1ZSksXG4gICAgbWF4RmVlUGVyR2FzOiAobWF4RmVlUGVyR2FzKSA9PiBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgobWF4RmVlUGVyR2FzKSxcbiAgICBtYXhQcmlvcml0eUZlZVBlckdhczogKG1heFByaW9yaXR5RmVlUGVyR2FzKSA9PiBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgobWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxuICAgIGVzdGltYXRlZEJhc2VGZWU6IChtYXhQcmlvcml0eUZlZVBlckdhcykgPT4gZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KG1heFByaW9yaXR5RmVlUGVyR2FzKSxcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgQk4gb2JqZWN0IHRvIGEgaGV4IHN0cmluZyB3aXRoIGEgJzB4JyBwcmVmaXhcbiAqXG4gKiBAcGFyYW0gaW5wdXRCbiAtIEJOIGluc3RhbmNlIHRvIGNvbnZlcnQgdG8gYSBoZXggc3RyaW5nXG4gKiBAcmV0dXJucyAtICcweCctcHJlZml4ZWQgaGV4IHN0cmluZ1xuICpcbiAqL1xuZnVuY3Rpb24gQk5Ub0hleChpbnB1dEJuKSB7XG4gICAgcmV0dXJuIGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeChpbnB1dEJuLnRvU3RyaW5nKDE2KSk7XG59XG5leHBvcnRzLkJOVG9IZXggPSBCTlRvSGV4O1xuLyoqXG4gKiBVc2VkIHRvIG11bHRpcGx5IGEgQk4gYnkgYSBmcmFjdGlvblxuICpcbiAqIEBwYXJhbSB0YXJnZXRCTiAtIE51bWJlciB0byBtdWx0aXBseSBieSBhIGZyYWN0aW9uXG4gKiBAcGFyYW0gbnVtZXJhdG9yIC0gTnVtZXJhdG9yIG9mIHRoZSBmcmFjdGlvbiBtdWx0aXBsaWVyXG4gKiBAcGFyYW0gZGVub21pbmF0b3IgLSBEZW5vbWluYXRvciBvZiB0aGUgZnJhY3Rpb24gbXVsdGlwbGllclxuICogQHJldHVybnMgLSBQcm9kdWN0IG9mIHRoZSBtdWx0aXBsaWNhdGlvblxuICovXG5mdW5jdGlvbiBmcmFjdGlvbkJOKHRhcmdldEJOLCBudW1lcmF0b3IsIGRlbm9taW5hdG9yKSB7XG4gICAgY29uc3QgbnVtQk4gPSBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4obnVtZXJhdG9yKTtcbiAgICBjb25zdCBkZW5vbUJOID0gbmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKGRlbm9taW5hdG9yKTtcbiAgICByZXR1cm4gdGFyZ2V0Qk4ubXVsKG51bUJOKS5kaXYoZGVub21CTik7XG59XG5leHBvcnRzLmZyYWN0aW9uQk4gPSBmcmFjdGlvbkJOO1xuLyoqXG4gKiBVc2VkIHRvIGNvbnZlcnQgYSBiYXNlLTEwIG51bWJlciBmcm9tIEdXRUkgdG8gV0VJLiBDYW4gaGFuZGxlIG51bWJlcnMgd2l0aCBkZWNpbWFsIHBhcnRzXG4gKlxuICogQHBhcmFtIG4gLSBUaGUgYmFzZSAxMCBudW1iZXIgdG8gY29udmVydCB0byBXRUlcbiAqIEByZXR1cm5zIC0gVGhlIG51bWJlciBpbiBXRUksIGFzIGEgQk5cbiAqL1xuZnVuY3Rpb24gZ3dlaURlY1RvV0VJQk4obikge1xuICAgIGlmIChOdW1iZXIuaXNOYU4obikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTigwKTtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSBuLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICBjb25zdCB3aG9sZVBhcnQgPSBwYXJ0c1swXSB8fCAnMCc7XG4gICAgbGV0IGRlY2ltYWxQYXJ0ID0gcGFydHNbMV0gfHwgJyc7XG4gICAgaWYgKCFkZWNpbWFsUGFydCkge1xuICAgICAgICByZXR1cm4gZXRoanNfdW5pdF8xLnRvV2VpKHdob2xlUGFydCwgJ2d3ZWknKTtcbiAgICB9XG4gICAgaWYgKGRlY2ltYWxQYXJ0Lmxlbmd0aCA8PSA5KSB7XG4gICAgICAgIHJldHVybiBldGhqc191bml0XzEudG9XZWkoYCR7d2hvbGVQYXJ0fS4ke2RlY2ltYWxQYXJ0fWAsICdnd2VpJyk7XG4gICAgfVxuICAgIGNvbnN0IGRlY2ltYWxQYXJ0VG9SZW1vdmUgPSBkZWNpbWFsUGFydC5zbGljZSg5KTtcbiAgICBjb25zdCBkZWNpbWFsUm91bmRpbmdEaWdpdCA9IGRlY2ltYWxQYXJ0VG9SZW1vdmVbMF07XG4gICAgZGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5zbGljZSgwLCA5KTtcbiAgICBsZXQgd2VpID0gZXRoanNfdW5pdF8xLnRvV2VpKGAke3dob2xlUGFydH0uJHtkZWNpbWFsUGFydH1gLCAnZ3dlaScpO1xuICAgIGlmIChOdW1iZXIoZGVjaW1hbFJvdW5kaW5nRGlnaXQpID49IDUpIHtcbiAgICAgICAgd2VpID0gd2VpLmFkZChuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oMSkpO1xuICAgIH1cbiAgICByZXR1cm4gd2VpO1xufVxuZXhwb3J0cy5nd2VpRGVjVG9XRUlCTiA9IGd3ZWlEZWNUb1dFSUJOO1xuLyoqXG4gKiBVc2VkIHRvIGNvbnZlcnQgdmFsdWVzIGZyb20gd2VpIGhleCBmb3JtYXQgdG8gZGVjIGd3ZWkgZm9ybWF0XG4gKiBAcGFyYW0gaGV4IC0gdmFsdWUgaW4gaGV4IHdlaVxuICogQHJldHVybnMgLSB2YWx1ZSBpbiBkZWMgZ3dlaSBhcyBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gd2VpSGV4VG9Hd2VpRGVjKGhleCkge1xuICAgIGNvbnN0IGhleFdlaSA9IG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTihldGhqc191dGlsXzEuc3RyaXBIZXhQcmVmaXgoaGV4KSwgMTYpO1xuICAgIHJldHVybiBldGhqc191bml0XzEuZnJvbVdlaShoZXhXZWksICdnd2VpJykudG9TdHJpbmcoMTApO1xufVxuZXhwb3J0cy53ZWlIZXhUb0d3ZWlEZWMgPSB3ZWlIZXhUb0d3ZWlEZWM7XG4vKipcbiAqIFJldHVybiBhIFVSTCB0aGF0IGNhbiBiZSB1c2VkIHRvIG9idGFpbiBFVEggZm9yIGEgZ2l2ZW4gbmV0d29ya1xuICpcbiAqIEBwYXJhbSBuZXR3b3JrQ29kZSAtIE5ldHdvcmsgY29kZSBvZiBkZXNpcmVkIG5ldHdvcmtcbiAqIEBwYXJhbSBhZGRyZXNzIC0gQWRkcmVzcyB0byBkZXBvc2l0IG9idGFpbmVkIEVUSFxuICogQHBhcmFtIGFtb3VudCAtIEhvdyBtdWNoIEVUSCBpcyBkZXNpcmVkXG4gKiBAcmV0dXJucyAtIFVSTCB0byBidXkgRVRIIGJhc2VkIG9uIG5ldHdvcmtcbiAqL1xuZnVuY3Rpb24gZ2V0QnV5VVJMKG5ldHdvcmtDb2RlID0gJzEnLCBhZGRyZXNzLCBhbW91bnQgPSA1KSB7XG4gICAgc3dpdGNoIChuZXR3b3JrQ29kZSkge1xuICAgICAgICBjYXNlICcxJzpcbiAgICAgICAgICAgIHJldHVybiBgaHR0cHM6Ly9idXkuY29pbmJhc2UuY29tLz9jb2RlPTllYzU2ZDAxLTdlODEtNTAxNy05MzBjLTUxM2RhYTI3YmI2YSZhbW91bnQ9JHthbW91bnR9JmFkZHJlc3M9JHthZGRyZXNzfSZjcnlwdG9fY3VycmVuY3k9RVRIYDtcbiAgICAgICAgY2FzZSAnMyc6XG4gICAgICAgICAgICByZXR1cm4gJ2h0dHBzOi8vZmF1Y2V0Lm1ldGFtYXNrLmlvLyc7XG4gICAgICAgIGNhc2UgJzQnOlxuICAgICAgICAgICAgcmV0dXJuICdodHRwczovL3d3dy5yaW5rZWJ5LmlvLyc7XG4gICAgICAgIGNhc2UgJzUnOlxuICAgICAgICAgICAgcmV0dXJuICdodHRwczovL2dvZXJsaS1mYXVjZXQuc2xvY2suaXQvJztcbiAgICAgICAgY2FzZSAnNDInOlxuICAgICAgICAgICAgcmV0dXJuICdodHRwczovL2dpdGh1Yi5jb20va292YW4tdGVzdG5ldC9mYXVjZXQnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLmdldEJ1eVVSTCA9IGdldEJ1eVVSTDtcbi8qKlxuICogUmV0dXJuIGEgVVJMIHRoYXQgY2FuIGJlIHVzZWQgdG8gZmV0Y2ggRVRIIHRyYW5zYWN0aW9uc1xuICpcbiAqIEBwYXJhbSBuZXR3b3JrVHlwZSAtIE5ldHdvcmsgdHlwZSBvZiBkZXNpcmVkIG5ldHdvcmtcbiAqIEBwYXJhbSB1cmxQYXJhbXMgLSBQYXJhbWV0ZXJzIHVzZWQgdG8gY29uc3RydWN0IHRoZSBVUkxcbiAqIEByZXR1cm5zIC0gVVJMIHRvIGZldGNoIHRoZSBhY2Nlc3MgdGhlIGVuZHBvaW50XG4gKi9cbmZ1bmN0aW9uIGdldEV0aGVyc2NhbkFwaVVybChuZXR3b3JrVHlwZSwgdXJsUGFyYW1zKSB7XG4gICAgbGV0IGV0aGVyc2NhblN1YmRvbWFpbiA9ICdhcGknO1xuICAgIGlmIChuZXR3b3JrVHlwZSAhPT0gY29uc3RhbnRzXzEuTUFJTk5FVCkge1xuICAgICAgICBldGhlcnNjYW5TdWJkb21haW4gPSBgYXBpLSR7bmV0d29ya1R5cGV9YDtcbiAgICB9XG4gICAgY29uc3QgYXBpVXJsID0gYGh0dHBzOi8vJHtldGhlcnNjYW5TdWJkb21haW59LmV0aGVyc2Nhbi5pb2A7XG4gICAgbGV0IHVybCA9IGAke2FwaVVybH0vYXBpP2A7XG4gICAgZm9yIChjb25zdCBwYXJhbUtleSBpbiB1cmxQYXJhbXMpIHtcbiAgICAgICAgaWYgKHVybFBhcmFtc1twYXJhbUtleV0pIHtcbiAgICAgICAgICAgIHVybCArPSBgJHtwYXJhbUtleX09JHt1cmxQYXJhbXNbcGFyYW1LZXldfSZgO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVybCArPSAndGFnPWxhdGVzdCZwYWdlPTEnO1xuICAgIHJldHVybiB1cmw7XG59XG5leHBvcnRzLmdldEV0aGVyc2NhbkFwaVVybCA9IGdldEV0aGVyc2NhbkFwaVVybDtcbi8qKlxuICogSGFuZGxlcyB0aGUgZmV0Y2ggb2YgaW5jb21pbmcgdHJhbnNhY3Rpb25zXG4gKlxuICogQHBhcmFtIG5ldHdvcmtUeXBlIC0gTmV0d29yayB0eXBlIG9mIGRlc2lyZWQgbmV0d29ya1xuICogQHBhcmFtIGFkZHJlc3MgLSBBZGRyZXNzIHRvIGdldCB0aGUgdHJhbnNhY3Rpb25zIGZyb21cbiAqIEBwYXJhbSBvcHQ/IC0gT2JqZWN0IHRoYXQgY2FuIGNvbnRhaW4gZnJvbUJsb2NrIGFuZCBFdGhlcnNjYW4gc2VydmljZSBBUEkga2V5XG4gKiBAcmV0dXJucyAtIFJlc3BvbnNlcyBmb3IgYm90aCBFVEggYW5kIEVSQzIwIHRva2VuIHRyYW5zYWN0aW9uc1xuICovXG5mdW5jdGlvbiBoYW5kbGVUcmFuc2FjdGlvbkZldGNoKG5ldHdvcmtUeXBlLCBhZGRyZXNzLCB0eEhpc3RvcnlMaW1pdCwgb3B0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgLy8gdHJhbnNhY3Rpb25zXG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IHtcbiAgICAgICAgICAgIG1vZHVsZTogJ2FjY291bnQnLFxuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIHN0YXJ0QmxvY2s6IG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5mcm9tQmxvY2ssXG4gICAgICAgICAgICBhcGlrZXk6IG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5ldGhlcnNjYW5BcGlLZXksXG4gICAgICAgICAgICBvZmZzZXQ6IHR4SGlzdG9yeUxpbWl0LnRvU3RyaW5nKCksXG4gICAgICAgICAgICBvcmRlcjogJ2Rlc2MnLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBldGhlcnNjYW5UeFVybCA9IGdldEV0aGVyc2NhbkFwaVVybChuZXR3b3JrVHlwZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB1cmxQYXJhbXMpLCB7IGFjdGlvbjogJ3R4bGlzdCcgfSkpO1xuICAgICAgICBjb25zdCBldGhlcnNjYW5UeFJlc3BvbnNlUHJvbWlzZSA9IGhhbmRsZUZldGNoKGV0aGVyc2NhblR4VXJsKTtcbiAgICAgICAgLy8gdG9rZW5zXG4gICAgICAgIGNvbnN0IGV0aGVyc2NhblRva2VuVXJsID0gZ2V0RXRoZXJzY2FuQXBpVXJsKG5ldHdvcmtUeXBlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHVybFBhcmFtcyksIHsgYWN0aW9uOiAndG9rZW50eCcgfSkpO1xuICAgICAgICBjb25zdCBldGhlcnNjYW5Ub2tlblJlc3BvbnNlUHJvbWlzZSA9IGhhbmRsZUZldGNoKGV0aGVyc2NhblRva2VuVXJsKTtcbiAgICAgICAgbGV0IFtldGhlcnNjYW5UeFJlc3BvbnNlLCBldGhlcnNjYW5Ub2tlblJlc3BvbnNlXSA9IHlpZWxkIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGV0aGVyc2NhblR4UmVzcG9uc2VQcm9taXNlLFxuICAgICAgICAgICAgZXRoZXJzY2FuVG9rZW5SZXNwb25zZVByb21pc2UsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoZXRoZXJzY2FuVHhSZXNwb25zZS5zdGF0dXMgPT09ICcwJyB8fFxuICAgICAgICAgICAgZXRoZXJzY2FuVHhSZXNwb25zZS5yZXN1bHQubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIGV0aGVyc2NhblR4UmVzcG9uc2UgPSB7IHN0YXR1czogZXRoZXJzY2FuVHhSZXNwb25zZS5zdGF0dXMsIHJlc3VsdDogW10gfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXRoZXJzY2FuVG9rZW5SZXNwb25zZS5zdGF0dXMgPT09ICcwJyB8fFxuICAgICAgICAgICAgZXRoZXJzY2FuVG9rZW5SZXNwb25zZS5yZXN1bHQubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIGV0aGVyc2NhblRva2VuUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBldGhlcnNjYW5Ub2tlblJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2V0aGVyc2NhblR4UmVzcG9uc2UsIGV0aGVyc2NhblRva2VuUmVzcG9uc2VdO1xuICAgIH0pO1xufVxuZXhwb3J0cy5oYW5kbGVUcmFuc2FjdGlvbkZldGNoID0gaGFuZGxlVHJhbnNhY3Rpb25GZXRjaDtcbi8qKlxuICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGEgQk4gb2JqZWN0XG4gKlxuICogQHBhcmFtIGlucHV0SGV4IC0gTnVtYmVyIHJlcHJlc2VudGVkIGFzIGEgaGV4IHN0cmluZ1xuICogQHJldHVybnMgLSBBIEJOIGluc3RhbmNlXG4gKlxuICovXG5mdW5jdGlvbiBoZXhUb0JOKGlucHV0SGV4KSB7XG4gICAgcmV0dXJuIG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTihldGhqc191dGlsXzEuc3RyaXBIZXhQcmVmaXgoaW5wdXRIZXgpLCAxNik7XG59XG5leHBvcnRzLmhleFRvQk4gPSBoZXhUb0JOO1xuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IGNvbnZlcnRzIGhleCBkYXRhIHRvIGh1bWFuIHJlYWRhYmxlIHN0cmluZ1xuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUgaGV4IHN0cmluZyB0byBjb252ZXJ0IHRvIHN0cmluZ1xuICogQHJldHVybnMgLSBBIGh1bWFuIHJlYWRhYmxlIHN0cmluZyBjb252ZXJzaW9uXG4gKlxuICovXG5mdW5jdGlvbiBoZXhUb1RleHQoaGV4KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RyaXBwZWQgPSBldGhqc191dGlsXzEuc3RyaXBIZXhQcmVmaXgoaGV4KTtcbiAgICAgICAgY29uc3QgYnVmZiA9IEJ1ZmZlci5mcm9tKHN0cmlwcGVkLCAnaGV4Jyk7XG4gICAgICAgIHJldHVybiBidWZmLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBoZXg7XG4gICAgfVxufVxuZXhwb3J0cy5oZXhUb1RleHQgPSBoZXhUb1RleHQ7XG4vKipcbiAqIE5vcm1hbGl6ZXMgcHJvcGVydGllcyBvbiBhIFRyYW5zYWN0aW9uIG9iamVjdFxuICpcbiAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRyYW5zYWN0aW9uIG9iamVjdCB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIC0gTm9ybWFsaXplZCBUcmFuc2FjdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICBjb25zdCBub3JtYWxpemVkVHJhbnNhY3Rpb24gPSB7IGZyb206ICcnIH07XG4gICAgbGV0IGtleTtcbiAgICBmb3IgKGtleSBpbiBOT1JNQUxJWkVSUykge1xuICAgICAgICBpZiAodHJhbnNhY3Rpb25ba2V5XSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZFRyYW5zYWN0aW9uW2tleV0gPSBOT1JNQUxJWkVSU1trZXldKHRyYW5zYWN0aW9uW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkVHJhbnNhY3Rpb247XG59XG5leHBvcnRzLm5vcm1hbGl6ZVRyYW5zYWN0aW9uID0gbm9ybWFsaXplVHJhbnNhY3Rpb247XG4vKipcbiAqIEV4ZWN1dGUgYW5kIHJldHVybiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uIHdpdGhvdXQgdGhyb3dpbmcgZXJyb3JzXG4gKlxuICogQHBhcmFtIG9wZXJhdGlvbiAtIEZ1bmN0aW9uIHJldHVybmluZyBhIFByb21pc2VcbiAqIEBwYXJhbSBsb2dFcnJvciAtIERldGVybWluZXMgaWYgdGhlIGVycm9yIHNob3VsZCBiZSBsb2dnZWRcbiAqIEBwYXJhbSByZXRyeSAtIEZ1bmN0aW9uIGNhbGxlZCBpZiBhbiBlcnJvciBpcyBjYXVnaHRcbiAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHJlc3VsdCBvZiB0aGUgYXN5bmMgb3BlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHNhZmVseUV4ZWN1dGUob3BlcmF0aW9uLCBsb2dFcnJvciA9IGZhbHNlLCByZXRyeSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgb3BlcmF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKGxvZ0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXRyeSA9PT0gbnVsbCB8fCByZXRyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmV0cnkoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5zYWZlbHlFeGVjdXRlID0gc2FmZWx5RXhlY3V0ZTtcbi8qKlxuICogRXhlY3V0ZSBhbmQgcmV0dXJuIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24gd2l0aCBhIHRpbWVvdXRcbiAqXG4gKiBAcGFyYW0gb3BlcmF0aW9uIC0gRnVuY3Rpb24gcmV0dXJuaW5nIGEgUHJvbWlzZVxuICogQHBhcmFtIGxvZ0Vycm9yIC0gRGV0ZXJtaW5lcyBpZiB0aGUgZXJyb3Igc2hvdWxkIGJlIGxvZ2dlZFxuICogQHBhcmFtIHJldHJ5IC0gRnVuY3Rpb24gY2FsbGVkIGlmIGFuIGVycm9yIGlzIGNhdWdodFxuICogQHBhcmFtIHRpbWVvdXQgLSBUaW1lb3V0IHRvIGZhaWwgdGhlIG9wZXJhdGlvblxuICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgcmVzdWx0IG9mIHRoZSBhc3luYyBvcGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gc2FmZWx5RXhlY3V0ZVdpdGhUaW1lb3V0KG9wZXJhdGlvbiwgbG9nRXJyb3IgPSBmYWxzZSwgdGltZW91dCA9IDUwMCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24oKSxcbiAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcigndGltZW91dCcpKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KSksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAobG9nRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuc2FmZWx5RXhlY3V0ZVdpdGhUaW1lb3V0ID0gc2FmZWx5RXhlY3V0ZVdpdGhUaW1lb3V0O1xuZnVuY3Rpb24gdG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcykge1xuICAgIGNvbnN0IGhleFByZWZpeGVkID0gZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KGFkZHJlc3MpO1xuICAgIGlmICghZXRoZXJldW1qc191dGlsXzEuaXNIZXhTdHJpbmcoaGV4UHJlZml4ZWQpKSB7XG4gICAgICAgIC8vIFZlcnNpb24gNS4xIG9mIGV0aGVyZXVtanMtdXRpbHMgd291bGQgaGF2ZSByZXR1cm5lZCAnMHhZJyBmb3IgaW5wdXQgJ3knXG4gICAgICAgIC8vIGJ1dCB3ZSBzaG91bGRuJ3Qgd2FzdGUgZWZmb3J0IHRyeWluZyB0byBjaGFuZ2UgY2FzZSBvbiBhIGNsZWFybHkgaW52YWxpZFxuICAgICAgICAvLyBzdHJpbmcuIEluc3RlYWQganVzdCByZXR1cm4gdGhlIGhleCBwcmVmaXhlZCBvcmlnaW5hbCBzdHJpbmcgd2hpY2ggbW9zdFxuICAgICAgICAvLyBjbG9zZWx5IG1pbWljcyB0aGUgb3JpZ2luYWwgYmVoYXZpb3IuXG4gICAgICAgIHJldHVybiBoZXhQcmVmaXhlZDtcbiAgICB9XG4gICAgcmV0dXJuIGV0aGVyZXVtanNfdXRpbF8xLnRvQ2hlY2tzdW1BZGRyZXNzKGhleFByZWZpeGVkKTtcbn1cbmV4cG9ydHMudG9DaGVja3N1bUhleEFkZHJlc3MgPSB0b0NoZWNrc3VtSGV4QWRkcmVzcztcbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgdGhlIGlucHV0IGlzIGEgaGV4IGFkZHJlc3MuIFRoaXMgdXRpbGl0eSBtZXRob2QgaXMgYSB0aGluXG4gKiB3cmFwcGVyIGFyb3VuZCBldGhlcmV1bWpzLXV0aWwuaXNWYWxpZEFkZHJlc3MsIHdpdGggdGhlIGV4Y2VwdGlvbiB0aGF0IGl0XG4gKiBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvciB3aGVuIHByb3ZpZGVkIHZhbHVlcyB0aGF0IGFyZSBub3QgaGV4IHN0cmluZ3MuIEluXG4gKiBhZGRpdGlvbiwgYW5kIGJ5IGRlZmF1bHQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRydWUgZm9yIGhleCBzdHJpbmdzIHRoYXRcbiAqIG1lZXQgdGhlIGxlbmd0aCByZXF1aXJlbWVudCBvZiBhIGhleCBhZGRyZXNzLCBidXQgYXJlIG5vdCBwcmVmaXhlZCB3aXRoIGAweGBcbiAqIEZpbmFsbHksIGlmIHRoZSBtaXhlZENhc2VVc2VDaGVja3N1bSBmbGFnIGlzIHRydWUgYW5kIGEgbWl4ZWQgY2FzZSBzdHJpbmcgaXNcbiAqIHByb3ZpZGVkIHRoaXMgbWV0aG9kIHdpbGwgdmFsaWRhdGUgaXQgaGFzIHRoZSBwcm9wZXIgY2hlY2tzdW0gZm9ybWF0dGluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwb3NzaWJsZUFkZHJlc3MgLSBJbnB1dCBwYXJhbWV0ZXIgdG8gY2hlY2sgYWdhaW5zdFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG9wdGlvbnMgYmFnXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFsbG93Tm9uUHJlZml4ZWRdIC0gSWYgdHJ1ZSB3aWxsIGZpcnN0IGVuc3VyZSAnMHgnXG4gKiAgaXMgcHJlcGVuZGVkIHRvIHRoZSBzdHJpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgaW5wdXQgaXMgYSB2YWxpZCBoZXggYWRkcmVzc1xuICovXG5mdW5jdGlvbiBpc1ZhbGlkSGV4QWRkcmVzcyhwb3NzaWJsZUFkZHJlc3MsIHsgYWxsb3dOb25QcmVmaXhlZCA9IHRydWUgfSA9IHt9KSB7XG4gICAgY29uc3QgYWRkcmVzc1RvQ2hlY2sgPSBhbGxvd05vblByZWZpeGVkXG4gICAgICAgID8gZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KHBvc3NpYmxlQWRkcmVzcylcbiAgICAgICAgOiBwb3NzaWJsZUFkZHJlc3M7XG4gICAgaWYgKCFldGhlcmV1bWpzX3V0aWxfMS5pc0hleFN0cmluZyhhZGRyZXNzVG9DaGVjaykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZXRoZXJldW1qc191dGlsXzEuaXNWYWxpZEFkZHJlc3MoYWRkcmVzc1RvQ2hlY2spO1xufVxuZXhwb3J0cy5pc1ZhbGlkSGV4QWRkcmVzcyA9IGlzVmFsaWRIZXhBZGRyZXNzO1xuLyoqXG4gKiBWYWxpZGF0ZXMgYSBUcmFuc2FjdGlvbiBvYmplY3QgZm9yIHJlcXVpcmVkIHByb3BlcnRpZXMgYW5kIHRocm93cyBpblxuICogdGhlIGV2ZW50IG9mIGFueSB2YWxpZGF0aW9uIGVycm9yLlxuICpcbiAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRyYW5zYWN0aW9uIG9iamVjdCB0byB2YWxpZGF0ZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKCF0cmFuc2FjdGlvbi5mcm9tIHx8XG4gICAgICAgIHR5cGVvZiB0cmFuc2FjdGlvbi5mcm9tICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAhaXNWYWxpZEhleEFkZHJlc3ModHJhbnNhY3Rpb24uZnJvbSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwiZnJvbVwiIGFkZHJlc3M6ICR7dHJhbnNhY3Rpb24uZnJvbX0gbXVzdCBiZSBhIHZhbGlkIHN0cmluZy5gKTtcbiAgICB9XG4gICAgaWYgKHRyYW5zYWN0aW9uLnRvID09PSAnMHgnIHx8IHRyYW5zYWN0aW9uLnRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmRhdGEpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0cmFuc2FjdGlvbi50bztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcInRvXCIgYWRkcmVzczogJHt0cmFuc2FjdGlvbi50b30gbXVzdCBiZSBhIHZhbGlkIHN0cmluZy5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2FjdGlvbi50byAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICFpc1ZhbGlkSGV4QWRkcmVzcyh0cmFuc2FjdGlvbi50bykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwidG9cIiBhZGRyZXNzOiAke3RyYW5zYWN0aW9uLnRvfSBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nLmApO1xuICAgIH1cbiAgICBpZiAodHJhbnNhY3Rpb24udmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRyYW5zYWN0aW9uLnZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcygnLScpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJ2YWx1ZVwiOiAke3ZhbHVlfSBpcyBub3QgYSBwb3NpdGl2ZSBudW1iZXIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcInZhbHVlXCI6ICR7dmFsdWV9IG51bWJlciBtdXN0IGJlIGRlbm9taW5hdGVkIGluIHdlaS5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnRWYWx1ZSA9IHBhcnNlSW50KHRyYW5zYWN0aW9uLnZhbHVlLCAxMCk7XG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSBOdW1iZXIuaXNGaW5pdGUoaW50VmFsdWUpICYmXG4gICAgICAgICAgICAhTnVtYmVyLmlzTmFOKGludFZhbHVlKSAmJlxuICAgICAgICAgICAgIWlzTmFOKE51bWJlcih2YWx1ZSkpICYmXG4gICAgICAgICAgICBOdW1iZXIuaXNTYWZlSW50ZWdlcihpbnRWYWx1ZSk7XG4gICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwidmFsdWVcIjogJHt2YWx1ZX0gbnVtYmVyIG11c3QgYmUgYSB2YWxpZCBudW1iZXIuYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlVHJhbnNhY3Rpb24gPSB2YWxpZGF0ZVRyYW5zYWN0aW9uO1xuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IGNvbnZlcnRzIHJhd21lc3NhZ2VEYXRhIGJ1ZmZlciBkYXRhIHRvIGEgaGV4LCBvciBqdXN0IHJldHVybnMgdGhlIGRhdGEgaWZcbiAqIGl0IGlzIGFscmVhZHkgZm9ybWF0dGVkIGFzIGEgaGV4LlxuICpcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGJ1ZmZlciBkYXRhIHRvIGNvbnZlcnQgdG8gYSBoZXhcbiAqIEByZXR1cm5zIC0gQSBoZXggc3RyaW5nIGNvbnZlcnNpb24gb2YgdGhlIGJ1ZmZlciBkYXRhXG4gKlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVNZXNzYWdlRGF0YShkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RyaXBwZWQgPSBldGhqc191dGlsXzEuc3RyaXBIZXhQcmVmaXgoZGF0YSk7XG4gICAgICAgIGlmIChzdHJpcHBlZC5tYXRjaChoZXhSZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgoc3RyaXBwZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgfVxuICAgIHJldHVybiBldGhlcmV1bWpzX3V0aWxfMS5idWZmZXJUb0hleChCdWZmZXIuZnJvbShkYXRhLCAndXRmOCcpKTtcbn1cbmV4cG9ydHMubm9ybWFsaXplTWVzc2FnZURhdGEgPSBub3JtYWxpemVNZXNzYWdlRGF0YTtcbi8qKlxuICogVmFsaWRhdGVzIGEgUGVyc29uYWxNZXNzYWdlUGFyYW1zIGFuZCBNZXNzYWdlUGFyYW1zIG9iamVjdHMgZm9yIHJlcXVpcmVkIHByb3BlcnRpZXMgYW5kIHRocm93cyBpblxuICogdGhlIGV2ZW50IG9mIGFueSB2YWxpZGF0aW9uIGVycm9yLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlRGF0YSAtIFBlcnNvbmFsTWVzc2FnZVBhcmFtcyBvYmplY3QgdG8gdmFsaWRhdGVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTaWduTWVzc2FnZURhdGEobWVzc2FnZURhdGEpIHtcbiAgICBjb25zdCB7IGZyb20sIGRhdGEgfSA9IG1lc3NhZ2VEYXRhO1xuICAgIGlmICghZnJvbSB8fCB0eXBlb2YgZnJvbSAhPT0gJ3N0cmluZycgfHwgIWlzVmFsaWRIZXhBZGRyZXNzKGZyb20pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcImZyb21cIiBhZGRyZXNzOiAke2Zyb219IG11c3QgYmUgYSB2YWxpZCBzdHJpbmcuYCk7XG4gICAgfVxuICAgIGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1lc3NhZ2UgXCJkYXRhXCI6ICR7ZGF0YX0gbXVzdCBiZSBhIHZhbGlkIHN0cmluZy5gKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlU2lnbk1lc3NhZ2VEYXRhID0gdmFsaWRhdGVTaWduTWVzc2FnZURhdGE7XG4vKipcbiAqIFZhbGlkYXRlcyBhIFR5cGVkTWVzc2FnZVBhcmFtcyBvYmplY3QgZm9yIHJlcXVpcmVkIHByb3BlcnRpZXMgYW5kIHRocm93cyBpblxuICogdGhlIGV2ZW50IG9mIGFueSB2YWxpZGF0aW9uIGVycm9yIGZvciBldGhfc2lnblR5cGVkTWVzc2FnZV9WMS5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZURhdGEgLSBUeXBlZE1lc3NhZ2VQYXJhbXMgb2JqZWN0IHRvIHZhbGlkYXRlXG4gKiBAcGFyYW0gYWN0aXZlQ2hhaW5JZCAtIEFjdGl2ZSBjaGFpbiBpZFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGVkU2lnbk1lc3NhZ2VEYXRhVjEobWVzc2FnZURhdGEpIHtcbiAgICBpZiAoIW1lc3NhZ2VEYXRhLmZyb20gfHxcbiAgICAgICAgdHlwZW9mIG1lc3NhZ2VEYXRhLmZyb20gIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICFpc1ZhbGlkSGV4QWRkcmVzcyhtZXNzYWdlRGF0YS5mcm9tKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJmcm9tXCIgYWRkcmVzczogJHttZXNzYWdlRGF0YS5mcm9tfSBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nLmApO1xuICAgIH1cbiAgICBpZiAoIW1lc3NhZ2VEYXRhLmRhdGEgfHwgIUFycmF5LmlzQXJyYXkobWVzc2FnZURhdGEuZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1lc3NhZ2UgXCJkYXRhXCI6ICR7bWVzc2FnZURhdGEuZGF0YX0gbXVzdCBiZSBhIHZhbGlkIGFycmF5LmApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB0eXBlZFNpZ25hdHVyZUhhc2ggd2lsbCB0aHJvdyBpZiB0aGUgZGF0YSBpcyBpbnZhbGlkLlxuICAgICAgICBldGhfc2lnX3V0aWxfMS50eXBlZFNpZ25hdHVyZUhhc2gobWVzc2FnZURhdGEuZGF0YSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgRUlQNzEyIHR5cGVkIGRhdGEuYCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVR5cGVkU2lnbk1lc3NhZ2VEYXRhVjEgPSB2YWxpZGF0ZVR5cGVkU2lnbk1lc3NhZ2VEYXRhVjE7XG4vKipcbiAqIFZhbGlkYXRlcyBhIFR5cGVkTWVzc2FnZVBhcmFtcyBvYmplY3QgZm9yIHJlcXVpcmVkIHByb3BlcnRpZXMgYW5kIHRocm93cyBpblxuICogdGhlIGV2ZW50IG9mIGFueSB2YWxpZGF0aW9uIGVycm9yIGZvciBldGhfc2lnblR5cGVkTWVzc2FnZV9WMy5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZURhdGEgLSBUeXBlZE1lc3NhZ2VQYXJhbXMgb2JqZWN0IHRvIHZhbGlkYXRlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZWRTaWduTWVzc2FnZURhdGFWMyhtZXNzYWdlRGF0YSkge1xuICAgIGlmICghbWVzc2FnZURhdGEuZnJvbSB8fFxuICAgICAgICB0eXBlb2YgbWVzc2FnZURhdGEuZnJvbSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgIWlzVmFsaWRIZXhBZGRyZXNzKG1lc3NhZ2VEYXRhLmZyb20pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcImZyb21cIiBhZGRyZXNzOiAke21lc3NhZ2VEYXRhLmZyb219IG11c3QgYmUgYSB2YWxpZCBzdHJpbmcuYCk7XG4gICAgfVxuICAgIGlmICghbWVzc2FnZURhdGEuZGF0YSB8fCB0eXBlb2YgbWVzc2FnZURhdGEuZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1lc3NhZ2UgXCJkYXRhXCI6ICR7bWVzc2FnZURhdGEuZGF0YX0gbXVzdCBiZSBhIHZhbGlkIGFycmF5LmApO1xuICAgIH1cbiAgICBsZXQgZGF0YTtcbiAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlRGF0YS5kYXRhKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgYmUgcGFzc2VkIGFzIGEgdmFsaWQgSlNPTiBzdHJpbmcuJyk7XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkYXRpb24gPSBqc29uc2NoZW1hXzEudmFsaWRhdGUoZGF0YSwgZXRoX3NpZ191dGlsXzEuVFlQRURfTUVTU0FHRV9TQ0hFTUEpO1xuICAgIGlmICh2YWxpZGF0aW9uLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBtdXN0IGNvbmZvcm0gdG8gRUlQLTcxMiBzY2hlbWEuIFNlZSBodHRwczovL2dpdC5pby9mTnRjeC4nKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlVHlwZWRTaWduTWVzc2FnZURhdGFWMyA9IHZhbGlkYXRlVHlwZWRTaWduTWVzc2FnZURhdGFWMztcbi8qKlxuICogVmFsaWRhdGVzIGEgRVJDMjAgdG9rZW4gdG8gYmUgYWRkZWQgd2l0aCBFSVA3NDcuXG4gKlxuICogQHBhcmFtIHRva2VuIC0gVG9rZW4gb2JqZWN0IHRvIHZhbGlkYXRlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVG9rZW5Ub1dhdGNoKHRva2VuKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBzeW1ib2wsIGRlY2ltYWxzIH0gPSB0b2tlbjtcbiAgICBpZiAoIWFkZHJlc3MgfHwgIXN5bWJvbCB8fCB0eXBlb2YgZGVjaW1hbHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKGBNdXN0IHNwZWNpZnkgYWRkcmVzcywgc3ltYm9sLCBhbmQgZGVjaW1hbHMuYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3ltYm9sICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhgSW52YWxpZCBzeW1ib2w6IG5vdCBhIHN0cmluZy5gKTtcbiAgICB9XG4gICAgaWYgKHN5bWJvbC5sZW5ndGggPiAxMSkge1xuICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhgSW52YWxpZCBzeW1ib2wgXCIke3N5bWJvbH1cIjogbG9uZ2VyIHRoYW4gMTEgY2hhcmFjdGVycy5gKTtcbiAgICB9XG4gICAgY29uc3QgbnVtRGVjaW1hbHMgPSBwYXJzZUludChkZWNpbWFscywgMTApO1xuICAgIGlmIChpc05hTihudW1EZWNpbWFscykgfHwgbnVtRGVjaW1hbHMgPiAzNiB8fCBudW1EZWNpbWFscyA8IDApIHtcbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoYEludmFsaWQgZGVjaW1hbHMgXCIke2RlY2ltYWxzfVwiOiBtdXN0IGJlIDAgPD0gMzYuYCk7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZEhleEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoYEludmFsaWQgYWRkcmVzcyBcIiR7YWRkcmVzc31cIi5gKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlVG9rZW5Ub1dhdGNoID0gdmFsaWRhdGVUb2tlblRvV2F0Y2g7XG4vKipcbiAqIFJldHVybnMgd2V0aGVyIHRoZSBnaXZlbiBjb2RlIGNvcnJlc3BvbmRzIHRvIGEgc21hcnQgY29udHJhY3RcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIENvcnJlc3BvbmRpbmcgY29kZSB0byByZXZpZXdcbiAqL1xuZnVuY3Rpb24gaXNTbWFydENvbnRyYWN0Q29kZShjb2RlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gR2V0aCB3aWxsIHJldHVybiAnMHgnLCBhbmQgZ2FuYWNoZS1jb3JlIHYyLjIuMSB3aWxsIHJldHVybiAnMHgwJ1xuICAgIGNvbnN0IHNtYXJ0Q29udHJhY3RDb2RlID0gY29kZSAhPT0gJzB4JyAmJiBjb2RlICE9PSAnMHgwJztcbiAgICByZXR1cm4gc21hcnRDb250cmFjdENvZGU7XG59XG5leHBvcnRzLmlzU21hcnRDb250cmFjdENvZGUgPSBpc1NtYXJ0Q29udHJhY3RDb2RlO1xuLyoqXG4gKiBFeGVjdXRlIGZldGNoIGFuZCB2ZXJpZnkgdGhhdCB0aGUgcmVzcG9uc2Ugd2FzIHN1Y2Nlc3NmdWxcbiAqXG4gKiBAcGFyYW0gcmVxdWVzdCAtIFJlcXVlc3QgaW5mb3JtYXRpb25cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uc1xuICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgZmV0Y2ggcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gc3VjY2Vzc2Z1bEZldGNoKHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGZldGNoKHJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZldGNoIGZhaWxlZCB3aXRoIHN0YXR1cyAnJHtyZXNwb25zZS5zdGF0dXN9JyBmb3IgcmVxdWVzdCAnJHtyZXF1ZXN0fSdgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSk7XG59XG5leHBvcnRzLnN1Y2Nlc3NmdWxGZXRjaCA9IHN1Y2Nlc3NmdWxGZXRjaDtcbi8qKlxuICogRXhlY3V0ZSBmZXRjaCBhbmQgcmV0dXJuIG9iamVjdCByZXNwb25zZVxuICpcbiAqIEBwYXJhbSByZXF1ZXN0IC0gUmVxdWVzdCBpbmZvcm1hdGlvblxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zXG4gKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSByZXN1bHQgb2JqZWN0IG9mIGZldGNoXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUZldGNoKHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHN1Y2Nlc3NmdWxGZXRjaChyZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0geWllbGQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xufVxuZXhwb3J0cy5oYW5kbGVGZXRjaCA9IGhhbmRsZUZldGNoO1xuLyoqXG4gKiBGZXRjaCB0aGF0IGZhaWxzIGFmdGVyIHRpbWVvdXRcbiAqXG4gKiBAcGFyYW0gdXJsIC0gVXJsIHRvIGZldGNoXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gc2VuZCB3aXRoIHRoZSByZXF1ZXN0XG4gKiBAcGFyYW0gdGltZW91dCAtIFRpbWVvdXQgdG8gZmFpbCByZXF1ZXN0XG4gKlxuICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0aGUgcmVxdWVzdFxuICovXG5mdW5jdGlvbiB0aW1lb3V0RmV0Y2godXJsLCBvcHRpb25zLCB0aW1lb3V0ID0gNTAwKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICAgICAgICBzdWNjZXNzZnVsRmV0Y2godXJsLCBvcHRpb25zKSxcbiAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ3RpbWVvdXQnKSk7XG4gICAgICAgICAgICB9LCB0aW1lb3V0KSksXG4gICAgICAgIF0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy50aW1lb3V0RmV0Y2ggPSB0aW1lb3V0RmV0Y2g7XG4vKipcbiAqIE5vcm1hbGl6ZXMgdGhlIGdpdmVuIEVOUyBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbnNOYW1lIC0gVGhlIEVOUyBuYW1lXG4gKlxuICogQHJldHVybnMgLSB0aGUgbm9ybWFsaXplZCBFTlMgbmFtZSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRW5zTmFtZShlbnNOYW1lKSB7XG4gICAgaWYgKGVuc05hbWUgJiYgdHlwZW9mIGVuc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gZXRoX2Vuc19uYW1laGFzaF8xLmRlZmF1bHQubm9ybWFsaXplKGVuc05hbWUudHJpbSgpKTtcbiAgICAgICAgICAgIC8vIHRoaXMgcmVnZXggaXMgb25seSBzdWZmaWNpZW50IHdpdGggdGhlIGFib3ZlIGNhbGwgdG8gZW5zTmFtZWhhc2gubm9ybWFsaXplXG4gICAgICAgICAgICAvLyBUT0RPOiBjaGFuZ2UgNyBpbiByZWdleCB0byAzIHdoZW4gc2hvcnRlciBFTlMgZG9tYWlucyBhcmUgbGl2ZVxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQubWF0Y2goL14oKFtcXHdcXGQtXSspXFwuKSpbXFx3XFxkLV17Nyx9XFwuKGV0aHx0ZXN0KSQvdSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5ub3JtYWxpemVFbnNOYW1lID0gbm9ybWFsaXplRW5zTmFtZTtcbi8qKlxuICogV3JhcHBlciBtZXRob2QgdG8gaGFuZGxlIEV0aFF1ZXJ5IHJlcXVlc3RzXG4gKlxuICogQHBhcmFtIGV0aFF1ZXJ5IC0gRXRoUXVlcnkgb2JqZWN0IGluaXRpYWxpemVkIHdpdGggYSBwcm92aWRlclxuICogQHBhcmFtIG1ldGhvZCAtIE1ldGhvZCB0byByZXF1ZXN0XG4gKiBAcGFyYW0gYXJncyAtIEFyZ3VtZW50cyB0byBzZW5kXG4gKlxuICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0aGUgcmVxdWVzdFxuICovXG5mdW5jdGlvbiBxdWVyeShldGhRdWVyeSwgbWV0aG9kLCBhcmdzID0gW10pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBldGhRdWVyeVttZXRob2RdKC4uLmFyZ3MsIChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnF1ZXJ5ID0gcXVlcnk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHRyYW5zYWN0aW9uIGlzIEVJUC0xNTU5IGJ5IGNoZWNraW5nIGZvciB0aGUgZXhpc3RlbmNlIG9mXG4gKiBtYXhGZWVQZXJHYXMgYW5kIG1heFByaW9yaXR5RmVlUGVyR2FzIHdpdGhpbiBpdHMgcGFyYW1ldGVyc1xuICpcbiAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRyYW5zYWN0aW9uIG9iamVjdCB0byBhZGRcbiAqIEByZXR1cm5zIC0gQm9vbGVhbiB0aGF0IGlzIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIEVJUC0xNTU5IChoYXMgbWF4RmVlUGVyR2FzIGFuZCBtYXhQcmlvcml0eUZlZVBlckdhcyksIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlXG4gKi9cbmNvbnN0IGlzRUlQMTU1OVRyYW5zYWN0aW9uID0gKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgaGFzT3duUHJvcCA9IChvYmosIGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgICByZXR1cm4gKGhhc093blByb3AodHJhbnNhY3Rpb24sICdtYXhGZWVQZXJHYXMnKSAmJlxuICAgICAgICBoYXNPd25Qcm9wKHRyYW5zYWN0aW9uLCAnbWF4UHJpb3JpdHlGZWVQZXJHYXMnKSk7XG59O1xuZXhwb3J0cy5pc0VJUDE1NTlUcmFuc2FjdGlvbiA9IGlzRUlQMTU1OVRyYW5zYWN0aW9uO1xuY29uc3QgY29udmVydFByaWNlVG9EZWNpbWFsID0gKHZhbHVlKSA9PiBwYXJzZUludCh2YWx1ZSA9PT0gdW5kZWZpbmVkID8gJzB4MCcgOiB2YWx1ZSwgMTYpO1xuZXhwb3J0cy5jb252ZXJ0UHJpY2VUb0RlY2ltYWwgPSBjb252ZXJ0UHJpY2VUb0RlY2ltYWw7XG5jb25zdCBnZXRJbmNyZWFzZWRQcmljZUhleCA9ICh2YWx1ZSwgcmF0ZSkgPT4gZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KGAke3BhcnNlSW50KGAke3ZhbHVlICogcmF0ZX1gLCAxMCkudG9TdHJpbmcoMTYpfWApO1xuZXhwb3J0cy5nZXRJbmNyZWFzZWRQcmljZUhleCA9IGdldEluY3JlYXNlZFByaWNlSGV4O1xuY29uc3QgZ2V0SW5jcmVhc2VkUHJpY2VGcm9tRXhpc3RpbmcgPSAodmFsdWUsIHJhdGUpID0+IHtcbiAgICByZXR1cm4gZXhwb3J0cy5nZXRJbmNyZWFzZWRQcmljZUhleChleHBvcnRzLmNvbnZlcnRQcmljZVRvRGVjaW1hbCh2YWx1ZSksIHJhdGUpO1xufTtcbmV4cG9ydHMuZ2V0SW5jcmVhc2VkUHJpY2VGcm9tRXhpc3RpbmcgPSBnZXRJbmNyZWFzZWRQcmljZUZyb21FeGlzdGluZztcbmNvbnN0IHZhbGlkYXRlR2FzVmFsdWVzID0gKGdhc1ZhbHVlcykgPT4ge1xuICAgIE9iamVjdC5rZXlzKGdhc1ZhbHVlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2FzVmFsdWVzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICFldGhlcmV1bWpzX3V0aWxfMS5pc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIGhleCBzdHJpbmcgZm9yICR7a2V5fSBidXQgcmVjZWl2ZWQ6ICR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5leHBvcnRzLnZhbGlkYXRlR2FzVmFsdWVzID0gdmFsaWRhdGVHYXNWYWx1ZXM7XG5jb25zdCBpc0ZlZU1hcmtldEVJUDE1NTlWYWx1ZXMgPSAoZ2FzVmFsdWVzKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKChfYSA9IGdhc1ZhbHVlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1heEZlZVBlckdhcykgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAoKF9iID0gZ2FzVmFsdWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWF4UHJpb3JpdHlGZWVQZXJHYXMpICE9PSB1bmRlZmluZWQ7XG59O1xuZXhwb3J0cy5pc0ZlZU1hcmtldEVJUDE1NTlWYWx1ZXMgPSBpc0ZlZU1hcmtldEVJUDE1NTlWYWx1ZXM7XG5jb25zdCBpc0dhc1ByaWNlVmFsdWUgPSAoZ2FzVmFsdWVzKSA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSBnYXNWYWx1ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nYXNQcmljZSkgIT09IHVuZGVmaW5lZDsgfTtcbmV4cG9ydHMuaXNHYXNQcmljZVZhbHVlID0gaXNHYXNQcmljZVZhbHVlO1xuZnVuY3Rpb24gdmFsaWRhdGVNaW5pbXVtSW5jcmVhc2UocHJvcG9zZWQsIG1pbikge1xuICAgIGNvbnN0IHByb3Bvc2VkRGVjaW1hbCA9IGV4cG9ydHMuY29udmVydFByaWNlVG9EZWNpbWFsKHByb3Bvc2VkKTtcbiAgICBjb25zdCBtaW5EZWNpbWFsID0gZXhwb3J0cy5jb252ZXJ0UHJpY2VUb0RlY2ltYWwobWluKTtcbiAgICBpZiAocHJvcG9zZWREZWNpbWFsID49IG1pbkRlY2ltYWwpIHtcbiAgICAgICAgcmV0dXJuIHByb3Bvc2VkO1xuICAgIH1cbiAgICBjb25zdCBlcnJvck1zZyA9IGBUaGUgcHJvcG9zZWQgdmFsdWU6ICR7cHJvcG9zZWREZWNpbWFsfSBzaG91bGQgbWVldCBvciBleGNlZWQgdGhlIG1pbmltdW0gdmFsdWU6ICR7bWluRGVjaW1hbH1gO1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG59XG5leHBvcnRzLnZhbGlkYXRlTWluaW11bUluY3JlYXNlID0gdmFsaWRhdGVNaW5pbXVtSW5jcmVhc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRva2VuTGlzdENvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBjb250cmFjdF9tZXRhZGF0YV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAbWV0YW1hc2svY29udHJhY3QtbWV0YWRhdGFcIikpO1xuY29uc3QgYXN5bmNfbXV0ZXhfMSA9IHJlcXVpcmUoXCJhc3luYy1tdXRleFwiKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbmFtZWQtYXMtZGVmYXVsdFxuY29uc3QgYWJvcnRfY29udHJvbGxlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhYm9ydC1jb250cm9sbGVyXCIpKTtcbmNvbnN0IEJhc2VDb250cm9sbGVyVjJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclYyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCB0b2tlbl9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vYXBpcy90b2tlbi1zZXJ2aWNlXCIpO1xuY29uc3QgREVGQVVMVF9JTlRFUlZBTCA9IDYwICogNjAgKiAxMDAwO1xuY29uc3QgREVGQVVMVF9USFJFU0hPTEQgPSA2MCAqIDMwICogMTAwMDtcbmNvbnN0IG5hbWUgPSAnVG9rZW5MaXN0Q29udHJvbGxlcic7XG5jb25zdCBtZXRhZGF0YSA9IHtcbiAgICB0b2tlbkxpc3Q6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiB0cnVlIH0sXG4gICAgdG9rZW5zQ2hhaW5zQ2FjaGU6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiB0cnVlIH0sXG59O1xuY29uc3QgZGVmYXVsdFN0YXRlID0ge1xuICAgIHRva2VuTGlzdDoge30sXG4gICAgdG9rZW5zQ2hhaW5zQ2FjaGU6IHt9LFxufTtcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IHBhc3NpdmVseSBwb2xscyBvbiBhIHNldCBpbnRlcnZhbCBmb3IgdGhlIGxpc3Qgb2YgdG9rZW5zIGZyb20gbWV0YXN3YXBzIGFwaVxuICovXG5jbGFzcyBUb2tlbkxpc3RDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJWMl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvLyBwcml2YXRlIGFib3J0U2lnbmFsOiBBYm9ydFNpZ25hbDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVG9rZW5MaXN0Q29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBDb25zdHJ1Y3RvciBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaW50ZXJ2YWwgLSBUaGUgcG9sbGluZyBpbnRlcnZhbCwgaW4gbWlsbGlzZWNvbmRzXG4gICAgICogQHBhcmFtIG9wdGlvbnMubWVzc2VuZ2VyIC0gQSByZWZlcmVuY2UgdG8gdGhlIG1lc3NhZ2luZyBzeXN0ZW1cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgY2hhaW5JZCwgdXNlU3RhdGljVG9rZW5MaXN0LCBvbk5ldHdvcmtTdGF0ZUNoYW5nZSwgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlLCBpbnRlcnZhbCA9IERFRkFVTFRfSU5URVJWQUwsIGNhY2hlUmVmcmVzaFRocmVzaG9sZCA9IERFRkFVTFRfVEhSRVNIT0xELCBtZXNzZW5nZXIsIHN0YXRlLCB9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIG1lc3NlbmdlcixcbiAgICAgICAgICAgIHN0YXRlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTdGF0ZSksIHN0YXRlKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubXV0ZXggPSBuZXcgYXN5bmNfbXV0ZXhfMS5NdXRleCgpO1xuICAgICAgICB0aGlzLmludGVydmFsRGVsYXkgPSBpbnRlcnZhbDtcbiAgICAgICAgdGhpcy5jYWNoZVJlZnJlc2hUaHJlc2hvbGQgPSBjYWNoZVJlZnJlc2hUaHJlc2hvbGQ7XG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIHRoaXMudXNlU3RhdGljVG9rZW5MaXN0ID0gdXNlU3RhdGljVG9rZW5MaXN0O1xuICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IG5ldyBhYm9ydF9jb250cm9sbGVyXzEuZGVmYXVsdCgpO1xuICAgICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZSgobmV0d29ya1N0YXRlKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFpbklkICE9PSBuZXR3b3JrU3RhdGUucHJvdmlkZXIuY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBuZXcgYWJvcnRfY29udHJvbGxlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYWluSWQgPSBuZXR3b3JrU3RhdGUucHJvdmlkZXIuY2hhaW5JZDtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UoKHByZWZlcmVuY2VzU3RhdGUpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZVN0YXRpY1Rva2VuTGlzdCAhPT0gcHJlZmVyZW5jZXNTdGF0ZS51c2VTdGF0aWNUb2tlbkxpc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbmV3IGFib3J0X2NvbnRyb2xsZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy51c2VTdGF0aWNUb2tlbkxpc3QgPSBwcmVmZXJlbmNlc1N0YXRlLnVzZVN0YXRpY1Rva2VuTGlzdDtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBwb2xsaW5nIGZvciB0aGUgdG9rZW4gbGlzdFxuICAgICAqL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zdGFydFBvbGxpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3RhcnQgcG9sbGluZyBmb3IgdGhlIHRva2VuIGxpc3RcbiAgICAgKi9cbiAgICByZXN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wUG9sbGluZygpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zdGFydFBvbGxpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgcG9sbGluZyBmb3IgdGhlIHRva2VuIGxpc3RcbiAgICAgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdG8gZGlzY2FyZCB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHN0b3BzIGFueSBhY3RpdmUgcG9sbGluZy5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc3RvcFBvbGxpbmcoKTtcbiAgICB9XG4gICAgc3RvcFBvbGxpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVydmFsSWQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBuZXcgcG9sbGluZyBpbnRlcnZhbFxuICAgICAqL1xuICAgIHN0YXJ0UG9sbGluZygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IHRoaXMuZmV0Y2hUb2tlbkxpc3QoKSk7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdXRpbF8xLnNhZmVseUV4ZWN1dGUoKCkgPT4gdGhpcy5mZXRjaFRva2VuTGlzdCgpKTtcbiAgICAgICAgICAgIH0pLCB0aGlzLmludGVydmFsRGVsYXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hpbmcgdG9rZW4gbGlzdFxuICAgICAqL1xuICAgIGZldGNoVG9rZW5MaXN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlU3RhdGljVG9rZW5MaXN0KSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5mZXRjaEZyb21TdGF0aWNUb2tlbkxpc3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZmV0Y2hGcm9tRHluYW1pY1Rva2VuTGlzdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hpbmcgdG9rZW4gbGlzdCBmcm9tIHRoZSBjb250cmFjdC1tZXRhZGF0YSBhcyBhIGZhbGxiYWNrXG4gICAgICovXG4gICAgZmV0Y2hGcm9tU3RhdGljVG9rZW5MaXN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5MaXN0ID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuQWRkcmVzcyBpbiBjb250cmFjdF9tZXRhZGF0YV8xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfYSA9IGNvbnRyYWN0X21ldGFkYXRhXzEuZGVmYXVsdFt0b2tlbkFkZHJlc3NdLCB7IGVyYzIwLCBsb2dvOiBmaWxlUGF0aCB9ID0gX2EsIHRva2VuID0gX19yZXN0KF9hLCBbXCJlcmMyMFwiLCBcImxvZ29cIl0pO1xuICAgICAgICAgICAgICAgIGlmIChlcmMyMCkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbkxpc3RbdG9rZW5BZGRyZXNzXSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdG9rZW4pLCB7IGFkZHJlc3M6IHRva2VuQWRkcmVzcywgaWNvblVybDogZmlsZVBhdGgsIG9jY3VycmVuY2VzOiBudWxsIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbkxpc3QsXG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc0NoYWluc0NhY2hlOiB7fSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGluZyB0b2tlbiBsaXN0IGZyb20gdGhlIFRva2VuIFNlcnZpY2UgQVBJXG4gICAgICovXG4gICAgZmV0Y2hGcm9tRHluYW1pY1Rva2VuTGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VMb2NrID0geWllbGQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZFRva2VucyA9IHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IHRoaXMuZmV0Y2hGcm9tQ2FjaGUoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgX2EgPSB0aGlzLnN0YXRlLCB7IHRva2Vuc0NoYWluc0NhY2hlIH0gPSBfYSwgdG9rZW5zRGF0YSA9IF9fcmVzdChfYSwgW1widG9rZW5zQ2hhaW5zQ2FjaGVcIl0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuTGlzdCA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBjYWNoZWRUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuTGlzdFt0b2tlbi5hZGRyZXNzXSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbnNGcm9tQVBJID0geWllbGQgdXRpbF8xLnNhZmVseUV4ZWN1dGUoKCkgPT4gdG9rZW5fc2VydmljZV8xLmZldGNoVG9rZW5MaXN0KHRoaXMuY2hhaW5JZCwgdGhpcy5hYm9ydENvbnRyb2xsZXIuc2lnbmFsKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdG9rZW5zRnJvbUFQSSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFja3VwVG9rZW5MaXN0ID0gdG9rZW5zQ2hhaW5zQ2FjaGVbdGhpcy5jaGFpbklkXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdG9rZW5zQ2hhaW5zQ2FjaGVbdGhpcy5jaGFpbklkXS5kYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgYmFja3VwVG9rZW5MaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5MaXN0W3Rva2VuLmFkZHJlc3NdID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdG9rZW5zRGF0YSksIHsgdG9rZW5MaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnNDaGFpbnNDYWNoZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbHRlcmluZyBvdXQgdG9rZW5zIHdpdGggbGVzcyB0aGFuIDIgb2NjdXJyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRUb2tlbkxpc3QgPSB0b2tlbnNGcm9tQVBJLmZpbHRlcigodG9rZW4pID0+IHRva2VuLm9jY3VycmVuY2VzICYmIHRva2VuLm9jY3VycmVuY2VzID49IDIpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmluZyB0aGUgdG9rZW5zIHdpdGggc3ltYm9sIGNvbmZsaWN0c1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzeW1ib2xzTGlzdCA9IGZpbHRlcmVkVG9rZW5MaXN0Lm1hcCgodG9rZW4pID0+IHRva2VuLnN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR1cGxpY2F0ZVN5bWJvbHMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5uZXcgU2V0KHN5bWJvbHNMaXN0LmZpbHRlcigoc3ltYm9sLCBpbmRleCkgPT4gc3ltYm9sc0xpc3QuaW5kZXhPZihzeW1ib2wpICE9PSBpbmRleCkpLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1bmlxdWVUb2tlbkxpc3QgPSBmaWx0ZXJlZFRva2VuTGlzdC5maWx0ZXIoKHRva2VuKSA9PiAhZHVwbGljYXRlU3ltYm9scy5pbmNsdWRlcyh0b2tlbi5zeW1ib2wpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiB1bmlxdWVUb2tlbkxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuTGlzdFt0b2tlbi5hZGRyZXNzXSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUb2tlbnNDaGFpbnNDYWNoZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdG9rZW5zQ2hhaW5zQ2FjaGUpLCB7IFt0aGlzLmNoYWluSWRdOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QudmFsdWVzKHRva2VuTGlzdCksXG4gICAgICAgICAgICAgICAgICAgIH0gfSk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0b2tlbnNEYXRhKSwgeyB0b2tlbkxpc3QsIHRva2Vuc0NoYWluc0NhY2hlOiB1cGRhdGVkVG9rZW5zQ2hhaW5zQ2FjaGUgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBDYWNoZSB0aW1lc3RhbXAgaXMgdmFsaWQsXG4gICAgICogIGlmIHllcyBkYXRhIGluIGNhY2hlIHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgKiAgb3RoZXJ3aXNlIG51bGwgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgaW50byBUb2tlbkxpc3RUb2tlbltdIG9yIG51bGxcbiAgICAgKi9cbiAgICBmZXRjaEZyb21DYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdG9rZW5zQ2hhaW5zQ2FjaGUgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBkYXRhQ2FjaGUgPSB0b2tlbnNDaGFpbnNDYWNoZVt0aGlzLmNoYWluSWRdO1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGlmICgoZGF0YUNhY2hlID09PSBudWxsIHx8IGRhdGFDYWNoZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YUNhY2hlLmRhdGEpICYmXG4gICAgICAgICAgICAgICAgbm93IC0gKGRhdGFDYWNoZSA9PT0gbnVsbCB8fCBkYXRhQ2FjaGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGFDYWNoZS50aW1lc3RhbXApIDwgdGhpcy5jYWNoZVJlZnJlc2hUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YUNhY2hlLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIG1ldGFkYXRhIGZvciBhIHRva2VuIHdob3NlIGFkZHJlc3MgaXMgc2VuZCB0byB0aGUgQVBJXG4gICAgICogQHBhcmFtIHRva2VuQWRkcmVzc1xuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBUb2tlbiBNZXRhZGF0YVxuICAgICAqL1xuICAgIGZldGNoVG9rZW5NZXRhZGF0YSh0b2tlbkFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VMb2NrID0geWllbGQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuID0gKHlpZWxkIHRva2VuX3NlcnZpY2VfMS5mZXRjaFRva2VuTWV0YWRhdGEodGhpcy5jaGFpbklkLCB0b2tlbkFkZHJlc3MsIHRoaXMuYWJvcnRDb250cm9sbGVyLnNpZ25hbCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuVG9rZW5MaXN0Q29udHJvbGxlciA9IFRva2VuTGlzdENvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBUb2tlbkxpc3RDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VG9rZW5MaXN0Q29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ub2tlbnNDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgY29udHJhY3RfbWV0YWRhdGFfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQG1ldGFtYXNrL2NvbnRyYWN0LW1ldGFkYXRhXCIpKTtcbmNvbnN0IGh1bWFuX3N0YW5kYXJkX2NvbGxlY3RpYmxlX2FiaV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJodW1hbi1zdGFuZGFyZC1jb2xsZWN0aWJsZS1hYmlcIikpO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG5jb25zdCBhc3luY19tdXRleF8xID0gcmVxdWlyZShcImFzeW5jLW11dGV4XCIpO1xuY29uc3QgZXRoZXJzXzEgPSByZXF1aXJlKFwiZXRoZXJzXCIpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuY29uc3QgRVJDNzIxX0lOVEVSRkFDRV9JRCA9ICcweDgwYWM1OGNkJztcbnZhciBTdWdnZXN0ZWRBc3NldFN0YXR1cztcbihmdW5jdGlvbiAoU3VnZ2VzdGVkQXNzZXRTdGF0dXMpIHtcbiAgICBTdWdnZXN0ZWRBc3NldFN0YXR1c1tcImFjY2VwdGVkXCJdID0gXCJhY2NlcHRlZFwiO1xuICAgIFN1Z2dlc3RlZEFzc2V0U3RhdHVzW1wiZmFpbGVkXCJdID0gXCJmYWlsZWRcIjtcbiAgICBTdWdnZXN0ZWRBc3NldFN0YXR1c1tcInBlbmRpbmdcIl0gPSBcInBlbmRpbmdcIjtcbiAgICBTdWdnZXN0ZWRBc3NldFN0YXR1c1tcInJlamVjdGVkXCJdID0gXCJyZWplY3RlZFwiO1xufSkoU3VnZ2VzdGVkQXNzZXRTdGF0dXMgfHwgKFN1Z2dlc3RlZEFzc2V0U3RhdHVzID0ge30pKTtcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IHN0b3JlcyBhc3NldHMgYW5kIGV4cG9zZXMgY29udmVuaWVuY2UgbWV0aG9kc1xuICovXG5jbGFzcyBUb2tlbnNDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFRva2Vuc0NvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIHByZWZlcmVuY2UgY29udHJvbGxlciBzdGF0ZSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25OZXR3b3JrU3RhdGVDaGFuZ2UgLSBBbGxvd3Mgc3Vic2NyaWJpbmcgdG8gbmV0d29yayBjb250cm9sbGVyIHN0YXRlIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlLCBvbk5ldHdvcmtTdGF0ZUNoYW5nZSwgY29uZmlnLCBzdGF0ZSwgfSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5tdXRleCA9IG5ldyBhc3luY19tdXRleF8xLk11dGV4KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudEVtaXR0ZXIgaW5zdGFuY2UgdXNlZCB0byBsaXN0ZW4gdG8gc3BlY2lmaWMgRUlQNzQ3IGV2ZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5odWIgPSBuZXcgZXZlbnRzXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ1Rva2Vuc0NvbnRyb2xsZXInO1xuICAgICAgICB0aGlzLmRlZmF1bHRDb25maWcgPSBPYmplY3QuYXNzaWduKHsgbmV0d29ya1R5cGU6IGNvbnN0YW50c18xLk1BSU5ORVQsIHNlbGVjdGVkQWRkcmVzczogJycsIGNoYWluSWQ6ICcnLCBwcm92aWRlcjogdW5kZWZpbmVkIH0sIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXRlID0gT2JqZWN0LmFzc2lnbih7IGFsbFRva2Vuczoge30sIGFsbElnbm9yZWRUb2tlbnM6IHt9LCBpZ25vcmVkVG9rZW5zOiBbXSwgc3VnZ2VzdGVkQXNzZXRzOiBbXSwgdG9rZW5zOiBbXSB9LCBzdGF0ZSk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UoKHsgc2VsZWN0ZWRBZGRyZXNzIH0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCB7IGFsbFRva2VucywgYWxsSWdub3JlZFRva2VucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IHNlbGVjdGVkQWRkcmVzcyB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICB0b2tlbnM6ICgoX2EgPSBhbGxUb2tlbnNbY2hhaW5JZF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtzZWxlY3RlZEFkZHJlc3NdKSB8fCBbXSxcbiAgICAgICAgICAgICAgICBpZ25vcmVkVG9rZW5zOiAoKF9iID0gYWxsSWdub3JlZFRva2Vuc1tjaGFpbklkXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW3NlbGVjdGVkQWRkcmVzc10pIHx8IFtdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZSgoeyBwcm92aWRlciB9KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3QgeyBhbGxUb2tlbnMsIGFsbElnbm9yZWRUb2tlbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB7IHNlbGVjdGVkQWRkcmVzcyB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICBjb25zdCB7IGNoYWluSWQgfSA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmUoeyBjaGFpbklkIH0pO1xuICAgICAgICAgICAgdGhpcy5ldGhlcnNQcm92aWRlciA9IHRoaXMuX2luc3RhbnRpYXRlTmV3RXRoZXJzUHJvdmlkZXIoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICB0b2tlbnM6ICgoX2EgPSBhbGxUb2tlbnNbY2hhaW5JZF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtzZWxlY3RlZEFkZHJlc3NdKSB8fCBbXSxcbiAgICAgICAgICAgICAgICBpZ25vcmVkVG9rZW5zOiAoKF9iID0gYWxsSWdub3JlZFRva2Vuc1tjaGFpbklkXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW3NlbGVjdGVkQWRkcmVzc10pIHx8IFtdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmYWlsU3VnZ2VzdGVkQXNzZXQoc3VnZ2VzdGVkQXNzZXRNZXRhLCBlcnJvcikge1xuICAgICAgICBjb25zdCBmYWlsZWRTdWdnZXN0ZWRBc3NldE1ldGEgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN1Z2dlc3RlZEFzc2V0TWV0YSksIHsgc3RhdHVzOiBTdWdnZXN0ZWRBc3NldFN0YXR1cy5mYWlsZWQsIGVycm9yIH0pO1xuICAgICAgICB0aGlzLmh1Yi5lbWl0KGAke3N1Z2dlc3RlZEFzc2V0TWV0YS5pZH06ZmluaXNoZWRgLCBmYWlsZWRTdWdnZXN0ZWRBc3NldE1ldGEpO1xuICAgIH1cbiAgICBfaW5zdGFudGlhdGVOZXdFdGhlcnNQcm92aWRlcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gbmV3IGV0aGVyc18xLmV0aGVycy5wcm92aWRlcnMuV2ViM1Byb3ZpZGVyKChfYSA9IHRoaXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdG9rZW4gdG8gdGhlIHN0b3JlZCB0b2tlbiBsaXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSB0b2tlbiBjb250cmFjdFxuICAgICAqIEBwYXJhbSBzeW1ib2wgLSBTeW1ib2wgb2YgdGhlIHRva2VuXG4gICAgICogQHBhcmFtIGRlY2ltYWxzIC0gTnVtYmVyIG9mIGRlY2ltYWxzIHRoZSB0b2tlbiB1c2VzXG4gICAgICogQHBhcmFtIGltYWdlIC0gSW1hZ2Ugb2YgdGhlIHRva2VuXG4gICAgICogQHJldHVybnMgLSBDdXJyZW50IHRva2VuIGxpc3RcbiAgICAgKi9cbiAgICBhZGRUb2tlbihhZGRyZXNzLCBzeW1ib2wsIGRlY2ltYWxzLCBpbWFnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVsZWFzZUxvY2sgPSB5aWVsZCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRva2VucywgaWdub3JlZFRva2VucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0VSQzcyMSA9IHlpZWxkIHRoaXMuX2RldGVjdElzRVJDNzIxKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0VudHJ5ID0geyBhZGRyZXNzLCBzeW1ib2wsIGRlY2ltYWxzLCBpbWFnZSwgaXNFUkM3MjEgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0VudHJ5ID0gdG9rZW5zLmZpbmQoKHRva2VuKSA9PiB0b2tlbi5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRva2Vucy5pbmRleE9mKHByZXZpb3VzRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbcHJldmlvdXNJbmRleF0gPSBuZXdFbnRyeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKG5ld0VudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SWdub3JlZFRva2VucyA9IGlnbm9yZWRUb2tlbnMuZmlsdGVyKCh0b2tlbkFkZHJlc3MpID0+IHRva2VuQWRkcmVzcy50b0xvd2VyQ2FzZSgpICE9PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbmV3QWxsVG9rZW5zLCBuZXdBbGxJZ25vcmVkVG9rZW5zIH0gPSB0aGlzLl9nZXROZXdBbGxUb2tlbnNTdGF0ZSh0b2tlbnMsIG5ld0lnbm9yZWRUb2tlbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgYWxsVG9rZW5zOiBuZXdBbGxUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgYWxsSWdub3JlZFRva2VuczogbmV3QWxsSWdub3JlZFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgaWdub3JlZFRva2VuczogbmV3SWdub3JlZFRva2VucyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBiYXRjaCBvZiB0b2tlbnMgdG8gdGhlIHN0b3JlZCB0b2tlbiBsaXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW5zIC0gQXJyYXkgb2YgVG9rZW5zIHRvIGJlIGFkZGVkIG9yIHVwZGF0ZWRcbiAgICAgKiBAcmV0dXJucyAtIEN1cnJlbnQgdG9rZW4gbGlzdFxuICAgICAqL1xuICAgIGFkZFRva2Vucyh0b2tlbnNUb0FkZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVsZWFzZUxvY2sgPSB5aWVsZCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgdG9rZW5zLCBpZ25vcmVkVG9rZW5zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0b2tlbnNUb0FkZCA9IHlpZWxkIFByb21pc2UuYWxsKHRva2Vuc1RvQWRkLm1hcCgodG9rZW4pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uaXNFUkM3MjEgPSB5aWVsZCB0aGlzLl9kZXRlY3RJc0VSQzcyMSh0b2tlbi5hZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgICAgbGV0IG5ld0lnbm9yZWRUb2tlbnMgPSBpZ25vcmVkVG9rZW5zO1xuICAgICAgICAgICAgICAgIHRva2Vuc1RvQWRkLmZvckVhY2goKHRva2VuVG9BZGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBhZGRyZXNzLCBzeW1ib2wsIGRlY2ltYWxzLCBpbWFnZSwgaXNFUkM3MjEgfSA9IHRva2VuVG9BZGQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtQWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3RW50cnkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNpbWFscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFUkM3MjEsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRW50cnkgPSB0b2tlbnMuZmluZCgodG9rZW4pID0+IHRva2VuLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gY2hlY2tzdW1BZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRva2Vucy5pbmRleE9mKHByZXZpb3VzRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zW3ByZXZpb3VzSW5kZXhdID0gbmV3RW50cnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaChuZXdFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV3SWdub3JlZFRva2VucyA9IG5ld0lnbm9yZWRUb2tlbnMuZmlsdGVyKCh0b2tlbkFkZHJlc3MpID0+IHRva2VuQWRkcmVzcy50b0xvd2VyQ2FzZSgpICE9PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbmV3QWxsVG9rZW5zLCBuZXdBbGxJZ25vcmVkVG9rZW5zIH0gPSB0aGlzLl9nZXROZXdBbGxUb2tlbnNTdGF0ZSh0b2tlbnMsIG5ld0lnbm9yZWRUb2tlbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBhbGxUb2tlbnM6IG5ld0FsbFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgYWxsSWdub3JlZFRva2VuczogbmV3QWxsSWdub3JlZFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgaWdub3JlZFRva2VuczogbmV3SWdub3JlZFRva2VucyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgaXNFUkM3MjEgZmllbGQgdG8gdG9rZW4gb2JqZWN0XG4gICAgICogKENhbGxlZCB3aGVuIGEgdXNlciBhdHRlbXB0cyB0byBhZGQgdG9rZW5zIHRoYXQgd2VyZSBwcmV2aW91c2x5IGFkZGVkIHdoaWNoIGRvIG5vdCB5ZXQgaGFkIGlzRVJDNzIxIGZpZWxkKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuQWRkcmVzcyAtIFRoZSBjb250cmFjdCBhZGRyZXNzIG9mIHRoZSB0b2tlbiByZXF1aXJpbmcgdGhlIGlzRVJDNzIxIGZpZWxkIGFkZGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBuZXcgdG9rZW4gb2JqZWN0IHdpdGggdGhlIGFkZGVkIGlzRVJDNzIxIGZpZWxkLlxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlVG9rZW5UeXBlKHRva2VuQWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgaXNFUkM3MjEgPSB5aWVsZCB0aGlzLl9kZXRlY3RJc0VSQzcyMSh0b2tlbkFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgeyB0b2tlbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkluZGV4ID0gdG9rZW5zLmZpbmRJbmRleCgodG9rZW4pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4uYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSB0b2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuSW5kZXhdLmlzRVJDNzIxID0gaXNFUkM3MjE7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHRva2VucyB9KTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbnNbdG9rZW5JbmRleF07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlY3RzIHdoZXRoZXIgb3Igbm90IGEgdG9rZW4gaXMgRVJDLTcyMSBjb21wYXRpYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2Vuc0FkZHJlc3MgLSB0aGUgdG9rZW4gY29udHJhY3QgYWRkcmVzcy5cbiAgICAgKiBAcmV0dXJucyBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgdG9rZW4gYWRkcmVzcyBwYXNzZWQgaW4gc3VwcG9ydHMgdGhlIEVJUC03MjEgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICovXG4gICAgX2RldGVjdElzRVJDNzIxKHRva2VuQWRkcmVzcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY2hlY2tzdW1BZGRyZXNzID0gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKHRva2VuQWRkcmVzcyk7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIHRva2VuIGlzIGFscmVhZHkgaW4gb3VyIGNvbnRyYWN0IG1ldGFkYXRhIG1hcCB3ZSBkb24ndCBuZWVkXG4gICAgICAgICAgICAvLyB0byBjaGVjayBhZ2FpbnN0IHRoZSBjb250cmFjdFxuICAgICAgICAgICAgaWYgKCgoX2EgPSBjb250cmFjdF9tZXRhZGF0YV8xLmRlZmF1bHRbY2hlY2tzdW1BZGRyZXNzXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVyYzcyMSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKChfYiA9IGNvbnRyYWN0X21ldGFkYXRhXzEuZGVmYXVsdFtjaGVja3N1bUFkZHJlc3NdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZXJjMjApID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b2tlbkNvbnRyYWN0ID0geWllbGQgdGhpcy5fY3JlYXRlRXRoZXJzQ29udHJhY3QodG9rZW5BZGRyZXNzLCBodW1hbl9zdGFuZGFyZF9jb2xsZWN0aWJsZV9hYmlfMS5kZWZhdWx0LCB0aGlzLmV0aGVyc1Byb3ZpZGVyKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRva2VuQ29udHJhY3Quc3VwcG9ydHNJbnRlcmZhY2UoRVJDNzIxX0lOVEVSRkFDRV9JRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50bHkgd2Ugc2VlIGEgdmFyaWV0eSBvZiBlcnJvcnMgYWNyb3NzIGRpZmZlcmVudCBuZXR3b3JrcyB3aGVuXG4gICAgICAgICAgICAgICAgLy8gdG9rZW4gY29udHJhY3RzIGFyZSBub3QgRVJDNzIxIGNvbXBhdGlibGUuIFdlIG5lZWQgdG8gZmlndXJlIG91dCBhIGJldHRlclxuICAgICAgICAgICAgICAgIC8vIHdheSBvZiBkaWZmZXJlbnRpYXRpbmcgdG9rZW4gaW50ZXJmYWNlIHR5cGVzIGJ1dCBmb3Igbm93IGlmIHdlIGdldCBhbiBlcnJvclxuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gYXNzdW1lIHRoZSB0b2tlbiBpcyBub3QgRVJDNzIxIGNvbXBhdGlibGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2NyZWF0ZUV0aGVyc0NvbnRyYWN0KHRva2VuQWRkcmVzcywgYWJpLCBldGhlcnNQcm92aWRlcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5Db250cmFjdCA9IHlpZWxkIG5ldyBldGhlcnNfMS5ldGhlcnMuQ29udHJhY3QodG9rZW5BZGRyZXNzLCBhYmksIGV0aGVyc1Byb3ZpZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbkNvbnRyYWN0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dlbmVyYXRlUmFuZG9tSWQoKSB7XG4gICAgICAgIHJldHVybiB1dWlkXzEudjEoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBzdWdnZXN0ZWRBc3NldCB0byBzdGF0ZS4gUGFyYW1ldGVycyB3aWxsIGJlIHZhbGlkYXRlZCBhY2NvcmRpbmcgdG9cbiAgICAgKiBhc3NldCB0eXBlIGJlaW5nIHdhdGNoZWQuIEEgYDxzdWdnZXN0ZWRBc3NldE1ldGEuaWQ+OnBlbmRpbmdgIGh1YiBldmVudCB3aWxsIGJlIGVtaXR0ZWQgb25jZSBhZGRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldCAtIEFzc2V0IHRvIGJlIHdhdGNoZWQuIEZvciBub3cgb25seSBFUkMyMCB0b2tlbnMgYXJlIGFjY2VwdGVkLlxuICAgICAqIEBwYXJhbSB0eXBlIC0gQXNzZXQgdHlwZVxuICAgICAqIEByZXR1cm5zIC0gT2JqZWN0IGNvbnRhaW5pbmcgYSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgc3VnZ2VzdGVkQXNzZXQgYWRkcmVzcyBpZiBhY2NlcHRlZFxuICAgICAqL1xuICAgIHdhdGNoQXNzZXQoYXNzZXQsIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1Z2dlc3RlZEFzc2V0TWV0YSA9IHtcbiAgICAgICAgICAgICAgICBhc3NldCxcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5fZ2VuZXJhdGVSYW5kb21JZCgpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogU3VnZ2VzdGVkQXNzZXRTdGF0dXMucGVuZGluZyxcbiAgICAgICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRVJDMjAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbF8xLnZhbGlkYXRlVG9rZW5Ub1dhdGNoKGFzc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3NldCBvZiB0eXBlICR7dHlwZX0gbm90IHN1cHBvcnRlZGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZmFpbFN1Z2dlc3RlZEFzc2V0KHN1Z2dlc3RlZEFzc2V0TWV0YSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5odWIub25jZShgJHtzdWdnZXN0ZWRBc3NldE1ldGEuaWR9OmZpbmlzaGVkYCwgKG1ldGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtZXRhLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTdWdnZXN0ZWRBc3NldFN0YXR1cy5hY2NlcHRlZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShtZXRhLmFzc2V0LmFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTdWdnZXN0ZWRBc3NldFN0YXR1cy5yZWplY3RlZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignVXNlciByZWplY3RlZCB0byB3YXRjaCB0aGUgYXNzZXQuJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTdWdnZXN0ZWRBc3NldFN0YXR1cy5mYWlsZWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IobWV0YS5lcnJvci5tZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihgVW5rbm93biBzdGF0dXM6ICR7bWV0YS5zdGF0dXN9YCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgc3VnZ2VzdGVkQXNzZXRzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgc3VnZ2VzdGVkQXNzZXRzLnB1c2goc3VnZ2VzdGVkQXNzZXRNZXRhKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgc3VnZ2VzdGVkQXNzZXRzOiBbLi4uc3VnZ2VzdGVkQXNzZXRzXSB9KTtcbiAgICAgICAgICAgIHRoaXMuaHViLmVtaXQoJ3BlbmRpbmdTdWdnZXN0ZWRBc3NldCcsIHN1Z2dlc3RlZEFzc2V0TWV0YSk7XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQsIHN1Z2dlc3RlZEFzc2V0TWV0YSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNjZXB0cyB0byB3YXRjaCBhbiBhc3NldCBhbmQgdXBkYXRlcyBpdCdzIHN0YXR1cyBhbmQgZGVsZXRlcyB0aGUgc3VnZ2VzdGVkQXNzZXQgZnJvbSBzdGF0ZSxcbiAgICAgKiBhZGRpbmcgdGhlIGFzc2V0IHRvIGNvcnJlc3BvbmRpbmcgYXNzZXQgc3RhdGUuIEluIHRoaXMgY2FzZSBFUkMyMCB0b2tlbnMuXG4gICAgICogQSBgPHN1Z2dlc3RlZEFzc2V0TWV0YS5pZD46ZmluaXNoZWRgIGh1YiBldmVudCBpcyBmaXJlZCBhZnRlciBhY2NlcHRlZCBvciBmYWlsdXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1Z2dlc3RlZEFzc2V0SUQgLSBJRCBvZiB0aGUgc3VnZ2VzdGVkQXNzZXQgdG8gYWNjZXB0XG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoaXMgb3BlcmF0aW9uIGNvbXBsZXRlc1xuICAgICAqL1xuICAgIGFjY2VwdFdhdGNoQXNzZXQoc3VnZ2VzdGVkQXNzZXRJRCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBzdWdnZXN0ZWRBc3NldHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN1Z2dlc3RlZEFzc2V0cy5maW5kSW5kZXgoKHsgaWQgfSkgPT4gc3VnZ2VzdGVkQXNzZXRJRCA9PT0gaWQpO1xuICAgICAgICAgICAgY29uc3Qgc3VnZ2VzdGVkQXNzZXRNZXRhID0gc3VnZ2VzdGVkQXNzZXRzW2luZGV4XTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzdWdnZXN0ZWRBc3NldE1ldGEudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdFUkMyMCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGFkZHJlc3MsIHN5bWJvbCwgZGVjaW1hbHMsIGltYWdlIH0gPSBzdWdnZXN0ZWRBc3NldE1ldGEuYXNzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmFkZFRva2VuKGFkZHJlc3MsIHN5bWJvbCwgZGVjaW1hbHMsIGltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Z2dlc3RlZEFzc2V0TWV0YS5zdGF0dXMgPSBTdWdnZXN0ZWRBc3NldFN0YXR1cy5hY2NlcHRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaHViLmVtaXQoYCR7c3VnZ2VzdGVkQXNzZXRNZXRhLmlkfTpmaW5pc2hlZGAsIHN1Z2dlc3RlZEFzc2V0TWV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXNzZXQgb2YgdHlwZSAke3N1Z2dlc3RlZEFzc2V0TWV0YS50eXBlfSBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsU3VnZ2VzdGVkQXNzZXQoc3VnZ2VzdGVkQXNzZXRNZXRhLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdTdWdnZXN0ZWRBc3NldHMgPSBzdWdnZXN0ZWRBc3NldHMuZmlsdGVyKCh7IGlkIH0pID0+IGlkICE9PSBzdWdnZXN0ZWRBc3NldElEKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgc3VnZ2VzdGVkQXNzZXRzOiBbLi4ubmV3U3VnZ2VzdGVkQXNzZXRzXSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlamVjdHMgYSB3YXRjaEFzc2V0IHJlcXVlc3QgYmFzZWQgb24gaXRzIElEIGJ5IHNldHRpbmcgaXRzIHN0YXR1cyB0byBcInJlamVjdGVkXCJcbiAgICAgKiBhbmQgZW1pdHRpbmcgYSBgPHN1Z2dlc3RlZEFzc2V0TWV0YS5pZD46ZmluaXNoZWRgIGh1YiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWdnZXN0ZWRBc3NldElEIC0gSUQgb2YgdGhlIHN1Z2dlc3RlZEFzc2V0IHRvIGFjY2VwdFxuICAgICAqL1xuICAgIHJlamVjdFdhdGNoQXNzZXQoc3VnZ2VzdGVkQXNzZXRJRCkge1xuICAgICAgICBjb25zdCB7IHN1Z2dlc3RlZEFzc2V0cyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzdWdnZXN0ZWRBc3NldHMuZmluZEluZGV4KCh7IGlkIH0pID0+IHN1Z2dlc3RlZEFzc2V0SUQgPT09IGlkKTtcbiAgICAgICAgY29uc3Qgc3VnZ2VzdGVkQXNzZXRNZXRhID0gc3VnZ2VzdGVkQXNzZXRzW2luZGV4XTtcbiAgICAgICAgaWYgKCFzdWdnZXN0ZWRBc3NldE1ldGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdWdnZXN0ZWRBc3NldE1ldGEuc3RhdHVzID0gU3VnZ2VzdGVkQXNzZXRTdGF0dXMucmVqZWN0ZWQ7XG4gICAgICAgIHRoaXMuaHViLmVtaXQoYCR7c3VnZ2VzdGVkQXNzZXRNZXRhLmlkfTpmaW5pc2hlZGAsIHN1Z2dlc3RlZEFzc2V0TWV0YSk7XG4gICAgICAgIGNvbnN0IG5ld1N1Z2dlc3RlZEFzc2V0cyA9IHN1Z2dlc3RlZEFzc2V0cy5maWx0ZXIoKHsgaWQgfSkgPT4gaWQgIT09IHN1Z2dlc3RlZEFzc2V0SUQpO1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IHN1Z2dlc3RlZEFzc2V0czogWy4uLm5ld1N1Z2dlc3RlZEFzc2V0c10gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB0b2tlbiBmcm9tIHRoZSBzdG9yZWQgdG9rZW4gbGlzdCBhbmQgc2F2ZXMgaXQgaW4gaWdub3JlZCB0b2tlbnMgbGlzdFxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgdG9rZW4gY29udHJhY3RcbiAgICAgKi9cbiAgICByZW1vdmVBbmRJZ25vcmVUb2tlbihhZGRyZXNzKSB7XG4gICAgICAgIGFkZHJlc3MgPSB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IHsgdG9rZW5zLCBpZ25vcmVkVG9rZW5zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCBhbHJlYWR5SWdub3JlZCA9IGlnbm9yZWRUb2tlbnMuZmluZCgodG9rZW5BZGRyZXNzKSA9PiB0b2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgY29uc3QgbmV3VG9rZW5zID0gdG9rZW5zLmZpbHRlcigodG9rZW4pID0+IHtcbiAgICAgICAgICAgIGlmICh0b2tlbi5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICFhbHJlYWR5SWdub3JlZCAmJiBpZ25vcmVkVG9rZW5zLnB1c2goYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IG5ld0FsbFRva2VucywgbmV3QWxsSWdub3JlZFRva2VucyB9ID0gdGhpcy5fZ2V0TmV3QWxsVG9rZW5zU3RhdGUobmV3VG9rZW5zLCBpZ25vcmVkVG9rZW5zKTtcbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgYWxsVG9rZW5zOiBuZXdBbGxUb2tlbnMsXG4gICAgICAgICAgICB0b2tlbnM6IG5ld1Rva2VucyxcbiAgICAgICAgICAgIGFsbElnbm9yZWRUb2tlbnM6IG5ld0FsbElnbm9yZWRUb2tlbnMsXG4gICAgICAgICAgICBpZ25vcmVkVG9rZW5zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBuZXcgdG9rZW5zIGFuZCBpZ25vcmVkVG9rZW5zIGFycmF5IGZvciB0aGUgY3VycmVudCBuZXR3b3JrL2FjY291bnQgY29tYmluYXRpb25cbiAgICAgKiBhbmQgcmV0dXJucyBuZXcgYWxsVG9rZW5zIGFuZCBhbGxJZ25vcmVkVG9rZW5zIHN0YXRlIHRvIHVwZGF0ZSB0by5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdUb2tlbnMgLSBUaGUgbmV3IHRva2VucyB0byBzZXQgZm9yIHRoZSBjdXJyZW50IG5ldHdvcmsgYW5kIHNlbGVjdGVkIGFjY291bnQuXG4gICAgICogQHBhcmFtIG5ld0lnbm9yZWRUb2tlbnMgLSBUaGUgbmV3IGlnbm9yZWQgdG9rZW5zIHRvIHNldCBmb3IgdGhlIGN1cnJlbnQgbmV0d29yayBhbmQgc2VsZWN0ZWQgYWNjb3VudC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdXBkYXRlZCBgYWxsVG9rZW5zYCBhbmQgYGFsbElnbm9yZWRUb2tlbnNgIHN0YXRlLlxuICAgICAqL1xuICAgIF9nZXROZXdBbGxUb2tlbnNTdGF0ZShuZXdUb2tlbnMsIG5ld0lnbm9yZWRUb2tlbnMpIHtcbiAgICAgICAgY29uc3QgeyBhbGxUb2tlbnMsIGFsbElnbm9yZWRUb2tlbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5JZCwgc2VsZWN0ZWRBZGRyZXNzIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgY29uc3QgbmV0d29ya1Rva2VucyA9IGFsbFRva2Vuc1tjaGFpbklkXTtcbiAgICAgICAgY29uc3QgbmV0d29ya0lnbm9yZWRUb2tlbnMgPSBhbGxJZ25vcmVkVG9rZW5zW2NoYWluSWRdO1xuICAgICAgICBjb25zdCBuZXdOZXR3b3JrVG9rZW5zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBuZXR3b3JrVG9rZW5zKSwgeyBbc2VsZWN0ZWRBZGRyZXNzXTogbmV3VG9rZW5zIH0pO1xuICAgICAgICBjb25zdCBuZXdJZ25vcmVkTmV0d29ya1Rva2VucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbmV0d29ya0lnbm9yZWRUb2tlbnMpLCB7IFtzZWxlY3RlZEFkZHJlc3NdOiBuZXdJZ25vcmVkVG9rZW5zIH0pO1xuICAgICAgICBjb25zdCBuZXdBbGxUb2tlbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFsbFRva2VucyksIHsgW2NoYWluSWRdOiBuZXdOZXR3b3JrVG9rZW5zIH0pO1xuICAgICAgICBjb25zdCBuZXdBbGxJZ25vcmVkVG9rZW5zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhbGxJZ25vcmVkVG9rZW5zKSwgeyBbY2hhaW5JZF06IG5ld0lnbm9yZWROZXR3b3JrVG9rZW5zIH0pO1xuICAgICAgICByZXR1cm4geyBuZXdBbGxUb2tlbnMsIG5ld0FsbElnbm9yZWRUb2tlbnMgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdG9rZW5zIGZyb20gdGhlIGlnbm9yZWQgbGlzdFxuICAgICAqL1xuICAgIGNsZWFySWdub3JlZFRva2VucygpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBpZ25vcmVkVG9rZW5zOiBbXSwgYWxsSWdub3JlZFRva2Vuczoge30gfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ub2tlbnNDb250cm9sbGVyID0gVG9rZW5zQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IFRva2Vuc0NvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ub2tlbnNDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBoaXNoaW5nQ29udHJvbGxlciA9IHZvaWQgMDtcbmNvbnN0IHB1bnljb2RlXzEgPSByZXF1aXJlKFwicHVueWNvZGUvXCIpO1xuY29uc3QgY29uZmlnX2pzb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXRoLXBoaXNoaW5nLWRldGVjdC9zcmMvY29uZmlnLmpzb25cIikpO1xuY29uc3QgZGV0ZWN0b3JfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXRoLXBoaXNoaW5nLWRldGVjdC9zcmMvZGV0ZWN0b3JcIikpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgcGFzc2l2ZWx5IHBvbGxzIG9uIGEgc2V0IGludGVydmFsIGZvciBhcHByb3ZlZCBhbmQgdW5hcHByb3ZlZCB3ZWJzaXRlIG9yaWdpbnNcbiAqL1xuY2xhc3MgUGhpc2hpbmdDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFBoaXNoaW5nQ29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICB0aGlzLmNvbmZpZ1VybCA9ICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvZ2gvTWV0YU1hc2svZXRoLXBoaXNoaW5nLWRldGVjdEBtYXN0ZXIvc3JjL2NvbmZpZy5qc29uJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnUGhpc2hpbmdDb250cm9sbGVyJztcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29uZmlnID0geyBpbnRlcnZhbDogNjAgKiA2MCAqIDEwMDAgfTtcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XG4gICAgICAgICAgICBwaGlzaGluZzogY29uZmlnX2pzb25fMS5kZWZhdWx0LFxuICAgICAgICAgICAgd2hpdGVsaXN0OiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZXRlY3RvciA9IG5ldyBkZXRlY3Rvcl8xLmRlZmF1bHQodGhpcy5kZWZhdWx0U3RhdGUucGhpc2hpbmcpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhIG5ldyBwb2xsaW5nIGludGVydmFsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW50ZXJ2YWwgLSBQb2xsaW5nIGludGVydmFsIHVzZWQgdG8gZmV0Y2ggbmV3IGFwcHJvdmFsIGxpc3RzXG4gICAgICovXG4gICAgcG9sbChpbnRlcnZhbCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaW50ZXJ2YWwgJiYgdGhpcy5jb25maWd1cmUoeyBpbnRlcnZhbCB9LCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGUgJiYgY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKTtcbiAgICAgICAgICAgIHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IHRoaXMudXBkYXRlUGhpc2hpbmdMaXN0cygpKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2xsKHRoaXMuY29uZmlnLmludGVydmFsKTtcbiAgICAgICAgICAgIH0sIHRoaXMuY29uZmlnLmludGVydmFsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBnaXZlbiBvcmlnaW4gaXMgdW5hcHByb3ZlZFxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIERvbWFpbiBvcmlnaW4gb2YgYSB3ZWJzaXRlXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBvcmlnaW4gaXMgYW4gdW5hcHByb3ZlZCBvcmlnaW5cbiAgICAgKi9cbiAgICB0ZXN0KG9yaWdpbikge1xuICAgICAgICBjb25zdCBwdW55Y29kZU9yaWdpbiA9IHB1bnljb2RlXzEudG9BU0NJSShvcmlnaW4pO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS53aGl0ZWxpc3QuaW5kZXhPZihwdW55Y29kZU9yaWdpbikgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGV0ZWN0b3IuY2hlY2socHVueWNvZGVPcmlnaW4pLnJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVtcG9yYXJpbHkgbWFya3MgYSBnaXZlbiBvcmlnaW4gYXMgYXBwcm92ZWRcbiAgICAgKi9cbiAgICBieXBhc3Mob3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IHB1bnljb2RlT3JpZ2luID0gcHVueWNvZGVfMS50b0FTQ0lJKG9yaWdpbik7XG4gICAgICAgIGNvbnN0IHsgd2hpdGVsaXN0IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAod2hpdGVsaXN0LmluZGV4T2YocHVueWNvZGVPcmlnaW4pICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKHsgd2hpdGVsaXN0OiBbLi4ud2hpdGVsaXN0LCBwdW55Y29kZU9yaWdpbl0gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgbGlzdHMgb2YgYXBwcm92ZWQgYW5kIHVuYXBwcm92ZWQgd2Vic2l0ZSBvcmlnaW5zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoaXMgb3BlcmF0aW9uIGNvbXBsZXRlc1xuICAgICAqL1xuICAgIHVwZGF0ZVBoaXNoaW5nTGlzdHMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBoaXNoaW5nT3B0cyA9IHlpZWxkIHRoaXMucXVlcnlDb25maWcodGhpcy5jb25maWdVcmwpO1xuICAgICAgICAgICAgaWYgKHBoaXNoaW5nT3B0cykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0ZWN0b3IgPSBuZXcgZGV0ZWN0b3JfMS5kZWZhdWx0KHBoaXNoaW5nT3B0cyk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICBwaGlzaGluZzogcGhpc2hpbmdPcHRzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcXVlcnlDb25maWcoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2goaW5wdXQsIHsgY2FjaGU6ICduby1jYWNoZScgfSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHJlc3BvbnNlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgMjAwOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMzA0OlxuICAgICAgICAgICAgICAgIGNhc2UgNDAzOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmV0Y2ggZmFpbGVkIHdpdGggc3RhdHVzICcke3Jlc3BvbnNlLnN0YXR1c30nIGZvciByZXF1ZXN0ICcke2lucHV0fSdgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUGhpc2hpbmdDb250cm9sbGVyID0gUGhpc2hpbmdDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gUGhpc2hpbmdDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGhpc2hpbmdDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5ldHdvcmtDb250cm9sbGVyID0gZXhwb3J0cy5OZXR3b3Jrc0NoYWluSWQgPSB2b2lkIDA7XG5jb25zdCBldGhfcXVlcnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXRoLXF1ZXJ5XCIpKTtcbmNvbnN0IHByb3ZpZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIndlYjMtcHJvdmlkZXItZW5naW5lL3N1YnByb3ZpZGVycy9wcm92aWRlclwiKSk7XG5jb25zdCBjcmVhdGVQcm92aWRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJldGgtanNvbi1ycGMtaW5mdXJhL3NyYy9jcmVhdGVQcm92aWRlclwiKSk7XG5jb25zdCB6ZXJvXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIndlYjMtcHJvdmlkZXItZW5naW5lL3plcm9cIikpO1xuY29uc3QgYXN5bmNfbXV0ZXhfMSA9IHJlcXVpcmUoXCJhc3luYy1tdXRleFwiKTtcbmNvbnN0IEJhc2VDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG52YXIgTmV0d29ya3NDaGFpbklkO1xuKGZ1bmN0aW9uIChOZXR3b3Jrc0NoYWluSWQpIHtcbiAgICBOZXR3b3Jrc0NoYWluSWRbXCJtYWlubmV0XCJdID0gXCIxXCI7XG4gICAgTmV0d29ya3NDaGFpbklkW1wia292YW5cIl0gPSBcIjQyXCI7XG4gICAgTmV0d29ya3NDaGFpbklkW1wicmlua2VieVwiXSA9IFwiNFwiO1xuICAgIE5ldHdvcmtzQ2hhaW5JZFtcImdvZXJsaVwiXSA9IFwiNVwiO1xuICAgIE5ldHdvcmtzQ2hhaW5JZFtcInJvcHN0ZW5cIl0gPSBcIjNcIjtcbiAgICBOZXR3b3Jrc0NoYWluSWRbXCJsb2NhbGhvc3RcIl0gPSBcIlwiO1xuICAgIE5ldHdvcmtzQ2hhaW5JZFtcInJwY1wiXSA9IFwiXCI7XG4gICAgTmV0d29ya3NDaGFpbklkW1wib3B0aW1pc21cIl0gPSBcIjEwXCI7XG4gICAgTmV0d29ya3NDaGFpbklkW1wib3B0aW1pc21UZXN0XCJdID0gXCI2OVwiO1xufSkoTmV0d29ya3NDaGFpbklkID0gZXhwb3J0cy5OZXR3b3Jrc0NoYWluSWQgfHwgKGV4cG9ydHMuTmV0d29ya3NDaGFpbklkID0ge30pKTtcbmNvbnN0IExPQ0FMSE9TVF9SUENfVVJMID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6ODU0NSc7XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCBjcmVhdGVzIGFuZCBtYW5hZ2VzIGFuIEV0aGVyZXVtIG5ldHdvcmsgcHJvdmlkZXJcbiAqL1xuY2xhc3MgTmV0d29ya0NvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlcl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTmV0d29ya0NvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFByb3ZpZGVyQ29uZmlnID0ge307XG4gICAgICAgIHRoaXMubXV0ZXggPSBuZXcgYXN5bmNfbXV0ZXhfMS5NdXRleCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdOZXR3b3JrQ29udHJvbGxlcic7XG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xuICAgICAgICAgICAgbmV0d29yazogJ2xvYWRpbmcnLFxuICAgICAgICAgICAgaXNDdXN0b21OZXR3b3JrOiBmYWxzZSxcbiAgICAgICAgICAgIHByb3ZpZGVyOiB7IHR5cGU6IGNvbnN0YW50c18xLk1BSU5ORVQsIGNoYWluSWQ6IE5ldHdvcmtzQ2hhaW5JZC5tYWlubmV0IH0sXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7IGlzRUlQMTU1OUNvbXBhdGlibGU6IGZhbHNlIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLmdldEVJUDE1NTlDb21wYXRpYmlsaXR5KCk7XG4gICAgfVxuICAgIGluaXRpYWxpemVQcm92aWRlcih0eXBlLCBycGNUYXJnZXQsIGNoYWluSWQsIHRpY2tlciwgbmlja25hbWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBpc0N1c3RvbU5ldHdvcms6IHRoaXMuZ2V0SXNDdXN0b21OZXR3b3JrKGNoYWluSWQpIH0pO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2tvdmFuJzpcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuTUFJTk5FVDpcbiAgICAgICAgICAgIGNhc2UgJ3JpbmtlYnknOlxuICAgICAgICAgICAgY2FzZSAnZ29lcmxpJzpcbiAgICAgICAgICAgIGNhc2UgJ29wdGltaXNtJzpcbiAgICAgICAgICAgIGNhc2UgJ29wdGltaXNtVGVzdCc6XG4gICAgICAgICAgICBjYXNlICdyb3BzdGVuJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNldHVwSW5mdXJhUHJvdmlkZXIodHlwZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsb2NhbGhvc3QnOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBTdGFuZGFyZFByb3ZpZGVyKExPQ0FMSE9TVF9SUENfVVJMKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuUlBDOlxuICAgICAgICAgICAgICAgIHJwY1RhcmdldCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHVwU3RhbmRhcmRQcm92aWRlcihycGNUYXJnZXQsIGNoYWluSWQsIHRpY2tlciwgbmlja25hbWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBuZXR3b3JrIHR5cGU6ICcke3R5cGV9J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZnJlc2hOZXR3b3JrKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IG5ldHdvcms6ICdsb2FkaW5nJywgcHJvcGVydGllczoge30gfSk7XG4gICAgICAgIGNvbnN0IHsgcnBjVGFyZ2V0LCB0eXBlLCBjaGFpbklkLCB0aWNrZXIgfSA9IHRoaXMuc3RhdGUucHJvdmlkZXI7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVByb3ZpZGVyKHR5cGUsIHJwY1RhcmdldCwgY2hhaW5JZCwgdGlja2VyKTtcbiAgICAgICAgdGhpcy5sb29rdXBOZXR3b3JrKCk7XG4gICAgfVxuICAgIHJlZ2lzdGVyUHJvdmlkZXIoKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXIub24oJ2Vycm9yJywgdGhpcy52ZXJpZnlOZXR3b3JrLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmV0aFF1ZXJ5ID0gbmV3IGV0aF9xdWVyeV8xLmRlZmF1bHQodGhpcy5wcm92aWRlcik7XG4gICAgfVxuICAgIHNldHVwSW5mdXJhUHJvdmlkZXIodHlwZSkge1xuICAgICAgICBjb25zdCBpbmZ1cmFQcm92aWRlciA9IGNyZWF0ZVByb3ZpZGVyXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0eXBlLFxuICAgICAgICAgICAgcHJvamVjdElkOiB0aGlzLmNvbmZpZy5pbmZ1cmFQcm9qZWN0SWQsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpbmZ1cmFTdWJwcm92aWRlciA9IG5ldyBwcm92aWRlcl8xLmRlZmF1bHQoaW5mdXJhUHJvdmlkZXIpO1xuICAgICAgICBjb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaW50ZXJuYWxQcm92aWRlckNvbmZpZyksIHtcbiAgICAgICAgICAgIGRhdGFTdWJwcm92aWRlcjogaW5mdXJhU3VicHJvdmlkZXIsXG4gICAgICAgICAgICBlbmdpbmVQYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBibG9ja1RyYWNrZXJQcm92aWRlcjogaW5mdXJhUHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgcG9sbGluZ0ludGVydmFsOiAxMjAwMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZVByb3ZpZGVyKHplcm9fMS5kZWZhdWx0KGNvbmZpZykpO1xuICAgIH1cbiAgICBnZXRJc0N1c3RvbU5ldHdvcmsoY2hhaW5JZCkge1xuICAgICAgICByZXR1cm4gKGNoYWluSWQgIT09IE5ldHdvcmtzQ2hhaW5JZC5tYWlubmV0ICYmXG4gICAgICAgICAgICBjaGFpbklkICE9PSBOZXR3b3Jrc0NoYWluSWQua292YW4gJiZcbiAgICAgICAgICAgIGNoYWluSWQgIT09IE5ldHdvcmtzQ2hhaW5JZC5yaW5rZWJ5ICYmXG4gICAgICAgICAgICBjaGFpbklkICE9PSBOZXR3b3Jrc0NoYWluSWQuZ29lcmxpICYmXG4gICAgICAgICAgICBjaGFpbklkICE9PSBOZXR3b3Jrc0NoYWluSWQucm9wc3RlbiAmJlxuICAgICAgICAgICAgY2hhaW5JZCAhPT0gTmV0d29ya3NDaGFpbklkLmxvY2FsaG9zdCk7XG4gICAgfVxuICAgIHNldHVwU3RhbmRhcmRQcm92aWRlcihycGNUYXJnZXQsIGNoYWluSWQsIHRpY2tlciwgbmlja25hbWUpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmludGVybmFsUHJvdmlkZXJDb25maWcpLCB7XG4gICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgZW5naW5lUGFyYW1zOiB7IHBvbGxpbmdJbnRlcnZhbDogMTIwMDAgfSxcbiAgICAgICAgICAgIG5pY2tuYW1lLFxuICAgICAgICAgICAgcnBjVXJsOiBycGNUYXJnZXQsXG4gICAgICAgICAgICB0aWNrZXIsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZVByb3ZpZGVyKHplcm9fMS5kZWZhdWx0KGNvbmZpZykpO1xuICAgIH1cbiAgICB1cGRhdGVQcm92aWRlcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLnNhZmVseVN0b3BQcm92aWRlcih0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyUHJvdmlkZXIoKTtcbiAgICB9XG4gICAgc2FmZWx5U3RvcFByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcHJvdmlkZXIgPT09IG51bGwgfHwgcHJvdmlkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3ZpZGVyLnN0b3AoKTtcbiAgICAgICAgfSwgNTAwKTtcbiAgICB9XG4gICAgdmVyaWZ5TmV0d29yaygpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5uZXR3b3JrID09PSAnbG9hZGluZycgJiYgdGhpcy5sb29rdXBOZXR3b3JrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBuZXcgY29uZmlndXJhdGlvbiBmb3Igd2ViMy1wcm92aWRlci1lbmdpbmVcbiAgICAgKlxuICAgICAqIFRPRE86IFJlcGxhY2UgdGhpcyB3dGggYSBtZXRob2RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm92aWRlckNvbmZpZyAtIHdlYjMtcHJvdmlkZXItZW5naW5lIGNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICBzZXQgcHJvdmlkZXJDb25maWcocHJvdmlkZXJDb25maWcpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFByb3ZpZGVyQ29uZmlnID0gcHJvdmlkZXJDb25maWc7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcnBjVGFyZ2V0LCBjaGFpbklkLCB0aWNrZXIsIG5pY2tuYW1lIH0gPSB0aGlzLnN0YXRlLnByb3ZpZGVyO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVQcm92aWRlcih0eXBlLCBycGNUYXJnZXQsIGNoYWluSWQsIHRpY2tlciwgbmlja25hbWUpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyUHJvdmlkZXIoKTtcbiAgICAgICAgdGhpcy5sb29rdXBOZXR3b3JrKCk7XG4gICAgfVxuICAgIGdldCBwcm92aWRlckNvbmZpZygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBvbmx5IHVzZWQgZm9yIHNldHRpbmcnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBjdXJyZW50IG5ldHdvcmsgY29kZVxuICAgICAqL1xuICAgIGxvb2t1cE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5ldGhRdWVyeSB8fCAhdGhpcy5ldGhRdWVyeS5zZW5kQXN5bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWxlYXNlTG9jayA9IHlpZWxkIHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgdGhpcy5ldGhRdWVyeS5zZW5kQXN5bmMoeyBtZXRob2Q6ICduZXRfdmVyc2lvbicgfSwgKGVycm9yLCBuZXR3b3JrKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrOiBlcnJvciA/IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0Ki8gJ2xvYWRpbmcnIDogbmV0d29yayxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gdXBkYXRlIHByb3ZpZGVyIG5ldHdvcmsgdHlwZSBzZXR0aW5nc1xuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgLSBIdW1hbiByZWFkYWJsZSBuZXR3b3JrIG5hbWVcbiAgICAgKi9cbiAgICBzZXRQcm92aWRlclR5cGUodHlwZSkge1xuICAgICAgICBjb25zdCBfYSA9IHRoaXMuc3RhdGUucHJvdmlkZXIsIHsgcnBjVGFyZ2V0LCBjaGFpbklkLCBuaWNrbmFtZSB9ID0gX2EsIHByb3ZpZGVyU3RhdGUgPSBfX3Jlc3QoX2EsIFtcInJwY1RhcmdldFwiLCBcImNoYWluSWRcIiwgXCJuaWNrbmFtZVwiXSk7XG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgIHByb3ZpZGVyOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3ZpZGVyU3RhdGUpLCB7IHR5cGUsIHRpY2tlcjogJ0VUSCcsIGNoYWluSWQ6IE5ldHdvcmtzQ2hhaW5JZFt0eXBlXSB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVmcmVzaE5ldHdvcmsoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHVwZGF0ZSBwcm92aWRlciBSUEMgc2V0dGluZ3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSBycGNUYXJnZXQgLSBSUEMgZW5kcG9pbnQgVVJMXG4gICAgICogQHBhcmFtIGNoYWluSWQgLSBOZXR3b3JrIElEIGFzIHBlciBFSVAtMTU1XG4gICAgICogQHBhcmFtIHRpY2tlcj8gLSBDdXJyZW5jeSB0aWNrZXJcbiAgICAgKiBAcGFyYW0gbmlja25hbWU/IC0gUGVyc29uYWxpemVkIG5ldHdvcmsgbmFtZVxuICAgICAqL1xuICAgIHNldFJwY1RhcmdldChycGNUYXJnZXQsIGNoYWluSWQsIHRpY2tlciwgbmlja25hbWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgcHJvdmlkZXI6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZS5wcm92aWRlciksIHsgdHlwZTogY29uc3RhbnRzXzEuUlBDLCB0aWNrZXIsIHJwY1RhcmdldCwgY2hhaW5JZCwgbmlja25hbWUgfSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZnJlc2hOZXR3b3JrKCk7XG4gICAgfVxuICAgIGdldEVJUDE1NTlDb21wYXRpYmlsaXR5KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgcHJvcGVydGllcyA9IHt9IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAoIXByb3BlcnRpZXMuaXNFSVAxNTU5Q29tcGF0aWJsZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoKF9hID0gdGhpcy5ldGhRdWVyeSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlbmRBc3luYykgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmV0aFF1ZXJ5LnNlbmRBc3luYyh7IG1ldGhvZDogJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJywgcGFyYW1zOiBbJ2xhdGVzdCcsIGZhbHNlXSB9LCAoZXJyb3IsIGJsb2NrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRUlQMTU1OUNvbXBhdGlibGUgPSB0eXBlb2YgYmxvY2suYmFzZUZlZVBlckdhcyAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5pc0VJUDE1NTlDb21wYXRpYmxlICE9PSBpc0VJUDE1NTlDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0VJUDE1NTlDb21wYXRpYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpc0VJUDE1NTlDb21wYXRpYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICB9XG59XG5leHBvcnRzLk5ldHdvcmtDb250cm9sbGVyID0gTmV0d29ya0NvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBOZXR3b3JrQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5ldHdvcmtDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuS2V5cmluZ0NvbnRyb2xsZXIgPSBleHBvcnRzLlNpZ25UeXBlZERhdGFWZXJzaW9uID0gZXhwb3J0cy5BY2NvdW50SW1wb3J0U3RyYXRlZ3kgPSBleHBvcnRzLktleXJpbmdUeXBlcyA9IHZvaWQgMDtcbmNvbnN0IGV0aGVyZXVtanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKTtcbmNvbnN0IGV0aGpzX3V0aWxfMSA9IHJlcXVpcmUoXCJldGhqcy11dGlsXCIpO1xuY29uc3QgZXRoX3NpZ191dGlsXzEgPSByZXF1aXJlKFwiZXRoLXNpZy11dGlsXCIpO1xuY29uc3QgZXRoZXJldW1qc193YWxsZXRfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZXRoZXJldW1qcy13YWxsZXRcIikpO1xuY29uc3QgZXRoX2tleXJpbmdfY29udHJvbGxlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJldGgta2V5cmluZy1jb250cm9sbGVyXCIpKTtcbmNvbnN0IGFzeW5jX211dGV4XzEgPSByZXF1aXJlKFwiYXN5bmMtbXV0ZXhcIik7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBwcml2YXRlcyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEF2YWlsYWJsZSBrZXlyaW5nIHR5cGVzXG4gKi9cbnZhciBLZXlyaW5nVHlwZXM7XG4oZnVuY3Rpb24gKEtleXJpbmdUeXBlcykge1xuICAgIEtleXJpbmdUeXBlc1tcInNpbXBsZVwiXSA9IFwiU2ltcGxlIEtleSBQYWlyXCI7XG4gICAgS2V5cmluZ1R5cGVzW1wiaGRcIl0gPSBcIkhEIEtleSBUcmVlXCI7XG59KShLZXlyaW5nVHlwZXMgPSBleHBvcnRzLktleXJpbmdUeXBlcyB8fCAoZXhwb3J0cy5LZXlyaW5nVHlwZXMgPSB7fSkpO1xuLyoqXG4gKiBBIHN0cmF0ZWd5IGZvciBpbXBvcnRpbmcgYW4gYWNjb3VudFxuICovXG52YXIgQWNjb3VudEltcG9ydFN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChBY2NvdW50SW1wb3J0U3RyYXRlZ3kpIHtcbiAgICBBY2NvdW50SW1wb3J0U3RyYXRlZ3lbXCJwcml2YXRlS2V5XCJdID0gXCJwcml2YXRlS2V5XCI7XG4gICAgQWNjb3VudEltcG9ydFN0cmF0ZWd5W1wianNvblwiXSA9IFwianNvblwiO1xufSkoQWNjb3VudEltcG9ydFN0cmF0ZWd5ID0gZXhwb3J0cy5BY2NvdW50SW1wb3J0U3RyYXRlZ3kgfHwgKGV4cG9ydHMuQWNjb3VudEltcG9ydFN0cmF0ZWd5ID0ge30pKTtcbi8qKlxuICogVGhlIGBzaWduVHlwZWRNZXNzYWdlYCB2ZXJzaW9uXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5tZXRhbWFzay5pby9ndWlkZS9zaWduaW5nLWRhdGEuaHRtbFxuICovXG52YXIgU2lnblR5cGVkRGF0YVZlcnNpb247XG4oZnVuY3Rpb24gKFNpZ25UeXBlZERhdGFWZXJzaW9uKSB7XG4gICAgU2lnblR5cGVkRGF0YVZlcnNpb25bXCJWMVwiXSA9IFwiVjFcIjtcbiAgICBTaWduVHlwZWREYXRhVmVyc2lvbltcIlYzXCJdID0gXCJWM1wiO1xuICAgIFNpZ25UeXBlZERhdGFWZXJzaW9uW1wiVjRcIl0gPSBcIlY0XCI7XG59KShTaWduVHlwZWREYXRhVmVyc2lvbiA9IGV4cG9ydHMuU2lnblR5cGVkRGF0YVZlcnNpb24gfHwgKGV4cG9ydHMuU2lnblR5cGVkRGF0YVZlcnNpb24gPSB7fSkpO1xuLyoqXG4gKiBDb250cm9sbGVyIHJlc3BvbnNpYmxlIGZvciBlc3RhYmxpc2hpbmcgYW5kIG1hbmFnaW5nIHVzZXIgaWRlbnRpdHlcbiAqL1xuY2xhc3MgS2V5cmluZ0NvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlcl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgS2V5cmluZ0NvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVtb3ZlSWRlbnRpdHkgLSBSZW1vdmUgdGhlIGlkZW50aXR5IHdpdGggdGhlIGdpdmVuIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zeW5jSWRlbnRpdGllcyAtIFN5bmMgaWRlbnRpdGllcyB3aXRoIHRoZSBnaXZlbiBsaXN0IG9mIGFkZHJlc3Nlc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnVwZGF0ZUlkZW50aXRpZXMgLSBHZW5lcmF0ZSBhbiBpZGVudGl0eSBmb3IgZWFjaCBhZGRyZXNzIGdpdmVuIHRoYXQgZG9lc24ndCBhbHJlYWR5IGhhdmUgYW4gaWRlbnRpdHlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zZXRTZWxlY3RlZEFkZHJlc3MgLSBTZXQgdGhlIHNlbGVjdGVkIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgcmVtb3ZlSWRlbnRpdHksIHN5bmNJZGVudGl0aWVzLCB1cGRhdGVJZGVudGl0aWVzLCBzZXRTZWxlY3RlZEFkZHJlc3MsIH0sIGNvbmZpZywgc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzdGF0ZSk7XG4gICAgICAgIHRoaXMubXV0ZXggPSBuZXcgYXN5bmNfbXV0ZXhfMS5NdXRleCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdLZXlyaW5nQ29udHJvbGxlcic7XG4gICAgICAgIHByaXZhdGVzLnNldCh0aGlzLCB7XG4gICAgICAgICAgICBrZXlyaW5nOiBuZXcgZXRoX2tleXJpbmdfY29udHJvbGxlcl8xLmRlZmF1bHQoT2JqZWN0LmFzc2lnbih7IGluaXRTdGF0ZTogc3RhdGUgfSwgY29uZmlnKSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcuc3RvcmUuZ2V0U3RhdGUoKSksIHsga2V5cmluZ3M6IFtdIH0pO1xuICAgICAgICB0aGlzLnJlbW92ZUlkZW50aXR5ID0gcmVtb3ZlSWRlbnRpdHk7XG4gICAgICAgIHRoaXMuc3luY0lkZW50aXRpZXMgPSBzeW5jSWRlbnRpdGllcztcbiAgICAgICAgdGhpcy51cGRhdGVJZGVudGl0aWVzID0gdXBkYXRlSWRlbnRpdGllcztcbiAgICAgICAgdGhpcy5zZXRTZWxlY3RlZEFkZHJlc3MgPSBzZXRTZWxlY3RlZEFkZHJlc3M7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBhY2NvdW50IHRvIHRoZSBkZWZhdWx0IChmaXJzdCkgSEQgc2VlZCBwaHJhc2Uga2V5cmluZ1xuICAgICAqXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byBjdXJyZW50IHN0YXRlIHdoZW4gdGhlIGFjY291bnQgaXMgYWRkZWRcbiAgICAgKi9cbiAgICBhZGROZXdBY2NvdW50KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHJpbWFyeUtleXJpbmcgPSBwcml2YXRlc1xuICAgICAgICAgICAgICAgIC5nZXQodGhpcylcbiAgICAgICAgICAgICAgICAua2V5cmluZy5nZXRLZXlyaW5nc0J5VHlwZSgnSEQgS2V5IFRyZWUnKVswXTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCFwcmltYXJ5S2V5cmluZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gSEQga2V5cmluZyBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2xkQWNjb3VudHMgPSB5aWVsZCBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgeWllbGQgcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcuYWRkTmV3QWNjb3VudChwcmltYXJ5S2V5cmluZyk7XG4gICAgICAgICAgICBjb25zdCBuZXdBY2NvdW50cyA9IHlpZWxkIHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLmdldEFjY291bnRzKCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnZlcmlmeVNlZWRQaHJhc2UoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSWRlbnRpdGllcyhuZXdBY2NvdW50cyk7XG4gICAgICAgICAgICBuZXdBY2NvdW50cy5mb3JFYWNoKChzZWxlY3RlZEFkZHJlc3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW9sZEFjY291bnRzLmluY2x1ZGVzKHNlbGVjdGVkQWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3RlZEFkZHJlc3Moc2VsZWN0ZWRBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgYWNjb3VudCB0byB0aGUgZGVmYXVsdCAoZmlyc3QpIEhEIHNlZWQgcGhyYXNlIGtleXJpbmcgd2l0aG91dCB1cGRhdGluZyBpZGVudGl0aWVzIGluIHByZWZlcmVuY2VzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIGN1cnJlbnQgc3RhdGUgd2hlbiB0aGUgYWNjb3VudCBpcyBhZGRlZFxuICAgICAqL1xuICAgIGFkZE5ld0FjY291bnRXaXRob3V0VXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHJpbWFyeUtleXJpbmcgPSBwcml2YXRlc1xuICAgICAgICAgICAgICAgIC5nZXQodGhpcylcbiAgICAgICAgICAgICAgICAua2V5cmluZy5nZXRLZXlyaW5nc0J5VHlwZSgnSEQgS2V5IFRyZWUnKVswXTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCFwcmltYXJ5S2V5cmluZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gSEQga2V5cmluZyBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcuYWRkTmV3QWNjb3VudChwcmltYXJ5S2V5cmluZyk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnZlcmlmeVNlZWRQaHJhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzIGNyZWF0aW5nIGEgbmV3IGtleWNoYWluIHRoZW4gcG9wdWxhdGluZyBpdFxuICAgICAqIHVzaW5nIHRoZSBnaXZlbiBzZWVkIHBocmFzZVxuICAgICAqXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIC0gUGFzc3dvcmQgdG8gdW5sb2NrIGtleWNoYWluXG4gICAgICogQHBhcmFtIHNlZWQgLSBTZWVkIHBocmFzZSB0byByZXN0b3JlIGtleWNoYWluXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aCByZXN0b3JlZCBrZXljaGFpbiBvYmplY3RcbiAgICAgKi9cbiAgICBjcmVhdGVOZXdWYXVsdEFuZFJlc3RvcmUocGFzc3dvcmQsIHNlZWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VMb2NrID0geWllbGQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSWRlbnRpdGllcyhbXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmF1bHQgPSB5aWVsZCBwcml2YXRlc1xuICAgICAgICAgICAgICAgICAgICAuZ2V0KHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIC5rZXlyaW5nLmNyZWF0ZU5ld1ZhdWx0QW5kUmVzdG9yZShwYXNzd29yZCwgc2VlZCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJZGVudGl0aWVzKHlpZWxkIHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLmdldEFjY291bnRzKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZnVsbFVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgcHJpbWFyeSBrZXljaGFpbiBhbmQgd2lwZSBhbnkgcHJldmlvdXMga2V5Y2hhaW5zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFzc3dvcmQgLSBQYXNzd29yZCB0byB1bmxvY2sgdGhlIG5ldyB2YXVsdFxuICAgICAqIEByZXR1cm5zIC0gTmV3bHktY3JlYXRlZCBrZXljaGFpbiBvYmplY3RcbiAgICAgKi9cbiAgICBjcmVhdGVOZXdWYXVsdEFuZEtleWNoYWluKHBhc3N3b3JkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWxlYXNlTG9jayA9IHlpZWxkIHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YXVsdCA9IHlpZWxkIHByaXZhdGVzXG4gICAgICAgICAgICAgICAgICAgIC5nZXQodGhpcylcbiAgICAgICAgICAgICAgICAgICAgLmtleXJpbmcuY3JlYXRlTmV3VmF1bHRBbmRLZXljaGFpbihwYXNzd29yZCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJZGVudGl0aWVzKHlpZWxkIHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLmdldEFjY291bnRzKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZnVsbFVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGF0dXMgb2YgdGhlIHZhdWx0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIEJvb2xlYW4gcmV0dXJuaW5nIHRydWUgaWYgdGhlIHZhdWx0IGlzIHVubG9ja2VkXG4gICAgICovXG4gICAgaXNVbmxvY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLm1lbVN0b3JlLmdldFN0YXRlKCkuaXNVbmxvY2tlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2VlZCBwaHJhc2Ugb2YgdGhlIEhEIGtleXJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXNzd29yZCAtIFBhc3N3b3JkIG9mIHRoZSBrZXlyaW5nXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgc2VlZCBwaHJhc2VcbiAgICAgKi9cbiAgICBleHBvcnRTZWVkUGhyYXNlKHBhc3N3b3JkKSB7XG4gICAgICAgIGlmIChwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5wYXNzd29yZCA9PT0gcGFzc3dvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5rZXlyaW5nc1swXS5tbmVtb25pYztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFzc3dvcmQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcHJpdmF0ZSBrZXkgZnJvbSB0aGUga2V5cmluZyBjb250cm9sbGluZyBhbiBhZGRyZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFzc3dvcmQgLSBQYXNzd29yZCBvZiB0aGUga2V5cmluZ1xuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gQWRkcmVzcyB0byBleHBvcnRcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBwcml2YXRlIGtleSBmb3IgYW4gYWRkcmVzc1xuICAgICAqL1xuICAgIGV4cG9ydEFjY291bnQocGFzc3dvcmQsIGFkZHJlc3MpIHtcbiAgICAgICAgaWYgKHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLnBhc3N3b3JkID09PSBwYXNzd29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLmV4cG9ydEFjY291bnQoYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhc3N3b3JkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHB1YmxpYyBhZGRyZXNzZXMgb2YgYWxsIGFjY291bnRzIGZvciB0aGUgY3VycmVudCBrZXlyaW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gYXJyYXkgb2YgYWRkcmVzc2VzXG4gICAgICovXG4gICAgZ2V0QWNjb3VudHMoKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5nZXRBY2NvdW50cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBvcnRzIGFuIGFjY291bnQgd2l0aCB0aGUgc3BlY2lmaWVkIGltcG9ydCBzdHJhdGVneVxuICAgICAqXG4gICAgICogQHBhcmFtIHN0cmF0ZWd5IC0gSW1wb3J0IHN0cmF0ZWd5IG5hbWVcbiAgICAgKiBAcGFyYW0gYXJncyAtIEFycmF5IG9mIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSB1bmRlcmx5aW5nIHN0YXRlZ3lcbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgd2hlbiBwYXNzZWQgYW4gdW5yZWNvZ25pemVkIHN0cmF0ZWd5XG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byBjdXJyZW50IHN0YXRlIHdoZW4gdGhlIGltcG9ydCBpcyBjb21wbGV0ZVxuICAgICAqL1xuICAgIGltcG9ydEFjY291bnRXaXRoU3RyYXRlZ3koc3RyYXRlZ3ksIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBwcml2YXRlS2V5O1xuICAgICAgICAgICAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3ByaXZhdGVLZXknOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbaW1wb3J0ZWRLZXldID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbXBvcnRlZEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW1wb3J0IGFuIGVtcHR5IGtleS4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXhlZCA9IGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeChpbXBvcnRlZEtleSk7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV0aGVyZXVtanNfdXRpbF8xLmlzVmFsaWRQcml2YXRlKGV0aGVyZXVtanNfdXRpbF8xLnRvQnVmZmVyKHByZWZpeGVkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGltcG9ydCBpbnZhbGlkIHByaXZhdGUga2V5LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXkgPSBldGhqc191dGlsXzEuc3RyaXBIZXhQcmVmaXgocHJlZml4ZWQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdhbGxldDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2lucHV0LCBwYXNzd29yZF0gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FsbGV0ID0gZXRoZXJldW1qc193YWxsZXRfMS50aGlyZHBhcnR5LmZyb21FdGhlcldhbGxldChpbnB1dCwgcGFzc3dvcmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXQgPSB3YWxsZXQgfHwgKHlpZWxkIGV0aGVyZXVtanNfd2FsbGV0XzEuZGVmYXVsdC5mcm9tVjMoaW5wdXQsIHBhc3N3b3JkLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZUtleSA9IGV0aGVyZXVtanNfdXRpbF8xLmJ1ZmZlclRvSGV4KHdhbGxldC5nZXRQcml2YXRlS2V5KCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW1wb3J0IHN0cmF0ZWd5OiAnJHtzdHJhdGVneX0nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdLZXlyaW5nID0geWllbGQgcHJpdmF0ZXNcbiAgICAgICAgICAgICAgICAuZ2V0KHRoaXMpXG4gICAgICAgICAgICAgICAgLmtleXJpbmcuYWRkTmV3S2V5cmluZyhLZXlyaW5nVHlwZXMuc2ltcGxlLCBbcHJpdmF0ZUtleV0pO1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSB5aWVsZCBuZXdLZXlyaW5nLmdldEFjY291bnRzKCk7XG4gICAgICAgICAgICBjb25zdCBhbGxBY2NvdW50cyA9IHlpZWxkIHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLmdldEFjY291bnRzKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUlkZW50aXRpZXMoYWxsQWNjb3VudHMpO1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3RlZEFkZHJlc3MoYWNjb3VudHNbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVsbFVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBhY2NvdW50IGZyb20ga2V5cmluZyBzdGF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBBZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgY3VycmVudCBzdGF0ZSB3aGVuIHRoaXMgYWNjb3VudCByZW1vdmFsIGNvbXBsZXRlc1xuICAgICAqL1xuICAgIHJlbW92ZUFjY291bnQoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVJZGVudGl0eShhZGRyZXNzKTtcbiAgICAgICAgICAgIHlpZWxkIHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLnJlbW92ZUFjY291bnQoYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdWxsVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWFsbG9jYXRlcyBhbGwgc2VjcmV0cyBhbmQgbG9ja3MgdGhlIHdhbGxldFxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byBjdXJyZW50IHN0YXRlXG4gICAgICovXG4gICAgc2V0TG9ja2VkKCkge1xuICAgICAgICByZXR1cm4gcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcuc2V0TG9ja2VkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgYnkgY2FsbGluZyBkb3duIGludG8gYSBzcGVjaWZpYyBrZXlyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVBhcmFtcyAtIFBlcnNvbmFsTWVzc2FnZVBhcmFtcyBvYmplY3QgdG8gc2lnblxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gYSBzaWduZWQgbWVzc2FnZSBzdHJpbmdcbiAgICAgKi9cbiAgICBzaWduTWVzc2FnZShtZXNzYWdlUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5zaWduTWVzc2FnZShtZXNzYWdlUGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgcGVyc29uYWwgbWVzc2FnZSBieSBjYWxsaW5nIGRvd24gaW50byBhIHNwZWNpZmljIGtleXJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlUGFyYW1zIC0gUGVyc29uYWxNZXNzYWdlUGFyYW1zIG9iamVjdCB0byBzaWduXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byBhIHNpZ25lZCBtZXNzYWdlIHN0cmluZ1xuICAgICAqL1xuICAgIHNpZ25QZXJzb25hbE1lc3NhZ2UobWVzc2FnZVBhcmFtcykge1xuICAgICAgICByZXR1cm4gcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcuc2lnblBlcnNvbmFsTWVzc2FnZShtZXNzYWdlUGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgdHlwZWQgbWVzc2FnZSBieSBjYWxsaW5nIGRvd24gaW50byBhIHNwZWNpZmljIGtleXJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlUGFyYW1zIC0gVHlwZWRNZXNzYWdlUGFyYW1zIG9iamVjdCB0byBzaWduXG4gICAgICogQHBhcmFtIHZlcnNpb24gLSBDb21wYXRpYmlsaXR5IHZlcnNpb24gRUlQNzEyXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IHdoZW4gcGFzc2VkIGFuIHVucmVjb2duaXplZCB2ZXJzaW9uXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byBhIHNpZ25lZCBtZXNzYWdlIHN0cmluZyBvciBhbiBlcnJvciBpZiBhbnlcbiAgICAgKi9cbiAgICBzaWduVHlwZWRNZXNzYWdlKG1lc3NhZ2VQYXJhbXMsIHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGV0aF9zaWdfdXRpbF8xLm5vcm1hbGl6ZShtZXNzYWdlUGFyYW1zLmZyb20pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFzc3dvcmQgfSA9IHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSB5aWVsZCB0aGlzLmV4cG9ydEFjY291bnQocGFzc3dvcmQsIGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByaXZhdGVLZXlCdWZmZXIgPSBldGhlcmV1bWpzX3V0aWxfMS50b0J1ZmZlcihldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgocHJpdmF0ZUtleSkpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFNpZ25UeXBlZERhdGFWZXJzaW9uLlYxOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2lnblR5cGVkRGF0YUxlZ2FjeSB3aWxsIHRocm93IGlmIHRoZSBkYXRhIGlzIGludmFsaWQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXRoX3NpZ191dGlsXzEuc2lnblR5cGVkRGF0YUxlZ2FjeShwcml2YXRlS2V5QnVmZmVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogbWVzc2FnZVBhcmFtcy5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU2lnblR5cGVkRGF0YVZlcnNpb24uVjM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXRoX3NpZ191dGlsXzEuc2lnblR5cGVkRGF0YShwcml2YXRlS2V5QnVmZmVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogSlNPTi5wYXJzZShtZXNzYWdlUGFyYW1zLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU2lnblR5cGVkRGF0YVZlcnNpb24uVjQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXRoX3NpZ191dGlsXzEuc2lnblR5cGVkRGF0YV92NChwcml2YXRlS2V5QnVmZmVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogSlNPTi5wYXJzZShtZXNzYWdlUGFyYW1zLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgc2lnblR5cGVkTWVzc2FnZSB2ZXJzaW9uOiAnJHt2ZXJzaW9ufSdgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleXJpbmcgQ29udHJvbGxlciBzaWduVHlwZWRNZXNzYWdlOiAke2Vycm9yfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgYSB0cmFuc2FjdGlvbiBieSBjYWxsaW5nIGRvd24gaW50byBhIHNwZWNpZmljIGtleXJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRyYW5zYWN0aW9uIG9iamVjdCB0byBzaWduLiBNdXN0IGJlIGEgYGV0aGVyZXVtanMtdHhgIHRyYW5zYWN0aW9uIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSBmcm9tIC0gQWRkcmVzcyB0byBzaWduIGZyb20sIHNob3VsZCBiZSBpbiBrZXljaGFpblxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gYSBzaWduZWQgdHJhbnNhY3Rpb24gc3RyaW5nXG4gICAgICovXG4gICAgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBmcm9tKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBkZWNyeXB0IHRoZSBjdXJyZW50IHZhdWx0IGFuZCBsb2FkIGl0cyBrZXlyaW5nc1xuICAgICAqXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIC0gUGFzc3dvcmQgdG8gdW5sb2NrIHRoZSBrZXljaGFpblxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgKi9cbiAgICBzdWJtaXRQYXNzd29yZChwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcuc3VibWl0UGFzc3dvcmQocGFzc3dvcmQpO1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSB5aWVsZCBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zeW5jSWRlbnRpdGllcyhhY2NvdW50cyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdWxsVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIG5ldyBsaXN0ZW5lciB0byBiZSBub3RpZmllZCBvZiBzdGF0ZSBjaGFuZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBDYWxsYmFjayB0cmlnZ2VyZWQgd2hlbiBzdGF0ZSBjaGFuZ2VzXG4gICAgICovXG4gICAgc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgICAgIHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLnN0b3JlLnN1YnNjcmliZShsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZXhpc3RpbmcgbGlzdGVuZXIgZnJvbSByZWNlaXZpbmcgc3RhdGUgY2hhbmdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gQ2FsbGJhY2sgdG8gcmVtb3ZlXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIGEgbGlzdGVuZXIgaXMgZm91bmQgYW5kIHVuc3Vic2NyaWJlZFxuICAgICAqL1xuICAgIHVuc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5zdG9yZS51bnN1YnNjcmliZShsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgbmV3IGxpc3RlbmVyIHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHdhbGxldCBpcyBsb2NrZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIENhbGxiYWNrIHRyaWdnZXJlZCB3aGVuIHdhbGxldCBpcyBsb2NrZWRcbiAgICAgKiBAcmV0dXJucyAtIEV2ZW50RW1pdHRlciBpZiBsaXN0ZW5lciBhZGRlZFxuICAgICAqL1xuICAgIG9uTG9jayhsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcub24oJ2xvY2snLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgbmV3IGxpc3RlbmVyIHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHdhbGxldCBpcyB1bmxvY2tlZFxuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gQ2FsbGJhY2sgdHJpZ2dlcmVkIHdoZW4gd2FsbGV0IGlzIHVubG9ja2VkXG4gICAgICogQHJldHVybnMgLSBFdmVudEVtaXR0ZXIgaWYgbGlzdGVuZXIgYWRkZWRcbiAgICAgKi9cbiAgICBvblVubG9jayhsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcub24oJ3VubG9jaycsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgdGhlIHRoYXQgdGhlIHNlZWQgcGhyYXNlIHJlc3RvcmVzIHRoZSBjdXJyZW50IGtleWNoYWluJ3MgYWNjb3VudHNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgaWYgdGhlIHZlcmlmaWNhdGlvbiBzdWNjZWVkc1xuICAgICAqL1xuICAgIHZlcmlmeVNlZWRQaHJhc2UoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwcmltYXJ5S2V5cmluZyA9IHByaXZhdGVzXG4gICAgICAgICAgICAgICAgLmdldCh0aGlzKVxuICAgICAgICAgICAgICAgIC5rZXlyaW5nLmdldEtleXJpbmdzQnlUeXBlKEtleXJpbmdUeXBlcy5oZClbMF07XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICghcHJpbWFyeUtleXJpbmcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIEhEIGtleXJpbmcgZm91bmQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZWVkV29yZHMgPSAoeWllbGQgcHJpbWFyeUtleXJpbmcuc2VyaWFsaXplKCkpLm1uZW1vbmljO1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSB5aWVsZCBwcmltYXJ5S2V5cmluZy5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoYWNjb3VudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdmVyaWZ5IGFuIGVtcHR5IGtleXJpbmcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBUZXN0S2V5cmluZ0NsYXNzID0gcHJpdmF0ZXNcbiAgICAgICAgICAgICAgICAuZ2V0KHRoaXMpXG4gICAgICAgICAgICAgICAgLmtleXJpbmcuZ2V0S2V5cmluZ0NsYXNzRm9yVHlwZShLZXlyaW5nVHlwZXMuaGQpO1xuICAgICAgICAgICAgY29uc3QgdGVzdEtleXJpbmcgPSBuZXcgVGVzdEtleXJpbmdDbGFzcyh7XG4gICAgICAgICAgICAgICAgbW5lbW9uaWM6IHNlZWRXb3JkcyxcbiAgICAgICAgICAgICAgICBudW1iZXJPZkFjY291bnRzOiBhY2NvdW50cy5sZW5ndGgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RBY2NvdW50cyA9IHlpZWxkIHRlc3RLZXlyaW5nLmdldEFjY291bnRzKCk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0ZXN0QWNjb3VudHMubGVuZ3RoICE9PSBhY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlZWQgcGhyYXNlIGltcG9ydGVkIGluY29ycmVjdCBudW1iZXIgb2YgYWNjb3VudHMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXN0QWNjb3VudHMuZm9yRWFjaCgoYWNjb3VudCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmIChhY2NvdW50LnRvTG93ZXJDYXNlKCkgIT09IGFjY291bnRzW2ldLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWVkIHBocmFzZSBpbXBvcnRlZCBkaWZmZXJlbnQgYWNjb3VudHMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2VlZFdvcmRzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGtleXJpbmdzIGluIHN0YXRlIGFuZCBjYWxscyBLZXlyaW5nQ29udHJvbGxlciBmdWxsVXBkYXRlIG1ldGhvZCByZXR1cm5pbmcgY3VycmVudCBzdGF0ZVxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byBjdXJyZW50IHN0YXRlXG4gICAgICovXG4gICAgZnVsbFVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXJpbmdzID0geWllbGQgUHJvbWlzZS5hbGwocHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcua2V5cmluZ3MubWFwKChrZXlyaW5nLCBpbmRleCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXJpbmdBY2NvdW50cyA9IHlpZWxkIGtleXJpbmcuZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IEFycmF5LmlzQXJyYXkoa2V5cmluZ0FjY291bnRzKVxuICAgICAgICAgICAgICAgICAgICA/IGtleXJpbmdBY2NvdW50cy5tYXAoKGFkZHJlc3MpID0+IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKSlcbiAgICAgICAgICAgICAgICAgICAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGtleXJpbmcudHlwZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHsga2V5cmluZ3M6IFsuLi5rZXlyaW5nc10gfSk7XG4gICAgICAgICAgICByZXR1cm4gcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcuZnVsbFVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLktleXJpbmdDb250cm9sbGVyID0gS2V5cmluZ0NvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBLZXlyaW5nQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUtleXJpbmdDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYW5zYWN0aW9uQ29udHJvbGxlciA9IGV4cG9ydHMuU1BFRURfVVBfUkFURSA9IGV4cG9ydHMuQ0FOQ0VMX1JBVEUgPSBleHBvcnRzLldhbGxldERldmljZSA9IGV4cG9ydHMuVHJhbnNhY3Rpb25TdGF0dXMgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBldGhlcmV1bWpzX3V0aWxfMSA9IHJlcXVpcmUoXCJldGhlcmV1bWpzLXV0aWxcIik7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuY29uc3QgZXRoX21ldGhvZF9yZWdpc3RyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJldGgtbWV0aG9kLXJlZ2lzdHJ5XCIpKTtcbmNvbnN0IGV0aF9xdWVyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJldGgtcXVlcnlcIikpO1xuY29uc3QgY29tbW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBldGhlcmV1bWpzL2NvbW1vblwiKSk7XG5jb25zdCB0eF8xID0gcmVxdWlyZShcIkBldGhlcmV1bWpzL3R4XCIpO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG5jb25zdCBhc3luY19tdXRleF8xID0gcmVxdWlyZShcImFzeW5jLW11dGV4XCIpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuY29uc3QgSEFSREZPUksgPSAnbG9uZG9uJztcbi8qKlxuICogVGhlIHN0YXR1cyBvZiB0aGUgdHJhbnNhY3Rpb24uIEVhY2ggc3RhdHVzIHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSB0cmFuc2FjdGlvbiBpbnRlcm5hbGx5XG4gKiBpbiB0aGUgd2FsbGV0LiBTb21lIG9mIHRoZXNlIGNvcnJlc3BvbmQgd2l0aCB0aGUgc3RhdGUgb2YgdGhlIHRyYW5zYWN0aW9uIG9uIHRoZSBuZXR3b3JrLCBidXRcbiAqIHNvbWUgYXJlIHdhbGxldC1zcGVjaWZpYy5cbiAqL1xudmFyIFRyYW5zYWN0aW9uU3RhdHVzO1xuKGZ1bmN0aW9uIChUcmFuc2FjdGlvblN0YXR1cykge1xuICAgIFRyYW5zYWN0aW9uU3RhdHVzW1wiYXBwcm92ZWRcIl0gPSBcImFwcHJvdmVkXCI7XG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbXCJjYW5jZWxsZWRcIl0gPSBcImNhbmNlbGxlZFwiO1xuICAgIFRyYW5zYWN0aW9uU3RhdHVzW1wiY29uZmlybWVkXCJdID0gXCJjb25maXJtZWRcIjtcbiAgICBUcmFuc2FjdGlvblN0YXR1c1tcImZhaWxlZFwiXSA9IFwiZmFpbGVkXCI7XG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbXCJyZWplY3RlZFwiXSA9IFwicmVqZWN0ZWRcIjtcbiAgICBUcmFuc2FjdGlvblN0YXR1c1tcInNpZ25lZFwiXSA9IFwic2lnbmVkXCI7XG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbXCJzdWJtaXR0ZWRcIl0gPSBcInN1Ym1pdHRlZFwiO1xuICAgIFRyYW5zYWN0aW9uU3RhdHVzW1widW5hcHByb3ZlZFwiXSA9IFwidW5hcHByb3ZlZFwiO1xufSkoVHJhbnNhY3Rpb25TdGF0dXMgPSBleHBvcnRzLlRyYW5zYWN0aW9uU3RhdHVzIHx8IChleHBvcnRzLlRyYW5zYWN0aW9uU3RhdHVzID0ge30pKTtcbi8qKlxuICogT3B0aW9ucyBmb3Igd2FsbGV0IGRldmljZS5cbiAqL1xudmFyIFdhbGxldERldmljZTtcbihmdW5jdGlvbiAoV2FsbGV0RGV2aWNlKSB7XG4gICAgV2FsbGV0RGV2aWNlW1wiTU1fTU9CSUxFXCJdID0gXCJtZXRhbWFza19tb2JpbGVcIjtcbiAgICBXYWxsZXREZXZpY2VbXCJNTV9FWFRFTlNJT05cIl0gPSBcIm1ldGFtYXNrX2V4dGVuc2lvblwiO1xuICAgIFdhbGxldERldmljZVtcIk9USEVSXCJdID0gXCJvdGhlcl9kZXZpY2VcIjtcbn0pKFdhbGxldERldmljZSA9IGV4cG9ydHMuV2FsbGV0RGV2aWNlIHx8IChleHBvcnRzLldhbGxldERldmljZSA9IHt9KSk7XG4vKipcbiAqIE11bHRpcGxpZXIgdXNlZCB0byBkZXRlcm1pbmUgYSB0cmFuc2FjdGlvbidzIGluY3JlYXNlZCBnYXMgZmVlIGR1cmluZyBjYW5jZWxsYXRpb25cbiAqL1xuZXhwb3J0cy5DQU5DRUxfUkFURSA9IDEuNTtcbi8qKlxuICogTXVsdGlwbGllciB1c2VkIHRvIGRldGVybWluZSBhIHRyYW5zYWN0aW9uJ3MgaW5jcmVhc2VkIGdhcyBmZWUgZHVyaW5nIHNwZWVkIHVwXG4gKi9cbmV4cG9ydHMuU1BFRURfVVBfUkFURSA9IDEuMTtcbi8qKlxuICogQ29udHJvbGxlciByZXNwb25zaWJsZSBmb3Igc3VibWl0dGluZyBhbmQgbWFuYWdpbmcgdHJhbnNhY3Rpb25zXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0TmV0d29ya1N0YXRlIC0gR2V0cyB0aGUgc3RhdGUgb2YgdGhlIG5ldHdvcmsgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uTmV0d29ya1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIG5ldHdvcmsgY29udHJvbGxlciBzdGF0ZSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0UHJvdmlkZXIgLSBSZXR1cm5zIGEgcHJvdmlkZXIgZm9yIHRoZSBjdXJyZW50IG5ldHdvcmtcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgZ2V0TmV0d29ya1N0YXRlLCBvbk5ldHdvcmtTdGF0ZUNoYW5nZSwgZ2V0UHJvdmlkZXIsIH0sIGNvbmZpZywgc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzdGF0ZSk7XG4gICAgICAgIHRoaXMubXV0ZXggPSBuZXcgYXN5bmNfbXV0ZXhfMS5NdXRleCgpO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZVRva2VuVHggPSAodHhNZXRhLCBjdXJyZW50TmV0d29ya0lELCBjdXJyZW50Q2hhaW5JZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGltZSA9IHBhcnNlSW50KHR4TWV0YS50aW1lU3RhbXAsIDEwKSAqIDEwMDA7XG4gICAgICAgICAgICBjb25zdCB7IHRvLCBmcm9tLCBnYXMsIGdhc1ByaWNlLCBnYXNVc2VkLCBoYXNoLCBjb250cmFjdEFkZHJlc3MsIHRva2VuRGVjaW1hbCwgdG9rZW5TeW1ib2wsIHZhbHVlLCB9ID0gdHhNZXRhO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZDogdXVpZF8xLnYxKHsgbXNlY3M6IHRpbWUgfSksXG4gICAgICAgICAgICAgICAgaXNUcmFuc2ZlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBuZXR3b3JrSUQ6IGN1cnJlbnROZXR3b3JrSUQsXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogY3VycmVudENoYWluSWQsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBUcmFuc2FjdGlvblN0YXR1cy5jb25maXJtZWQsXG4gICAgICAgICAgICAgICAgdGltZSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiAxLFxuICAgICAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgICAgICBnYXMsXG4gICAgICAgICAgICAgICAgICAgIGdhc1ByaWNlLFxuICAgICAgICAgICAgICAgICAgICBnYXNVc2VkLFxuICAgICAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJJbmZvcm1hdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiBOdW1iZXIodG9rZW5EZWNpbWFsKSxcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiB0b2tlblN5bWJvbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHZlcmlmaWVkT25CbG9ja2NoYWluOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudEVtaXR0ZXIgaW5zdGFuY2UgdXNlZCB0byBsaXN0ZW4gdG8gc3BlY2lmaWMgdHJhbnNhY3Rpb25hbCBldmVudHNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaHViID0gbmV3IGV2ZW50c18xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdUcmFuc2FjdGlvbkNvbnRyb2xsZXInO1xuICAgICAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgICAgICBpbnRlcnZhbDogMTUwMDAsXG4gICAgICAgICAgICB0eEhpc3RvcnlMaW1pdDogNDAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xuICAgICAgICAgICAgbWV0aG9kRGF0YToge30sXG4gICAgICAgICAgICB0cmFuc2FjdGlvbnM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcigpO1xuICAgICAgICB0aGlzLmdldE5ldHdvcmtTdGF0ZSA9IGdldE5ldHdvcmtTdGF0ZTtcbiAgICAgICAgdGhpcy5ldGhRdWVyeSA9IG5ldyBldGhfcXVlcnlfMS5kZWZhdWx0KHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy5yZWdpc3RyeSA9IG5ldyBldGhfbWV0aG9kX3JlZ2lzdHJ5XzEuZGVmYXVsdCh7IHByb3ZpZGVyIH0pO1xuICAgICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdQcm92aWRlciA9IGdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICB0aGlzLmV0aFF1ZXJ5ID0gbmV3IGV0aF9xdWVyeV8xLmRlZmF1bHQobmV3UHJvdmlkZXIpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RyeSA9IG5ldyBldGhfbWV0aG9kX3JlZ2lzdHJ5XzEuZGVmYXVsdCh7IHByb3ZpZGVyOiBuZXdQcm92aWRlciB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucG9sbCgpO1xuICAgIH1cbiAgICBmYWlsVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25NZXRhLCBlcnJvcikge1xuICAgICAgICBjb25zdCBuZXdUcmFuc2FjdGlvbk1ldGEgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyYW5zYWN0aW9uTWV0YSksIHsgZXJyb3IsIHN0YXR1czogVHJhbnNhY3Rpb25TdGF0dXMuZmFpbGVkIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zYWN0aW9uKG5ld1RyYW5zYWN0aW9uTWV0YSk7XG4gICAgICAgIHRoaXMuaHViLmVtaXQoYCR7dHJhbnNhY3Rpb25NZXRhLmlkfTpmaW5pc2hlZGAsIG5ld1RyYW5zYWN0aW9uTWV0YSk7XG4gICAgfVxuICAgIHJlZ2lzdHJ5TG9va3VwKGZvdXJCeXRlUHJlZml4KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWdpc3RyeU1ldGhvZCA9IHlpZWxkIHRoaXMucmVnaXN0cnkubG9va3VwKGZvdXJCeXRlUHJlZml4KTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJlZ2lzdHJ5TWV0aG9kID0gdGhpcy5yZWdpc3RyeS5wYXJzZShyZWdpc3RyeU1ldGhvZCk7XG4gICAgICAgICAgICByZXR1cm4geyByZWdpc3RyeU1ldGhvZCwgcGFyc2VkUmVnaXN0cnlNZXRob2QgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgdGhlIHRyYW5zYWN0aW9uIGluZm9ybWF0aW9uIGZyb20gZXRoZXJzY2FuXG4gICAgICogdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBUcmFuc2FjdGlvbk1ldGEgaW50ZXJmYWNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHhNZXRhIC0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRyYW5zYWN0aW9uIGluZm9ybWF0aW9uXG4gICAgICogQHBhcmFtIGN1cnJlbnROZXR3b3JrSUQgLSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IG5ldHdvcmsgaWRcbiAgICAgKiBAcGFyYW0gY3VycmVudENoYWluSWQgLSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IGNoYWluIGlkXG4gICAgICogQHJldHVybnMgLSBUcmFuc2FjdGlvbk1ldGFcbiAgICAgKi9cbiAgICBub3JtYWxpemVUeCh0eE1ldGEsIGN1cnJlbnROZXR3b3JrSUQsIGN1cnJlbnRDaGFpbklkKSB7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBwYXJzZUludCh0eE1ldGEudGltZVN0YW1wLCAxMCkgKiAxMDAwO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkVHJhbnNhY3Rpb25CYXNlID0ge1xuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHR4TWV0YS5ibG9ja051bWJlcixcbiAgICAgICAgICAgIGlkOiB1dWlkXzEudjEoeyBtc2VjczogdGltZSB9KSxcbiAgICAgICAgICAgIG5ldHdvcmtJRDogY3VycmVudE5ldHdvcmtJRCxcbiAgICAgICAgICAgIGNoYWluSWQ6IGN1cnJlbnRDaGFpbklkLFxuICAgICAgICAgICAgdGltZSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgZGF0YTogdHhNZXRhLmlucHV0LFxuICAgICAgICAgICAgICAgIGZyb206IHR4TWV0YS5mcm9tLFxuICAgICAgICAgICAgICAgIGdhczogdXRpbF8xLkJOVG9IZXgobmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKHR4TWV0YS5nYXMpKSxcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogdXRpbF8xLkJOVG9IZXgobmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKHR4TWV0YS5nYXNQcmljZSkpLFxuICAgICAgICAgICAgICAgIGdhc1VzZWQ6IHV0aWxfMS5CTlRvSGV4KG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTih0eE1ldGEuZ2FzVXNlZCkpLFxuICAgICAgICAgICAgICAgIG5vbmNlOiB1dGlsXzEuQk5Ub0hleChuZXcgZXRoZXJldW1qc191dGlsXzEuQk4odHhNZXRhLm5vbmNlKSksXG4gICAgICAgICAgICAgICAgdG86IHR4TWV0YS50byxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdXRpbF8xLkJOVG9IZXgobmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKHR4TWV0YS52YWx1ZSkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogdHhNZXRhLmhhc2gsXG4gICAgICAgICAgICB2ZXJpZmllZE9uQmxvY2tjaGFpbjogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICh0eE1ldGEuaXNFcnJvciA9PT0gJzAnKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBub3JtYWxpemVkVHJhbnNhY3Rpb25CYXNlKSwgeyBzdGF0dXM6IFRyYW5zYWN0aW9uU3RhdHVzLmNvbmZpcm1lZCB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBub3JtYWxpemVkVHJhbnNhY3Rpb25CYXNlKSwgeyBlcnJvcjogbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBmYWlsZWQnKSwgc3RhdHVzOiBUcmFuc2FjdGlvblN0YXR1cy5mYWlsZWQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhIG5ldyBwb2xsaW5nIGludGVydmFsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW50ZXJ2YWwgLSBQb2xsaW5nIGludGVydmFsIHVzZWQgdG8gZmV0Y2ggbmV3IHRyYW5zYWN0aW9uIHN0YXR1c2VzXG4gICAgICovXG4gICAgcG9sbChpbnRlcnZhbCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaW50ZXJ2YWwgJiYgdGhpcy5jb25maWd1cmUoeyBpbnRlcnZhbCB9LCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGUgJiYgY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKTtcbiAgICAgICAgICAgIHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IHRoaXMucXVlcnlUcmFuc2FjdGlvblN0YXR1c2VzKCkpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvbGwodGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfSwgdGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIG5ldyBtZXRob2QgZGF0YSByZXF1ZXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm91ckJ5dGVQcmVmaXggLSBTdHJpbmcgY29ycmVzcG9uZGluZyB0byBtZXRob2QgcHJlZml4XG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byBtZXRob2QgZGF0YSBvYmplY3QgY29ycmVzcG9uZGluZyB0byBzaWduYXR1cmUgcHJlZml4XG4gICAgICovXG4gICAgaGFuZGxlTWV0aG9kRGF0YShmb3VyQnl0ZVByZWZpeCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVsZWFzZUxvY2sgPSB5aWVsZCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBtZXRob2REYXRhIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtub3duTWV0aG9kID0gT2JqZWN0LmtleXMobWV0aG9kRGF0YSkuZmluZCgoa25vd25Gb3VyQnl0ZVByZWZpeCkgPT4gZm91ckJ5dGVQcmVmaXggPT09IGtub3duRm91ckJ5dGVQcmVmaXgpO1xuICAgICAgICAgICAgICAgIGlmIChrbm93bk1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kRGF0YVtmb3VyQnl0ZVByZWZpeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0geWllbGQgdGhpcy5yZWdpc3RyeUxvb2t1cChmb3VyQnl0ZVByZWZpeCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2REYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1ldGhvZERhdGEpLCB7IFtmb3VyQnl0ZVByZWZpeF06IHJlZ2lzdHJ5IH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWdpc3RyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBuZXcgdW5hcHByb3ZlZCB0cmFuc2FjdGlvbiB0byBzdGF0ZS4gUGFyYW1ldGVycyB3aWxsIGJlIHZhbGlkYXRlZCwgYVxuICAgICAqIHVuaXF1ZSB0cmFuc2FjdGlvbiBpZCB3aWxsIGJlIGdlbmVyYXRlZCwgYW5kIGdhcyBhbmQgZ2FzUHJpY2Ugd2lsbCBiZSBjYWxjdWxhdGVkXG4gICAgICogaWYgbm90IHByb3ZpZGVkLiBJZiBBIGA8dHguaWQ+OnVuYXBwcm92ZWRgIGh1YiBldmVudCB3aWxsIGJlIGVtaXR0ZWQgb25jZSBhZGRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRyYW5zYWN0aW9uIG9iamVjdCB0byBhZGRcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gRG9tYWluIG9yaWdpbiB0byBhcHBlbmQgdG8gdGhlIGdlbmVyYXRlZCBUcmFuc2FjdGlvbk1ldGFcbiAgICAgKiBAcGFyYW0gZGV2aWNlQ29uZmlybWVkT24gLSBlbnVtIHRvIGluZGljYXRlIHdoYXQgZGV2aWNlIHRoZSB0cmFuc2FjdGlvbiB3YXMgY29uZmlybWVkIHRvIGFwcGVuZCB0byB0aGUgZ2VuZXJhdGVkIFRyYW5zYWN0aW9uTWV0YVxuICAgICAqIEByZXR1cm5zIC0gT2JqZWN0IGNvbnRhaW5pbmcgYSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgdHJhbnNhY3Rpb24gaGFzaCBpZiBhcHByb3ZlZFxuICAgICAqL1xuICAgIGFkZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBvcmlnaW4sIGRldmljZUNvbmZpcm1lZE9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3ZpZGVyLCBuZXR3b3JrIH0gPSB0aGlzLmdldE5ldHdvcmtTdGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbiA9IHV0aWxfMS5ub3JtYWxpemVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB1dGlsXzEudmFsaWRhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbk1ldGEgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IHV1aWRfMS52MSgpLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtJRDogbmV0d29yayxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBwcm92aWRlci5jaGFpbklkLFxuICAgICAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFRyYW5zYWN0aW9uU3RhdHVzLnVuYXBwcm92ZWQsXG4gICAgICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICBkZXZpY2VDb25maXJtZWRPbixcbiAgICAgICAgICAgICAgICB2ZXJpZmllZE9uQmxvY2tjaGFpbjogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGdhcyB9ID0geWllbGQgdGhpcy5lc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uZ2FzID0gZ2FzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25NZXRhLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmh1Yi5vbmNlKGAke3RyYW5zYWN0aW9uTWV0YS5pZH06ZmluaXNoZWRgLCAobWV0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1ldGEuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdHVzLnN1Ym1pdHRlZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShtZXRhLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdHVzLnJlamVjdGVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdCgnVXNlciByZWplY3RlZCB0aGUgdHJhbnNhY3Rpb24nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdHVzLmNhbmNlbGxlZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCgnVXNlciBjYW5jZWxsZWQgdGhlIHRyYW5zYWN0aW9uJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUcmFuc2FjdGlvblN0YXR1cy5mYWlsZWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW50ZXJuYWwobWV0YS5lcnJvci5tZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbChgTWV0YU1hc2sgVHggU2lnbmF0dXJlOiBVbmtub3duIHByb2JsZW06ICR7SlNPTi5zdHJpbmdpZnkobWV0YSl9YCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9ucy5wdXNoKHRyYW5zYWN0aW9uTWV0YSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHRyYW5zYWN0aW9uczogdGhpcy50cmltVHJhbnNhY3Rpb25zRm9yU3RhdGUodHJhbnNhY3Rpb25zKSB9KTtcbiAgICAgICAgICAgIHRoaXMuaHViLmVtaXQoYHVuYXBwcm92ZWRUcmFuc2FjdGlvbmAsIHRyYW5zYWN0aW9uTWV0YSk7XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQsIHRyYW5zYWN0aW9uTWV0YSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJlcGFyZVVuc2lnbmVkRXRoVHgodHhQYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHR4XzEuVHJhbnNhY3Rpb25GYWN0b3J5LmZyb21UeERhdGEodHhQYXJhbXMsIHtcbiAgICAgICAgICAgIGNvbW1vbjogdGhpcy5nZXRDb21tb25Db25maWd1cmF0aW9uKCksXG4gICAgICAgICAgICBmcmVlemU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGV0aGVyZXVtanMvdHggdXNlcyBAZXRoZXJldW1qcy9jb21tb24gYXMgYSBjb25maWd1cmF0aW9uIHRvb2wgZm9yXG4gICAgICogc3BlY2lmeWluZyB3aGljaCBjaGFpbiwgbmV0d29yaywgaGFyZGZvcmsgYW5kIEVJUHMgdG8gc3VwcG9ydCBmb3JcbiAgICAgKiBhIHRyYW5zYWN0aW9uLiBCeSByZWZlcmVuY2luZyB0aGlzIGNvbmZpZ3VyYXRpb24sIGFuZCBhbmFseXppbmcgdGhlIGZpZWxkc1xuICAgICAqIHNwZWNpZmllZCBpbiB0eFBhcmFtcywgQGV0aGVyZXVtanMvdHggaXMgYWJsZSB0byBkZXRlcm1pbmUgd2hpY2ggRUlQLTI3MThcbiAgICAgKiB0cmFuc2FjdGlvbiB0eXBlIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJucyB7Q29tbW9ufSBjb21tb24gY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgKi9cbiAgICBnZXRDb21tb25Db25maWd1cmF0aW9uKCkge1xuICAgICAgICBjb25zdCB7IG5ldHdvcms6IG5ldHdvcmtJZCwgcHJvdmlkZXI6IHsgdHlwZTogY2hhaW4sIGNoYWluSWQsIG5pY2tuYW1lOiBuYW1lIH0sIH0gPSB0aGlzLmdldE5ldHdvcmtTdGF0ZSgpO1xuICAgICAgICBpZiAoY2hhaW4gIT09IGNvbnN0YW50c18xLlJQQykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjb21tb25fMS5kZWZhdWx0KHsgY2hhaW4sIGhhcmRmb3JrOiBIQVJERk9SSyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXN0b21DaGFpblBhcmFtcyA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBjaGFpbklkOiBwYXJzZUludChjaGFpbklkLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgbmV0d29ya0lkOiBwYXJzZUludChuZXR3b3JrSWQsIHVuZGVmaW5lZCksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjb21tb25fMS5kZWZhdWx0LmZvckN1c3RvbUNoYWluKGNvbnN0YW50c18xLk1BSU5ORVQsIGN1c3RvbUNoYWluUGFyYW1zLCBIQVJERk9SSyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcHJvdmVzIGEgdHJhbnNhY3Rpb24gYW5kIHVwZGF0ZXMgaXQncyBzdGF0dXMgaW4gc3RhdGUuIElmIHRoaXMgaXMgbm90IGFcbiAgICAgKiByZXRyeSB0cmFuc2FjdGlvbiwgYSBub25jZSB3aWxsIGJlIGdlbmVyYXRlZC4gVGhlIHRyYW5zYWN0aW9uIGlzIHNpZ25lZFxuICAgICAqIHVzaW5nIHRoZSBzaWduIGNvbmZpZ3VyYXRpb24gcHJvcGVydHksIHRoZW4gcHVibGlzaGVkIHRvIHRoZSBibG9ja2NoYWluLlxuICAgICAqIEEgYDx0eC5pZD46ZmluaXNoZWRgIGh1YiBldmVudCBpcyBmaXJlZCBhZnRlciBzdWNjZXNzIG9yIGZhaWx1cmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25JRCAtIElEIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBhcHByb3ZlXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoaXMgb3BlcmF0aW9uIGNvbXBsZXRlc1xuICAgICAqL1xuICAgIGFwcHJvdmVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbklEKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VMb2NrID0geWllbGQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgICAgICBjb25zdCB7IHByb3ZpZGVyIH0gPSB0aGlzLmdldE5ldHdvcmtTdGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgeyBjaGFpbklkOiBjdXJyZW50Q2hhaW5JZCB9ID0gcHJvdmlkZXI7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRyYW5zYWN0aW9ucy5maW5kSW5kZXgoKHsgaWQgfSkgPT4gdHJhbnNhY3Rpb25JRCA9PT0gaWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25NZXRhID0gdHJhbnNhY3Rpb25zW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9uY2UgfSA9IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBmcm9tIH0gPSB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25NZXRhLCBuZXcgRXJyb3IoJ05vIHNpZ24gbWV0aG9kIGRlZmluZWQuJykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJyZW50Q2hhaW5JZCkge1xuICAgICAgICAgICAgICAgICAgICByZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk1ldGEsIG5ldyBFcnJvcignTm8gY2hhaW5JZCBkZWZpbmVkLicpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbklkID0gcGFyc2VJbnQoY3VycmVudENoYWluSWQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhcHByb3ZlZDogc3RhdHVzIH0gPSBUcmFuc2FjdGlvblN0YXR1cztcbiAgICAgICAgICAgICAgICBjb25zdCB0eE5vbmNlID0gbm9uY2UgfHxcbiAgICAgICAgICAgICAgICAgICAgKHlpZWxkIHV0aWxfMS5xdWVyeSh0aGlzLmV0aFF1ZXJ5LCAnZ2V0VHJhbnNhY3Rpb25Db3VudCcsIFtmcm9tLCAncGVuZGluZyddKSk7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25NZXRhLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24ubm9uY2UgPSB0eE5vbmNlO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlVHhQYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbiksIHsgZ2FzTGltaXQ6IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5nYXMsIGNoYWluSWQsIG5vbmNlOiB0eE5vbmNlLCBzdGF0dXMgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNFSVAxNTU5ID0gdXRpbF8xLmlzRUlQMTU1OVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgdHhQYXJhbXMgPSBpc0VJUDE1NTlcbiAgICAgICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJhc2VUeFBhcmFtcyksIHsgbWF4RmVlUGVyR2FzOiB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhczogdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLm1heFByaW9yaXR5RmVlUGVyR2FzLCBlc3RpbWF0ZWRCYXNlRmVlOiB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24uZXN0aW1hdGVkQmFzZUZlZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZ5IHR5cGUgMiBpZiBtYXhGZWVQZXJHYXMgYW5kIG1heFByaW9yaXR5RmVlUGVyR2FzIGFyZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDIgfSkgOiBiYXNlVHhQYXJhbXM7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIGdhc1ByaWNlIGlmIG1heEZlZVBlckdhcyBhbmQgbWF4UHJpb3JpdHlGZWVQZXJHYXMgYXJlIHNldFxuICAgICAgICAgICAgICAgIGlmIChpc0VJUDE1NTkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHR4UGFyYW1zLmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB1bnNpZ25lZEV0aFR4ID0gdGhpcy5wcmVwYXJlVW5zaWduZWRFdGhUeCh0eFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmVkVHggPSB5aWVsZCB0aGlzLnNpZ24odW5zaWduZWRFdGhUeCwgZnJvbSk7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25NZXRhLnN0YXR1cyA9IFRyYW5zYWN0aW9uU3RhdHVzLnNpZ25lZDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uTWV0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3VHJhbnNhY3Rpb24gPSBldGhlcmV1bWpzX3V0aWxfMS5idWZmZXJUb0hleChzaWduZWRUeC5zZXJpYWxpemUoKSk7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25NZXRhLnJhd1RyYW5zYWN0aW9uID0gcmF3VHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk1ldGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaCA9IHlpZWxkIHV0aWxfMS5xdWVyeSh0aGlzLmV0aFF1ZXJ5LCAnc2VuZFJhd1RyYW5zYWN0aW9uJywgW1xuICAgICAgICAgICAgICAgICAgICByYXdUcmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb25IYXNoID0gdHJhbnNhY3Rpb25IYXNoO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uTWV0YS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5zdWJtaXR0ZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk1ldGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuaHViLmVtaXQoYCR7dHJhbnNhY3Rpb25NZXRhLmlkfTpmaW5pc2hlZGAsIHRyYW5zYWN0aW9uTWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWxUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk1ldGEsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGEgdHJhbnNhY3Rpb24gYmFzZWQgb24gaXRzIElEIGJ5IHNldHRpbmcgaXRzIHN0YXR1cyB0byBcInJlamVjdGVkXCJcbiAgICAgKiBhbmQgZW1pdHRpbmcgYSBgPHR4LmlkPjpmaW5pc2hlZGAgaHViIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uSUQgLSBJRCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gY2FuY2VsXG4gICAgICovXG4gICAgY2FuY2VsVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25JRCkge1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbk1ldGEgPSB0aGlzLnN0YXRlLnRyYW5zYWN0aW9ucy5maW5kKCh7IGlkIH0pID0+IGlkID09PSB0cmFuc2FjdGlvbklEKTtcbiAgICAgICAgaWYgKCF0cmFuc2FjdGlvbk1ldGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2FjdGlvbk1ldGEuc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMucmVqZWN0ZWQ7XG4gICAgICAgIHRoaXMuaHViLmVtaXQoYCR7dHJhbnNhY3Rpb25NZXRhLmlkfTpmaW5pc2hlZGAsIHRyYW5zYWN0aW9uTWV0YSk7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IHRoaXMuc3RhdGUudHJhbnNhY3Rpb25zLmZpbHRlcigoeyBpZCB9KSA9PiBpZCAhPT0gdHJhbnNhY3Rpb25JRCk7XG4gICAgICAgIHRoaXMudXBkYXRlKHsgdHJhbnNhY3Rpb25zOiB0aGlzLnRyaW1UcmFuc2FjdGlvbnNGb3JTdGF0ZSh0cmFuc2FjdGlvbnMpIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBjYW5jZWwgYSB0cmFuc2FjdGlvbiBiYXNlZCBvbiBpdHMgSUQgYnkgc2V0dGluZyBpdHMgc3RhdHVzIHRvIFwicmVqZWN0ZWRcIlxuICAgICAqIGFuZCBlbWl0dGluZyBhIGA8dHguaWQ+OmZpbmlzaGVkYCBodWIgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25JRCAtIElEIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBjYW5jZWxcbiAgICAgKi9cbiAgICBzdG9wVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25JRCwgZ2FzVmFsdWVzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoZ2FzVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgdXRpbF8xLnZhbGlkYXRlR2FzVmFsdWVzKGdhc1ZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbk1ldGEgPSB0aGlzLnN0YXRlLnRyYW5zYWN0aW9ucy5maW5kKCh7IGlkIH0pID0+IGlkID09PSB0cmFuc2FjdGlvbklEKTtcbiAgICAgICAgICAgIGlmICghdHJhbnNhY3Rpb25NZXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnNpZ24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ24gbWV0aG9kIGRlZmluZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBnYXNQcmljZSAobGVnYWN5IG5vbiBFSVAxNTU5KVxuICAgICAgICAgICAgY29uc3QgbWluR2FzUHJpY2UgPSB1dGlsXzEuZ2V0SW5jcmVhc2VkUHJpY2VGcm9tRXhpc3RpbmcodHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmdhc1ByaWNlLCBleHBvcnRzLkNBTkNFTF9SQVRFKTtcbiAgICAgICAgICAgIGNvbnN0IGdhc1ByaWNlRnJvbVZhbHVlcyA9IHV0aWxfMS5pc0dhc1ByaWNlVmFsdWUoZ2FzVmFsdWVzKSAmJiBnYXNWYWx1ZXMuZ2FzUHJpY2U7XG4gICAgICAgICAgICBjb25zdCBuZXdHYXNQcmljZSA9IChnYXNQcmljZUZyb21WYWx1ZXMgJiZcbiAgICAgICAgICAgICAgICB1dGlsXzEudmFsaWRhdGVNaW5pbXVtSW5jcmVhc2UoZ2FzUHJpY2VGcm9tVmFsdWVzLCBtaW5HYXNQcmljZSkpIHx8XG4gICAgICAgICAgICAgICAgbWluR2FzUHJpY2U7XG4gICAgICAgICAgICAvLyBtYXhGZWVQZXJHYXMgKEVJUDE1NTkpXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ01heEZlZVBlckdhcyA9IChfYSA9IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1heEZlZVBlckdhcztcbiAgICAgICAgICAgIGNvbnN0IG1pbk1heEZlZVBlckdhcyA9IHV0aWxfMS5nZXRJbmNyZWFzZWRQcmljZUZyb21FeGlzdGluZyhleGlzdGluZ01heEZlZVBlckdhcywgZXhwb3J0cy5DQU5DRUxfUkFURSk7XG4gICAgICAgICAgICBjb25zdCBtYXhGZWVQZXJHYXNWYWx1ZXMgPSB1dGlsXzEuaXNGZWVNYXJrZXRFSVAxNTU5VmFsdWVzKGdhc1ZhbHVlcykgJiYgZ2FzVmFsdWVzLm1heEZlZVBlckdhcztcbiAgICAgICAgICAgIGNvbnN0IG5ld01heEZlZVBlckdhcyA9IChtYXhGZWVQZXJHYXNWYWx1ZXMgJiZcbiAgICAgICAgICAgICAgICB1dGlsXzEudmFsaWRhdGVNaW5pbXVtSW5jcmVhc2UobWF4RmVlUGVyR2FzVmFsdWVzLCBtaW5NYXhGZWVQZXJHYXMpKSB8fFxuICAgICAgICAgICAgICAgIChleGlzdGluZ01heEZlZVBlckdhcyAmJiBtaW5NYXhGZWVQZXJHYXMpO1xuICAgICAgICAgICAgLy8gbWF4UHJpb3JpdHlGZWVQZXJHYXMgKEVJUDE1NTkpXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ01heFByaW9yaXR5RmVlUGVyR2FzID0gKF9iID0gdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICBjb25zdCBtaW5NYXhQcmlvcml0eUZlZVBlckdhcyA9IHV0aWxfMS5nZXRJbmNyZWFzZWRQcmljZUZyb21FeGlzdGluZyhleGlzdGluZ01heFByaW9yaXR5RmVlUGVyR2FzLCBleHBvcnRzLkNBTkNFTF9SQVRFKTtcbiAgICAgICAgICAgIGNvbnN0IG1heFByaW9yaXR5RmVlUGVyR2FzVmFsdWVzID0gdXRpbF8xLmlzRmVlTWFya2V0RUlQMTU1OVZhbHVlcyhnYXNWYWx1ZXMpICYmIGdhc1ZhbHVlcy5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgIGNvbnN0IG5ld01heFByaW9yaXR5RmVlUGVyR2FzID0gKG1heFByaW9yaXR5RmVlUGVyR2FzVmFsdWVzICYmXG4gICAgICAgICAgICAgICAgdXRpbF8xLnZhbGlkYXRlTWluaW11bUluY3JlYXNlKG1heFByaW9yaXR5RmVlUGVyR2FzVmFsdWVzLCBtaW5NYXhQcmlvcml0eUZlZVBlckdhcykpIHx8XG4gICAgICAgICAgICAgICAgKGV4aXN0aW5nTWF4UHJpb3JpdHlGZWVQZXJHYXMgJiYgbWluTWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICAgICAgY29uc3QgdHhQYXJhbXMgPSBuZXdNYXhGZWVQZXJHYXMgJiYgbmV3TWF4UHJpb3JpdHlGZWVQZXJHYXNcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmZyb20sXG4gICAgICAgICAgICAgICAgICAgIGdhc0xpbWl0OiB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24uZ2FzLFxuICAgICAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXM6IG5ld01heEZlZVBlckdhcyxcbiAgICAgICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IG5ld01heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgICAgICAgICBub25jZTogdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLm5vbmNlLFxuICAgICAgICAgICAgICAgICAgICB0bzogdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmZyb20sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnMHgwJyxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5mcm9tLFxuICAgICAgICAgICAgICAgICAgICBnYXNMaW1pdDogdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmdhcyxcbiAgICAgICAgICAgICAgICAgICAgZ2FzUHJpY2U6IG5ld0dhc1ByaWNlLFxuICAgICAgICAgICAgICAgICAgICBub25jZTogdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLm5vbmNlLFxuICAgICAgICAgICAgICAgICAgICB0bzogdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmZyb20sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnMHgwJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdW5zaWduZWRFdGhUeCA9IHRoaXMucHJlcGFyZVVuc2lnbmVkRXRoVHgodHhQYXJhbXMpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkVHggPSB5aWVsZCB0aGlzLnNpZ24odW5zaWduZWRFdGhUeCwgdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmZyb20pO1xuICAgICAgICAgICAgY29uc3QgcmF3VHJhbnNhY3Rpb24gPSBldGhlcmV1bWpzX3V0aWxfMS5idWZmZXJUb0hleChzaWduZWRUeC5zZXJpYWxpemUoKSk7XG4gICAgICAgICAgICB5aWVsZCB1dGlsXzEucXVlcnkodGhpcy5ldGhRdWVyeSwgJ3NlbmRSYXdUcmFuc2FjdGlvbicsIFtyYXdUcmFuc2FjdGlvbl0pO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25NZXRhLnN0YXR1cyA9IFRyYW5zYWN0aW9uU3RhdHVzLmNhbmNlbGxlZDtcbiAgICAgICAgICAgIHRoaXMuaHViLmVtaXQoYCR7dHJhbnNhY3Rpb25NZXRhLmlkfTpmaW5pc2hlZGAsIHRyYW5zYWN0aW9uTWV0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXBzIHRvIHNwZWVkIHVwIGEgdHJhbnNhY3Rpb24gaW5jcmVhc2luZyB0cmFuc2FjdGlvbiBnYXNQcmljZSBieSB0ZW4gcGVyY2VudFxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uSUQgLSBJRCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gc3BlZWQgdXBcbiAgICAgKi9cbiAgICBzcGVlZFVwVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25JRCwgZ2FzVmFsdWVzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoZ2FzVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgdXRpbF8xLnZhbGlkYXRlR2FzVmFsdWVzKGdhc1ZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbk1ldGEgPSB0aGlzLnN0YXRlLnRyYW5zYWN0aW9ucy5maW5kKCh7IGlkIH0pID0+IGlkID09PSB0cmFuc2FjdGlvbklEKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoIXRyYW5zYWN0aW9uTWV0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoIXRoaXMuc2lnbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbiBtZXRob2QgZGVmaW5lZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgLy8gZ2FzUHJpY2UgKGxlZ2FjeSBub24gRUlQMTU1OSlcbiAgICAgICAgICAgIGNvbnN0IG1pbkdhc1ByaWNlID0gdXRpbF8xLmdldEluY3JlYXNlZFByaWNlRnJvbUV4aXN0aW5nKHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5nYXNQcmljZSwgZXhwb3J0cy5TUEVFRF9VUF9SQVRFKTtcbiAgICAgICAgICAgIGNvbnN0IGdhc1ByaWNlRnJvbVZhbHVlcyA9IHV0aWxfMS5pc0dhc1ByaWNlVmFsdWUoZ2FzVmFsdWVzKSAmJiBnYXNWYWx1ZXMuZ2FzUHJpY2U7XG4gICAgICAgICAgICBjb25zdCBuZXdHYXNQcmljZSA9IChnYXNQcmljZUZyb21WYWx1ZXMgJiZcbiAgICAgICAgICAgICAgICB1dGlsXzEudmFsaWRhdGVNaW5pbXVtSW5jcmVhc2UoZ2FzUHJpY2VGcm9tVmFsdWVzLCBtaW5HYXNQcmljZSkpIHx8XG4gICAgICAgICAgICAgICAgbWluR2FzUHJpY2U7XG4gICAgICAgICAgICAvLyBtYXhGZWVQZXJHYXMgKEVJUDE1NTkpXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ01heEZlZVBlckdhcyA9IChfYSA9IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1heEZlZVBlckdhcztcbiAgICAgICAgICAgIGNvbnN0IG1pbk1heEZlZVBlckdhcyA9IHV0aWxfMS5nZXRJbmNyZWFzZWRQcmljZUZyb21FeGlzdGluZyhleGlzdGluZ01heEZlZVBlckdhcywgZXhwb3J0cy5TUEVFRF9VUF9SQVRFKTtcbiAgICAgICAgICAgIGNvbnN0IG1heEZlZVBlckdhc1ZhbHVlcyA9IHV0aWxfMS5pc0ZlZU1hcmtldEVJUDE1NTlWYWx1ZXMoZ2FzVmFsdWVzKSAmJiBnYXNWYWx1ZXMubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgY29uc3QgbmV3TWF4RmVlUGVyR2FzID0gKG1heEZlZVBlckdhc1ZhbHVlcyAmJlxuICAgICAgICAgICAgICAgIHV0aWxfMS52YWxpZGF0ZU1pbmltdW1JbmNyZWFzZShtYXhGZWVQZXJHYXNWYWx1ZXMsIG1pbk1heEZlZVBlckdhcykpIHx8XG4gICAgICAgICAgICAgICAgKGV4aXN0aW5nTWF4RmVlUGVyR2FzICYmIG1pbk1heEZlZVBlckdhcyk7XG4gICAgICAgICAgICAvLyBtYXhQcmlvcml0eUZlZVBlckdhcyAoRUlQMTU1OSlcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAoX2IgPSB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgIGNvbnN0IG1pbk1heFByaW9yaXR5RmVlUGVyR2FzID0gdXRpbF8xLmdldEluY3JlYXNlZFByaWNlRnJvbUV4aXN0aW5nKGV4aXN0aW5nTWF4UHJpb3JpdHlGZWVQZXJHYXMsIGV4cG9ydHMuU1BFRURfVVBfUkFURSk7XG4gICAgICAgICAgICBjb25zdCBtYXhQcmlvcml0eUZlZVBlckdhc1ZhbHVlcyA9IHV0aWxfMS5pc0ZlZU1hcmtldEVJUDE1NTlWYWx1ZXMoZ2FzVmFsdWVzKSAmJiBnYXNWYWx1ZXMubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICBjb25zdCBuZXdNYXhQcmlvcml0eUZlZVBlckdhcyA9IChtYXhQcmlvcml0eUZlZVBlckdhc1ZhbHVlcyAmJlxuICAgICAgICAgICAgICAgIHV0aWxfMS52YWxpZGF0ZU1pbmltdW1JbmNyZWFzZShtYXhQcmlvcml0eUZlZVBlckdhc1ZhbHVlcywgbWluTWF4UHJpb3JpdHlGZWVQZXJHYXMpKSB8fFxuICAgICAgICAgICAgICAgIChleGlzdGluZ01heFByaW9yaXR5RmVlUGVyR2FzICYmIG1pbk1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICAgICAgICAgIGNvbnN0IHR4UGFyYW1zID0gbmV3TWF4RmVlUGVyR2FzICYmIG5ld01heFByaW9yaXR5RmVlUGVyR2FzXG4gICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbiksIHsgZ2FzTGltaXQ6IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5nYXMsIG1heEZlZVBlckdhczogbmV3TWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhczogbmV3TWF4UHJpb3JpdHlGZWVQZXJHYXMsIHR5cGU6IDIgfSkgOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbiksIHsgZ2FzTGltaXQ6IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5nYXMsIGdhc1ByaWNlOiBuZXdHYXNQcmljZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHVuc2lnbmVkRXRoVHggPSB0aGlzLnByZXBhcmVVbnNpZ25lZEV0aFR4KHR4UGFyYW1zKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZFR4ID0geWllbGQgdGhpcy5zaWduKHVuc2lnbmVkRXRoVHgsIHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5mcm9tKTtcbiAgICAgICAgICAgIGNvbnN0IHJhd1RyYW5zYWN0aW9uID0gZXRoZXJldW1qc191dGlsXzEuYnVmZmVyVG9IZXgoc2lnbmVkVHguc2VyaWFsaXplKCkpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25IYXNoID0geWllbGQgdXRpbF8xLnF1ZXJ5KHRoaXMuZXRoUXVlcnksICdzZW5kUmF3VHJhbnNhY3Rpb24nLCBbXG4gICAgICAgICAgICAgICAgcmF3VHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VUcmFuc2FjdGlvbk1ldGEgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyYW5zYWN0aW9uTWV0YSksIHsgaWQ6IHV1aWRfMS52MSgpLCB0aW1lOiBEYXRlLm5vdygpLCB0cmFuc2FjdGlvbkhhc2ggfSk7XG4gICAgICAgICAgICBjb25zdCBuZXdUcmFuc2FjdGlvbk1ldGEgPSBuZXdNYXhGZWVQZXJHYXMgJiYgbmV3TWF4UHJpb3JpdHlGZWVQZXJHYXNcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYmFzZVRyYW5zYWN0aW9uTWV0YSksIHsgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uKSwgeyBtYXhGZWVQZXJHYXM6IG5ld01heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IG5ld01heFByaW9yaXR5RmVlUGVyR2FzIH0pIH0pIDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBiYXNlVHJhbnNhY3Rpb25NZXRhKSwgeyB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24pLCB7IGdhc1ByaWNlOiBuZXdHYXNQcmljZSB9KSB9KTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9ucy5wdXNoKG5ld1RyYW5zYWN0aW9uTWV0YSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHRyYW5zYWN0aW9uczogdGhpcy50cmltVHJhbnNhY3Rpb25zRm9yU3RhdGUodHJhbnNhY3Rpb25zKSB9KTtcbiAgICAgICAgICAgIHRoaXMuaHViLmVtaXQoYCR7dHJhbnNhY3Rpb25NZXRhLmlkfTpzcGVlZHVwYCwgbmV3VHJhbnNhY3Rpb25NZXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVzdGltYXRlcyByZXF1aXJlZCBnYXMgZm9yIGEgZ2l2ZW4gdHJhbnNhY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRyYW5zYWN0aW9uIG9iamVjdCB0byBlc3RpbWF0ZSBnYXMgZm9yXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0byBhbiBvYmplY3QgY29udGFpbmluZyBnYXMgYW5kIGdhc1ByaWNlXG4gICAgICovXG4gICAgZXN0aW1hdGVHYXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlZFRyYW5zYWN0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgdHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgY29uc3QgeyBnYXMsIGdhc1ByaWNlOiBwcm92aWRlZEdhc1ByaWNlLCB0bywgdmFsdWUsIGRhdGEsIH0gPSBlc3RpbWF0ZWRUcmFuc2FjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGdhc1ByaWNlID0gdHlwZW9mIHByb3ZpZGVkR2FzUHJpY2UgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyB5aWVsZCB1dGlsXzEucXVlcnkodGhpcy5ldGhRdWVyeSwgJ2dhc1ByaWNlJylcbiAgICAgICAgICAgICAgICA6IHByb3ZpZGVkR2FzUHJpY2U7XG4gICAgICAgICAgICBjb25zdCB7IGlzQ3VzdG9tTmV0d29yayB9ID0gdGhpcy5nZXROZXR3b3JrU3RhdGUoKTtcbiAgICAgICAgICAgIC8vIDEuIElmIGdhcyBpcyBhbHJlYWR5IGRlZmluZWQgb24gdGhlIHRyYW5zYWN0aW9uLCB1c2UgaXRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZ2FzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGdhcywgZ2FzUHJpY2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZ2FzTGltaXQgfSA9IHlpZWxkIHV0aWxfMS5xdWVyeSh0aGlzLmV0aFF1ZXJ5LCAnZ2V0QmxvY2tCeU51bWJlcicsIFtcbiAgICAgICAgICAgICAgICAnbGF0ZXN0JyxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgLy8gMi4gSWYgdG8gaXMgbm90IGRlZmluZWQgb3IgdGhpcyBpcyBub3QgYSBjb250cmFjdCBhZGRyZXNzLCBhbmQgdGhlcmUgaXMgbm8gZGF0YSB1c2UgMHg1MjA4IC8gMjEwMDAuXG4gICAgICAgICAgICAvLyBJZiB0aGUgbmV3dHdvcmsgaXMgYSBjdXN0b20gbmV0d29yayB0aGVuIGJ5cGFzcyB0aGlzIGNoZWNrIGFuZCBmZXRjaCAnZXN0aW1hdGVHYXMnLlxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB0byA/IHlpZWxkIHV0aWxfMS5xdWVyeSh0aGlzLmV0aFF1ZXJ5LCAnZ2V0Q29kZScsIFt0b10pIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmICghaXNDdXN0b21OZXR3b3JrICYmXG4gICAgICAgICAgICAgICAgKCF0byB8fCAodG8gJiYgIWRhdGEgJiYgKCFjb2RlIHx8IGNvZGUgPT09ICcweCcpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBnYXM6ICcweDUyMDgnLCBnYXNQcmljZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgZGF0YSwgc2hvdWxkIGJlIGhleCBzdHJpbmcgZm9ybWF0XG4gICAgICAgICAgICBlc3RpbWF0ZWRUcmFuc2FjdGlvbi5kYXRhID0gIWRhdGFcbiAgICAgICAgICAgICAgICA/IGRhdGFcbiAgICAgICAgICAgICAgICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeChkYXRhKTtcbiAgICAgICAgICAgIC8vIDMuIElmIHRoaXMgaXMgYSBjb250cmFjdCBhZGRyZXNzLCBzYWZlbHkgZXN0aW1hdGUgZ2FzIHVzaW5nIFJQQ1xuICAgICAgICAgICAgZXN0aW1hdGVkVHJhbnNhY3Rpb24udmFsdWUgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAnMHgwJyA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHZhbHVlO1xuICAgICAgICAgICAgY29uc3QgZ2FzTGltaXRCTiA9IHV0aWxfMS5oZXhUb0JOKGdhc0xpbWl0KTtcbiAgICAgICAgICAgIGVzdGltYXRlZFRyYW5zYWN0aW9uLmdhcyA9IHV0aWxfMS5CTlRvSGV4KHV0aWxfMS5mcmFjdGlvbkJOKGdhc0xpbWl0Qk4sIDE5LCAyMCkpO1xuICAgICAgICAgICAgY29uc3QgZ2FzSGV4ID0geWllbGQgdXRpbF8xLnF1ZXJ5KHRoaXMuZXRoUXVlcnksICdlc3RpbWF0ZUdhcycsIFtcbiAgICAgICAgICAgICAgICBlc3RpbWF0ZWRUcmFuc2FjdGlvbixcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgLy8gNC4gUGFkIGVzdGltYXRlZCBnYXMgd2l0aG91dCBleGNlZWRpbmcgdGhlIG1vc3QgcmVjZW50IGJsb2NrIGdhc0xpbWl0LiBJZiB0aGUgbmV0d29yayBpcyBhXG4gICAgICAgICAgICAvLyBhIGN1c3RvbSBuZXR3b3JrIHRoZW4gcmV0dXJuIHRoZSBldGhfZXN0aW1hdGVHYXMgdmFsdWUuXG4gICAgICAgICAgICBjb25zdCBnYXNCTiA9IHV0aWxfMS5oZXhUb0JOKGdhc0hleCk7XG4gICAgICAgICAgICBjb25zdCBtYXhHYXNCTiA9IGdhc0xpbWl0Qk4ubXVsbigwLjkpO1xuICAgICAgICAgICAgY29uc3QgcGFkZGVkR2FzQk4gPSBnYXNCTi5tdWxuKDEuNSk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKGdhc0JOLmd0KG1heEdhc0JOKSB8fCBpc0N1c3RvbU5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBnYXM6IGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeChnYXNIZXgpLCBnYXNQcmljZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmIChwYWRkZWRHYXNCTi5sdChtYXhHYXNCTikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBnYXM6IGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeCh1dGlsXzEuQk5Ub0hleChwYWRkZWRHYXNCTikpLCBnYXNQcmljZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZ2FzOiBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgodXRpbF8xLkJOVG9IZXgobWF4R2FzQk4pKSwgZ2FzUHJpY2UgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2lsaWVudGx5IGNoZWNrcyBhbGwgc3VibWl0dGVkIHRyYW5zYWN0aW9ucyBvbiB0aGUgYmxvY2tjaGFpblxuICAgICAqIGFuZCB2ZXJpZmllcyB0aGF0IGl0IGhhcyBiZWVuIGluY2x1ZGVkIGluIGEgYmxvY2tcbiAgICAgKiB3aGVuIHRoYXQgaGFwcGVucywgdGhlIHR4IHN0YXR1cyBpcyB1cGRhdGVkIHRvIGNvbmZpcm1lZFxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoaXMgb3BlcmF0aW9uIGNvbXBsZXRlc1xuICAgICAqL1xuICAgIHF1ZXJ5VHJhbnNhY3Rpb25TdGF0dXNlcygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgeyBwcm92aWRlciwgbmV0d29yazogY3VycmVudE5ldHdvcmtJRCB9ID0gdGhpcy5nZXROZXR3b3JrU3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZDogY3VycmVudENoYWluSWQgfSA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgbGV0IGdvdFVwZGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IFByb21pc2UuYWxsKHRyYW5zYWN0aW9ucy5tYXAoKG1ldGEsIGluZGV4KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNpbmcgZmFsbGJhY2sgdG8gbmV0d29ya0lEIG9ubHkgd2hlbiB0aGVyZSBpcyBubyBjaGFpbklkIHByZXNlbnQuXG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBuZXR3b3JrSUQgaXMgY29tcGxldGVseSByZW1vdmVkLlxuICAgICAgICAgICAgICAgIGNvbnN0IHR4QmVsb25nc1RvQ3VycmVudENoYWluID0gbWV0YS5jaGFpbklkID09PSBjdXJyZW50Q2hhaW5JZCB8fFxuICAgICAgICAgICAgICAgICAgICAoIW1ldGEuY2hhaW5JZCAmJiBtZXRhLm5ldHdvcmtJRCA9PT0gY3VycmVudE5ldHdvcmtJRCk7XG4gICAgICAgICAgICAgICAgaWYgKCFtZXRhLnZlcmlmaWVkT25CbG9ja2NoYWluICYmIHR4QmVsb25nc1RvQ3VycmVudENoYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtyZWNvbmNpbGVkVHgsIHVwZGF0ZVJlcXVpcmVkLF0gPSB5aWVsZCB0aGlzLmJsb2NrY2hhaW5UcmFuc2FjdGlvblN0YXRlUmVjb25jaWxlcihtZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnNbaW5kZXhdID0gcmVjb25jaWxlZFR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZ290VXBkYXRlcyA9IHVwZGF0ZVJlcXVpcmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpKSk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKGdvdFVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uczogdGhpcy50cmltVHJhbnNhY3Rpb25zRm9yU3RhdGUodHJhbnNhY3Rpb25zKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgdHJhbnNhY3Rpb24gaW4gc3RhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbk1ldGEgLSBOZXcgdHJhbnNhY3Rpb24gbWV0YSB0byBzdG9yZSBpbiBzdGF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uTWV0YSkge1xuICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uID0gdXRpbF8xLm5vcm1hbGl6ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbik7XG4gICAgICAgIHV0aWxfMS52YWxpZGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbik7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdHJhbnNhY3Rpb25zLmZpbmRJbmRleCgoeyBpZCB9KSA9PiB0cmFuc2FjdGlvbk1ldGEuaWQgPT09IGlkKTtcbiAgICAgICAgdHJhbnNhY3Rpb25zW2luZGV4XSA9IHRyYW5zYWN0aW9uTWV0YTtcbiAgICAgICAgdGhpcy51cGRhdGUoeyB0cmFuc2FjdGlvbnM6IHRoaXMudHJpbVRyYW5zYWN0aW9uc0ZvclN0YXRlKHRyYW5zYWN0aW9ucykgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRyYW5zYWN0aW9ucyBmcm9tIHN0YXRlLCBvcHRpb25hbGx5IGJhc2VkIG9uIHRoZSBjdXJyZW50IG5ldHdvcmtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZ25vcmVOZXR3b3JrIC0gSWdub3JlcyBuZXR3b3JrXG4gICAgICovXG4gICAgd2lwZVRyYW5zYWN0aW9ucyhpZ25vcmVOZXR3b3JrKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChpZ25vcmVOZXR3b3JrKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHRyYW5zYWN0aW9uczogW10gfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwcm92aWRlciwgbmV0d29yazogY3VycmVudE5ldHdvcmtJRCB9ID0gdGhpcy5nZXROZXR3b3JrU3RhdGUoKTtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkOiBjdXJyZW50Q2hhaW5JZCB9ID0gcHJvdmlkZXI7XG4gICAgICAgIGNvbnN0IG5ld1RyYW5zYWN0aW9ucyA9IHRoaXMuc3RhdGUudHJhbnNhY3Rpb25zLmZpbHRlcigoeyBuZXR3b3JrSUQsIGNoYWluSWQgfSkgPT4ge1xuICAgICAgICAgICAgLy8gVXNpbmcgZmFsbGJhY2sgdG8gbmV0d29ya0lEIG9ubHkgd2hlbiB0aGVyZSBpcyBubyBjaGFpbklkIHByZXNlbnQuIFNob3VsZCBiZSByZW1vdmVkIHdoZW4gbmV0d29ya0lEIGlzIGNvbXBsZXRlbHkgcmVtb3ZlZC5cbiAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudE5ldHdvcmsgPSBjaGFpbklkID09PSBjdXJyZW50Q2hhaW5JZCB8fFxuICAgICAgICAgICAgICAgICghY2hhaW5JZCAmJiBuZXR3b3JrSUQgPT09IGN1cnJlbnROZXR3b3JrSUQpO1xuICAgICAgICAgICAgcmV0dXJuICFpc0N1cnJlbnROZXR3b3JrO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiB0aGlzLnRyaW1UcmFuc2FjdGlvbnNGb3JTdGF0ZShuZXdUcmFuc2FjdGlvbnMpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgdHJhbnNhY3Rpb25zIGZyb20gZXRoZXJzY2FuIGZvciBhIHNwZWNpZmljIGFkZHJlc3NcbiAgICAgKiBvcHRpb25hbGx5IHN0YXJ0aW5nIGZyb20gYSBzcGVjaWZpYyBibG9ja1xuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSB0cmFuc2FjdGlvbnMgZnJvbVxuICAgICAqIEBwYXJhbSBvcHQgLSBPYmplY3QgY29udGFpbmluZyBvcHRpb25hbCBkYXRhLCBmcm9tQmxvY2sgYW5kIEFsZXRoaW8gQVBJIGtleVxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGJsb2NrIG51bWJlciBvZiB0aGUgbGF0ZXN0IGluY29taW5nIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGZldGNoQWxsKGFkZHJlc3MsIG9wdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBwcm92aWRlciwgbmV0d29yazogY3VycmVudE5ldHdvcmtJRCB9ID0gdGhpcy5nZXROZXR3b3JrU3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZDogY3VycmVudENoYWluSWQsIHR5cGU6IG5ldHdvcmtUeXBlIH0gPSBwcm92aWRlcjtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3Qgc3VwcG9ydGVkTmV0d29ya0lkcyA9IFsnMScsICczJywgJzQnLCAnNDInXTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoc3VwcG9ydGVkTmV0d29ya0lkcy5pbmRleE9mKGN1cnJlbnROZXR3b3JrSUQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbZXRoZXJzY2FuVHhSZXNwb25zZSwgZXRoZXJzY2FuVG9rZW5SZXNwb25zZSxdID0geWllbGQgdXRpbF8xLmhhbmRsZVRyYW5zYWN0aW9uRmV0Y2gobmV0d29ya1R5cGUsIGFkZHJlc3MsIHRoaXMuY29uZmlnLnR4SGlzdG9yeUxpbWl0LCBvcHQpO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZFR4cyA9IGV0aGVyc2NhblR4UmVzcG9uc2UucmVzdWx0Lm1hcCgodHgpID0+IHRoaXMubm9ybWFsaXplVHgodHgsIGN1cnJlbnROZXR3b3JrSUQsIGN1cnJlbnRDaGFpbklkKSk7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkVG9rZW5UeHMgPSBldGhlcnNjYW5Ub2tlblJlc3BvbnNlLnJlc3VsdC5tYXAoKHR4KSA9PiB0aGlzLm5vcm1hbGl6ZVRva2VuVHgodHgsIGN1cnJlbnROZXR3b3JrSUQsIGN1cnJlbnRDaGFpbklkKSk7XG4gICAgICAgICAgICBjb25zdCBbdXBkYXRlUmVxdWlyZWQsIGFsbFR4c10gPSB0aGlzLmV0aGVyc2NhblRyYW5zYWN0aW9uU3RhdGVSZWNvbmNpbGVyKFsuLi5ub3JtYWxpemVkVHhzLCAuLi5ub3JtYWxpemVkVG9rZW5UeHNdLCB0cmFuc2FjdGlvbnMpO1xuICAgICAgICAgICAgYWxsVHhzLnNvcnQoKGEsIGIpID0+IChhLnRpbWUgPCBiLnRpbWUgPyAtMSA6IDEpKTtcbiAgICAgICAgICAgIGxldCBsYXRlc3RJbmNvbWluZ1R4QmxvY2tOdW1iZXI7XG4gICAgICAgICAgICBhbGxUeHMuZm9yRWFjaCgodHgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyBVc2luZyBmYWxsYmFjayB0byBuZXR3b3JrSUQgb25seSB3aGVuIHRoZXJlIGlzIG5vIGNoYWluSWQgcHJlc2VudC4gU2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBuZXR3b3JrSUQgaXMgY29tcGxldGVseSByZW1vdmVkLlxuICAgICAgICAgICAgICAgICh0eC5jaGFpbklkID09PSBjdXJyZW50Q2hhaW5JZCB8fFxuICAgICAgICAgICAgICAgICAgICAoIXR4LmNoYWluSWQgJiYgdHgubmV0d29ya0lEID09PSBjdXJyZW50TmV0d29ya0lEKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgdHgudHJhbnNhY3Rpb24udG8gJiZcbiAgICAgICAgICAgICAgICAgICAgdHgudHJhbnNhY3Rpb24udG8udG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eC5ibG9ja051bWJlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFsYXRlc3RJbmNvbWluZ1R4QmxvY2tOdW1iZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUludChsYXRlc3RJbmNvbWluZ1R4QmxvY2tOdW1iZXIsIDEwKSA8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KHR4LmJsb2NrTnVtYmVyLCAxMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXRlc3RJbmNvbWluZ1R4QmxvY2tOdW1iZXIgPSB0eC5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmICh0eC50b1NtYXJ0Q29udHJhY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3QgYHRvYCBpcyBhIGNvbnRyYWN0IGRlcGxveSwgaWYgbm90IGBkYXRhYCBpcyBzZW5kIGV0aFxuICAgICAgICAgICAgICAgICAgICBpZiAodHgudHJhbnNhY3Rpb24udG8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICghdHgudHJhbnNhY3Rpb24uZGF0YSB8fCB0eC50cmFuc2FjdGlvbi5kYXRhICE9PSAnMHgnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IHlpZWxkIHV0aWxfMS5xdWVyeSh0aGlzLmV0aFF1ZXJ5LCAnZ2V0Q29kZScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC50cmFuc2FjdGlvbi50byxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHgudG9TbWFydENvbnRyYWN0ID0gdXRpbF8xLmlzU21hcnRDb250cmFjdENvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eC50b1NtYXJ0Q29udHJhY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0ZSBvbmx5IGlmIG5ldyB0cmFuc2FjdGlvbnMgd2VyZSBmZXRjaGVkIG9yXG4gICAgICAgICAgICAvLyB0aGUgc3RhdHVzIG9yIGdhcyBkYXRhIG9mIGEgdHJhbnNhY3Rpb24gaGFzIGNoYW5nZWRcbiAgICAgICAgICAgIGlmICh1cGRhdGVSZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgdHJhbnNhY3Rpb25zOiB0aGlzLnRyaW1UcmFuc2FjdGlvbnNGb3JTdGF0ZShhbGxUeHMpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxhdGVzdEluY29taW5nVHhCbG9ja051bWJlcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaW0gdGhlIGFtb3VudCBvZiB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgc2V0IG9uIHRoZSBzdGF0ZS4gQ2hlY2tzXG4gICAgICogaWYgdGhlIGxlbmd0aCBvZiB0aGUgdHggaGlzdG9yeSBpcyBsb25nZXIgdGhlbiBkZXNpcmVkIHBlcnNpc3RlbmNlXG4gICAgICogbGltaXQgYW5kIHRoZW4gaWYgaXQgaXMgcmVtb3ZlcyB0aGUgb2xkZXN0IGNvbmZpcm1lZCBvciByZWplY3RlZCB0eC5cbiAgICAgKiBQZW5kaW5nIG9yIHVuYXBwcm92ZWQgdHJhbnNhY3Rpb25zIHdpbGwgbm90IGJlIHJlbW92ZWQgYnkgdGhpc1xuICAgICAqIG9wZXJhdGlvbi4gRm9yIHNhZmV0eSBvZiBwcmVzZW50aW5nIGEgZnVsbHkgZnVuY3Rpb25hbCB0cmFuc2FjdGlvbiBVSVxuICAgICAqIHJlcHJlc2VudGF0aW9uLCB0aGlzIGZ1bmN0aW9uIHdpbGwgbm90IGJyZWFrIGFwYXJ0IHRyYW5zYWN0aW9ucyB3aXRoIHRoZVxuICAgICAqIHNhbWUgbm9uY2UsIGNyZWF0ZWQgb24gdGhlIHNhbWUgZGF5LCBwZXIgbmV0d29yay4gTm90IGFjY291bnRpbmcgZm9yIHRyYW5zYWN0aW9ucyBvZiB0aGUgc2FtZVxuICAgICAqIG5vbmNlLCBzYW1lIGRheSBhbmQgbmV0d29yayBjb21ibyBjYW4gcmVzdWx0IGluIGNvbmZ1c2luZyBvciBicm9rZW4gZXhwZXJpZW5jZXNcbiAgICAgKiBpbiB0aGUgVUkuIFRoZSB0cmFuc2FjdGlvbnMgYXJlIHRoZW4gdXBkYXRlZCB1c2luZyB0aGUgQmFzZUNvbnRyb2xsZXIgdXBkYXRlLlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbnMgLSBhcnJheSBvZiB0cmFuc2FjdGlvbnMgdG8gYmUgYXBwbGllZCB0byB0aGUgc3RhdGVcbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBUcmFuc2FjdGlvbk1ldGEgd2l0aCB0aGUgZGVzaXJlZCBsZW5ndGguXG4gICAgICovXG4gICAgdHJpbVRyYW5zYWN0aW9uc0ZvclN0YXRlKHRyYW5zYWN0aW9ucykge1xuICAgICAgICBjb25zdCBub25jZU5ldHdvcmtTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IHR4c1RvS2VlcCA9IHRyYW5zYWN0aW9ucy5yZXZlcnNlKCkuZmlsdGVyKCh0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBjaGFpbklkLCBuZXR3b3JrSUQsIHN0YXR1cywgdHJhbnNhY3Rpb24sIHRpbWUgfSA9IHR4O1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7dHJhbnNhY3Rpb24ubm9uY2V9LSR7Y2hhaW5JZCAhPT0gbnVsbCAmJiBjaGFpbklkICE9PSB2b2lkIDAgPyBjaGFpbklkIDogbmV0d29ya0lEfS0ke25ldyBEYXRlKHRpbWUpLnRvRGF0ZVN0cmluZygpfWA7XG4gICAgICAgICAgICAgICAgaWYgKG5vbmNlTmV0d29ya1NldC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9uY2VOZXR3b3JrU2V0LnNpemUgPCB0aGlzLmNvbmZpZy50eEhpc3RvcnlMaW1pdCB8fFxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5pc0ZpbmFsU3RhdGUoc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICBub25jZU5ldHdvcmtTZXQuYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHR4c1RvS2VlcC5yZXZlcnNlKCk7XG4gICAgICAgIHJldHVybiB0eHNUb0tlZXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBkZXRlcm1pbmUgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGluIGEgZmluYWwgc3RhdGVcbiAgICAgKiBAcGFyYW0gc3RhdHVzIC0gVHJhbnNhY3Rpb24gc3RhdHVzXG4gICAgICogQHJldHVybnMgYm9vbGVhbiBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgaW4gYSBmaW5hbCBzdGF0ZVxuICAgICAqL1xuICAgIGlzRmluYWxTdGF0ZShzdGF0dXMpIHtcbiAgICAgICAgcmV0dXJuIChzdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLnJlamVjdGVkIHx8XG4gICAgICAgICAgICBzdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLmNvbmZpcm1lZCB8fFxuICAgICAgICAgICAgc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5mYWlsZWQgfHxcbiAgICAgICAgICAgIHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuY2FuY2VsbGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIHZlcmlmeSB0aGUgc3RhdGUgb2YgYSB0cmFuc2FjdGlvbiB1c2luZyB0aGUgQmxvY2tjaGFpbiBhcyBhIHNvdXJjZSBvZiB0cnV0aFxuICAgICAqIEBwYXJhbSBtZXRhIExvY2FsIHRyYW5zYWN0aW9uIHRvIHZlcmlmeSBkYXRhIGluIGJsb2NrY2hhaW5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggW1RyYW5zYWN0aW9uTWV0YSwgYm9vbGVhbl1cbiAgICAgKi9cbiAgICBibG9ja2NoYWluVHJhbnNhY3Rpb25TdGF0ZVJlY29uY2lsZXIobWV0YSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBzdGF0dXMsIHRyYW5zYWN0aW9uSGFzaCB9ID0gbWV0YTtcbiAgICAgICAgICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBUcmFuc2FjdGlvblN0YXR1cy5jb25maXJtZWQ6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4UmVjZWlwdCA9IHlpZWxkIHV0aWxfMS5xdWVyeSh0aGlzLmV0aFF1ZXJ5LCAnZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eFJlY2VpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWV0YSwgZmFsc2VdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1ldGEudmVyaWZpZWRPbkJsb2NrY2hhaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtZXRhLnRyYW5zYWN0aW9uLmdhc1VzZWQgPSB0eFJlY2VpcHQuZ2FzVXNlZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBXZWIzIGRvY3M6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRSVUUgaWYgdGhlIHRyYW5zYWN0aW9uIHdhcyBzdWNjZXNzZnVsLCBGQUxTRSBpZiB0aGUgRVZNIHJldmVydGVkIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKE51bWJlcih0eFJlY2VpcHQuc3RhdHVzKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIGZhaWxlZC4gVGhlIHRyYW5zYWN0aW9uIHdhcyByZXZlcnNlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsVHJhbnNhY3Rpb24obWV0YSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttZXRhLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttZXRhLCB0cnVlXTtcbiAgICAgICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdHVzLnN1Ym1pdHRlZDpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHhPYmogPSB5aWVsZCB1dGlsXzEucXVlcnkodGhpcy5ldGhRdWVyeSwgJ2dldFRyYW5zYWN0aW9uQnlIYXNoJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eE9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdFNob3dzRmFpbGVkU3RhdHVzID0geWllbGQgdGhpcy5jaGVja1R4UmVjZWlwdFN0YXR1c0lzRmFpbGVkKHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYXNlIHRoZSB0eE9iaiBpcyBldmFsdWF0ZWQgYXMgZmFsc2UsIGEgc2Vjb25kIGNoZWNrIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSBpZiB0aGUgdHggZmFpbGVkIG9yIGl0IGlzIHBlbmRpbmcgb3IgY29uZmlybWVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdFNob3dzRmFpbGVkU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIGZhaWxlZC4gVGhlIHRyYW5zYWN0aW9uIHdhcyBkcm9wcGVkIG9yIHJlcGxhY2VkIGJ5IGEgbmV3IG9uZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmFpbFRyYW5zYWN0aW9uKG1ldGEsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAodHhPYmogPT09IG51bGwgfHwgdHhPYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR4T2JqLmJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhLnN0YXR1cyA9IFRyYW5zYWN0aW9uU3RhdHVzLmNvbmZpcm1lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaHViLmVtaXQoYCR7bWV0YS5pZH06Y29uZmlybWVkYCwgbWV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW21ldGEsIHRydWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWV0YSwgZmFsc2VdO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWV0YSwgZmFsc2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGNoZWNrIGlmIGEgdHggaGFzIGZhaWxlZCBhY2NvcmRpbmcgdG8gdGhlaXIgcmVjZWlwdFxuICAgICAqIEFjY29yZGluZyB0byB0aGUgV2ViMyBkb2NzOlxuICAgICAqIFRSVUUgaWYgdGhlIHRyYW5zYWN0aW9uIHdhcyBzdWNjZXNzZnVsLCBGQUxTRSBpZiB0aGUgRVZNIHJldmVydGVkIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBUaGUgcmVjZWlwdCBpcyBub3QgYXZhaWxhYmxlIGZvciBwZW5kaW5nIHRyYW5zYWN0aW9ucyBhbmQgcmV0dXJucyBudWxsLlxuICAgICAqIEBwYXJhbSB0eEhhc2ggVHJhbnNhY3Rpb24gaGFzaFxuICAgICAqIEByZXR1cm5zIFByb21pc2U8Ym9vbGVhbj4gaW5kaWNhdGluZyBpZiB0aGUgdHJhbnNhY3Rpb24gaGF2ZSBmYWlsZWRcbiAgICAgKi9cbiAgICBjaGVja1R4UmVjZWlwdFN0YXR1c0lzRmFpbGVkKHR4SGFzaCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdHhSZWNlaXB0ID0geWllbGQgdXRpbF8xLnF1ZXJ5KHRoaXMuZXRoUXVlcnksICdnZXRUcmFuc2FjdGlvblJlY2VpcHQnLCBbXG4gICAgICAgICAgICAgICAgdHhIYXNoLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBpZiAoIXR4UmVjZWlwdCkge1xuICAgICAgICAgICAgICAgIC8vIFRyYW5zYWN0aW9uIGlzIHBlbmRpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHR4UmVjZWlwdC5zdGF0dXMpID09PSAwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIHZlcmlmeSB0aGUgc3RhdGUgb2YgdHJhbnNhY3Rpb25zIHVzaW5nIEV0aGVyc2NhbiBhcyBhIHNvdXJjZSBvZiB0cnV0aFxuICAgICAqIEBwYXJhbSByZW1vdGVUeHMgQXJyYXkgb2YgdHJhbnNhY3Rpb25zIGZyb20gcmVtb3RlIHNvdXJjZVxuICAgICAqIEBwYXJhbSBsb2NhbFR4cyBBcnJheSBvZiB0cmFuc2FjdGlvbnMgc3RvcmVkIGxvY2FsbHlcbiAgICAgKiBAcmV0dXJucyBbYm9vbGVhbiwgVHJhbnNhY3Rpb25NZXRhW11dXG4gICAgICovXG4gICAgZXRoZXJzY2FuVHJhbnNhY3Rpb25TdGF0ZVJlY29uY2lsZXIocmVtb3RlVHhzLCBsb2NhbFR4cykge1xuICAgICAgICBjb25zdCB1cGRhdGVkVHhzID0gdGhpcy5nZXRVcGRhdGVkVHJhbnNhY3Rpb25zKHJlbW90ZVR4cywgbG9jYWxUeHMpO1xuICAgICAgICBjb25zdCBuZXdUeHMgPSB0aGlzLmdldE5ld1RyYW5zYWN0aW9ucyhyZW1vdGVUeHMsIGxvY2FsVHhzKTtcbiAgICAgICAgY29uc3QgdXBkYXRlZExvY2FsVHhzID0gbG9jYWxUeHMubWFwKCh0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHhJZHggPSB1cGRhdGVkVHhzLmZpbmRJbmRleCgoeyB0cmFuc2FjdGlvbkhhc2ggfSkgPT4gdHJhbnNhY3Rpb25IYXNoID09PSB0eC50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICAgICAgcmV0dXJuIHR4SWR4ID09PSAtMSA/IHR4IDogdXBkYXRlZFR4c1t0eElkeF07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB1cGRhdGVSZXF1aXJlZCA9IG5ld1R4cy5sZW5ndGggPiAwIHx8IHVwZGF0ZWRMb2NhbFR4cy5sZW5ndGggPiAwO1xuICAgICAgICByZXR1cm4gW3VwZGF0ZVJlcXVpcmVkLCBbLi4ubmV3VHhzLCAuLi51cGRhdGVkTG9jYWxUeHNdXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgaW4gdGhlIHJlbW90ZSB0cmFuc2FjdGlvbnMgYXJyYXlcbiAgICAgKiBidXQgbm90IGluIHRoZSBsb2NhbCB0cmFuc2FjdGlvbnMgYXJyYXlcbiAgICAgKiBAcGFyYW0gcmVtb3RlVHhzIC0gQXJyYXkgb2YgdHJhbnNhY3Rpb25zIGZyb20gcmVtb3RlIHNvdXJjZVxuICAgICAqIEBwYXJhbSBsb2NhbFR4cyAtIEFycmF5IG9mIHRyYW5zYWN0aW9ucyBzdG9yZWQgbG9jYWxseVxuICAgICAqIEByZXR1cm5zIFRyYW5zYWN0aW9uTWV0YSBhcnJheVxuICAgICAqL1xuICAgIGdldE5ld1RyYW5zYWN0aW9ucyhyZW1vdGVUeHMsIGxvY2FsVHhzKSB7XG4gICAgICAgIHJldHVybiByZW1vdGVUeHMuZmlsdGVyKCh0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWxyZWFkeUluVHJhbnNhY3Rpb25zID0gbG9jYWxUeHMuZmluZCgoeyB0cmFuc2FjdGlvbkhhc2ggfSkgPT4gdHJhbnNhY3Rpb25IYXNoID09PSB0eC50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICAgICAgcmV0dXJuICFhbHJlYWR5SW5UcmFuc2FjdGlvbnM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHRoZSB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgbG9jYWxseSBvdXRkYXRlZCB3aXRoIHJlc3BlY3RcbiAgICAgKiB0byBhIHJlbW90ZSBzb3VyY2UgKGV0aGVyc2NhbiBvciBibG9ja2NoYWluKS4gVGhlIHJldHVybmVkIGFycmF5XG4gICAgICogY29udGFpbnMgdGhlIHRyYW5zYWN0aW9ucyB3aXRoIHRoZSB1cGRhdGVkIGRhdGEuXG4gICAgICogQHBhcmFtIHJlbW90ZVR4cyAtIEFycmF5IG9mIHRyYW5zYWN0aW9ucyBmcm9tIHJlbW90ZSBzb3VyY2VcbiAgICAgKiBAcGFyYW0gbG9jYWxUeHMgLSBBcnJheSBvZiB0cmFuc2FjdGlvbnMgc3RvcmVkIGxvY2FsbHlcbiAgICAgKiBAcmV0dXJucyBUcmFuc2FjdGlvbk1ldGEgYXJyYXlcbiAgICAgKi9cbiAgICBnZXRVcGRhdGVkVHJhbnNhY3Rpb25zKHJlbW90ZVR4cywgbG9jYWxUeHMpIHtcbiAgICAgICAgcmV0dXJuIHJlbW90ZVR4cy5maWx0ZXIoKHJlbW90ZVR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc1R4T3V0ZGF0ZWQgPSBsb2NhbFR4cy5maW5kKChsb2NhbFR4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChyZW1vdGVUeC50cmFuc2FjdGlvbkhhc2ggPT09IGxvY2FsVHgudHJhbnNhY3Rpb25IYXNoICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNUcmFuc2FjdGlvbk91dGRhdGVkKHJlbW90ZVR4LCBsb2NhbFR4KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBpc1R4T3V0ZGF0ZWQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBpZiBhIGxvY2FsIHRyYW5zYWN0aW9uIGlzIG91dGRhdGVkIHdpdGggcmVzcGVjdCB0byB0aGUgcmVtb3RlIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIHJlbW90ZVR4IC0gUmVtb3RlIHRyYW5zYWN0aW9uIGZyb20gRXRoZXJzY2FuXG4gICAgICogQHBhcmFtIGxvY2FsVHggLSBMb2NhbCB0cmFuc2FjdGlvblxuICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc1RyYW5zYWN0aW9uT3V0ZGF0ZWQocmVtb3RlVHgsIGxvY2FsVHgpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzT3V0ZGF0ZWQgPSB0aGlzLmlzU3RhdHVzT3V0ZGF0ZWQocmVtb3RlVHgudHJhbnNhY3Rpb25IYXNoLCBsb2NhbFR4LnRyYW5zYWN0aW9uSGFzaCwgcmVtb3RlVHguc3RhdHVzLCBsb2NhbFR4LnN0YXR1cyk7XG4gICAgICAgIGNvbnN0IGdhc0RhdGFPdXRkYXRlZCA9IHRoaXMuaXNHYXNEYXRhT3V0ZGF0ZWQocmVtb3RlVHgudHJhbnNhY3Rpb24uZ2FzVXNlZCwgbG9jYWxUeC50cmFuc2FjdGlvbi5nYXNVc2VkKTtcbiAgICAgICAgcmV0dXJuIHN0YXR1c091dGRhdGVkIHx8IGdhc0RhdGFPdXRkYXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgaWYgdGhlIHN0YXR1cyBvZiBhIGxvY2FsIHRyYW5zYWN0aW9uIGlzIG91dGRhdGVkIHdpdGggcmVzcGVjdCB0byB0aGUgcmVtb3RlIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIHJlbW90ZVR4SGFzaCAtIFJlbW90ZSB0cmFuc2FjdGlvbiBoYXNoXG4gICAgICogQHBhcmFtIGxvY2FsVHhIYXNoIC0gTG9jYWwgdHJhbnNhY3Rpb24gaGFzaFxuICAgICAqIEBwYXJhbSByZW1vdGVUeFN0YXR1cyAtIFJlbW90ZSB0cmFuc2FjdGlvbiBzdGF0dXNcbiAgICAgKiBAcGFyYW0gbG9jYWxUeFN0YXR1cyAtIExvY2FsIHRyYW5zYWN0aW9uIHN0YXR1c1xuICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc1N0YXR1c091dGRhdGVkKHJlbW90ZVR4SGFzaCwgbG9jYWxUeEhhc2gsIHJlbW90ZVR4U3RhdHVzLCBsb2NhbFR4U3RhdHVzKSB7XG4gICAgICAgIHJldHVybiByZW1vdGVUeEhhc2ggPT09IGxvY2FsVHhIYXNoICYmIHJlbW90ZVR4U3RhdHVzICE9PSBsb2NhbFR4U3RhdHVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBpZiB0aGUgZ2FzIGRhdGEgb2YgYSBsb2NhbCB0cmFuc2FjdGlvbiBpcyBvdXRkYXRlZCB3aXRoIHJlc3BlY3QgdG8gdGhlIHJlbW90ZSB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSByZW1vdGVHYXNVc2VkIC0gUmVtb3RlIGdhcyB1c2VkIGluIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSBsb2NhbEdhc1VzZWQgLSBMb2NhbCBnYXMgdXNlZCBpbiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICovXG4gICAgaXNHYXNEYXRhT3V0ZGF0ZWQocmVtb3RlR2FzVXNlZCwgbG9jYWxHYXNVc2VkKSB7XG4gICAgICAgIHJldHVybiByZW1vdGVHYXNVc2VkICE9PSBsb2NhbEdhc1VzZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFuc2FjdGlvbkNvbnRyb2xsZXIgPSBUcmFuc2FjdGlvbkNvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBUcmFuc2FjdGlvbkNvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmFuc2FjdGlvbkNvbnRyb2xsZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkbyBub3QgZWRpdCAuanMgZmlsZXMgZGlyZWN0bHkgLSBlZGl0IHNyYy9pbmRleC5qc3RcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGVuZ3RoLCBpLCBrZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cblxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICBpZiAoYS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gICAgaWYgKGEudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdHJ1ZSBpZiBib3RoIE5hTiwgZmFsc2Ugb3RoZXJ3aXNlXG4gIHJldHVybiBhIT09YSAmJiBiIT09Yjtcbn07XG4iLCJsZXQgdXJsQWxwaGFiZXQgPVxuICAndXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdCdcbm1vZHVsZS5leHBvcnRzID0geyB1cmxBbHBoYWJldCB9XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3RvcmVBc1N0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNsYXNzIE9ic2VydmFibGVTdG9yZVN0cmVhbSBleHRlbmRzIHN0cmVhbV8xLkR1cGxleCB7XG4gICAgY29uc3RydWN0b3Iob2JzU3RvcmUpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgLy8gcGFzcyB2YWx1ZXMsIG5vdCBzZXJpYWxpemF0aW9uc1xuICAgICAgICAgICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGRvbnQgYnVmZmVyIG91dGdvaW5nIHVwZGF0ZXNcbiAgICAgICAgdGhpcy5yZXN1bWUoKTtcbiAgICAgICAgLy8gc2F2ZSBoYW5kbGVyIHNvIHdlIGNhbiB1bnN1YnNjcmliZSBsYXRlclxuICAgICAgICB0aGlzLmhhbmRsZXIgPSAoc3RhdGUpID0+IHRoaXMucHVzaChzdGF0ZSk7XG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBvYnNTdG9yZSBjaGFuZ2VzXG4gICAgICAgIHRoaXMub2JzU3RvcmUgPSBvYnNTdG9yZTtcbiAgICAgICAgdGhpcy5vYnNTdG9yZS5zdWJzY3JpYmUodGhpcy5oYW5kbGVyKTtcbiAgICB9XG4gICAgLy8gZW1pdCBjdXJyZW50IHN0YXRlIG9uIG5ldyBkZXN0aW5hdGlvblxuICAgIHBpcGUoZGVzdCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5waXBlKGRlc3QsIG9wdGlvbnMpO1xuICAgICAgICBkZXN0LndyaXRlKHRoaXMub2JzU3RvcmUuZ2V0U3RhdGUoKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIHdyaXRlIGZyb20gaW5jb21pbmcgc3RyZWFtIHRvIHN0YXRlXG4gICAgX3dyaXRlKGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub2JzU3RvcmUucHV0U3RhdGUoY2h1bmspO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICAvLyBub29wIC0gb3V0Z29pbmcgc3RyZWFtIGlzIGFza2luZyB1cyBpZiB3ZSBoYXZlIGRhdGEgd2UgYXJlbnQgZ2l2aW5nIGl0XG4gICAgX3JlYWQoX3NpemUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBldmVudCBlbWl0dGVyXG4gICAgX2Rlc3Ryb3koZXJyLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9ic1N0b3JlLnVuc3Vic2NyaWJlKHRoaXMuaGFuZGxlcik7XG4gICAgICAgIHN1cGVyLl9kZXN0cm95KGVyciwgY2FsbGJhY2spO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0b3JlQXNTdHJlYW0ob2JzU3RvcmUpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVTdG9yZVN0cmVhbShvYnNTdG9yZSk7XG59XG5leHBvcnRzLnN0b3JlQXNTdHJlYW0gPSBzdG9yZUFzU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNTdHJlYW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbXBvc2VkU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBPYnNlcnZhYmxlU3RvcmVfMSA9IHJlcXVpcmUoXCIuL09ic2VydmFibGVTdG9yZVwiKTtcbmNsYXNzIENvbXBvc2VkU3RvcmUgZXh0ZW5kcyBPYnNlcnZhYmxlU3RvcmVfMS5PYnNlcnZhYmxlU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuKSB7XG4gICAgICAgIC8vIFR5cGVjYXN0OiBQcmVzZXJ2ZSBleGlzdGluZyBiZWhhdmlvclxuICAgICAgICBzdXBlcih7fSk7XG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBjaGlsZHJlblxuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IGNoaWxkcmVuIHx8IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9jaGlsZHJlbikuZm9yRWFjaCgoY2hpbGRLZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5fY2hpbGRyZW5bY2hpbGRLZXldO1xuICAgICAgICAgICAgdGhpcy5fYWRkQ2hpbGQoY2hpbGRLZXksIGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGlsZChjaGlsZEtleSwgY2hpbGQpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlRnJvbUNoaWxkID0gKGNoaWxkVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgc3RhdGVbY2hpbGRLZXldID0gY2hpbGRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMucHV0U3RhdGUoc3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBjaGlsZC5zdWJzY3JpYmUodXBkYXRlRnJvbUNoaWxkKTtcbiAgICAgICAgdXBkYXRlRnJvbUNoaWxkKGNoaWxkLmdldFN0YXRlKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tcG9zZWRTdG9yZSA9IENvbXBvc2VkU3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21wb3NlZFN0b3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZXJnZWRTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IE9ic2VydmFibGVTdG9yZV8xID0gcmVxdWlyZShcIi4vT2JzZXJ2YWJsZVN0b3JlXCIpO1xuY2xhc3MgTWVyZ2VkU3RvcmUgZXh0ZW5kcyBPYnNlcnZhYmxlU3RvcmVfMS5PYnNlcnZhYmxlU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuID0gW10pIHtcbiAgICAgICAgLy8gVHlwZWNhc3Q6IFByZXNlcnZlIGV4aXN0aW5nIGJlaGF2aW9yXG4gICAgICAgIHN1cGVyKHt9KTtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIGNoaWxkcmVuXG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB0aGlzLl9hZGRDaGlsZChjaGlsZCkpO1xuICAgICAgICB0aGlzLl91cGRhdGVXaG9sZVN0YXRlKCk7XG4gICAgfVxuICAgIF9hZGRDaGlsZChjaGlsZCkge1xuICAgICAgICBjaGlsZC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fdXBkYXRlV2hvbGVTdGF0ZSgpKTtcbiAgICB9XG4gICAgX3VwZGF0ZVdob2xlU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkU3RhdGVzID0gdGhpcy5fY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gY2hpbGQuZ2V0U3RhdGUoKSk7XG4gICAgICAgIC8vIGFwcGx5IHNoYWxsb3cgbWVyZ2Ugb3ZlciBzdGF0ZXNcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5jaGlsZFN0YXRlcyk7XG4gICAgICAgIHRoaXMucHV0U3RhdGUoc3RhdGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVyZ2VkU3RvcmUgPSBNZXJnZWRTdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lcmdlZFN0b3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PYnNlcnZhYmxlU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBzYWZlX2V2ZW50X2VtaXR0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQG1ldGFtYXNrL3NhZmUtZXZlbnQtZW1pdHRlclwiKSk7XG5jbGFzcyBPYnNlcnZhYmxlU3RvcmUgZXh0ZW5kcyBzYWZlX2V2ZW50X2VtaXR0ZXJfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0U3RhdGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKGluaXRTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBpbml0U3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUeXBlY2FzdC9kZWZhdWx0IHN0YXRlOiBQcmVzZXJ2ZSBleGlzdGluZyBiZWhhdmlvclxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB3cmFwcGVyIGFyb3VuZCBpbnRlcm5hbCBnZXRTdGF0ZVxuICAgIGdldFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U3RhdGUoKTtcbiAgICB9XG4gICAgLy8gd3JhcHBlciBhcm91bmQgaW50ZXJuYWwgcHV0U3RhdGVcbiAgICBwdXRTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICB0aGlzLl9wdXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgbmV3U3RhdGUpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShwYXJ0aWFsU3RhdGUpIHtcbiAgICAgICAgLy8gaWYgbm9uLW51bGwgb2JqZWN0LCBtZXJnZVxuICAgICAgICBpZiAocGFydGlhbFN0YXRlICYmIHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHRoaXMucHV0U3RhdGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHBhcnRpYWxTdGF0ZSkpO1xuICAgICAgICAgICAgLy8gaWYgbm90IG9iamVjdCwgdXNlIG5ldyB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wdXRTdGF0ZShwYXJ0aWFsU3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHN1YnNjcmliZSB0byBjaGFuZ2VzXG4gICAgc3Vic2NyaWJlKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5vbigndXBkYXRlJywgaGFuZGxlcik7XG4gICAgfVxuICAgIC8vIHVuc3Vic2NyaWJlIHRvIGNoYW5nZXNcbiAgICB1bnN1YnNjcmliZShoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3VwZGF0ZScsIGhhbmRsZXIpO1xuICAgIH1cbiAgICAvL1xuICAgIC8vIHByaXZhdGVcbiAgICAvL1xuICAgIC8vIHJlYWQgZnJvbSBwZXJzaXN0ZW5jZVxuICAgIF9nZXRTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgICAvLyB3cml0ZSB0byBwZXJzaXN0ZW5jZVxuICAgIF9wdXRTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH1cbn1cbmV4cG9ydHMuT2JzZXJ2YWJsZVN0b3JlID0gT2JzZXJ2YWJsZVN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2YWJsZVN0b3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdG9yZVRyYW5zZm9ybVN0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IHRocm91Z2gyXzEgPSByZXF1aXJlKFwidGhyb3VnaDJcIik7XG5mdW5jdGlvbiBzdG9yZVRyYW5zZm9ybVN0cmVhbShzeW5jVHJhbnNmb3JtRm4pIHtcbiAgICByZXR1cm4gdGhyb3VnaDJfMS5vYmooKHN0YXRlLCBfZW5jb2RpbmcsIGNiKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHN5bmNUcmFuc2Zvcm1GbihzdGF0ZSk7XG4gICAgICAgICAgICBjYihudWxsLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnN0b3JlVHJhbnNmb3JtU3RyZWFtID0gc3RvcmVUcmFuc2Zvcm1TdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2Zvcm0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNUUkVBTV9OQU1FUyA9IHZvaWQgMDtcbi8vIEkgaGF2ZSBubyBpZGVhIHdoeSB0aGlzIHJ1bGUgZmlyZXMgYnV0IHlvdSBkbyB5b3UgZXNsaW50XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG52YXIgU1RSRUFNX05BTUVTO1xuKGZ1bmN0aW9uIChTVFJFQU1fTkFNRVMpIHtcbiAgICBTVFJFQU1fTkFNRVNbXCJKU09OX1JQQ1wiXSA9IFwianNvblJwY1wiO1xuICAgIFNUUkVBTV9OQU1FU1tcIkNPTU1BTkRcIl0gPSBcImNvbW1hbmRcIjtcbn0pKFNUUkVBTV9OQU1FUyA9IGV4cG9ydHMuU1RSRUFNX05BTUVTIHx8IChleHBvcnRzLlNUUkVBTV9OQU1FUyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlYWRhYmxlX3N0cmVhbV8xID0gcmVxdWlyZShcInJlYWRhYmxlLXN0cmVhbVwiKTtcbi8qKlxuICogVGFrZXMgYSBKc29uUnBjRW5naW5lIGFuZCByZXR1cm5zIGEgRHVwbGV4IHN0cmVhbSB3cmFwcGluZyBpdC5cbiAqXG4gKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgYmFnLlxuICogQHBhcmFtIG9wdHMuZW5naW5lIC0gVGhlIEpzb25ScGNFbmdpbmUgdG8gd3JhcCBpbiBhIHN0cmVhbS5cbiAqIEByZXR1cm5zIFRoZSBzdHJlYW0gd3JhcHBpbmcgdGhlIGVuZ2luZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW5naW5lU3RyZWFtKG9wdHMpIHtcbiAgICBpZiAoIW9wdHMgfHwgIW9wdHMuZW5naW5lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBlbmdpbmUgcGFyYW1ldGVyIScpO1xuICAgIH1cbiAgICBjb25zdCB7IGVuZ2luZSB9ID0gb3B0cztcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgcmVhZGFibGVfc3RyZWFtXzEuRHVwbGV4KHsgb2JqZWN0TW9kZTogdHJ1ZSwgcmVhZCwgd3JpdGUgfSk7XG4gICAgLy8gZm9yd2FyZCBub3RpZmljYXRpb25zXG4gICAgaWYgKGVuZ2luZS5vbikge1xuICAgICAgICBlbmdpbmUub24oJ25vdGlmaWNhdGlvbicsIChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBzdHJlYW0ucHVzaChtZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJlYW07XG4gICAgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGUocmVxLCBfZW5jb2RpbmcsIGNiKSB7XG4gICAgICAgIGVuZ2luZS5oYW5kbGUocmVxLCAoX2VyciwgcmVzKSA9PiB7XG4gICAgICAgICAgICBzdHJlYW0ucHVzaChyZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2IoKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVFbmdpbmVTdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVFbmdpbmVTdHJlYW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBzYWZlX2V2ZW50X2VtaXR0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQG1ldGFtYXNrL3NhZmUtZXZlbnQtZW1pdHRlclwiKSk7XG5jb25zdCByZWFkYWJsZV9zdHJlYW1fMSA9IHJlcXVpcmUoXCJyZWFkYWJsZS1zdHJlYW1cIik7XG4vKipcbiAqIENyZWF0ZXMgYSBKc29uUnBjRW5naW5lIG1pZGRsZXdhcmUgd2l0aCBhbiBhc3NvY2lhdGVkIER1cGxleCBzdHJlYW0gYW5kXG4gKiBFdmVudEVtaXR0ZXIuIFRoZSBtaWRkbGV3YXJlLCBhbmQgYnkgZXh0ZW5zaW9uIHN0cmVhbSwgYXNzdW1lIHRoYXQgbWlkZGxld2FyZVxuICogcGFyYW1ldGVycyBhcmUgcHJvcGVybHkgZm9ybWF0dGVkLiBObyBydW50aW1lIHR5cGUgY2hlY2tpbmcgb3IgdmFsaWRhdGlvbiBpc1xuICogcGVyZm9ybWVkLlxuICpcbiAqIEByZXR1cm5zIFRoZSBldmVudCBlbWl0dGVyLCBtaWRkbGV3YXJlLCBhbmQgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlKCkge1xuICAgIGNvbnN0IGlkTWFwID0ge307XG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IHJlYWRhYmxlX3N0cmVhbV8xLkR1cGxleCh7XG4gICAgICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgICAgIHJlYWQ6IHJlYWROb29wLFxuICAgICAgICB3cml0ZTogcHJvY2Vzc01lc3NhZ2UsXG4gICAgfSk7XG4gICAgY29uc3QgZXZlbnRzID0gbmV3IHNhZmVfZXZlbnRfZW1pdHRlcl8xLmRlZmF1bHQoKTtcbiAgICBjb25zdCBtaWRkbGV3YXJlID0gKHJlcSwgcmVzLCBuZXh0LCBlbmQpID0+IHtcbiAgICAgICAgLy8gd3JpdGUgcmVxIHRvIHN0cmVhbVxuICAgICAgICBzdHJlYW0ucHVzaChyZXEpO1xuICAgICAgICAvLyByZWdpc3RlciByZXF1ZXN0IG9uIGlkIG1hcFxuICAgICAgICBpZE1hcFtyZXEuaWRdID0geyByZXEsIHJlcywgbmV4dCwgZW5kIH07XG4gICAgfTtcbiAgICByZXR1cm4geyBldmVudHMsIG1pZGRsZXdhcmUsIHN0cmVhbSB9O1xuICAgIGZ1bmN0aW9uIHJlYWROb29wKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlKHJlcywgX2VuY29kaW5nLCBjYikge1xuICAgICAgICBsZXQgZXJyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaXNOb3RpZmljYXRpb24gPSAhcmVzLmlkO1xuICAgICAgICAgICAgaWYgKGlzTm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc05vdGlmaWNhdGlvbihyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc1Jlc3BvbnNlKHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAgIGVyciA9IF9lcnI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29udGludWUgcHJvY2Vzc2luZyBzdHJlYW1cbiAgICAgICAgY2IoZXJyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvY2Vzc1Jlc3BvbnNlKHJlcykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gaWRNYXBbcmVzLmlkXTtcbiAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0cmVhbU1pZGRsZXdhcmUgLSBVbmtub3duIHJlc3BvbnNlIGlkIFwiJHtyZXMuaWR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgaWRNYXBbcmVzLmlkXTtcbiAgICAgICAgLy8gY29weSB3aG9sZSByZXMgb250byBvcmlnaW5hbCByZXNcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb250ZXh0LnJlcywgcmVzKTtcbiAgICAgICAgLy8gcnVuIGNhbGxiYWNrIG9uIGVtcHR5IHN0YWNrLFxuICAgICAgICAvLyBwcmV2ZW50IGludGVybmFsIHN0cmVhbS1oYW5kbGVyIGZyb20gY2F0Y2hpbmcgZXJyb3JzXG4gICAgICAgIHNldFRpbWVvdXQoY29udGV4dC5lbmQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzTm90aWZpY2F0aW9uKHJlcykge1xuICAgICAgICBldmVudHMuZW1pdCgnbm90aWZpY2F0aW9uJywgcmVzKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlU3RyZWFtTWlkZGxld2FyZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT2JqZWN0TXVsdGlwbGV4ID0gdm9pZCAwO1xuY29uc3QgcmVhZGFibGVfc3RyZWFtXzEgPSByZXF1aXJlKFwicmVhZGFibGUtc3RyZWFtXCIpO1xuY29uc3QgZW5kX29mX3N0cmVhbV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJlbmQtb2Ytc3RyZWFtXCIpKTtcbmNvbnN0IG9uY2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwib25jZVwiKSk7XG5jb25zdCBTdWJzdHJlYW1fMSA9IHJlcXVpcmUoXCIuL1N1YnN0cmVhbVwiKTtcbmNvbnN0IElHTk9SRV9TVUJTVFJFQU0gPSBTeW1ib2woJ0lHTk9SRV9TVUJTVFJFQU0nKTtcbmNsYXNzIE9iamVjdE11bHRpcGxleCBleHRlbmRzIHJlYWRhYmxlX3N0cmVhbV8xLkR1cGxleCB7XG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0cyksIHsgb2JqZWN0TW9kZTogdHJ1ZSB9KSk7XG4gICAgICAgIHRoaXMuX3N1YnN0cmVhbXMgPSB7fTtcbiAgICB9XG4gICAgY3JlYXRlU3RyZWFtKG5hbWUpIHtcbiAgICAgICAgLy8gdmFsaWRhdGUgbmFtZVxuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0TXVsdGlwbGV4IC0gbmFtZSBtdXN0IG5vdCBiZSBlbXB0eScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdWJzdHJlYW1zW25hbWVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdE11bHRpcGxleCAtIFN1YnN0cmVhbSBmb3IgbmFtZSBcIiR7bmFtZX1cIiBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBzdWJzdHJlYW1cbiAgICAgICAgY29uc3Qgc3Vic3RyZWFtID0gbmV3IFN1YnN0cmVhbV8xLlN1YnN0cmVhbSh7IHBhcmVudDogdGhpcywgbmFtZSB9KTtcbiAgICAgICAgdGhpcy5fc3Vic3RyZWFtc1tuYW1lXSA9IHN1YnN0cmVhbTtcbiAgICAgICAgLy8gbGlzdGVuIGZvciBwYXJlbnQgc3RyZWFtIHRvIGVuZFxuICAgICAgICBhbnlTdHJlYW1FbmQodGhpcywgKF9lcnJvcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnN0cmVhbS5kZXN0cm95KF9lcnJvciB8fCB1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN1YnN0cmVhbTtcbiAgICB9XG4gICAgLy8gaWdub3JlIHN0cmVhbXMgKGRvbnQgZGlzcGxheSBvcnBoYW5lZCBkYXRhIHdhcm5pbmcpXG4gICAgaWdub3JlU3RyZWFtKG5hbWUpIHtcbiAgICAgICAgLy8gdmFsaWRhdGUgbmFtZVxuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0TXVsdGlwbGV4IC0gbmFtZSBtdXN0IG5vdCBiZSBlbXB0eScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdWJzdHJlYW1zW25hbWVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdE11bHRpcGxleCAtIFN1YnN0cmVhbSBmb3IgbmFtZSBcIiR7bmFtZX1cIiBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldFxuICAgICAgICB0aGlzLl9zdWJzdHJlYW1zW25hbWVdID0gSUdOT1JFX1NVQlNUUkVBTTtcbiAgICB9XG4gICAgX3JlYWQoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIF93cml0ZShjaHVuaywgX2VuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCB7IG5hbWUsIGRhdGEgfSA9IGNodW5rO1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgT2JqZWN0TXVsdGlwbGV4IC0gbWFsZm9ybWVkIGNodW5rIHdpdGhvdXQgbmFtZSBcIiR7Y2h1bmt9XCJgKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBjb3JyZXNwb25kaW5nIHN1YnN0cmVhbVxuICAgICAgICBjb25zdCBzdWJzdHJlYW0gPSB0aGlzLl9zdWJzdHJlYW1zW25hbWVdO1xuICAgICAgICBpZiAoIXN1YnN0cmVhbSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBPYmplY3RNdWx0aXBsZXggLSBvcnBoYW5lZCBkYXRhIGZvciBzdHJlYW0gXCIke25hbWV9XCJgKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHB1c2ggZGF0YSBpbnRvIHN1YnN0cmVhbVxuICAgICAgICBpZiAoc3Vic3RyZWFtICE9PSBJR05PUkVfU1VCU1RSRUFNKSB7XG4gICAgICAgICAgICBzdWJzdHJlYW0ucHVzaChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG59XG5leHBvcnRzLk9iamVjdE11bHRpcGxleCA9IE9iamVjdE11bHRpcGxleDtcbi8vIHV0aWxcbmZ1bmN0aW9uIGFueVN0cmVhbUVuZChzdHJlYW0sIF9jYikge1xuICAgIGNvbnN0IGNiID0gb25jZV8xLmRlZmF1bHQoX2NiKTtcbiAgICBlbmRfb2Zfc3RyZWFtXzEuZGVmYXVsdChzdHJlYW0sIHsgcmVhZGFibGU6IGZhbHNlIH0sIGNiKTtcbiAgICBlbmRfb2Zfc3RyZWFtXzEuZGVmYXVsdChzdHJlYW0sIHsgd3JpdGFibGU6IGZhbHNlIH0sIGNiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdE11bHRpcGxleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV29ya2VyUGFyZW50UG9zdE1lc3NhZ2VTdHJlYW0gPSB2b2lkIDA7XG5jb25zdCBCYXNlUG9zdE1lc3NhZ2VTdHJlYW1fMSA9IHJlcXVpcmUoXCIuL0Jhc2VQb3N0TWVzc2FnZVN0cmVhbVwiKTtcbmNvbnN0IGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbi8qKlxuICogUGFyZW50LXNpZGUgZGVkaWNhdGVkIHdlYiB3b3JrZXIgYHBvc3RNZXNzYWdlYCBzdHJlYW0uXG4gKi9cbmNsYXNzIFdvcmtlclBhcmVudFBvc3RNZXNzYWdlU3RyZWFtIGV4dGVuZHMgQmFzZVBvc3RNZXNzYWdlU3RyZWFtXzEuQmFzZVBvc3RNZXNzYWdlU3RyZWFtIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RyZWFtIGZvciBjb21tdW5pY2F0aW5nIHdpdGggYSBkZWRpY2F0ZWQgd2ViIHdvcmtlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzLndvcmtlciAtIFRoZSBXZWIgV29ya2VyIHRvIGV4Y2hhbmdlIG1lc3NhZ2VzIHdpdGguIFRoZSB3b3JrZXJcbiAgICAgKiBtdXN0IGluc3RhbnRpYXRlIGEgV29ya2VyUG9zdE1lc3NhZ2VTdHJlYW0uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyB3b3JrZXIgfSkge1xuICAgICAgICBpZiAoIXdvcmtlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0LicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3RhcmdldCA9IGVudW1zXzEuREVESUNBVEVEX1dPUktFUl9OQU1FO1xuICAgICAgICB0aGlzLl93b3JrZXIgPSB3b3JrZXI7XG4gICAgICAgIHRoaXMuX3dvcmtlci5vbm1lc3NhZ2UgPSB0aGlzLl9vbk1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faGFuZHNoYWtlKCk7XG4gICAgfVxuICAgIF9wb3N0TWVzc2FnZShkYXRhKSB7XG4gICAgICAgIHRoaXMuX3dvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuX3RhcmdldCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfb25NZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuICAgICAgICAvLyB2YWxpZGF0ZSBtZXNzYWdlXG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ29iamVjdCcgfHwgIW1lc3NhZ2UuZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29uRGF0YShtZXNzYWdlLmRhdGEpO1xuICAgIH1cbiAgICBfZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fd29ya2VyLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5Xb3JrZXJQYXJlbnRQb3N0TWVzc2FnZVN0cmVhbSA9IFdvcmtlclBhcmVudFBvc3RNZXNzYWdlU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V29ya2VyUGFyZW50UG9zdE1lc3NhZ2VTdHJlYW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldvcmtlclBvc3RNZXNzYWdlU3RyZWFtID0gdm9pZCAwO1xuLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cbi8vIFdlIGlnbm9yZSBjb3ZlcmFnZSBmb3IgdGhlIGVudGlyZSBmaWxlIGR1ZSB0byBsaW1pdHMgb24gb3VyIGluc3RydW1lbnRhdGlvbixcbi8vIGJ1dCBpdCBpcyBpbiBmYWN0IGNvdmVyZWQgYnkgb3VyIHRlc3RzLlxuY29uc3QgQmFzZVBvc3RNZXNzYWdlU3RyZWFtXzEgPSByZXF1aXJlKFwiLi9CYXNlUG9zdE1lc3NhZ2VTdHJlYW1cIik7XG5jb25zdCBlbnVtc18xID0gcmVxdWlyZShcIi4vZW51bXNcIik7XG4vKipcbiAqIFdvcmtlci1zaWRlIGRlZGljYXRlZCB3ZWIgd29ya2VyIGBwb3N0TWVzc2FnZWAgc3RyZWFtLlxuICovXG5jbGFzcyBXb3JrZXJQb3N0TWVzc2FnZVN0cmVhbSBleHRlbmRzIEJhc2VQb3N0TWVzc2FnZVN0cmVhbV8xLkJhc2VQb3N0TWVzc2FnZVN0cmVhbSB7XG4gICAgLyoqXG4gICAgICogTm90ZTogRGVzaWduZWQgZm9yIHVzZSBpbiB3ZWIgd29ya2VycyBvbmx5LlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhIHN0cmVhbSBmb3IgY29tbXVuaWNhdGluZyB3aXRoIHRoZSB3aW5kb3cgdGhhdCBjcmVhdGVkIHRoaXMgd2ViXG4gICAgICogd29ya2VyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9uYW1lID0gZW51bXNfMS5ERURJQ0FURURfV09SS0VSX05BTUU7XG4gICAgICAgIHNlbGYub25tZXNzYWdlID0gdGhpcy5fb25NZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRzaGFrZSgpO1xuICAgIH1cbiAgICBfcG9zdE1lc3NhZ2UoZGF0YSkge1xuICAgICAgICAvLyBDYXN0IG9mIHNlbGYucG9zdE1lc3NhZ2UgZHVlIHRvIHVzYWdlIG9mIERPTSBsaWJcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IGRhdGEgfSk7XG4gICAgfVxuICAgIF9vbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIC8vIHZhbGlkYXRlIG1lc3NhZ2VcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgbWVzc2FnZS50YXJnZXQgIT09IHRoaXMuX25hbWUgfHxcbiAgICAgICAgICAgICFtZXNzYWdlLmRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vbkRhdGEobWVzc2FnZS5kYXRhKTtcbiAgICB9XG4gICAgLy8gd29ya2VyIHN0cmVhbSBsaWZlY3ljbGUgYXNzdW1lZCB0byBiZSBjb3Rlcm1pbm91cyB3aXRoIGdsb2JhbCBzY29wZVxuICAgIF9kZXN0cm95KCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuV29ya2VyUG9zdE1lc3NhZ2VTdHJlYW0gPSBXb3JrZXJQb3N0TWVzc2FnZVN0cmVhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdvcmtlclBvc3RNZXNzYWdlU3RyZWFtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XaW5kb3dQb3N0TWVzc2FnZVN0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IEJhc2VQb3N0TWVzc2FnZVN0cmVhbV8xID0gcmVxdWlyZShcIi4vQmFzZVBvc3RNZXNzYWdlU3RyZWFtXCIpO1xuLyoqXG4gKiBXaW5kb3cucG9zdE1lc3NhZ2Ugc3RyZWFtLlxuICovXG5jbGFzcyBXaW5kb3dQb3N0TWVzc2FnZVN0cmVhbSBleHRlbmRzIEJhc2VQb3N0TWVzc2FnZVN0cmVhbV8xLkJhc2VQb3N0TWVzc2FnZVN0cmVhbSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0cmVhbSBmb3IgY29tbXVuaWNhdGluZyB3aXRoIG90aGVyIHN0cmVhbXMgYWNyb3NzIHRoZSBzYW1lIG9yXG4gICAgICogZGlmZmVyZW50IHdpbmRvdyBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzdHJlYW0uIFVzZWQgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuXG4gICAgICogbXVsdGlwbGUgc3RyZWFtcyBzaGFyaW5nIHRoZSBzYW1lIHdpbmRvdyBvYmplY3QuXG4gICAgICogQHBhcmFtIGFyZ3MudGFyZ2V0IC0gVGhlIG5hbWUgb2YgdGhlIHN0cmVhbSB0byBleGNoYW5nZSBtZXNzYWdlcyB3aXRoLlxuICAgICAqIEBwYXJhbSBhcmdzLnRhcmdldFdpbmRvdyAtIFRoZSB3aW5kb3cgb2JqZWN0IG9mIHRoZSB0YXJnZXQgc3RyZWFtLiBEZWZhdWx0c1xuICAgICAqIHRvIGB3aW5kb3dgLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgbmFtZSwgdGFyZ2V0LCB0YXJnZXRXaW5kb3cgfSkge1xuICAgICAgICBpZiAoIW5hbWUgfHwgIXRhcmdldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0LicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuX3RhcmdldE9yaWdpbiA9IHRhcmdldFdpbmRvdyA/ICcqJyA6IGxvY2F0aW9uLm9yaWdpbjtcbiAgICAgICAgdGhpcy5fdGFyZ2V0V2luZG93ID0gdGFyZ2V0V2luZG93IHx8IHdpbmRvdztcbiAgICAgICAgdGhpcy5fb25NZXNzYWdlID0gdGhpcy5fb25NZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fb25NZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX2hhbmRzaGFrZSgpO1xuICAgIH1cbiAgICBfcG9zdE1lc3NhZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLl90YXJnZXRXaW5kb3cucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLl90YXJnZXQsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICB9LCB0aGlzLl90YXJnZXRPcmlnaW4pO1xuICAgIH1cbiAgICBfb25NZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuICAgICAgICAvLyB2YWxpZGF0ZSBtZXNzYWdlXG4gICAgICAgIGlmICgodGhpcy5fdGFyZ2V0T3JpZ2luICE9PSAnKicgJiYgZXZlbnQub3JpZ2luICE9PSB0aGlzLl90YXJnZXRPcmlnaW4pIHx8XG4gICAgICAgICAgICBldmVudC5zb3VyY2UgIT09IHRoaXMuX3RhcmdldFdpbmRvdyB8fFxuICAgICAgICAgICAgdHlwZW9mIG1lc3NhZ2UgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICBtZXNzYWdlLnRhcmdldCAhPT0gdGhpcy5fbmFtZSB8fFxuICAgICAgICAgICAgIW1lc3NhZ2UuZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29uRGF0YShtZXNzYWdlLmRhdGEpO1xuICAgIH1cbiAgICBfZGVzdHJveSgpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9vbk1lc3NhZ2UsIGZhbHNlKTtcbiAgICB9XG59XG5leHBvcnRzLldpbmRvd1Bvc3RNZXNzYWdlU3RyZWFtID0gV2luZG93UG9zdE1lc3NhZ2VTdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XaW5kb3dQb3N0TWVzc2FnZVN0cmVhbS5qcy5tYXAiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuVHJhbnNmb3JtXG4gICwgaW5oZXJpdHMgID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG4gICwgeHRlbmQgICAgID0gcmVxdWlyZSgneHRlbmQnKVxuXG5mdW5jdGlvbiBEZXN0cm95YWJsZVRyYW5zZm9ybShvcHRzKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdHMpXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlXG59XG5cbmluaGVyaXRzKERlc3Ryb3lhYmxlVHJhbnNmb3JtLCBUcmFuc2Zvcm0pXG5cbkRlc3Ryb3lhYmxlVHJhbnNmb3JtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlXG4gIFxuICB2YXIgc2VsZiA9IHRoaXNcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBpZiAoZXJyKVxuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJylcbiAgfSlcbn1cblxuLy8gYSBub29wIF90cmFuc2Zvcm0gZnVuY3Rpb25cbmZ1bmN0aW9uIG5vb3AgKGNodW5rLCBlbmMsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKG51bGwsIGNodW5rKVxufVxuXG5cbi8vIGNyZWF0ZSBhIG5ldyBleHBvcnQgZnVuY3Rpb24sIHVzZWQgYnkgYm90aCB0aGUgbWFpbiBleHBvcnQgYW5kXG4vLyB0aGUgLmN0b3IgZXhwb3J0LCBjb250YWlucyBjb21tb24gbG9naWMgZm9yIGRlYWxpbmcgd2l0aCBhcmd1bWVudHNcbmZ1bmN0aW9uIHRocm91Z2gyIChjb25zdHJ1Y3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZsdXNoICAgICA9IHRyYW5zZm9ybVxuICAgICAgdHJhbnNmb3JtID0gb3B0aW9uc1xuICAgICAgb3B0aW9ucyAgID0ge31cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSAhPSAnZnVuY3Rpb24nKVxuICAgICAgdHJhbnNmb3JtID0gbm9vcFxuXG4gICAgaWYgKHR5cGVvZiBmbHVzaCAhPSAnZnVuY3Rpb24nKVxuICAgICAgZmx1c2ggPSBudWxsXG5cbiAgICByZXR1cm4gY29uc3RydWN0KG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpXG4gIH1cbn1cblxuXG4vLyBtYWluIGV4cG9ydCwganVzdCBtYWtlIG1lIGEgdHJhbnNmb3JtIHN0cmVhbSFcbm1vZHVsZS5leHBvcnRzID0gdGhyb3VnaDIoZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgdmFyIHQyID0gbmV3IERlc3Ryb3lhYmxlVHJhbnNmb3JtKG9wdGlvbnMpXG5cbiAgdDIuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybVxuXG4gIGlmIChmbHVzaClcbiAgICB0Mi5fZmx1c2ggPSBmbHVzaFxuXG4gIHJldHVybiB0MlxufSlcblxuXG4vLyBtYWtlIG1lIGEgcmV1c2FibGUgcHJvdG90eXBlIHRoYXQgSSBjYW4gYG5ld2AsIG9yIGltcGxpY2l0bHkgYG5ld2Bcbi8vIHdpdGggYSBjb25zdHJ1Y3RvciBjYWxsXG5tb2R1bGUuZXhwb3J0cy5jdG9yID0gdGhyb3VnaDIoZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgZnVuY3Rpb24gVGhyb3VnaDIgKG92ZXJyaWRlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRocm91Z2gyKSlcbiAgICAgIHJldHVybiBuZXcgVGhyb3VnaDIob3ZlcnJpZGUpXG5cbiAgICB0aGlzLm9wdGlvbnMgPSB4dGVuZChvcHRpb25zLCBvdmVycmlkZSlcblxuICAgIERlc3Ryb3lhYmxlVHJhbnNmb3JtLmNhbGwodGhpcywgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgaW5oZXJpdHMoVGhyb3VnaDIsIERlc3Ryb3lhYmxlVHJhbnNmb3JtKVxuXG4gIFRocm91Z2gyLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIFRocm91Z2gyLnByb3RvdHlwZS5fZmx1c2ggPSBmbHVzaFxuXG4gIHJldHVybiBUaHJvdWdoMlxufSlcblxuXG5tb2R1bGUuZXhwb3J0cy5vYmogPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICB2YXIgdDIgPSBuZXcgRGVzdHJveWFibGVUcmFuc2Zvcm0oeHRlbmQoeyBvYmplY3RNb2RlOiB0cnVlLCBoaWdoV2F0ZXJNYXJrOiAxNiB9LCBvcHRpb25zKSlcblxuICB0Mi5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIHQyLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIHQyXG59KVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhbnNhY3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zYWN0aW9uXzEuZGVmYXVsdDsgfSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcbid1c2Ugc3RyaWN0J1xuXG5pZiAoXCJkZXZlbG9wbWVudFwiID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2JjLXVyLXJlZ2lzdHJ5LWV0aC5janMucHJvZHVjdGlvbi5taW4uanMnKVxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2JjLXVyLXJlZ2lzdHJ5LWV0aC5janMuZGV2ZWxvcG1lbnQuanMnKVxufVxuIiwidmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vZ2V0UHJvdG90eXBlT2YuanNcIik7XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc3VwZXJQcm9wQmFzZTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgYXNzaWduID0gbWFrZV9hc3NpZ24oKVxudmFyIGNyZWF0ZSA9IG1ha2VfY3JlYXRlKClcbnZhciB0cmltID0gbWFrZV90cmltKClcbnZhciBHbG9iYWwgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRhc3NpZ246IGFzc2lnbixcblx0Y3JlYXRlOiBjcmVhdGUsXG5cdHRyaW06IHRyaW0sXG5cdGJpbmQ6IGJpbmQsXG5cdHNsaWNlOiBzbGljZSxcblx0ZWFjaDogZWFjaCxcblx0bWFwOiBtYXAsXG5cdHBsdWNrOiBwbHVjayxcblx0aXNMaXN0OiBpc0xpc3QsXG5cdGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG5cdGlzT2JqZWN0OiBpc09iamVjdCxcblx0R2xvYmFsOiBHbG9iYWxcbn1cblxuZnVuY3Rpb24gbWFrZV9hc3NpZ24oKSB7XG5cdGlmIChPYmplY3QuYXNzaWduKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5hc3NpZ25cblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gc2hpbUFzc2lnbihvYmosIHByb3BzMSwgcHJvcHMyLCBldGMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGVhY2goT2JqZWN0KGFyZ3VtZW50c1tpXSksIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG5cdFx0XHRcdFx0b2JqW2tleV0gPSB2YWxcblx0XHRcdFx0fSlcblx0XHRcdH1cdFx0XHRcblx0XHRcdHJldHVybiBvYmpcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbWFrZV9jcmVhdGUoKSB7XG5cdGlmIChPYmplY3QuY3JlYXRlKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZShvYmosIGFzc2lnblByb3BzMSwgYXNzaWduUHJvcHMyLCBldGMpIHtcblx0XHRcdHZhciBhc3NpZ25BcmdzTGlzdCA9IHNsaWNlKGFyZ3VtZW50cywgMSlcblx0XHRcdHJldHVybiBhc3NpZ24uYXBwbHkodGhpcywgW09iamVjdC5jcmVhdGUob2JqKV0uY29uY2F0KGFzc2lnbkFyZ3NMaXN0KSlcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0ZnVuY3Rpb24gRigpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW5uZXItZGVjbGFyYXRpb25zXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZShvYmosIGFzc2lnblByb3BzMSwgYXNzaWduUHJvcHMyLCBldGMpIHtcblx0XHRcdHZhciBhc3NpZ25BcmdzTGlzdCA9IHNsaWNlKGFyZ3VtZW50cywgMSlcblx0XHRcdEYucHJvdG90eXBlID0gb2JqXG5cdFx0XHRyZXR1cm4gYXNzaWduLmFwcGx5KHRoaXMsIFtuZXcgRigpXS5jb25jYXQoYXNzaWduQXJnc0xpc3QpKVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBtYWtlX3RyaW0oKSB7XG5cdGlmIChTdHJpbmcucHJvdG90eXBlLnRyaW0pIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gdHJpbShzdHIpIHtcblx0XHRcdHJldHVybiBTdHJpbmcucHJvdG90eXBlLnRyaW0uY2FsbChzdHIpXG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBmdW5jdGlvbiB0cmltKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpXG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGJpbmQob2JqLCBmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZuLmFwcGx5KG9iaiwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSlcblx0fVxufVxuXG5mdW5jdGlvbiBzbGljZShhcnIsIGluZGV4KSB7XG5cdHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIsIGluZGV4IHx8IDApXG59XG5cbmZ1bmN0aW9uIGVhY2gob2JqLCBmbikge1xuXHRwbHVjayhvYmosIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG5cdFx0Zm4odmFsLCBrZXkpXG5cdFx0cmV0dXJuIGZhbHNlXG5cdH0pXG59XG5cbmZ1bmN0aW9uIG1hcChvYmosIGZuKSB7XG5cdHZhciByZXMgPSAoaXNMaXN0KG9iaikgPyBbXSA6IHt9KVxuXHRwbHVjayhvYmosIGZ1bmN0aW9uKHYsIGspIHtcblx0XHRyZXNba10gPSBmbih2LCBrKVxuXHRcdHJldHVybiBmYWxzZVxuXHR9KVxuXHRyZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHBsdWNrKG9iaiwgZm4pIHtcblx0aWYgKGlzTGlzdChvYmopKSB7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPG9iai5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGZuKG9ialtpXSwgaSkpIHtcblx0XHRcdFx0cmV0dXJuIG9ialtpXVxuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdFx0XHRpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0aWYgKGZuKG9ialtrZXldLCBrZXkpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9ialtrZXldXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gaXNMaXN0KHZhbCkge1xuXHRyZXR1cm4gKHZhbCAhPSBudWxsICYmIHR5cGVvZiB2YWwgIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsLmxlbmd0aCA9PSAnbnVtYmVyJylcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcblx0cmV0dXJuIHZhbCAmJiB7fS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSdcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG5cdHJldHVybiB2YWwgJiYge30udG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cblxuLy8gIGpzb24yLmpzXG4vLyAgMjAxNi0xMC0yOFxuLy8gIFB1YmxpYyBEb21haW4uXG4vLyAgTk8gV0FSUkFOVFkgRVhQUkVTU0VEIE9SIElNUExJRUQuIFVTRSBBVCBZT1VSIE9XTiBSSVNLLlxuLy8gIFNlZSBodHRwOi8vd3d3LkpTT04ub3JnL2pzLmh0bWxcbi8vICBUaGlzIGNvZGUgc2hvdWxkIGJlIG1pbmlmaWVkIGJlZm9yZSBkZXBsb3ltZW50LlxuLy8gIFNlZSBodHRwOi8vamF2YXNjcmlwdC5jcm9ja2ZvcmQuY29tL2pzbWluLmh0bWxcblxuLy8gIFVTRSBZT1VSIE9XTiBDT1BZLiBJVCBJUyBFWFRSRU1FTFkgVU5XSVNFIFRPIExPQUQgQ09ERSBGUk9NIFNFUlZFUlMgWU9VIERPXG4vLyAgTk9UIENPTlRST0wuXG5cbi8vICBUaGlzIGZpbGUgY3JlYXRlcyBhIGdsb2JhbCBKU09OIG9iamVjdCBjb250YWluaW5nIHR3byBtZXRob2RzOiBzdHJpbmdpZnlcbi8vICBhbmQgcGFyc2UuIFRoaXMgZmlsZSBwcm92aWRlcyB0aGUgRVM1IEpTT04gY2FwYWJpbGl0eSB0byBFUzMgc3lzdGVtcy5cbi8vICBJZiBhIHByb2plY3QgbWlnaHQgcnVuIG9uIElFOCBvciBlYXJsaWVyLCB0aGVuIHRoaXMgZmlsZSBzaG91bGQgYmUgaW5jbHVkZWQuXG4vLyAgVGhpcyBmaWxlIGRvZXMgbm90aGluZyBvbiBFUzUgc3lzdGVtcy5cblxuLy8gICAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKVxuLy8gICAgICAgICAgdmFsdWUgICAgICAgYW55IEphdmFTY3JpcHQgdmFsdWUsIHVzdWFsbHkgYW4gb2JqZWN0IG9yIGFycmF5LlxuLy8gICAgICAgICAgcmVwbGFjZXIgICAgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgZGV0ZXJtaW5lcyBob3cgb2JqZWN0XG4vLyAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgYXJlIHN0cmluZ2lmaWVkIGZvciBvYmplY3RzLiBJdCBjYW4gYmUgYVxuLy8gICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbi8vICAgICAgICAgIHNwYWNlICAgICAgIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbi8vICAgICAgICAgICAgICAgICAgICAgIG9mIG5lc3RlZCBzdHJ1Y3R1cmVzLiBJZiBpdCBpcyBvbWl0dGVkLCB0aGUgdGV4dCB3aWxsXG4vLyAgICAgICAgICAgICAgICAgICAgICBiZSBwYWNrZWQgd2l0aG91dCBleHRyYSB3aGl0ZXNwYWNlLiBJZiBpdCBpcyBhIG51bWJlcixcbi8vICAgICAgICAgICAgICAgICAgICAgIGl0IHdpbGwgc3BlY2lmeSB0aGUgbnVtYmVyIG9mIHNwYWNlcyB0byBpbmRlbnQgYXQgZWFjaFxuLy8gICAgICAgICAgICAgICAgICAgICAgbGV2ZWwuIElmIGl0IGlzIGEgc3RyaW5nIChzdWNoIGFzIFwiXFx0XCIgb3IgXCImbmJzcDtcIiksXG4vLyAgICAgICAgICAgICAgICAgICAgICBpdCBjb250YWlucyB0aGUgY2hhcmFjdGVycyB1c2VkIHRvIGluZGVudCBhdCBlYWNoIGxldmVsLlxuLy8gICAgICAgICAgVGhpcyBtZXRob2QgcHJvZHVjZXMgYSBKU09OIHRleHQgZnJvbSBhIEphdmFTY3JpcHQgdmFsdWUuXG4vLyAgICAgICAgICBXaGVuIGFuIG9iamVjdCB2YWx1ZSBpcyBmb3VuZCwgaWYgdGhlIG9iamVjdCBjb250YWlucyBhIHRvSlNPTlxuLy8gICAgICAgICAgbWV0aG9kLCBpdHMgdG9KU09OIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhbmQgdGhlIHJlc3VsdCB3aWxsIGJlXG4vLyAgICAgICAgICBzdHJpbmdpZmllZC4gQSB0b0pTT04gbWV0aG9kIGRvZXMgbm90IHNlcmlhbGl6ZTogaXQgcmV0dXJucyB0aGVcbi8vICAgICAgICAgIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBuYW1lL3ZhbHVlIHBhaXIgdGhhdCBzaG91bGQgYmUgc2VyaWFsaXplZCxcbi8vICAgICAgICAgIG9yIHVuZGVmaW5lZCBpZiBub3RoaW5nIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgdG9KU09OIG1ldGhvZFxuLy8gICAgICAgICAgd2lsbCBiZSBwYXNzZWQgdGhlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIHZhbHVlLCBhbmQgdGhpcyB3aWxsIGJlXG4vLyAgICAgICAgICBib3VuZCB0byB0aGUgdmFsdWUuXG5cbi8vICAgICAgICAgIEZvciBleGFtcGxlLCB0aGlzIHdvdWxkIHNlcmlhbGl6ZSBEYXRlcyBhcyBJU08gc3RyaW5ncy5cblxuLy8gICAgICAgICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcbi8vICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZihuKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAvLyBGb3JtYXQgaW50ZWdlcnMgdG8gaGF2ZSBhdCBsZWFzdCB0d28gZGlnaXRzLlxuLy8gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChuIDwgMTApXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIjBcIiArIG5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICA6IG47XG4vLyAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VVRDRnVsbFllYXIoKSAgICsgXCItXCIgK1xuLy8gICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNb250aCgpICsgMSkgKyBcIi1cIiArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0RhdGUoKSkgICAgICArIFwiVFwiICtcbi8vICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDSG91cnMoKSkgICAgICsgXCI6XCIgK1xuLy8gICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNaW51dGVzKCkpICAgKyBcIjpcIiArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ1NlY29uZHMoKSkgICArIFwiWlwiO1xuLy8gICAgICAgICAgICAgIH07XG5cbi8vICAgICAgICAgIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbCByZXBsYWNlciBtZXRob2QuIEl0IHdpbGwgYmUgcGFzc2VkIHRoZVxuLy8gICAgICAgICAga2V5IGFuZCB2YWx1ZSBvZiBlYWNoIG1lbWJlciwgd2l0aCB0aGlzIGJvdW5kIHRvIHRoZSBjb250YWluaW5nXG4vLyAgICAgICAgICBvYmplY3QuIFRoZSB2YWx1ZSB0aGF0IGlzIHJldHVybmVkIGZyb20geW91ciBtZXRob2Qgd2lsbCBiZVxuLy8gICAgICAgICAgc2VyaWFsaXplZC4gSWYgeW91ciBtZXRob2QgcmV0dXJucyB1bmRlZmluZWQsIHRoZW4gdGhlIG1lbWJlciB3aWxsXG4vLyAgICAgICAgICBiZSBleGNsdWRlZCBmcm9tIHRoZSBzZXJpYWxpemF0aW9uLlxuXG4vLyAgICAgICAgICBJZiB0aGUgcmVwbGFjZXIgcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MsIHRoZW4gaXQgd2lsbCBiZVxuLy8gICAgICAgICAgdXNlZCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc2VyaWFsaXplZC4gSXQgZmlsdGVycyB0aGUgcmVzdWx0c1xuLy8gICAgICAgICAgc3VjaCB0aGF0IG9ubHkgbWVtYmVycyB3aXRoIGtleXMgbGlzdGVkIGluIHRoZSByZXBsYWNlciBhcnJheSBhcmVcbi8vICAgICAgICAgIHN0cmluZ2lmaWVkLlxuXG4vLyAgICAgICAgICBWYWx1ZXMgdGhhdCBkbyBub3QgaGF2ZSBKU09OIHJlcHJlc2VudGF0aW9ucywgc3VjaCBhcyB1bmRlZmluZWQgb3Jcbi8vICAgICAgICAgIGZ1bmN0aW9ucywgd2lsbCBub3QgYmUgc2VyaWFsaXplZC4gU3VjaCB2YWx1ZXMgaW4gb2JqZWN0cyB3aWxsIGJlXG4vLyAgICAgICAgICBkcm9wcGVkOyBpbiBhcnJheXMgdGhleSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggbnVsbC4gWW91IGNhbiB1c2Vcbi8vICAgICAgICAgIGEgcmVwbGFjZXIgZnVuY3Rpb24gdG8gcmVwbGFjZSB0aG9zZSB3aXRoIEpTT04gdmFsdWVzLlxuXG4vLyAgICAgICAgICBKU09OLnN0cmluZ2lmeSh1bmRlZmluZWQpIHJldHVybnMgdW5kZWZpbmVkLlxuXG4vLyAgICAgICAgICBUaGUgb3B0aW9uYWwgc3BhY2UgcGFyYW1ldGVyIHByb2R1Y2VzIGEgc3RyaW5naWZpY2F0aW9uIG9mIHRoZVxuLy8gICAgICAgICAgdmFsdWUgdGhhdCBpcyBmaWxsZWQgd2l0aCBsaW5lIGJyZWFrcyBhbmQgaW5kZW50YXRpb24gdG8gbWFrZSBpdFxuLy8gICAgICAgICAgZWFzaWVyIHRvIHJlYWQuXG5cbi8vICAgICAgICAgIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBub24tZW1wdHkgc3RyaW5nLCB0aGVuIHRoYXQgc3RyaW5nIHdpbGxcbi8vICAgICAgICAgIGJlIHVzZWQgZm9yIGluZGVudGF0aW9uLiBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCB0aGVuXG4vLyAgICAgICAgICB0aGUgaW5kZW50YXRpb24gd2lsbCBiZSB0aGF0IG1hbnkgc3BhY2VzLlxuXG4vLyAgICAgICAgICBFeGFtcGxlOlxuXG4vLyAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW1wiZVwiLCB7cGx1cmlidXM6IFwidW51bVwifV0pO1xuLy8gICAgICAgICAgLy8gdGV4dCBpcyAnW1wiZVwiLHtcInBsdXJpYnVzXCI6XCJ1bnVtXCJ9XSdcblxuLy8gICAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KFtcImVcIiwge3BsdXJpYnVzOiBcInVudW1cIn1dLCBudWxsLCBcIlxcdFwiKTtcbi8vICAgICAgICAgIC8vIHRleHQgaXMgJ1tcXG5cXHRcImVcIixcXG5cXHR7XFxuXFx0XFx0XCJwbHVyaWJ1c1wiOiBcInVudW1cIlxcblxcdH1cXG5dJ1xuXG4vLyAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW25ldyBEYXRlKCldLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuLy8gICAgICAgICAgICAgIHJldHVybiB0aGlzW2tleV0gaW5zdGFuY2VvZiBEYXRlXG4vLyAgICAgICAgICAgICAgICAgID8gXCJEYXRlKFwiICsgdGhpc1trZXldICsgXCIpXCJcbi8vICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcbi8vICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgLy8gdGV4dCBpcyAnW1wiRGF0ZSgtLS1jdXJyZW50IHRpbWUtLS0pXCJdJ1xuXG4vLyAgICAgIEpTT04ucGFyc2UodGV4dCwgcmV2aXZlcilcbi8vICAgICAgICAgIFRoaXMgbWV0aG9kIHBhcnNlcyBhIEpTT04gdGV4dCB0byBwcm9kdWNlIGFuIG9iamVjdCBvciBhcnJheS5cbi8vICAgICAgICAgIEl0IGNhbiB0aHJvdyBhIFN5bnRheEVycm9yIGV4Y2VwdGlvbi5cblxuLy8gICAgICAgICAgVGhlIG9wdGlvbmFsIHJldml2ZXIgcGFyYW1ldGVyIGlzIGEgZnVuY3Rpb24gdGhhdCBjYW4gZmlsdGVyIGFuZFxuLy8gICAgICAgICAgdHJhbnNmb3JtIHRoZSByZXN1bHRzLiBJdCByZWNlaXZlcyBlYWNoIG9mIHRoZSBrZXlzIGFuZCB2YWx1ZXMsXG4vLyAgICAgICAgICBhbmQgaXRzIHJldHVybiB2YWx1ZSBpcyB1c2VkIGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIHZhbHVlLlxuLy8gICAgICAgICAgSWYgaXQgcmV0dXJucyB3aGF0IGl0IHJlY2VpdmVkLCB0aGVuIHRoZSBzdHJ1Y3R1cmUgaXMgbm90IG1vZGlmaWVkLlxuLy8gICAgICAgICAgSWYgaXQgcmV0dXJucyB1bmRlZmluZWQgdGhlbiB0aGUgbWVtYmVyIGlzIGRlbGV0ZWQuXG5cbi8vICAgICAgICAgIEV4YW1wbGU6XG5cbi8vICAgICAgICAgIC8vIFBhcnNlIHRoZSB0ZXh0LiBWYWx1ZXMgdGhhdCBsb29rIGxpa2UgSVNPIGRhdGUgc3RyaW5ncyB3aWxsXG4vLyAgICAgICAgICAvLyBiZSBjb252ZXJ0ZWQgdG8gRGF0ZSBvYmplY3RzLlxuXG4vLyAgICAgICAgICBteURhdGEgPSBKU09OLnBhcnNlKHRleHQsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4vLyAgICAgICAgICAgICAgdmFyIGE7XG4vLyAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuLy8gICAgICAgICAgICAgICAgICBhID1cbi8vICAgL14oXFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KVQoXFxkezJ9KTooXFxkezJ9KTooXFxkezJ9KD86XFwuXFxkKik/KVokLy5leGVjKHZhbHVlKTtcbi8vICAgICAgICAgICAgICAgICAgaWYgKGEpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygrYVsxXSwgK2FbMl0gLSAxLCArYVszXSwgK2FbNF0sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgK2FbNV0sICthWzZdKSk7XG4vLyAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuLy8gICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgIG15RGF0YSA9IEpTT04ucGFyc2UoJ1tcIkRhdGUoMDkvMDkvMjAwMSlcIl0nLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuLy8gICAgICAgICAgICAgIHZhciBkO1xuLy8gICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbi8vICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKDAsIDUpID09PSBcIkRhdGUoXCIgJiZcbi8vICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKC0xKSA9PT0gXCIpXCIpIHtcbi8vICAgICAgICAgICAgICAgICAgZCA9IG5ldyBEYXRlKHZhbHVlLnNsaWNlKDUsIC0xKSk7XG4vLyAgICAgICAgICAgICAgICAgIGlmIChkKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbi8vICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4vLyAgICAgICAgICB9KTtcblxuLy8gIFRoaXMgaXMgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24uIFlvdSBhcmUgZnJlZSB0byBjb3B5LCBtb2RpZnksIG9yXG4vLyAgcmVkaXN0cmlidXRlLlxuXG4vKmpzbGludFxuICAgIGV2YWwsIGZvciwgdGhpc1xuKi9cblxuLypwcm9wZXJ0eVxuICAgIEpTT04sIGFwcGx5LCBjYWxsLCBjaGFyQ29kZUF0LCBnZXRVVENEYXRlLCBnZXRVVENGdWxsWWVhciwgZ2V0VVRDSG91cnMsXG4gICAgZ2V0VVRDTWludXRlcywgZ2V0VVRDTW9udGgsIGdldFVUQ1NlY29uZHMsIGhhc093blByb3BlcnR5LCBqb2luLFxuICAgIGxhc3RJbmRleCwgbGVuZ3RoLCBwYXJzZSwgcHJvdG90eXBlLCBwdXNoLCByZXBsYWNlLCBzbGljZSwgc3RyaW5naWZ5LFxuICAgIHRlc3QsIHRvSlNPTiwgdG9TdHJpbmcsIHZhbHVlT2ZcbiovXG5cblxuLy8gQ3JlYXRlIGEgSlNPTiBvYmplY3Qgb25seSBpZiBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC4gV2UgY3JlYXRlIHRoZVxuLy8gbWV0aG9kcyBpbiBhIGNsb3N1cmUgdG8gYXZvaWQgY3JlYXRpbmcgZ2xvYmFsIHZhcmlhYmxlcy5cblxuaWYgKHR5cGVvZiBKU09OICE9PSBcIm9iamVjdFwiKSB7XG4gICAgSlNPTiA9IHt9O1xufVxuXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHJ4X29uZSA9IC9eW1xcXSw6e31cXHNdKiQvO1xuICAgIHZhciByeF90d28gPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nO1xuICAgIHZhciByeF90aHJlZSA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZztcbiAgICB2YXIgcnhfZm91ciA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZztcbiAgICB2YXIgcnhfZXNjYXBhYmxlID0gL1tcXFxcXCJcXHUwMDAwLVxcdTAwMWZcXHUwMDdmLVxcdTAwOWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZztcbiAgICB2YXIgcnhfZGFuZ2Vyb3VzID0gL1tcXHUwMDAwXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2c7XG5cbiAgICBmdW5jdGlvbiBmKG4pIHtcbiAgICAgICAgLy8gRm9ybWF0IGludGVnZXJzIHRvIGhhdmUgYXQgbGVhc3QgdHdvIGRpZ2l0cy5cbiAgICAgICAgcmV0dXJuIG4gPCAxMFxuICAgICAgICAgICAgPyBcIjBcIiArIG5cbiAgICAgICAgICAgIDogbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aGlzX3ZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0pTT04gIT09IFwiZnVuY3Rpb25cIikge1xuXG4gICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHRoaXMudmFsdWVPZigpKVxuICAgICAgICAgICAgICAgID8gdGhpcy5nZXRVVENGdWxsWWVhcigpICsgXCItXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01vbnRoKCkgKyAxKSArIFwiLVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENEYXRlKCkpICsgXCJUXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0hvdXJzKCkpICsgXCI6XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01pbnV0ZXMoKSkgKyBcIjpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDU2Vjb25kcygpKSArIFwiWlwiXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnRvSlNPTiA9IHRoaXNfdmFsdWU7XG4gICAgICAgIE51bWJlci5wcm90b3R5cGUudG9KU09OID0gdGhpc192YWx1ZTtcbiAgICAgICAgU3RyaW5nLnByb3RvdHlwZS50b0pTT04gPSB0aGlzX3ZhbHVlO1xuICAgIH1cblxuICAgIHZhciBnYXA7XG4gICAgdmFyIGluZGVudDtcbiAgICB2YXIgbWV0YTtcbiAgICB2YXIgcmVwO1xuXG5cbiAgICBmdW5jdGlvbiBxdW90ZShzdHJpbmcpIHtcblxuLy8gSWYgdGhlIHN0cmluZyBjb250YWlucyBubyBjb250cm9sIGNoYXJhY3RlcnMsIG5vIHF1b3RlIGNoYXJhY3RlcnMsIGFuZCBub1xuLy8gYmFja3NsYXNoIGNoYXJhY3RlcnMsIHRoZW4gd2UgY2FuIHNhZmVseSBzbGFwIHNvbWUgcXVvdGVzIGFyb3VuZCBpdC5cbi8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlIGVzY2FwZVxuLy8gc2VxdWVuY2VzLlxuXG4gICAgICAgIHJ4X2VzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gcnhfZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKVxuICAgICAgICAgICAgPyBcIlxcXCJcIiArIHN0cmluZy5yZXBsYWNlKHJ4X2VzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgID8gY1xuICAgICAgICAgICAgICAgICAgICA6IFwiXFxcXHVcIiArIChcIjAwMDBcIiArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgICAgIH0pICsgXCJcXFwiXCJcbiAgICAgICAgICAgIDogXCJcXFwiXCIgKyBzdHJpbmcgKyBcIlxcXCJcIjtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHN0cihrZXksIGhvbGRlcikge1xuXG4vLyBQcm9kdWNlIGEgc3RyaW5nIGZyb20gaG9sZGVyW2tleV0uXG5cbiAgICAgICAgdmFyIGk7ICAgICAgICAgIC8vIFRoZSBsb29wIGNvdW50ZXIuXG4gICAgICAgIHZhciBrOyAgICAgICAgICAvLyBUaGUgbWVtYmVyIGtleS5cbiAgICAgICAgdmFyIHY7ICAgICAgICAgIC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgICAgIHZhciBsZW5ndGg7XG4gICAgICAgIHZhciBtaW5kID0gZ2FwO1xuICAgICAgICB2YXIgcGFydGlhbDtcbiAgICAgICAgdmFyIHZhbHVlID0gaG9sZGVyW2tleV07XG5cbi8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgICAgIH1cblxuLy8gSWYgd2Ugd2VyZSBjYWxsZWQgd2l0aCBhIHJlcGxhY2VyIGZ1bmN0aW9uLCB0aGVuIGNhbGwgdGhlIHJlcGxhY2VyIHRvXG4vLyBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cblxuICAgICAgICBpZiAodHlwZW9mIHJlcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHJlcC5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG5cbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuXG4vLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cblxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKHZhbHVlKVxuICAgICAgICAgICAgICAgIDogXCJudWxsXCI7XG5cbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcIm51bGxcIjpcblxuLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSBcIm51bGxcIi4gVGhlIGNhc2UgaXMgaW5jbHVkZWQgaGVyZSBpblxuLy8gdGhlIHJlbW90ZSBjaGFuY2UgdGhhdCB0aGlzIGdldHMgZml4ZWQgc29tZWRheS5cblxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cbi8vIElmIHRoZSB0eXBlIGlzIFwib2JqZWN0XCIsIHdlIG1pZ2h0IGJlIGRlYWxpbmcgd2l0aCBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgb3Jcbi8vIG51bGwuXG5cbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuXG4vLyBEdWUgdG8gYSBzcGVjaWZpY2F0aW9uIGJsdW5kZXIgaW4gRUNNQVNjcmlwdCwgdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIixcbi8vIHNvIHdhdGNoIG91dCBmb3IgdGhhdCBjYXNlLlxuXG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgICAgfVxuXG4vLyBNYWtlIGFuIGFycmF5IHRvIGhvbGQgdGhlIHBhcnRpYWwgcmVzdWx0cyBvZiBzdHJpbmdpZnlpbmcgdGhpcyBvYmplY3QgdmFsdWUuXG5cbiAgICAgICAgICAgIGdhcCArPSBpbmRlbnQ7XG4gICAgICAgICAgICBwYXJ0aWFsID0gW107XG5cbi8vIElzIHRoZSB2YWx1ZSBhbiBhcnJheT9cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcblxuLy8gVGhlIHZhbHVlIGlzIGFuIGFycmF5LiBTdHJpbmdpZnkgZXZlcnkgZWxlbWVudC4gVXNlIG51bGwgYXMgYSBwbGFjZWhvbGRlclxuLy8gZm9yIG5vbi1KU09OIHZhbHVlcy5cblxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgXCJudWxsXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kIHdyYXAgdGhlbSBpblxuLy8gYnJhY2tldHMuXG5cbiAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyBcIltdXCJcbiAgICAgICAgICAgICAgICAgICAgOiBnYXBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJbXFxuXCIgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oXCIsXFxuXCIgKyBnYXApICsgXCJcXG5cIiArIG1pbmQgKyBcIl1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIltcIiArIHBhcnRpYWwuam9pbihcIixcIikgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgcmVwbGFjZXIgaXMgYW4gYXJyYXksIHVzZSBpdCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc3RyaW5naWZpZWQuXG5cbiAgICAgICAgICAgIGlmIChyZXAgJiYgdHlwZW9mIHJlcCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJlcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwW2ldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrID0gcmVwW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiOiBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjpcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbi8vIE90aGVyd2lzZSwgaXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUga2V5cyBpbiB0aGUgb2JqZWN0LlxuXG4gICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCI6IFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiOlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4vLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4vLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cblxuICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgPyBcInt9XCJcbiAgICAgICAgICAgICAgICA6IGdhcFxuICAgICAgICAgICAgICAgICAgICA/IFwie1xcblwiICsgZ2FwICsgcGFydGlhbC5qb2luKFwiLFxcblwiICsgZ2FwKSArIFwiXFxuXCIgKyBtaW5kICsgXCJ9XCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIntcIiArIHBhcnRpYWwuam9pbihcIixcIikgKyBcIn1cIjtcbiAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgIH1cblxuLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgc3RyaW5naWZ5IG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBpZiAodHlwZW9mIEpTT04uc3RyaW5naWZ5ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbWV0YSA9IHsgICAgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgICAgIFwiXFxiXCI6IFwiXFxcXGJcIixcbiAgICAgICAgICAgIFwiXFx0XCI6IFwiXFxcXHRcIixcbiAgICAgICAgICAgIFwiXFxuXCI6IFwiXFxcXG5cIixcbiAgICAgICAgICAgIFwiXFxmXCI6IFwiXFxcXGZcIixcbiAgICAgICAgICAgIFwiXFxyXCI6IFwiXFxcXHJcIixcbiAgICAgICAgICAgIFwiXFxcIlwiOiBcIlxcXFxcXFwiXCIsXG4gICAgICAgICAgICBcIlxcXFxcIjogXCJcXFxcXFxcXFwiXG4gICAgICAgIH07XG4gICAgICAgIEpTT04uc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcblxuLy8gVGhlIHN0cmluZ2lmeSBtZXRob2QgdGFrZXMgYSB2YWx1ZSBhbmQgYW4gb3B0aW9uYWwgcmVwbGFjZXIsIGFuZCBhbiBvcHRpb25hbFxuLy8gc3BhY2UgcGFyYW1ldGVyLCBhbmQgcmV0dXJucyBhIEpTT04gdGV4dC4gVGhlIHJlcGxhY2VyIGNhbiBiZSBhIGZ1bmN0aW9uXG4vLyB0aGF0IGNhbiByZXBsYWNlIHZhbHVlcywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHdpbGwgc2VsZWN0IHRoZSBrZXlzLlxuLy8gQSBkZWZhdWx0IHJlcGxhY2VyIG1ldGhvZCBjYW4gYmUgcHJvdmlkZWQuIFVzZSBvZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGNhblxuLy8gcHJvZHVjZSB0ZXh0IHRoYXQgaXMgbW9yZSBlYXNpbHkgcmVhZGFibGUuXG5cbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZ2FwID0gXCJcIjtcbiAgICAgICAgICAgIGluZGVudCA9IFwiXCI7XG5cbi8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIG1ha2UgYW4gaW5kZW50IHN0cmluZyBjb250YWluaW5nIHRoYXRcbi8vIG1hbnkgc3BhY2VzLlxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwYWNlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IFwiIFwiO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbmRlbnQgc3RyaW5nLlxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGFjZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGluZGVudCA9IHNwYWNlO1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGVyZSBpcyBhIHJlcGxhY2VyLCBpdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkuXG4vLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yLlxuXG4gICAgICAgICAgICByZXAgPSByZXBsYWNlcjtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlciAmJiB0eXBlb2YgcmVwbGFjZXIgIT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHJlcGxhY2VyICE9PSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXBsYWNlci5sZW5ndGggIT09IFwibnVtYmVyXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSlNPTi5zdHJpbmdpZnlcIik7XG4gICAgICAgICAgICB9XG5cbi8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgXCJcIi5cbi8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHN0cmluZ2lmeWluZyB0aGUgdmFsdWUuXG5cbiAgICAgICAgICAgIHJldHVybiBzdHIoXCJcIiwge1wiXCI6IHZhbHVlfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG5cbi8vIElmIHRoZSBKU09OIG9iamVjdCBkb2VzIG5vdCB5ZXQgaGF2ZSBhIHBhcnNlIG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBpZiAodHlwZW9mIEpTT04ucGFyc2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBKU09OLnBhcnNlID0gZnVuY3Rpb24gKHRleHQsIHJldml2ZXIpIHtcblxuLy8gVGhlIHBhcnNlIG1ldGhvZCB0YWtlcyBhIHRleHQgYW5kIGFuIG9wdGlvbmFsIHJldml2ZXIgZnVuY3Rpb24sIGFuZCByZXR1cm5zXG4vLyBhIEphdmFTY3JpcHQgdmFsdWUgaWYgdGhlIHRleHQgaXMgYSB2YWxpZCBKU09OIHRleHQuXG5cbiAgICAgICAgICAgIHZhciBqO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB3YWxrKGhvbGRlciwga2V5KSB7XG5cbi8vIFRoZSB3YWxrIG1ldGhvZCBpcyB1c2VkIHRvIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIHJlc3VsdGluZyBzdHJ1Y3R1cmUgc29cbi8vIHRoYXQgbW9kaWZpY2F0aW9ucyBjYW4gYmUgbWFkZS5cblxuICAgICAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgICAgIHZhciB2O1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB3YWxrKHZhbHVlLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXZpdmVyLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuXG4vLyBQYXJzaW5nIGhhcHBlbnMgaW4gZm91ciBzdGFnZXMuIEluIHRoZSBmaXJzdCBzdGFnZSwgd2UgcmVwbGFjZSBjZXJ0YWluXG4vLyBVbmljb2RlIGNoYXJhY3RlcnMgd2l0aCBlc2NhcGUgc2VxdWVuY2VzLiBKYXZhU2NyaXB0IGhhbmRsZXMgbWFueSBjaGFyYWN0ZXJzXG4vLyBpbmNvcnJlY3RseSwgZWl0aGVyIHNpbGVudGx5IGRlbGV0aW5nIHRoZW0sIG9yIHRyZWF0aW5nIHRoZW0gYXMgbGluZSBlbmRpbmdzLlxuXG4gICAgICAgICAgICB0ZXh0ID0gU3RyaW5nKHRleHQpO1xuICAgICAgICAgICAgcnhfZGFuZ2Vyb3VzLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAocnhfZGFuZ2Vyb3VzLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJ4X2Rhbmdlcm91cywgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHVcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiMDAwMFwiICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4vLyBJbiB0aGUgc2Vjb25kIHN0YWdlLCB3ZSBydW4gdGhlIHRleHQgYWdhaW5zdCByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbG9va1xuLy8gZm9yIG5vbi1KU09OIHBhdHRlcm5zLiBXZSBhcmUgZXNwZWNpYWxseSBjb25jZXJuZWQgd2l0aCBcIigpXCIgYW5kIFwibmV3XCJcbi8vIGJlY2F1c2UgdGhleSBjYW4gY2F1c2UgaW52b2NhdGlvbiwgYW5kIFwiPVwiIGJlY2F1c2UgaXQgY2FuIGNhdXNlIG11dGF0aW9uLlxuLy8gQnV0IGp1c3QgdG8gYmUgc2FmZSwgd2Ugd2FudCB0byByZWplY3QgYWxsIHVuZXhwZWN0ZWQgZm9ybXMuXG5cbi8vIFdlIHNwbGl0IHRoZSBzZWNvbmQgc3RhZ2UgaW50byA0IHJlZ2V4cCBvcGVyYXRpb25zIGluIG9yZGVyIHRvIHdvcmsgYXJvdW5kXG4vLyBjcmlwcGxpbmcgaW5lZmZpY2llbmNpZXMgaW4gSUUncyBhbmQgU2FmYXJpJ3MgcmVnZXhwIGVuZ2luZXMuIEZpcnN0IHdlXG4vLyByZXBsYWNlIHRoZSBKU09OIGJhY2tzbGFzaCBwYWlycyB3aXRoIFwiQFwiIChhIG5vbi1KU09OIGNoYXJhY3RlcikuIFNlY29uZCwgd2Vcbi8vIHJlcGxhY2UgYWxsIHNpbXBsZSB2YWx1ZSB0b2tlbnMgd2l0aCBcIl1cIiBjaGFyYWN0ZXJzLiBUaGlyZCwgd2UgZGVsZXRlIGFsbFxuLy8gb3BlbiBicmFja2V0cyB0aGF0IGZvbGxvdyBhIGNvbG9uIG9yIGNvbW1hIG9yIHRoYXQgYmVnaW4gdGhlIHRleHQuIEZpbmFsbHksXG4vLyB3ZSBsb29rIHRvIHNlZSB0aGF0IHRoZSByZW1haW5pbmcgY2hhcmFjdGVycyBhcmUgb25seSB3aGl0ZXNwYWNlIG9yIFwiXVwiIG9yXG4vLyBcIixcIiBvciBcIjpcIiBvciBcIntcIiBvciBcIn1cIi4gSWYgdGhhdCBpcyBzbywgdGhlbiB0aGUgdGV4dCBpcyBzYWZlIGZvciBldmFsLlxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcnhfb25lLnRlc3QoXG4gICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJ4X3R3bywgXCJAXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShyeF90aHJlZSwgXCJdXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShyeF9mb3VyLCBcIlwiKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuXG4vLyBJbiB0aGUgdGhpcmQgc3RhZ2Ugd2UgdXNlIHRoZSBldmFsIGZ1bmN0aW9uIHRvIGNvbXBpbGUgdGhlIHRleHQgaW50byBhXG4vLyBKYXZhU2NyaXB0IHN0cnVjdHVyZS4gVGhlIFwie1wiIG9wZXJhdG9yIGlzIHN1YmplY3QgdG8gYSBzeW50YWN0aWMgYW1iaWd1aXR5XG4vLyBpbiBKYXZhU2NyaXB0OiBpdCBjYW4gYmVnaW4gYSBibG9jayBvciBhbiBvYmplY3QgbGl0ZXJhbC4gV2Ugd3JhcCB0aGUgdGV4dFxuLy8gaW4gcGFyZW5zIHRvIGVsaW1pbmF0ZSB0aGUgYW1iaWd1aXR5LlxuXG4gICAgICAgICAgICAgICAgaiA9ICgwLGV2YWwpKFwiKFwiICsgdGV4dCArIFwiKVwiKTtcblxuLy8gSW4gdGhlIG9wdGlvbmFsIGZvdXJ0aCBzdGFnZSwgd2UgcmVjdXJzaXZlbHkgd2FsayB0aGUgbmV3IHN0cnVjdHVyZSwgcGFzc2luZ1xuLy8gZWFjaCBuYW1lL3ZhbHVlIHBhaXIgdG8gYSByZXZpdmVyIGZ1bmN0aW9uIGZvciBwb3NzaWJsZSB0cmFuc2Zvcm1hdGlvbi5cblxuICAgICAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHJldml2ZXIgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICAgICAgPyB3YWxrKHtcIlwiOiBqfSwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgOiBqO1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgdGV4dCBpcyBub3QgSlNPTiBwYXJzZWFibGUsIHRoZW4gYSBTeW50YXhFcnJvciBpcyB0aHJvd24uXG5cbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkpTT04ucGFyc2VcIik7XG4gICAgICAgIH07XG4gICAgfVxufSgpKTsiLCIvLyBtZW1vcnlTdG9yYWdlIGlzIGEgdXNlZnVsIGxhc3QgZmFsbGJhY2sgdG8gZW5zdXJlIHRoYXQgdGhlIHN0b3JlXG4vLyBpcyBmdW5jdGlvbnMgKG1lYW5pbmcgc3RvcmUuZ2V0KCksIHN0b3JlLnNldCgpLCBldGMgd2lsbCBhbGwgZnVuY3Rpb24pLlxuLy8gSG93ZXZlciwgc3RvcmVkIHZhbHVlcyB3aWxsIG5vdCBwZXJzaXN0IHdoZW4gdGhlIGJyb3dzZXIgbmF2aWdhdGVzIHRvXG4vLyBhIG5ldyBwYWdlIG9yIHJlbG9hZHMgdGhlIGN1cnJlbnQgcGFnZS5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdG5hbWU6ICdtZW1vcnlTdG9yYWdlJyxcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlLFxuXHRlYWNoOiBlYWNoLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0Y2xlYXJBbGw6IGNsZWFyQWxsLFxufVxuXG52YXIgbWVtb3J5U3RvcmFnZSA9IHt9XG5cbmZ1bmN0aW9uIHJlYWQoa2V5KSB7XG5cdHJldHVybiBtZW1vcnlTdG9yYWdlW2tleV1cbn1cblxuZnVuY3Rpb24gd3JpdGUoa2V5LCBkYXRhKSB7XG5cdG1lbW9yeVN0b3JhZ2Vba2V5XSA9IGRhdGFcbn1cblxuZnVuY3Rpb24gZWFjaChjYWxsYmFjaykge1xuXHRmb3IgKHZhciBrZXkgaW4gbWVtb3J5U3RvcmFnZSkge1xuXHRcdGlmIChtZW1vcnlTdG9yYWdlLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdGNhbGxiYWNrKG1lbW9yeVN0b3JhZ2Vba2V5XSwga2V5KVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmUoa2V5KSB7XG5cdGRlbGV0ZSBtZW1vcnlTdG9yYWdlW2tleV1cbn1cblxuZnVuY3Rpb24gY2xlYXJBbGwoa2V5KSB7XG5cdG1lbW9yeVN0b3JhZ2UgPSB7fVxufVxuIiwiLy8gb2xkRkYtZ2xvYmFsU3RvcmFnZSBwcm92aWRlcyBzdG9yYWdlIGZvciBGaXJlZm94XG4vLyB2ZXJzaW9ucyA2IGFuZCA3LCB3aGVyZSBubyBsb2NhbFN0b3JhZ2UsIGV0Y1xuLy8gaXMgYXZhaWxhYmxlLlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3NyYy91dGlsJylcbnZhciBHbG9iYWwgPSB1dGlsLkdsb2JhbFxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bmFtZTogJ29sZEZGLWdsb2JhbFN0b3JhZ2UnLFxuXHRyZWFkOiByZWFkLFxuXHR3cml0ZTogd3JpdGUsXG5cdGVhY2g6IGVhY2gsXG5cdHJlbW92ZTogcmVtb3ZlLFxuXHRjbGVhckFsbDogY2xlYXJBbGwsXG59XG5cbnZhciBnbG9iYWxTdG9yYWdlID0gR2xvYmFsLmdsb2JhbFN0b3JhZ2VcblxuZnVuY3Rpb24gcmVhZChrZXkpIHtcblx0cmV0dXJuIGdsb2JhbFN0b3JhZ2Vba2V5XVxufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIGRhdGEpIHtcblx0Z2xvYmFsU3RvcmFnZVtrZXldID0gZGF0YVxufVxuXG5mdW5jdGlvbiBlYWNoKGZuKSB7XG5cdGZvciAodmFyIGkgPSBnbG9iYWxTdG9yYWdlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0dmFyIGtleSA9IGdsb2JhbFN0b3JhZ2Uua2V5KGkpXG5cdFx0Zm4oZ2xvYmFsU3RvcmFnZVtrZXldLCBrZXkpXG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xuXHRyZXR1cm4gZ2xvYmFsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSlcbn1cblxuZnVuY3Rpb24gY2xlYXJBbGwoKSB7XG5cdGVhY2goZnVuY3Rpb24oa2V5LCBfKSB7XG5cdFx0ZGVsZXRlIGdsb2JhbFN0b3JhZ2Vba2V5XVxuXHR9KVxufVxuIiwiLy8gb2xkSUUtdXNlckRhdGFTdG9yYWdlIHByb3ZpZGVzIHN0b3JhZ2UgZm9yIEludGVybmV0IEV4cGxvcmVyXG4vLyB2ZXJzaW9ucyA2IGFuZCA3LCB3aGVyZSBubyBsb2NhbFN0b3JhZ2UsIHNlc3Npb25TdG9yYWdlLCBldGNcbi8vIGlzIGF2YWlsYWJsZS5cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi9zcmMvdXRpbCcpXG52YXIgR2xvYmFsID0gdXRpbC5HbG9iYWxcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdG5hbWU6ICdvbGRJRS11c2VyRGF0YVN0b3JhZ2UnLFxuXHR3cml0ZTogd3JpdGUsXG5cdHJlYWQ6IHJlYWQsXG5cdGVhY2g6IGVhY2gsXG5cdHJlbW92ZTogcmVtb3ZlLFxuXHRjbGVhckFsbDogY2xlYXJBbGwsXG59XG5cbnZhciBzdG9yYWdlTmFtZSA9ICdzdG9yZWpzJ1xudmFyIGRvYyA9IEdsb2JhbC5kb2N1bWVudFxudmFyIF93aXRoU3RvcmFnZUVsID0gX21ha2VJRVN0b3JhZ2VFbEZ1bmN0aW9uKClcbnZhciBkaXNhYmxlID0gKEdsb2JhbC5uYXZpZ2F0b3IgPyBHbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCA6ICcnKS5tYXRjaCgvIChNU0lFIDh8TVNJRSA5fE1TSUUgMTApXFwuLykgLy8gTVNJRSA5LngsIE1TSUUgMTAueFxuXG5mdW5jdGlvbiB3cml0ZSh1bmZpeGVkS2V5LCBkYXRhKSB7XG5cdGlmIChkaXNhYmxlKSB7IHJldHVybiB9XG5cdHZhciBmaXhlZEtleSA9IGZpeEtleSh1bmZpeGVkS2V5KVxuXHRfd2l0aFN0b3JhZ2VFbChmdW5jdGlvbihzdG9yYWdlRWwpIHtcblx0XHRzdG9yYWdlRWwuc2V0QXR0cmlidXRlKGZpeGVkS2V5LCBkYXRhKVxuXHRcdHN0b3JhZ2VFbC5zYXZlKHN0b3JhZ2VOYW1lKVxuXHR9KVxufVxuXG5mdW5jdGlvbiByZWFkKHVuZml4ZWRLZXkpIHtcblx0aWYgKGRpc2FibGUpIHsgcmV0dXJuIH1cblx0dmFyIGZpeGVkS2V5ID0gZml4S2V5KHVuZml4ZWRLZXkpXG5cdHZhciByZXMgPSBudWxsXG5cdF93aXRoU3RvcmFnZUVsKGZ1bmN0aW9uKHN0b3JhZ2VFbCkge1xuXHRcdHJlcyA9IHN0b3JhZ2VFbC5nZXRBdHRyaWJ1dGUoZml4ZWRLZXkpXG5cdH0pXG5cdHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZWFjaChjYWxsYmFjaykge1xuXHRfd2l0aFN0b3JhZ2VFbChmdW5jdGlvbihzdG9yYWdlRWwpIHtcblx0XHR2YXIgYXR0cmlidXRlcyA9IHN0b3JhZ2VFbC5YTUxEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0cmlidXRlc1xuXHRcdGZvciAodmFyIGk9YXR0cmlidXRlcy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG5cdFx0XHR2YXIgYXR0ciA9IGF0dHJpYnV0ZXNbaV1cblx0XHRcdGNhbGxiYWNrKHN0b3JhZ2VFbC5nZXRBdHRyaWJ1dGUoYXR0ci5uYW1lKSwgYXR0ci5uYW1lKVxuXHRcdH1cblx0fSlcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKHVuZml4ZWRLZXkpIHtcblx0dmFyIGZpeGVkS2V5ID0gZml4S2V5KHVuZml4ZWRLZXkpXG5cdF93aXRoU3RvcmFnZUVsKGZ1bmN0aW9uKHN0b3JhZ2VFbCkge1xuXHRcdHN0b3JhZ2VFbC5yZW1vdmVBdHRyaWJ1dGUoZml4ZWRLZXkpXG5cdFx0c3RvcmFnZUVsLnNhdmUoc3RvcmFnZU5hbWUpXG5cdH0pXG59XG5cbmZ1bmN0aW9uIGNsZWFyQWxsKCkge1xuXHRfd2l0aFN0b3JhZ2VFbChmdW5jdGlvbihzdG9yYWdlRWwpIHtcblx0XHR2YXIgYXR0cmlidXRlcyA9IHN0b3JhZ2VFbC5YTUxEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0cmlidXRlc1xuXHRcdHN0b3JhZ2VFbC5sb2FkKHN0b3JhZ2VOYW1lKVxuXHRcdGZvciAodmFyIGk9YXR0cmlidXRlcy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG5cdFx0XHRzdG9yYWdlRWwucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZXNbaV0ubmFtZSlcblx0XHR9XG5cdFx0c3RvcmFnZUVsLnNhdmUoc3RvcmFnZU5hbWUpXG5cdH0pXG59XG5cbi8vIEhlbHBlcnNcbi8vLy8vLy8vLy9cblxuLy8gSW4gSUU3LCBrZXlzIGNhbm5vdCBzdGFydCB3aXRoIGEgZGlnaXQgb3IgY29udGFpbiBjZXJ0YWluIGNoYXJzLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJjdXN3ZXN0aW4vc3RvcmUuanMvaXNzdWVzLzQwXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcmN1c3dlc3Rpbi9zdG9yZS5qcy9pc3N1ZXMvODNcbnZhciBmb3JiaWRkZW5DaGFyc1JlZ2V4ID0gbmV3IFJlZ0V4cChcIlshXFxcIiMkJSYnKCkqKywvXFxcXFxcXFw6Ozw9Pj9AW1xcXFxdXmB7fH1+XVwiLCBcImdcIilcbmZ1bmN0aW9uIGZpeEtleShrZXkpIHtcblx0cmV0dXJuIGtleS5yZXBsYWNlKC9eXFxkLywgJ19fXyQmJykucmVwbGFjZShmb3JiaWRkZW5DaGFyc1JlZ2V4LCAnX19fJylcbn1cblxuZnVuY3Rpb24gX21ha2VJRVN0b3JhZ2VFbEZ1bmN0aW9uKCkge1xuXHRpZiAoIWRvYyB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCB8fCAhZG9jLmRvY3VtZW50RWxlbWVudC5hZGRCZWhhdmlvcikge1xuXHRcdHJldHVybiBudWxsXG5cdH1cblx0dmFyIHNjcmlwdFRhZyA9ICdzY3JpcHQnLFxuXHRcdHN0b3JhZ2VPd25lcixcblx0XHRzdG9yYWdlQ29udGFpbmVyLFxuXHRcdHN0b3JhZ2VFbFxuXG5cdC8vIFNpbmNlICN1c2VyRGF0YSBzdG9yYWdlIGFwcGxpZXMgb25seSB0byBzcGVjaWZpYyBwYXRocywgd2UgbmVlZCB0b1xuXHQvLyBzb21laG93IGxpbmsgb3VyIGRhdGEgdG8gYSBzcGVjaWZpYyBwYXRoLiAgV2UgY2hvb3NlIC9mYXZpY29uLmljb1xuXHQvLyBhcyBhIHByZXR0eSBzYWZlIG9wdGlvbiwgc2luY2UgYWxsIGJyb3dzZXJzIGFscmVhZHkgbWFrZSBhIHJlcXVlc3QgdG9cblx0Ly8gdGhpcyBVUkwgYW55d2F5IGFuZCBiZWluZyBhIDQwNCB3aWxsIG5vdCBodXJ0IHVzIGhlcmUuICBXZSB3cmFwIGFuXG5cdC8vIGlmcmFtZSBwb2ludGluZyB0byB0aGUgZmF2aWNvbiBpbiBhbiBBY3RpdmVYT2JqZWN0KGh0bWxmaWxlKSBvYmplY3Rcblx0Ly8gKHNlZTogaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2FhNzUyNTc0KHY9VlMuODUpLmFzcHgpXG5cdC8vIHNpbmNlIHRoZSBpZnJhbWUgYWNjZXNzIHJ1bGVzIGFwcGVhciB0byBhbGxvdyBkaXJlY3QgYWNjZXNzIGFuZFxuXHQvLyBtYW5pcHVsYXRpb24gb2YgdGhlIGRvY3VtZW50IGVsZW1lbnQsIGV2ZW4gZm9yIGEgNDA0IHBhZ2UuICBUaGlzXG5cdC8vIGRvY3VtZW50IGNhbiBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgZG9jdW1lbnQgKHdoaWNoIHdvdWxkXG5cdC8vIGhhdmUgYmVlbiBsaW1pdGVkIHRvIHRoZSBjdXJyZW50IHBhdGgpIHRvIHBlcmZvcm0gI3VzZXJEYXRhIHN0b3JhZ2UuXG5cdHRyeSB7XG5cdFx0LyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgKi9cblx0XHRzdG9yYWdlQ29udGFpbmVyID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJylcblx0XHRzdG9yYWdlQ29udGFpbmVyLm9wZW4oKVxuXHRcdHN0b3JhZ2VDb250YWluZXIud3JpdGUoJzwnK3NjcmlwdFRhZysnPmRvY3VtZW50Lnc9d2luZG93PC8nK3NjcmlwdFRhZysnPjxpZnJhbWUgc3JjPVwiL2Zhdmljb24uaWNvXCI+PC9pZnJhbWU+Jylcblx0XHRzdG9yYWdlQ29udGFpbmVyLmNsb3NlKClcblx0XHRzdG9yYWdlT3duZXIgPSBzdG9yYWdlQ29udGFpbmVyLncuZnJhbWVzWzBdLmRvY3VtZW50XG5cdFx0c3RvcmFnZUVsID0gc3RvcmFnZU93bmVyLmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cdH0gY2F0Y2goZSkge1xuXHRcdC8vIHNvbWVob3cgQWN0aXZlWE9iamVjdCBpbnN0YW50aWF0aW9uIGZhaWxlZCAocGVyaGFwcyBzb21lIHNwZWNpYWxcblx0XHQvLyBzZWN1cml0eSBzZXR0aW5ncyBvciBvdGhlcndzZSksIGZhbGwgYmFjayB0byBwZXItcGF0aCBzdG9yYWdlXG5cdFx0c3RvcmFnZUVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cdFx0c3RvcmFnZU93bmVyID0gZG9jLmJvZHlcblx0fVxuXG5cdHJldHVybiBmdW5jdGlvbihzdG9yZUZ1bmN0aW9uKSB7XG5cdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMClcblx0XHRhcmdzLnVuc2hpZnQoc3RvcmFnZUVsKVxuXHRcdC8vIFNlZSBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzEwODEodj1WUy44NSkuYXNweFxuXHRcdC8vIGFuZCBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzE0MjQodj1WUy44NSkuYXNweFxuXHRcdHN0b3JhZ2VPd25lci5hcHBlbmRDaGlsZChzdG9yYWdlRWwpXG5cdFx0c3RvcmFnZUVsLmFkZEJlaGF2aW9yKCcjZGVmYXVsdCN1c2VyRGF0YScpXG5cdFx0c3RvcmFnZUVsLmxvYWQoc3RvcmFnZU5hbWUpXG5cdFx0c3RvcmVGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmdzKVxuXHRcdHN0b3JhZ2VPd25lci5yZW1vdmVDaGlsZChzdG9yYWdlRWwpXG5cdFx0cmV0dXJuXG5cdH1cbn1cbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vc3JjL3V0aWwnKVxudmFyIEdsb2JhbCA9IHV0aWwuR2xvYmFsXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRuYW1lOiAnbG9jYWxTdG9yYWdlJyxcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlLFxuXHRlYWNoOiBlYWNoLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0Y2xlYXJBbGw6IGNsZWFyQWxsLFxufVxuXG5mdW5jdGlvbiBsb2NhbFN0b3JhZ2UoKSB7XG5cdHJldHVybiBHbG9iYWwubG9jYWxTdG9yYWdlXG59XG5cbmZ1bmN0aW9uIHJlYWQoa2V5KSB7XG5cdHJldHVybiBsb2NhbFN0b3JhZ2UoKS5nZXRJdGVtKGtleSlcbn1cblxuZnVuY3Rpb24gd3JpdGUoa2V5LCBkYXRhKSB7XG5cdHJldHVybiBsb2NhbFN0b3JhZ2UoKS5zZXRJdGVtKGtleSwgZGF0YSlcbn1cblxuZnVuY3Rpb24gZWFjaChmbikge1xuXHRmb3IgKHZhciBpID0gbG9jYWxTdG9yYWdlKCkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHR2YXIga2V5ID0gbG9jYWxTdG9yYWdlKCkua2V5KGkpXG5cdFx0Zm4ocmVhZChrZXkpLCBrZXkpXG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xuXHRyZXR1cm4gbG9jYWxTdG9yYWdlKCkucmVtb3ZlSXRlbShrZXkpXG59XG5cbmZ1bmN0aW9uIGNsZWFyQWxsKCkge1xuXHRyZXR1cm4gbG9jYWxTdG9yYWdlKCkuY2xlYXIoKVxufVxuIiwiLy8gY29va2llU3RvcmFnZSBpcyB1c2VmdWwgU2FmYXJpIHByaXZhdGUgYnJvd3NlciBtb2RlLCB3aGVyZSBsb2NhbFN0b3JhZ2Vcbi8vIGRvZXNuJ3Qgd29yayBidXQgY29va2llcyBkby4gVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBhZG9wdGVkIGZyb21cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdG9yYWdlL0xvY2FsU3RvcmFnZVxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3NyYy91dGlsJylcbnZhciBHbG9iYWwgPSB1dGlsLkdsb2JhbFxudmFyIHRyaW0gPSB1dGlsLnRyaW1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdG5hbWU6ICdjb29raWVTdG9yYWdlJyxcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlLFxuXHRlYWNoOiBlYWNoLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0Y2xlYXJBbGw6IGNsZWFyQWxsLFxufVxuXG52YXIgZG9jID0gR2xvYmFsLmRvY3VtZW50XG5cbmZ1bmN0aW9uIHJlYWQoa2V5KSB7XG5cdGlmICgha2V5IHx8ICFfaGFzKGtleSkpIHsgcmV0dXJuIG51bGwgfVxuXHR2YXIgcmVnZXhwU3RyID0gXCIoPzpefC4qO1xcXFxzKilcIiArXG5cdFx0ZXNjYXBlKGtleSkucmVwbGFjZSgvW1xcLVxcLlxcK1xcKl0vZywgXCJcXFxcJCZcIikgK1xuXHRcdFwiXFxcXHMqXFxcXD1cXFxccyooKD86W147XSg/ITspKSpbXjtdPykuKlwiXG5cdHJldHVybiB1bmVzY2FwZShkb2MuY29va2llLnJlcGxhY2UobmV3IFJlZ0V4cChyZWdleHBTdHIpLCBcIiQxXCIpKVxufVxuXG5mdW5jdGlvbiBlYWNoKGNhbGxiYWNrKSB7XG5cdHZhciBjb29raWVzID0gZG9jLmNvb2tpZS5zcGxpdCgvOyA/L2cpXG5cdGZvciAodmFyIGkgPSBjb29raWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0aWYgKCF0cmltKGNvb2tpZXNbaV0pKSB7XG5cdFx0XHRjb250aW51ZVxuXHRcdH1cblx0XHR2YXIga3ZwID0gY29va2llc1tpXS5zcGxpdCgnPScpXG5cdFx0dmFyIGtleSA9IHVuZXNjYXBlKGt2cFswXSlcblx0XHR2YXIgdmFsID0gdW5lc2NhcGUoa3ZwWzFdKVxuXHRcdGNhbGxiYWNrKHZhbCwga2V5KVxuXHR9XG59XG5cbmZ1bmN0aW9uIHdyaXRlKGtleSwgZGF0YSkge1xuXHRpZigha2V5KSB7IHJldHVybiB9XG5cdGRvYy5jb29raWUgPSBlc2NhcGUoa2V5KSArIFwiPVwiICsgZXNjYXBlKGRhdGEpICsgXCI7IGV4cGlyZXM9VHVlLCAxOSBKYW4gMjAzOCAwMzoxNDowNyBHTVQ7IHBhdGg9L1wiXG59XG5cbmZ1bmN0aW9uIHJlbW92ZShrZXkpIHtcblx0aWYgKCFrZXkgfHwgIV9oYXMoa2V5KSkge1xuXHRcdHJldHVyblxuXHR9XG5cdGRvYy5jb29raWUgPSBlc2NhcGUoa2V5KSArIFwiPTsgZXhwaXJlcz1UaHUsIDAxIEphbiAxOTcwIDAwOjAwOjAwIEdNVDsgcGF0aD0vXCJcbn1cblxuZnVuY3Rpb24gY2xlYXJBbGwoKSB7XG5cdGVhY2goZnVuY3Rpb24oXywga2V5KSB7XG5cdFx0cmVtb3ZlKGtleSlcblx0fSlcbn1cblxuZnVuY3Rpb24gX2hhcyhrZXkpIHtcblx0cmV0dXJuIChuZXcgUmVnRXhwKFwiKD86Xnw7XFxcXHMqKVwiICsgZXNjYXBlKGtleSkucmVwbGFjZSgvW1xcLVxcLlxcK1xcKl0vZywgXCJcXFxcJCZcIikgKyBcIlxcXFxzKlxcXFw9XCIpKS50ZXN0KGRvYy5jb29raWUpXG59XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3NyYy91dGlsJylcbnZhciBHbG9iYWwgPSB1dGlsLkdsb2JhbFxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bmFtZTogJ3Nlc3Npb25TdG9yYWdlJyxcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlLFxuXHRlYWNoOiBlYWNoLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0Y2xlYXJBbGw6IGNsZWFyQWxsXG59XG5cbmZ1bmN0aW9uIHNlc3Npb25TdG9yYWdlKCkge1xuXHRyZXR1cm4gR2xvYmFsLnNlc3Npb25TdG9yYWdlXG59XG5cbmZ1bmN0aW9uIHJlYWQoa2V5KSB7XG5cdHJldHVybiBzZXNzaW9uU3RvcmFnZSgpLmdldEl0ZW0oa2V5KVxufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIGRhdGEpIHtcblx0cmV0dXJuIHNlc3Npb25TdG9yYWdlKCkuc2V0SXRlbShrZXksIGRhdGEpXG59XG5cbmZ1bmN0aW9uIGVhY2goZm4pIHtcblx0Zm9yICh2YXIgaSA9IHNlc3Npb25TdG9yYWdlKCkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHR2YXIga2V5ID0gc2Vzc2lvblN0b3JhZ2UoKS5rZXkoaSlcblx0XHRmbihyZWFkKGtleSksIGtleSlcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmUoa2V5KSB7XG5cdHJldHVybiBzZXNzaW9uU3RvcmFnZSgpLnJlbW92ZUl0ZW0oa2V5KVxufVxuXG5mdW5jdGlvbiBjbGVhckFsbCgpIHtcblx0cmV0dXJuIHNlc3Npb25TdG9yYWdlKCkuY2xlYXIoKVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRpZF9yZXNvbHZlcl8xID0gcmVxdWlyZShcImRpZC1yZXNvbHZlclwiKTtcbnZhciBET0NfUEFUSCA9ICcvLndlbGwta25vd24vZGlkLmpzb24nO1xuZnVuY3Rpb24gZ2V0KHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIGRlY2xhcmUgWE1MSHR0cFJlcXVlc3QgaW4gaGVyZSBzbyBpdCBjYW4gYmUgbW9ja2VkIGZvciB0ZXN0c1xuICAgICAgICB2YXIgWE1MSHR0cFJlcXVlc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyB3aW5kb3cuWE1MSHR0cFJlcXVlc3RcbiAgICAgICAgICAgIDogcmVxdWlyZSgneG1saHR0cHJlcXVlc3QnKS5YTUxIdHRwUmVxdWVzdDtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoKFwiSW52YWxpZCBodHRwIHJlc3BvbnNlIHN0YXR1cyBcIiArIHJlcXVlc3Quc3RhdHVzICsgXCIgXCIgKyByZXF1ZXN0LnJlc3BvbnNlVGV4dCkudHJpbSgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcignYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZWdpc3RlcigpIHtcbiAgICBmdW5jdGlvbiByZXNvbHZlKGRpZCwgcGFyc2VkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1cmwsIHJlc3BvbnNlLCBlcnJvcl8xLCBkYXRhLCBoYXNDb250ZXh0LCBkb2NJZE1hdGNoZXNEaWQsIGRvY0hhc1B1YmxpY0tleTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaHR0cHM6Ly9cIiArIHBhcnNlZC5pZCArIERPQ19QQVRIO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2V0KHVybCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRElEIG11c3QgcmVzb2x2ZSB0byBhIHZhbGlkIGh0dHBzIFVSTDogXCIgKyBlcnJvcl8xLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdESUQgbXVzdCByZXNvbHZlIHRvIGEgSlNPTiBkb2N1bWVudCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ29udGV4dCA9IGRhdGFbJ0Bjb250ZXh0J10gPT09ICdodHRwczovL3czaWQub3JnL2RpZC92MSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc0NvbnRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdESUQgZG9jdW1lbnQgbWlzc2luZyBjb250ZXh0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2NJZE1hdGNoZXNEaWQgPSBkYXRhLmlkID09PSBkaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRvY0lkTWF0Y2hlc0RpZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RJRCBkb2N1bWVudCBpZCBkb2VzIG5vdCBtYXRjaCByZXF1ZXN0ZWQgZGlkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2NIYXNQdWJsaWNLZXkgPSBBcnJheS5pc0FycmF5KGRhdGEucHVibGljS2V5KSAmJiBkYXRhLnB1YmxpY0tleS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkb2NIYXNQdWJsaWNLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdESUQgZG9jdW1lbnQgaGFzIG5vIHB1YmxpYyBrZXlzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGF0YV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkaWRfcmVzb2x2ZXJfMS5yZWdpc3Rlck1ldGhvZCgnaHR0cHMnLCByZXNvbHZlKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHJlZ2lzdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVnaXN0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9kaWRSZXNvbHZlciA9IHJlcXVpcmUoXCJkaWQtcmVzb2x2ZXJcIik7XG5cbnZhciBfbm9kZUZldGNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibm9kZS1mZXRjaFwiKSk7XG5cbnZhciBJTkZVUkEgPSAnaHR0cHM6Ly9pcGZzLmluZnVyYS5pby9pcGZzLyc7XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyKGlwZnMpIHtcbiAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIGZ1bmN0aW9uIHJlc29sdmUoX3gsIF94Mikge1xuICAgIHJldHVybiBfcmVzb2x2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3Jlc29sdmUoKSB7XG4gICAgX3Jlc29sdmUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgLyojX19QVVJFX18qL1xuICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKGRpZCwgcGFyc2VkKSB7XG4gICAgICB2YXIgZG9jO1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiBmZXRjaE11UG9ydERvYyhpcGZzLCBwYXJzZWQuaWQpO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGRvYyA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgd3JhcERvY3VtZW50KGRpZCwgZG9jKSk7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUpO1xuICAgIH0pKTtcbiAgICByZXR1cm4gX3Jlc29sdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gICgwLCBfZGlkUmVzb2x2ZXIucmVnaXN0ZXJNZXRob2QpKCdtdXBvcnQnLCByZXNvbHZlKTtcbn1cblxuZnVuY3Rpb24gZmV0Y2hNdVBvcnREb2MoX3gzLCBfeDQpIHtcbiAgcmV0dXJuIF9mZXRjaE11UG9ydERvYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZmV0Y2hNdVBvcnREb2MoKSB7XG4gIF9mZXRjaE11UG9ydERvYyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgLyojX19QVVJFX18qL1xuICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoaXBmcywgaXBmc0hhc2gpIHtcbiAgICB2YXIgZG9jO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAwO1xuXG4gICAgICAgICAgICBpZiAoIWlwZnMpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQyLnQxID0gSlNPTjtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiBpcGZzLmNhdChpcGZzSGFzaCk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBfY29udGV4dDIudDIgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0Mi50MS5wYXJzZS5jYWxsKF9jb250ZXh0Mi50MSwgX2NvbnRleHQyLnQyKTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTE7XG4gICAgICAgICAgICByZXR1cm4gaHR0cEZldGNoKGlwZnNIYXNoKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBkb2MgPSBfY29udGV4dDIudDA7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE3O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxNTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MyA9IF9jb250ZXh0MltcImNhdGNoXCJdKDApO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIGlmICghKCFkb2MgfHwgZG9jLnZlcnNpb24gIT09IDEgfHwgIWRvYy5zaWduaW5nS2V5IHx8ICFkb2MubWFuYWdlbWVudEtleSB8fCAhZG9jLmFzeW1FbmNyeXB0aW9uS2V5KSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKGlwZnMpIGlwZnMucGluLnJtKGlwZnNIYXNoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtdXBvcnQgZGlkJyk7XG5cbiAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgZG9jKTtcblxuICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgbnVsbCwgW1swLCAxNV1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2ZldGNoTXVQb3J0RG9jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGh0dHBGZXRjaChfeDUpIHtcbiAgcmV0dXJuIF9odHRwRmV0Y2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2h0dHBGZXRjaCgpIHtcbiAgX2h0dHBGZXRjaCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgLyojX19QVVJFX18qL1xuICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoY2lkKSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9ub2RlRmV0Y2hbXCJkZWZhdWx0XCJdKShJTkZVUkEgKyBjaWQpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQzLnNlbnQuanNvbigpKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzKTtcbiAgfSkpO1xuICByZXR1cm4gX2h0dHBGZXRjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiB3cmFwRG9jdW1lbnQoZGlkLCBtdXBvcnREb2N1bWVudCkge1xuICB2YXIgZG9jID0ge1xuICAgIFwiQGNvbnRleHRcIjogXCJodHRwczovL3czaWQub3JnL2RpZC92MVwiLFxuICAgIFwiaWRcIjogZGlkLFxuICAgIFwicHVibGljS2V5XCI6IFt7XG4gICAgICBcImlkXCI6IGRpZCArIFwiI3NpZ25pbmdLZXlcIixcbiAgICAgIFwidHlwZVwiOiBcIlNlY3AyNTZrMVZlcmlmaWNhdGlvbktleTIwMThcIixcbiAgICAgIFwib3duZXJcIjogZGlkLFxuICAgICAgXCJwdWJsaWNLZXlIZXhcIjogbXVwb3J0RG9jdW1lbnQuc2lnbmluZ0tleVxuICAgIH0sIHtcbiAgICAgIFwiaWRcIjogZGlkICsgXCIjbWFuYWdlbWVudEtleVwiLFxuICAgICAgXCJ0eXBlXCI6IFwiU2VjcDI1NmsxVmVyaWZpY2F0aW9uS2V5MjAxOFwiLFxuICAgICAgXCJvd25lclwiOiBkaWRcbiAgICB9LCB7XG4gICAgICBcImlkXCI6IGRpZCArIFwiI2VuY3J5cHRpb25LZXlcIixcbiAgICAgIFwidHlwZVwiOiBcIkN1cnZlMjU1MTlFbmNyeXB0aW9uUHVibGljS2V5XCIsXG4gICAgICBcIm93bmVyXCI6IGRpZCxcbiAgICAgIFwicHVibGljS2V5QmFzZTY0XCI6IG11cG9ydERvY3VtZW50LmFzeW1FbmNyeXB0aW9uS2V5XG4gICAgfV0sXG4gICAgXCJhdXRoZW50aWNhdGlvblwiOiBbe1xuICAgICAgXCJ0eXBlXCI6IFwiU2VjcDI1NmsxU2lnbmF0dXJlQXV0aGVudGljYXRpb24yMDE4XCIsXG4gICAgICBcInB1YmxpY0tleVwiOiBkaWQgKyBcIiNzaWduaW5nS2V5XCJcbiAgICB9XSxcbiAgICBcIm11cG9ydERhdGFcIjoge31cbiAgfTtcblxuICBpZiAobXVwb3J0RG9jdW1lbnQubWFuYWdlbWVudEtleS5sZW5ndGggPT09IDQyKSB7XG4gICAgZG9jLnB1YmxpY0tleVsxXS5ldGhlcmV1bUFkZHJlc3MgPSBtdXBvcnREb2N1bWVudC5tYW5hZ2VtZW50S2V5O1xuICB9IGVsc2Uge1xuICAgIGRvYy5wdWJsaWNLZXlbMV0ucHVibGljS2V5SGV4ID0gbXVwb3J0RG9jdW1lbnQubWFuYWdlbWVudEtleTtcbiAgfVxuXG4gIGlmIChtdXBvcnREb2N1bWVudC5wdWJsaWNQcm9maWxlKSBkb2MudXBvcnRQcm9maWxlID0gbXVwb3J0RG9jdW1lbnQucHVibGljUHJvZmlsZTtcbiAgaWYgKG11cG9ydERvY3VtZW50LnN5bUVuY3J5cHRlZERhdGEpIGRvYy5tdXBvcnREYXRhLnN5bUVuY3J5cHRlZERhdGEgPSBtdXBvcnREb2N1bWVudC5zeW1FbmNyeXB0ZWREYXRhO1xuICBpZiAobXVwb3J0RG9jdW1lbnQucmVjb3ZlcnlOZXR3b3JrKSBkb2MubXVwb3J0RGF0YS5yZWNvdmVyeU5ldHdvcmsgPSBtdXBvcnREb2N1bWVudC5yZWNvdmVyeU5ldHdvcms7XG4gIHJldHVybiBkb2M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVnaXN0ZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDbGllbnRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2xpZW50RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2xpZW50RXJyb3IocmVzcG9uc2UsIHJlcXVlc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBDbGllbnRFcnJvci5leHRyYWN0TWVzc2FnZShyZXNwb25zZSkgKyBcIjogXCIgKyBKU09OLnN0cmluZ2lmeSh7IHJlc3BvbnNlOiByZXNwb25zZSwgcmVxdWVzdDogcmVxdWVzdCB9KTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgLy8gdGhpcyBpcyBuZWVkZWQgYXMgU2FmYXJpIGRvZXNuJ3Qgc3VwcG9ydCAuY2FwdHVyZVN0YWNrVHJhY2VcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lICovXG4gICAgICAgIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBDbGllbnRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDbGllbnRFcnJvci5leHRyYWN0TWVzc2FnZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmVycm9yc1swXS5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJHcmFwaFFMIEVycm9yIChDb2RlOiBcIiArIHJlc3BvbnNlLnN0YXR1cyArIFwiKVwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2xpZW50RXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLkNsaWVudEVycm9yID0gQ2xpZW50RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCIoZnVuY3Rpb24oc2VsZikge1xuXG4gIGlmIChzZWxmLmZldGNoKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIHNlbGYsXG4gICAgaXRlcmFibGU6ICdTeW1ib2wnIGluIHNlbGYgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gICAgYmxvYjogJ0ZpbGVSZWFkZXInIGluIHNlbGYgJiYgJ0Jsb2InIGluIHNlbGYgJiYgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KSgpLFxuICAgIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIHNlbGYsXG4gICAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gc2VsZlxuICB9O1xuXG4gIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gICAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gICAgXTtcblxuICAgIHZhciBpc0RhdGFWaWV3ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iailcbiAgICB9O1xuXG4gICAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID0gQXJyYXlCdWZmZXIuaXNWaWV3IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB2aWV3Q2xhc3Nlcy5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSA+IC0xXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLlxcXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKVxuICAgIH1cbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLy8gQnVpbGQgYSBkZXN0cnVjdGl2ZSBpdGVyYXRvciBmb3IgdGhlIHZhbHVlIGxpc3RcbiAgZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcmF0b3JcbiAgfVxuXG4gIGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICAgIHRoaXMubWFwID0ge307XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdO1xuICAgIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSsnLCcrdmFsdWUgOiB2YWx1ZTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsgaXRlbXMucHVzaChuYW1lKTsgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkgeyBpdGVtcy5wdXNoKHZhbHVlKTsgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsgaXRlbXMucHVzaChbbmFtZSwgdmFsdWVdKTsgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgICAgfTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICAgIGlmIChidWYuc2xpY2UpIHtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKTtcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcik7XG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIEJvZHlJbml0IHR5cGUnKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKTtcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gY29uc3VtZWQodGhpcykgfHwgUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ibG9iKCkudGhlbihyZWFkQmxvYkFzQXJyYXlCdWZmZXIpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKTtcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXTtcblxuICBmdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gICAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICByZXR1cm4gKG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xKSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keTtcblxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmw7XG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHM7XG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kO1xuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZTtcbiAgICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0O1xuICAgICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KTtcbiAgICB9XG5cbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdvbWl0JztcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKTtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGw7XG4gICAgdGhpcy5yZWZlcnJlciA9IG51bGw7XG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpO1xuICB9XG5cbiAgUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywgeyBib2R5OiB0aGlzLl9ib2R5SW5pdCB9KVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBib2R5LnRyaW0oKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpO1xuICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJz0nKS5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZm9ybVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIHtcbiAgICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgLy8gUmVwbGFjZSBpbnN0YW5jZXMgb2YgXFxyXFxuIGFuZCBcXG4gZm9sbG93ZWQgYnkgYXQgbGVhc3Qgb25lIHNwYWNlIG9yIGhvcml6b250YWwgdGFiIHdpdGggYSBzcGFjZVxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yXG4gICAgdmFyIHByZVByb2Nlc3NlZEhlYWRlcnMgPSByYXdIZWFkZXJzLnJlcGxhY2UoL1xccj9cXG5bXFx0IF0rL2csICcgJyk7XG4gICAgcHJlUHJvY2Vzc2VkSGVhZGVycy5zcGxpdCgvXFxyP1xcbi8pLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpO1xuICAgICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpO1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpO1xuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG5cbiAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKTtcblxuICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9ICdkZWZhdWx0JztcbiAgICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzID09PSB1bmRlZmluZWQgPyAyMDAgOiBvcHRpb25zLnN0YXR1cztcbiAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9ICdzdGF0dXNUZXh0JyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXNUZXh0IDogJ09LJztcbiAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpO1xuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJyc7XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpO1xuICB9XG5cbiAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSk7XG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSlcbiAgfTtcblxuICBSZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAwLCBzdGF0dXNUZXh0OiAnJ30pO1xuICAgIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InO1xuICAgIHJldHVybiByZXNwb25zZVxuICB9O1xuXG4gIHZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XTtcblxuICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxuICB9O1xuXG4gIHNlbGYuSGVhZGVycyA9IEhlYWRlcnM7XG4gIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZTtcblxuICBzZWxmLmZldGNoID0gZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KTtcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KTtcbiAgICB9KVxuICB9O1xuICBzZWxmLmZldGNoLnBvbHlmaWxsID0gdHJ1ZTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzKTtcbiIsIi8qIGVzbGludCBxdW90ZS1wcm9wczogb2ZmICovXG4vKiBlc2xpbnQga2V5LXNwYWNpbmc6IG9mZiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMubmFtZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgJ2lkZW50aXR5JzogICAweDAsXG4gICdzaGExJzogICAgICAgMHgxMSxcbiAgJ3NoYTItMjU2JzogICAweDEyLFxuICAnc2hhMi01MTInOiAgIDB4MTMsXG4gICdkYmwtc2hhMi0yNTYnOiAweDU2LFxuICAnc2hhMy0yMjQnOiAgIDB4MTcsXG4gICdzaGEzLTI1Nic6ICAgMHgxNixcbiAgJ3NoYTMtMzg0JzogICAweDE1LFxuICAnc2hhMy01MTInOiAgIDB4MTQsXG4gICdzaGFrZS0xMjgnOiAgMHgxOCxcbiAgJ3NoYWtlLTI1Nic6ICAweDE5LFxuICAna2VjY2FrLTIyNCc6IDB4MUEsXG4gICdrZWNjYWstMjU2JzogMHgxQixcbiAgJ2tlY2Nhay0zODQnOiAweDFDLFxuICAna2VjY2FrLTUxMic6IDB4MUQsXG4gICdtdXJtdXIzLTEyOCc6IDB4MjIsXG4gICdtdXJtdXIzLTMyJzogIDB4MjMsXG4gICdibGFrZTJiLTgnOiAgIDB4YjIwMSxcbiAgJ2JsYWtlMmItMTYnOiAgMHhiMjAyLFxuICAnYmxha2UyYi0yNCc6ICAweGIyMDMsXG4gICdibGFrZTJiLTMyJzogIDB4YjIwNCxcbiAgJ2JsYWtlMmItNDAnOiAgMHhiMjA1LFxuICAnYmxha2UyYi00OCc6ICAweGIyMDYsXG4gICdibGFrZTJiLTU2JzogIDB4YjIwNyxcbiAgJ2JsYWtlMmItNjQnOiAgMHhiMjA4LFxuICAnYmxha2UyYi03Mic6ICAweGIyMDksXG4gICdibGFrZTJiLTgwJzogIDB4YjIwYSxcbiAgJ2JsYWtlMmItODgnOiAgMHhiMjBiLFxuICAnYmxha2UyYi05Nic6ICAweGIyMGMsXG4gICdibGFrZTJiLTEwNCc6IDB4YjIwZCxcbiAgJ2JsYWtlMmItMTEyJzogMHhiMjBlLFxuICAnYmxha2UyYi0xMjAnOiAweGIyMGYsXG4gICdibGFrZTJiLTEyOCc6IDB4YjIxMCxcbiAgJ2JsYWtlMmItMTM2JzogMHhiMjExLFxuICAnYmxha2UyYi0xNDQnOiAweGIyMTIsXG4gICdibGFrZTJiLTE1Mic6IDB4YjIxMyxcbiAgJ2JsYWtlMmItMTYwJzogMHhiMjE0LFxuICAnYmxha2UyYi0xNjgnOiAweGIyMTUsXG4gICdibGFrZTJiLTE3Nic6IDB4YjIxNixcbiAgJ2JsYWtlMmItMTg0JzogMHhiMjE3LFxuICAnYmxha2UyYi0xOTInOiAweGIyMTgsXG4gICdibGFrZTJiLTIwMCc6IDB4YjIxOSxcbiAgJ2JsYWtlMmItMjA4JzogMHhiMjFhLFxuICAnYmxha2UyYi0yMTYnOiAweGIyMWIsXG4gICdibGFrZTJiLTIyNCc6IDB4YjIxYyxcbiAgJ2JsYWtlMmItMjMyJzogMHhiMjFkLFxuICAnYmxha2UyYi0yNDAnOiAweGIyMWUsXG4gICdibGFrZTJiLTI0OCc6IDB4YjIxZixcbiAgJ2JsYWtlMmItMjU2JzogMHhiMjIwLFxuICAnYmxha2UyYi0yNjQnOiAweGIyMjEsXG4gICdibGFrZTJiLTI3Mic6IDB4YjIyMixcbiAgJ2JsYWtlMmItMjgwJzogMHhiMjIzLFxuICAnYmxha2UyYi0yODgnOiAweGIyMjQsXG4gICdibGFrZTJiLTI5Nic6IDB4YjIyNSxcbiAgJ2JsYWtlMmItMzA0JzogMHhiMjI2LFxuICAnYmxha2UyYi0zMTInOiAweGIyMjcsXG4gICdibGFrZTJiLTMyMCc6IDB4YjIyOCxcbiAgJ2JsYWtlMmItMzI4JzogMHhiMjI5LFxuICAnYmxha2UyYi0zMzYnOiAweGIyMmEsXG4gICdibGFrZTJiLTM0NCc6IDB4YjIyYixcbiAgJ2JsYWtlMmItMzUyJzogMHhiMjJjLFxuICAnYmxha2UyYi0zNjAnOiAweGIyMmQsXG4gICdibGFrZTJiLTM2OCc6IDB4YjIyZSxcbiAgJ2JsYWtlMmItMzc2JzogMHhiMjJmLFxuICAnYmxha2UyYi0zODQnOiAweGIyMzAsXG4gICdibGFrZTJiLTM5Mic6IDB4YjIzMSxcbiAgJ2JsYWtlMmItNDAwJzogMHhiMjMyLFxuICAnYmxha2UyYi00MDgnOiAweGIyMzMsXG4gICdibGFrZTJiLTQxNic6IDB4YjIzNCxcbiAgJ2JsYWtlMmItNDI0JzogMHhiMjM1LFxuICAnYmxha2UyYi00MzInOiAweGIyMzYsXG4gICdibGFrZTJiLTQ0MCc6IDB4YjIzNyxcbiAgJ2JsYWtlMmItNDQ4JzogMHhiMjM4LFxuICAnYmxha2UyYi00NTYnOiAweGIyMzksXG4gICdibGFrZTJiLTQ2NCc6IDB4YjIzYSxcbiAgJ2JsYWtlMmItNDcyJzogMHhiMjNiLFxuICAnYmxha2UyYi00ODAnOiAweGIyM2MsXG4gICdibGFrZTJiLTQ4OCc6IDB4YjIzZCxcbiAgJ2JsYWtlMmItNDk2JzogMHhiMjNlLFxuICAnYmxha2UyYi01MDQnOiAweGIyM2YsXG4gICdibGFrZTJiLTUxMic6IDB4YjI0MCxcbiAgJ2JsYWtlMnMtOCc6ICAgMHhiMjQxLFxuICAnYmxha2Uycy0xNic6ICAweGIyNDIsXG4gICdibGFrZTJzLTI0JzogIDB4YjI0MyxcbiAgJ2JsYWtlMnMtMzInOiAgMHhiMjQ0LFxuICAnYmxha2Uycy00MCc6ICAweGIyNDUsXG4gICdibGFrZTJzLTQ4JzogIDB4YjI0NixcbiAgJ2JsYWtlMnMtNTYnOiAgMHhiMjQ3LFxuICAnYmxha2Uycy02NCc6ICAweGIyNDgsXG4gICdibGFrZTJzLTcyJzogIDB4YjI0OSxcbiAgJ2JsYWtlMnMtODAnOiAgMHhiMjRhLFxuICAnYmxha2Uycy04OCc6ICAweGIyNGIsXG4gICdibGFrZTJzLTk2JzogIDB4YjI0YyxcbiAgJ2JsYWtlMnMtMTA0JzogMHhiMjRkLFxuICAnYmxha2Uycy0xMTInOiAweGIyNGUsXG4gICdibGFrZTJzLTEyMCc6IDB4YjI0ZixcbiAgJ2JsYWtlMnMtMTI4JzogMHhiMjUwLFxuICAnYmxha2Uycy0xMzYnOiAweGIyNTEsXG4gICdibGFrZTJzLTE0NCc6IDB4YjI1MixcbiAgJ2JsYWtlMnMtMTUyJzogMHhiMjUzLFxuICAnYmxha2Uycy0xNjAnOiAweGIyNTQsXG4gICdibGFrZTJzLTE2OCc6IDB4YjI1NSxcbiAgJ2JsYWtlMnMtMTc2JzogMHhiMjU2LFxuICAnYmxha2Uycy0xODQnOiAweGIyNTcsXG4gICdibGFrZTJzLTE5Mic6IDB4YjI1OCxcbiAgJ2JsYWtlMnMtMjAwJzogMHhiMjU5LFxuICAnYmxha2Uycy0yMDgnOiAweGIyNWEsXG4gICdibGFrZTJzLTIxNic6IDB4YjI1YixcbiAgJ2JsYWtlMnMtMjI0JzogMHhiMjVjLFxuICAnYmxha2Uycy0yMzInOiAweGIyNWQsXG4gICdibGFrZTJzLTI0MCc6IDB4YjI1ZSxcbiAgJ2JsYWtlMnMtMjQ4JzogMHhiMjVmLFxuICAnYmxha2Uycy0yNTYnOiAweGIyNjAsXG4gICdTa2VpbjI1Ni04JzogMHhiMzAxLFxuICAnU2tlaW4yNTYtMTYnOiAweGIzMDIsXG4gICdTa2VpbjI1Ni0yNCc6IDB4YjMwMyxcbiAgJ1NrZWluMjU2LTMyJzogMHhiMzA0LFxuICAnU2tlaW4yNTYtNDAnOiAweGIzMDUsXG4gICdTa2VpbjI1Ni00OCc6IDB4YjMwNixcbiAgJ1NrZWluMjU2LTU2JzogMHhiMzA3LFxuICAnU2tlaW4yNTYtNjQnOiAweGIzMDgsXG4gICdTa2VpbjI1Ni03Mic6IDB4YjMwOSxcbiAgJ1NrZWluMjU2LTgwJzogMHhiMzBhLFxuICAnU2tlaW4yNTYtODgnOiAweGIzMGIsXG4gICdTa2VpbjI1Ni05Nic6IDB4YjMwYyxcbiAgJ1NrZWluMjU2LTEwNCc6IDB4YjMwZCxcbiAgJ1NrZWluMjU2LTExMic6IDB4YjMwZSxcbiAgJ1NrZWluMjU2LTEyMCc6IDB4YjMwZixcbiAgJ1NrZWluMjU2LTEyOCc6IDB4YjMxMCxcbiAgJ1NrZWluMjU2LTEzNic6IDB4YjMxMSxcbiAgJ1NrZWluMjU2LTE0NCc6IDB4YjMxMixcbiAgJ1NrZWluMjU2LTE1Mic6IDB4YjMxMyxcbiAgJ1NrZWluMjU2LTE2MCc6IDB4YjMxNCxcbiAgJ1NrZWluMjU2LTE2OCc6IDB4YjMxNSxcbiAgJ1NrZWluMjU2LTE3Nic6IDB4YjMxNixcbiAgJ1NrZWluMjU2LTE4NCc6IDB4YjMxNyxcbiAgJ1NrZWluMjU2LTE5Mic6IDB4YjMxOCxcbiAgJ1NrZWluMjU2LTIwMCc6IDB4YjMxOSxcbiAgJ1NrZWluMjU2LTIwOCc6IDB4YjMxYSxcbiAgJ1NrZWluMjU2LTIxNic6IDB4YjMxYixcbiAgJ1NrZWluMjU2LTIyNCc6IDB4YjMxYyxcbiAgJ1NrZWluMjU2LTIzMic6IDB4YjMxZCxcbiAgJ1NrZWluMjU2LTI0MCc6IDB4YjMxZSxcbiAgJ1NrZWluMjU2LTI0OCc6IDB4YjMxZixcbiAgJ1NrZWluMjU2LTI1Nic6IDB4YjMyMCxcbiAgJ1NrZWluNTEyLTgnOiAweGIzMjEsXG4gICdTa2VpbjUxMi0xNic6IDB4YjMyMixcbiAgJ1NrZWluNTEyLTI0JzogMHhiMzIzLFxuICAnU2tlaW41MTItMzInOiAweGIzMjQsXG4gICdTa2VpbjUxMi00MCc6IDB4YjMyNSxcbiAgJ1NrZWluNTEyLTQ4JzogMHhiMzI2LFxuICAnU2tlaW41MTItNTYnOiAweGIzMjcsXG4gICdTa2VpbjUxMi02NCc6IDB4YjMyOCxcbiAgJ1NrZWluNTEyLTcyJzogMHhiMzI5LFxuICAnU2tlaW41MTItODAnOiAweGIzMmEsXG4gICdTa2VpbjUxMi04OCc6IDB4YjMyYixcbiAgJ1NrZWluNTEyLTk2JzogMHhiMzJjLFxuICAnU2tlaW41MTItMTA0JzogMHhiMzJkLFxuICAnU2tlaW41MTItMTEyJzogMHhiMzJlLFxuICAnU2tlaW41MTItMTIwJzogMHhiMzJmLFxuICAnU2tlaW41MTItMTI4JzogMHhiMzMwLFxuICAnU2tlaW41MTItMTM2JzogMHhiMzMxLFxuICAnU2tlaW41MTItMTQ0JzogMHhiMzMyLFxuICAnU2tlaW41MTItMTUyJzogMHhiMzMzLFxuICAnU2tlaW41MTItMTYwJzogMHhiMzM0LFxuICAnU2tlaW41MTItMTY4JzogMHhiMzM1LFxuICAnU2tlaW41MTItMTc2JzogMHhiMzM2LFxuICAnU2tlaW41MTItMTg0JzogMHhiMzM3LFxuICAnU2tlaW41MTItMTkyJzogMHhiMzM4LFxuICAnU2tlaW41MTItMjAwJzogMHhiMzM5LFxuICAnU2tlaW41MTItMjA4JzogMHhiMzNhLFxuICAnU2tlaW41MTItMjE2JzogMHhiMzNiLFxuICAnU2tlaW41MTItMjI0JzogMHhiMzNjLFxuICAnU2tlaW41MTItMjMyJzogMHhiMzNkLFxuICAnU2tlaW41MTItMjQwJzogMHhiMzNlLFxuICAnU2tlaW41MTItMjQ4JzogMHhiMzNmLFxuICAnU2tlaW41MTItMjU2JzogMHhiMzQwLFxuICAnU2tlaW41MTItMjY0JzogMHhiMzQxLFxuICAnU2tlaW41MTItMjcyJzogMHhiMzQyLFxuICAnU2tlaW41MTItMjgwJzogMHhiMzQzLFxuICAnU2tlaW41MTItMjg4JzogMHhiMzQ0LFxuICAnU2tlaW41MTItMjk2JzogMHhiMzQ1LFxuICAnU2tlaW41MTItMzA0JzogMHhiMzQ2LFxuICAnU2tlaW41MTItMzEyJzogMHhiMzQ3LFxuICAnU2tlaW41MTItMzIwJzogMHhiMzQ4LFxuICAnU2tlaW41MTItMzI4JzogMHhiMzQ5LFxuICAnU2tlaW41MTItMzM2JzogMHhiMzRhLFxuICAnU2tlaW41MTItMzQ0JzogMHhiMzRiLFxuICAnU2tlaW41MTItMzUyJzogMHhiMzRjLFxuICAnU2tlaW41MTItMzYwJzogMHhiMzRkLFxuICAnU2tlaW41MTItMzY4JzogMHhiMzRlLFxuICAnU2tlaW41MTItMzc2JzogMHhiMzRmLFxuICAnU2tlaW41MTItMzg0JzogMHhiMzUwLFxuICAnU2tlaW41MTItMzkyJzogMHhiMzUxLFxuICAnU2tlaW41MTItNDAwJzogMHhiMzUyLFxuICAnU2tlaW41MTItNDA4JzogMHhiMzUzLFxuICAnU2tlaW41MTItNDE2JzogMHhiMzU0LFxuICAnU2tlaW41MTItNDI0JzogMHhiMzU1LFxuICAnU2tlaW41MTItNDMyJzogMHhiMzU2LFxuICAnU2tlaW41MTItNDQwJzogMHhiMzU3LFxuICAnU2tlaW41MTItNDQ4JzogMHhiMzU4LFxuICAnU2tlaW41MTItNDU2JzogMHhiMzU5LFxuICAnU2tlaW41MTItNDY0JzogMHhiMzVhLFxuICAnU2tlaW41MTItNDcyJzogMHhiMzViLFxuICAnU2tlaW41MTItNDgwJzogMHhiMzVjLFxuICAnU2tlaW41MTItNDg4JzogMHhiMzVkLFxuICAnU2tlaW41MTItNDk2JzogMHhiMzVlLFxuICAnU2tlaW41MTItNTA0JzogMHhiMzVmLFxuICAnU2tlaW41MTItNTEyJzogMHhiMzYwLFxuICAnU2tlaW4xMDI0LTgnOiAweGIzNjEsXG4gICdTa2VpbjEwMjQtMTYnOiAweGIzNjIsXG4gICdTa2VpbjEwMjQtMjQnOiAweGIzNjMsXG4gICdTa2VpbjEwMjQtMzInOiAweGIzNjQsXG4gICdTa2VpbjEwMjQtNDAnOiAweGIzNjUsXG4gICdTa2VpbjEwMjQtNDgnOiAweGIzNjYsXG4gICdTa2VpbjEwMjQtNTYnOiAweGIzNjcsXG4gICdTa2VpbjEwMjQtNjQnOiAweGIzNjgsXG4gICdTa2VpbjEwMjQtNzInOiAweGIzNjksXG4gICdTa2VpbjEwMjQtODAnOiAweGIzNmEsXG4gICdTa2VpbjEwMjQtODgnOiAweGIzNmIsXG4gICdTa2VpbjEwMjQtOTYnOiAweGIzNmMsXG4gICdTa2VpbjEwMjQtMTA0JzogMHhiMzZkLFxuICAnU2tlaW4xMDI0LTExMic6IDB4YjM2ZSxcbiAgJ1NrZWluMTAyNC0xMjAnOiAweGIzNmYsXG4gICdTa2VpbjEwMjQtMTI4JzogMHhiMzcwLFxuICAnU2tlaW4xMDI0LTEzNic6IDB4YjM3MSxcbiAgJ1NrZWluMTAyNC0xNDQnOiAweGIzNzIsXG4gICdTa2VpbjEwMjQtMTUyJzogMHhiMzczLFxuICAnU2tlaW4xMDI0LTE2MCc6IDB4YjM3NCxcbiAgJ1NrZWluMTAyNC0xNjgnOiAweGIzNzUsXG4gICdTa2VpbjEwMjQtMTc2JzogMHhiMzc2LFxuICAnU2tlaW4xMDI0LTE4NCc6IDB4YjM3NyxcbiAgJ1NrZWluMTAyNC0xOTInOiAweGIzNzgsXG4gICdTa2VpbjEwMjQtMjAwJzogMHhiMzc5LFxuICAnU2tlaW4xMDI0LTIwOCc6IDB4YjM3YSxcbiAgJ1NrZWluMTAyNC0yMTYnOiAweGIzN2IsXG4gICdTa2VpbjEwMjQtMjI0JzogMHhiMzdjLFxuICAnU2tlaW4xMDI0LTIzMic6IDB4YjM3ZCxcbiAgJ1NrZWluMTAyNC0yNDAnOiAweGIzN2UsXG4gICdTa2VpbjEwMjQtMjQ4JzogMHhiMzdmLFxuICAnU2tlaW4xMDI0LTI1Nic6IDB4YjM4MCxcbiAgJ1NrZWluMTAyNC0yNjQnOiAweGIzODEsXG4gICdTa2VpbjEwMjQtMjcyJzogMHhiMzgyLFxuICAnU2tlaW4xMDI0LTI4MCc6IDB4YjM4MyxcbiAgJ1NrZWluMTAyNC0yODgnOiAweGIzODQsXG4gICdTa2VpbjEwMjQtMjk2JzogMHhiMzg1LFxuICAnU2tlaW4xMDI0LTMwNCc6IDB4YjM4NixcbiAgJ1NrZWluMTAyNC0zMTInOiAweGIzODcsXG4gICdTa2VpbjEwMjQtMzIwJzogMHhiMzg4LFxuICAnU2tlaW4xMDI0LTMyOCc6IDB4YjM4OSxcbiAgJ1NrZWluMTAyNC0zMzYnOiAweGIzOGEsXG4gICdTa2VpbjEwMjQtMzQ0JzogMHhiMzhiLFxuICAnU2tlaW4xMDI0LTM1Mic6IDB4YjM4YyxcbiAgJ1NrZWluMTAyNC0zNjAnOiAweGIzOGQsXG4gICdTa2VpbjEwMjQtMzY4JzogMHhiMzhlLFxuICAnU2tlaW4xMDI0LTM3Nic6IDB4YjM4ZixcbiAgJ1NrZWluMTAyNC0zODQnOiAweGIzOTAsXG4gICdTa2VpbjEwMjQtMzkyJzogMHhiMzkxLFxuICAnU2tlaW4xMDI0LTQwMCc6IDB4YjM5MixcbiAgJ1NrZWluMTAyNC00MDgnOiAweGIzOTMsXG4gICdTa2VpbjEwMjQtNDE2JzogMHhiMzk0LFxuICAnU2tlaW4xMDI0LTQyNCc6IDB4YjM5NSxcbiAgJ1NrZWluMTAyNC00MzInOiAweGIzOTYsXG4gICdTa2VpbjEwMjQtNDQwJzogMHhiMzk3LFxuICAnU2tlaW4xMDI0LTQ0OCc6IDB4YjM5OCxcbiAgJ1NrZWluMTAyNC00NTYnOiAweGIzOTksXG4gICdTa2VpbjEwMjQtNDY0JzogMHhiMzlhLFxuICAnU2tlaW4xMDI0LTQ3Mic6IDB4YjM5YixcbiAgJ1NrZWluMTAyNC00ODAnOiAweGIzOWMsXG4gICdTa2VpbjEwMjQtNDg4JzogMHhiMzlkLFxuICAnU2tlaW4xMDI0LTQ5Nic6IDB4YjM5ZSxcbiAgJ1NrZWluMTAyNC01MDQnOiAweGIzOWYsXG4gICdTa2VpbjEwMjQtNTEyJzogMHhiM2EwLFxuICAnU2tlaW4xMDI0LTUyMCc6IDB4YjNhMSxcbiAgJ1NrZWluMTAyNC01MjgnOiAweGIzYTIsXG4gICdTa2VpbjEwMjQtNTM2JzogMHhiM2EzLFxuICAnU2tlaW4xMDI0LTU0NCc6IDB4YjNhNCxcbiAgJ1NrZWluMTAyNC01NTInOiAweGIzYTUsXG4gICdTa2VpbjEwMjQtNTYwJzogMHhiM2E2LFxuICAnU2tlaW4xMDI0LTU2OCc6IDB4YjNhNyxcbiAgJ1NrZWluMTAyNC01NzYnOiAweGIzYTgsXG4gICdTa2VpbjEwMjQtNTg0JzogMHhiM2E5LFxuICAnU2tlaW4xMDI0LTU5Mic6IDB4YjNhYSxcbiAgJ1NrZWluMTAyNC02MDAnOiAweGIzYWIsXG4gICdTa2VpbjEwMjQtNjA4JzogMHhiM2FjLFxuICAnU2tlaW4xMDI0LTYxNic6IDB4YjNhZCxcbiAgJ1NrZWluMTAyNC02MjQnOiAweGIzYWUsXG4gICdTa2VpbjEwMjQtNjMyJzogMHhiM2FmLFxuICAnU2tlaW4xMDI0LTY0MCc6IDB4YjNiMCxcbiAgJ1NrZWluMTAyNC02NDgnOiAweGIzYjEsXG4gICdTa2VpbjEwMjQtNjU2JzogMHhiM2IyLFxuICAnU2tlaW4xMDI0LTY2NCc6IDB4YjNiMyxcbiAgJ1NrZWluMTAyNC02NzInOiAweGIzYjQsXG4gICdTa2VpbjEwMjQtNjgwJzogMHhiM2I1LFxuICAnU2tlaW4xMDI0LTY4OCc6IDB4YjNiNixcbiAgJ1NrZWluMTAyNC02OTYnOiAweGIzYjcsXG4gICdTa2VpbjEwMjQtNzA0JzogMHhiM2I4LFxuICAnU2tlaW4xMDI0LTcxMic6IDB4YjNiOSxcbiAgJ1NrZWluMTAyNC03MjAnOiAweGIzYmEsXG4gICdTa2VpbjEwMjQtNzI4JzogMHhiM2JiLFxuICAnU2tlaW4xMDI0LTczNic6IDB4YjNiYyxcbiAgJ1NrZWluMTAyNC03NDQnOiAweGIzYmQsXG4gICdTa2VpbjEwMjQtNzUyJzogMHhiM2JlLFxuICAnU2tlaW4xMDI0LTc2MCc6IDB4YjNiZixcbiAgJ1NrZWluMTAyNC03NjgnOiAweGIzYzAsXG4gICdTa2VpbjEwMjQtNzc2JzogMHhiM2MxLFxuICAnU2tlaW4xMDI0LTc4NCc6IDB4YjNjMixcbiAgJ1NrZWluMTAyNC03OTInOiAweGIzYzMsXG4gICdTa2VpbjEwMjQtODAwJzogMHhiM2M0LFxuICAnU2tlaW4xMDI0LTgwOCc6IDB4YjNjNSxcbiAgJ1NrZWluMTAyNC04MTYnOiAweGIzYzYsXG4gICdTa2VpbjEwMjQtODI0JzogMHhiM2M3LFxuICAnU2tlaW4xMDI0LTgzMic6IDB4YjNjOCxcbiAgJ1NrZWluMTAyNC04NDAnOiAweGIzYzksXG4gICdTa2VpbjEwMjQtODQ4JzogMHhiM2NhLFxuICAnU2tlaW4xMDI0LTg1Nic6IDB4YjNjYixcbiAgJ1NrZWluMTAyNC04NjQnOiAweGIzY2MsXG4gICdTa2VpbjEwMjQtODcyJzogMHhiM2NkLFxuICAnU2tlaW4xMDI0LTg4MCc6IDB4YjNjZSxcbiAgJ1NrZWluMTAyNC04ODgnOiAweGIzY2YsXG4gICdTa2VpbjEwMjQtODk2JzogMHhiM2QwLFxuICAnU2tlaW4xMDI0LTkwNCc6IDB4YjNkMSxcbiAgJ1NrZWluMTAyNC05MTInOiAweGIzZDIsXG4gICdTa2VpbjEwMjQtOTIwJzogMHhiM2QzLFxuICAnU2tlaW4xMDI0LTkyOCc6IDB4YjNkNCxcbiAgJ1NrZWluMTAyNC05MzYnOiAweGIzZDUsXG4gICdTa2VpbjEwMjQtOTQ0JzogMHhiM2Q2LFxuICAnU2tlaW4xMDI0LTk1Mic6IDB4YjNkNyxcbiAgJ1NrZWluMTAyNC05NjAnOiAweGIzZDgsXG4gICdTa2VpbjEwMjQtOTY4JzogMHhiM2Q5LFxuICAnU2tlaW4xMDI0LTk3Nic6IDB4YjNkYSxcbiAgJ1NrZWluMTAyNC05ODQnOiAweGIzZGIsXG4gICdTa2VpbjEwMjQtOTkyJzogMHhiM2RjLFxuICAnU2tlaW4xMDI0LTEwMDAnOiAweGIzZGQsXG4gICdTa2VpbjEwMjQtMTAwOCc6IDB4YjNkZSxcbiAgJ1NrZWluMTAyNC0xMDE2JzogMHhiM2RmLFxuICAnU2tlaW4xMDI0LTEwMjQnOiAweGIzZTBcbn0pXG5cbmV4cG9ydHMuY29kZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgMHgwOiAnaWRlbnRpdHknLFxuXG4gIC8vIHNoYSBmYW1pbHlcbiAgMHgxMTogJ3NoYTEnLFxuICAweDEyOiAnc2hhMi0yNTYnLFxuICAweDEzOiAnc2hhMi01MTInLFxuICAweDU2OiAnZGJsLXNoYTItMjU2JyxcbiAgMHgxNzogJ3NoYTMtMjI0JyxcbiAgMHgxNjogJ3NoYTMtMjU2JyxcbiAgMHgxNTogJ3NoYTMtMzg0JyxcbiAgMHgxNDogJ3NoYTMtNTEyJyxcbiAgMHgxODogJ3NoYWtlLTEyOCcsXG4gIDB4MTk6ICdzaGFrZS0yNTYnLFxuICAweDFBOiAna2VjY2FrLTIyNCcsXG4gIDB4MUI6ICdrZWNjYWstMjU2JyxcbiAgMHgxQzogJ2tlY2Nhay0zODQnLFxuICAweDFEOiAna2VjY2FrLTUxMicsXG5cbiAgMHgyMjogJ211cm11cjMtMTI4JyxcbiAgMHgyMzogJ211cm11cjMtMzInLFxuXG4gIC8vIGJsYWtlMlxuICAweGIyMDE6ICdibGFrZTJiLTgnLFxuICAweGIyMDI6ICdibGFrZTJiLTE2JyxcbiAgMHhiMjAzOiAnYmxha2UyYi0yNCcsXG4gIDB4YjIwNDogJ2JsYWtlMmItMzInLFxuICAweGIyMDU6ICdibGFrZTJiLTQwJyxcbiAgMHhiMjA2OiAnYmxha2UyYi00OCcsXG4gIDB4YjIwNzogJ2JsYWtlMmItNTYnLFxuICAweGIyMDg6ICdibGFrZTJiLTY0JyxcbiAgMHhiMjA5OiAnYmxha2UyYi03MicsXG4gIDB4YjIwYTogJ2JsYWtlMmItODAnLFxuICAweGIyMGI6ICdibGFrZTJiLTg4JyxcbiAgMHhiMjBjOiAnYmxha2UyYi05NicsXG4gIDB4YjIwZDogJ2JsYWtlMmItMTA0JyxcbiAgMHhiMjBlOiAnYmxha2UyYi0xMTInLFxuICAweGIyMGY6ICdibGFrZTJiLTEyMCcsXG4gIDB4YjIxMDogJ2JsYWtlMmItMTI4JyxcbiAgMHhiMjExOiAnYmxha2UyYi0xMzYnLFxuICAweGIyMTI6ICdibGFrZTJiLTE0NCcsXG4gIDB4YjIxMzogJ2JsYWtlMmItMTUyJyxcbiAgMHhiMjE0OiAnYmxha2UyYi0xNjAnLFxuICAweGIyMTU6ICdibGFrZTJiLTE2OCcsXG4gIDB4YjIxNjogJ2JsYWtlMmItMTc2JyxcbiAgMHhiMjE3OiAnYmxha2UyYi0xODQnLFxuICAweGIyMTg6ICdibGFrZTJiLTE5MicsXG4gIDB4YjIxOTogJ2JsYWtlMmItMjAwJyxcbiAgMHhiMjFhOiAnYmxha2UyYi0yMDgnLFxuICAweGIyMWI6ICdibGFrZTJiLTIxNicsXG4gIDB4YjIxYzogJ2JsYWtlMmItMjI0JyxcbiAgMHhiMjFkOiAnYmxha2UyYi0yMzInLFxuICAweGIyMWU6ICdibGFrZTJiLTI0MCcsXG4gIDB4YjIxZjogJ2JsYWtlMmItMjQ4JyxcbiAgMHhiMjIwOiAnYmxha2UyYi0yNTYnLFxuICAweGIyMjE6ICdibGFrZTJiLTI2NCcsXG4gIDB4YjIyMjogJ2JsYWtlMmItMjcyJyxcbiAgMHhiMjIzOiAnYmxha2UyYi0yODAnLFxuICAweGIyMjQ6ICdibGFrZTJiLTI4OCcsXG4gIDB4YjIyNTogJ2JsYWtlMmItMjk2JyxcbiAgMHhiMjI2OiAnYmxha2UyYi0zMDQnLFxuICAweGIyMjc6ICdibGFrZTJiLTMxMicsXG4gIDB4YjIyODogJ2JsYWtlMmItMzIwJyxcbiAgMHhiMjI5OiAnYmxha2UyYi0zMjgnLFxuICAweGIyMmE6ICdibGFrZTJiLTMzNicsXG4gIDB4YjIyYjogJ2JsYWtlMmItMzQ0JyxcbiAgMHhiMjJjOiAnYmxha2UyYi0zNTInLFxuICAweGIyMmQ6ICdibGFrZTJiLTM2MCcsXG4gIDB4YjIyZTogJ2JsYWtlMmItMzY4JyxcbiAgMHhiMjJmOiAnYmxha2UyYi0zNzYnLFxuICAweGIyMzA6ICdibGFrZTJiLTM4NCcsXG4gIDB4YjIzMTogJ2JsYWtlMmItMzkyJyxcbiAgMHhiMjMyOiAnYmxha2UyYi00MDAnLFxuICAweGIyMzM6ICdibGFrZTJiLTQwOCcsXG4gIDB4YjIzNDogJ2JsYWtlMmItNDE2JyxcbiAgMHhiMjM1OiAnYmxha2UyYi00MjQnLFxuICAweGIyMzY6ICdibGFrZTJiLTQzMicsXG4gIDB4YjIzNzogJ2JsYWtlMmItNDQwJyxcbiAgMHhiMjM4OiAnYmxha2UyYi00NDgnLFxuICAweGIyMzk6ICdibGFrZTJiLTQ1NicsXG4gIDB4YjIzYTogJ2JsYWtlMmItNDY0JyxcbiAgMHhiMjNiOiAnYmxha2UyYi00NzInLFxuICAweGIyM2M6ICdibGFrZTJiLTQ4MCcsXG4gIDB4YjIzZDogJ2JsYWtlMmItNDg4JyxcbiAgMHhiMjNlOiAnYmxha2UyYi00OTYnLFxuICAweGIyM2Y6ICdibGFrZTJiLTUwNCcsXG4gIDB4YjI0MDogJ2JsYWtlMmItNTEyJyxcbiAgMHhiMjQxOiAnYmxha2Uycy04JyxcbiAgMHhiMjQyOiAnYmxha2Uycy0xNicsXG4gIDB4YjI0MzogJ2JsYWtlMnMtMjQnLFxuICAweGIyNDQ6ICdibGFrZTJzLTMyJyxcbiAgMHhiMjQ1OiAnYmxha2Uycy00MCcsXG4gIDB4YjI0NjogJ2JsYWtlMnMtNDgnLFxuICAweGIyNDc6ICdibGFrZTJzLTU2JyxcbiAgMHhiMjQ4OiAnYmxha2Uycy02NCcsXG4gIDB4YjI0OTogJ2JsYWtlMnMtNzInLFxuICAweGIyNGE6ICdibGFrZTJzLTgwJyxcbiAgMHhiMjRiOiAnYmxha2Uycy04OCcsXG4gIDB4YjI0YzogJ2JsYWtlMnMtOTYnLFxuICAweGIyNGQ6ICdibGFrZTJzLTEwNCcsXG4gIDB4YjI0ZTogJ2JsYWtlMnMtMTEyJyxcbiAgMHhiMjRmOiAnYmxha2Uycy0xMjAnLFxuICAweGIyNTA6ICdibGFrZTJzLTEyOCcsXG4gIDB4YjI1MTogJ2JsYWtlMnMtMTM2JyxcbiAgMHhiMjUyOiAnYmxha2Uycy0xNDQnLFxuICAweGIyNTM6ICdibGFrZTJzLTE1MicsXG4gIDB4YjI1NDogJ2JsYWtlMnMtMTYwJyxcbiAgMHhiMjU1OiAnYmxha2Uycy0xNjgnLFxuICAweGIyNTY6ICdibGFrZTJzLTE3NicsXG4gIDB4YjI1NzogJ2JsYWtlMnMtMTg0JyxcbiAgMHhiMjU4OiAnYmxha2Uycy0xOTInLFxuICAweGIyNTk6ICdibGFrZTJzLTIwMCcsXG4gIDB4YjI1YTogJ2JsYWtlMnMtMjA4JyxcbiAgMHhiMjViOiAnYmxha2Uycy0yMTYnLFxuICAweGIyNWM6ICdibGFrZTJzLTIyNCcsXG4gIDB4YjI1ZDogJ2JsYWtlMnMtMjMyJyxcbiAgMHhiMjVlOiAnYmxha2Uycy0yNDAnLFxuICAweGIyNWY6ICdibGFrZTJzLTI0OCcsXG4gIDB4YjI2MDogJ2JsYWtlMnMtMjU2JyxcblxuICAvLyBza2VpblxuICAweGIzMDE6ICdTa2VpbjI1Ni04JyxcbiAgMHhiMzAyOiAnU2tlaW4yNTYtMTYnLFxuICAweGIzMDM6ICdTa2VpbjI1Ni0yNCcsXG4gIDB4YjMwNDogJ1NrZWluMjU2LTMyJyxcbiAgMHhiMzA1OiAnU2tlaW4yNTYtNDAnLFxuICAweGIzMDY6ICdTa2VpbjI1Ni00OCcsXG4gIDB4YjMwNzogJ1NrZWluMjU2LTU2JyxcbiAgMHhiMzA4OiAnU2tlaW4yNTYtNjQnLFxuICAweGIzMDk6ICdTa2VpbjI1Ni03MicsXG4gIDB4YjMwYTogJ1NrZWluMjU2LTgwJyxcbiAgMHhiMzBiOiAnU2tlaW4yNTYtODgnLFxuICAweGIzMGM6ICdTa2VpbjI1Ni05NicsXG4gIDB4YjMwZDogJ1NrZWluMjU2LTEwNCcsXG4gIDB4YjMwZTogJ1NrZWluMjU2LTExMicsXG4gIDB4YjMwZjogJ1NrZWluMjU2LTEyMCcsXG4gIDB4YjMxMDogJ1NrZWluMjU2LTEyOCcsXG4gIDB4YjMxMTogJ1NrZWluMjU2LTEzNicsXG4gIDB4YjMxMjogJ1NrZWluMjU2LTE0NCcsXG4gIDB4YjMxMzogJ1NrZWluMjU2LTE1MicsXG4gIDB4YjMxNDogJ1NrZWluMjU2LTE2MCcsXG4gIDB4YjMxNTogJ1NrZWluMjU2LTE2OCcsXG4gIDB4YjMxNjogJ1NrZWluMjU2LTE3NicsXG4gIDB4YjMxNzogJ1NrZWluMjU2LTE4NCcsXG4gIDB4YjMxODogJ1NrZWluMjU2LTE5MicsXG4gIDB4YjMxOTogJ1NrZWluMjU2LTIwMCcsXG4gIDB4YjMxYTogJ1NrZWluMjU2LTIwOCcsXG4gIDB4YjMxYjogJ1NrZWluMjU2LTIxNicsXG4gIDB4YjMxYzogJ1NrZWluMjU2LTIyNCcsXG4gIDB4YjMxZDogJ1NrZWluMjU2LTIzMicsXG4gIDB4YjMxZTogJ1NrZWluMjU2LTI0MCcsXG4gIDB4YjMxZjogJ1NrZWluMjU2LTI0OCcsXG4gIDB4YjMyMDogJ1NrZWluMjU2LTI1NicsXG4gIDB4YjMyMTogJ1NrZWluNTEyLTgnLFxuICAweGIzMjI6ICdTa2VpbjUxMi0xNicsXG4gIDB4YjMyMzogJ1NrZWluNTEyLTI0JyxcbiAgMHhiMzI0OiAnU2tlaW41MTItMzInLFxuICAweGIzMjU6ICdTa2VpbjUxMi00MCcsXG4gIDB4YjMyNjogJ1NrZWluNTEyLTQ4JyxcbiAgMHhiMzI3OiAnU2tlaW41MTItNTYnLFxuICAweGIzMjg6ICdTa2VpbjUxMi02NCcsXG4gIDB4YjMyOTogJ1NrZWluNTEyLTcyJyxcbiAgMHhiMzJhOiAnU2tlaW41MTItODAnLFxuICAweGIzMmI6ICdTa2VpbjUxMi04OCcsXG4gIDB4YjMyYzogJ1NrZWluNTEyLTk2JyxcbiAgMHhiMzJkOiAnU2tlaW41MTItMTA0JyxcbiAgMHhiMzJlOiAnU2tlaW41MTItMTEyJyxcbiAgMHhiMzJmOiAnU2tlaW41MTItMTIwJyxcbiAgMHhiMzMwOiAnU2tlaW41MTItMTI4JyxcbiAgMHhiMzMxOiAnU2tlaW41MTItMTM2JyxcbiAgMHhiMzMyOiAnU2tlaW41MTItMTQ0JyxcbiAgMHhiMzMzOiAnU2tlaW41MTItMTUyJyxcbiAgMHhiMzM0OiAnU2tlaW41MTItMTYwJyxcbiAgMHhiMzM1OiAnU2tlaW41MTItMTY4JyxcbiAgMHhiMzM2OiAnU2tlaW41MTItMTc2JyxcbiAgMHhiMzM3OiAnU2tlaW41MTItMTg0JyxcbiAgMHhiMzM4OiAnU2tlaW41MTItMTkyJyxcbiAgMHhiMzM5OiAnU2tlaW41MTItMjAwJyxcbiAgMHhiMzNhOiAnU2tlaW41MTItMjA4JyxcbiAgMHhiMzNiOiAnU2tlaW41MTItMjE2JyxcbiAgMHhiMzNjOiAnU2tlaW41MTItMjI0JyxcbiAgMHhiMzNkOiAnU2tlaW41MTItMjMyJyxcbiAgMHhiMzNlOiAnU2tlaW41MTItMjQwJyxcbiAgMHhiMzNmOiAnU2tlaW41MTItMjQ4JyxcbiAgMHhiMzQwOiAnU2tlaW41MTItMjU2JyxcbiAgMHhiMzQxOiAnU2tlaW41MTItMjY0JyxcbiAgMHhiMzQyOiAnU2tlaW41MTItMjcyJyxcbiAgMHhiMzQzOiAnU2tlaW41MTItMjgwJyxcbiAgMHhiMzQ0OiAnU2tlaW41MTItMjg4JyxcbiAgMHhiMzQ1OiAnU2tlaW41MTItMjk2JyxcbiAgMHhiMzQ2OiAnU2tlaW41MTItMzA0JyxcbiAgMHhiMzQ3OiAnU2tlaW41MTItMzEyJyxcbiAgMHhiMzQ4OiAnU2tlaW41MTItMzIwJyxcbiAgMHhiMzQ5OiAnU2tlaW41MTItMzI4JyxcbiAgMHhiMzRhOiAnU2tlaW41MTItMzM2JyxcbiAgMHhiMzRiOiAnU2tlaW41MTItMzQ0JyxcbiAgMHhiMzRjOiAnU2tlaW41MTItMzUyJyxcbiAgMHhiMzRkOiAnU2tlaW41MTItMzYwJyxcbiAgMHhiMzRlOiAnU2tlaW41MTItMzY4JyxcbiAgMHhiMzRmOiAnU2tlaW41MTItMzc2JyxcbiAgMHhiMzUwOiAnU2tlaW41MTItMzg0JyxcbiAgMHhiMzUxOiAnU2tlaW41MTItMzkyJyxcbiAgMHhiMzUyOiAnU2tlaW41MTItNDAwJyxcbiAgMHhiMzUzOiAnU2tlaW41MTItNDA4JyxcbiAgMHhiMzU0OiAnU2tlaW41MTItNDE2JyxcbiAgMHhiMzU1OiAnU2tlaW41MTItNDI0JyxcbiAgMHhiMzU2OiAnU2tlaW41MTItNDMyJyxcbiAgMHhiMzU3OiAnU2tlaW41MTItNDQwJyxcbiAgMHhiMzU4OiAnU2tlaW41MTItNDQ4JyxcbiAgMHhiMzU5OiAnU2tlaW41MTItNDU2JyxcbiAgMHhiMzVhOiAnU2tlaW41MTItNDY0JyxcbiAgMHhiMzViOiAnU2tlaW41MTItNDcyJyxcbiAgMHhiMzVjOiAnU2tlaW41MTItNDgwJyxcbiAgMHhiMzVkOiAnU2tlaW41MTItNDg4JyxcbiAgMHhiMzVlOiAnU2tlaW41MTItNDk2JyxcbiAgMHhiMzVmOiAnU2tlaW41MTItNTA0JyxcbiAgMHhiMzYwOiAnU2tlaW41MTItNTEyJyxcbiAgMHhiMzYxOiAnU2tlaW4xMDI0LTgnLFxuICAweGIzNjI6ICdTa2VpbjEwMjQtMTYnLFxuICAweGIzNjM6ICdTa2VpbjEwMjQtMjQnLFxuICAweGIzNjQ6ICdTa2VpbjEwMjQtMzInLFxuICAweGIzNjU6ICdTa2VpbjEwMjQtNDAnLFxuICAweGIzNjY6ICdTa2VpbjEwMjQtNDgnLFxuICAweGIzNjc6ICdTa2VpbjEwMjQtNTYnLFxuICAweGIzNjg6ICdTa2VpbjEwMjQtNjQnLFxuICAweGIzNjk6ICdTa2VpbjEwMjQtNzInLFxuICAweGIzNmE6ICdTa2VpbjEwMjQtODAnLFxuICAweGIzNmI6ICdTa2VpbjEwMjQtODgnLFxuICAweGIzNmM6ICdTa2VpbjEwMjQtOTYnLFxuICAweGIzNmQ6ICdTa2VpbjEwMjQtMTA0JyxcbiAgMHhiMzZlOiAnU2tlaW4xMDI0LTExMicsXG4gIDB4YjM2ZjogJ1NrZWluMTAyNC0xMjAnLFxuICAweGIzNzA6ICdTa2VpbjEwMjQtMTI4JyxcbiAgMHhiMzcxOiAnU2tlaW4xMDI0LTEzNicsXG4gIDB4YjM3MjogJ1NrZWluMTAyNC0xNDQnLFxuICAweGIzNzM6ICdTa2VpbjEwMjQtMTUyJyxcbiAgMHhiMzc0OiAnU2tlaW4xMDI0LTE2MCcsXG4gIDB4YjM3NTogJ1NrZWluMTAyNC0xNjgnLFxuICAweGIzNzY6ICdTa2VpbjEwMjQtMTc2JyxcbiAgMHhiMzc3OiAnU2tlaW4xMDI0LTE4NCcsXG4gIDB4YjM3ODogJ1NrZWluMTAyNC0xOTInLFxuICAweGIzNzk6ICdTa2VpbjEwMjQtMjAwJyxcbiAgMHhiMzdhOiAnU2tlaW4xMDI0LTIwOCcsXG4gIDB4YjM3YjogJ1NrZWluMTAyNC0yMTYnLFxuICAweGIzN2M6ICdTa2VpbjEwMjQtMjI0JyxcbiAgMHhiMzdkOiAnU2tlaW4xMDI0LTIzMicsXG4gIDB4YjM3ZTogJ1NrZWluMTAyNC0yNDAnLFxuICAweGIzN2Y6ICdTa2VpbjEwMjQtMjQ4JyxcbiAgMHhiMzgwOiAnU2tlaW4xMDI0LTI1NicsXG4gIDB4YjM4MTogJ1NrZWluMTAyNC0yNjQnLFxuICAweGIzODI6ICdTa2VpbjEwMjQtMjcyJyxcbiAgMHhiMzgzOiAnU2tlaW4xMDI0LTI4MCcsXG4gIDB4YjM4NDogJ1NrZWluMTAyNC0yODgnLFxuICAweGIzODU6ICdTa2VpbjEwMjQtMjk2JyxcbiAgMHhiMzg2OiAnU2tlaW4xMDI0LTMwNCcsXG4gIDB4YjM4NzogJ1NrZWluMTAyNC0zMTInLFxuICAweGIzODg6ICdTa2VpbjEwMjQtMzIwJyxcbiAgMHhiMzg5OiAnU2tlaW4xMDI0LTMyOCcsXG4gIDB4YjM4YTogJ1NrZWluMTAyNC0zMzYnLFxuICAweGIzOGI6ICdTa2VpbjEwMjQtMzQ0JyxcbiAgMHhiMzhjOiAnU2tlaW4xMDI0LTM1MicsXG4gIDB4YjM4ZDogJ1NrZWluMTAyNC0zNjAnLFxuICAweGIzOGU6ICdTa2VpbjEwMjQtMzY4JyxcbiAgMHhiMzhmOiAnU2tlaW4xMDI0LTM3NicsXG4gIDB4YjM5MDogJ1NrZWluMTAyNC0zODQnLFxuICAweGIzOTE6ICdTa2VpbjEwMjQtMzkyJyxcbiAgMHhiMzkyOiAnU2tlaW4xMDI0LTQwMCcsXG4gIDB4YjM5MzogJ1NrZWluMTAyNC00MDgnLFxuICAweGIzOTQ6ICdTa2VpbjEwMjQtNDE2JyxcbiAgMHhiMzk1OiAnU2tlaW4xMDI0LTQyNCcsXG4gIDB4YjM5NjogJ1NrZWluMTAyNC00MzInLFxuICAweGIzOTc6ICdTa2VpbjEwMjQtNDQwJyxcbiAgMHhiMzk4OiAnU2tlaW4xMDI0LTQ0OCcsXG4gIDB4YjM5OTogJ1NrZWluMTAyNC00NTYnLFxuICAweGIzOWE6ICdTa2VpbjEwMjQtNDY0JyxcbiAgMHhiMzliOiAnU2tlaW4xMDI0LTQ3MicsXG4gIDB4YjM5YzogJ1NrZWluMTAyNC00ODAnLFxuICAweGIzOWQ6ICdTa2VpbjEwMjQtNDg4JyxcbiAgMHhiMzllOiAnU2tlaW4xMDI0LTQ5NicsXG4gIDB4YjM5ZjogJ1NrZWluMTAyNC01MDQnLFxuICAweGIzYTA6ICdTa2VpbjEwMjQtNTEyJyxcbiAgMHhiM2ExOiAnU2tlaW4xMDI0LTUyMCcsXG4gIDB4YjNhMjogJ1NrZWluMTAyNC01MjgnLFxuICAweGIzYTM6ICdTa2VpbjEwMjQtNTM2JyxcbiAgMHhiM2E0OiAnU2tlaW4xMDI0LTU0NCcsXG4gIDB4YjNhNTogJ1NrZWluMTAyNC01NTInLFxuICAweGIzYTY6ICdTa2VpbjEwMjQtNTYwJyxcbiAgMHhiM2E3OiAnU2tlaW4xMDI0LTU2OCcsXG4gIDB4YjNhODogJ1NrZWluMTAyNC01NzYnLFxuICAweGIzYTk6ICdTa2VpbjEwMjQtNTg0JyxcbiAgMHhiM2FhOiAnU2tlaW4xMDI0LTU5MicsXG4gIDB4YjNhYjogJ1NrZWluMTAyNC02MDAnLFxuICAweGIzYWM6ICdTa2VpbjEwMjQtNjA4JyxcbiAgMHhiM2FkOiAnU2tlaW4xMDI0LTYxNicsXG4gIDB4YjNhZTogJ1NrZWluMTAyNC02MjQnLFxuICAweGIzYWY6ICdTa2VpbjEwMjQtNjMyJyxcbiAgMHhiM2IwOiAnU2tlaW4xMDI0LTY0MCcsXG4gIDB4YjNiMTogJ1NrZWluMTAyNC02NDgnLFxuICAweGIzYjI6ICdTa2VpbjEwMjQtNjU2JyxcbiAgMHhiM2IzOiAnU2tlaW4xMDI0LTY2NCcsXG4gIDB4YjNiNDogJ1NrZWluMTAyNC02NzInLFxuICAweGIzYjU6ICdTa2VpbjEwMjQtNjgwJyxcbiAgMHhiM2I2OiAnU2tlaW4xMDI0LTY4OCcsXG4gIDB4YjNiNzogJ1NrZWluMTAyNC02OTYnLFxuICAweGIzYjg6ICdTa2VpbjEwMjQtNzA0JyxcbiAgMHhiM2I5OiAnU2tlaW4xMDI0LTcxMicsXG4gIDB4YjNiYTogJ1NrZWluMTAyNC03MjAnLFxuICAweGIzYmI6ICdTa2VpbjEwMjQtNzI4JyxcbiAgMHhiM2JjOiAnU2tlaW4xMDI0LTczNicsXG4gIDB4YjNiZDogJ1NrZWluMTAyNC03NDQnLFxuICAweGIzYmU6ICdTa2VpbjEwMjQtNzUyJyxcbiAgMHhiM2JmOiAnU2tlaW4xMDI0LTc2MCcsXG4gIDB4YjNjMDogJ1NrZWluMTAyNC03NjgnLFxuICAweGIzYzE6ICdTa2VpbjEwMjQtNzc2JyxcbiAgMHhiM2MyOiAnU2tlaW4xMDI0LTc4NCcsXG4gIDB4YjNjMzogJ1NrZWluMTAyNC03OTInLFxuICAweGIzYzQ6ICdTa2VpbjEwMjQtODAwJyxcbiAgMHhiM2M1OiAnU2tlaW4xMDI0LTgwOCcsXG4gIDB4YjNjNjogJ1NrZWluMTAyNC04MTYnLFxuICAweGIzYzc6ICdTa2VpbjEwMjQtODI0JyxcbiAgMHhiM2M4OiAnU2tlaW4xMDI0LTgzMicsXG4gIDB4YjNjOTogJ1NrZWluMTAyNC04NDAnLFxuICAweGIzY2E6ICdTa2VpbjEwMjQtODQ4JyxcbiAgMHhiM2NiOiAnU2tlaW4xMDI0LTg1NicsXG4gIDB4YjNjYzogJ1NrZWluMTAyNC04NjQnLFxuICAweGIzY2Q6ICdTa2VpbjEwMjQtODcyJyxcbiAgMHhiM2NlOiAnU2tlaW4xMDI0LTg4MCcsXG4gIDB4YjNjZjogJ1NrZWluMTAyNC04ODgnLFxuICAweGIzZDA6ICdTa2VpbjEwMjQtODk2JyxcbiAgMHhiM2QxOiAnU2tlaW4xMDI0LTkwNCcsXG4gIDB4YjNkMjogJ1NrZWluMTAyNC05MTInLFxuICAweGIzZDM6ICdTa2VpbjEwMjQtOTIwJyxcbiAgMHhiM2Q0OiAnU2tlaW4xMDI0LTkyOCcsXG4gIDB4YjNkNTogJ1NrZWluMTAyNC05MzYnLFxuICAweGIzZDY6ICdTa2VpbjEwMjQtOTQ0JyxcbiAgMHhiM2Q3OiAnU2tlaW4xMDI0LTk1MicsXG4gIDB4YjNkODogJ1NrZWluMTAyNC05NjAnLFxuICAweGIzZDk6ICdTa2VpbjEwMjQtOTY4JyxcbiAgMHhiM2RhOiAnU2tlaW4xMDI0LTk3NicsXG4gIDB4YjNkYjogJ1NrZWluMTAyNC05ODQnLFxuICAweGIzZGM6ICdTa2VpbjEwMjQtOTkyJyxcbiAgMHhiM2RkOiAnU2tlaW4xMDI0LTEwMDAnLFxuICAweGIzZGU6ICdTa2VpbjEwMjQtMTAwOCcsXG4gIDB4YjNkZjogJ1NrZWluMTAyNC0xMDE2JyxcbiAgMHhiM2UwOiAnU2tlaW4xMDI0LTEwMjQnXG59KVxuXG5leHBvcnRzLmRlZmF1bHRMZW5ndGhzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIDB4MTE6IDIwLFxuICAweDEyOiAzMixcbiAgMHgxMzogNjQsXG4gIDB4NTY6IDMyLFxuICAweDE3OiAyOCxcbiAgMHgxNjogMzIsXG4gIDB4MTU6IDQ4LFxuICAweDE0OiA2NCxcbiAgMHgxODogMzIsXG4gIDB4MTk6IDY0LFxuICAweDFBOiAyOCxcbiAgMHgxQjogMzIsXG4gIDB4MUM6IDQ4LFxuICAweDFEOiA2NCxcbiAgMHgyMjogMzIsXG5cbiAgMHhiMjAxOiAweDAxLFxuICAweGIyMDI6IDB4MDIsXG4gIDB4YjIwMzogMHgwMyxcbiAgMHhiMjA0OiAweDA0LFxuICAweGIyMDU6IDB4MDUsXG4gIDB4YjIwNjogMHgwNixcbiAgMHhiMjA3OiAweDA3LFxuICAweGIyMDg6IDB4MDgsXG4gIDB4YjIwOTogMHgwOSxcbiAgMHhiMjBhOiAweDBhLFxuICAweGIyMGI6IDB4MGIsXG4gIDB4YjIwYzogMHgwYyxcbiAgMHhiMjBkOiAweDBkLFxuICAweGIyMGU6IDB4MGUsXG4gIDB4YjIwZjogMHgwZixcbiAgMHhiMjEwOiAweDEwLFxuICAweGIyMTE6IDB4MTEsXG4gIDB4YjIxMjogMHgxMixcbiAgMHhiMjEzOiAweDEzLFxuICAweGIyMTQ6IDB4MTQsXG4gIDB4YjIxNTogMHgxNSxcbiAgMHhiMjE2OiAweDE2LFxuICAweGIyMTc6IDB4MTcsXG4gIDB4YjIxODogMHgxOCxcbiAgMHhiMjE5OiAweDE5LFxuICAweGIyMWE6IDB4MWEsXG4gIDB4YjIxYjogMHgxYixcbiAgMHhiMjFjOiAweDFjLFxuICAweGIyMWQ6IDB4MWQsXG4gIDB4YjIxZTogMHgxZSxcbiAgMHhiMjFmOiAweDFmLFxuICAweGIyMjA6IDB4MjAsXG4gIDB4YjIyMTogMHgyMSxcbiAgMHhiMjIyOiAweDIyLFxuICAweGIyMjM6IDB4MjMsXG4gIDB4YjIyNDogMHgyNCxcbiAgMHhiMjI1OiAweDI1LFxuICAweGIyMjY6IDB4MjYsXG4gIDB4YjIyNzogMHgyNyxcbiAgMHhiMjI4OiAweDI4LFxuICAweGIyMjk6IDB4MjksXG4gIDB4YjIyYTogMHgyYSxcbiAgMHhiMjJiOiAweDJiLFxuICAweGIyMmM6IDB4MmMsXG4gIDB4YjIyZDogMHgyZCxcbiAgMHhiMjJlOiAweDJlLFxuICAweGIyMmY6IDB4MmYsXG4gIDB4YjIzMDogMHgzMCxcbiAgMHhiMjMxOiAweDMxLFxuICAweGIyMzI6IDB4MzIsXG4gIDB4YjIzMzogMHgzMyxcbiAgMHhiMjM0OiAweDM0LFxuICAweGIyMzU6IDB4MzUsXG4gIDB4YjIzNjogMHgzNixcbiAgMHhiMjM3OiAweDM3LFxuICAweGIyMzg6IDB4MzgsXG4gIDB4YjIzOTogMHgzOSxcbiAgMHhiMjNhOiAweDNhLFxuICAweGIyM2I6IDB4M2IsXG4gIDB4YjIzYzogMHgzYyxcbiAgMHhiMjNkOiAweDNkLFxuICAweGIyM2U6IDB4M2UsXG4gIDB4YjIzZjogMHgzZixcbiAgMHhiMjQwOiAweDQwLFxuICAweGIyNDE6IDB4MDEsXG4gIDB4YjI0MjogMHgwMixcbiAgMHhiMjQzOiAweDAzLFxuICAweGIyNDQ6IDB4MDQsXG4gIDB4YjI0NTogMHgwNSxcbiAgMHhiMjQ2OiAweDA2LFxuICAweGIyNDc6IDB4MDcsXG4gIDB4YjI0ODogMHgwOCxcbiAgMHhiMjQ5OiAweDA5LFxuICAweGIyNGE6IDB4MGEsXG4gIDB4YjI0YjogMHgwYixcbiAgMHhiMjRjOiAweDBjLFxuICAweGIyNGQ6IDB4MGQsXG4gIDB4YjI0ZTogMHgwZSxcbiAgMHhiMjRmOiAweDBmLFxuICAweGIyNTA6IDB4MTAsXG4gIDB4YjI1MTogMHgxMSxcbiAgMHhiMjUyOiAweDEyLFxuICAweGIyNTM6IDB4MTMsXG4gIDB4YjI1NDogMHgxNCxcbiAgMHhiMjU1OiAweDE1LFxuICAweGIyNTY6IDB4MTYsXG4gIDB4YjI1NzogMHgxNyxcbiAgMHhiMjU4OiAweDE4LFxuICAweGIyNTk6IDB4MTksXG4gIDB4YjI1YTogMHgxYSxcbiAgMHhiMjViOiAweDFiLFxuICAweGIyNWM6IDB4MWMsXG4gIDB4YjI1ZDogMHgxZCxcbiAgMHhiMjVlOiAweDFlLFxuICAweGIyNWY6IDB4MWYsXG4gIDB4YjI2MDogMHgyMCxcbiAgMHhiMzAxOiAweDAxLFxuICAweGIzMDI6IDB4MDIsXG4gIDB4YjMwMzogMHgwMyxcbiAgMHhiMzA0OiAweDA0LFxuICAweGIzMDU6IDB4MDUsXG4gIDB4YjMwNjogMHgwNixcbiAgMHhiMzA3OiAweDA3LFxuICAweGIzMDg6IDB4MDgsXG4gIDB4YjMwOTogMHgwOSxcbiAgMHhiMzBhOiAweDBhLFxuICAweGIzMGI6IDB4MGIsXG4gIDB4YjMwYzogMHgwYyxcbiAgMHhiMzBkOiAweDBkLFxuICAweGIzMGU6IDB4MGUsXG4gIDB4YjMwZjogMHgwZixcbiAgMHhiMzEwOiAweDEwLFxuICAweGIzMTE6IDB4MTEsXG4gIDB4YjMxMjogMHgxMixcbiAgMHhiMzEzOiAweDEzLFxuICAweGIzMTQ6IDB4MTQsXG4gIDB4YjMxNTogMHgxNSxcbiAgMHhiMzE2OiAweDE2LFxuICAweGIzMTc6IDB4MTcsXG4gIDB4YjMxODogMHgxOCxcbiAgMHhiMzE5OiAweDE5LFxuICAweGIzMWE6IDB4MWEsXG4gIDB4YjMxYjogMHgxYixcbiAgMHhiMzFjOiAweDFjLFxuICAweGIzMWQ6IDB4MWQsXG4gIDB4YjMxZTogMHgxZSxcbiAgMHhiMzFmOiAweDFmLFxuICAweGIzMjA6IDB4MjAsXG4gIDB4YjMyMTogMHgwMSxcbiAgMHhiMzIyOiAweDAyLFxuICAweGIzMjM6IDB4MDMsXG4gIDB4YjMyNDogMHgwNCxcbiAgMHhiMzI1OiAweDA1LFxuICAweGIzMjY6IDB4MDYsXG4gIDB4YjMyNzogMHgwNyxcbiAgMHhiMzI4OiAweDA4LFxuICAweGIzMjk6IDB4MDksXG4gIDB4YjMyYTogMHgwYSxcbiAgMHhiMzJiOiAweDBiLFxuICAweGIzMmM6IDB4MGMsXG4gIDB4YjMyZDogMHgwZCxcbiAgMHhiMzJlOiAweDBlLFxuICAweGIzMmY6IDB4MGYsXG4gIDB4YjMzMDogMHgxMCxcbiAgMHhiMzMxOiAweDExLFxuICAweGIzMzI6IDB4MTIsXG4gIDB4YjMzMzogMHgxMyxcbiAgMHhiMzM0OiAweDE0LFxuICAweGIzMzU6IDB4MTUsXG4gIDB4YjMzNjogMHgxNixcbiAgMHhiMzM3OiAweDE3LFxuICAweGIzMzg6IDB4MTgsXG4gIDB4YjMzOTogMHgxOSxcbiAgMHhiMzNhOiAweDFhLFxuICAweGIzM2I6IDB4MWIsXG4gIDB4YjMzYzogMHgxYyxcbiAgMHhiMzNkOiAweDFkLFxuICAweGIzM2U6IDB4MWUsXG4gIDB4YjMzZjogMHgxZixcbiAgMHhiMzQwOiAweDIwLFxuICAweGIzNDE6IDB4MjEsXG4gIDB4YjM0MjogMHgyMixcbiAgMHhiMzQzOiAweDIzLFxuICAweGIzNDQ6IDB4MjQsXG4gIDB4YjM0NTogMHgyNSxcbiAgMHhiMzQ2OiAweDI2LFxuICAweGIzNDc6IDB4MjcsXG4gIDB4YjM0ODogMHgyOCxcbiAgMHhiMzQ5OiAweDI5LFxuICAweGIzNGE6IDB4MmEsXG4gIDB4YjM0YjogMHgyYixcbiAgMHhiMzRjOiAweDJjLFxuICAweGIzNGQ6IDB4MmQsXG4gIDB4YjM0ZTogMHgyZSxcbiAgMHhiMzRmOiAweDJmLFxuICAweGIzNTA6IDB4MzAsXG4gIDB4YjM1MTogMHgzMSxcbiAgMHhiMzUyOiAweDMyLFxuICAweGIzNTM6IDB4MzMsXG4gIDB4YjM1NDogMHgzNCxcbiAgMHhiMzU1OiAweDM1LFxuICAweGIzNTY6IDB4MzYsXG4gIDB4YjM1NzogMHgzNyxcbiAgMHhiMzU4OiAweDM4LFxuICAweGIzNTk6IDB4MzksXG4gIDB4YjM1YTogMHgzYSxcbiAgMHhiMzViOiAweDNiLFxuICAweGIzNWM6IDB4M2MsXG4gIDB4YjM1ZDogMHgzZCxcbiAgMHhiMzVlOiAweDNlLFxuICAweGIzNWY6IDB4M2YsXG4gIDB4YjM2MDogMHg0MCxcbiAgMHhiMzYxOiAweDAxLFxuICAweGIzNjI6IDB4MDIsXG4gIDB4YjM2MzogMHgwMyxcbiAgMHhiMzY0OiAweDA0LFxuICAweGIzNjU6IDB4MDUsXG4gIDB4YjM2NjogMHgwNixcbiAgMHhiMzY3OiAweDA3LFxuICAweGIzNjg6IDB4MDgsXG4gIDB4YjM2OTogMHgwOSxcbiAgMHhiMzZhOiAweDBhLFxuICAweGIzNmI6IDB4MGIsXG4gIDB4YjM2YzogMHgwYyxcbiAgMHhiMzZkOiAweDBkLFxuICAweGIzNmU6IDB4MGUsXG4gIDB4YjM2ZjogMHgwZixcbiAgMHhiMzcwOiAweDEwLFxuICAweGIzNzE6IDB4MTEsXG4gIDB4YjM3MjogMHgxMixcbiAgMHhiMzczOiAweDEzLFxuICAweGIzNzQ6IDB4MTQsXG4gIDB4YjM3NTogMHgxNSxcbiAgMHhiMzc2OiAweDE2LFxuICAweGIzNzc6IDB4MTcsXG4gIDB4YjM3ODogMHgxOCxcbiAgMHhiMzc5OiAweDE5LFxuICAweGIzN2E6IDB4MWEsXG4gIDB4YjM3YjogMHgxYixcbiAgMHhiMzdjOiAweDFjLFxuICAweGIzN2Q6IDB4MWQsXG4gIDB4YjM3ZTogMHgxZSxcbiAgMHhiMzdmOiAweDFmLFxuICAweGIzODA6IDB4MjAsXG4gIDB4YjM4MTogMHgyMSxcbiAgMHhiMzgyOiAweDIyLFxuICAweGIzODM6IDB4MjMsXG4gIDB4YjM4NDogMHgyNCxcbiAgMHhiMzg1OiAweDI1LFxuICAweGIzODY6IDB4MjYsXG4gIDB4YjM4NzogMHgyNyxcbiAgMHhiMzg4OiAweDI4LFxuICAweGIzODk6IDB4MjksXG4gIDB4YjM4YTogMHgyYSxcbiAgMHhiMzhiOiAweDJiLFxuICAweGIzOGM6IDB4MmMsXG4gIDB4YjM4ZDogMHgyZCxcbiAgMHhiMzhlOiAweDJlLFxuICAweGIzOGY6IDB4MmYsXG4gIDB4YjM5MDogMHgzMCxcbiAgMHhiMzkxOiAweDMxLFxuICAweGIzOTI6IDB4MzIsXG4gIDB4YjM5MzogMHgzMyxcbiAgMHhiMzk0OiAweDM0LFxuICAweGIzOTU6IDB4MzUsXG4gIDB4YjM5NjogMHgzNixcbiAgMHhiMzk3OiAweDM3LFxuICAweGIzOTg6IDB4MzgsXG4gIDB4YjM5OTogMHgzOSxcbiAgMHhiMzlhOiAweDNhLFxuICAweGIzOWI6IDB4M2IsXG4gIDB4YjM5YzogMHgzYyxcbiAgMHhiMzlkOiAweDNkLFxuICAweGIzOWU6IDB4M2UsXG4gIDB4YjM5ZjogMHgzZixcbiAgMHhiM2EwOiAweDQwLFxuICAweGIzYTE6IDB4NDEsXG4gIDB4YjNhMjogMHg0MixcbiAgMHhiM2EzOiAweDQzLFxuICAweGIzYTQ6IDB4NDQsXG4gIDB4YjNhNTogMHg0NSxcbiAgMHhiM2E2OiAweDQ2LFxuICAweGIzYTc6IDB4NDcsXG4gIDB4YjNhODogMHg0OCxcbiAgMHhiM2E5OiAweDQ5LFxuICAweGIzYWE6IDB4NGEsXG4gIDB4YjNhYjogMHg0YixcbiAgMHhiM2FjOiAweDRjLFxuICAweGIzYWQ6IDB4NGQsXG4gIDB4YjNhZTogMHg0ZSxcbiAgMHhiM2FmOiAweDRmLFxuICAweGIzYjA6IDB4NTAsXG4gIDB4YjNiMTogMHg1MSxcbiAgMHhiM2IyOiAweDUyLFxuICAweGIzYjM6IDB4NTMsXG4gIDB4YjNiNDogMHg1NCxcbiAgMHhiM2I1OiAweDU1LFxuICAweGIzYjY6IDB4NTYsXG4gIDB4YjNiNzogMHg1NyxcbiAgMHhiM2I4OiAweDU4LFxuICAweGIzYjk6IDB4NTksXG4gIDB4YjNiYTogMHg1YSxcbiAgMHhiM2JiOiAweDViLFxuICAweGIzYmM6IDB4NWMsXG4gIDB4YjNiZDogMHg1ZCxcbiAgMHhiM2JlOiAweDVlLFxuICAweGIzYmY6IDB4NWYsXG4gIDB4YjNjMDogMHg2MCxcbiAgMHhiM2MxOiAweDYxLFxuICAweGIzYzI6IDB4NjIsXG4gIDB4YjNjMzogMHg2MyxcbiAgMHhiM2M0OiAweDY0LFxuICAweGIzYzU6IDB4NjUsXG4gIDB4YjNjNjogMHg2NixcbiAgMHhiM2M3OiAweDY3LFxuICAweGIzYzg6IDB4NjgsXG4gIDB4YjNjOTogMHg2OSxcbiAgMHhiM2NhOiAweDZhLFxuICAweGIzY2I6IDB4NmIsXG4gIDB4YjNjYzogMHg2YyxcbiAgMHhiM2NkOiAweDZkLFxuICAweGIzY2U6IDB4NmUsXG4gIDB4YjNjZjogMHg2ZixcbiAgMHhiM2QwOiAweDcwLFxuICAweGIzZDE6IDB4NzEsXG4gIDB4YjNkMjogMHg3MixcbiAgMHhiM2QzOiAweDczLFxuICAweGIzZDQ6IDB4NzQsXG4gIDB4YjNkNTogMHg3NSxcbiAgMHhiM2Q2OiAweDc2LFxuICAweGIzZDc6IDB4NzcsXG4gIDB4YjNkODogMHg3OCxcbiAgMHhiM2Q5OiAweDc5LFxuICAweGIzZGE6IDB4N2EsXG4gIDB4YjNkYjogMHg3YixcbiAgMHhiM2RjOiAweDdjLFxuICAweGIzZGQ6IDB4N2QsXG4gIDB4YjNkZTogMHg3ZSxcbiAgMHhiM2RmOiAweDdmLFxuICAweGIzZTA6IDB4ODBcbn0pXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBkaWZmZXJlbmNlfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJylcblxuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuICBzdGFydDogdHJ1ZSxcbiAgcG9sbEludGVydmFsOiAxMDAwLFxufVxuXG5jbGFzcyBJcGZzUHVic3ViUGVlck1vbml0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoaXBmc1B1YnN1YiwgdG9waWMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fcHVic3ViID0gaXBmc1B1YnN1YlxuICAgIHRoaXMuX3RvcGljID0gdG9waWNcbiAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKVxuICAgIHRoaXMuX3BlZXJzID0gW11cbiAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGxcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnN0YXJ0KVxuICAgICAgdGhpcy5zdGFydCgpXG4gIH1cblxuICBnZXQgc3RhcnRlZCAoKSB7IHJldHVybiB0aGlzLl9pbnRlcnZhbCAhPT0gbnVsbCB9XG4gIHNldCBzdGFydGVkICh2YWwpIHsgdGhyb3cgbmV3IEVycm9yKFwiJ3N0YXJ0ZWQnIGlzIHJlYWQtb25seVwiKSB9XG5cbiAgc3RhcnQgKCkge1xuICAgIGlmICh0aGlzLl9pbnRlcnZhbClcbiAgICAgIHRoaXMuc3RvcCgpXG5cbiAgICB0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKFxuICAgICAgdGhpcy5fcG9sbFBlZXJzLmJpbmQodGhpcyksIFxuICAgICAgdGhpcy5fb3B0aW9ucy5wb2xsSW50ZXJ2YWxcbiAgICApXG4gIH1cblxuICBzdG9wICgpIHtcbiAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKVxuICAgIHRoaXMuX2ludGVydmFsID0gbnVsbFxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdlcnJvcicpXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2pvaW4nKVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdsZWF2ZScpXG4gIH1cblxuICBhc3luYyBnZXRQZWVycyAoKSB7XG4gICAgdGhpcy5fcGVlcnMgPSBhd2FpdCB0aGlzLl9wdWJzdWIucGVlcnModGhpcy5fdG9waWMpXG4gICAgcmV0dXJuIHRoaXMuX3BlZXJzLnNsaWNlKClcbiAgfVxuXG4gIGhhc1BlZXIgKHBlZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcGVlcnMuaW5jbHVkZXMocGVlcilcbiAgfVxuXG4gIGFzeW5jIF9wb2xsUGVlcnMgKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwZWVycyA9IGF3YWl0IHRoaXMuX3B1YnN1Yi5wZWVycyh0aGlzLl90b3BpYylcbiAgICAgIElwZnNQdWJzdWJQZWVyTW9uaXRvci5fZW1pdEpvaW5zQW5kTGVhdmVzKG5ldyBTZXQodGhpcy5fcGVlcnMpLCBuZXcgU2V0KHBlZXJzKSwgdGhpcylcbiAgICAgIHRoaXMuX3BlZXJzID0gcGVlcnNcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpXG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBfZW1pdEpvaW5zQW5kTGVhdmVzIChvbGRWYWx1ZXMsIG5ld1ZhbHVlcywgZXZlbnRzKSB7XG4gICAgY29uc3QgZW1pdEpvaW4gPSBhZGRlZFBlZXIgPT4gZXZlbnRzLmVtaXQoJ2pvaW4nLCBhZGRlZFBlZXIpXG4gICAgY29uc3QgZW1pdExlYXZlID0gcmVtb3ZlZFBlZXIgPT4gZXZlbnRzLmVtaXQoJ2xlYXZlJywgcmVtb3ZlZFBlZXIpXG4gICAgZGlmZmVyZW5jZShuZXdWYWx1ZXMsIG9sZFZhbHVlcykuZm9yRWFjaChlbWl0Sm9pbilcbiAgICBkaWZmZXJlbmNlKG9sZFZhbHVlcywgbmV3VmFsdWVzKS5mb3JFYWNoKGVtaXRMZWF2ZSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IElwZnNQdWJzdWJQZWVyTW9uaXRvclxuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcFJlZHVjZSA9IHJlcXVpcmUoJ3AtcmVkdWNlJyk7XG5jb25zdCBpcyA9IHJlcXVpcmUoJ0BzaW5kcmVzb3JodXMvaXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpdGVyYWJsZSA9PiB7XG5cdGNvbnN0IHJldCA9IFtdO1xuXG5cdGZvciAoY29uc3QgdGFzayBvZiBpdGVyYWJsZSkge1xuXHRcdGNvbnN0IHR5cGUgPSBpcyh0YXNrKTtcblxuXHRcdGlmICh0eXBlICE9PSAnRnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgdGFzayB0byBiZSBhIFxcYEZ1bmN0aW9uXFxgLCByZWNlaXZlZCBcXGAke3R5cGV9XFxgYCkpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBwUmVkdWNlKGl0ZXJhYmxlLCAoXywgZm4pID0+IHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmbikudGhlbih2YWwgPT4ge1xuXHRcdFx0cmV0LnB1c2godmFsKTtcblx0XHR9KTtcblx0fSkudGhlbigoKSA9PiByZXQpO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgRy1TZXQgQ1JEVFxuICpcbiAqIEZyb206XG4gKiBcIkEgY29tcHJlaGVuc2l2ZSBzdHVkeSBvZiBDb252ZXJnZW50IGFuZCBDb21tdXRhdGl2ZSBSZXBsaWNhdGVkIERhdGEgVHlwZXNcIlxuICogaHR0cHM6Ly9oYWwuaW5yaWEuZnIvaW5yaWEtMDA1NTU1ODhcbiAqL1xuY2xhc3MgR1NldCB7XG4gIGNvbnN0cnVjdG9yICh2YWx1ZXMpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgYXBwZW5kICh2YWx1ZSkge31cbiAgbWVyZ2UgKHNldCkge31cbiAgZ2V0ICh2YWx1ZSkge31cbiAgaGFzICh2YWx1ZSkge31cbiAgZ2V0IHZhbHVlcyAoKSB7fVxuICBnZXQgbGVuZ3RoICgpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR1NldFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IElQRlNOb3REZWZpbmVkRXJyb3IgPSAoKSA9PiBuZXcgRXJyb3IoJ0lQRlMgaW5zdGFuY2Ugbm90IGRlZmluZWQnKVxuY29uc3QgTG9nTm90RGVmaW5lZEVycm9yID0gKCkgPT4gbmV3IEVycm9yKCdMb2cgaW5zdGFuY2Ugbm90IGRlZmluZWQnKVxuY29uc3QgTm90QUxvZ0Vycm9yID0gKCkgPT4gbmV3IEVycm9yKCdHaXZlbiBhcmd1bWVudCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgTG9nJylcbmNvbnN0IENhbm5vdEpvaW5XaXRoRGlmZmVyZW50SWQgPSAoKSA9PiBuZXcgRXJyb3IoJ0NhblxcJ3Qgam9pbiBsb2dzIHdpdGggZGlmZmVyZW50IElEcycpXG5jb25zdCBMdE9yTHRlTXVzdEJlU3RyaW5nT3JBcnJheSA9ICgpID0+IG5ldyBFcnJvcignbHQgb3IgbHRlIG11c3QgYmUgYSBzdHJpbmcgb3IgYXJyYXkgb2YgRW50cmllcycpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBJUEZTTm90RGVmaW5lZEVycm9yOiBJUEZTTm90RGVmaW5lZEVycm9yLFxuICBMb2dOb3REZWZpbmVkRXJyb3I6IExvZ05vdERlZmluZWRFcnJvcixcbiAgTm90QUxvZ0Vycm9yOiBOb3RBTG9nRXJyb3IsXG4gIENhbm5vdEpvaW5XaXRoRGlmZmVyZW50SWQ6IENhbm5vdEpvaW5XaXRoRGlmZmVyZW50SWQsXG4gIEx0T3JMdGVNdXN0QmVTdHJpbmdPckFycmF5OiBMdE9yTHRlTXVzdEJlU3RyaW5nT3JBcnJheVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNsYXNzIExhbXBvcnRDbG9jayB7XG4gIGNvbnN0cnVjdG9yIChpZCwgdGltZSkge1xuICAgIHRoaXMuaWQgPSBpZFxuICAgIHRoaXMudGltZSA9IHRpbWUgfHwgMFxuICB9XG5cbiAgdGljayAoKSB7XG4gICAgcmV0dXJuIG5ldyBMYW1wb3J0Q2xvY2sodGhpcy5pZCwgKyt0aGlzLnRpbWUpXG4gIH1cblxuICBtZXJnZSAoY2xvY2spIHtcbiAgICB0aGlzLnRpbWUgPSBNYXRoLm1heCh0aGlzLnRpbWUsIGNsb2NrLnRpbWUpXG4gICAgcmV0dXJuIG5ldyBMYW1wb3J0Q2xvY2sodGhpcy5pZCwgdGhpcy50aW1lKVxuICB9XG5cbiAgY2xvbmUgKCkge1xuICAgIHJldHVybiBuZXcgTGFtcG9ydENsb2NrKHRoaXMuaWQsIHRoaXMudGltZSlcbiAgfVxuXG4gIHN0YXRpYyBjb21wYXJlIChhLCBiKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBcImRpc3RhbmNlXCIgYmFzZWQgb24gdGhlIGNsb2NrLCBpZS4gbG93ZXIgb3IgZ3JlYXRlclxuICAgIHZhciBkaXN0ID0gYS50aW1lIC0gYi50aW1lXG5cbiAgICAvLyBJZiB0aGUgc2VxdWVuY2UgbnVtYmVyIGlzIHRoZSBzYW1lIChjb25jdXJyZW50IGV2ZW50cyksXG4gICAgLy8gYW5kIHRoZSBJRHMgYXJlIGRpZmZlcmVudCwgdGFrZSB0aGUgb25lIHdpdGggYSBcImxvd2VyXCIgaWRcbiAgICBpZiAoZGlzdCA9PT0gMCAmJiBhLmlkICE9PSBiLmlkKSByZXR1cm4gYS5pZCA8IGIuaWQgPyAtMSA6IDFcblxuICAgIHJldHVybiBkaXN0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMYW1wb3J0Q2xvY2tcbiIsIid1c2Ugc3RyaWN0J1xuXG5jbGFzcyBBY2Nlc3NDb250cm9sbGVyIHtcbiAgYXN5bmMgY2FuQXBwZW5kIChlbnRyeSwgaWRlbnRpdHlQcm92aWRlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBY2Nlc3NDb250cm9sbGVyXG4iLCIndXNlIHN0cmljdCdcblxuY2xhc3MgRW50cnlJbmRleCB7XG4gIGNvbnN0cnVjdG9yIChlbnRyaWVzID0ge30pIHtcbiAgICB0aGlzLl9jYWNoZSA9IGVudHJpZXNcbiAgfVxuXG4gIHNldCAoaywgdikge1xuICAgIHRoaXMuX2NhY2hlW2tdID0gdlxuICB9XG5cbiAgZ2V0IChrKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlW2tdXG4gIH1cblxuICBkZWxldGUgKGspIHtcbiAgICByZXR1cm4gZGVsZXRlIHRoaXMuX2NhY2hlW2tdXG4gIH1cblxuICBhZGQgKG5ld0l0ZW1zKSB7XG4gICAgdGhpcy5fY2FjaGUgPSBPYmplY3QuYXNzaWduKHRoaXMuX2NhY2hlLCBuZXdJdGVtcylcbiAgfVxuXG4gIGdldCBsZW5ndGggKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX2NhY2hlKS5sZW5ndGhcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVudHJ5SW5kZXhcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBDbG9jayA9IHJlcXVpcmUoJy4vbGFtcG9ydC1jbG9jaycpXG5cbi8qKlxuICogU29ydCB0d28gZW50cmllcyBhcyBMYXN0LVdyaXRlLVdpbnMgKExXVykuXG4gKlxuICogTGFzdCBXcml0ZSBXaW5zIGlzIGEgY29uZmxpY3QgcmVzb2x1dGlvbiBzdHJhdGVneSBmb3Igc29ydGluZyBlbGVtZW50c1xuICogd2hlcmUgdGhlIGVsZW1lbnQgd2l0aCBhIGdyZWF0ZXIgY2xvY2sgKGxhdGVzdCkgaXMgY2hvc2VuIGFzIHRoZSB3aW5uZXIuXG4gKlxuICogQHBhcmFtIHtFbnRyeX0gYSBGaXJzdCBlbnRyeVxuICogQHBhcmFtIHtFbnRyeX0gYiBTZWNvbmQgZW50cnlcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDEgaWYgYSBpcyBsYXRlc3QsIC0xIGlmIGIgaXMgbGF0ZXN0XG4gKi9cbmZ1bmN0aW9uIExhc3RXcml0ZVdpbnMgKGEsIGIpIHtcbiAgLy8gVWx0aW1hdGUgY29uZmxpY3QgcmVzb2x1dGlvbiAodGFrZSB0aGUgZmlyc3QvbGVmdCBhcmcpXG4gIGNvbnN0IEZpcnN0ID0gKGEsIGIpID0+IGFcbiAgLy8gU29ydCB0d28gZW50cmllcyBieSB0aGVpciBjbG9jayBpZCwgaWYgdGhlIHNhbWUgYWx3YXlzIHRha2UgdGhlIGZpcnN0XG4gIGNvbnN0IHNvcnRCeUlkID0gKGEsIGIpID0+IFNvcnRCeUNsb2NrSWQoYSwgYiwgRmlyc3QpXG4gIC8vIFNvcnQgdHdvIGVudHJpZXMgYnkgdGhlaXIgY2xvY2sgdGltZSwgaWYgY29uY3VycmVudCxcbiAgLy8gZGV0ZXJtaW5lIHNvcnRpbmcgdXNpbmcgcHJvdmlkZWQgY29uZmxpY3QgcmVzb2x1dGlvbiBmdW5jdGlvblxuICBjb25zdCBzb3J0QnlFbnRyeUNsb2NrcyA9IChhLCBiKSA9PiBTb3J0QnlDbG9ja3MoYSwgYiwgc29ydEJ5SWQpXG4gIC8vIFNvcnQgZW50cmllcyBieSBjbG9jayB0aW1lIGFzIHRoZSBwcmltYXJ5IHNvcnQgY3JpdGVyaWFcbiAgcmV0dXJuIHNvcnRCeUVudHJ5Q2xvY2tzKGEsIGIpXG59XG5cbi8qKlxuICogU29ydCB0d28gZW50cmllcyBieSB0aGVpciBoYXNoLlxuICpcbiAqIEBwYXJhbSB7RW50cnl9IGEgRmlyc3QgZW50cnlcbiAqIEBwYXJhbSB7RW50cnl9IGIgU2Vjb25kIGVudHJ5XG4gKiBAcmV0dXJucyB7bnVtYmVyfSAxIGlmIGEgaXMgbGF0ZXN0LCAtMSBpZiBiIGlzIGxhdGVzdFxuICovXG5mdW5jdGlvbiBTb3J0QnlFbnRyeUhhc2ggKGEsIGIpIHtcbiAgLy8gVWx0aW1hdGUgY29uZmxpY3QgcmVzb2x1dGlvbiAoY29tcGFyZSBoYXNoZXMpXG4gIGNvbnN0IGNvbXBhcmVIYXNoID0gKGEsIGIpID0+IGEuaGFzaCA8IGIuaGFzaCA/IC0xIDogMVxuICAvLyBTb3J0IHR3byBlbnRyaWVzIGJ5IHRoZWlyIGNsb2NrIGlkLCBpZiB0aGUgc2FtZSB0aGVuIGNvbXBhcmUgaGFzaGVzXG4gIGNvbnN0IHNvcnRCeUlkID0gKGEsIGIpID0+IFNvcnRCeUNsb2NrSWQoYSwgYiwgY29tcGFyZUhhc2gpXG4gIC8vIFNvcnQgdHdvIGVudHJpZXMgYnkgdGhlaXIgY2xvY2sgdGltZSwgaWYgY29uY3VycmVudCxcbiAgLy8gZGV0ZXJtaW5lIHNvcnRpbmcgdXNpbmcgcHJvdmlkZWQgY29uZmxpY3QgcmVzb2x1dGlvbiBmdW5jdGlvblxuICBjb25zdCBzb3J0QnlFbnRyeUNsb2NrcyA9IChhLCBiKSA9PiBTb3J0QnlDbG9ja3MoYSwgYiwgc29ydEJ5SWQpXG4gIC8vIFNvcnQgZW50cmllcyBieSBjbG9jayB0aW1lIGFzIHRoZSBwcmltYXJ5IHNvcnQgY3JpdGVyaWFcbiAgcmV0dXJuIHNvcnRCeUVudHJ5Q2xvY2tzKGEsIGIpXG59XG5cbi8qKlxuICogU29ydCB0d28gZW50cmllcyBieSB0aGVpciBjbG9jayB0aW1lLlxuICogQHBhcmFtIHtFbnRyeX0gYSBGaXJzdCBlbnRyeSB0byBjb21wYXJlXG4gKiBAcGFyYW0ge0VudHJ5fSBiIFNlY29uZCBlbnRyeSB0byBjb21wYXJlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGEsIGIpfSByZXNvbHZlQ29uZmxpY3QgQSBmdW5jdGlvbiB0byBjYWxsIGlmIGVudHJpZXMgYXJlIGNvbmN1cnJlbnQgKGhhcHBlbmVkIGF0IHRoZSBzYW1lIHRpbWUpLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHRha2UgaW4gdHdvIGVudHJpZXMgYW5kIHJldHVybiAxIGlmIHRoZSBmaXJzdCBlbnRyeSBzaG91bGQgYmUgY2hvc2VuIGFuZCAtMSBpZiB0aGUgc2Vjb25kIGVudHJ5IHNob3VsZCBiZSBjaG9zZW4uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAxIGlmIGEgaXMgZ3JlYXRlciwgLTEgaWYgYiBpcyBncmVhdGVyXG4gKi9cbmZ1bmN0aW9uIFNvcnRCeUNsb2NrcyAoYSwgYiwgcmVzb2x2ZUNvbmZsaWN0KSB7XG4gIC8vIENvbXBhcmUgdGhlIGNsb2Nrc1xuICBjb25zdCBkaWZmID0gQ2xvY2suY29tcGFyZShhLmNsb2NrLCBiLmNsb2NrKVxuICAvLyBJZiB0aGUgY2xvY2tzIGFyZSBjb25jdXJyZW50LCB1c2UgdGhlIHByb3ZpZGVkXG4gIC8vIGNvbmZsaWN0IHJlc29sdXRpb24gZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoaWNoIGNvbWVzIGZpcnN0XG4gIHJldHVybiBkaWZmID09PSAwID8gcmVzb2x2ZUNvbmZsaWN0KGEsIGIpIDogZGlmZlxufVxuXG4vKipcbiAqIFNvcnQgdHdvIGVudHJpZXMgYnkgdGhlaXIgY2xvY2sgaWQuXG4gKiBAcGFyYW0ge0VudHJ5fSBhIEZpcnN0IGVudHJ5IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7RW50cnl9IGIgU2Vjb25kIGVudHJ5IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYSwgYil9IHJlc29sdmVDb25mbGljdCBBIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhlIGNsb2NrcyBpZHMgYXJlIHRoZSBzYW1lLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHRha2UgaW4gdHdvIGVudHJpZXMgYW5kIHJldHVybiAxIGlmIHRoZSBmaXJzdCBlbnRyeSBzaG91bGQgYmUgY2hvc2VuIGFuZCAtMSBpZiB0aGUgc2Vjb25kIGVudHJ5IHNob3VsZCBiZSBjaG9zZW4uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAxIGlmIGEgaXMgZ3JlYXRlciwgLTEgaWYgYiBpcyBncmVhdGVyXG4gKi9cbmZ1bmN0aW9uIFNvcnRCeUNsb2NrSWQgKGEsIGIsIHJlc29sdmVDb25mbGljdCkge1xuICAvLyBTb3J0IGJ5IElEIGlmIGNsb2NrcyBhcmUgY29uY3VycmVudCxcbiAgLy8gdGFrZSB0aGUgZW50cnkgd2l0aCBhIFwiZ3JlYXRlclwiIGNsb2NrIGlkXG4gIHJldHVybiBhLmNsb2NrLmlkID09PSBiLmNsb2NrLmlkXG4gICAgPyByZXNvbHZlQ29uZmxpY3QoYSwgYilcbiAgICA6IGEuY2xvY2suaWQgPCBiLmNsb2NrLmlkID8gLTEgOiAxXG59XG5cbi8qKlxuICogQSB3cmFwcGVyIGZ1bmN0aW9uIHRvIHRocm93IGFuIGVycm9yIGlmIHRoZSByZXN1bHRzIG9mIGEgcGFzc2VkIGZ1bmN0aW9uIHJldHVybiB6ZXJvXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGEsIGIpfSBbdGllYnJlYWtlcl0gVGhlIHRpZWJyZWFrZXIgZnVuY3Rpb24gdG8gdmFsaWRhdGUuXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oYSwgYil9IDEgaWYgYSBpcyBncmVhdGVyLCAtMSBpZiBiIGlzIGdyZWF0ZXJcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBmdW5jIGV2ZXIgcmV0dXJucyAwXG4gKi9cbmZ1bmN0aW9uIE5vWmVyb2VzIChmdW5jKSB7XG4gIGNvbnN0IG1zZyA9IGBZb3VyIGxvZydzIHRpZWJyZWFrZXIgZnVuY3Rpb24sICR7ZnVuYy5uYW1lfSwgaGFzIHJldHVybmVkIHplcm8gYW5kIHRoZXJlZm9yZSBjYW5ub3QgYmVgXG5cbiAgY29uc3QgY29tcGFyYXRvciA9IChhLCBiKSA9PiB7XG4gICAgLy8gVmFsaWRhdGUgYnkgY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAgICBjb25zdCByZXN1bHQgPSBmdW5jKGEsIGIpXG4gICAgaWYgKHJlc3VsdCA9PT0gMCkgeyB0aHJvdyBFcnJvcihtc2cpIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICByZXR1cm4gY29tcGFyYXRvclxufVxuXG5leHBvcnRzLlNvcnRCeUNsb2NrcyA9IFNvcnRCeUNsb2Nrc1xuZXhwb3J0cy5Tb3J0QnlDbG9ja0lkID0gU29ydEJ5Q2xvY2tJZFxuZXhwb3J0cy5MYXN0V3JpdGVXaW5zID0gTGFzdFdyaXRlV2luc1xuZXhwb3J0cy5Tb3J0QnlFbnRyeUhhc2ggPSBTb3J0QnlFbnRyeUhhc2hcbmV4cG9ydHMuTm9aZXJvZXMgPSBOb1plcm9lc1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBwRWFjaFNlcmllcyA9IGFzeW5jIChpdGVyYWJsZSwgaXRlcmF0b3IpID0+IHtcblx0bGV0IGluZGV4ID0gMDtcblxuXHRmb3IgKGNvbnN0IHZhbHVlIG9mIGl0ZXJhYmxlKSB7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3Bcblx0XHRhd2FpdCBpdGVyYXRvcihhd2FpdCB2YWx1ZSwgaW5kZXgrKyk7XG5cdH1cblxuXHRyZXR1cm4gaXRlcmFibGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBFYWNoU2VyaWVzO1xuLy8gVE9ETzogUmVtb3ZlIHRoaXMgZm9yIHRoZSBuZXh0IG1ham9yIHJlbGVhc2Vcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBwRWFjaFNlcmllcztcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBkaWZmZXJlbmNlID0gcmVxdWlyZSgnLi9kaWZmZXJlbmNlJylcbmNvbnN0IGZpbmRVbmlxdWVzID0gcmVxdWlyZSgnLi9maW5kLXVuaXF1ZXMnKVxuY29uc3QgaXNEZWZpbmVkID0gcmVxdWlyZSgnLi9pcy1kZWZpbmVkJylcbmNvbnN0IGlvID0gcmVxdWlyZSgnb3JiaXQtZGItaW8nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGlmZmVyZW5jZSxcbiAgZmluZFVuaXF1ZXMsXG4gIGlzRGVmaW5lZCxcbiAgaW9cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBFbnRyeSA9IHJlcXVpcmUoJy4vZW50cnknKVxuY29uc3QgRW50cnlJTyA9IHJlcXVpcmUoJy4vZW50cnktaW8nKVxuY29uc3QgQ2xvY2sgPSByZXF1aXJlKCcuL2xhbXBvcnQtY2xvY2snKVxuY29uc3QgTG9nRXJyb3IgPSByZXF1aXJlKCcuL2xvZy1lcnJvcnMnKVxuY29uc3QgeyBpc0RlZmluZWQsIGZpbmRVbmlxdWVzLCBkaWZmZXJlbmNlLCBpbyB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5cbmNvbnN0IElQTERfTElOS1MgPSBbJ2hlYWRzJ11cbmNvbnN0IGxhc3QgPSAoYXJyLCBuKSA9PiBhcnIuc2xpY2UoYXJyLmxlbmd0aCAtIG4sIGFyci5sZW5ndGgpXG5cbmNsYXNzIExvZ0lPIHtcbiAgLy9cbiAgLyoqXG4gICAqIEdldCB0aGUgbXVsdGloYXNoIG9mIGEgTG9nLlxuICAgKiBAcGFyYW0ge0lQRlN9IGlwZnMgQW4gSVBGUyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0xvZ30gbG9nIExvZyB0byBnZXQgYSBtdWx0aWhhc2ggZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgdG9NdWx0aWhhc2ggKGlwZnMsIGxvZywgeyBmb3JtYXQgfSA9IHt9KSB7XG4gICAgaWYgKCFpc0RlZmluZWQoaXBmcykpIHRocm93IExvZ0Vycm9yLklQRlNOb3REZWZpbmVkRXJyb3IoKVxuICAgIGlmICghaXNEZWZpbmVkKGxvZykpIHRocm93IExvZ0Vycm9yLkxvZ05vdERlZmluZWRFcnJvcigpXG4gICAgaWYgKCFpc0RlZmluZWQoZm9ybWF0KSkgZm9ybWF0ID0gJ2RhZy1jYm9yJ1xuICAgIGlmIChsb2cudmFsdWVzLmxlbmd0aCA8IDEpIHRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc2VyaWFsaXplIGFuIGVtcHR5IGxvZ2ApXG5cbiAgICByZXR1cm4gaW8ud3JpdGUoaXBmcywgZm9ybWF0LCBsb2cudG9KU09OKCksIHsgbGlua3M6IElQTERfTElOS1MgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsb2cgZnJvbSBhIGhhc2hlcy5cbiAgICogQHBhcmFtIHtJUEZTfSBpcGZzIEFuIElQRlMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggVGhlIGhhc2ggb2YgdGhlIGxvZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5sZW5ndGggSG93IG1hbnkgaXRlbXMgdG8gaW5jbHVkZSBpbiB0aGUgbG9nXG4gICAqIEBwYXJhbSB7QXJyYXk8RW50cnk+fSBvcHRpb25zLmV4Y2x1ZGUgRW50cmllcyB0byBub3QgZmV0Y2ggKGNhY2hlZClcbiAgICogQHBhcmFtIHtmdW5jdGlvbihoYXNoLCBlbnRyeSwgcGFyZW50LCBkZXB0aCl9IG9wdGlvbnMub25Qcm9ncmVzc0NhbGxiYWNrXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZnJvbU11bHRpaGFzaCAoaXBmcywgaGFzaCwgeyBsZW5ndGggPSAtMSwgZXhjbHVkZSwgb25Qcm9ncmVzc0NhbGxiYWNrLCB0aW1lb3V0IH0gPSB7fSkge1xuICAgIGlmICghaXNEZWZpbmVkKGlwZnMpKSB0aHJvdyBMb2dFcnJvci5JUEZTTm90RGVmaW5lZEVycm9yKClcbiAgICBpZiAoIWlzRGVmaW5lZChoYXNoKSkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhhc2g6ICR7aGFzaH1gKVxuXG4gICAgY29uc3QgbG9nRGF0YSA9IGF3YWl0IGlvLnJlYWQoaXBmcywgaGFzaCwgeyBsaW5rczogSVBMRF9MSU5LUyB9KVxuICAgIGlmICghbG9nRGF0YS5oZWFkcyB8fCAhbG9nRGF0YS5pZCkgdGhyb3cgTG9nRXJyb3IuTm90QUxvZ0Vycm9yKClcblxuICAgIGNvbnN0IGVudHJpZXMgPSBhd2FpdCBFbnRyeUlPLmZldGNoQWxsKGlwZnMsIGxvZ0RhdGEuaGVhZHMsXG4gICAgICB7IGxlbmd0aCwgZXhjbHVkZSwgb25Qcm9ncmVzc0NhbGxiYWNrLCB0aW1lb3V0IH0pXG5cbiAgICAvLyBGaW5kIGxhdGVzdCBjbG9ja1xuICAgIGNvbnN0IGNsb2NrID0gZW50cmllcy5yZWR1Y2UoKGNsb2NrLCBlbnRyeSkgPT4ge1xuICAgICAgaWYgKGVudHJ5LmNsb2NrLnRpbWUgPiBjbG9jay50aW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2xvY2soZW50cnkuY2xvY2suaWQsIGVudHJ5LmNsb2NrLnRpbWUpXG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvY2tcbiAgICB9LCBuZXcgQ2xvY2sobG9nRGF0YS5pZCkpXG5cbiAgICBjb25zdCBmaW5hbEVudHJpZXMgPSBlbnRyaWVzLnNsaWNlKCkuc29ydChFbnRyeS5jb21wYXJlKVxuICAgIGNvbnN0IGhlYWRzID0gZmluYWxFbnRyaWVzLmZpbHRlcihlID0+IGxvZ0RhdGEuaGVhZHMuaW5jbHVkZXMoZS5oYXNoKSlcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGxvZ0RhdGEuaWQsXG4gICAgICB2YWx1ZXM6IGZpbmFsRW50cmllcyxcbiAgICAgIGhlYWRzOiBoZWFkcyxcbiAgICAgIGNsb2NrOiBjbG9ja1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsb2cgZnJvbSBhbiBlbnRyeSBoYXNoLlxuICAgKiBAcGFyYW0ge0lQRlN9IGlwZnMgQW4gSVBGUyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBUaGUgaGFzaCBvZiB0aGUgZW50cnlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubGVuZ3RoIEhvdyBtYW55IGl0ZW1zIHRvIGluY2x1ZGUgaW4gdGhlIGxvZ1xuICAgKiBAcGFyYW0ge0FycmF5PEVudHJ5Pn0gb3B0aW9ucy5leGNsdWRlIEVudHJpZXMgdG8gbm90IGZldGNoIChjYWNoZWQpXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaGFzaCwgZW50cnksIHBhcmVudCwgZGVwdGgpfSBvcHRpb25zLm9uUHJvZ3Jlc3NDYWxsYmFja1xuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50aW1lb3V0IFRpbWVvdXQgZm9yIGZldGNoaW5nIGEgbG9nIGVudHJ5IGZyb20gSVBGU1xuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21FbnRyeUhhc2ggKGlwZnMsIGhhc2gsIHsgbGVuZ3RoID0gLTEsIGV4Y2x1ZGUsIG9uUHJvZ3Jlc3NDYWxsYmFjaywgdGltZW91dCB9KSB7XG4gICAgaWYgKCFpc0RlZmluZWQoaXBmcykpIHRocm93IExvZ0Vycm9yLklwZnNOb3REZWZpbmVkRXJyb3IoKVxuICAgIGlmICghaXNEZWZpbmVkKGhhc2gpKSB0aHJvdyBuZXcgRXJyb3IoXCInaGFzaCcgbXVzdCBiZSBkZWZpbmVkXCIpXG4gICAgLy8gQ29udmVydCBpbnB1dCBoYXNoKHMpIHRvIGFuIGFycmF5XG4gICAgY29uc3QgaGFzaGVzID0gQXJyYXkuaXNBcnJheShoYXNoKSA/IGhhc2ggOiBbaGFzaF1cbiAgICAvLyBGZXRjaCBnaXZlbiBsZW5ndGgsIHJldHVybiBzaXplIGF0IGxlYXN0IHRoZSBnaXZlbiBpbnB1dCBlbnRyaWVzXG4gICAgbGVuZ3RoID0gbGVuZ3RoID4gLTEgPyBNYXRoLm1heChsZW5ndGgsIDEpIDogbGVuZ3RoXG5cbiAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgRW50cnlJTy5mZXRjaFBhcmFsbGVsKGlwZnMsIGhhc2hlcyxcbiAgICAgIHsgbGVuZ3RoLCBleGNsdWRlLCBvblByb2dyZXNzQ2FsbGJhY2ssIHRpbWVvdXQgfSlcbiAgICAvLyBDYXAgdGhlIHJlc3VsdCBhdCB0aGUgcmlnaHQgc2l6ZSBieSB0YWtpbmcgdGhlIGxhc3QgbiBlbnRyaWVzLFxuICAgIC8vIG9yIGlmIGdpdmVuIGxlbmd0aCBpcyAtMSwgdGhlbiB0YWtlIGFsbFxuICAgIGNvbnN0IHNsaWNlZCA9IGxlbmd0aCA+IC0xID8gbGFzdChlbnRyaWVzLCBsZW5ndGgpIDogZW50cmllc1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZXM6IHNsaWNlZFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbG9nIGRhdGEgZnJvbSBhIEpTT04gb2JqZWN0LCB0byBiZSBwYXNzZWQgdG8gYSBMb2cgY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtJUEZTfSBpcGZzIEFuIElQRlMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtqc29ufSBqc29uIEEganNvbiBvYmplY3QgY29udGFpbmluZyB2YWxpZCBsb2cgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5sZW5ndGggSG93IG1hbnkgZW50cmllcyB0byBpbmNsdWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRpbWVvdXQgTWF4aW11bSB0aW1lIHRvIHdhaXQgZm9yIGVhY2ggZmV0Y2ggb3BlcmF0aW9uLCBpbiBtc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGhhc2gsIGVudHJ5LCBwYXJlbnQsIGRlcHRoKX0gb3B0aW9ucy5vblByb2dyZXNzQ2FsbGJhY2tcbiAgICoqL1xuICBzdGF0aWMgYXN5bmMgZnJvbUpTT04gKGlwZnMsIGpzb24sIHsgbGVuZ3RoID0gLTEsIHRpbWVvdXQsIG9uUHJvZ3Jlc3NDYWxsYmFjayB9KSB7XG4gICAgaWYgKCFpc0RlZmluZWQoaXBmcykpIHRocm93IExvZ0Vycm9yLklQRlNOb3REZWZpbmVkRXJyb3IoKVxuICAgIGNvbnN0IGhlYWRIYXNoZXMgPSBqc29uLmhlYWRzLm1hcChlID0+IGUuaGFzaClcbiAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgRW50cnlJTy5mZXRjaFBhcmFsbGVsKGlwZnMsIGhlYWRIYXNoZXMsXG4gICAgICB7IGxlbmd0aCwgZXhjbHVkZTogW10sIGNvbmN1cnJlbmN5OiAxNiwgdGltZW91dCwgb25Qcm9ncmVzc0NhbGxiYWNrIH0pXG4gICAgY29uc3QgZmluYWxFbnRyaWVzID0gZW50cmllcy5zbGljZSgpLnNvcnQoRW50cnkuY29tcGFyZSlcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGpzb24uaWQsXG4gICAgICB2YWx1ZXM6IGZpbmFsRW50cmllcyxcbiAgICAgIGhlYWRzOiBqc29uLmhlYWRzXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBsb2cgc3RhcnRpbmcgZnJvbSBhbiBlbnRyeS5cbiAgICogQHBhcmFtIHtJUEZTfSBpcGZzIEFuIElQRlMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtFbnRyeXxBcnJheTxFbnRyeT59IHNvdXJjZUVudHJpZXMgQW4gZW50cnkgb3IgYW4gYXJyYXkgb2YgZW50cmllcyB0byBmZXRjaCBhIGxvZyBmcm9tXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmxlbmd0aCBIb3cgbWFueSBlbnRyaWVzIHRvIGluY2x1ZGVcbiAgICogQHBhcmFtIHtBcnJheTxFbnRyeT59IG9wdGlvbnMuZXhjbHVkZSBFbnRyaWVzIHRvIG5vdCBmZXRjaCAoY2FjaGVkKVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGhhc2gsIGVudHJ5LCBwYXJlbnQsIGRlcHRoKX0gb3B0aW9ucy5vblByb2dyZXNzQ2FsbGJhY2tcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmcm9tRW50cnkgKGlwZnMsIHNvdXJjZUVudHJpZXMsIHsgbGVuZ3RoID0gLTEsIGV4Y2x1ZGUsIG9uUHJvZ3Jlc3NDYWxsYmFjaywgdGltZW91dCB9KSB7XG4gICAgaWYgKCFpc0RlZmluZWQoaXBmcykpIHRocm93IExvZ0Vycm9yLklQRlNOb3REZWZpbmVkRXJyb3IoKVxuICAgIGlmICghaXNEZWZpbmVkKHNvdXJjZUVudHJpZXMpKSB0aHJvdyBuZXcgRXJyb3IoXCInc291cmNlRW50cmllcycgbXVzdCBiZSBkZWZpbmVkXCIpXG5cbiAgICAvLyBNYWtlIHN1cmUgd2Ugb25seSBoYXZlIEVudHJ5IG9iamVjdHMgYXMgaW5wdXRcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc291cmNlRW50cmllcykgJiYgIUVudHJ5LmlzRW50cnkoc291cmNlRW50cmllcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJ3NvdXJjZUVudHJpZXMnIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkgb2YgRW50cnkgaW5zdGFuY2VzIG9yIGEgc2luZ2xlIEVudHJ5YClcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc291cmNlRW50cmllcykpIHtcbiAgICAgIHNvdXJjZUVudHJpZXMgPSBbc291cmNlRW50cmllc11cbiAgICB9XG5cbiAgICAvLyBGZXRjaCBnaXZlbiBsZW5ndGgsIHJldHVybiBzaXplIGF0IGxlYXN0IHRoZSBnaXZlbiBpbnB1dCBlbnRyaWVzXG4gICAgbGVuZ3RoID0gbGVuZ3RoID4gLTEgPyBNYXRoLm1heChsZW5ndGgsIHNvdXJjZUVudHJpZXMubGVuZ3RoKSA6IGxlbmd0aFxuXG4gICAgLy8gTWFrZSBzdXJlIHdlIHBhc3MgaGFzaGVzIGluc3RlYWQgb2Ygb2JqZWN0cyB0byB0aGUgZmV0Y2hlciBmdW5jdGlvblxuICAgIGNvbnN0IGhhc2hlcyA9IHNvdXJjZUVudHJpZXMubWFwKGUgPT4gZS5oYXNoKVxuXG4gICAgLy8gRmV0Y2ggdGhlIGVudHJpZXNcbiAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgRW50cnlJTy5mZXRjaFBhcmFsbGVsKGlwZnMsIGhhc2hlcyxcbiAgICAgIHsgbGVuZ3RoLCBleGNsdWRlLCBvblByb2dyZXNzQ2FsbGJhY2ssIHRpbWVvdXQgfSlcblxuICAgIC8vIENvbWJpbmUgdGhlIGZldGNoZXMgd2l0aCB0aGUgc291cmNlIGVudHJpZXMgYW5kIHRha2Ugb25seSB1bmlxdWVzXG4gICAgY29uc3QgY29tYmluZWQgPSBzb3VyY2VFbnRyaWVzLmNvbmNhdChlbnRyaWVzKVxuICAgIGNvbnN0IHVuaXF1ZXMgPSBmaW5kVW5pcXVlcyhjb21iaW5lZCwgJ2hhc2gnKS5zb3J0KEVudHJ5LmNvbXBhcmUpXG5cbiAgICAvLyBDYXAgdGhlIHJlc3VsdCBhdCB0aGUgcmlnaHQgc2l6ZSBieSB0YWtpbmcgdGhlIGxhc3QgbiBlbnRyaWVzXG4gICAgY29uc3Qgc2xpY2VkID0gdW5pcXVlcy5zbGljZShsZW5ndGggPiAtMSA/IC1sZW5ndGggOiAtdW5pcXVlcy5sZW5ndGgpXG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgZ2l2ZW4gaW5wdXQgZW50cmllcyBhcmUgcHJlc2VudCBpbiB0aGUgcmVzdWx0XG4gICAgLy8gaW4gb3JkZXIgdG8gbm90IGxvc2UgcmVmZXJlbmNlc1xuICAgIGNvbnN0IG1pc3NpbmdTb3VyY2VFbnRyaWVzID0gZGlmZmVyZW5jZShzbGljZWQsIHNvdXJjZUVudHJpZXMsICdoYXNoJylcblxuICAgIGNvbnN0IHJlcGxhY2VJbkZyb250ID0gKGEsIHdpdGhFbnRyaWVzKSA9PiB7XG4gICAgICB2YXIgc2xpY2VkID0gYS5zbGljZSh3aXRoRW50cmllcy5sZW5ndGgsIGEubGVuZ3RoKVxuICAgICAgcmV0dXJuIHdpdGhFbnRyaWVzLmNvbmNhdChzbGljZWQpXG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBpbnB1dCBlbnRyaWVzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGFuZCByZW1vdmVcbiAgICAvLyBhcyBtYW55IGVsZW1lbnRzIGZyb20gdGhlIGFycmF5IGJlZm9yZSBpbnNlcnRpbmcgdGhlIG9yaWdpbmFsIGVudHJpZXNcbiAgICBjb25zdCByZXN1bHQgPSByZXBsYWNlSW5Gcm9udChzbGljZWQsIG1pc3NpbmdTb3VyY2VFbnRyaWVzKVxuICAgIHJldHVybiB7XG4gICAgICBpZDogcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS5pZCxcbiAgICAgIHZhbHVlczogcmVzdWx0XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTG9nSU9cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBDbG9jayA9IHJlcXVpcmUoJy4vbGFtcG9ydC1jbG9jaycpXG5jb25zdCB7IGlzRGVmaW5lZCwgaW8gfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3Qgc3RyaW5naWZ5ID0gcmVxdWlyZSgnanNvbi1zdHJpbmdpZnktZGV0ZXJtaW5pc3RpYycpXG5jb25zdCBJUExEX0xJTktTID0gWyduZXh0J11cbmNvbnN0IElwZnNOb3REZWZpbmVkRXJyb3IgPSAoKSA9PiBuZXcgRXJyb3IoJ0lwZnMgaW5zdGFuY2Ugbm90IGRlZmluZWQnKVxuY29uc3Qgd3JpdGVGb3JtYXRzID0ge1xuICAwOiAnZGFnLXBiJyxcbiAgMTogJ2RhZy1jYm9yJ1xufVxuXG5jbGFzcyBFbnRyeSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gRW50cnlcbiAgICogQHBhcmFtIHtJUEZTfSBpcGZzIEFuIElQRlMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtJZGVudGl0eX0gaWRlbnRpdHkgVGhlIGlkZW50aXR5IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2dJZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgbG9nXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBEYXRhIG9mIHRoZSBlbnRyeSB0byBiZSBhZGRlZC4gQ2FuIGJlIGFueSBKU09OLnN0cmluZ2lmeWFibGUgZGF0YVxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xFbnRyeT59IFtuZXh0PVtdXSBQYXJlbnQgaGFzaGVzIG9yIGVudHJpZXNcbiAgICogQHBhcmFtIHtMYW1wb3J0Q2xvY2t9IFtjbG9ja10gVGhlIGxhbXBvcnQgY2xvY2tcbiAgICogQHJldHVybnMge1Byb21pc2U8RW50cnk+fVxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBlbnRyeSA9IGF3YWl0IEVudHJ5LmNyZWF0ZShpcGZzLCBpZGVudGl0eSwgJ2hlbGxvJylcbiAgICogY29uc29sZS5sb2coZW50cnkpXG4gICAqIC8vIHsgaGFzaDogbnVsbCwgcGF5bG9hZDogXCJoZWxsb1wiLCBuZXh0OiBbXSB9XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgY3JlYXRlIChpcGZzLCBpZGVudGl0eSwgbG9nSWQsIGRhdGEsIG5leHQgPSBbXSwgY2xvY2spIHtcbiAgICBpZiAoIWlzRGVmaW5lZChpcGZzKSkgdGhyb3cgSXBmc05vdERlZmluZWRFcnJvcigpXG4gICAgaWYgKCFpc0RlZmluZWQoaWRlbnRpdHkpKSB0aHJvdyBuZXcgRXJyb3IoJ0lkZW50aXR5IGlzIHJlcXVpcmVkLCBjYW5ub3QgY3JlYXRlIGVudHJ5JylcbiAgICBpZiAoIWlzRGVmaW5lZChsb2dJZCkpIHRocm93IG5ldyBFcnJvcignRW50cnkgcmVxdWlyZXMgYW4gaWQnKVxuICAgIGlmICghaXNEZWZpbmVkKGRhdGEpKSB0aHJvdyBuZXcgRXJyb3IoJ0VudHJ5IHJlcXVpcmVzIGRhdGEnKVxuICAgIGlmICghaXNEZWZpbmVkKG5leHQpIHx8ICFBcnJheS5pc0FycmF5KG5leHQpKSB0aHJvdyBuZXcgRXJyb3IoXCInbmV4dCcgYXJndW1lbnQgaXMgbm90IGFuIGFycmF5XCIpXG5cbiAgICAvLyBDbGVhbiB0aGUgbmV4dCBvYmplY3RzIGFuZCBjb252ZXJ0IHRvIGhhc2hlc1xuICAgIGNvbnN0IHRvRW50cnkgPSAoZSkgPT4gZS5oYXNoID8gZS5oYXNoIDogZVxuICAgIGNvbnN0IG5leHRzID0gbmV4dC5maWx0ZXIoaXNEZWZpbmVkKS5tYXAodG9FbnRyeSlcblxuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgaGFzaDogbnVsbCwgLy8gXCJ6ZC4uLkZvb1wiLCB3ZSdsbCBzZXQgdGhlIGhhc2ggYWZ0ZXIgcGVyc2lzdGluZyB0aGUgZW50cnlcbiAgICAgIGlkOiBsb2dJZCwgLy8gRm9yIGRldGVybWluaW5nIGEgdW5pcXVlIGNoYWluXG4gICAgICBwYXlsb2FkOiBkYXRhLCAvLyBDYW4gYmUgYW55IEpTT04uc3RyaW5naWZ5YWJsZSBkYXRhXG4gICAgICBuZXh0OiBuZXh0cywgLy8gQXJyYXkgb2YgaGFzaGVzXG4gICAgICB2OiAxLCAvLyBUbyB0YWcgdGhlIHZlcnNpb24gb2YgdGhpcyBkYXRhIHN0cnVjdHVyZVxuICAgICAgY2xvY2s6IGNsb2NrIHx8IG5ldyBDbG9jayhpZGVudGl0eS5wdWJsaWNLZXkpXG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgaWRlbnRpdHkucHJvdmlkZXIuc2lnbihpZGVudGl0eSwgRW50cnkudG9CdWZmZXIoZW50cnkpKVxuXG4gICAgZW50cnkua2V5ID0gaWRlbnRpdHkucHVibGljS2V5XG4gICAgZW50cnkuaWRlbnRpdHkgPSBpZGVudGl0eS50b0pTT04oKVxuICAgIGVudHJ5LnNpZyA9IHNpZ25hdHVyZVxuICAgIGVudHJ5Lmhhc2ggPSBhd2FpdCBFbnRyeS50b011bHRpaGFzaChpcGZzLCBlbnRyeSlcblxuICAgIHJldHVybiBlbnRyeVxuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIGFuIGVudHJ5IHNpZ25hdHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtJZGVudGl0eVByb3ZpZGVyfSBpZGVudGl0eVByb3ZpZGVyIFRoZSBpZGVudGl0eSBwcm92aWRlciB0byB1c2VcbiAgICogQHBhcmFtIHtFbnRyeX0gZW50cnkgVGhlIGVudHJ5IGJlaW5nIHZlcmlmaWVkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoZSBzaWduYXR1cmUgaXMgdmFsaWRcbiAgICovXG4gIHN0YXRpYyBhc3luYyB2ZXJpZnkgKGlkZW50aXR5UHJvdmlkZXIsIGVudHJ5KSB7XG4gICAgaWYgKCFpZGVudGl0eVByb3ZpZGVyKSB0aHJvdyBuZXcgRXJyb3IoJ0lkZW50aXR5LXByb3ZpZGVyIGlzIHJlcXVpcmVkLCBjYW5ub3QgdmVyaWZ5IGVudHJ5JylcbiAgICBpZiAoIUVudHJ5LmlzRW50cnkoZW50cnkpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTG9nIGVudHJ5JylcbiAgICBpZiAoIWVudHJ5LmtleSkgdGhyb3cgbmV3IEVycm9yKFwiRW50cnkgZG9lc24ndCBoYXZlIGEga2V5XCIpXG4gICAgaWYgKCFlbnRyeS5zaWcpIHRocm93IG5ldyBFcnJvcihcIkVudHJ5IGRvZXNuJ3QgaGF2ZSBhIHNpZ25hdHVyZVwiKVxuXG4gICAgY29uc3QgZSA9IHtcbiAgICAgIGhhc2g6IG51bGwsXG4gICAgICBpZDogZW50cnkuaWQsXG4gICAgICBwYXlsb2FkOiBlbnRyeS5wYXlsb2FkLFxuICAgICAgbmV4dDogZW50cnkubmV4dCxcbiAgICAgIHY6IGVudHJ5LnYsXG4gICAgICBjbG9jazogZW50cnkuY2xvY2tcbiAgICB9XG5cbiAgICByZXR1cm4gaWRlbnRpdHlQcm92aWRlci52ZXJpZnkoZW50cnkuc2lnLCBlbnRyeS5rZXksIEVudHJ5LnRvQnVmZmVyKGUpLCAndicgKyBlbnRyeS52KVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgYW4gZW50cnkgaW50byBhIEJ1ZmZlci5cbiAgICogQHBhcmFtIHtFbnRyeX0gZW50cnkgVGhlIGVudHJ5XG4gICAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGJ1ZmZlclxuICAgKi9cbiAgc3RhdGljIHRvQnVmZmVyIChlbnRyeSkge1xuICAgIGNvbnN0IHN0cmluZ2lmaWVkRW50cnkgPSBlbnRyeS52ID09PSAwID8gSlNPTi5zdHJpbmdpZnkoZW50cnkpIDogc3RyaW5naWZ5KGVudHJ5KVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHJpbmdpZmllZEVudHJ5KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbXVsdGloYXNoIG9mIGFuIEVudHJ5LlxuICAgKiBAcGFyYW0ge0lQRlN9IGlwZnMgQW4gSVBGUyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0VudHJ5fSBlbnRyeSBFbnRyeSB0byBnZXQgYSBtdWx0aWhhc2ggZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59XG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IG11bHRpaGFzaCA9IGF3YWl0IEVudHJ5LnRvTXVsdGloYXNoKGlwZnMsIGVudHJ5KVxuICAgKiBjb25zb2xlLmxvZyhtdWx0aWhhc2gpXG4gICAqIC8vIFwiUW0uLi5Gb29cIlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHRvTXVsdGloYXNoIChpcGZzLCBlbnRyeSkge1xuICAgIGlmICghaXBmcykgdGhyb3cgSXBmc05vdERlZmluZWRFcnJvcigpXG4gICAgaWYgKCFFbnRyeS5pc0VudHJ5KGVudHJ5KSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9iamVjdCBmb3JtYXQsIGNhbm5vdCBnZW5lcmF0ZSBlbnRyeSBoYXNoJylcblxuICAgIC8vIEVuc3VyZSBgZW50cnlgIGZvbGxvd3MgdGhlIGNvcnJlY3QgZm9ybWF0XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIGhhc2g6IG51bGwsXG4gICAgICBpZDogZW50cnkuaWQsXG4gICAgICBwYXlsb2FkOiBlbnRyeS5wYXlsb2FkLFxuICAgICAgbmV4dDogZW50cnkubmV4dCxcbiAgICAgIHY6IGVudHJ5LnYsXG4gICAgICBjbG9jazogZW50cnkuY2xvY2tcbiAgICB9XG5cbiAgICBpZiAoZW50cnkua2V5KSBPYmplY3QuYXNzaWduKGUsIHsga2V5OiBlbnRyeS5rZXkgfSlcbiAgICBpZiAoZW50cnkuaWRlbnRpdHkpIE9iamVjdC5hc3NpZ24oZSwgeyBpZGVudGl0eTogZW50cnkuaWRlbnRpdHkgfSlcbiAgICBpZiAoZW50cnkuc2lnKSBPYmplY3QuYXNzaWduKGUsIHsgc2lnOiBlbnRyeS5zaWcgfSlcblxuICAgIHJldHVybiBpby53cml0ZShpcGZzLCB3cml0ZUZvcm1hdHNbZS52XSwgZSwgeyBsaW5rczogSVBMRF9MSU5LUyB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBFbnRyeSBmcm9tIGEgaGFzaC5cbiAgICogQHBhcmFtIHtJUEZTfSBpcGZzIEFuIElQRlMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggVGhlIGhhc2ggdG8gY3JlYXRlIGFuIEVudHJ5IGZyb21cbiAgICogQHJldHVybnMge1Byb21pc2U8RW50cnk+fVxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBlbnRyeSA9IGF3YWl0IEVudHJ5LmZyb21NdWx0aWhhc2goaXBmcywgXCJ6ZC4uLkZvb1wiKVxuICAgKiBjb25zb2xlLmxvZyhlbnRyeSlcbiAgICogLy8geyBoYXNoOiBcIlpkLi4uRm9vXCIsIHBheWxvYWQ6IFwiaGVsbG9cIiwgbmV4dDogW10gfVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21NdWx0aWhhc2ggKGlwZnMsIGhhc2gpIHtcbiAgICBpZiAoIWlwZnMpIHRocm93IElwZnNOb3REZWZpbmVkRXJyb3IoKVxuICAgIGlmICghaGFzaCkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhhc2g6ICR7aGFzaH1gKVxuXG4gICAgY29uc3QgZSA9IGF3YWl0IGlvLnJlYWQoaXBmcywgaGFzaCwgeyBsaW5rczogSVBMRF9MSU5LUyB9KVxuXG4gICAgbGV0IGVudHJ5ID0ge1xuICAgICAgaGFzaDogaGFzaCxcbiAgICAgIGlkOiBlLmlkLFxuICAgICAgcGF5bG9hZDogZS5wYXlsb2FkLFxuICAgICAgbmV4dDogZS5uZXh0LFxuICAgICAgdjogZS52LFxuICAgICAgY2xvY2s6IG5ldyBDbG9jayhlLmNsb2NrLmlkLCBlLmNsb2NrLnRpbWUpXG4gICAgfVxuXG4gICAgaWYgKGUua2V5KSBPYmplY3QuYXNzaWduKGVudHJ5LCB7IGtleTogZS5rZXkgfSlcbiAgICBpZiAoZS5pZGVudGl0eSkgT2JqZWN0LmFzc2lnbihlbnRyeSwgeyBpZGVudGl0eTogZS5pZGVudGl0eSB9KVxuICAgIGlmIChlLnNpZykgT2JqZWN0LmFzc2lnbihlbnRyeSwgeyBzaWc6IGUuc2lnIH0pXG5cbiAgICByZXR1cm4gZW50cnlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYW4gRW50cnkuXG4gICAqIEBwYXJhbSB7RW50cnl9IG9ialxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0VudHJ5IChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5pZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBvYmoubmV4dCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBvYmoucGF5bG9hZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBvYmoudiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBvYmouaGFzaCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBvYmouY2xvY2sgIT09IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmVzIHR3byBlbnRyaWVzLlxuICAgKiBAcGFyYW0ge0VudHJ5fSBhXG4gICAqIEBwYXJhbSB7RW50cnl9IGJcbiAgICogQHJldHVybnMge251bWJlcn0gMSBpZiBhIGlzIGdyZWF0ZXIsIC0xIGlzIGIgaXMgZ3JlYXRlclxuICAgKi9cbiAgc3RhdGljIGNvbXBhcmUgKGEsIGIpIHtcbiAgICB2YXIgZGlzdGFuY2UgPSBDbG9jay5jb21wYXJlKGEuY2xvY2ssIGIuY2xvY2spXG4gICAgaWYgKGRpc3RhbmNlID09PSAwKSByZXR1cm4gYS5jbG9jay5pZCA8IGIuY2xvY2suaWQgPyAtMSA6IDFcbiAgICByZXR1cm4gZGlzdGFuY2VcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBlbnRyeSBlcXVhbHMgYW5vdGhlciBlbnRyeS5cbiAgICogQHBhcmFtIHtFbnRyeX0gYVxuICAgKiBAcGFyYW0ge0VudHJ5fSBiXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzRXF1YWwgKGEsIGIpIHtcbiAgICByZXR1cm4gYS5oYXNoID09PSBiLmhhc2hcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBlbnRyeSBpcyBhIHBhcmVudCB0byBhbm90aGVyIGVudHJ5LlxuICAgKiBAcGFyYW0ge0VudHJ5fSBlbnRyeTEgRW50cnkgdG8gY2hlY2tcbiAgICogQHBhcmFtIHtFbnRyeX0gZW50cnkyIFRoZSBwYXJlbnQgRW50cnlcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNQYXJlbnQgKGVudHJ5MSwgZW50cnkyKSB7XG4gICAgcmV0dXJuIGVudHJ5Mi5uZXh0LmluZGV4T2YoZW50cnkxLmhhc2gpID4gLTFcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGVudHJ5J3MgY2hpbGRyZW4gZnJvbSBhbiBBcnJheSBvZiBlbnRyaWVzLlxuICAgKiBSZXR1cm5zIGVudHJ5J3MgY2hpbGRyZW4gYXMgYW4gQXJyYXkgdXAgdG8gdGhlIGxhc3Qga25vdyBjaGlsZC5cbiAgICogQHBhcmFtIHtFbnRyeX0gZW50cnkgRW50cnkgZm9yIHdoaWNoIHRvIGZpbmQgdGhlIHBhcmVudHNcbiAgICogQHBhcmFtIHtBcnJheTxFbnRyeT59IHZhbHVlcyBFbnRyaWVzIHRvIHNlYXJjaCBwYXJlbnRzIGZyb21cbiAgICogQHJldHVybnMge0FycmF5PEVudHJ5Pn1cbiAgICovXG4gIHN0YXRpYyBmaW5kQ2hpbGRyZW4gKGVudHJ5LCB2YWx1ZXMpIHtcbiAgICB2YXIgc3RhY2sgPSBbXVxuICAgIHZhciBwYXJlbnQgPSB2YWx1ZXMuZmluZCgoZSkgPT4gRW50cnkuaXNQYXJlbnQoZW50cnksIGUpKVxuICAgIHZhciBwcmV2ID0gZW50cnlcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBzdGFjay5wdXNoKHBhcmVudClcbiAgICAgIHByZXYgPSBwYXJlbnRcbiAgICAgIHBhcmVudCA9IHZhbHVlcy5maW5kKChlKSA9PiBFbnRyeS5pc1BhcmVudChwcmV2LCBlKSlcbiAgICB9XG4gICAgc3RhY2sgPSBzdGFjay5zb3J0KChhLCBiKSA9PiBhLmNsb2NrLnRpbWUgPiBiLmNsb2NrLnRpbWUpXG4gICAgcmV0dXJuIHN0YWNrXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFbnRyeVxuIiwiLyoqXG4gKiBbanMtc2hhM117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2VtbjE3OC9qcy1zaGEzfVxuICpcbiAqIEB2ZXJzaW9uIDAuOC4wXG4gKiBAYXV0aG9yIENoZW4sIFlpLUN5dWFuIFtlbW4xNzhAZ21haWwuY29tXVxuICogQGNvcHlyaWdodCBDaGVuLCBZaS1DeXVhbiAyMDE1LTIwMThcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4vKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG4oZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIElOUFVUX0VSUk9SID0gJ2lucHV0IGlzIGludmFsaWQgdHlwZSc7XG4gIHZhciBGSU5BTElaRV9FUlJPUiA9ICdmaW5hbGl6ZSBhbHJlYWR5IGNhbGxlZCc7XG4gIHZhciBXSU5ET1cgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JztcbiAgdmFyIHJvb3QgPSBXSU5ET1cgPyB3aW5kb3cgOiB7fTtcbiAgaWYgKHJvb3QuSlNfU0hBM19OT19XSU5ET1cpIHtcbiAgICBXSU5ET1cgPSBmYWxzZTtcbiAgfVxuICB2YXIgV0VCX1dPUktFUiA9ICFXSU5ET1cgJiYgdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnO1xuICB2YXIgTk9ERV9KUyA9ICFyb290LkpTX1NIQTNfTk9fTk9ERV9KUyAmJiB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7XG4gIGlmIChOT0RFX0pTKSB7XG4gICAgcm9vdCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmIChXRUJfV09SS0VSKSB7XG4gICAgcm9vdCA9IHNlbGY7XG4gIH1cbiAgdmFyIENPTU1PTl9KUyA9ICFyb290LkpTX1NIQTNfTk9fQ09NTU9OX0pTICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzO1xuICB2YXIgQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kO1xuICB2YXIgQVJSQVlfQlVGRkVSID0gIXJvb3QuSlNfU0hBM19OT19BUlJBWV9CVUZGRVIgJiYgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIEhFWF9DSEFSUyA9ICcwMTIzNDU2Nzg5YWJjZGVmJy5zcGxpdCgnJyk7XG4gIHZhciBTSEFLRV9QQURESU5HID0gWzMxLCA3OTM2LCAyMDMxNjE2LCA1MjAwOTM2OTZdO1xuICB2YXIgQ1NIQUtFX1BBRERJTkcgPSBbNCwgMTAyNCwgMjYyMTQ0LCA2NzEwODg2NF07XG4gIHZhciBLRUNDQUtfUEFERElORyA9IFsxLCAyNTYsIDY1NTM2LCAxNjc3NzIxNl07XG4gIHZhciBQQURESU5HID0gWzYsIDE1MzYsIDM5MzIxNiwgMTAwNjYzMjk2XTtcbiAgdmFyIFNISUZUID0gWzAsIDgsIDE2LCAyNF07XG4gIHZhciBSQyA9IFsxLCAwLCAzMjg5OCwgMCwgMzI5MDYsIDIxNDc0ODM2NDgsIDIxNDc1MTY0MTYsIDIxNDc0ODM2NDgsIDMyOTA3LCAwLCAyMTQ3NDgzNjQ5LFxuICAgIDAsIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyNzc3LCAyMTQ3NDgzNjQ4LCAxMzgsIDAsIDEzNiwgMCwgMjE0NzUxNjQyNSwgMCxcbiAgICAyMTQ3NDgzNjU4LCAwLCAyMTQ3NTE2NTU1LCAwLCAxMzksIDIxNDc0ODM2NDgsIDMyOTA1LCAyMTQ3NDgzNjQ4LCAzMjc3MSxcbiAgICAyMTQ3NDgzNjQ4LCAzMjc3MCwgMjE0NzQ4MzY0OCwgMTI4LCAyMTQ3NDgzNjQ4LCAzMjc3OCwgMCwgMjE0NzQ4MzY1OCwgMjE0NzQ4MzY0OCxcbiAgICAyMTQ3NTE2NTQ1LCAyMTQ3NDgzNjQ4LCAzMjg5NiwgMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0OSwgMCwgMjE0NzUxNjQyNCwgMjE0NzQ4MzY0OF07XG4gIHZhciBCSVRTID0gWzIyNCwgMjU2LCAzODQsIDUxMl07XG4gIHZhciBTSEFLRV9CSVRTID0gWzEyOCwgMjU2XTtcbiAgdmFyIE9VVFBVVF9UWVBFUyA9IFsnaGV4JywgJ2J1ZmZlcicsICdhcnJheUJ1ZmZlcicsICdhcnJheScsICdkaWdlc3QnXTtcbiAgdmFyIENTSEFLRV9CWVRFUEFEID0ge1xuICAgICcxMjgnOiAxNjgsXG4gICAgJzI1Nic6IDEzNlxuICB9O1xuXG4gIGlmIChyb290LkpTX1NIQTNfTk9fTk9ERV9KUyB8fCAhQXJyYXkuaXNBcnJheSkge1xuICAgIEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChBUlJBWV9CVUZGRVIgJiYgKHJvb3QuSlNfU0hBM19OT19BUlJBWV9CVUZGRVJfSVNfVklFVyB8fCAhQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIEFycmF5QnVmZmVyLmlzVmlldyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmouYnVmZmVyICYmIG9iai5idWZmZXIuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyO1xuICAgIH07XG4gIH1cblxuICB2YXIgY3JlYXRlT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIGJpdHMpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVNoYWtlT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIG91dHB1dEJpdHMpIHtcbiAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUNzaGFrZU91dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBvdXRwdXRCaXRzLCBuLCBzKSB7XG4gICAgICByZXR1cm4gbWV0aG9kc1snY3NoYWtlJyArIGJpdHNdLnVwZGF0ZShtZXNzYWdlLCBvdXRwdXRCaXRzLCBuLCBzKVtvdXRwdXRUeXBlXSgpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUttYWNPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZywgb3V0cHV0VHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCBtZXNzYWdlLCBvdXRwdXRCaXRzLCBzKSB7XG4gICAgICByZXR1cm4gbWV0aG9kc1sna21hYycgKyBiaXRzXS51cGRhdGUoa2V5LCBtZXNzYWdlLCBvdXRwdXRCaXRzLCBzKVtvdXRwdXRUeXBlXSgpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZU91dHB1dE1ldGhvZHMgPSBmdW5jdGlvbiAobWV0aG9kLCBjcmVhdGVNZXRob2QsIGJpdHMsIHBhZGRpbmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE9VVFBVVF9UWVBFUy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHR5cGUgPSBPVVRQVVRfVFlQRVNbaV07XG4gICAgICBtZXRob2RbdHlwZV0gPSBjcmVhdGVNZXRob2QoYml0cywgcGFkZGluZywgdHlwZSk7XG4gICAgfVxuICAgIHJldHVybiBtZXRob2Q7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nKSB7XG4gICAgdmFyIG1ldGhvZCA9IGNyZWF0ZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7XG4gICAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIGJpdHMpO1xuICAgIH07XG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZSgpLnVwZGF0ZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBjcmVhdGVPdXRwdXRNZXRob2RzKG1ldGhvZCwgY3JlYXRlT3V0cHV0TWV0aG9kLCBiaXRzLCBwYWRkaW5nKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlU2hha2VNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xuICAgIHZhciBtZXRob2QgPSBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7XG4gICAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uIChvdXRwdXRCaXRzKSB7XG4gICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKTtcbiAgICB9O1xuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cykge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUob3V0cHV0Qml0cykudXBkYXRlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIGNyZWF0ZU91dHB1dE1ldGhvZHMobWV0aG9kLCBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZCwgYml0cywgcGFkZGluZyk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUNzaGFrZU1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nKSB7XG4gICAgdmFyIHcgPSBDU0hBS0VfQllURVBBRFtiaXRzXTtcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlQ3NoYWtlT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsICdoZXgnKTtcbiAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKG91dHB1dEJpdHMsIG4sIHMpIHtcbiAgICAgIGlmICghbiAmJiAhcykge1xuICAgICAgICByZXR1cm4gbWV0aG9kc1snc2hha2UnICsgYml0c10uY3JlYXRlKG91dHB1dEJpdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cykuYnl0ZXBhZChbbiwgc10sIHcpO1xuICAgICAgfVxuICAgIH07XG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvdXRwdXRCaXRzLCBuLCBzKSB7XG4gICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZShvdXRwdXRCaXRzLCBuLCBzKS51cGRhdGUobWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRlT3V0cHV0TWV0aG9kcyhtZXRob2QsIGNyZWF0ZUNzaGFrZU91dHB1dE1ldGhvZCwgYml0cywgcGFkZGluZyk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUttYWNNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xuICAgIHZhciB3ID0gQ1NIQUtFX0JZVEVQQURbYml0c107XG4gICAgdmFyIG1ldGhvZCA9IGNyZWF0ZUttYWNPdXRwdXRNZXRob2QoYml0cywgcGFkZGluZywgJ2hleCcpO1xuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAoa2V5LCBvdXRwdXRCaXRzLCBzKSB7XG4gICAgICByZXR1cm4gbmV3IEttYWMoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cykuYnl0ZXBhZChbJ0tNQUMnLCBzXSwgdykuYnl0ZXBhZChba2V5XSwgdyk7XG4gICAgfTtcbiAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24gKGtleSwgbWVzc2FnZSwgb3V0cHV0Qml0cywgcykge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUoa2V5LCBvdXRwdXRCaXRzLCBzKS51cGRhdGUobWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRlT3V0cHV0TWV0aG9kcyhtZXRob2QsIGNyZWF0ZUttYWNPdXRwdXRNZXRob2QsIGJpdHMsIHBhZGRpbmcpO1xuICB9O1xuXG4gIHZhciBhbGdvcml0aG1zID0gW1xuICAgIHsgbmFtZTogJ2tlY2NhaycsIHBhZGRpbmc6IEtFQ0NBS19QQURESU5HLCBiaXRzOiBCSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZU1ldGhvZCB9LFxuICAgIHsgbmFtZTogJ3NoYTMnLCBwYWRkaW5nOiBQQURESU5HLCBiaXRzOiBCSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZU1ldGhvZCB9LFxuICAgIHsgbmFtZTogJ3NoYWtlJywgcGFkZGluZzogU0hBS0VfUEFERElORywgYml0czogU0hBS0VfQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVTaGFrZU1ldGhvZCB9LFxuICAgIHsgbmFtZTogJ2NzaGFrZScsIHBhZGRpbmc6IENTSEFLRV9QQURESU5HLCBiaXRzOiBTSEFLRV9CSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZUNzaGFrZU1ldGhvZCB9LFxuICAgIHsgbmFtZTogJ2ttYWMnLCBwYWRkaW5nOiBDU0hBS0VfUEFERElORywgYml0czogU0hBS0VfQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVLbWFjTWV0aG9kIH1cbiAgXTtcblxuICB2YXIgbWV0aG9kcyA9IHt9LCBtZXRob2ROYW1lcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxnb3JpdGhtcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBhbGdvcml0aG0gPSBhbGdvcml0aG1zW2ldO1xuICAgIHZhciBiaXRzID0gYWxnb3JpdGhtLmJpdHM7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBiaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICB2YXIgbWV0aG9kTmFtZSA9IGFsZ29yaXRobS5uYW1lICsgJ18nICsgYml0c1tqXTtcbiAgICAgIG1ldGhvZE5hbWVzLnB1c2gobWV0aG9kTmFtZSk7XG4gICAgICBtZXRob2RzW21ldGhvZE5hbWVdID0gYWxnb3JpdGhtLmNyZWF0ZU1ldGhvZChiaXRzW2pdLCBhbGdvcml0aG0ucGFkZGluZyk7XG4gICAgICBpZiAoYWxnb3JpdGhtLm5hbWUgIT09ICdzaGEzJykge1xuICAgICAgICB2YXIgbmV3TWV0aG9kTmFtZSA9IGFsZ29yaXRobS5uYW1lICsgYml0c1tqXTtcbiAgICAgICAgbWV0aG9kTmFtZXMucHVzaChuZXdNZXRob2ROYW1lKTtcbiAgICAgICAgbWV0aG9kc1tuZXdNZXRob2ROYW1lXSA9IG1ldGhvZHNbbWV0aG9kTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gS2VjY2FrKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpIHtcbiAgICB0aGlzLmJsb2NrcyA9IFtdO1xuICAgIHRoaXMucyA9IFtdO1xuICAgIHRoaXMucGFkZGluZyA9IHBhZGRpbmc7XG4gICAgdGhpcy5vdXRwdXRCaXRzID0gb3V0cHV0Qml0cztcbiAgICB0aGlzLnJlc2V0ID0gdHJ1ZTtcbiAgICB0aGlzLmZpbmFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuYmxvY2sgPSAwO1xuICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgIHRoaXMuYmxvY2tDb3VudCA9ICgxNjAwIC0gKGJpdHMgPDwgMSkpID4+IDU7XG4gICAgdGhpcy5ieXRlQ291bnQgPSB0aGlzLmJsb2NrQ291bnQgPDwgMjtcbiAgICB0aGlzLm91dHB1dEJsb2NrcyA9IG91dHB1dEJpdHMgPj4gNTtcbiAgICB0aGlzLmV4dHJhQnl0ZXMgPSAob3V0cHV0Qml0cyAmIDMxKSA+PiAzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1MDsgKytpKSB7XG4gICAgICB0aGlzLnNbaV0gPSAwO1xuICAgIH1cbiAgfVxuXG4gIEtlY2Nhay5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihGSU5BTElaRV9FUlJPUik7XG4gICAgfVxuICAgIHZhciBub3RTdHJpbmcsIHR5cGUgPSB0eXBlb2YgbWVzc2FnZTtcbiAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICAgIH0gZWxzZSBpZiAoQVJSQVlfQlVGRkVSICYmIG1lc3NhZ2UuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgaWYgKCFBUlJBWV9CVUZGRVIgfHwgIUFycmF5QnVmZmVyLmlzVmlldyhtZXNzYWdlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICB9XG4gICAgICBub3RTdHJpbmcgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGJ5dGVDb3VudCA9IHRoaXMuYnl0ZUNvdW50LCBsZW5ndGggPSBtZXNzYWdlLmxlbmd0aCxcbiAgICAgIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIGluZGV4ID0gMCwgcyA9IHRoaXMucywgaSwgY29kZTtcblxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMucmVzZXQpIHtcbiAgICAgICAgdGhpcy5yZXNldCA9IGZhbHNlO1xuICAgICAgICBibG9ja3NbMF0gPSB0aGlzLmJsb2NrO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYmxvY2tDb3VudCArIDE7ICsraSkge1xuICAgICAgICAgIGJsb2Nrc1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub3RTdHJpbmcpIHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IGJ5dGVDb3VudDsgKytpbmRleCkge1xuICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9IG1lc3NhZ2VbaW5kZXhdIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgYnl0ZUNvdW50OyArK2luZGV4KSB7XG4gICAgICAgICAgY29kZSA9IG1lc3NhZ2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBjb2RlIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhjMCB8IChjb2RlID4+IDYpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhlMCB8IChjb2RlID4+IDEyKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUgPSAweDEwMDAwICsgKCgoY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAobWVzc2FnZS5jaGFyQ29kZUF0KCsraW5kZXgpICYgMHgzZmYpKTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGYwIHwgKGNvZGUgPj4gMTgpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDEyKSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdEJ5dGVJbmRleCA9IGk7XG4gICAgICBpZiAoaSA+PSBieXRlQ291bnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IGkgLSBieXRlQ291bnQ7XG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9ja3NbYmxvY2tDb3VudF07XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50OyArK2kpIHtcbiAgICAgICAgICBzW2ldIF49IGJsb2Nrc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBmKHMpO1xuICAgICAgICB0aGlzLnJlc2V0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh4LCByaWdodCkge1xuICAgIHZhciBvID0geCAmIDI1NSwgbiA9IDE7XG4gICAgdmFyIGJ5dGVzID0gW29dO1xuICAgIHggPSB4ID4+IDg7XG4gICAgbyA9IHggJiAyNTU7XG4gICAgd2hpbGUgKG8gPiAwKSB7XG4gICAgICBieXRlcy51bnNoaWZ0KG8pO1xuICAgICAgeCA9IHggPj4gODtcbiAgICAgIG8gPSB4ICYgMjU1O1xuICAgICAgKytuO1xuICAgIH1cbiAgICBpZiAocmlnaHQpIHtcbiAgICAgIGJ5dGVzLnB1c2gobik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ5dGVzLnVuc2hpZnQobik7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXMubGVuZ3RoO1xuICB9O1xuXG4gIEtlY2Nhay5wcm90b3R5cGUuZW5jb2RlU3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciBub3RTdHJpbmcsIHR5cGUgPSB0eXBlb2Ygc3RyO1xuICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChzdHIgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgICB9IGVsc2UgaWYgKEFSUkFZX0JVRkZFUiAmJiBzdHIuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgc3RyID0gbmV3IFVpbnQ4QXJyYXkoc3RyKTtcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShzdHIpKSB7XG4gICAgICAgICAgaWYgKCFBUlJBWV9CVUZGRVIgfHwgIUFycmF5QnVmZmVyLmlzVmlldyhzdHIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcbiAgICAgIH1cbiAgICAgIG5vdFN0cmluZyA9IHRydWU7XG4gICAgfVxuICAgIHZhciBieXRlcyA9IDAsIGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgaWYgKG5vdFN0cmluZykge1xuICAgICAgYnl0ZXMgPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlIDwgMHg4MCkge1xuICAgICAgICAgIGJ5dGVzICs9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgYnl0ZXMgKz0gMjtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgYnl0ZXMgKz0gMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweDNmZikpO1xuICAgICAgICAgIGJ5dGVzICs9IDQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYnl0ZXMgKz0gdGhpcy5lbmNvZGUoYnl0ZXMgKiA4KTtcbiAgICB0aGlzLnVwZGF0ZShzdHIpO1xuICAgIHJldHVybiBieXRlcztcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmJ5dGVwYWQgPSBmdW5jdGlvbiAoc3Rycywgdykge1xuICAgIHZhciBieXRlcyA9IHRoaXMuZW5jb2RlKHcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Rycy5sZW5ndGg7ICsraSkge1xuICAgICAgYnl0ZXMgKz0gdGhpcy5lbmNvZGVTdHJpbmcoc3Ryc1tpXSk7XG4gICAgfVxuICAgIHZhciBwYWRkaW5nQnl0ZXMgPSB3IC0gYnl0ZXMgJSB3O1xuICAgIHZhciB6ZXJvcyA9IFtdO1xuICAgIHplcm9zLmxlbmd0aCA9IHBhZGRpbmdCeXRlcztcbiAgICB0aGlzLnVwZGF0ZSh6ZXJvcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xuICAgIHZhciBibG9ja3MgPSB0aGlzLmJsb2NrcywgaSA9IHRoaXMubGFzdEJ5dGVJbmRleCwgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucztcbiAgICBibG9ja3NbaSA+PiAyXSB8PSB0aGlzLnBhZGRpbmdbaSAmIDNdO1xuICAgIGlmICh0aGlzLmxhc3RCeXRlSW5kZXggPT09IHRoaXMuYnl0ZUNvdW50KSB7XG4gICAgICBibG9ja3NbMF0gPSBibG9ja3NbYmxvY2tDb3VudF07XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgYmxvY2tDb3VudCArIDE7ICsraSkge1xuICAgICAgICBibG9ja3NbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBibG9ja3NbYmxvY2tDb3VudCAtIDFdIHw9IDB4ODAwMDAwMDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQ7ICsraSkge1xuICAgICAgc1tpXSBePSBibG9ja3NbaV07XG4gICAgfVxuICAgIGYocyk7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS50b1N0cmluZyA9IEtlY2Nhay5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zLCBvdXRwdXRCbG9ja3MgPSB0aGlzLm91dHB1dEJsb2NrcyxcbiAgICAgIGV4dHJhQnl0ZXMgPSB0aGlzLmV4dHJhQnl0ZXMsIGkgPSAwLCBqID0gMDtcbiAgICB2YXIgaGV4ID0gJycsIGJsb2NrO1xuICAgIHdoaWxlIChqIDwgb3V0cHV0QmxvY2tzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xuICAgICAgICBibG9jayA9IHNbaV07XG4gICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbYmxvY2sgJiAweDBGXSArXG4gICAgICAgICAgSEVYX0NIQVJTWyhibG9jayA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gOCkgJiAweDBGXSArXG4gICAgICAgICAgSEVYX0NIQVJTWyhibG9jayA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDI0KSAmIDB4MEZdO1xuICAgICAgfVxuICAgICAgaWYgKGogJSBibG9ja0NvdW50ID09PSAwKSB7XG4gICAgICAgIGYocyk7XG4gICAgICAgIGkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXh0cmFCeXRlcykge1xuICAgICAgYmxvY2sgPSBzW2ldO1xuICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1tibG9jayAmIDB4MEZdO1xuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAxKSB7XG4gICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiA4KSAmIDB4MEZdO1xuICAgICAgfVxuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAyKSB7XG4gICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiAxNikgJiAweDBGXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmFycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zLCBvdXRwdXRCbG9ja3MgPSB0aGlzLm91dHB1dEJsb2NrcyxcbiAgICAgIGV4dHJhQnl0ZXMgPSB0aGlzLmV4dHJhQnl0ZXMsIGkgPSAwLCBqID0gMDtcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLm91dHB1dEJpdHMgPj4gMztcbiAgICB2YXIgYnVmZmVyO1xuICAgIGlmIChleHRyYUJ5dGVzKSB7XG4gICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoKG91dHB1dEJsb2NrcyArIDEpIDw8IDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZXMpO1xuICAgIH1cbiAgICB2YXIgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICB3aGlsZSAoaiA8IG91dHB1dEJsb2Nrcykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQgJiYgaiA8IG91dHB1dEJsb2NrczsgKytpLCArK2opIHtcbiAgICAgICAgYXJyYXlbal0gPSBzW2ldO1xuICAgICAgfVxuICAgICAgaWYgKGogJSBibG9ja0NvdW50ID09PSAwKSB7XG4gICAgICAgIGYocyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChleHRyYUJ5dGVzKSB7XG4gICAgICBhcnJheVtpXSA9IHNbaV07XG4gICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoMCwgYnl0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9O1xuXG4gIEtlY2Nhay5wcm90b3R5cGUuYnVmZmVyID0gS2VjY2FrLnByb3RvdHlwZS5hcnJheUJ1ZmZlcjtcblxuICBLZWNjYWsucHJvdG90eXBlLmRpZ2VzdCA9IEtlY2Nhay5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuXG4gICAgdmFyIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnMsIG91dHB1dEJsb2NrcyA9IHRoaXMub3V0cHV0QmxvY2tzLFxuICAgICAgZXh0cmFCeXRlcyA9IHRoaXMuZXh0cmFCeXRlcywgaSA9IDAsIGogPSAwO1xuICAgIHZhciBhcnJheSA9IFtdLCBvZmZzZXQsIGJsb2NrO1xuICAgIHdoaWxlIChqIDwgb3V0cHV0QmxvY2tzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xuICAgICAgICBvZmZzZXQgPSBqIDw8IDI7XG4gICAgICAgIGJsb2NrID0gc1tpXTtcbiAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IGJsb2NrICYgMHhGRjtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSAoYmxvY2sgPj4gOCkgJiAweEZGO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyAyXSA9IChibG9jayA+PiAxNikgJiAweEZGO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyAzXSA9IChibG9jayA+PiAyNCkgJiAweEZGO1xuICAgICAgfVxuICAgICAgaWYgKGogJSBibG9ja0NvdW50ID09PSAwKSB7XG4gICAgICAgIGYocyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChleHRyYUJ5dGVzKSB7XG4gICAgICBvZmZzZXQgPSBqIDw8IDI7XG4gICAgICBibG9jayA9IHNbaV07XG4gICAgICBhcnJheVtvZmZzZXRdID0gYmxvY2sgJiAweEZGO1xuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAxKSB7XG4gICAgICAgIGFycmF5W29mZnNldCArIDFdID0gKGJsb2NrID4+IDgpICYgMHhGRjtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYUJ5dGVzID4gMikge1xuICAgICAgICBhcnJheVtvZmZzZXQgKyAyXSA9IChibG9jayA+PiAxNikgJiAweEZGO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH07XG5cbiAgZnVuY3Rpb24gS21hYyhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKSB7XG4gICAgS2VjY2FrLmNhbGwodGhpcywgYml0cywgcGFkZGluZywgb3V0cHV0Qml0cyk7XG4gIH1cblxuICBLbWFjLnByb3RvdHlwZSA9IG5ldyBLZWNjYWsoKTtcblxuICBLbWFjLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVuY29kZSh0aGlzLm91dHB1dEJpdHMsIHRydWUpO1xuICAgIHJldHVybiBLZWNjYWsucHJvdG90eXBlLmZpbmFsaXplLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgdmFyIGYgPSBmdW5jdGlvbiAocykge1xuICAgIHZhciBoLCBsLCBuLCBjMCwgYzEsIGMyLCBjMywgYzQsIGM1LCBjNiwgYzcsIGM4LCBjOSxcbiAgICAgIGIwLCBiMSwgYjIsIGIzLCBiNCwgYjUsIGI2LCBiNywgYjgsIGI5LCBiMTAsIGIxMSwgYjEyLCBiMTMsIGIxNCwgYjE1LCBiMTYsIGIxNyxcbiAgICAgIGIxOCwgYjE5LCBiMjAsIGIyMSwgYjIyLCBiMjMsIGIyNCwgYjI1LCBiMjYsIGIyNywgYjI4LCBiMjksIGIzMCwgYjMxLCBiMzIsIGIzMyxcbiAgICAgIGIzNCwgYjM1LCBiMzYsIGIzNywgYjM4LCBiMzksIGI0MCwgYjQxLCBiNDIsIGI0MywgYjQ0LCBiNDUsIGI0NiwgYjQ3LCBiNDgsIGI0OTtcbiAgICBmb3IgKG4gPSAwOyBuIDwgNDg7IG4gKz0gMikge1xuICAgICAgYzAgPSBzWzBdIF4gc1sxMF0gXiBzWzIwXSBeIHNbMzBdIF4gc1s0MF07XG4gICAgICBjMSA9IHNbMV0gXiBzWzExXSBeIHNbMjFdIF4gc1szMV0gXiBzWzQxXTtcbiAgICAgIGMyID0gc1syXSBeIHNbMTJdIF4gc1syMl0gXiBzWzMyXSBeIHNbNDJdO1xuICAgICAgYzMgPSBzWzNdIF4gc1sxM10gXiBzWzIzXSBeIHNbMzNdIF4gc1s0M107XG4gICAgICBjNCA9IHNbNF0gXiBzWzE0XSBeIHNbMjRdIF4gc1szNF0gXiBzWzQ0XTtcbiAgICAgIGM1ID0gc1s1XSBeIHNbMTVdIF4gc1syNV0gXiBzWzM1XSBeIHNbNDVdO1xuICAgICAgYzYgPSBzWzZdIF4gc1sxNl0gXiBzWzI2XSBeIHNbMzZdIF4gc1s0Nl07XG4gICAgICBjNyA9IHNbN10gXiBzWzE3XSBeIHNbMjddIF4gc1szN10gXiBzWzQ3XTtcbiAgICAgIGM4ID0gc1s4XSBeIHNbMThdIF4gc1syOF0gXiBzWzM4XSBeIHNbNDhdO1xuICAgICAgYzkgPSBzWzldIF4gc1sxOV0gXiBzWzI5XSBeIHNbMzldIF4gc1s0OV07XG5cbiAgICAgIGggPSBjOCBeICgoYzIgPDwgMSkgfCAoYzMgPj4+IDMxKSk7XG4gICAgICBsID0gYzkgXiAoKGMzIDw8IDEpIHwgKGMyID4+PiAzMSkpO1xuICAgICAgc1swXSBePSBoO1xuICAgICAgc1sxXSBePSBsO1xuICAgICAgc1sxMF0gXj0gaDtcbiAgICAgIHNbMTFdIF49IGw7XG4gICAgICBzWzIwXSBePSBoO1xuICAgICAgc1syMV0gXj0gbDtcbiAgICAgIHNbMzBdIF49IGg7XG4gICAgICBzWzMxXSBePSBsO1xuICAgICAgc1s0MF0gXj0gaDtcbiAgICAgIHNbNDFdIF49IGw7XG4gICAgICBoID0gYzAgXiAoKGM0IDw8IDEpIHwgKGM1ID4+PiAzMSkpO1xuICAgICAgbCA9IGMxIF4gKChjNSA8PCAxKSB8IChjNCA+Pj4gMzEpKTtcbiAgICAgIHNbMl0gXj0gaDtcbiAgICAgIHNbM10gXj0gbDtcbiAgICAgIHNbMTJdIF49IGg7XG4gICAgICBzWzEzXSBePSBsO1xuICAgICAgc1syMl0gXj0gaDtcbiAgICAgIHNbMjNdIF49IGw7XG4gICAgICBzWzMyXSBePSBoO1xuICAgICAgc1szM10gXj0gbDtcbiAgICAgIHNbNDJdIF49IGg7XG4gICAgICBzWzQzXSBePSBsO1xuICAgICAgaCA9IGMyIF4gKChjNiA8PCAxKSB8IChjNyA+Pj4gMzEpKTtcbiAgICAgIGwgPSBjMyBeICgoYzcgPDwgMSkgfCAoYzYgPj4+IDMxKSk7XG4gICAgICBzWzRdIF49IGg7XG4gICAgICBzWzVdIF49IGw7XG4gICAgICBzWzE0XSBePSBoO1xuICAgICAgc1sxNV0gXj0gbDtcbiAgICAgIHNbMjRdIF49IGg7XG4gICAgICBzWzI1XSBePSBsO1xuICAgICAgc1szNF0gXj0gaDtcbiAgICAgIHNbMzVdIF49IGw7XG4gICAgICBzWzQ0XSBePSBoO1xuICAgICAgc1s0NV0gXj0gbDtcbiAgICAgIGggPSBjNCBeICgoYzggPDwgMSkgfCAoYzkgPj4+IDMxKSk7XG4gICAgICBsID0gYzUgXiAoKGM5IDw8IDEpIHwgKGM4ID4+PiAzMSkpO1xuICAgICAgc1s2XSBePSBoO1xuICAgICAgc1s3XSBePSBsO1xuICAgICAgc1sxNl0gXj0gaDtcbiAgICAgIHNbMTddIF49IGw7XG4gICAgICBzWzI2XSBePSBoO1xuICAgICAgc1syN10gXj0gbDtcbiAgICAgIHNbMzZdIF49IGg7XG4gICAgICBzWzM3XSBePSBsO1xuICAgICAgc1s0Nl0gXj0gaDtcbiAgICAgIHNbNDddIF49IGw7XG4gICAgICBoID0gYzYgXiAoKGMwIDw8IDEpIHwgKGMxID4+PiAzMSkpO1xuICAgICAgbCA9IGM3IF4gKChjMSA8PCAxKSB8IChjMCA+Pj4gMzEpKTtcbiAgICAgIHNbOF0gXj0gaDtcbiAgICAgIHNbOV0gXj0gbDtcbiAgICAgIHNbMThdIF49IGg7XG4gICAgICBzWzE5XSBePSBsO1xuICAgICAgc1syOF0gXj0gaDtcbiAgICAgIHNbMjldIF49IGw7XG4gICAgICBzWzM4XSBePSBoO1xuICAgICAgc1szOV0gXj0gbDtcbiAgICAgIHNbNDhdIF49IGg7XG4gICAgICBzWzQ5XSBePSBsO1xuXG4gICAgICBiMCA9IHNbMF07XG4gICAgICBiMSA9IHNbMV07XG4gICAgICBiMzIgPSAoc1sxMV0gPDwgNCkgfCAoc1sxMF0gPj4+IDI4KTtcbiAgICAgIGIzMyA9IChzWzEwXSA8PCA0KSB8IChzWzExXSA+Pj4gMjgpO1xuICAgICAgYjE0ID0gKHNbMjBdIDw8IDMpIHwgKHNbMjFdID4+PiAyOSk7XG4gICAgICBiMTUgPSAoc1syMV0gPDwgMykgfCAoc1syMF0gPj4+IDI5KTtcbiAgICAgIGI0NiA9IChzWzMxXSA8PCA5KSB8IChzWzMwXSA+Pj4gMjMpO1xuICAgICAgYjQ3ID0gKHNbMzBdIDw8IDkpIHwgKHNbMzFdID4+PiAyMyk7XG4gICAgICBiMjggPSAoc1s0MF0gPDwgMTgpIHwgKHNbNDFdID4+PiAxNCk7XG4gICAgICBiMjkgPSAoc1s0MV0gPDwgMTgpIHwgKHNbNDBdID4+PiAxNCk7XG4gICAgICBiMjAgPSAoc1syXSA8PCAxKSB8IChzWzNdID4+PiAzMSk7XG4gICAgICBiMjEgPSAoc1szXSA8PCAxKSB8IChzWzJdID4+PiAzMSk7XG4gICAgICBiMiA9IChzWzEzXSA8PCAxMikgfCAoc1sxMl0gPj4+IDIwKTtcbiAgICAgIGIzID0gKHNbMTJdIDw8IDEyKSB8IChzWzEzXSA+Pj4gMjApO1xuICAgICAgYjM0ID0gKHNbMjJdIDw8IDEwKSB8IChzWzIzXSA+Pj4gMjIpO1xuICAgICAgYjM1ID0gKHNbMjNdIDw8IDEwKSB8IChzWzIyXSA+Pj4gMjIpO1xuICAgICAgYjE2ID0gKHNbMzNdIDw8IDEzKSB8IChzWzMyXSA+Pj4gMTkpO1xuICAgICAgYjE3ID0gKHNbMzJdIDw8IDEzKSB8IChzWzMzXSA+Pj4gMTkpO1xuICAgICAgYjQ4ID0gKHNbNDJdIDw8IDIpIHwgKHNbNDNdID4+PiAzMCk7XG4gICAgICBiNDkgPSAoc1s0M10gPDwgMikgfCAoc1s0Ml0gPj4+IDMwKTtcbiAgICAgIGI0MCA9IChzWzVdIDw8IDMwKSB8IChzWzRdID4+PiAyKTtcbiAgICAgIGI0MSA9IChzWzRdIDw8IDMwKSB8IChzWzVdID4+PiAyKTtcbiAgICAgIGIyMiA9IChzWzE0XSA8PCA2KSB8IChzWzE1XSA+Pj4gMjYpO1xuICAgICAgYjIzID0gKHNbMTVdIDw8IDYpIHwgKHNbMTRdID4+PiAyNik7XG4gICAgICBiNCA9IChzWzI1XSA8PCAxMSkgfCAoc1syNF0gPj4+IDIxKTtcbiAgICAgIGI1ID0gKHNbMjRdIDw8IDExKSB8IChzWzI1XSA+Pj4gMjEpO1xuICAgICAgYjM2ID0gKHNbMzRdIDw8IDE1KSB8IChzWzM1XSA+Pj4gMTcpO1xuICAgICAgYjM3ID0gKHNbMzVdIDw8IDE1KSB8IChzWzM0XSA+Pj4gMTcpO1xuICAgICAgYjE4ID0gKHNbNDVdIDw8IDI5KSB8IChzWzQ0XSA+Pj4gMyk7XG4gICAgICBiMTkgPSAoc1s0NF0gPDwgMjkpIHwgKHNbNDVdID4+PiAzKTtcbiAgICAgIGIxMCA9IChzWzZdIDw8IDI4KSB8IChzWzddID4+PiA0KTtcbiAgICAgIGIxMSA9IChzWzddIDw8IDI4KSB8IChzWzZdID4+PiA0KTtcbiAgICAgIGI0MiA9IChzWzE3XSA8PCAyMykgfCAoc1sxNl0gPj4+IDkpO1xuICAgICAgYjQzID0gKHNbMTZdIDw8IDIzKSB8IChzWzE3XSA+Pj4gOSk7XG4gICAgICBiMjQgPSAoc1syNl0gPDwgMjUpIHwgKHNbMjddID4+PiA3KTtcbiAgICAgIGIyNSA9IChzWzI3XSA8PCAyNSkgfCAoc1syNl0gPj4+IDcpO1xuICAgICAgYjYgPSAoc1szNl0gPDwgMjEpIHwgKHNbMzddID4+PiAxMSk7XG4gICAgICBiNyA9IChzWzM3XSA8PCAyMSkgfCAoc1szNl0gPj4+IDExKTtcbiAgICAgIGIzOCA9IChzWzQ3XSA8PCAyNCkgfCAoc1s0Nl0gPj4+IDgpO1xuICAgICAgYjM5ID0gKHNbNDZdIDw8IDI0KSB8IChzWzQ3XSA+Pj4gOCk7XG4gICAgICBiMzAgPSAoc1s4XSA8PCAyNykgfCAoc1s5XSA+Pj4gNSk7XG4gICAgICBiMzEgPSAoc1s5XSA8PCAyNykgfCAoc1s4XSA+Pj4gNSk7XG4gICAgICBiMTIgPSAoc1sxOF0gPDwgMjApIHwgKHNbMTldID4+PiAxMik7XG4gICAgICBiMTMgPSAoc1sxOV0gPDwgMjApIHwgKHNbMThdID4+PiAxMik7XG4gICAgICBiNDQgPSAoc1syOV0gPDwgNykgfCAoc1syOF0gPj4+IDI1KTtcbiAgICAgIGI0NSA9IChzWzI4XSA8PCA3KSB8IChzWzI5XSA+Pj4gMjUpO1xuICAgICAgYjI2ID0gKHNbMzhdIDw8IDgpIHwgKHNbMzldID4+PiAyNCk7XG4gICAgICBiMjcgPSAoc1szOV0gPDwgOCkgfCAoc1szOF0gPj4+IDI0KTtcbiAgICAgIGI4ID0gKHNbNDhdIDw8IDE0KSB8IChzWzQ5XSA+Pj4gMTgpO1xuICAgICAgYjkgPSAoc1s0OV0gPDwgMTQpIHwgKHNbNDhdID4+PiAxOCk7XG5cbiAgICAgIHNbMF0gPSBiMCBeICh+YjIgJiBiNCk7XG4gICAgICBzWzFdID0gYjEgXiAofmIzICYgYjUpO1xuICAgICAgc1sxMF0gPSBiMTAgXiAofmIxMiAmIGIxNCk7XG4gICAgICBzWzExXSA9IGIxMSBeICh+YjEzICYgYjE1KTtcbiAgICAgIHNbMjBdID0gYjIwIF4gKH5iMjIgJiBiMjQpO1xuICAgICAgc1syMV0gPSBiMjEgXiAofmIyMyAmIGIyNSk7XG4gICAgICBzWzMwXSA9IGIzMCBeICh+YjMyICYgYjM0KTtcbiAgICAgIHNbMzFdID0gYjMxIF4gKH5iMzMgJiBiMzUpO1xuICAgICAgc1s0MF0gPSBiNDAgXiAofmI0MiAmIGI0NCk7XG4gICAgICBzWzQxXSA9IGI0MSBeICh+YjQzICYgYjQ1KTtcbiAgICAgIHNbMl0gPSBiMiBeICh+YjQgJiBiNik7XG4gICAgICBzWzNdID0gYjMgXiAofmI1ICYgYjcpO1xuICAgICAgc1sxMl0gPSBiMTIgXiAofmIxNCAmIGIxNik7XG4gICAgICBzWzEzXSA9IGIxMyBeICh+YjE1ICYgYjE3KTtcbiAgICAgIHNbMjJdID0gYjIyIF4gKH5iMjQgJiBiMjYpO1xuICAgICAgc1syM10gPSBiMjMgXiAofmIyNSAmIGIyNyk7XG4gICAgICBzWzMyXSA9IGIzMiBeICh+YjM0ICYgYjM2KTtcbiAgICAgIHNbMzNdID0gYjMzIF4gKH5iMzUgJiBiMzcpO1xuICAgICAgc1s0Ml0gPSBiNDIgXiAofmI0NCAmIGI0Nik7XG4gICAgICBzWzQzXSA9IGI0MyBeICh+YjQ1ICYgYjQ3KTtcbiAgICAgIHNbNF0gPSBiNCBeICh+YjYgJiBiOCk7XG4gICAgICBzWzVdID0gYjUgXiAofmI3ICYgYjkpO1xuICAgICAgc1sxNF0gPSBiMTQgXiAofmIxNiAmIGIxOCk7XG4gICAgICBzWzE1XSA9IGIxNSBeICh+YjE3ICYgYjE5KTtcbiAgICAgIHNbMjRdID0gYjI0IF4gKH5iMjYgJiBiMjgpO1xuICAgICAgc1syNV0gPSBiMjUgXiAofmIyNyAmIGIyOSk7XG4gICAgICBzWzM0XSA9IGIzNCBeICh+YjM2ICYgYjM4KTtcbiAgICAgIHNbMzVdID0gYjM1IF4gKH5iMzcgJiBiMzkpO1xuICAgICAgc1s0NF0gPSBiNDQgXiAofmI0NiAmIGI0OCk7XG4gICAgICBzWzQ1XSA9IGI0NSBeICh+YjQ3ICYgYjQ5KTtcbiAgICAgIHNbNl0gPSBiNiBeICh+YjggJiBiMCk7XG4gICAgICBzWzddID0gYjcgXiAofmI5ICYgYjEpO1xuICAgICAgc1sxNl0gPSBiMTYgXiAofmIxOCAmIGIxMCk7XG4gICAgICBzWzE3XSA9IGIxNyBeICh+YjE5ICYgYjExKTtcbiAgICAgIHNbMjZdID0gYjI2IF4gKH5iMjggJiBiMjApO1xuICAgICAgc1syN10gPSBiMjcgXiAofmIyOSAmIGIyMSk7XG4gICAgICBzWzM2XSA9IGIzNiBeICh+YjM4ICYgYjMwKTtcbiAgICAgIHNbMzddID0gYjM3IF4gKH5iMzkgJiBiMzEpO1xuICAgICAgc1s0Nl0gPSBiNDYgXiAofmI0OCAmIGI0MCk7XG4gICAgICBzWzQ3XSA9IGI0NyBeICh+YjQ5ICYgYjQxKTtcbiAgICAgIHNbOF0gPSBiOCBeICh+YjAgJiBiMik7XG4gICAgICBzWzldID0gYjkgXiAofmIxICYgYjMpO1xuICAgICAgc1sxOF0gPSBiMTggXiAofmIxMCAmIGIxMik7XG4gICAgICBzWzE5XSA9IGIxOSBeICh+YjExICYgYjEzKTtcbiAgICAgIHNbMjhdID0gYjI4IF4gKH5iMjAgJiBiMjIpO1xuICAgICAgc1syOV0gPSBiMjkgXiAofmIyMSAmIGIyMyk7XG4gICAgICBzWzM4XSA9IGIzOCBeICh+YjMwICYgYjMyKTtcbiAgICAgIHNbMzldID0gYjM5IF4gKH5iMzEgJiBiMzMpO1xuICAgICAgc1s0OF0gPSBiNDggXiAofmI0MCAmIGI0Mik7XG4gICAgICBzWzQ5XSA9IGI0OSBeICh+YjQxICYgYjQzKTtcblxuICAgICAgc1swXSBePSBSQ1tuXTtcbiAgICAgIHNbMV0gXj0gUkNbbiArIDFdO1xuICAgIH1cbiAgfTtcblxuICBpZiAoQ09NTU9OX0pTKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtZXRob2RzO1xuICB9IGVsc2Uge1xuICAgIGZvciAoaSA9IDA7IGkgPCBtZXRob2ROYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgcm9vdFttZXRob2ROYW1lc1tpXV0gPSBtZXRob2RzW21ldGhvZE5hbWVzW2ldXTtcbiAgICB9XG4gICAgaWYgKEFNRCkge1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZHM7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ2xvYmFsT2JqZWN0O1xudmFyIFJFR0lTVFJZO1xuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSB7XG4gICAgZ2xvYmFsT2JqZWN0ID0gd2luZG93O1xufVxuZWxzZSBpZiAodHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCcpIHtcbiAgICBnbG9iYWxPYmplY3QgPSBnbG9iYWw7XG59XG5lbHNlIHtcbiAgICBnbG9iYWxPYmplY3QgPSB7XG4gICAgICAgIERJRF9SRUdJU1RSWToge31cbiAgICB9O1xufVxuaWYgKGdsb2JhbE9iamVjdC5ESURfUkVHSVNUUlkpIHtcbiAgICBSRUdJU1RSWSA9IGdsb2JhbE9iamVjdC5ESURfUkVHSVNUUlk7XG59XG5lbHNlIHtcbiAgICBSRUdJU1RSWSA9IGdsb2JhbE9iamVjdC5ESURfUkVHSVNUUlkgPSB7fTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyTWV0aG9kKG1ldGhvZCwgcmVzb2x2ZXIpIHtcbiAgICBSRUdJU1RSWVttZXRob2RdID0gcmVzb2x2ZXI7XG59XG5leHBvcnRzLnJlZ2lzdGVyTWV0aG9kID0gcmVnaXN0ZXJNZXRob2Q7XG5mdW5jdGlvbiBwYXJzZShkaWQpIHtcbiAgICBpZiAoZGlkID09PSAnJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIERJRCcpO1xuICAgIHZhciBzZWN0aW9ucyA9IGRpZC5tYXRjaCgvXmRpZDooW2EtekEtWjAtOV9dKyk6KFtbYS16QS1aMC05Xy4tXSspKFxcL1teI10qKT8oIy4qKT8kLyk7XG4gICAgaWYgKHNlY3Rpb25zKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHsgZGlkOiBzZWN0aW9uc1swXSwgbWV0aG9kOiBzZWN0aW9uc1sxXSwgaWQ6IHNlY3Rpb25zWzJdIH07XG4gICAgICAgIGlmIChzZWN0aW9uc1szXSlcbiAgICAgICAgICAgIHBhcnRzLnBhdGggPSBzZWN0aW9uc1szXTtcbiAgICAgICAgaWYgKHNlY3Rpb25zWzRdKVxuICAgICAgICAgICAgcGFydHMuZnJhZ21lbnQgPSBzZWN0aW9uc1s0XS5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIERJRCBcIiArIGRpZCk7XG59XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5mdW5jdGlvbiByZXNvbHZlKGRpZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcnNlZCwgcmVzb2x2ZXI7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IHBhcnNlKGRpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVyID0gUkVHSVNUUllbcGFyc2VkLm1ldGhvZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZXIpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNvbHZlcihkaWQsIHBhcnNlZCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOiB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBESUQgbWV0aG9kOiAnXCIgKyBwYXJzZWQubWV0aG9kICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHJlc29sdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoQykgMjAxNiBEbWl0cnkgQ2hlc3RueWtoXG4vLyBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBmb3IgZGV0YWlscy5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBJTlZBTElEX1VURjE2ID0gXCJ1dGY4OiBpbnZhbGlkIHN0cmluZ1wiO1xudmFyIElOVkFMSURfVVRGOCA9IFwidXRmODogaW52YWxpZCBzb3VyY2UgZW5jb2RpbmdcIjtcbi8qKlxuICogRW5jb2RlcyB0aGUgZ2l2ZW4gc3RyaW5nIGludG8gVVRGLTggYnl0ZSBhcnJheS5cbiAqIFRocm93cyBpZiB0aGUgc291cmNlIHN0cmluZyBoYXMgaW52YWxpZCBVVEYtMTYgZW5jb2RpbmcuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShzKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHJlc3VsdCBsZW5ndGggYW5kIGFsbG9jYXRlIG91dHB1dCBhcnJheS5cbiAgICAvLyBlbmNvZGVkTGVuZ3RoKCkgYWxzbyB2YWxpZGF0ZXMgc3RyaW5nIGFuZCB0aHJvd3MgZXJyb3JzLFxuICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgcmVwZWF0IHZhbGlkYXRpb24gaGVyZS5cbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZExlbmd0aChzKSk7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4YzAgfCBjID4+IDY7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHg4MCB8IGMgJiAweDNmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweGQ4MDApIHtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweGUwIHwgYyA+PiAxMjtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgKGMgPj4gNikgJiAweDNmO1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ODAgfCBjICYgMHgzZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGkrKzsgLy8gZ2V0IG9uZSBtb3JlIGNoYXJhY3RlclxuICAgICAgICAgICAgYyA9IChjICYgMHgzZmYpIDw8IDEwO1xuICAgICAgICAgICAgYyB8PSBzLmNoYXJDb2RlQXQoaSkgJiAweDNmZjtcbiAgICAgICAgICAgIGMgKz0gMHgxMDAwMDtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweGYwIHwgYyA+PiAxODtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgKGMgPj4gMTIpICYgMHgzZjtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgKGMgPj4gNikgJiAweDNmO1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ODAgfCBjICYgMHgzZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byBlbmNvZGUgdGhlIGdpdmVuIHN0cmluZyBpbnRvIFVURi04LlxuICogVGhyb3dzIGlmIHRoZSBzb3VyY2Ugc3RyaW5nIGhhcyBpbnZhbGlkIFVURi0xNiBlbmNvZGluZy5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlZExlbmd0aChzKSB7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ZDgwMCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgIGlmIChpID49IHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKzsgLy8gXCJlYXRcIiBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgcmVzdWx0ICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEYxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZW5jb2RlZExlbmd0aCA9IGVuY29kZWRMZW5ndGg7XG4vKipcbiAqIERlY29kZXMgdGhlIGdpdmVuIGJ5dGUgYXJyYXkgZnJvbSBVVEYtOCBpbnRvIGEgc3RyaW5nLlxuICogVGhyb3dzIGlmIGVuY29kaW5nIGlzIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShhcnIpIHtcbiAgICB2YXIgY2hhcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYiA9IGFycltpXTtcbiAgICAgICAgaWYgKGIgJiAweDgwKSB7XG4gICAgICAgICAgICB2YXIgbWluID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGIgPCAweGUwKSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCAxIG1vcmUgYnl0ZS5cbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbjEgPSBhcnJbKytpXTtcbiAgICAgICAgICAgICAgICBpZiAoKG4xICYgMHhjMCkgIT09IDB4ODApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGIgPSAoYiAmIDB4MWYpIDw8IDYgfCAobjEgJiAweDNmKTtcbiAgICAgICAgICAgICAgICBtaW4gPSAweDgwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiA8IDB4ZjApIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIDIgbW9yZSBieXRlcy5cbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBhcnIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG4xID0gYXJyWysraV07XG4gICAgICAgICAgICAgICAgdmFyIG4yID0gYXJyWysraV07XG4gICAgICAgICAgICAgICAgaWYgKChuMSAmIDB4YzApICE9PSAweDgwIHx8IChuMiAmIDB4YzApICE9PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiID0gKGIgJiAweDBmKSA8PCAxMiB8IChuMSAmIDB4M2YpIDw8IDYgfCAobjIgJiAweDNmKTtcbiAgICAgICAgICAgICAgICBtaW4gPSAweDgwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgPCAweGY4KSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCAzIG1vcmUgYnl0ZXMuXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gYXJyLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuMSA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIHZhciBuMiA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIHZhciBuMyA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIGlmICgobjEgJiAweGMwKSAhPT0gMHg4MCB8fCAobjIgJiAweGMwKSAhPT0gMHg4MCB8fCAobjMgJiAweGMwKSAhPT0gMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYiA9IChiICYgMHgwZikgPDwgMTggfCAobjEgJiAweDNmKSA8PCAxMiB8IChuMiAmIDB4M2YpIDw8IDYgfCAobjMgJiAweDNmKTtcbiAgICAgICAgICAgICAgICBtaW4gPSAweDEwMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYiA8IG1pbiB8fCAoYiA+PSAweGQ4MDAgJiYgYiA8PSAweGRmZmYpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYiA+PSAweDEwMDAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU3Vycm9nYXRlIHBhaXIuXG4gICAgICAgICAgICAgICAgaWYgKGIgPiAweDEwZmZmZikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYiAtPSAweDEwMDAwO1xuICAgICAgICAgICAgICAgIGNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MDAgfCAoYiA+PiAxMCkpKTtcbiAgICAgICAgICAgICAgICBiID0gMHhkYzAwIHwgKGIgJiAweDNmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oXCJcIik7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0ZjguanMubWFwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvYmFzZTY0dXJsJykuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cztcbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgSWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JylcbmNvbnN0IE9yYml0REJJZGVudGl0eVByb3ZpZGVyID0gcmVxdWlyZSgnLi9vcmJpdC1kYi1pZGVudGl0eS1wcm92aWRlcicpXG5jb25zdCBLZXlzdG9yZSA9IHJlcXVpcmUoJ29yYml0LWRiLWtleXN0b3JlJylcbmNvbnN0IHR5cGUgPSAnb3JiaXRkYidcbmNvbnN0IGlkZW50aXR5S2V5c1BhdGggPSAnLi9vcmJpdGRiL2lkZW50aXR5L2lkZW50aXR5a2V5cydcbmNvbnN0IHN1cHBvcnRlZFR5cGVzID0ge1xuICBvcmJpdGRiOiBPcmJpdERCSWRlbnRpdHlQcm92aWRlclxufVxuXG5jb25zdCBnZXRIYW5kbGVyRm9yID0gKHR5cGUpID0+IHtcbiAgaWYgKCFJZGVudGl0aWVzLmlzU3VwcG9ydGVkKHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJZGVudGl0eVByb3ZpZGVyIHR5cGUgJyR7dHlwZX0nIGlzIG5vdCBzdXBwb3J0ZWRgKVxuICB9XG4gIHJldHVybiBzdXBwb3J0ZWRUeXBlc1t0eXBlXVxufVxuXG5jbGFzcyBJZGVudGl0aWVzIHtcbiAgY29uc3RydWN0b3IgKGtleXN0b3JlKSB7XG4gICAgdGhpcy5fa2V5c3RvcmUgPSBrZXlzdG9yZVxuICB9XG5cbiAgYXN5bmMgc2lnbiAoaWRlbnRpdHksIGRhdGEpIHtcbiAgICBjb25zdCBzaWduaW5nS2V5ID0gYXdhaXQgdGhpcy5fa2V5c3RvcmUuZ2V0S2V5KGlkZW50aXR5LmlkKVxuICAgIGlmICghc2lnbmluZ0tleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcml2YXRlIHNpZ25pbmcga2V5IG5vdCBmb3VuZCBmcm9tIEtleXN0b3JlYClcbiAgICB9XG4gICAgY29uc3Qgc2lnID0gYXdhaXQgdGhpcy5fa2V5c3RvcmUuc2lnbihzaWduaW5nS2V5LCBkYXRhKVxuICAgIHJldHVybiBzaWdcbiAgfVxuXG4gIGFzeW5jIHZlcmlmeSAoc2lnbmF0dXJlLCBwdWJsaWNLZXksIGRhdGEsIHZlcmlmaWVyID0gJ3YxJykge1xuICAgIHJldHVybiB0aGlzLl9rZXlzdG9yZS52ZXJpZnkoc2lnbmF0dXJlLCBwdWJsaWNLZXksIGRhdGEsIHZlcmlmaWVyKVxuICB9XG5cbiAgYXN5bmMgY3JlYXRlSWRlbnRpdHkgKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IElkZW50aXR5UHJvdmlkZXIgPSBnZXRIYW5kbGVyRm9yKG9wdGlvbnMudHlwZSlcbiAgICBjb25zdCBpZGVudGl0eVByb3ZpZGVyID0gbmV3IElkZW50aXR5UHJvdmlkZXIob3B0aW9ucylcbiAgICBjb25zdCBpZCA9IGF3YWl0IGlkZW50aXR5UHJvdmlkZXIuZ2V0SWQob3B0aW9ucylcbiAgICBpZiAob3B0aW9ucy5taWdyYXRlKSB7XG4gICAgICBhd2FpdCBvcHRpb25zLm1pZ3JhdGUoeyB0YXJnZXRQYXRoOiB0aGlzLl9rZXlzdG9yZS5wYXRoLCB0YXJnZXRJZDogaWQgfSlcbiAgICB9XG4gICAgY29uc3QgeyBwdWJsaWNLZXksIGlkU2lnbmF0dXJlIH0gPSBhd2FpdCB0aGlzLnNpZ25JZChpZClcbiAgICBjb25zdCBwdWJLZXlJZFNpZ25hdHVyZSA9IGF3YWl0IGlkZW50aXR5UHJvdmlkZXIuc2lnbklkZW50aXR5KHB1YmxpY0tleSArIGlkU2lnbmF0dXJlLCBvcHRpb25zKVxuICAgIHJldHVybiBuZXcgSWRlbnRpdHkoaWQsIHB1YmxpY0tleSwgaWRTaWduYXR1cmUsIHB1YktleUlkU2lnbmF0dXJlLCBJZGVudGl0eVByb3ZpZGVyLnR5cGUsIHRoaXMpXG4gIH1cblxuICBhc3luYyBzaWduSWQgKGlkKSB7XG4gICAgY29uc3Qga2V5c3RvcmUgPSB0aGlzLl9rZXlzdG9yZVxuICAgIGNvbnN0IGtleSA9IGF3YWl0IGtleXN0b3JlLmdldEtleShpZCkgfHwgYXdhaXQga2V5c3RvcmUuY3JlYXRlS2V5KGlkKVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IGtleXN0b3JlLmdldFB1YmxpYyhrZXkpXG4gICAgY29uc3QgaWRTaWduYXR1cmUgPSBhd2FpdCBrZXlzdG9yZS5zaWduKGtleSwgaWQpXG4gICAgcmV0dXJuIHsgcHVibGljS2V5LCBpZFNpZ25hdHVyZSB9XG4gIH1cblxuICBhc3luYyB2ZXJpZnlJZGVudGl0eSAoaWRlbnRpdHkpIHtcbiAgICBjb25zdCB2ZXJpZmllZCA9IGF3YWl0IHRoaXMuX2tleXN0b3JlLnZlcmlmeShcbiAgICAgIGlkZW50aXR5LnNpZ25hdHVyZXMuaWQsXG4gICAgICBpZGVudGl0eS5wdWJsaWNLZXksXG4gICAgICBpZGVudGl0eS5pZFxuICAgIClcbiAgICByZXR1cm4gdmVyaWZpZWQgJiYgSWRlbnRpdGllcy52ZXJpZnlJZGVudGl0eShpZGVudGl0eSlcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyB2ZXJpZnlJZGVudGl0eSAoaWRlbnRpdHkpIHtcbiAgICBjb25zdCBJZGVudGl0eVByb3ZpZGVyID0gZ2V0SGFuZGxlckZvcihpZGVudGl0eS50eXBlKVxuICAgIHJldHVybiBJZGVudGl0eVByb3ZpZGVyLnZlcmlmeUlkZW50aXR5KGlkZW50aXR5KVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZUlkZW50aXR5IChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBrZXlzdG9yZSA9IG9wdGlvbnMua2V5c3RvcmUgfHwgS2V5c3RvcmUuY3JlYXRlKG9wdGlvbnMuaWRlbnRpdHlLZXlzUGF0aCB8fCBpZGVudGl0eUtleXNQYXRoKVxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB7IHR5cGUgfSwgb3B0aW9ucylcbiAgICBjb25zdCBpZGVudGl0aWVzID0gbmV3IElkZW50aXRpZXMoa2V5c3RvcmUpXG4gICAgcmV0dXJuIGlkZW50aXRpZXMuY3JlYXRlSWRlbnRpdHkob3B0aW9ucylcbiAgfVxuXG4gIHN0YXRpYyBpc1N1cHBvcnRlZCAodHlwZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzdXBwb3J0ZWRUeXBlcykuaW5jbHVkZXModHlwZSlcbiAgfVxuXG4gIHN0YXRpYyBhZGRJZGVudGl0eVByb3ZpZGVyIChJZGVudGl0eVByb3ZpZGVyKSB7XG4gICAgaWYgKCFJZGVudGl0eVByb3ZpZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lkZW50aXR5UHJvdmlkZXIgY2xhc3MgbmVlZHMgdG8gYmUgZ2l2ZW4gYXMgYW4gb3B0aW9uJylcbiAgICB9XG5cbiAgICBpZiAoIUlkZW50aXR5UHJvdmlkZXIudHlwZSB8fFxuICAgICAgdHlwZW9mIElkZW50aXR5UHJvdmlkZXIudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gSWRlbnRpdHlQcm92aWRlciBjbGFzcyBuZWVkcyB0byBpbXBsZW1lbnQ6IHN0YXRpYyBnZXQgdHlwZSgpIHsgLyogcmV0dXJuIGEgc3RyaW5nICovfS4nKVxuICAgIH1cblxuICAgIHN1cHBvcnRlZFR5cGVzW0lkZW50aXR5UHJvdmlkZXIudHlwZV0gPSBJZGVudGl0eVByb3ZpZGVyXG4gIH1cblxuICBzdGF0aWMgcmVtb3ZlSWRlbnRpdHlQcm92aWRlciAodHlwZSkge1xuICAgIGRlbGV0ZSBzdXBwb3J0ZWRUeXBlc1t0eXBlXVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSWRlbnRpdGllc1xuIiwiY29uc3QgWE1MSHR0cFJlcXVlc3QgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3Q7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxubW9kdWxlLmV4cG9ydHMgPSBYTUxIdHRwUmVxdWVzdDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2Jhc2U2NHVybCcpLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfU2ltcGxlU2lnbmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9TaW1wbGVTaWduZXJcIikpO1xuXG52YXIgX05hY2xTaWduZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL05hY2xTaWduZXJcIikpO1xuXG52YXIgX0pXVCA9IHJlcXVpcmUoXCIuL0pXVFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFNpbXBsZVNpZ25lcjogX1NpbXBsZVNpZ25lci5kZWZhdWx0LFxuICBOYWNsU2lnbmVyOiBfTmFjbFNpZ25lci5kZWZhdWx0LFxuICB2ZXJpZnlKV1Q6IF9KV1QudmVyaWZ5SldULFxuICBjcmVhdGVKV1Q6IF9KV1QuY3JlYXRlSldULFxuICBkZWNvZGVKV1Q6IF9KV1QuZGVjb2RlSldUXG59OyIsIid1c2Ugc3RyaWN0J1xuY29uc3QgaW8gPSByZXF1aXJlKCdvcmJpdC1kYi1pbycpXG5cbmNsYXNzIEFjY2Vzc0NvbnRyb2xsZXJNYW5pZmVzdCB7XG4gIGNvbnN0cnVjdG9yICh0eXBlLCBwYXJhbXMgPSB7fSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtc1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIHJlc29sdmUgKGlwZnMsIG1hbmlmZXN0SGFzaCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMuc2tpcE1hbmlmZXN0KSB7XG4gICAgICBpZiAoIW9wdGlvbnMudHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1hbmlmZXN0LCBhY2Nlc3MtY29udHJvbGxlciB0eXBlIHJlcXVpcmVkYClcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQWNjZXNzQ29udHJvbGxlck1hbmlmZXN0KG9wdGlvbnMudHlwZSwgeyBhZGRyZXNzOiBtYW5pZmVzdEhhc2ggfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogZW5zdXJlIHRoaXMgaXMgYSB2YWxpZCBtdWx0aWhhc2hcbiAgICAgIGlmIChtYW5pZmVzdEhhc2guaW5kZXhPZignL2lwZnMnKSA9PT0gMCkgeyBtYW5pZmVzdEhhc2ggPSBtYW5pZmVzdEhhc2guc3BsaXQoJy8nKVsyXSB9XG4gICAgICBjb25zdCB7IHR5cGUsIHBhcmFtcyB9ID0gYXdhaXQgaW8ucmVhZChpcGZzLCBtYW5pZmVzdEhhc2gpXG4gICAgICByZXR1cm4gbmV3IEFjY2Vzc0NvbnRyb2xsZXJNYW5pZmVzdCh0eXBlLCBwYXJhbXMpXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZSAoaXBmcywgdHlwZSwgcGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy5za2lwTWFuaWZlc3QpIHtcbiAgICAgIHJldHVybiBwYXJhbXMuYWRkcmVzc1xuICAgIH1cbiAgICBjb25zdCBtYW5pZmVzdCA9IHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBwYXJhbXM6IHBhcmFtc1xuICAgIH1cbiAgICByZXR1cm4gaW8ud3JpdGUoaXBmcywgJ2RhZy1jYm9yJywgbWFuaWZlc3QpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBY2Nlc3NDb250cm9sbGVyTWFuaWZlc3RcbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgaW8gPSByZXF1aXJlKCdvcmJpdC1kYi1pbycpXG5jb25zdCBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlci8nKS5CdWZmZXJcbmNvbnN0IEFjY2Vzc0NvbnRyb2xsZXIgPSByZXF1aXJlKCcuL2FjY2Vzcy1jb250cm9sbGVyLWludGVyZmFjZScpXG5jb25zdCB0eXBlID0gJ2xlZ2FjeS1pcGZzJ1xuXG5jbGFzcyBMZWdhY3lJUEZTQWNjZXNzQ29udHJvbGxlciBleHRlbmRzIEFjY2Vzc0NvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvciAoaXBmcywgb3B0aW9ucykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9pcGZzID0gaXBmc1xuICAgIHRoaXMuX3dyaXRlID0gQXJyYXkuZnJvbShvcHRpb25zLndyaXRlIHx8IFtdKVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgdHlwZSBvZiB0aGUgYWNjZXNzIGNvbnRyb2xsZXJcbiAgc3RhdGljIGdldCB0eXBlICgpIHsgcmV0dXJuIHR5cGUgfVxuXG4gIC8vIFJldHVybiBhIFNldCBvZiBrZXlzIHRoYXQgaGF2ZSBgYWNjZXNzYCBjYXBhYmlsaXR5XG4gIGdldCB3cml0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRlXG4gIH1cblxuICBhc3luYyBjYW5BcHBlbmQgKGVudHJ5LCBpZGVudGl0eVByb3ZpZGVyKSB7XG4gICAgLy8gQWxsb3cgaWYgYWNjZXNzIGxpc3QgY29udGFpbiB0aGUgd3JpdGVyJ3MgcHVibGljS2V5IG9yIGlzICcqJ1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGVudHJ5LmtleVxuICAgIGlmICh0aGlzLndyaXRlLmluY2x1ZGVzKHB1YmxpY0tleSkgfHxcbiAgICAgIHRoaXMud3JpdGUuaW5jbHVkZXMoJyonKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBhc3luYyBsb2FkIChhZGRyZXNzKSB7XG4gICAgLy8gVHJhbnNmb3JtICcvaXBmcy9RbVBGdEhpM2NtZlplcnh0SDl5U0xkenBnMXlGaG9jWURaZ0VaeXdkVVhIeEZVJ1xuICAgIC8vIHRvICdRbVBGdEhpM2NtZlplcnh0SDl5U0xkenBnMXlGaG9jWURaZ0VaeXdkVVhIeEZVJ1xuICAgIGlmIChhZGRyZXNzLmluZGV4T2YoJy9pcGZzJykgPT09IDApIHsgYWRkcmVzcyA9IGFkZHJlc3Muc3BsaXQoJy8nKVsyXSB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYWNjZXNzID0gYXdhaXQgaW8ucmVhZCh0aGlzLl9pcGZzLCBhZGRyZXNzKVxuICAgICAgdGhpcy5fd3JpdGUgPSBhY2Nlc3Mud3JpdGVcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmxvZygnTGVnYWN5SVBGU0FjY2Vzc0NvbnRyb2xsZXIubG9hZCBFUlJPUjonLCBlKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHNhdmUgKG9wdGlvbnMpIHtcbiAgICBsZXQgY2lkXG4gICAgY29uc3QgYWNjZXNzID0geyBhZG1pbjogW10sIHdyaXRlOiB0aGlzLndyaXRlLCByZWFkOiBbXSB9XG4gICAgdHJ5IHtcbiAgICAgIGNpZCA9IGF3YWl0IGlvLndyaXRlKHRoaXMuX2lwZnMsICdyYXcnLCBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShhY2Nlc3MsIG51bGwsIDIpKSwgeyBmb3JtYXQ6ICdkYWctcGInfSlcblxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdMZWdhY3lJUEZTQWNjZXNzQ29udHJvbGxlci5zYXZlIEVSUk9SOicsIGUpXG4gICAgfVxuICAgIC8vIHJldHVybiB0aGUgbWFuaWZlc3QgZGF0YVxuICAgIHJldHVybiB7IGFkZHJlc3M6IGNpZCwgc2tpcE1hbmlmZXN0OiB0cnVlIH1cbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBjcmVhdGUgKG9yYml0ZGIsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIC4uLnsgd3JpdGU6IG9wdGlvbnMud3JpdGUgfHwgW29yYml0ZGIuaWRlbnRpdHkucHVibGljS2V5XSB9IH1cbiAgICByZXR1cm4gbmV3IExlZ2FjeUlQRlNBY2Nlc3NDb250cm9sbGVyKG9yYml0ZGIuX2lwZnMsIG9wdGlvbnMpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMZWdhY3lJUEZTQWNjZXNzQ29udHJvbGxlclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBNYXBTZXJpZXMgPSByZXF1aXJlKCdwLW1hcC1zZXJpZXMnKVxuY29uc3QgQWNjZXNzQ29udHJvbGxlciA9IHJlcXVpcmUoJy4vYWNjZXNzLWNvbnRyb2xsZXItaW50ZXJmYWNlJylcbmNvbnN0IGVuc3VyZUFkZHJlc3MgPSByZXF1aXJlKCcuL3V0aWxzL2Vuc3VyZS1hYy1hZGRyZXNzJylcblxuY29uc3QgdHlwZSA9ICdvcmJpdGRiJ1xuXG5jbGFzcyBPcmJpdERCQWNjZXNzQ29udHJvbGxlciBleHRlbmRzIEFjY2Vzc0NvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvciAob3JiaXRkYiwgb3B0aW9ucykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9vcmJpdGRiID0gb3JiaXRkYlxuICAgIHRoaXMuX2RiID0gbnVsbFxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSB0eXBlIG9mIHRoZSBhY2Nlc3MgY29udHJvbGxlclxuICBzdGF0aWMgZ2V0IHR5cGUgKCkgeyByZXR1cm4gdHlwZSB9XG5cbiAgLy8gUmV0dXJucyB0aGUgYWRkcmVzcyBvZiB0aGUgT3JiaXREQiB1c2VkIGFzIHRoZSBBQ1xuICBnZXQgYWRkcmVzcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RiLmFkZHJlc3NcbiAgfVxuXG4gIC8vIFJldHVybiB0cnVlIGlmIGVudHJ5IGlzIGFsbG93ZWQgdG8gYmUgYWRkZWQgdG8gdGhlIGRhdGFiYXNlXG4gIGFzeW5jIGNhbkFwcGVuZCAoZW50cnksIGlkZW50aXR5UHJvdmlkZXIpIHtcbiAgICAvLyBXcml0ZSBrZXlzIGFuZCBhZG1pbnMga2V5cyBhcmUgYWxsb3dlZFxuICAgIGNvbnN0IGFjY2VzcyA9IG5ldyBTZXQoWy4uLnRoaXMuZ2V0KCd3cml0ZScpLCAuLi50aGlzLmdldCgnYWRtaW4nKV0pXG4gICAgLy8gSWYgdGhlIEFDTCBjb250YWlucyB0aGUgd3JpdGVyJ3MgcHVibGljIGtleSBvciBpdCBjb250YWlucyAnKidcbiAgICBpZiAoYWNjZXNzLmhhcyhlbnRyeS5pZGVudGl0eS5pZCkgfHwgYWNjZXNzLmhhcygnKicpKSB7XG4gICAgICBjb25zdCB2ZXJpZmllZElkZW50aXR5ID0gYXdhaXQgaWRlbnRpdHlQcm92aWRlci52ZXJpZnlJZGVudGl0eShlbnRyeS5pZGVudGl0eSlcbiAgICAgIC8vIEFsbG93IGFjY2VzcyBpZiBpZGVudGl0eSB2ZXJpZmllc1xuICAgICAgcmV0dXJuIHZlcmlmaWVkSWRlbnRpdHlcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGdldCBjYXBhYmlsaXRpZXMgKCkge1xuICAgIGlmICh0aGlzLl9kYikge1xuICAgICAgbGV0IGNhcGFiaWxpdGllcyA9IHRoaXMuX2RiLmluZGV4XG5cbiAgICAgIGNvbnN0IHRvU2V0ID0gKGUpID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gZVswXVxuICAgICAgICBjYXBhYmlsaXRpZXNba2V5XSA9IG5ldyBTZXQoWy4uLihjYXBhYmlsaXRpZXNba2V5XSB8fCBbXSksIC4uLmVbMV1dKVxuICAgICAgfVxuXG4gICAgICAvLyBNZXJnZSB3aXRoIHRoZSBhY2Nlc3MgY29udHJvbGxlciBvZiB0aGUgZGF0YWJhc2VcbiAgICAgIC8vIGFuZCBtYWtlIHN1cmUgYWxsIHZhbHVlcyBhcmUgU2V0c1xuICAgICAgT2JqZWN0LmVudHJpZXMoe1xuICAgICAgICAuLi5jYXBhYmlsaXRpZXMsXG4gICAgICAgIC8vIEFkZCB0aGUgcm9vdCBhY2Nlc3MgY29udHJvbGxlcidzICd3cml0ZScgYWNjZXNzIGxpc3RcbiAgICAgICAgLy8gYXMgYWRtaW5zIG9uIHRoaXMgY29udHJvbGxlclxuICAgICAgICAuLi57IGFkbWluOiBuZXcgU2V0KFsuLi4oY2FwYWJpbGl0aWVzLmFkbWluIHx8IFtdKSwgLi4udGhpcy5fZGIuYWNjZXNzLndyaXRlXSlcbiAgICAgICAgfVxuICAgICAgfSkuZm9yRWFjaCh0b1NldClcblxuICAgICAgcmV0dXJuIGNhcGFiaWxpdGllc1xuICAgIH1cbiAgICByZXR1cm4ge31cbiAgfVxuXG4gIGdldCAoY2FwYWJpbGl0eSkge1xuICAgIHJldHVybiB0aGlzLmNhcGFiaWxpdGllc1tjYXBhYmlsaXR5XSB8fCBuZXcgU2V0KFtdKVxuICB9XG5cbiAgYXN5bmMgY2xvc2UgKCkge1xuICAgIGF3YWl0IHRoaXMuX2RiLmNsb3NlKClcbiAgfVxuXG4gIGFzeW5jIGxvYWQgKGFkZHJlc3MpIHtcbiAgICBpZiAodGhpcy5fZGIpIHsgYXdhaXQgdGhpcy5fZGIuY2xvc2UoKSB9XG5cbiAgICAvLyBGb3JjZSAnPGFkZHJlc3M+L19hY2Nlc3MnIG5hbWluZyBmb3IgdGhlIGRhdGFiYXNlXG4gICAgdGhpcy5fZGIgPSBhd2FpdCB0aGlzLl9vcmJpdGRiLmtleXZhbHVlKGVuc3VyZUFkZHJlc3MoYWRkcmVzcyksIHtcbiAgICAgIC8vIHVzZSBpcGZzIGNvbnRyb2xsZXIgYXMgYSBpbW11dGFibGUgXCJyb290IGNvbnRyb2xsZXJcIlxuICAgICAgYWNjZXNzQ29udHJvbGxlcjoge1xuICAgICAgICB0eXBlOiAnaXBmcycsXG4gICAgICAgIHdyaXRlOiB0aGlzLl9vcHRpb25zLmFkbWluIHx8IFt0aGlzLl9vcmJpdGRiLmlkZW50aXR5LmlkXVxuICAgICAgfSxcbiAgICAgIHN5bmM6IHRydWVcbiAgICB9KVxuXG4gICAgdGhpcy5fZGIuZXZlbnRzLm9uKCdyZWFkeScsIHRoaXMuX29uVXBkYXRlLmJpbmQodGhpcykpXG4gICAgdGhpcy5fZGIuZXZlbnRzLm9uKCd3cml0ZScsIHRoaXMuX29uVXBkYXRlLmJpbmQodGhpcykpXG4gICAgdGhpcy5fZGIuZXZlbnRzLm9uKCdyZXBsaWNhdGVkJywgdGhpcy5fb25VcGRhdGUuYmluZCh0aGlzKSlcblxuICAgIGF3YWl0IHRoaXMuX2RiLmxvYWQoKVxuICB9XG5cbiAgYXN5bmMgc2F2ZSAoKSB7XG4gICAgLy8gcmV0dXJuIHRoZSBtYW5pZmVzdCBkYXRhXG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZHJlc3M6IHRoaXMuX2RiLmFkZHJlc3MudG9TdHJpbmcoKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdyYW50IChjYXBhYmlsaXR5LCBrZXkpIHtcbiAgICAvLyBNZXJnZSBjdXJyZW50IGtleXMgd2l0aCB0aGUgbmV3IGtleVxuICAgIGNvbnN0IGNhcGFiaWxpdGllcyA9IG5ldyBTZXQoWy4uLih0aGlzLl9kYi5nZXQoY2FwYWJpbGl0eSkgfHwgW10pLCAuLi5ba2V5XV0pXG4gICAgYXdhaXQgdGhpcy5fZGIucHV0KGNhcGFiaWxpdHksIEFycmF5LmZyb20oY2FwYWJpbGl0aWVzLnZhbHVlcygpKSlcbiAgfVxuXG4gIGFzeW5jIHJldm9rZSAoY2FwYWJpbGl0eSwga2V5KSB7XG4gICAgbGV0IGNhcGFiaWxpdGllcyA9IG5ldyBTZXQodGhpcy5fZGIuZ2V0KGNhcGFiaWxpdHkpIHx8IFtdKVxuICAgIGNhcGFiaWxpdGllcy5kZWxldGUoa2V5KVxuICAgIGlmIChjYXBhYmlsaXRpZXMuc2l6ZSA+IDApIHtcbiAgICAgIGF3YWl0IHRoaXMuX2RiLnB1dChjYXBhYmlsaXR5LCBBcnJheS5mcm9tKGNhcGFiaWxpdGllcy52YWx1ZXMoKSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHRoaXMuX2RiLmRlbChjYXBhYmlsaXR5KVxuICAgIH1cbiAgfVxuXG4gIC8qIFByaXZhdGUgbWV0aG9kcyAqL1xuICBfb25VcGRhdGUgKCkge1xuICAgIHRoaXMuZW1pdCgndXBkYXRlZCcpXG4gIH1cblxuICAvKiBGYWN0b3J5ICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGUgKG9yYml0ZGIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGFjID0gbmV3IE9yYml0REJBY2Nlc3NDb250cm9sbGVyKG9yYml0ZGIsIG9wdGlvbnMpXG4gICAgYXdhaXQgYWMubG9hZChvcHRpb25zLmFkZHJlc3MgfHwgb3B0aW9ucy5uYW1lIHx8ICdkZWZhdWx0LWFjY2Vzcy1jb250cm9sbGVyJylcblxuICAgIC8vIEFkZCB3cml0ZSBhY2Nlc3MgZnJvbSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMud3JpdGUgJiYgIW9wdGlvbnMuYWRkcmVzcykge1xuICAgICAgYXdhaXQgcE1hcFNlcmllcyhvcHRpb25zLndyaXRlLCBhc3luYyAoZSkgPT4gYWMuZ3JhbnQoJ3dyaXRlJywgZSkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGFjXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPcmJpdERCQWNjZXNzQ29udHJvbGxlclxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCB7IGlvIH0gPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IEFjY2Vzc0NvbnRyb2xsZXIgPSByZXF1aXJlKCcuL2FjY2Vzcy1jb250cm9sbGVyLWludGVyZmFjZScpXG5jb25zdCB0eXBlID0gJ2lwZnMnXG5cbmNsYXNzIElQRlNBY2Nlc3NDb250cm9sbGVyIGV4dGVuZHMgQWNjZXNzQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yIChpcGZzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2lwZnMgPSBpcGZzXG4gICAgdGhpcy5fd3JpdGUgPSBBcnJheS5mcm9tKG9wdGlvbnMud3JpdGUgfHwgW10pXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSB0eXBlIG9mIHRoZSBhY2Nlc3MgY29udHJvbGxlclxuICBzdGF0aWMgZ2V0IHR5cGUgKCkgeyByZXR1cm4gdHlwZSB9XG5cbiAgLy8gUmV0dXJuIGEgU2V0IG9mIGtleXMgdGhhdCBoYXZlIGBhY2Nlc3NgIGNhcGFiaWxpdHlcbiAgZ2V0IHdyaXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGVcbiAgfVxuXG4gIGFzeW5jIGNhbkFwcGVuZCAoZW50cnksIGlkZW50aXR5UHJvdmlkZXIpIHtcbiAgICAvLyBBbGxvdyBpZiBhY2Nlc3MgbGlzdCBjb250YWluIHRoZSB3cml0ZXIncyBwdWJsaWNLZXkgb3IgaXMgJyonXG4gICAgY29uc3Qga2V5ID0gZW50cnkuaWRlbnRpdHkuaWRcbiAgICBpZiAodGhpcy53cml0ZS5pbmNsdWRlcyhrZXkpIHx8IHRoaXMud3JpdGUuaW5jbHVkZXMoJyonKSkge1xuICAgICAgLy9jaGVjayBpZGVudGl0eSBpcyB2YWxpZFxuICAgICAgcmV0dXJuIGlkZW50aXR5UHJvdmlkZXIudmVyaWZ5SWRlbnRpdHkoZW50cnkuaWRlbnRpdHkpXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cblxuICBhc3luYyBsb2FkIChhZGRyZXNzKSB7XG4gICAgLy8gVHJhbnNmb3JtICcvaXBmcy9RbVBGdEhpM2NtZlplcnh0SDl5U0xkenBnMXlGaG9jWURaZ0VaeXdkVVhIeEZVJ1xuICAgIC8vIHRvICdRbVBGdEhpM2NtZlplcnh0SDl5U0xkenBnMXlGaG9jWURaZ0VaeXdkVVhIeEZVJ1xuICAgIGlmIChhZGRyZXNzLmluZGV4T2YoJy9pcGZzJykgPT09IDApIHsgYWRkcmVzcyA9IGFkZHJlc3Muc3BsaXQoJy8nKVsyXSB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fd3JpdGUgPSBhd2FpdCBpby5yZWFkKHRoaXMuX2lwZnMsIGFkZHJlc3MpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coJ0lQRlNBY2Nlc3NDb250cm9sbGVyLmxvYWQgRVJST1I6JywgZSlcbiAgICB9XG4gIH1cblxuICBhc3luYyBzYXZlICgpIHtcbiAgICBsZXQgY2lkXG4gICAgdHJ5IHtcblxuICAgICAgY2lkID0gYXdhaXQgaW8ud3JpdGUodGhpcy5faXBmcywgJ2RhZy1jYm9yJywgeyB3cml0ZTogSlNPTi5zdHJpbmdpZnkodGhpcy53cml0ZSwgbnVsbCwgMikgfSlcblxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdJUEZTQWNjZXNzQ29udHJvbGxlci5zYXZlIEVSUk9SOicsIGUpXG4gICAgfVxuICAgIC8vIHJldHVybiB0aGUgbWFuaWZlc3QgZGF0YVxuICAgIHJldHVybiB7IGFkZHJlc3M6IGNpZCB9XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgY3JlYXRlIChvcmJpdGRiLCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCAuLi57IHdyaXRlOiBvcHRpb25zLndyaXRlIHx8IFtvcmJpdGRiLmlkZW50aXR5LmlkXSB9IH1cbiAgICByZXR1cm4gbmV3IElQRlNBY2Nlc3NDb250cm9sbGVyKG9yYml0ZGIuX2lwZnMsIG9wdGlvbnMpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJUEZTQWNjZXNzQ29udHJvbGxlclxuIiwiY29uc3QgQ0lEID0gcmVxdWlyZSgnY2lkcycpXG5jb25zdCBkYWdQQiA9IHJlcXVpcmUoJ2lwbGQtZGFnLXBiJylcbmNvbnN0IGRlZmF1bHRCYXNlID0gJ2Jhc2U1OGJ0YydcblxuY29uc3QgY2lkaWZ5U3RyaW5nID0gKHN0cikgPT4ge1xuICBpZiAoIXN0cikge1xuICAgIHJldHVybiBzdHJcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHN0cikpIHtcbiAgICByZXR1cm4gc3RyLm1hcChjaWRpZnlTdHJpbmcpXG4gIH1cblxuICByZXR1cm4gbmV3IENJRChzdHIpXG59XG5cbmNvbnN0IHN0cmluZ2lmeUNpZCA9IChjaWQsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFjaWQpIHtcbiAgICByZXR1cm4gY2lkXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShjaWQpKSB7XG4gICAgcmV0dXJuIGNpZC5tYXAoc3RyaW5naWZ5Q2lkKVxuICB9XG4gIFxuICBpZiAoY2lkWycvJ10pIHtcbiAgICByZXR1cm4gY2lkWycvJ11cbiAgfVxuXG4gIGNvbnN0IGJhc2UgPSBvcHRpb25zLmJhc2UgfHwgZGVmYXVsdEJhc2VcbiAgcmV0dXJuIGNpZC50b0Jhc2VFbmNvZGVkU3RyaW5nKGJhc2UpXG59XG5cbmNvbnN0IHdyaXRlUGIgPSBhc3luYyAoaXBmcywgb2JqKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KG9iaikpXG4gIGNvbnN0IGRhZ05vZGUgPSBkYWdQQi5EQUdOb2RlLmNyZWF0ZShidWZmZXIpXG4gIGNvbnN0IGNpZCA9IGF3YWl0IGlwZnMuZGFnLnB1dChkYWdOb2RlLCB7XG4gICAgZm9ybWF0OiAnZGFnLXBiJyxcbiAgICBoYXNoQWxnOiAnc2hhMi0yNTYnXG4gIH0pXG5cbiAgcmV0dXJuIGNpZC50b1YwKCkudG9CYXNlRW5jb2RlZFN0cmluZygpXG59XG5cbmNvbnN0IHJlYWRQYiA9IGFzeW5jIChpcGZzLCBjaWQpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaXBmcy5kYWcuZ2V0KGNpZClcbiAgY29uc3QgZGFnTm9kZSA9IHJlc3VsdC52YWx1ZVxuXG4gIHJldHVybiBKU09OLnBhcnNlKGRhZ05vZGUudG9KU09OKCkuZGF0YSlcbn1cblxuY29uc3Qgd3JpdGVDYm9yID0gYXN5bmMgKGlwZnMsIG9iaiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBkYWdOb2RlID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKVxuICBjb25zdCBsaW5rcyA9IG9wdGlvbnMubGlua3MgfHwgW11cbiAgbGlua3MuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgIGRhZ05vZGVbcHJvcF0gPSBjaWRpZnlTdHJpbmcoZGFnTm9kZVtwcm9wXSlcbiAgfSlcblxuICBjb25zdCBiYXNlID0gb3B0aW9ucy5iYXNlIHx8IGRlZmF1bHRCYXNlXG4gIGNvbnN0IG9ubHlIYXNoID0gb3B0aW9ucy5vbmx5SGFzaCB8fCBmYWxzZVxuICBjb25zdCBjaWQgPSBhd2FpdCBpcGZzLmRhZy5wdXQoZGFnTm9kZSwgeyBvbmx5SGFzaCB9KVxuICByZXR1cm4gY2lkLnRvQmFzZUVuY29kZWRTdHJpbmcoYmFzZSlcbn1cblxuY29uc3QgcmVhZENib3IgPSBhc3luYyAoaXBmcywgY2lkLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGlwZnMuZGFnLmdldChjaWQpXG4gIGNvbnN0IG9iaiA9IHJlc3VsdC52YWx1ZVxuICBjb25zdCBsaW5rcyA9IG9wdGlvbnMubGlua3MgfHwgW11cbiAgbGlua3MuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgIG9ialtwcm9wXSA9IHN0cmluZ2lmeUNpZChvYmpbcHJvcF0sIG9wdGlvbnMpXG4gIH0pXG5cbiAgcmV0dXJuIG9ialxufVxuXG5jb25zdCB3cml0ZU9iaiA9IGFzeW5jIChpcGZzLCBvYmosIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgb25seUhhc2ggPSBvcHRpb25zLm9ubHlIYXNoIHx8IGZhbHNlXG4gIGNvbnN0IGJhc2UgPSBvcHRpb25zLmJhc2UgfHwgZGVmYXVsdEJhc2VcbiAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHsgb25seUhhc2g6IG9ubHlIYXNoIH0sIG9wdGlvbnMuZm9ybWF0ID8geyBmb3JtYXQ6IG9wdGlvbnMuZm9ybWF0LCBoYXNoQWxnOiAnc2hhMi0yNTYnIH0gOiB7fSlcbiAgaWYgKG9wdHMuZm9ybWF0ID09PSAnZGFnLXBiJykge1xuICAgIG9iaiA9IGRhZ1BCLkRBR05vZGUuY3JlYXRlKG9iailcbiAgfVxuXG4gIGNvbnN0IGNpZCA9IGF3YWl0IGlwZnMuZGFnLnB1dChvYmosIG9wdHMpXG4gIHJldHVybiBjaWQudG9CYXNlRW5jb2RlZFN0cmluZyhiYXNlKVxufVxuXG5jb25zdCBmb3JtYXRzID0ge1xuICAnZGFnLXBiJzogeyByZWFkOiByZWFkUGIsIHdyaXRlOiB3cml0ZVBiIH0sXG4gICdkYWctY2Jvcic6IHsgd3JpdGU6IHdyaXRlQ2JvciwgcmVhZDogcmVhZENib3IgfSxcbiAgJ3Jhdyc6IHsgd3JpdGU6IHdyaXRlT2JqIH1cbn1cblxuY29uc3Qgd3JpdGUgPSAoaXBmcywgY29kZWMsIG9iaiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IGZvcm1hdCA9IGZvcm1hdHNbY29kZWNdXG4gIGlmICghZm9ybWF0KSB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNvZGVjJylcblxuICByZXR1cm4gZm9ybWF0LndyaXRlKGlwZnMsIG9iaiwgb3B0aW9ucylcbn1cblxuY29uc3QgcmVhZCA9IChpcGZzLCBjaWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjaWQgPSBuZXcgQ0lEKGNpZClcbiAgY29uc3QgZm9ybWF0ID0gZm9ybWF0c1tjaWQuY29kZWNdXG5cbiAgaWYgKCFmb3JtYXQpIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY29kZWMnKVxuXG4gIHJldHVybiBmb3JtYXQucmVhZChpcGZzLCBjaWQsIG9wdGlvbnMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZWFkLFxuICB3cml0ZVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG4vLyBNYWtlIHN1cmUgdGhlIGdpdmVuIGFkZHJlc3MgaGFzICcvX2FjY2VzcycgYXMgdGhlIGxhc3QgcGFydFxuY29uc3QgZW5zdXJlQWRkcmVzcyA9IGFkZHJlc3MgPT4ge1xuICBjb25zdCBzdWZmaXggPSBhZGRyZXNzLnRvU3RyaW5nKCkuc3BsaXQoJy8nKS5wb3AoKVxuICByZXR1cm4gc3VmZml4ID09PSAnX2FjY2VzcydcbiAgICA/IGFkZHJlc3NcbiAgICA6IHBhdGguam9pbihhZGRyZXNzLCAnL19hY2Nlc3MnKVxufVxubW9kdWxlLmV4cG9ydHMgPSBlbnN1cmVBZGRyZXNzXG4iLCIndXNlIHN0cmljdCdcblxuY2xhc3MgRmVlZEluZGV4IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faW5kZXggPSB7fVxuICB9XG5cbiAgZ2V0KCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9pbmRleCkubWFwKChmKSA9PiB0aGlzLl9pbmRleFtmXSlcbiAgfVxuXG4gIHVwZGF0ZUluZGV4KG9wbG9nKSB7XG4gICAgdGhpcy5faW5kZXggPSB7fVxuICAgIG9wbG9nLnZhbHVlcy5yZWR1Y2UoKGhhbmRsZWQsIGl0ZW0pID0+IHtcbiAgICAgIGlmKCFoYW5kbGVkLmluY2x1ZGVzKGl0ZW0uaGFzaCkpIHtcbiAgICAgICAgaGFuZGxlZC5wdXNoKGl0ZW0uaGFzaClcbiAgICAgICAgaWYoaXRlbS5wYXlsb2FkLm9wID09PSAnQUREJykge1xuICAgICAgICAgIHRoaXMuX2luZGV4W2l0ZW0uaGFzaF0gPSBpdGVtXG4gICAgICAgIH0gZWxzZSBpZihpdGVtLnBheWxvYWQub3AgPT09ICdERUwnKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2luZGV4W2l0ZW0ucGF5bG9hZC52YWx1ZV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhbmRsZWRcbiAgICB9LCBbXSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZlZWRJbmRleFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNsYXNzIEtleVZhbHVlSW5kZXgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pbmRleCA9IHt9XG4gIH1cblxuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4W2tleV1cbiAgfVxuXG4gIHVwZGF0ZUluZGV4KG9wbG9nKSB7XG4gICAgb3Bsb2cudmFsdWVzXG4gICAgICAuc2xpY2UoKVxuICAgICAgLnJldmVyc2UoKVxuICAgICAgLnJlZHVjZSgoaGFuZGxlZCwgaXRlbSkgPT4ge1xuICAgICAgICBpZighaGFuZGxlZC5pbmNsdWRlcyhpdGVtLnBheWxvYWQua2V5KSkge1xuICAgICAgICAgIGhhbmRsZWQucHVzaChpdGVtLnBheWxvYWQua2V5KVxuICAgICAgICAgIGlmKGl0ZW0ucGF5bG9hZC5vcCA9PT0gJ1BVVCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4W2l0ZW0ucGF5bG9hZC5rZXldID0gaXRlbS5wYXlsb2FkLnZhbHVlXG4gICAgICAgICAgfSBlbHNlIGlmKGl0ZW0ucGF5bG9hZC5vcCA9PT0gJ0RFTCcpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbmRleFtpdGVtLnBheWxvYWQua2V5XVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlZFxuICAgICAgfSwgW10pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBLZXlWYWx1ZUluZGV4XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5jb25zdCBSZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5jb25zdCBtYXBTZXJpZXMgPSByZXF1aXJlKCdwLWVhY2gtc2VyaWVzJylcbmNvbnN0IExvZyA9IHJlcXVpcmUoJ2lwZnMtbG9nJylcbmNvbnN0IEluZGV4ID0gcmVxdWlyZSgnLi9JbmRleCcpXG5jb25zdCBSZXBsaWNhdG9yID0gcmVxdWlyZSgnLi9SZXBsaWNhdG9yJylcbmNvbnN0IFJlcGxpY2F0aW9uSW5mbyA9IHJlcXVpcmUoJy4vcmVwbGljYXRpb24taW5mbycpXG5cbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJ2xvZ3BsZWFzZScpXG5jb25zdCBsb2dnZXIgPSBMb2dnZXIuY3JlYXRlKCdvcmJpdC1kYi5zdG9yZScsIHsgY29sb3I6IExvZ2dlci5Db2xvcnMuQmx1ZSB9KVxuTG9nZ2VyLnNldExvZ0xldmVsKCdFUlJPUicpXG5jb25zdCBkYWdOb2RlID0gcmVxdWlyZSgnb3JiaXQtZGItaW8nKVxuXG5jb25zdCBEZWZhdWx0T3B0aW9ucyA9IHtcbiAgSW5kZXg6IEluZGV4LFxuICBtYXhIaXN0b3J5OiAtMSxcbiAgZGlyZWN0b3J5OiAnLi9vcmJpdGRiJyxcbiAgZmV0Y2hFbnRyeVRpbWVvdXQ6IG51bGwsXG4gIHJlcGxpY2F0ZTogdHJ1ZSxcbiAgcmVmZXJlbmNlQ291bnQ6IDY0LFxuICByZXBsaWNhdGlvbkNvbmN1cnJlbmN5OiAxMjgsXG4gIHN5bmNMb2NhbDogZmFsc2UsXG4gIHNvcnRGbjogdW5kZWZpbmVkXG59XG5cbmNsYXNzIFN0b3JlIHtcbiAgY29uc3RydWN0b3IgKGlwZnMsIGlkZW50aXR5LCBhZGRyZXNzLCBvcHRpb25zKSB7XG4gICAgaWYgKCFpZGVudGl0eSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZGVudGl0eSByZXF1aXJlZCcpXG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBvcHRpb25zXG4gICAgbGV0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBEZWZhdWx0T3B0aW9ucylcbiAgICBPYmplY3QuYXNzaWduKG9wdHMsIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0c1xuXG4gICAgLy8gRGVmYXVsdCB0eXBlXG4gICAgdGhpcy5fdHlwZSA9ICdzdG9yZSdcblxuICAgIC8vIENyZWF0ZSBJRHMsIG5hbWVzIGFuZCBwYXRoc1xuICAgIHRoaXMuaWQgPSBhZGRyZXNzLnRvU3RyaW5nKClcbiAgICB0aGlzLmlkZW50aXR5ID0gaWRlbnRpdHlcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzXG4gICAgdGhpcy5kYm5hbWUgPSBhZGRyZXNzLnBhdGggfHwgJydcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudEVtaXR0ZXIoKVxuXG4gICAgLy8gRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gICAgdGhpcy5faXBmcyA9IGlwZnNcbiAgICB0aGlzLl9jYWNoZSA9IG9wdGlvbnMuY2FjaGVcblxuICAgIC8vIEFjY2VzcyBtYXBwaW5nXG4gICAgY29uc3QgZGVmYXVsdEFjY2VzcyA9IHtcbiAgICAgIGNhbkFwcGVuZDogKGVudHJ5KSA9PiAoZW50cnkuaWRlbnRpdHkucHVibGljS2V5ID09PSBpZGVudGl0eS5wdWJsaWNLZXkpXG4gICAgfVxuICAgIHRoaXMuYWNjZXNzID0gb3B0aW9ucy5hY2Nlc3NDb250cm9sbGVyIHx8IGRlZmF1bHRBY2Nlc3NcblxuICAgIC8vIENyZWF0ZSB0aGUgb3BlcmF0aW9ucyBsb2dcbiAgICB0aGlzLl9vcGxvZyA9IG5ldyBMb2codGhpcy5faXBmcywgdGhpcy5pZGVudGl0eSwgeyBsb2dJZDogdGhpcy5pZCwgYWNjZXNzOiB0aGlzLmFjY2Vzcywgc29ydEZuOiB0aGlzLm9wdGlvbnMuc29ydEZuIH0pXG5cbiAgICAvLyBDcmVhdGUgdGhlIGluZGV4XG4gICAgdGhpcy5faW5kZXggPSBuZXcgdGhpcy5vcHRpb25zLkluZGV4KHRoaXMuYWRkcmVzcy5yb290KVxuXG4gICAgLy8gUmVwbGljYXRpb24gcHJvZ3Jlc3MgaW5mb1xuICAgIHRoaXMuX3JlcGxpY2F0aW9uU3RhdHVzID0gbmV3IFJlcGxpY2F0aW9uSW5mbygpXG5cbiAgICAvLyBTdGF0aXN0aWNzXG4gICAgdGhpcy5fc3RhdHMgPSB7XG4gICAgICBzbmFwc2hvdDoge1xuICAgICAgICBieXRlc0xvYWRlZDogLTFcbiAgICAgIH0sXG4gICAgICBzeW5jUmVxdWVzdHNSZWNlaWV2ZWQ6IDBcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fcmVwbGljYXRvciA9IG5ldyBSZXBsaWNhdG9yKHRoaXMsIHRoaXMub3B0aW9ucy5yZXBsaWNhdGlvbkNvbmN1cnJlbmN5KVxuICAgICAgLy8gRm9yIGludGVybmFsIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LFxuICAgICAgLy8gdG8gYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXNcbiAgICAgIHRoaXMuX2xvYWRlciA9IHRoaXMuX3JlcGxpY2F0b3JcbiAgICAgIHRoaXMuX3JlcGxpY2F0b3Iub24oJ2xvYWQuYWRkZWQnLCAoZW50cnkpID0+IHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBsYXRlc3QgZW50cnkgc3RhdGUgKGxhdGVzdCBpcyB0aGUgZW50cnkgd2l0aCBsYXJnZXN0IGNsb2NrIHRpbWUpXG4gICAgICAgIHRoaXMuX3JlcGxpY2F0aW9uU3RhdHVzLnF1ZXVlZCsrXG4gICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlUmVwbGljYXRpb25NYXgoZW50cnkuY2xvY2sgPyBlbnRyeS5jbG9jay50aW1lIDogMClcbiAgICAgICAgLy8gbG9nZ2VyLmRlYnVnKGA8cmVwbGljYXRlPmApXG4gICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ3JlcGxpY2F0ZScsIHRoaXMuYWRkcmVzcy50b1N0cmluZygpLCBlbnRyeSlcbiAgICAgIH0pXG4gICAgICB0aGlzLl9yZXBsaWNhdG9yLm9uKCdsb2FkLnByb2dyZXNzJywgKGlkLCBoYXNoLCBlbnRyeSwgaGF2ZSwgYnVmZmVyZWRMZW5ndGgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3JlcGxpY2F0aW9uU3RhdHVzLmJ1ZmZlcmVkID4gYnVmZmVyZWRMZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl9yZWNhbGN1bGF0ZVJlcGxpY2F0aW9uUHJvZ3Jlc3ModGhpcy5yZXBsaWNhdGlvblN0YXR1cy5wcm9ncmVzcyArIGJ1ZmZlcmVkTGVuZ3RoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlUmVwbGljYXRpb25Qcm9ncmVzcyh0aGlzLl9vcGxvZy5sZW5ndGggKyBidWZmZXJlZExlbmd0aClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXBsaWNhdGlvblN0YXR1cy5idWZmZXJlZCA9IGJ1ZmZlcmVkTGVuZ3RoXG4gICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlUmVwbGljYXRpb25NYXgodGhpcy5yZXBsaWNhdGlvblN0YXR1cy5wcm9ncmVzcylcbiAgICAgICAgLy8gbG9nZ2VyLmRlYnVnKGA8cmVwbGljYXRlLnByb2dyZXNzPmApXG4gICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ3JlcGxpY2F0ZS5wcm9ncmVzcycsIHRoaXMuYWRkcmVzcy50b1N0cmluZygpLCBoYXNoLCBlbnRyeSwgdGhpcy5yZXBsaWNhdGlvblN0YXR1cy5wcm9ncmVzcywgdGhpcy5yZXBsaWNhdGlvblN0YXR1cy5tYXgpXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBvbkxvYWRDb21wbGV0ZWQgPSBhc3luYyAobG9ncywgaGF2ZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAobGV0IGxvZyBvZiBsb2dzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9vcGxvZy5qb2luKGxvZylcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcmVwbGljYXRpb25TdGF0dXMucXVldWVkIC09IGxvZ3MubGVuZ3RoXG4gICAgICAgICAgdGhpcy5fcmVwbGljYXRpb25TdGF0dXMuYnVmZmVyZWQgPSB0aGlzLl9yZXBsaWNhdG9yLl9idWZmZXIubGVuZ3RoXG4gICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlSW5kZXgoKVxuXG4gICAgICAgICAgLy8gb25seSBzdG9yZSBoZWFkcyB0aGF0IGhhcyBiZWVuIHZlcmlmaWVkIGFuZCBtZXJnZXNcbiAgICAgICAgICBjb25zdCBoZWFkcyA9IHRoaXMuX29wbG9nLmhlYWRzXG4gICAgICAgICAgYXdhaXQgdGhpcy5fY2FjaGUuc2V0KCdfcmVtb3RlSGVhZHMnLCBoZWFkcylcbiAgICAgICAgICBsb2dnZXIuZGVidWcoYFNhdmVkIGhlYWRzICR7aGVhZHMubGVuZ3RofSBbJHtoZWFkcy5tYXAoZSA9PiBlLmhhc2gpLmpvaW4oJywgJyl9XWApXG5cbiAgICAgICAgICAvLyBsb2dnZXIuZGVidWcoYDxyZXBsaWNhdGVkPmApXG4gICAgICAgICAgdGhpcy5ldmVudHMuZW1pdCgncmVwbGljYXRlZCcsIHRoaXMuYWRkcmVzcy50b1N0cmluZygpLCBsb2dzLmxlbmd0aClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fcmVwbGljYXRvci5vbignbG9hZC5lbmQnLCBvbkxvYWRDb21wbGV0ZWQpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignU3RvcmUgRXJyb3I6JywgZSlcbiAgICB9XG4gIH1cblxuICBnZXQgYWxsICgpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLl9pbmRleC5faW5kZXgpXG4gICAgICA/IHRoaXMuX2luZGV4Ll9pbmRleFxuICAgICAgOiBPYmplY3Qua2V5cyh0aGlzLl9pbmRleC5faW5kZXgpLm1hcChlID0+IHRoaXMuX2luZGV4Ll9pbmRleFtlXSlcbiAgfVxuXG4gIGdldCBpbmRleCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4Ll9pbmRleFxuICB9XG5cbiAgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiB0aGlzLl90eXBlXG4gIH1cblxuICBnZXQga2V5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF0YWJhc2UncyBjdXJyZW50IHJlcGxpY2F0aW9uIHN0YXR1cyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtbT2JqZWN0XX0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgZ2V0IHJlcGxpY2F0aW9uU3RhdHVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVwbGljYXRpb25TdGF0dXNcbiAgfVxuXG4gIHNldElkZW50aXR5IChpZGVudGl0eSkge1xuICAgIHRoaXMuaWRlbnRpdHkgPSBpZGVudGl0eVxuICAgIHRoaXMuX29wbG9nLnNldElkZW50aXR5KGlkZW50aXR5KVxuICB9XG5cbiAgYXN5bmMgY2xvc2UgKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMub25DbG9zZSkge1xuICAgICAgYXdhaXQgdGhpcy5vcHRpb25zLm9uQ2xvc2UodGhpcy5hZGRyZXNzLnRvU3RyaW5nKCkpXG4gICAgfVxuXG4gICAgLy8gUmVwbGljYXRvciB0ZWFyZG93biBsb2dpY1xuICAgIHRoaXMuX3JlcGxpY2F0b3Iuc3RvcCgpXG5cbiAgICAvLyBSZXNldCByZXBsaWNhdGlvbiBzdGF0aXN0aWNzXG4gICAgdGhpcy5fcmVwbGljYXRpb25TdGF0dXMucmVzZXQoKVxuXG4gICAgLy8gUmVzZXQgZGF0YWJhc2Ugc3RhdGlzdGljc1xuICAgIHRoaXMuX3N0YXRzID0ge1xuICAgICAgc25hcHNob3Q6IHtcbiAgICAgICAgYnl0ZXNMb2FkZWQ6IC0xXG4gICAgICB9LFxuICAgICAgc3luY1JlcXVlc3RzUmVjZWlldmVkOiAwXG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLmV2ZW50cy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2xvYWQnKVxuICAgIHRoaXMuZXZlbnRzLnJlbW92ZUFsbExpc3RlbmVycygnbG9hZC5wcm9ncmVzcycpXG4gICAgdGhpcy5ldmVudHMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZXBsaWNhdGUnKVxuICAgIHRoaXMuZXZlbnRzLnJlbW92ZUFsbExpc3RlbmVycygncmVwbGljYXRlLnByb2dyZXNzJylcbiAgICB0aGlzLmV2ZW50cy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlcGxpY2F0ZWQnKVxuICAgIHRoaXMuZXZlbnRzLnJlbW92ZUFsbExpc3RlbmVycygncmVhZHknKVxuICAgIHRoaXMuZXZlbnRzLnJlbW92ZUFsbExpc3RlbmVycygnd3JpdGUnKVxuXG4gICAgLy8gQ2xvc2UgY2FjaGVcbiAgICBhd2FpdCB0aGlzLl9jYWNoZS5jbG9zZSgpXG5cbiAgICAvLyBEYXRhYmFzZSBpcyBub3cgY2xvc2VkXG4gICAgLy8gVE9ETzogYWZhaWsgd2UgZG9uJ3QgdXNlICdjbG9zZWQnIGV2ZW50IGFueW1vcmUsXG4gICAgLy8gdG8gYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXNcbiAgICB0aGlzLmV2ZW50cy5lbWl0KCdjbG9zZWQnLCB0aGlzLmFkZHJlc3MudG9TdHJpbmcoKSlcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBEcm9wcyBhIGRhdGFiYXNlIGFuZCByZW1vdmVzIGxvY2FsIGRhdGFcbiAgICogQHJldHVybiB7W05vbmVdfVxuICAgKi9cbiAgYXN5bmMgZHJvcCAoKSB7XG4gICAgYXdhaXQgdGhpcy5jbG9zZSgpXG4gICAgYXdhaXQgdGhpcy5fY2FjaGUuZGVzdHJveSgpXG4gICAgLy8gUmVzZXRcbiAgICB0aGlzLl9pbmRleCA9IG5ldyB0aGlzLm9wdGlvbnMuSW5kZXgodGhpcy5hZGRyZXNzLnJvb3QpXG4gICAgdGhpcy5fb3Bsb2cgPSBuZXcgTG9nKHRoaXMuX2lwZnMsIHRoaXMuaWRlbnRpdHksIHsgbG9nSWQ6IHRoaXMuaWQsIGFjY2VzczogdGhpcy5hY2Nlc3MsIHNvcnRGbjogdGhpcy5vcHRpb25zLnNvcnRGbiB9KVxuICAgIHRoaXMuX2NhY2hlID0gdGhpcy5vcHRpb25zLmNhY2hlXG4gIH1cblxuICBhc3luYyBsb2FkIChhbW91bnQsIHsgZmV0Y2hFbnRyeVRpbWVvdXQgfSA9IHt9KSB7XG4gICAgYW1vdW50ID0gYW1vdW50IHx8IHRoaXMub3B0aW9ucy5tYXhIaXN0b3J5XG4gICAgZmV0Y2hFbnRyeVRpbWVvdXQgPSBmZXRjaEVudHJ5VGltZW91dCB8fCB0aGlzLm9wdGlvbnMuZmV0Y2hFbnRyeVRpbWVvdXQ7XG5cbiAgICBjb25zdCBsb2NhbEhlYWRzID0gYXdhaXQgdGhpcy5fY2FjaGUuZ2V0KCdfbG9jYWxIZWFkcycpIHx8IFtdXG4gICAgY29uc3QgcmVtb3RlSGVhZHMgPSBhd2FpdCB0aGlzLl9jYWNoZS5nZXQoJ19yZW1vdGVIZWFkcycpIHx8IFtdXG4gICAgY29uc3QgaGVhZHMgPSBsb2NhbEhlYWRzLmNvbmNhdChyZW1vdGVIZWFkcylcblxuICAgIGlmIChoZWFkcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmV2ZW50cy5lbWl0KCdsb2FkJywgdGhpcy5hZGRyZXNzLnRvU3RyaW5nKCksIGhlYWRzKVxuICAgIH1cblxuICAgIGF3YWl0IG1hcFNlcmllcyhoZWFkcywgYXN5bmMgKGhlYWQpID0+IHtcbiAgICAgIHRoaXMuX3JlY2FsY3VsYXRlUmVwbGljYXRpb25NYXgoaGVhZC5jbG9jay50aW1lKVxuICAgICAgY29uc3QgbG9nID0gYXdhaXQgTG9nLmZyb21FbnRyeUhhc2godGhpcy5faXBmcywgdGhpcy5pZGVudGl0eSwgaGVhZC5oYXNoLCB7IGxvZ0lkOiB0aGlzLl9vcGxvZy5pZCwgYWNjZXNzOiB0aGlzLmFjY2Vzcywgc29ydEZuOiB0aGlzLm9wdGlvbnMuc29ydEZuLCBsZW5ndGg6IGFtb3VudCwgZXhjbHVkZTogdGhpcy5fb3Bsb2cudmFsdWVzLCBvblByb2dyZXNzQ2FsbGJhY2s6ICB0aGlzLl9vbkxvYWRQcm9ncmVzcy5iaW5kKHRoaXMpLCB0aW1lb3V0OiBmZXRjaEVudHJ5VGltZW91dCB9KVxuICAgICAgYXdhaXQgdGhpcy5fb3Bsb2cuam9pbihsb2csIGFtb3VudClcbiAgICB9KVxuXG4gICAgLy8gVXBkYXRlIHRoZSBpbmRleFxuICAgIGlmIChoZWFkcy5sZW5ndGggPiAwKSB7XG4gICAgICBhd2FpdCB0aGlzLl91cGRhdGVJbmRleCgpXG4gICAgfVxuXG4gICAgdGhpcy5ldmVudHMuZW1pdCgncmVhZHknLCB0aGlzLmFkZHJlc3MudG9TdHJpbmcoKSwgdGhpcy5fb3Bsb2cuaGVhZHMpXG4gIH1cblxuICBzeW5jIChoZWFkcykge1xuICAgIHRoaXMuX3N0YXRzLnN5bmNSZXF1ZXN0c1JlY2VpZXZlZCArPSAxXG4gICAgbG9nZ2VyLmRlYnVnKGBTeW5jIHJlcXVlc3QgIyR7dGhpcy5fc3RhdHMuc3luY1JlcXVlc3RzUmVjZWlldmVkfSAke2hlYWRzLmxlbmd0aH1gKVxuICAgIGlmIChoZWFkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFRvIHNpbXVsYXRlIG5ldHdvcmsgbGF0ZW5jeSwgdW5jb21tZW50IHRoaXMgbGluZVxuICAgIC8vIGFuZCBjb21tZW50IG91dCB0aGUgcmVzdCBvZiB0aGUgZnVuY3Rpb25cbiAgICAvLyBUaGF0IHdheSB0aGUgb2JqZWN0IChyZWNlaXZlZCBhcyBoZWFkIG1lc3NhZ2UgZnJvbSBwdWJzdWIpXG4gICAgLy8gZG9lc24ndCBnZXQgd3JpdHRlbiB0byBJUEZTIGFuZCBzbyB3aGVuIHRoZSBSZXBsaWNhdG9yIGlzIGZldGNoaW5nXG4gICAgLy8gdGhlIGxvZywgaXQnbGwgZmV0Y2ggaXQgZnJvbSB0aGUgbmV0d29yayBpbnN0ZWFkIGZyb20gdGhlIGRpc2suXG4gICAgLy8gcmV0dXJuIHRoaXMuX3JlcGxpY2F0b3IubG9hZChoZWFkcylcblxuICAgIGNvbnN0IHNhdmVUb0lwZnMgPSBhc3luYyAoaGVhZCkgPT4ge1xuICAgICAgaWYgKCFoZWFkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IEdpdmVuIGlucHV0IGVudHJ5IHdhcyAnbnVsbCcuXCIpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbClcbiAgICAgIH1cblxuICAgICAgY29uc3QgaWRlbnRpdHlQcm92aWRlciA9IHRoaXMuaWRlbnRpdHkucHJvdmlkZXJcbiAgICAgIGlmICghaWRlbnRpdHlQcm92aWRlcikgdGhyb3cgbmV3IEVycm9yKCdJZGVudGl0eS1wcm92aWRlciBpcyByZXF1aXJlZCwgY2Fubm90IHZlcmlmeSBlbnRyeScpXG5cbiAgICAgIGNvbnN0IGNhbkFwcGVuZCA9IGF3YWl0IHRoaXMuYWNjZXNzLmNhbkFwcGVuZChoZWFkLCBpZGVudGl0eVByb3ZpZGVyKVxuICAgICAgaWYgKCFjYW5BcHBlbmQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiBHaXZlbiBpbnB1dCBlbnRyeSBpcyBub3QgYWxsb3dlZCBpbiB0aGlzIGxvZyBhbmQgd2FzIGRpc2NhcmRlZCAobm8gd3JpdGUgYWNjZXNzKS4nKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvZ0VudHJ5ID0gT2JqZWN0LmFzc2lnbih7fSwgaGVhZClcbiAgICAgIGxvZ0VudHJ5Lmhhc2ggPSBudWxsXG4gICAgICBjb25zdCBjb2RlYyA9IGxvZ0VudHJ5LnYgPT09IDAgPyAnZGFnLXBiJyA6ICdkYWctY2JvcidcbiAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBkYWdOb2RlLndyaXRlKHRoaXMuX2lwZnMsIGNvZGVjLCBsb2dFbnRyeSwgeyBsaW5rczogWyduZXh0J10sIG9ubHlIYXNoOiB0cnVlIH0pXG5cbiAgICAgIGlmIChoYXNoICE9PSBoZWFkLmhhc2gpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdcIldBUk5JTkchIEhlYWQgaGFzaCBkaWRuXFwndCBtYXRjaCB0aGUgY29udGVudHMnKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGVhZFxuICAgIH1cblxuICAgIHJldHVybiBtYXBTZXJpZXMoaGVhZHMsIHNhdmVUb0lwZnMpXG4gICAgICAudGhlbihhc3luYyAoc2F2ZWQpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcGxpY2F0b3IubG9hZChzYXZlZC5maWx0ZXIoZSA9PiBlICE9PSBudWxsKSlcbiAgICAgIH0pXG4gIH1cblxuICBsb2FkTW9yZUZyb20gKGFtb3VudCwgZW50cmllcykge1xuICAgIHRoaXMuX3JlcGxpY2F0b3IubG9hZChlbnRyaWVzKVxuICB9XG5cbiAgYXN5bmMgc2F2ZVNuYXBzaG90ICgpIHtcbiAgICBjb25zdCB1bmZpbmlzaGVkID0gdGhpcy5fcmVwbGljYXRvci5nZXRRdWV1ZSgpXG5cbiAgICBsZXQgc25hcHNob3REYXRhID0gdGhpcy5fb3Bsb2cudG9TbmFwc2hvdCgpXG4gICAgbGV0IGhlYWRlciA9IEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGlkOiBzbmFwc2hvdERhdGEuaWQsXG4gICAgICBoZWFkczogc25hcHNob3REYXRhLmhlYWRzLFxuICAgICAgc2l6ZTogc25hcHNob3REYXRhLnZhbHVlcy5sZW5ndGgsXG4gICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICB9KSlcbiAgICBjb25zdCBycyA9IG5ldyBSZWFkYWJsZSgpXG4gICAgbGV0IHNpemUgPSBuZXcgVWludDE2QXJyYXkoW2hlYWRlci5sZW5ndGhdKVxuICAgIGxldCBieXRlcyA9IEJ1ZmZlci5mcm9tKHNpemUuYnVmZmVyKVxuICAgIHJzLnB1c2goYnl0ZXMpXG4gICAgcnMucHVzaChoZWFkZXIpXG5cbiAgICBjb25zdCBhZGRUb1N0cmVhbSA9ICh2YWwpID0+IHtcbiAgICAgIGxldCBzdHIgPSBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeSh2YWwpKVxuICAgICAgbGV0IHNpemUgPSBuZXcgVWludDE2QXJyYXkoW3N0ci5sZW5ndGhdKVxuICAgICAgcnMucHVzaChCdWZmZXIuZnJvbShzaXplLmJ1ZmZlcikpXG4gICAgICBycy5wdXNoKHN0cilcbiAgICB9XG5cbiAgICBzbmFwc2hvdERhdGEudmFsdWVzLmZvckVhY2goYWRkVG9TdHJlYW0pXG4gICAgcnMucHVzaChudWxsKSAvLyB0ZWxsIHRoZSBzdHJlYW0gd2UncmUgZmluaXNoZWRcblxuICAgIGNvbnN0IHNuYXBzaG90ID0gdGhpcy5faXBmcy5maWxlcy5hZGQgPyBhd2FpdCB0aGlzLl9pcGZzLmZpbGVzLmFkZChycykgOiBhd2FpdCB0aGlzLl9pcGZzLmFkZChycylcblxuICAgIGF3YWl0IHRoaXMuX2NhY2hlLnNldCgnc25hcHNob3QnLCBzbmFwc2hvdFtzbmFwc2hvdC5sZW5ndGggLSAxXSlcbiAgICBhd2FpdCB0aGlzLl9jYWNoZS5zZXQoJ3F1ZXVlJywgdW5maW5pc2hlZClcblxuICAgIGxvZ2dlci5kZWJ1ZyhgU2F2ZWQgc25hcHNob3Q6ICR7c25hcHNob3Rbc25hcHNob3QubGVuZ3RoIC0gMV0uaGFzaH0sIHF1ZXVlIGxlbmd0aDogJHt1bmZpbmlzaGVkLmxlbmd0aH1gKVxuXG4gICAgcmV0dXJuIHNuYXBzaG90XG4gIH1cblxuICBhc3luYyBsb2FkRnJvbVNuYXBzaG90IChvblByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICB0aGlzLmV2ZW50cy5lbWl0KCdsb2FkJywgdGhpcy5hZGRyZXNzLnRvU3RyaW5nKCkpXG5cbiAgICBjb25zdCBtYXhDbG9jayA9IChyZXMsIHZhbCkgPT4gTWF0aC5tYXgocmVzLCB2YWwuY2xvY2sudGltZSlcblxuICAgIGNvbnN0IHF1ZXVlID0gYXdhaXQgdGhpcy5fY2FjaGUuZ2V0KCdxdWV1ZScpXG4gICAgdGhpcy5zeW5jKHF1ZXVlIHx8IFtdKVxuXG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCB0aGlzLl9jYWNoZS5nZXQoJ3NuYXBzaG90JylcblxuICAgIGlmIChzbmFwc2hvdCkge1xuICAgICAgY29uc3QgcmVzID0gdGhpcy5faXBmcy5maWxlcy5jYXRSZWFkYWJsZVN0cmVhbSA/IGF3YWl0IHRoaXMuX2lwZnMuZmlsZXMuY2F0UmVhZGFibGVTdHJlYW0oc25hcHNob3QuaGFzaCkgOiBhd2FpdCB0aGlzLl9pcGZzLmNhdFJlYWRhYmxlU3RyZWFtKHNuYXBzaG90Lmhhc2gpXG4gICAgICBjb25zdCBsb2FkU25hcHNob3REYXRhID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGxldCBidWYgPSBCdWZmZXIuYWxsb2MoMClcbiAgICAgICAgICBsZXQgcSA9IFtdXG5cbiAgICAgICAgICBjb25zdCBidWZmZXJEYXRhID0gKGQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2J5dGVTaXplICs9IGQubGVuZ3RoXG4gICAgICAgICAgICBpZiAocS5sZW5ndGggPCAyMDAwMCkge1xuICAgICAgICAgICAgICBxLnB1c2goZClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGEgPSBCdWZmZXIuY29uY2F0KHEpXG4gICAgICAgICAgICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW2J1ZiwgYV0pXG4gICAgICAgICAgICAgIHEgPSBbXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGRvbmUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGEgPSBCdWZmZXIuY29uY2F0KHEpXG4gICAgICAgICAgICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW2J1ZiwgYV0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKGJ1Zikge1xuICAgICAgICAgICAgICB2YXIgYWIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmLmxlbmd0aClcbiAgICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShhYilcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2aWV3W2ldID0gYnVmW2ldXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGFiXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclNpemUgPSBwYXJzZUludChuZXcgVWludDE2QXJyYXkodG9BcnJheUJ1ZmZlcihidWYuc2xpY2UoMCwgMikpKSlcbiAgICAgICAgICAgIGxldCBoZWFkZXJcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaGVhZGVyID0gSlNPTi5wYXJzZShidWYuc2xpY2UoMiwgaGVhZGVyU2l6ZSArIDIpKVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBbXVxuICAgICAgICAgICAgbGV0IGEgPSAyICsgaGVhZGVyU2l6ZVxuICAgICAgICAgICAgd2hpbGUgKGEgPCBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHMgPSBwYXJzZUludChuZXcgVWludDE2QXJyYXkodG9BcnJheUJ1ZmZlcihidWYuc2xpY2UoYSwgYSArIDIpKSkpXG4gICAgICAgICAgICAgIGEgKz0gMlxuICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYnVmLnNsaWNlKGEsIGEgKyBzKVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBKU09OLnBhcnNlKGRhdGEpXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goZClcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGEgKz0gc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3R5cGUgPSBoZWFkZXIudHlwZVxuICAgICAgICAgICAgICByZXNvbHZlKHsgdmFsdWVzOiB2YWx1ZXMsIGlkOiBoZWFkZXIuaWQsIGhlYWRzOiBoZWFkZXIuaGVhZHMsIHR5cGU6IGhlYWRlci50eXBlIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKHsgdmFsdWVzOiB2YWx1ZXMsIGlkOiBudWxsLCBoZWFkczogbnVsbCwgdHlwZTogbnVsbCB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXMub24oJ2RhdGEnLCBidWZmZXJEYXRhKVxuICAgICAgICAgIHJlcy5vbignZW5kJywgZG9uZSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25Qcm9ncmVzcyA9IChoYXNoLCBlbnRyeSwgY291bnQsIHRvdGFsKSA9PiB7XG4gICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlUmVwbGljYXRpb25TdGF0dXMoY291bnQsIGVudHJ5LmNsb2NrLnRpbWUpXG4gICAgICAgIHRoaXMuX29uTG9hZFByb2dyZXNzKGhhc2gsIGVudHJ5KVxuICAgICAgfVxuXG4gICAgICAvLyBGZXRjaCB0aGUgZW50cmllc1xuICAgICAgLy8gVGltZW91dCAxIHNlYyB0byBvbmx5IGxvYWQgZW50cmllcyB0aGF0IGFyZSBhbHJlYWR5IGZldGNoZWQgKGluIG9yZGVyIHRvIG5vdCBnZXQgc3R1Y2sgYXQgbG9hZGluZylcbiAgICAgIGNvbnN0IHNuYXBzaG90RGF0YSA9IGF3YWl0IGxvYWRTbmFwc2hvdERhdGEoKVxuICAgICAgdGhpcy5fcmVjYWxjdWxhdGVSZXBsaWNhdGlvbk1heChzbmFwc2hvdERhdGEudmFsdWVzLnJlZHVjZShtYXhDbG9jaywgMCkpXG4gICAgICBpZiAoc25hcHNob3REYXRhKSB7XG4gICAgICAgIGNvbnN0IGxvZyA9IGF3YWl0IExvZy5mcm9tSlNPTih0aGlzLl9pcGZzLCB0aGlzLmlkZW50aXR5LCBzbmFwc2hvdERhdGEsIHsgYWNjZXNzOiB0aGlzLmFjY2Vzcywgc29ydEZuOiB0aGlzLm9wdGlvbnMuc29ydEZuLCBsZW5ndGg6IC0xLCB0aW1lb3V0OiAxMDAwLCBvblByb2dyZXNzQ2FsbGJhY2s6IG9uUHJvZ3Jlc3MgfSlcbiAgICAgICAgYXdhaXQgdGhpcy5fb3Bsb2cuam9pbihsb2cpXG4gICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZUluZGV4KClcbiAgICAgICAgdGhpcy5ldmVudHMuZW1pdCgncmVwbGljYXRlZCcsIHRoaXMuYWRkcmVzcy50b1N0cmluZygpKVxuICAgICAgfVxuICAgICAgdGhpcy5ldmVudHMuZW1pdCgncmVhZHknLCB0aGlzLmFkZHJlc3MudG9TdHJpbmcoKSwgdGhpcy5fb3Bsb2cuaGVhZHMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU25hcHNob3QgZm9yICR7dGhpcy5hZGRyZXNzfSBub3QgZm91bmQhYClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgYXN5bmMgX3VwZGF0ZUluZGV4ICgpIHtcbiAgICB0aGlzLl9yZWNhbGN1bGF0ZVJlcGxpY2F0aW9uTWF4KClcbiAgICBhd2FpdCB0aGlzLl9pbmRleC51cGRhdGVJbmRleCh0aGlzLl9vcGxvZylcbiAgICB0aGlzLl9yZWNhbGN1bGF0ZVJlcGxpY2F0aW9uUHJvZ3Jlc3MoKVxuICB9XG5cbiAgYXN5bmMgc3luY0xvY2FsICgpIHtcbiAgICBjb25zdCBsb2NhbEhlYWRzID0gYXdhaXQgdGhpcy5fY2FjaGUuZ2V0KCdfbG9jYWxIZWFkcycpIHx8IFtdXG4gICAgY29uc3QgcmVtb3RlSGVhZHMgPSBhd2FpdCB0aGlzLl9jYWNoZS5nZXQoJ19yZW1vdGVIZWFkcycpIHx8IFtdXG4gICAgY29uc3QgaGVhZHMgPSBsb2NhbEhlYWRzLmNvbmNhdChyZW1vdGVIZWFkcylcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBoZWFkID0gaGVhZHNbaV1cbiAgICAgIGlmICghdGhpcy5fb3Bsb2cuaGVhZHMuaW5jbHVkZXMoaGVhZCkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkKClcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBfYWRkT3BlcmF0aW9uIChkYXRhLCBiYXRjaE9wZXJhdGlvbiwgbGFzdE9wZXJhdGlvbiwgb25Qcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX29wbG9nKSB7XG4gICAgICAvLyBjaGVjayBsb2NhbCBjYWNoZT9cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3luY0xvY2FsKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc3luY0xvY2FsKClcbiAgICAgIH1cblxuICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCB0aGlzLl9vcGxvZy5hcHBlbmQoZGF0YSwgdGhpcy5vcHRpb25zLnJlZmVyZW5jZUNvdW50KVxuICAgICAgdGhpcy5fcmVjYWxjdWxhdGVSZXBsaWNhdGlvblN0YXR1cyh0aGlzLnJlcGxpY2F0aW9uU3RhdHVzLnByb2dyZXNzICsgMSwgZW50cnkuY2xvY2sudGltZSlcbiAgICAgIGF3YWl0IHRoaXMuX2NhY2hlLnNldCgnX2xvY2FsSGVhZHMnLCBbZW50cnldKVxuICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlSW5kZXgoKVxuICAgICAgdGhpcy5ldmVudHMuZW1pdCgnd3JpdGUnLCB0aGlzLmFkZHJlc3MudG9TdHJpbmcoKSwgZW50cnksIHRoaXMuX29wbG9nLmhlYWRzKVxuICAgICAgaWYgKG9uUHJvZ3Jlc3NDYWxsYmFjaykgb25Qcm9ncmVzc0NhbGxiYWNrKGVudHJ5KVxuICAgICAgcmV0dXJuIGVudHJ5Lmhhc2hcbiAgICB9XG4gIH1cblxuICBfYWRkT3BlcmF0aW9uQmF0Y2ggKGRhdGEsIGJhdGNoT3BlcmF0aW9uLCBsYXN0T3BlcmF0aW9uLCBvblByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCEnKVxuICB9XG5cbiAgX29uTG9hZFByb2dyZXNzIChoYXNoLCBlbnRyeSwgcHJvZ3Jlc3MsIHRvdGFsKSB7XG4gICAgdGhpcy5fcmVjYWxjdWxhdGVSZXBsaWNhdGlvblN0YXR1cyhwcm9ncmVzcywgdG90YWwpXG4gICAgdGhpcy5ldmVudHMuZW1pdCgnbG9hZC5wcm9ncmVzcycsIHRoaXMuYWRkcmVzcy50b1N0cmluZygpLCBoYXNoLCBlbnRyeSwgdGhpcy5yZXBsaWNhdGlvblN0YXR1cy5wcm9ncmVzcywgdGhpcy5yZXBsaWNhdGlvblN0YXR1cy5tYXgpXG4gIH1cblxuICAvKiBSZXBsaWNhdGlvbiBTdGF0dXMgc3RhdGUgdXBkYXRlcyAqL1xuXG4gIF9yZWNhbGN1bGF0ZVJlcGxpY2F0aW9uUHJvZ3Jlc3MgKG1heCkge1xuICAgIHRoaXMuX3JlcGxpY2F0aW9uU3RhdHVzLnByb2dyZXNzID0gTWF0aC5tYXguYXBwbHkobnVsbCwgW1xuICAgICAgdGhpcy5fcmVwbGljYXRpb25TdGF0dXMucHJvZ3Jlc3MsXG4gICAgICB0aGlzLl9vcGxvZy5sZW5ndGgsXG4gICAgICBtYXggfHwgMFxuICAgIF0pXG4gICAgdGhpcy5fcmVjYWxjdWxhdGVSZXBsaWNhdGlvbk1heCh0aGlzLnJlcGxpY2F0aW9uU3RhdHVzLnByb2dyZXNzKVxuICB9XG5cbiAgX3JlY2FsY3VsYXRlUmVwbGljYXRpb25NYXggKG1heCkge1xuICAgIHRoaXMuX3JlcGxpY2F0aW9uU3RhdHVzLm1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIFtcbiAgICAgIHRoaXMuX3JlcGxpY2F0aW9uU3RhdHVzLm1heCxcbiAgICAgIHRoaXMuX29wbG9nLmxlbmd0aCxcbiAgICAgIG1heCB8fCAwXG4gICAgXSlcbiAgfVxuXG4gIF9yZWNhbGN1bGF0ZVJlcGxpY2F0aW9uU3RhdHVzIChtYXhQcm9ncmVzcywgbWF4VG90YWwpIHtcbiAgICB0aGlzLl9yZWNhbGN1bGF0ZVJlcGxpY2F0aW9uUHJvZ3Jlc3MobWF4UHJvZ3Jlc3MpXG4gICAgdGhpcy5fcmVjYWxjdWxhdGVSZXBsaWNhdGlvbk1heChtYXhUb3RhbClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0b3JlXG4iLCIndXNlIHN0cmljdCdcblxuY2xhc3MgRG9jdW1lbnRJbmRleCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9pbmRleCA9IHt9XG4gIH1cblxuICBnZXQgKGtleSwgZnVsbE9wID0gZmFsc2UpIHtcbiAgICByZXR1cm4gZnVsbE9wXG4gICAgICA/IHRoaXMuX2luZGV4W2tleV1cbiAgICAgIDogdGhpcy5faW5kZXhba2V5XSA/IHRoaXMuX2luZGV4W2tleV0ucGF5bG9hZC52YWx1ZSA6IG51bGxcbiAgfVxuXG4gIHVwZGF0ZUluZGV4IChvcGxvZywgb25Qcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgY29uc3QgcmVkdWNlciA9IChoYW5kbGVkLCBpdGVtLCBpZHgpID0+IHtcbiAgICAgIGlmIChoYW5kbGVkW2l0ZW0ucGF5bG9hZC5rZXldICE9PSB0cnVlKSB7XG4gICAgICAgIGhhbmRsZWRbaXRlbS5wYXlsb2FkLmtleV0gPSB0cnVlXG4gICAgICAgIGlmKGl0ZW0ucGF5bG9hZC5vcCA9PT0gJ1BVVCcpIHtcbiAgICAgICAgICB0aGlzLl9pbmRleFtpdGVtLnBheWxvYWQua2V5XSA9IGl0ZW1cbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLnBheWxvYWQub3AgPT09ICdERUwnKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2luZGV4W2l0ZW0ucGF5bG9hZC5rZXldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvblByb2dyZXNzQ2FsbGJhY2spIG9uUHJvZ3Jlc3NDYWxsYmFjayhpdGVtLCBpZHgpXG4gICAgICByZXR1cm4gaGFuZGxlZFxuICAgIH1cblxuICAgIG9wbG9nLnZhbHVlc1xuICAgICAgLnNsaWNlKClcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5yZWR1Y2UocmVkdWNlciwge30pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEb2N1bWVudEluZGV4XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IChpdGVyYWJsZSwgbWFwcGVyLCBvcHRzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdG9wdHMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRjb25jdXJyZW5jeTogSW5maW5pdHlcblx0fSwgb3B0cyk7XG5cblx0Y29uc3QgY29uY3VycmVuY3kgPSBvcHRzLmNvbmN1cnJlbmN5O1xuXG5cdGlmIChjb25jdXJyZW5jeSA8IDEpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgY29uY3VycmVuY3lgIHRvIGJlIGEgbnVtYmVyIGZyb20gMSBhbmQgdXAnKTtcblx0fVxuXG5cdGNvbnN0IHJldCA9IFtdO1xuXHRjb25zdCBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0oKTtcblx0bGV0IGlzUmVqZWN0ZWQgPSBmYWxzZTtcblx0bGV0IGl0ZXJhYmxlRG9uZSA9IGZhbHNlO1xuXHRsZXQgcmVzb2x2aW5nQ291bnQgPSAwO1xuXHRsZXQgY3VycmVudElkeCA9IDA7XG5cblx0Y29uc3QgbmV4dCA9ICgpID0+IHtcblx0XHRpZiAoaXNSZWplY3RlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IG5leHRJdGVtID0gaXRlcmF0b3IubmV4dCgpO1xuXHRcdGNvbnN0IGkgPSBjdXJyZW50SWR4O1xuXHRcdGN1cnJlbnRJZHgrKztcblxuXHRcdGlmIChuZXh0SXRlbS5kb25lKSB7XG5cdFx0XHRpdGVyYWJsZURvbmUgPSB0cnVlO1xuXG5cdFx0XHRpZiAocmVzb2x2aW5nQ291bnQgPT09IDApIHtcblx0XHRcdFx0cmVzb2x2ZShyZXQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0cmVzb2x2aW5nQ291bnQrKztcblxuXHRcdFByb21pc2UucmVzb2x2ZShuZXh0SXRlbS52YWx1ZSlcblx0XHRcdC50aGVuKGVsID0+IG1hcHBlcihlbCwgaSkpXG5cdFx0XHQudGhlbihcblx0XHRcdFx0dmFsID0+IHtcblx0XHRcdFx0XHRyZXRbaV0gPSB2YWw7XG5cdFx0XHRcdFx0cmVzb2x2aW5nQ291bnQtLTtcblx0XHRcdFx0XHRuZXh0KCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVyciA9PiB7XG5cdFx0XHRcdFx0aXNSZWplY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0cmVqZWN0KGVycik7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdH07XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb25jdXJyZW5jeTsgaSsrKSB7XG5cdFx0bmV4dCgpO1xuXG5cdFx0aWYgKGl0ZXJhYmxlRG9uZSkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG59KTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBpc0RlZmluZWQgPSAoYXJnKSA9PiBhcmcgIT09IHVuZGVmaW5lZCAmJiBhcmcgIT09IG51bGxcblxubW9kdWxlLmV4cG9ydHMgPSBpc0RlZmluZWRcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBDb3VudGVyID0gcmVxdWlyZSgnY3JkdHMvc3JjL0ctQ291bnRlcicpXG5cbmNsYXNzIENvdW50ZXJJbmRleCB7XG4gIGNvbnN0cnVjdG9yKGlkKSB7XG4gICAgdGhpcy5faW5kZXggPSBuZXcgQ291bnRlcihpZClcbiAgfVxuXG4gIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kZXhcbiAgfVxuXG4gIHVwZGF0ZUluZGV4KG9wbG9nKSB7XG4gICAgaWYodGhpcy5faW5kZXgpIHtcbiAgICAgIGNvbnN0IGNyZWF0ZUNvdW50ZXIgPSBlID0+IENvdW50ZXIuZnJvbShlLnBheWxvYWQudmFsdWUpXG4gICAgICBjb25zdCBtZXJnZVRvSW5kZXggPSBlID0+IHRoaXMuX2luZGV4Lm1lcmdlKGUpXG4gICAgICBvcGxvZy52YWx1ZXMuZmlsdGVyKGUgPT4gZSAmJiBlLnBheWxvYWQub3AgPT09ICdDT1VOVEVSJylcbiAgICAgICAgLm1hcChjcmVhdGVDb3VudGVyKVxuICAgICAgICAuZm9yRWFjaChtZXJnZVRvSW5kZXgpXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ291bnRlckluZGV4XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBkZWVwRXF1YWwgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3Qgc3VtID0gKGFjYywgdmFsKSA9PiBhY2MgKyB2YWxcblxuLyoqXG4gKiBHLUNvdW50ZXJcbiAqXG4gKiBPcGVyYXRpb24tYmFzZWQgSW5jcmVtZW50LU9ubHkgQ291bnRlciBDUkRUXG4gKlxuICogU291cmNlczogXG4gKiBcIkEgY29tcHJlaGVuc2l2ZSBzdHVkeSBvZiBDb252ZXJnZW50IGFuZCBDb21tdXRhdGl2ZSBSZXBsaWNhdGVkIERhdGEgVHlwZXNcIlxuICogaHR0cDovL2hhbC51cG1jLmZyL2lucmlhLTAwNTU1NTg4L2RvY3VtZW50LCBcIjMuMS4xIE9wLWJhc2VkIGNvdW50ZXIgYW5kIDMuMS4yICBTdGF0ZS1iYXNlZCBpbmNyZW1lbnQtb25seSBDb3VudGVyIChHLUNvdW50ZXIpXCJcbiAqL1xuXG5jbGFzcyBHQ291bnRlciB7XG4gIGNvbnN0cnVjdG9yIChpZCwgY291bnRlcikge1xuICAgIHRoaXMuaWQgPSBpZFxuICAgIHRoaXMuX2NvdW50ZXJzID0gY291bnRlciA/IGNvdW50ZXIgOiB7fVxuICAgIHRoaXMuX2NvdW50ZXJzW3RoaXMuaWRdID0gdGhpcy5fY291bnRlcnNbdGhpcy5pZF0gPyB0aGlzLl9jb3VudGVyc1t0aGlzLmlkXSA6IDBcbiAgfVxuXG4gIGdldCB2YWx1ZSAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fY291bnRlcnMpLnJlZHVjZShzdW0sIDApXG4gIH1cblxuICBpbmNyZW1lbnQgKGFtb3VudCkge1xuICAgIGlmIChhbW91bnQgJiYgYW1vdW50IDwgMSkgXG4gICAgICByZXR1cm5cblxuICAgIGlmIChhbW91bnQgPT09IHVuZGVmaW5lZCB8fCBhbW91bnQgPT09IG51bGwpXG4gICAgICBhbW91bnQgPSAxXG5cbiAgICB0aGlzLl9jb3VudGVyc1t0aGlzLmlkXSA9IHRoaXMuX2NvdW50ZXJzW3RoaXMuaWRdICsgYW1vdW50XG4gIH1cblxuICBtZXJnZSAob3RoZXIpIHtcbiAgICAvLyBHbyB0aHJvdWdoIGVhY2ggY291bnRlciBpbiB0aGUgb3RoZXIgY291bnRlclxuICAgIE9iamVjdC5lbnRyaWVzKG90aGVyLl9jb3VudGVycykuZm9yRWFjaCgoW2lkLCB2YWx1ZV0pID0+IHtcbiAgICAgIC8vIFRha2UgdGhlIG1heGltdW0gb2YgdGhlIGNvdW50ZXIgdmFsdWUgd2UgaGF2ZSBvciB0aGUgY291bnRlciB2YWx1ZSB0aGV5IGhhdmVcbiAgICAgIHRoaXMuX2NvdW50ZXJzW2lkXSA9IE1hdGgubWF4KHRoaXMuX2NvdW50ZXJzW2lkXSB8fCAwLCB2YWx1ZSlcbiAgICB9KVxuICB9XG5cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4geyBcbiAgICAgIGlkOiB0aGlzLmlkLCBcbiAgICAgIGNvdW50ZXJzOiB0aGlzLl9jb3VudGVycyBcbiAgICB9XG4gIH1cblxuICBpc0VxdWFsIChvdGhlcikge1xuICAgIHJldHVybiBHQ291bnRlci5pc0VxdWFsKHRoaXMsIG90aGVyKVxuICB9XG5cbiAgc3RhdGljIGZyb20gKGpzb24pIHtcbiAgICByZXR1cm4gbmV3IEdDb3VudGVyKGpzb24uaWQsIGpzb24uY291bnRlcnMpXG4gIH1cblxuICBzdGF0aWMgaXNFcXVhbCAoYSwgYikge1xuICAgIGlmKGEuaWQgIT09IGIuaWQpXG4gICAgICByZXR1cm4gZmFsc2VcblxuICAgIHJldHVybiBkZWVwRXF1YWwoYS5fY291bnRlcnMsIGIuX2NvdW50ZXJzKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR0NvdW50ZXJcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKVxuY29uc3QgUFJPVE9DT0wgPSByZXF1aXJlKCcuL3Byb3RvY29sJylcbmNvbnN0IGVuY29kZSA9IHJlcXVpcmUoJy4vZW5jb2RpbmcnKVxuY29uc3Qgd2FpdEZvclBlZXJzID0gcmVxdWlyZSgnLi93YWl0LWZvci1wZWVycycpXG5jb25zdCBnZXRQZWVySUQgPSByZXF1aXJlKCcuL2dldC1wZWVyLWlkJylcblxuLyoqXG4gKiBDb21tdW5pY2F0aW9uIGNoYW5uZWwgb3ZlciBQdWJzdWIgYmV0d2VlbiB0d28gSVBGUyBub2Rlc1xuICovXG5jbGFzcyBEaXJlY3RDaGFubmVsIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKGlwZnMsIHJlY2VpdmVySUQpIHtcbiAgICBzdXBlcigpXG5cbiAgICAvLyBJUEZTIGluc3RhbmNlIHRvIHVzZSBpbnRlcm5hbGx5XG4gICAgdGhpcy5faXBmcyA9IGlwZnNcblxuICAgIGlmICghaXBmcy5wdWJzdWIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBJUEZTIG5vZGUgZG9lcyBub3Qgc3VwcG9ydCBwdWJzdWIuJylcbiAgICB9XG5cbiAgICB0aGlzLl9yZWNlaXZlcklEID0gcmVjZWl2ZXJJRFxuXG4gICAgaWYgKCF0aGlzLl9yZWNlaXZlcklEKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY2VpdmVyIElEIHdhcyB1bmRlZmluZWQnKVxuICAgIH1cbiAgICAvLyBTZWUgX3NldHVwKCkgZm9yIG1vcmUgc3RhdGUgaW5pdGlhbGl6YXRpb25cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFubmVsIElEXG4gICAqIEByZXR1cm4ge1tTdHJpbmddfSBDaGFubmVsJ3MgSURcbiAgICovXG4gIGdldCBpZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkXG4gIH1cblxuICAvKipcbiAgICogUGVlcnMgcGFydGljaXBhdGluZyBpbiB0aGlzIGNoYW5uZWxcbiAgICogQHJldHVybiB7W0FycmF5XX0gQXJyYXkgb2YgcGVlciBJRHMgcGFydGljaXBhdGluZyBpbiB0aGlzIGNoYW5uZWxcbiAgICovXG4gIGdldCBwZWVycyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlZXJzXG4gIH1cblxuICBhc3luYyBjb25uZWN0ICgpIHtcbiAgICBhd2FpdCB3YWl0Rm9yUGVlcnModGhpcy5faXBmcywgW3RoaXMuX3JlY2VpdmVySURdLCB0aGlzLl9pZClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlclxuICAgKiBAcGFyYW0gIHtbQW55XX0gbWVzc2FnZSBQYXlsb2FkXG4gICAqL1xuICBhc3luYyBzZW5kIChtZXNzYWdlKSB7XG4gICAgbGV0IG0gPSBlbmNvZGUobWVzc2FnZSlcbiAgICBhd2FpdCB0aGlzLl9pcGZzLnB1YnN1Yi5wdWJsaXNoKHRoaXMuX2lkLCBtKVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlIHRoZSBjaGFubmVsXG4gICAqL1xuICBjbG9zZSAoKSB7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ21lc3NhZ2UnKVxuICAgIHRoaXMuX2lwZnMucHVic3ViLnVuc3Vic2NyaWJlKHRoaXMuX2lkLCB0aGlzLl9tZXNzYWdlSGFuZGxlcilcbiAgfVxuXG4gIGFzeW5jIF9zZXR1cCAoKSB7XG4gICAgdGhpcy5fc2VuZGVySUQgPSBhd2FpdCBnZXRQZWVySUQodGhpcy5faXBmcylcblxuICAgIC8vIENoYW5uZWwncyBwYXJ0aWNpcGFudHNcbiAgICB0aGlzLl9wZWVycyA9IEFycmF5LmZyb20oW3RoaXMuX3NlbmRlcklELCB0aGlzLl9yZWNlaXZlcklEXSkuc29ydCgpXG5cbiAgICAvLyBJRCBvZiB0aGUgY2hhbm5lbCBpcyBcIjxwZWVyMSBpZD4vPHBlZXIgMiBpZD5cIlwiXG4gICAgdGhpcy5faWQgPSAnLycgKyAnJyArIFBST1RPQ09MICsgJy8nICsgdGhpcy5fcGVlcnMuam9pbignLycpXG5cbiAgICAvLyBGdW5jdGlvbiB0byB1c2UgdG8gaGFuZGxlIGluY29taW5nIG1lc3NhZ2VzXG4gICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBtZXNzYWdlID0+IHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgbWVzc2FnZSBpcyBjb21pbmcgZnJvbSB0aGUgY29ycmVjdCBwZWVyXG4gICAgICBjb25zdCBpc1ZhbGlkID0gbWVzc2FnZSAmJiBtZXNzYWdlLmZyb20gPT09IHRoaXMuX3JlY2VpdmVySURcbiAgICAgIC8vIEZpbHRlciBvdXQgYWxsIG1lc3NhZ2VzIHRoYXQgZGlkbid0IGNvbWUgZnJvbSB0aGUgc2Vjb25kIHBlZXJcbiAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIG1lc3NhZ2UpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX29wZW5DaGFubmVsICgpIHtcbiAgICBhd2FpdCB0aGlzLl9zZXR1cCgpXG4gICAgYXdhaXQgdGhpcy5faXBmcy5wdWJzdWIuc3Vic2NyaWJlKHRoaXMuX2lkLCB0aGlzLl9tZXNzYWdlSGFuZGxlcilcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBvcGVuIChpcGZzLCByZWNlaXZlcklEKSB7XG4gICAgY29uc3QgY2hhbm5lbCA9IG5ldyBEaXJlY3RDaGFubmVsKGlwZnMsIHJlY2VpdmVySUQpXG4gICAgYXdhaXQgY2hhbm5lbC5fb3BlbkNoYW5uZWwoKVxuICAgIHJldHVybiBjaGFubmVsXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaXJlY3RDaGFubmVsXG4iLCIndXNlIHN0cmljdCdcblxuY2xhc3MgRXZlbnRJbmRleCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9pbmRleCA9IG51bGxcbiAgfVxuXG4gIGdldCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4ID8gdGhpcy5faW5kZXgudmFsdWVzIDogW11cbiAgfVxuXG4gIHVwZGF0ZUluZGV4IChvcGxvZykge1xuICAgIHRoaXMuX2luZGV4ID0gb3Bsb2dcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50SW5kZXhcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJ2xvZ3BsZWFzZScpXG5jb25zdCBsb2dnZXIgPSBMb2dnZXIuY3JlYXRlKCdjYWNoZScsIHsgY29sb3I6IExvZ2dlci5Db2xvcnMuTWFnZW50YSB9KVxuTG9nZ2VyLnNldExvZ0xldmVsKCdFUlJPUicpXG5cbmxldCBjYWNoZXMgPSB7fVxuXG5jbGFzcyBDYWNoZSB7XG4gIGNvbnN0cnVjdG9yIChzdG9yYWdlLCBkaXJlY3RvcnkpIHtcbiAgICB0aGlzLnBhdGggPSBkaXJlY3RvcnkgfHwgJy4vb3JiaXRkYidcbiAgICB0aGlzLl9zdG9yYWdlID0gc3RvcmFnZVxuICAgIHRoaXMuX3N0b3JlID0gbnVsbFxuICB9XG5cbiAgLy8gU2V0dXAgc3RvcmFnZSBiYWNrZW5kXG4gIGFzeW5jIG9wZW4gKCkge1xuICAgIGxvZ2dlci5kZWJ1Zygnb3BlbicsIHRoaXMucGF0aClcblxuICAgIGlmICh0aGlzLnN0b3JlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3Qgc3RvcmUgPSB0aGlzLl9zdG9yYWdlKHRoaXMucGF0aClcbiAgICAgIHN0b3JlLm9wZW4oKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RvcmUgPSBzdG9yZVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIGNsb3NlICgpIHtcbiAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlJywgdGhpcy5wYXRoKVxuXG4gICAgaWYgKCF0aGlzLl9zdG9yZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3N0b3JlLmNsb3NlKChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0b3JlID0gbnVsbFxuICAgICAgICBkZWxldGUgY2FjaGVzW3RoaXMucGF0aF1cbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBhc3luYyBkZXN0cm95ICgpIHtcbiAgICBsb2dnZXIuZGVidWcoJ2Rlc3Ryb3knLCB0aGlzLnBhdGgpXG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fc3RvcmFnZS5kZXN0cm95KHRoaXMucGF0aCwgKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBhc3luYyBnZXQgKGtleSkge1xuICAgIGlmICghdGhpcy5fc3RvcmUpIHtcbiAgICAgIGF3YWl0IHRoaXMub3BlbigpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0b3JlLnN0YXR1cyAmJiB0aGlzLl9zdG9yZS5zdGF0dXMgIT09ICdvcGVuJykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9zdG9yZS5nZXQoa2V5LCAoZXJyLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGVycm9yIGlmIGtleSB3YXMgbm90IGZvdW5kXG4gICAgICAgICAgaWYgKGVyci50b1N0cmluZygpLmluZGV4T2YoJ05vdEZvdW5kRXJyb3I6IEtleSBub3QgZm91bmQgaW4gZGF0YWJhc2UnKSA9PT0gLTEgJiZcbiAgICAgICAgICAgIGVyci50b1N0cmluZygpLmluZGV4T2YoJ05vdEZvdW5kJykgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSA/IEpTT04ucGFyc2UodmFsdWUpIDogbnVsbClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8vIFNldCB2YWx1ZSBpbiB0aGUgY2FjaGUgYW5kIHJldHVybiB0aGUgbmV3IHZhbHVlXG4gIGFzeW5jIHNldCAoa2V5LCB2YWx1ZSkge1xuICAgIGlmICghdGhpcy5fc3RvcmUpIHtcbiAgICAgIGF3YWl0IHRoaXMub3BlbigpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0b3JlLnN0YXR1cyAmJiB0aGlzLl9zdG9yZS5zdGF0dXMgIT09ICdvcGVuJykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3N0b3JlLnB1dChrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGVycm9yIGlmIGtleSB3YXMgbm90IGZvdW5kXG4gICAgICAgICAgaWYgKGVyci50b1N0cmluZygpLmluZGV4T2YoJ05vdEZvdW5kRXJyb3I6IEtleSBub3QgZm91bmQgaW4gZGF0YWJhc2UnKSA9PT0gLTEgJiZcbiAgICAgICAgICAgIGVyci50b1N0cmluZygpLmluZGV4T2YoJ05vdEZvdW5kJykgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyBSZW1vdmUgYSB2YWx1ZSBhbmQga2V5IGZyb20gdGhlIGNhY2hlXG4gIGFzeW5jIGRlbCAoa2V5KSB7XG4gICAgaWYgKCF0aGlzLl9zdG9yZSkge1xuICAgICAgYXdhaXQgdGhpcy5vcGVuKClcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fc3RvcmUuZGVsKGtleSwgKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGVycm9yIGlmIGtleSB3YXMgbm90IGZvdW5kXG4gICAgICAgICAgaWYgKGVyci50b1N0cmluZygpLmluZGV4T2YoJ05vdEZvdW5kRXJyb3I6IEtleSBub3QgZm91bmQgaW4gZGF0YWJhc2UnKSA9PT0gLTEgJiZcbiAgICAgICAgICAgIGVyci50b1N0cmluZygpLmluZGV4T2YoJ05vdEZvdW5kJykgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoc3RvcmFnZSwgbWtkaXIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBsb2FkOiBhc3luYyAoZGlyZWN0b3J5LCBkYkFkZHJlc3MpID0+IHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnbG9hZCwgZGF0YWJhc2U6JywgZGJBZGRyZXNzLnRvU3RyaW5nKCkpXG5cbiAgICAgIGNvbnN0IGRiUGF0aCA9IHBhdGguam9pbihkYkFkZHJlc3Mucm9vdCwgZGJBZGRyZXNzLnBhdGgpXG4gICAgICBjb25zdCBkYXRhUGF0aCA9IHBhdGguam9pbihkaXJlY3RvcnksIGRiUGF0aClcbiAgICAgIGxldCBjYWNoZSA9IGNhY2hlc1tkYXRhUGF0aF1cbiAgICAgIGlmICghY2FjaGUpIHtcbiAgICAgICAgaWYgKG1rZGlyICYmIG1rZGlyLnN5bmMpIHtcbiAgICAgICAgICBta2Rpci5zeW5jKGRhdGFQYXRoKVxuICAgICAgICB9XG4gICAgICAgIGNhY2hlID0gbmV3IENhY2hlKHN0b3JhZ2UsIGRhdGFQYXRoKVxuICAgICAgICBhd2FpdCBjYWNoZS5vcGVuKClcbiAgICAgICAgY2FjaGVzW2RhdGFQYXRoXSA9IGNhY2hlXG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGVcbiAgICB9LFxuICAgIGNsb3NlOiBhc3luYyAoKSA9PiB7XG4gICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlIGFsbCcpXG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC52YWx1ZXMoY2FjaGVzKSwgY2FjaGUgPT4gY2FjaGUuY2xvc2UoKSlcbiAgICAgIGNhY2hlcyA9IHt9XG4gICAgfVxuICB9XG59XG4iLCIvKiBnbG9iYWwgaW5kZXhlZERCICovXG5cbid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IExldmVsXG5cbnZhciBBYnN0cmFjdExldmVsRE9XTiA9IHJlcXVpcmUoJ2Fic3RyYWN0LWxldmVsZG93bicpLkFic3RyYWN0TGV2ZWxET1dOXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSXRlcmF0b3IgPSByZXF1aXJlKCcuL2l0ZXJhdG9yJylcbnZhciBtaXhlZFRvQnVmZmVyID0gcmVxdWlyZSgnLi91dGlsL21peGVkLXRvLWJ1ZmZlcicpXG52YXIgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgnLi91dGlsL2ltbWVkaWF0ZScpXG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vdXRpbC9zdXBwb3J0JylcblxudmFyIERFRkFVTFRfUFJFRklYID0gJ2xldmVsLWpzLSdcblxuZnVuY3Rpb24gTGV2ZWwgKGxvY2F0aW9uLCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMZXZlbCkpIHJldHVybiBuZXcgTGV2ZWwobG9jYXRpb24sIG9wdHMpXG4gIEFic3RyYWN0TGV2ZWxET1dOLmNhbGwodGhpcylcbiAgb3B0cyA9IG9wdHMgfHwge31cblxuICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignY29uc3RydWN0b3IgcmVxdWlyZXMgYSBsb2NhdGlvbiBzdHJpbmcgYXJndW1lbnQnKVxuICB9XG5cbiAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uXG4gIHRoaXMucHJlZml4ID0gb3B0cy5wcmVmaXggfHwgREVGQVVMVF9QUkVGSVhcbiAgdGhpcy52ZXJzaW9uID0gcGFyc2VJbnQob3B0cy52ZXJzaW9uIHx8IDEsIDEwKVxufVxuXG5pbmhlcml0cyhMZXZlbCwgQWJzdHJhY3RMZXZlbERPV04pXG5cbi8vIERldGVjdCBiaW5hcnkgYW5kIGFycmF5IGtleSBzdXBwb3J0IChJbmRleGVkREIgU2Vjb25kIEVkaXRpb24pXG5MZXZlbC5iaW5hcnlLZXlzID0gc3VwcG9ydC5iaW5hcnlLZXlzKGluZGV4ZWREQilcbkxldmVsLmFycmF5S2V5cyA9IHN1cHBvcnQuYXJyYXlLZXlzKGluZGV4ZWREQilcblxuTGV2ZWwucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciByZXEgPSBpbmRleGVkREIub3Blbih0aGlzLnByZWZpeCArIHRoaXMubG9jYXRpb24sIHRoaXMudmVyc2lvbilcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2socmVxLmVycm9yIHx8IG5ldyBFcnJvcigndW5rbm93biBlcnJvcicpKVxuICB9XG5cbiAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmRiID0gcmVxLnJlc3VsdFxuICAgIGNhbGxiYWNrKClcbiAgfVxuXG4gIHJlcS5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICB2YXIgZGIgPSBldi50YXJnZXQucmVzdWx0XG5cbiAgICBpZiAoIWRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoc2VsZi5sb2NhdGlvbikpIHtcbiAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKHNlbGYubG9jYXRpb24pXG4gICAgfVxuICB9XG59XG5cbkxldmVsLnByb3RvdHlwZS5zdG9yZSA9IGZ1bmN0aW9uIChtb2RlKSB7XG4gIHZhciB0cmFuc2FjdGlvbiA9IHRoaXMuZGIudHJhbnNhY3Rpb24oW3RoaXMubG9jYXRpb25dLCBtb2RlKVxuICByZXR1cm4gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5sb2NhdGlvbilcbn1cblxuTGV2ZWwucHJvdG90eXBlLmF3YWl0ID0gZnVuY3Rpb24gKHJlcXVlc3QsIGNhbGxiYWNrKSB7XG4gIHZhciB0cmFuc2FjdGlvbiA9IHJlcXVlc3QudHJhbnNhY3Rpb25cblxuICAvLyBUYWtlIGFkdmFudGFnZSBvZiB0aGUgZmFjdCB0aGF0IGEgbm9uLWNhbmNlbGVkIHJlcXVlc3QgZXJyb3IgYWJvcnRzXG4gIC8vIHRoZSB0cmFuc2FjdGlvbi4gSS5lLiBubyBuZWVkIHRvIGxpc3RlbiBmb3IgXCJyZXF1ZXN0Lm9uZXJyb3JcIi5cbiAgdHJhbnNhY3Rpb24ub25hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayh0cmFuc2FjdGlvbi5lcnJvciB8fCBuZXcgRXJyb3IoJ2Fib3J0ZWQgYnkgdXNlcicpKVxuICB9XG5cbiAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayhudWxsLCByZXF1ZXN0LnJlc3VsdClcbiAgfVxufVxuXG5MZXZlbC5wcm90b3R5cGUuX2dldCA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBzdG9yZSA9IHRoaXMuc3RvcmUoJ3JlYWRvbmx5JylcblxuICB0cnkge1xuICAgIHZhciByZXEgPSBzdG9yZS5nZXQoa2V5KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKGVycilcbiAgICB9KVxuICB9XG5cbiAgdGhpcy5hd2FpdChyZXEsIGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyAnTm90Rm91bmQnIGVycm9yLCBjb25zaXN0ZW50IHdpdGggTGV2ZWxET1dOIEFQSVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignTm90Rm91bmQnKSlcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hc0J1ZmZlcikge1xuICAgICAgdmFsdWUgPSBtaXhlZFRvQnVmZmVyKHZhbHVlKVxuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIHZhbHVlKVxuICB9KVxufVxuXG5MZXZlbC5wcm90b3R5cGUuX2RlbCA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBzdG9yZSA9IHRoaXMuc3RvcmUoJ3JlYWR3cml0ZScpXG5cbiAgdHJ5IHtcbiAgICB2YXIgcmVxID0gc3RvcmUuZGVsZXRlKGtleSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhlcnIpXG4gICAgfSlcbiAgfVxuXG4gIHRoaXMuYXdhaXQocmVxLCBjYWxsYmFjaylcbn1cblxuTGV2ZWwucHJvdG90eXBlLl9wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZSgncmVhZHdyaXRlJylcblxuICB0cnkge1xuICAgIC8vIFdpbGwgdGhyb3cgYSBEYXRhRXJyb3Igb3IgRGF0YUNsb25lRXJyb3IgaWYgdGhlIGVudmlyb25tZW50XG4gICAgLy8gZG9lcyBub3Qgc3VwcG9ydCBzZXJpYWxpemluZyB0aGUga2V5IG9yIHZhbHVlIHJlc3BlY3RpdmVseS5cbiAgICB2YXIgcmVxID0gc3RvcmUucHV0KHZhbHVlLCBrZXkpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2soZXJyKVxuICAgIH0pXG4gIH1cblxuICB0aGlzLmF3YWl0KHJlcSwgY2FsbGJhY2spXG59XG5cbi8vIFZhbGlkIGtleSB0eXBlcyBpbiBJbmRleGVkREIgU2Vjb25kIEVkaXRpb246XG4vL1xuLy8gLSBOdW1iZXIsIGV4Y2VwdCBOYU4uIEluY2x1ZGVzIEluZmluaXR5IGFuZCAtSW5maW5pdHlcbi8vIC0gRGF0ZSwgZXhjZXB0IGludmFsaWQgKE5hTilcbi8vIC0gU3RyaW5nXG4vLyAtIEFycmF5QnVmZmVyIG9yIGEgdmlldyB0aGVyZW9mICh0eXBlZCBhcnJheXMpLiBJbiBsZXZlbC1qcyB3ZSBhbHNvIHN1cHBvcnRcbi8vICAgQnVmZmVyICh3aGljaCBpcyBhbiBVaW50OEFycmF5KSAoYW5kIHRoZSBwcmltYXJ5IGJpbmFyeSB0eXBlIG9mIExldmVsKS5cbi8vIC0gQXJyYXksIGV4Y2VwdCBjeWNsaWNhbCBhbmQgZW1wdHkgKGUuZy4gQXJyYXkoMTApKS4gRWxlbWVudHMgbXVzdCBiZSB2YWxpZFxuLy8gICB0eXBlcyB0aGVtc2VsdmVzLlxuTGV2ZWwucHJvdG90eXBlLl9zZXJpYWxpemVLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoa2V5KSkge1xuICAgIHJldHVybiBMZXZlbC5iaW5hcnlLZXlzID8ga2V5IDoga2V5LnRvU3RyaW5nKClcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICByZXR1cm4gTGV2ZWwuYXJyYXlLZXlzID8ga2V5Lm1hcCh0aGlzLl9zZXJpYWxpemVLZXksIHRoaXMpIDogU3RyaW5nKGtleSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ga2V5XG4gIH1cbn1cblxuTGV2ZWwucHJvdG90eXBlLl9zZXJpYWxpemVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWVcbn1cblxuTGV2ZWwucHJvdG90eXBlLl9pdGVyYXRvciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgSXRlcmF0b3IodGhpcywgdGhpcy5sb2NhdGlvbiwgb3B0aW9ucylcbn1cblxuTGV2ZWwucHJvdG90eXBlLl9iYXRjaCA9IGZ1bmN0aW9uIChvcGVyYXRpb25zLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAob3BlcmF0aW9ucy5sZW5ndGggPT09IDApIHJldHVybiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spXG5cbiAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZSgncmVhZHdyaXRlJylcbiAgdmFyIHRyYW5zYWN0aW9uID0gc3RvcmUudHJhbnNhY3Rpb25cbiAgdmFyIGluZGV4ID0gMFxuICB2YXIgZXJyb3JcblxuICB0cmFuc2FjdGlvbi5vbmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIGNhbGxiYWNrKGVycm9yIHx8IHRyYW5zYWN0aW9uLmVycm9yIHx8IG5ldyBFcnJvcignYWJvcnRlZCBieSB1c2VyJykpXG4gIH1cblxuICB0cmFuc2FjdGlvbi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGNhbGxiYWNrKClcbiAgfVxuXG4gIC8vIFdhaXQgZm9yIGEgcmVxdWVzdCB0byBjb21wbGV0ZSBiZWZvcmUgbWFraW5nIHRoZSBuZXh0LCBzYXZpbmcgQ1BVLlxuICBmdW5jdGlvbiBsb29wICgpIHtcbiAgICB2YXIgb3AgPSBvcGVyYXRpb25zW2luZGV4KytdXG4gICAgdmFyIGtleSA9IG9wLmtleVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciByZXEgPSBvcC50eXBlID09PSAnZGVsJyA/IHN0b3JlLmRlbGV0ZShrZXkpIDogc3RvcmUucHV0KG9wLnZhbHVlLCBrZXkpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnJvciA9IGVyclxuICAgICAgdHJhbnNhY3Rpb24uYWJvcnQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGluZGV4IDwgb3BlcmF0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBsb29wXG4gICAgfVxuICB9XG5cbiAgbG9vcCgpXG59XG5cbkxldmVsLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy5kYi5jbG9zZSgpXG4gIHNldEltbWVkaWF0ZShjYWxsYmFjaylcbn1cblxuTGV2ZWwuZGVzdHJveSA9IGZ1bmN0aW9uIChsb2NhdGlvbiwgcHJlZml4LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHByZWZpeCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gcHJlZml4XG4gICAgcHJlZml4ID0gREVGQVVMVF9QUkVGSVhcbiAgfVxuICB2YXIgcmVxdWVzdCA9IGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShwcmVmaXggKyBsb2NhdGlvbilcbiAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2soKVxuICB9XG4gIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBjYWxsYmFjayhlcnIpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgbGV2ZWx1cCA9IHJlcXVpcmUoJ2xldmVsdXAnKVxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnbGlicDJwLWNyeXB0bycpXG5jb25zdCBzZWNwMjU2azEgPSByZXF1aXJlKCdzZWNwMjU2azEnKVxuY29uc3QgTFJVID0gcmVxdWlyZSgnbHJ1JylcbmNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyLycpLkJ1ZmZlclxuY29uc3QgeyB2ZXJpZmllciB9ID0gcmVxdWlyZSgnLi92ZXJpZmllcnMnKVxuXG5jbGFzcyBLZXlzdG9yZSB7XG4gIGNvbnN0cnVjdG9yIChzdG9yYWdlLCBkaXJlY3RvcnkpIHtcbiAgICB0aGlzLnBhdGggPSBkaXJlY3RvcnkgfHwgJy4vb3JiaXRkYidcbiAgICB0aGlzLl9zdG9yYWdlID0gc3RvcmFnZVxuICAgIHRoaXMuX3N0b3JlID0gbnVsbFxuICAgIHRoaXMuX2NhY2hlID0gbmV3IExSVSgxMDApXG4gIH1cblxuICBhc3luYyBvcGVuICgpIHtcbiAgICBpZiAodGhpcy5zdG9yZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHN0b3JlID0gbGV2ZWx1cCh0aGlzLl9zdG9yYWdlKHRoaXMucGF0aCkpXG4gICAgICBzdG9yZS5vcGVuKChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0b3JlID0gc3RvcmVcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBhc3luYyBjbG9zZSAoKSB7XG4gICAgaWYgKCF0aGlzLl9zdG9yZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3N0b3JlLmNsb3NlKChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0b3JlID0gbnVsbFxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIGRlc3Ryb3kgKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9zdG9yYWdlLmRlc3Ryb3kodGhpcy5wYXRoLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIGhhc0tleSAoaWQpIHtcbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lkIG5lZWRlZCB0byBjaGVjayBhIGtleScpXG4gICAgfVxuICAgIGlmICghdGhpcy5fc3RvcmUpIHtcbiAgICAgIGF3YWl0IHRoaXMub3BlbigpXG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZS5zdGF0dXMgJiYgdGhpcy5fc3RvcmUuc3RhdHVzICE9PSAnb3BlbicpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbClcbiAgICB9XG5cbiAgICBsZXQgaGFzS2V5ID0gZmFsc2VcbiAgICB0cnkge1xuICAgICAgbGV0IHN0b3JlZEtleSA9IHRoaXMuX2NhY2hlLmdldChpZCkgfHwgYXdhaXQgdGhpcy5fc3RvcmUuZ2V0KGlkKVxuICAgICAgaGFzS2V5ID0gc3RvcmVkS2V5ICE9PSB1bmRlZmluZWQgJiYgc3RvcmVkS2V5ICE9PSBudWxsXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gQ2F0Y2hlcyAnRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSwgb3BlbiA8cGF0aD4nXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5JylcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5jbG9zZSgpXG5cbiAgICByZXR1cm4gaGFzS2V5XG4gIH1cblxuICBhc3luYyBjcmVhdGVLZXkgKGlkKSB7XG4gICAgaWYgKCFpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpZCBuZWVkZWQgdG8gY3JlYXRlIGEga2V5JylcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9zdG9yZSkge1xuICAgICAgYXdhaXQgdGhpcy5vcGVuKClcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0b3JlLnN0YXR1cyAmJiB0aGlzLl9zdG9yZS5zdGF0dXMgIT09ICdvcGVuJykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKVxuICAgIH1cblxuICAgIGNvbnN0IGdlbktleVBhaXIgPSAoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjcnlwdG8ua2V5cy5nZW5lcmF0ZUtleVBhaXIoJ3NlY3AyNTZrMScsIDI1NiwgKGVyciwga2V5KSA9PiB7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgcmVzb2x2ZShrZXkpXG4gICAgICAgIH1cbiAgICAgICAgcmVqZWN0KGVycilcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGNvbnN0IGtleXMgPSBhd2FpdCBnZW5LZXlQYWlyKClcbiAgICBjb25zdCBkZWNvbXByZXNzZWRLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChrZXlzLnB1YmxpYy5tYXJzaGFsKCksIGZhbHNlKVxuICAgIGNvbnN0IGtleSA9IHtcbiAgICAgIHB1YmxpY0tleTogZGVjb21wcmVzc2VkS2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHByaXZhdGVLZXk6IGtleXMubWFyc2hhbCgpLnRvU3RyaW5nKCdoZXgnKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl9zdG9yZS5wdXQoaWQsIEpTT04uc3RyaW5naWZ5KGtleSkpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coZSlcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5jbG9zZSgpXG4gICAgdGhpcy5fY2FjaGUuc2V0KGlkLCBrZXkpXG5cbiAgICByZXR1cm4ga2V5c1xuICB9XG5cbiAgYXN5bmMgZ2V0S2V5IChpZCkge1xuICAgIGlmICghaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaWQgbmVlZGVkIHRvIGdldCBhIGtleScpXG4gICAgfVxuICAgIGlmICghdGhpcy5fc3RvcmUpIHtcbiAgICAgIGF3YWl0IHRoaXMub3BlbigpXG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZS5zdGF0dXMgJiYgdGhpcy5fc3RvcmUuc3RhdHVzICE9PSAnb3BlbicpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbClcbiAgICB9XG5cbiAgICBjb25zdCBjYWNoZWRLZXkgPSB0aGlzLl9jYWNoZS5nZXQoaWQpXG4gICAgbGV0IHN0b3JlZEtleVxuICAgIHRyeSB7XG4gICAgICBzdG9yZWRLZXkgPSBjYWNoZWRLZXkgfHwgYXdhaXQgdGhpcy5fc3RvcmUuZ2V0KGlkKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlnbm9yZSBFTk9FTlQgZXJyb3JcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5jbG9zZSgpXG5cbiAgICBpZiAoIXN0b3JlZEtleSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZGVzZXJpYWxpemVkS2V5ID0gY2FjaGVkS2V5IHx8IEpTT04ucGFyc2Uoc3RvcmVkS2V5KVxuICAgIGlmICghZGVzZXJpYWxpemVkS2V5KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIWNhY2hlZEtleSkge1xuICAgICAgdGhpcy5fY2FjaGUuc2V0KGlkLCBkZXNlcmlhbGl6ZWRLZXkpXG4gICAgfVxuXG5cbiAgICBjb25zdCBnZW5Qcml2S2V5ID0gKHBrKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjcnlwdG8ua2V5cy5zdXBwb3J0ZWRLZXlzLnNlY3AyNTZrMS51bm1hcnNoYWxTZWNwMjU2azFQcml2YXRlS2V5KHBrLCAoZXJyLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICByZXNvbHZlKGtleSlcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoZXJyKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIGdlblByaXZLZXkoQnVmZmVyLmZyb20oZGVzZXJpYWxpemVkS2V5LnByaXZhdGVLZXksICdoZXgnKSlcbiAgfVxuXG4gIGFzeW5jIHNpZ24gKGtleSwgZGF0YSkge1xuICAgIGlmICgha2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25pbmcga2V5IGdpdmVuJylcbiAgICB9XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gaW5wdXQgZGF0YSB3YXMgdW5kZWZpbmVkJylcbiAgICB9XG5cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGtleS5zaWduKGRhdGEsIChlcnIsIHNpZ25hdHVyZSkgPT4ge1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHJlc29sdmUoc2lnbmF0dXJlLnRvU3RyaW5nKCdoZXgnKSlcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoZXJyKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgZ2V0UHVibGljKGtleXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGZvcm1hdHMgPSBbJ2hleCcsICdidWZmZXInXVxuICAgIGNvbnN0IGRlY29tcHJlc3MgPSBvcHRpb25zLmRlY29tcHJlc3MgfHwgdHJ1ZVxuICAgIGNvbnN0IGZvcm1hdCA9IGZvcm1hdHNbb3B0aW9ucy5mb3JtYXQgfHwgJ2hleCddXG4gICAgbGV0IHB1YktleSA9IGtleXMucHVibGljLm1hcnNoYWwoKVxuICAgIGlmIChkZWNvbXByZXNzKSB7XG4gICAgICBwdWJLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChwdWJLZXksIGZhbHNlKVxuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0ID09PSAnYnVmZmVyJyA/IHB1YktleSA6IHB1YktleS50b1N0cmluZygnaGV4JylcbiAgfVxuXG4gIGFzeW5jIHZlcmlmeSAoc2lnbmF0dXJlLCBwdWJsaWNLZXksIGRhdGEsIHYgPSAndjEnKSB7XG4gICAgcmV0dXJuIEtleXN0b3JlLnZlcmlmeShzaWduYXR1cmUsIHB1YmxpY0tleSwgZGF0YSwgdilcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyB2ZXJpZnkgKHNpZ25hdHVyZSwgcHVibGljS2V5LCBkYXRhLCB2ID0gJ3YxJykge1xuICAgIHJldHVybiB2ZXJpZmllcih2KS52ZXJpZnkoc2lnbmF0dXJlLCBwdWJsaWNLZXksIGRhdGEpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoc3RvcmFnZSwgbWtkaXIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBjcmVhdGU6IChkaXJlY3RvcnkgPSAnLi9rZXlzdG9yZScpID0+IHtcbiAgICAgIC8vIElmIHdlJ3JlIGluIE5vZGUuanMsIG1rZGlyIG1vZHVsZSBpcyBleHBlY3RlZCB0byBwYXNzZWRcbiAgICAgIC8vIGFuZCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgZGlyZWN0b3J5IGV4aXN0c1xuICAgICAgaWYgKG1rZGlyICYmIG1rZGlyLnN5bmMpIHtcbiAgICAgICAgbWtkaXIuc3luYyhkaXJlY3RvcnkpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgS2V5c3RvcmUoc3RvcmFnZSwgZGlyZWN0b3J5KVxuICAgIH0sXG4gICAgdmVyaWZ5OiBLZXlzdG9yZS52ZXJpZnlcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG11bHRpYWRkciA9IHJlcXVpcmUoJ211bHRpYWRkcicpXG5cbi8qXG4gKiBWYWxpZCBjb21iaW5hdGlvbnNcbiAqL1xuY29uc3QgRE5TNCA9IGJhc2UoJ2RuczQnKVxuY29uc3QgRE5TNiA9IGJhc2UoJ2RuczYnKVxuY29uc3QgX0ROUyA9IG9yKFxuICBiYXNlKCdkbnNhZGRyJyksXG4gIEROUzQsXG4gIEROUzZcbilcblxuY29uc3QgSVAgPSBvcihiYXNlKCdpcDQnKSwgYmFzZSgnaXA2JykpXG5jb25zdCBUQ1AgPSBvcihcbiAgYW5kKElQLCBiYXNlKCd0Y3AnKSksXG4gIGFuZChfRE5TLCBiYXNlKCd0Y3AnKSlcbilcbmNvbnN0IFVEUCA9IGFuZChJUCwgYmFzZSgndWRwJykpXG5jb25zdCBVVFAgPSBhbmQoVURQLCBiYXNlKCd1dHAnKSlcblxuY29uc3QgRE5TID0gb3IoXG4gIGFuZChfRE5TLCBiYXNlKCd0Y3AnKSksXG4gIF9ETlNcbilcblxuY29uc3QgV2ViU29ja2V0cyA9IG9yKFxuICBhbmQoVENQLCBiYXNlKCd3cycpKSxcbiAgYW5kKEROUywgYmFzZSgnd3MnKSlcbilcblxuY29uc3QgV2ViU29ja2V0c1NlY3VyZSA9IG9yKFxuICBhbmQoVENQLCBiYXNlKCd3c3MnKSksXG4gIGFuZChETlMsIGJhc2UoJ3dzcycpKVxuKVxuXG5jb25zdCBIVFRQID0gb3IoXG4gIGFuZChUQ1AsIGJhc2UoJ2h0dHAnKSksXG4gIGFuZChJUCwgYmFzZSgnaHR0cCcpKSxcbiAgYW5kKEROUywgYmFzZSgnaHR0cCcpKSxcbiAgYW5kKEROUylcbilcblxuY29uc3QgSFRUUFMgPSBvcihcbiAgYW5kKFRDUCwgYmFzZSgnaHR0cHMnKSksXG4gIGFuZChJUCwgYmFzZSgnaHR0cHMnKSksXG4gIGFuZChETlMsIGJhc2UoJ2h0dHBzJykpXG4pXG5cbmNvbnN0IFdlYlJUQ1N0YXIgPSBvcihcbiAgYW5kKFdlYlNvY2tldHMsIGJhc2UoJ3AycC13ZWJydGMtc3RhcicpLCBiYXNlKCdpcGZzJykpLFxuICBhbmQoV2ViU29ja2V0c1NlY3VyZSwgYmFzZSgncDJwLXdlYnJ0Yy1zdGFyJyksIGJhc2UoJ2lwZnMnKSlcbilcblxuY29uc3QgV2ViU29ja2V0U3RhciA9IG9yKFxuICBhbmQoV2ViU29ja2V0cywgYmFzZSgncDJwLXdlYnNvY2tldC1zdGFyJyksIGJhc2UoJ2lwZnMnKSksXG4gIGFuZChXZWJTb2NrZXRzU2VjdXJlLCBiYXNlKCdwMnAtd2Vic29ja2V0LXN0YXInKSwgYmFzZSgnaXBmcycpKSxcbiAgYW5kKFdlYlNvY2tldHMsIGJhc2UoJ3AycC13ZWJzb2NrZXQtc3RhcicpKSxcbiAgYW5kKFdlYlNvY2tldHNTZWN1cmUsIGJhc2UoJ3AycC13ZWJzb2NrZXQtc3RhcicpKVxuKVxuXG5jb25zdCBXZWJSVENEaXJlY3QgPSBvcihcbiAgYW5kKEhUVFAsIGJhc2UoJ3AycC13ZWJydGMtZGlyZWN0JykpLFxuICBhbmQoSFRUUFMsIGJhc2UoJ3AycC13ZWJydGMtZGlyZWN0JykpXG4pXG5cbmNvbnN0IFJlbGlhYmxlID0gb3IoXG4gIFdlYlNvY2tldHMsXG4gIFdlYlNvY2tldHNTZWN1cmUsXG4gIEhUVFAsXG4gIEhUVFBTLFxuICBXZWJSVENTdGFyLFxuICBXZWJSVENEaXJlY3QsXG4gIFRDUCxcbiAgVVRQXG4pXG5cbi8vIFVubGlrZSB3cy1zdGFyLCBzdGFyZHVzdCBjYW4gcnVuIG92ZXIgYW55IHRyYW5zcG9ydCB0aHVzIHJlbW92aW5nIHRoZSByZXF1aXJlbWVudCBmb3Igd2Vic29ja2V0cyAoYnV0IGRvbid0IGV2ZW4gdGhpbmsgYWJvdXQgcnVubmluZyBhIHN0YXJkdXN0IHNlcnZlciBvdmVyIHdlYnJ0Yy1zdGFyIDspIClcbmNvbnN0IFN0YXJkdXN0ID0gb3IoXG4gIGFuZChSZWxpYWJsZSwgYmFzZSgncDJwLXN0YXJkdXN0JyksIGJhc2UoJ2lwZnMnKSksXG4gIGFuZChSZWxpYWJsZSwgYmFzZSgncDJwLXN0YXJkdXN0JykpXG4pXG5cbmxldCBfSVBGUyA9IG9yKFxuICBhbmQoUmVsaWFibGUsIGJhc2UoJ2lwZnMnKSksXG4gIFdlYlJUQ1N0YXIsXG4gIGJhc2UoJ2lwZnMnKVxuKVxuXG5jb25zdCBfQ2lyY3VpdCA9IG9yKFxuICBhbmQoX0lQRlMsIGJhc2UoJ3AycC1jaXJjdWl0JyksIF9JUEZTKSxcbiAgYW5kKF9JUEZTLCBiYXNlKCdwMnAtY2lyY3VpdCcpKSxcbiAgYW5kKGJhc2UoJ3AycC1jaXJjdWl0JyksIF9JUEZTKSxcbiAgYW5kKFJlbGlhYmxlLCBiYXNlKCdwMnAtY2lyY3VpdCcpKSxcbiAgYW5kKGJhc2UoJ3AycC1jaXJjdWl0JyksIFJlbGlhYmxlKSxcbiAgYmFzZSgncDJwLWNpcmN1aXQnKVxuKVxuXG5jb25zdCBDaXJjdWl0UmVjdXJzaXZlID0gKCkgPT4gb3IoXG4gIGFuZChfQ2lyY3VpdCwgQ2lyY3VpdFJlY3Vyc2l2ZSksXG4gIF9DaXJjdWl0XG4pXG5cbmNvbnN0IENpcmN1aXQgPSBDaXJjdWl0UmVjdXJzaXZlKClcblxuY29uc3QgSVBGUyA9IG9yKFxuICBhbmQoQ2lyY3VpdCwgX0lQRlMsIENpcmN1aXQpLFxuICBhbmQoX0lQRlMsIENpcmN1aXQpLFxuICBhbmQoQ2lyY3VpdCwgX0lQRlMpLFxuICBDaXJjdWl0LFxuICBfSVBGU1xuKVxuXG5leHBvcnRzLkROUyA9IEROU1xuZXhwb3J0cy5ETlM0ID0gRE5TNFxuZXhwb3J0cy5ETlM2ID0gRE5TNlxuZXhwb3J0cy5JUCA9IElQXG5leHBvcnRzLlRDUCA9IFRDUFxuZXhwb3J0cy5VRFAgPSBVRFBcbmV4cG9ydHMuVVRQID0gVVRQXG5leHBvcnRzLkhUVFAgPSBIVFRQXG5leHBvcnRzLkhUVFBTID0gSFRUUFNcbmV4cG9ydHMuV2ViU29ja2V0cyA9IFdlYlNvY2tldHNcbmV4cG9ydHMuV2ViU29ja2V0c1NlY3VyZSA9IFdlYlNvY2tldHNTZWN1cmVcbmV4cG9ydHMuV2ViU29ja2V0U3RhciA9IFdlYlNvY2tldFN0YXJcbmV4cG9ydHMuV2ViUlRDU3RhciA9IFdlYlJUQ1N0YXJcbmV4cG9ydHMuV2ViUlRDRGlyZWN0ID0gV2ViUlRDRGlyZWN0XG5leHBvcnRzLlJlbGlhYmxlID0gUmVsaWFibGVcbmV4cG9ydHMuU3RhcmR1c3QgPSBTdGFyZHVzdFxuZXhwb3J0cy5DaXJjdWl0ID0gQ2lyY3VpdFxuZXhwb3J0cy5JUEZTID0gSVBGU1xuXG4vKlxuICogVmFsaWRhdGlvbiBmdW5jc1xuICovXG5cbmZ1bmN0aW9uIG1ha2VNYXRjaGVzRnVuY3Rpb24gKHBhcnRpYWxNYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gbWF0Y2hlcyAoYSkge1xuICAgIGlmICghbXVsdGlhZGRyLmlzTXVsdGlhZGRyKGEpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhID0gbXVsdGlhZGRyKGEpXG4gICAgICB9IGNhdGNoIChlcnIpIHsgLy8gY2F0Y2ggZXJyb3JcbiAgICAgICAgcmV0dXJuIGZhbHNlIC8vIGFsc28gaWYgaXQncyBpbnZhbGlkIGl0J3MgcHJvcGFibHkgbm90IG1hdGNoaW5nIGFzIHdlbGwgc28gcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGxldCBvdXQgPSBwYXJ0aWFsTWF0Y2goYS5wcm90b05hbWVzKCkpXG4gICAgaWYgKG91dCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiBvdXQubGVuZ3RoID09PSAwXG4gIH1cbn1cblxuZnVuY3Rpb24gYW5kICgpIHtcbiAgY29uc3QgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKVxuICBmdW5jdGlvbiBwYXJ0aWFsTWF0Y2ggKGEpIHtcbiAgICBpZiAoYS5sZW5ndGggPCBhcmdzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgYXJncy5zb21lKChhcmcpID0+IHtcbiAgICAgIGEgPSB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gYXJnKCkucGFydGlhbE1hdGNoKGEpXG4gICAgICAgIDogYXJnLnBhcnRpYWxNYXRjaChhKVxuXG4gICAgICBpZiAoYSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gYVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ3sgJyArIGFyZ3Muam9pbignICcpICsgJyB9JyB9LFxuICAgIGlucHV0OiBhcmdzLFxuICAgIG1hdGNoZXM6IG1ha2VNYXRjaGVzRnVuY3Rpb24ocGFydGlhbE1hdGNoKSxcbiAgICBwYXJ0aWFsTWF0Y2g6IHBhcnRpYWxNYXRjaFxuICB9XG59XG5cbmZ1bmN0aW9uIG9yICgpIHtcbiAgY29uc3QgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKVxuXG4gIGZ1bmN0aW9uIHBhcnRpYWxNYXRjaCAoYSkge1xuICAgIGxldCBvdXQgPSBudWxsXG4gICAgYXJncy5zb21lKChhcmcpID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBhcmcoKS5wYXJ0aWFsTWF0Y2goYSlcbiAgICAgICAgOiBhcmcucGFydGlhbE1hdGNoKGEpXG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIG91dCA9IHJlc1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gb3V0XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICd7ICcgKyBhcmdzLmpvaW4oJyAnKSArICcgfScgfSxcbiAgICBpbnB1dDogYXJncyxcbiAgICBtYXRjaGVzOiBtYWtlTWF0Y2hlc0Z1bmN0aW9uKHBhcnRpYWxNYXRjaCksXG4gICAgcGFydGlhbE1hdGNoOiBwYXJ0aWFsTWF0Y2hcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gYmFzZSAobikge1xuICBjb25zdCBuYW1lID0gblxuXG4gIGZ1bmN0aW9uIG1hdGNoZXMgKGEpIHtcbiAgICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhID0gbXVsdGlhZGRyKGEpXG4gICAgICB9IGNhdGNoIChlcnIpIHsgLy8gY2F0Y2ggZXJyb3JcbiAgICAgICAgcmV0dXJuIGZhbHNlIC8vIGFsc28gaWYgaXQncyBpbnZhbGlkIGl0J3MgcHJvcGFibHkgbm90IG1hdGNoaW5nIGFzIHdlbGwgc28gcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcG5hbWVzID0gYS5wcm90b05hbWVzKClcbiAgICBpZiAocG5hbWVzLmxlbmd0aCA9PT0gMSAmJiBwbmFtZXNbMF0gPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gcGFydGlhbE1hdGNoIChwcm90b3MpIHtcbiAgICBpZiAocHJvdG9zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBpZiAocHJvdG9zWzBdID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gcHJvdG9zLnNsaWNlKDEpXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuYW1lIH0sXG4gICAgbWF0Y2hlczogbWF0Y2hlcyxcbiAgICBwYXJ0aWFsTWF0Y2g6IHBhcnRpYWxNYXRjaFxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4KSB7XG5cdHZhciBwcm90b3R5cGU7XG5cdHJldHVybiB0b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBPYmplY3RdJyAmJiAocHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpLCBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pKTtcbn07XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3Qgd2F0ZXJmYWxsID0gcmVxdWlyZSgnYXN5bmMvd2F0ZXJmYWxsJylcbmNvbnN0IHNlcmllcyA9IHJlcXVpcmUoJ2FzeW5jL3NlcmllcycpXG5jb25zdCBwYXJhbGxlbCA9IHJlcXVpcmUoJ2FzeW5jL3BhcmFsbGVsJylcbmNvbnN0IGVhY2ggPSByZXF1aXJlKCdhc3luYy9lYWNoJylcbmNvbnN0IF9nZXQgPSByZXF1aXJlKCdkbHYnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgQmlnID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJylcbmNvbnN0IHB1bGwgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS9wdWxsJylcbmNvbnN0IHJlZHVjZSA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3NpbmtzL3JlZHVjZScpXG5cbmNvbnN0IGJhY2tlbmRzID0gcmVxdWlyZSgnLi9iYWNrZW5kcycpXG5jb25zdCB2ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJylcbmNvbnN0IGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJylcbmNvbnN0IHNwZWMgPSByZXF1aXJlKCcuL3NwZWMnKVxuY29uc3QgYXBpQWRkciA9IHJlcXVpcmUoJy4vYXBpLWFkZHInKVxuY29uc3QgYmxvY2tzdG9yZSA9IHJlcXVpcmUoJy4vYmxvY2tzdG9yZScpXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHJlcXVpcmUoJy4vZGVmYXVsdC1vcHRpb25zJylcbmNvbnN0IGRlZmF1bHREYXRhc3RvcmUgPSByZXF1aXJlKCcuL2RlZmF1bHQtZGF0YXN0b3JlJylcbmNvbnN0IEVSUk9SUyA9IHJlcXVpcmUoJy4vZXJyb3JzJylcblxuY29uc3QgbG9nID0gZGVidWcoJ3JlcG8nKVxuXG5jb25zdCBub0xpbWl0ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcblxuY29uc3QgbG9ja2VycyA9IHtcbiAgbWVtb3J5OiByZXF1aXJlKCcuL2xvY2stbWVtb3J5JyksXG4gIGZzOiByZXF1aXJlKCcuL2xvY2snKVxufVxuXG5jb25zdCByZXBvVmVyc2lvbiA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJykucmVwb1ZlcnNpb25cblxuLyoqXG4gKiBJcGZzUmVwbyBpbXBsZW1lbnRzIGFsbCByZXF1aXJlZCBmdW5jdGlvbmFsaXR5IHRvIHJlYWQgYW5kIHdyaXRlIHRvIGFuIGlwZnMgcmVwby5cbiAqXG4gKi9cbmNsYXNzIElwZnNSZXBvIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXBvUGF0aCAtIHBhdGggd2hlcmUgdGhlIHJlcG8gaXMgc3RvcmVkXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gQ29uZmlndXJhdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IgKHJlcG9QYXRoLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiByZXBvUGF0aCwgJ3N0cmluZycsICdtaXNzaW5nIHJlcG9QYXRoJylcblxuICAgIHRoaXMub3B0aW9ucyA9IGJ1aWxkT3B0aW9ucyhvcHRpb25zKVxuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZVxuICAgIHRoaXMucGF0aCA9IHJlcG9QYXRoXG5cbiAgICB0aGlzLl9sb2NrZXIgPSB0aGlzLl9nZXRMb2NrZXIoKVxuXG4gICAgdGhpcy5yb290ID0gYmFja2VuZHMuY3JlYXRlKCdyb290JywgdGhpcy5wYXRoLCB0aGlzLm9wdGlvbnMpXG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbih0aGlzLnJvb3QpXG4gICAgdGhpcy5jb25maWcgPSBjb25maWcodGhpcy5yb290KVxuICAgIHRoaXMuc3BlYyA9IHNwZWModGhpcy5yb290KVxuICAgIHRoaXMuYXBpQWRkciA9IGFwaUFkZHIodGhpcy5yb290KVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYSBuZXcgcmVwby5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIGNvbmZpZyB0byB3cml0ZSBpbnRvIGBjb25maWdgLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBpbml0IChjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgbG9nKCdpbml0aWFsaXppbmcgYXQ6ICVzJywgdGhpcy5wYXRoKVxuXG4gICAgc2VyaWVzKFtcbiAgICAgIChjYikgPT4gdGhpcy5yb290Lm9wZW4oaWdub3JpbmdBbHJlYWR5T3BlbmVkKGNiKSksXG4gICAgICAoY2IpID0+IHRoaXMuY29uZmlnLnNldChidWlsZENvbmZpZyhjb25maWcpLCBjYiksXG4gICAgICAoY2IpID0+IHRoaXMuc3BlYy5zZXQoYnVpbGREYXRhc3RvcmVTcGVjKGNvbmZpZyksIGNiKSxcbiAgICAgIChjYikgPT4gdGhpcy52ZXJzaW9uLnNldChyZXBvVmVyc2lvbiwgY2IpXG4gICAgXSwgY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogT3BlbiB0aGUgcmVwby4gSWYgdGhlIHJlcG8gaXMgYWxyZWFkeSBvcGVuIG5vIGFjdGlvbiB3aWxsIGJlIHRha2VuLlxuICAgKiBJZiB0aGUgcmVwbyBpcyBub3QgaW5pdGlhbGl6ZWQgaXQgd2lsbCByZXR1cm4gYW4gZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIG9wZW4gKGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmNsb3NlZCkge1xuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKG5ldyBFcnJvcigncmVwbyBpcyBhbHJlYWR5IG9wZW4nKSkpXG4gICAgICByZXR1cm4gLy8gZWFybHlcbiAgICB9XG4gICAgbG9nKCdvcGVuaW5nIGF0OiAlcycsIHRoaXMucGF0aClcblxuICAgIC8vIGNoZWNrIGlmIHRoZSByZXBvIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICB3YXRlcmZhbGwoW1xuICAgICAgKGNiKSA9PiB0aGlzLnJvb3Qub3BlbihpZ25vcmluZ0FscmVhZHlPcGVuZWQoY2IpKSxcbiAgICAgIChjYikgPT4gdGhpcy5faXNJbml0aWFsaXplZChjYiksXG4gICAgICAoY2IpID0+IHRoaXMuX29wZW5Mb2NrKHRoaXMucGF0aCwgY2IpLFxuICAgICAgKGxjaywgY2IpID0+IHtcbiAgICAgICAgbG9nKCdhcXVpcmVkIHJlcG8ubG9jaycpXG4gICAgICAgIHRoaXMubG9ja2ZpbGUgPSBsY2tcbiAgICAgICAgY2IoKVxuICAgICAgfSxcbiAgICAgIChjYikgPT4ge1xuICAgICAgICBsb2coJ2NyZWF0aW5nIGRhdGFzdG9yZScpXG4gICAgICAgIHRoaXMuZGF0YXN0b3JlID0gYmFja2VuZHMuY3JlYXRlKCdkYXRhc3RvcmUnLCBwYXRoLmpvaW4odGhpcy5wYXRoLCAnZGF0YXN0b3JlJyksIHRoaXMub3B0aW9ucylcbiAgICAgICAgbG9nKCdjcmVhdGluZyBibG9ja3MnKVxuICAgICAgICBjb25zdCBibG9ja3NCYXNlU3RvcmUgPSBiYWNrZW5kcy5jcmVhdGUoJ2Jsb2NrcycsIHBhdGguam9pbih0aGlzLnBhdGgsICdibG9ja3MnKSwgdGhpcy5vcHRpb25zKVxuICAgICAgICBibG9ja3N0b3JlKFxuICAgICAgICAgIGJsb2Nrc0Jhc2VTdG9yZSxcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuc3RvcmFnZUJhY2tlbmRPcHRpb25zLmJsb2NrcyxcbiAgICAgICAgICBjYilcbiAgICAgIH0sXG4gICAgICAoYmxvY2tzLCBjYikgPT4ge1xuICAgICAgICB0aGlzLmJsb2NrcyA9IGJsb2Nrc1xuICAgICAgICBjYigpXG4gICAgICB9LFxuICAgICAgKGNiKSA9PiB7XG4gICAgICAgIGxvZygnY3JlYXRpbmcga2V5c3RvcmUnKVxuICAgICAgICB0aGlzLmtleXMgPSBiYWNrZW5kcy5jcmVhdGUoJ2tleXMnLCBwYXRoLmpvaW4odGhpcy5wYXRoLCAna2V5cycpLCB0aGlzLm9wdGlvbnMpXG4gICAgICAgIGNiKClcbiAgICAgIH0sXG5cbiAgICAgIChjYikgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlXG4gICAgICAgIGxvZygnYWxsIG9wZW5lZCcpXG4gICAgICAgIGNiKClcbiAgICAgIH1cbiAgICBdLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyICYmIHRoaXMubG9ja2ZpbGUpIHtcbiAgICAgICAgdGhpcy5fY2xvc2VMb2NrKChlcnIyKSA9PiB7XG4gICAgICAgICAgaWYgKCFlcnIyKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2tmaWxlID0gbnVsbFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2coJ2Vycm9yIHJlbW92aW5nIGxvY2snLCBlcnIyKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXBvIGxvY2tlciB0byBiZSB1c2VkLiBOdWxsIHdpbGwgYmUgcmV0dXJuZWQgaWYgbm8gbG9ja2VyIGlzIHJlcXVlc3RlZFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7TG9ja2VyfVxuICAgKi9cbiAgX2dldExvY2tlciAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMubG9jayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGFzc2VydChsb2NrZXJzW3RoaXMub3B0aW9ucy5sb2NrXSwgJ1Vua25vd24gbG9jayB0eXBlOiAnICsgdGhpcy5vcHRpb25zLmxvY2spXG4gICAgICByZXR1cm4gbG9ja2Vyc1t0aGlzLm9wdGlvbnMubG9ja11cbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5vcHRpb25zLmxvY2ssICdObyBsb2NrIHByb3ZpZGVkJylcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxvY2tcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbG9jayBvbiB0aGUgcmVwbyBpZiBhIGxvY2tlciBpcyBzcGVjaWZpZWQuIFRoZSBsb2NrZmlsZSBvYmplY3Qgd2lsbFxuICAgKiBiZSByZXR1cm5lZCBpbiB0aGUgY2FsbGJhY2sgaWYgb25lIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIGxvY2tmaWxlKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfb3BlbkxvY2sgKHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fbG9ja2VyLmxvY2socGF0aCwgKGVyciwgbG9ja2ZpbGUpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgbnVsbClcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBsb2NrZmlsZS5jbG9zZSwgJ2Z1bmN0aW9uJywgJ0xvY2tzIG11c3QgaGF2ZSBhIGNsb3NlIG1ldGhvZCcpXG4gICAgICBjYWxsYmFjayhudWxsLCBsb2NrZmlsZSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgbG9jayBvbiB0aGUgcmVwb1xuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfY2xvc2VMb2NrIChjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmxvY2tmaWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2NrZmlsZS5jbG9zZShjYWxsYmFjaylcbiAgICB9XG4gICAgY2FsbGJhY2soKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSByZXBvIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9pc0luaXRpYWxpemVkIChjYWxsYmFjaykge1xuICAgIGxvZygnaW5pdCBjaGVjaycpXG4gICAgcGFyYWxsZWwoXG4gICAgICB7XG4gICAgICAgIGNvbmZpZzogKGNiKSA9PiB0aGlzLmNvbmZpZy5leGlzdHMoY2IpLFxuICAgICAgICBzcGVjOiAoY2IpID0+IHRoaXMuc3BlYy5leGlzdHMoY2IpLFxuICAgICAgICB2ZXJzaW9uOiAoY2IpID0+IHRoaXMudmVyc2lvbi5jaGVjayhyZXBvVmVyc2lvbiwgY2IpXG4gICAgICB9LFxuICAgICAgKGVyciwgcmVzKSA9PiB7XG4gICAgICAgIGxvZygnaW5pdCcsIGVyciwgcmVzKVxuICAgICAgICBpZiAoZXJyICYmICFyZXMuY29uZmlnKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdyZXBvIGlzIG5vdCBpbml0aWFsaXplZCB5ZXQnKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29kZTogRVJST1JTLkVSUl9SRVBPX05PVF9JTklUSUFMSVpFRCxcbiAgICAgICAgICAgICAgcGF0aDogdGhpcy5wYXRoXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlIHRoZSByZXBvIGFuZCBjbGVhbnVwLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBjbG9zZSAoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ3JlcG8gaXMgYWxyZWFkeSBjbG9zZWQnKSlcbiAgICB9XG5cbiAgICBsb2coJ2Nsb3NpbmcgYXQ6ICVzJywgdGhpcy5wYXRoKVxuICAgIHNlcmllcyhbXG4gICAgICAoY2IpID0+IHRoaXMuYXBpQWRkci5kZWxldGUoaWdub3JpbmdOb3RGb3VuZChjYikpLFxuICAgICAgKGNiKSA9PiB7XG4gICAgICAgIGVhY2goXG4gICAgICAgICAgW3RoaXMuYmxvY2tzLCB0aGlzLmtleXMsIHRoaXMuZGF0YXN0b3JlXSxcbiAgICAgICAgICAoc3RvcmUsIGNhbGxiYWNrKSA9PiBzdG9yZS5jbG9zZShjYWxsYmFjayksXG4gICAgICAgICAgY2IpXG4gICAgICB9LFxuICAgICAgKGNiKSA9PiB7XG4gICAgICAgIGxvZygndW5sb2NraW5nJylcbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlXG4gICAgICAgIHRoaXMuX2Nsb3NlTG9jayhjYilcbiAgICAgIH0sXG4gICAgICAoY2IpID0+IHtcbiAgICAgICAgdGhpcy5sb2NrZmlsZSA9IG51bGxcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgIF0sIChlcnIpID0+IGNhbGxiYWNrKGVycikpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSByZXBvIGV4aXN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgYm9vbCl9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZXhpc3RzIChjYWxsYmFjaykge1xuICAgIHRoaXMudmVyc2lvbi5leGlzdHMoY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogR2V0IHJlcG8gc3RhdHVzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmh1bWFuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIE9iamVjdCl9IGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBzdGF0IChvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgeyBodW1hbjogZmFsc2UgfSwgb3B0aW9ucylcblxuICAgIHBhcmFsbGVsKHtcbiAgICAgIHN0b3JhZ2VNYXg6IChjYikgPT4gdGhpcy5jb25maWcuZ2V0KCdEYXRhc3RvcmUuU3RvcmFnZU1heCcsIChlcnIsIG1heCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY2IobnVsbCwgbmV3IEJpZyhub0xpbWl0KSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYihudWxsLCBuZXcgQmlnKG1heCkpXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdmVyc2lvbjogKGNiKSA9PiB0aGlzLnZlcnNpb24uZ2V0KGNiKSxcbiAgICAgIGJsb2NrczogKGNiKSA9PiB0aGlzLmJsb2Nrcy5xdWVyeSh7fSwgKGVyciwgbGlzdCkgPT4ge1xuICAgICAgICBsaXN0ID0gbGlzdCB8fCBbXVxuXG4gICAgICAgIGNvbnN0IGNvdW50ID0gbmV3IEJpZyhsaXN0Lmxlbmd0aClcbiAgICAgICAgbGV0IHNpemUgPSBuZXcgQmlnKDApXG5cbiAgICAgICAgbGlzdC5mb3JFYWNoKGJsb2NrID0+IHtcbiAgICAgICAgICBzaXplID0gc2l6ZVxuICAgICAgICAgICAgLnBsdXMoYmxvY2sudmFsdWUuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgIC5wbHVzKGJsb2NrLmtleS5fYnVmLmJ5dGVMZW5ndGgpXG4gICAgICAgIH0pXG5cbiAgICAgICAgY2IoZXJyLCB7XG4gICAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICAgIHNpemU6IHNpemVcbiAgICAgICAgfSlcbiAgICAgIH0pLFxuICAgICAgZGF0YXN0b3JlOiAoY2IpID0+IGdldFNpemUodGhpcy5kYXRhc3RvcmUsIGNiKSxcbiAgICAgIGtleXM6IChjYikgPT4gZ2V0U2l6ZSh0aGlzLmtleXMsIGNiKVxuICAgIH0sIChlcnIsIHJlc3VsdHMpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG5cbiAgICAgIGxldCBzaXplID0gcmVzdWx0cy5ibG9ja3Muc2l6ZVxuICAgICAgICAucGx1cyhyZXN1bHRzLmRhdGFzdG9yZSlcbiAgICAgICAgLnBsdXMocmVzdWx0cy5rZXlzKVxuXG4gICAgICBpZiAob3B0aW9ucy5odW1hbikge1xuICAgICAgICBzaXplID0gc2l6ZS5kaXYoMTA0ODU3NilcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICByZXBvUGF0aDogdGhpcy5wYXRoLFxuICAgICAgICBzdG9yYWdlTWF4OiByZXN1bHRzLnN0b3JhZ2VNYXgsXG4gICAgICAgIHZlcnNpb246IHJlc3VsdHMudmVyc2lvbixcbiAgICAgICAgbnVtT2JqZWN0czogcmVzdWx0cy5ibG9ja3MuY291bnQsXG4gICAgICAgIHJlcG9TaXplOiBzaXplXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZSAocXVlcnlGbiwgY2FsbGJhY2spIHtcbiAgcHVsbChcbiAgICBxdWVyeUZuLnF1ZXJ5KHt9KSxcbiAgICByZWR1Y2UoKHN1bSwgYmxvY2spID0+IHtcbiAgICAgIHJldHVybiBzdW1cbiAgICAgICAgLnBsdXMoYmxvY2sudmFsdWUuYnl0ZUxlbmd0aClcbiAgICAgICAgLnBsdXMoYmxvY2sua2V5Ll9idWYuYnl0ZUxlbmd0aClcbiAgICB9LCBuZXcgQmlnKDApLCBjYWxsYmFjaykpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gSXBmc1JlcG9cbm1vZHVsZS5leHBvcnRzLnJlcG9WZXJzaW9uID0gcmVwb1ZlcnNpb25cbm1vZHVsZS5leHBvcnRzLmVycm9ycyA9IEVSUk9SU1xuXG5mdW5jdGlvbiBpZ25vcmluZ0lmIChjb25kLCBjYikge1xuICByZXR1cm4gKGVycikgPT4ge1xuICAgIGNiKGVyciAmJiAhY29uZChlcnIpID8gZXJyIDogbnVsbClcbiAgfVxufVxuZnVuY3Rpb24gaWdub3JpbmdBbHJlYWR5T3BlbmVkIChjYikge1xuICByZXR1cm4gaWdub3JpbmdJZigoZXJyKSA9PiBlcnIubWVzc2FnZSA9PT0gJ0FscmVhZHkgb3BlbicsIGNiKVxufVxuXG5mdW5jdGlvbiBpZ25vcmluZ05vdEZvdW5kIChjYikge1xuICByZXR1cm4gaWdub3JpbmdJZigoZXJyKSA9PiB7XG4gICAgcmV0dXJuIGVyciAmJiAoZXJyLmNvZGUgPT09IEVSUk9SUy5FUlJfUkVQT19OT1RfSU5JVElBTElaRUQgfHwgZXJyLm1lc3NhZ2Uuc3RhcnRzV2l0aCgnRU5PRU5UJykpXG4gIH0sIGNiKVxufVxuXG5mdW5jdGlvbiBidWlsZE9wdGlvbnMgKF9vcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgX29wdGlvbnMpXG5cbiAgb3B0aW9ucy5zdG9yYWdlQmFja2VuZHMgPSBPYmplY3QuYXNzaWduKFxuICAgIHt9LFxuICAgIGRlZmF1bHRPcHRpb25zLnN0b3JhZ2VCYWNrZW5kcyxcbiAgICBvcHRpb25zLnN0b3JhZ2VCYWNrZW5kcylcblxuICBvcHRpb25zLnN0b3JhZ2VCYWNrZW5kT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAge30sXG4gICAgZGVmYXVsdE9wdGlvbnMuc3RvcmFnZUJhY2tlbmRPcHRpb25zLFxuICAgIG9wdGlvbnMuc3RvcmFnZUJhY2tlbmRPcHRpb25zKVxuXG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8vIFRPRE8gdGhpcyBzaG91bGQgY29tZSBmcm9tIGpzLWlwZnMgaW5zdGVhZFxuZnVuY3Rpb24gYnVpbGRDb25maWcgKF9jb25maWcpIHtcbiAgX2NvbmZpZy5kYXRhc3RvcmUgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0RGF0YXN0b3JlLCBfZ2V0KF9jb25maWcsICdkYXRhc3RvcmUnLCB7fSkpXG5cbiAgcmV0dXJuIF9jb25maWdcbn1cblxuZnVuY3Rpb24gYnVpbGREYXRhc3RvcmVTcGVjIChfY29uZmlnKSB7XG4gIGNvbnN0IHNwZWMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0RGF0YXN0b3JlLlNwZWMsIF9nZXQoX2NvbmZpZywgJ2RhdGFzdG9yZS5TcGVjJywge30pKVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogc3BlYy50eXBlLFxuICAgIG1vdW50czogc3BlYy5tb3VudHMubWFwKChtb3VudGluZykgPT4gKHtcbiAgICAgIG1vdW50cG9pbnQ6IG1vdW50aW5nLm1vdW50cG9pbnQsXG4gICAgICB0eXBlOiBtb3VudGluZy5jaGlsZC50eXBlLFxuICAgICAgcGF0aDogbW91bnRpbmcuY2hpbGQucGF0aCxcbiAgICAgIHNoYXJkRnVuYzogbW91bnRpbmcuY2hpbGQuc2hhcmRGdW5jXG4gICAgfSkpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9zZXRJbW1lZGlhdGUgPSByZXF1aXJlKCcuL2ludGVybmFsL3NldEltbWVkaWF0ZScpO1xuXG52YXIgX3NldEltbWVkaWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXRJbW1lZGlhdGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIENhbGxzIGBjYWxsYmFja2Agb24gYSBsYXRlciBsb29wIGFyb3VuZCB0aGUgZXZlbnQgbG9vcC4gSW4gTm9kZS5qcyB0aGlzIGp1c3RcbiAqIGNhbGxzIGBzZXRJbW1lZGlhdGVgLiAgSW4gdGhlIGJyb3dzZXIgaXQgd2lsbCB1c2UgYHNldEltbWVkaWF0ZWAgaWZcbiAqIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKWAsIHdoaWNoIG1lYW5zIG90aGVyIGhpZ2hlclxuICogcHJpb3JpdHkgZXZlbnRzIG1heSBwcmVjZWRlIHRoZSBleGVjdXRpb24gb2YgYGNhbGxiYWNrYC5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxseSBmb3IgYnJvd3Nlci1jb21wYXRpYmlsaXR5IHB1cnBvc2VzLlxuICpcbiAqIEBuYW1lIHNldEltbWVkaWF0ZVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMubmV4dFRpY2tde0BsaW5rIG1vZHVsZTpVdGlscy5uZXh0VGlja31cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGEgbGF0ZXIgbG9vcCBhcm91bmRcbiAqIHRoZSBldmVudCBsb29wLiBJbnZva2VkIHdpdGggKGFyZ3MuLi4pLlxuICogQHBhcmFtIHsuLi4qfSBhcmdzLi4uIC0gYW55IG51bWJlciBvZiBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZVxuICogY2FsbGJhY2sgb24gdGhlIG5leHQgdGljay5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGNhbGxfb3JkZXIgPSBbXTtcbiAqIGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICogICAgIGNhbGxfb3JkZXIucHVzaCgndHdvJyk7XG4gKiAgICAgLy8gY2FsbF9vcmRlciBub3cgZXF1YWxzIFsnb25lJywndHdvJ11cbiAqIH0pO1xuICogY2FsbF9vcmRlci5wdXNoKCdvbmUnKTtcbiAqXG4gKiBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAqICAgICAvLyBhLCBiLCBhbmQgYyBlcXVhbCAxLCAyLCBhbmQgM1xuICogfSwgMSwgMiwgMyk7XG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IF9zZXRJbW1lZGlhdGUyLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCJjb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCBmc20gPSByZXF1aXJlKCdmc20nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZzbUV2ZW50XG5cbi8vIGNyZWF0ZSBhbiBmc21FdmVudCBpbnN0YW5jZVxuLy8gb2JqIC0+IGZuXG5mdW5jdGlvbiBmc21FdmVudCAoc3RhcnQsIGV2ZW50cykge1xuICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnb2JqZWN0Jykge1xuICAgIGV2ZW50cyA9IHN0YXJ0XG4gICAgc3RhcnQgPSAnU1RBUlQnXG4gIH1cbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBzdGFydCwgJ3N0cmluZycpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgZXZlbnRzLCAnb2JqZWN0JylcbiAgYXNzZXJ0Lm9rKGV2ZW50c1tzdGFydF0sICdpbnZhbGlkIHN0YXJ0aW5nIHN0YXRlICcgKyBzdGFydClcbiAgYXNzZXJ0Lm9rKGZzbS52YWxpZGF0ZShldmVudHMpKVxuXG4gIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKClcbiAgZW1pdC5fZ3JhcGggPSBmc20ucmVhY2hhYmxlKGV2ZW50cylcbiAgZW1pdC5fZW1pdHRlciA9IGVtaXR0ZXJcbiAgZW1pdC5fZXZlbnRzID0gZXZlbnRzXG4gIGVtaXQuX3N0YXRlID0gc3RhcnRcbiAgZW1pdC5lbWl0ID0gZW1pdFxuICBlbWl0Lm9uID0gb25cblxuICByZXR1cm4gZW1pdFxuXG4gIC8vIHNldCBhIHN0YXRlIGxpc3RlbmVyXG4gIC8vIHN0ciwgZm4gLT4gbnVsbFxuICBmdW5jdGlvbiBvbiAoZXZlbnQsIGNiKSB7XG4gICAgZW1pdHRlci5vbihldmVudCwgY2IpXG4gIH1cblxuICAvLyBjaGFuZ2UgdGhlIHN0YXRlXG4gIC8vIHN0ciAtPiBudWxsXG4gIGZ1bmN0aW9uIGVtaXQgKHN0cikge1xuICAgIGNvbnN0IG53U3RhdGUgPSBlbWl0Ll9ldmVudHNbZW1pdC5fc3RhdGVdW3N0cl1cbiAgICBpZiAoIXJlYWNoKGVtaXQuX3N0YXRlLCBud1N0YXRlLCBlbWl0Ll9ncmFwaCkpIHtcbiAgICAgIGNvbnN0IGVyciA9ICdpbnZhbGlkIHRyYW5zaXRpb246ICcgKyBlbWl0Ll9zdGF0ZSArICcgLT4gJyArIHN0clxuICAgICAgcmV0dXJuIGVtaXR0ZXIuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgfVxuXG4gICAgY29uc3QgbGVhdmVFdiA9IGVtaXQuX3N0YXRlICsgJzpsZWF2ZSdcbiAgICBjb25zdCBlbnRlckV2ID0gbndTdGF0ZSArICc6ZW50ZXInXG5cbiAgICBpZiAoIWVtaXQuX3N0YXRlKSByZXR1cm4gZW50ZXIoKVxuICAgIHJldHVybiBsZWF2ZSgpXG5cbiAgICBmdW5jdGlvbiBsZWF2ZSAoKSB7XG4gICAgICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tsZWF2ZUV2XSkgZW50ZXIoKVxuICAgICAgZWxzZSBlbWl0dGVyLmVtaXQobGVhdmVFdiwgZW50ZXIpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW50ZXIgKCkge1xuICAgICAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZW50ZXJFdl0pIGRvbmUoKVxuICAgICAgZWxzZSBlbWl0dGVyLmVtaXQoZW50ZXJFdiwgZG9uZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb25lICgpIHtcbiAgICAgIGVtaXQuX3N0YXRlID0gbndTdGF0ZVxuICAgICAgZW1pdHRlci5lbWl0KG53U3RhdGUpXG4gICAgICBlbWl0dGVyLmVtaXQoJ2RvbmUnKVxuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBpZiBzdGF0ZSBjYW4gcmVhY2ggaW4gcmVhY2hcbi8vIHN0ciwgc3RyLCBvYmogLT4gYm9vbFxuZnVuY3Rpb24gcmVhY2ggKGN1cnIsIG5leHQsIHJlYWNoYWJsZSkge1xuICBpZiAoIW5leHQpIHJldHVybiBmYWxzZVxuICBpZiAoIWN1cnIpIHJldHVybiB0cnVlXG5cbiAgY29uc3QgaGVyZSA9IHJlYWNoYWJsZVtjdXJyXVxuICBpZiAoIWhlcmUgfHwgIWhlcmVbbmV4dF0pIHJldHVybiBmYWxzZVxuICByZXR1cm4gaGVyZVtuZXh0XS5sZW5ndGggPT09IDFcbn1cbiIsIi8vIFRISVMgRklMRSBJUyBHRU5FUkFURUQsIERPIE5PIEVESVQgTUFOVUFMTFlcbi8vIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSB0aGUgUkVBRE1FLm1kXG4vKiBlc2xpbnQtZGlzYWJsZSBkb3Qtbm90YXRpb24gKi9cbid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKHtcblxuICAvLyBzZXJpYWxpemF0aW9uXG4gIFBST1RPQlVGOiAweDUwLFxuICBDQk9SOiAweDUxLFxuICBSTFA6IDB4NjAsXG4gIEJFTkNPREU6IDB4NjMsXG4gIEpTT046IDB4MDIwMCxcbiAgTUVTU0FHRVBBQ0s6IDB4MDIwMSxcblxuICAvLyBtdWx0aWZvcm1hdFxuICBNVUxUSUNPREVDOiAweDMwLFxuICBNVUxUSUhBU0g6IDB4MzEsXG4gIE1VTFRJQUREUjogMHgzMixcbiAgTVVMVElCQVNFOiAweDMzLFxuXG4gIC8vIG11bHRpaGFzaFxuICBJREVOVElUWTogMHgwMCxcbiAgU0hBMTogMHgxMSxcbiAgU0hBMl8yNTY6IDB4MTIsXG4gIFNIQTJfNTEyOiAweDEzLFxuICBTSEEzXzUxMjogMHgxNCxcbiAgU0hBM18zODQ6IDB4MTUsXG4gIFNIQTNfMjU2OiAweDE2LFxuICBTSEEzXzIyNDogMHgxNyxcbiAgU0hBS0VfMTI4OiAweDE4LFxuICBTSEFLRV8yNTY6IDB4MTksXG4gIEtFQ0NBS18yMjQ6IDB4MWEsXG4gIEtFQ0NBS18yNTY6IDB4MWIsXG4gIEtFQ0NBS18zODQ6IDB4MWMsXG4gIEtFQ0NBS181MTI6IDB4MWQsXG4gIE1VUk1VUjNfMTI4OiAweDIyLFxuICBNVVJNVVIzXzMyOiAweDIzLFxuICBEQkxfU0hBMl8yNTY6IDB4NTYsXG4gIE1ENDogMHhkNCxcbiAgTUQ1OiAweGQ1LFxuICBCTVQ6IDB4ZDYsXG4gIFgxMTogMHgxMTAwLFxuICBCTEFLRTJCXzg6IDB4YjIwMSxcbiAgQkxBS0UyQl8xNjogMHhiMjAyLFxuICBCTEFLRTJCXzI0OiAweGIyMDMsXG4gIEJMQUtFMkJfMzI6IDB4YjIwNCxcbiAgQkxBS0UyQl80MDogMHhiMjA1LFxuICBCTEFLRTJCXzQ4OiAweGIyMDYsXG4gIEJMQUtFMkJfNTY6IDB4YjIwNyxcbiAgQkxBS0UyQl82NDogMHhiMjA4LFxuICBCTEFLRTJCXzcyOiAweGIyMDksXG4gIEJMQUtFMkJfODA6IDB4YjIwYSxcbiAgQkxBS0UyQl84ODogMHhiMjBiLFxuICBCTEFLRTJCXzk2OiAweGIyMGMsXG4gIEJMQUtFMkJfMTA0OiAweGIyMGQsXG4gIEJMQUtFMkJfMTEyOiAweGIyMGUsXG4gIEJMQUtFMkJfMTIwOiAweGIyMGYsXG4gIEJMQUtFMkJfMTI4OiAweGIyMTAsXG4gIEJMQUtFMkJfMTM2OiAweGIyMTEsXG4gIEJMQUtFMkJfMTQ0OiAweGIyMTIsXG4gIEJMQUtFMkJfMTUyOiAweGIyMTMsXG4gIEJMQUtFMkJfMTYwOiAweGIyMTQsXG4gIEJMQUtFMkJfMTY4OiAweGIyMTUsXG4gIEJMQUtFMkJfMTc2OiAweGIyMTYsXG4gIEJMQUtFMkJfMTg0OiAweGIyMTcsXG4gIEJMQUtFMkJfMTkyOiAweGIyMTgsXG4gIEJMQUtFMkJfMjAwOiAweGIyMTksXG4gIEJMQUtFMkJfMjA4OiAweGIyMWEsXG4gIEJMQUtFMkJfMjE2OiAweGIyMWIsXG4gIEJMQUtFMkJfMjI0OiAweGIyMWMsXG4gIEJMQUtFMkJfMjMyOiAweGIyMWQsXG4gIEJMQUtFMkJfMjQwOiAweGIyMWUsXG4gIEJMQUtFMkJfMjQ4OiAweGIyMWYsXG4gIEJMQUtFMkJfMjU2OiAweGIyMjAsXG4gIEJMQUtFMkJfMjY0OiAweGIyMjEsXG4gIEJMQUtFMkJfMjcyOiAweGIyMjIsXG4gIEJMQUtFMkJfMjgwOiAweGIyMjMsXG4gIEJMQUtFMkJfMjg4OiAweGIyMjQsXG4gIEJMQUtFMkJfMjk2OiAweGIyMjUsXG4gIEJMQUtFMkJfMzA0OiAweGIyMjYsXG4gIEJMQUtFMkJfMzEyOiAweGIyMjcsXG4gIEJMQUtFMkJfMzIwOiAweGIyMjgsXG4gIEJMQUtFMkJfMzI4OiAweGIyMjksXG4gIEJMQUtFMkJfMzM2OiAweGIyMmEsXG4gIEJMQUtFMkJfMzQ0OiAweGIyMmIsXG4gIEJMQUtFMkJfMzUyOiAweGIyMmMsXG4gIEJMQUtFMkJfMzYwOiAweGIyMmQsXG4gIEJMQUtFMkJfMzY4OiAweGIyMmUsXG4gIEJMQUtFMkJfMzc2OiAweGIyMmYsXG4gIEJMQUtFMkJfMzg0OiAweGIyMzAsXG4gIEJMQUtFMkJfMzkyOiAweGIyMzEsXG4gIEJMQUtFMkJfNDAwOiAweGIyMzIsXG4gIEJMQUtFMkJfNDA4OiAweGIyMzMsXG4gIEJMQUtFMkJfNDE2OiAweGIyMzQsXG4gIEJMQUtFMkJfNDI0OiAweGIyMzUsXG4gIEJMQUtFMkJfNDMyOiAweGIyMzYsXG4gIEJMQUtFMkJfNDQwOiAweGIyMzcsXG4gIEJMQUtFMkJfNDQ4OiAweGIyMzgsXG4gIEJMQUtFMkJfNDU2OiAweGIyMzksXG4gIEJMQUtFMkJfNDY0OiAweGIyM2EsXG4gIEJMQUtFMkJfNDcyOiAweGIyM2IsXG4gIEJMQUtFMkJfNDgwOiAweGIyM2MsXG4gIEJMQUtFMkJfNDg4OiAweGIyM2QsXG4gIEJMQUtFMkJfNDk2OiAweGIyM2UsXG4gIEJMQUtFMkJfNTA0OiAweGIyM2YsXG4gIEJMQUtFMkJfNTEyOiAweGIyNDAsXG4gIEJMQUtFMlNfODogMHhiMjQxLFxuICBCTEFLRTJTXzE2OiAweGIyNDIsXG4gIEJMQUtFMlNfMjQ6IDB4YjI0MyxcbiAgQkxBS0UyU18zMjogMHhiMjQ0LFxuICBCTEFLRTJTXzQwOiAweGIyNDUsXG4gIEJMQUtFMlNfNDg6IDB4YjI0NixcbiAgQkxBS0UyU181NjogMHhiMjQ3LFxuICBCTEFLRTJTXzY0OiAweGIyNDgsXG4gIEJMQUtFMlNfNzI6IDB4YjI0OSxcbiAgQkxBS0UyU184MDogMHhiMjRhLFxuICBCTEFLRTJTXzg4OiAweGIyNGIsXG4gIEJMQUtFMlNfOTY6IDB4YjI0YyxcbiAgQkxBS0UyU18xMDQ6IDB4YjI0ZCxcbiAgQkxBS0UyU18xMTI6IDB4YjI0ZSxcbiAgQkxBS0UyU18xMjA6IDB4YjI0ZixcbiAgQkxBS0UyU18xMjg6IDB4YjI1MCxcbiAgQkxBS0UyU18xMzY6IDB4YjI1MSxcbiAgQkxBS0UyU18xNDQ6IDB4YjI1MixcbiAgQkxBS0UyU18xNTI6IDB4YjI1MyxcbiAgQkxBS0UyU18xNjA6IDB4YjI1NCxcbiAgQkxBS0UyU18xNjg6IDB4YjI1NSxcbiAgQkxBS0UyU18xNzY6IDB4YjI1NixcbiAgQkxBS0UyU18xODQ6IDB4YjI1NyxcbiAgQkxBS0UyU18xOTI6IDB4YjI1OCxcbiAgQkxBS0UyU18yMDA6IDB4YjI1OSxcbiAgQkxBS0UyU18yMDg6IDB4YjI1YSxcbiAgQkxBS0UyU18yMTY6IDB4YjI1YixcbiAgQkxBS0UyU18yMjQ6IDB4YjI1YyxcbiAgQkxBS0UyU18yMzI6IDB4YjI1ZCxcbiAgQkxBS0UyU18yNDA6IDB4YjI1ZSxcbiAgQkxBS0UyU18yNDg6IDB4YjI1ZixcbiAgQkxBS0UyU18yNTY6IDB4YjI2MCxcbiAgU0tFSU4yNTZfODogMHhiMzAxLFxuICBTS0VJTjI1Nl8xNjogMHhiMzAyLFxuICBTS0VJTjI1Nl8yNDogMHhiMzAzLFxuICBTS0VJTjI1Nl8zMjogMHhiMzA0LFxuICBTS0VJTjI1Nl80MDogMHhiMzA1LFxuICBTS0VJTjI1Nl80ODogMHhiMzA2LFxuICBTS0VJTjI1Nl81NjogMHhiMzA3LFxuICBTS0VJTjI1Nl82NDogMHhiMzA4LFxuICBTS0VJTjI1Nl83MjogMHhiMzA5LFxuICBTS0VJTjI1Nl84MDogMHhiMzBhLFxuICBTS0VJTjI1Nl84ODogMHhiMzBiLFxuICBTS0VJTjI1Nl85NjogMHhiMzBjLFxuICBTS0VJTjI1Nl8xMDQ6IDB4YjMwZCxcbiAgU0tFSU4yNTZfMTEyOiAweGIzMGUsXG4gIFNLRUlOMjU2XzEyMDogMHhiMzBmLFxuICBTS0VJTjI1Nl8xMjg6IDB4YjMxMCxcbiAgU0tFSU4yNTZfMTM2OiAweGIzMTEsXG4gIFNLRUlOMjU2XzE0NDogMHhiMzEyLFxuICBTS0VJTjI1Nl8xNTI6IDB4YjMxMyxcbiAgU0tFSU4yNTZfMTYwOiAweGIzMTQsXG4gIFNLRUlOMjU2XzE2ODogMHhiMzE1LFxuICBTS0VJTjI1Nl8xNzY6IDB4YjMxNixcbiAgU0tFSU4yNTZfMTg0OiAweGIzMTcsXG4gIFNLRUlOMjU2XzE5MjogMHhiMzE4LFxuICBTS0VJTjI1Nl8yMDA6IDB4YjMxOSxcbiAgU0tFSU4yNTZfMjA4OiAweGIzMWEsXG4gIFNLRUlOMjU2XzIxNjogMHhiMzFiLFxuICBTS0VJTjI1Nl8yMjQ6IDB4YjMxYyxcbiAgU0tFSU4yNTZfMjMyOiAweGIzMWQsXG4gIFNLRUlOMjU2XzI0MDogMHhiMzFlLFxuICBTS0VJTjI1Nl8yNDg6IDB4YjMxZixcbiAgU0tFSU4yNTZfMjU2OiAweGIzMjAsXG4gIFNLRUlONTEyXzg6IDB4YjMyMSxcbiAgU0tFSU41MTJfMTY6IDB4YjMyMixcbiAgU0tFSU41MTJfMjQ6IDB4YjMyMyxcbiAgU0tFSU41MTJfMzI6IDB4YjMyNCxcbiAgU0tFSU41MTJfNDA6IDB4YjMyNSxcbiAgU0tFSU41MTJfNDg6IDB4YjMyNixcbiAgU0tFSU41MTJfNTY6IDB4YjMyNyxcbiAgU0tFSU41MTJfNjQ6IDB4YjMyOCxcbiAgU0tFSU41MTJfNzI6IDB4YjMyOSxcbiAgU0tFSU41MTJfODA6IDB4YjMyYSxcbiAgU0tFSU41MTJfODg6IDB4YjMyYixcbiAgU0tFSU41MTJfOTY6IDB4YjMyYyxcbiAgU0tFSU41MTJfMTA0OiAweGIzMmQsXG4gIFNLRUlONTEyXzExMjogMHhiMzJlLFxuICBTS0VJTjUxMl8xMjA6IDB4YjMyZixcbiAgU0tFSU41MTJfMTI4OiAweGIzMzAsXG4gIFNLRUlONTEyXzEzNjogMHhiMzMxLFxuICBTS0VJTjUxMl8xNDQ6IDB4YjMzMixcbiAgU0tFSU41MTJfMTUyOiAweGIzMzMsXG4gIFNLRUlONTEyXzE2MDogMHhiMzM0LFxuICBTS0VJTjUxMl8xNjg6IDB4YjMzNSxcbiAgU0tFSU41MTJfMTc2OiAweGIzMzYsXG4gIFNLRUlONTEyXzE4NDogMHhiMzM3LFxuICBTS0VJTjUxMl8xOTI6IDB4YjMzOCxcbiAgU0tFSU41MTJfMjAwOiAweGIzMzksXG4gIFNLRUlONTEyXzIwODogMHhiMzNhLFxuICBTS0VJTjUxMl8yMTY6IDB4YjMzYixcbiAgU0tFSU41MTJfMjI0OiAweGIzM2MsXG4gIFNLRUlONTEyXzIzMjogMHhiMzNkLFxuICBTS0VJTjUxMl8yNDA6IDB4YjMzZSxcbiAgU0tFSU41MTJfMjQ4OiAweGIzM2YsXG4gIFNLRUlONTEyXzI1NjogMHhiMzQwLFxuICBTS0VJTjUxMl8yNjQ6IDB4YjM0MSxcbiAgU0tFSU41MTJfMjcyOiAweGIzNDIsXG4gIFNLRUlONTEyXzI4MDogMHhiMzQzLFxuICBTS0VJTjUxMl8yODg6IDB4YjM0NCxcbiAgU0tFSU41MTJfMjk2OiAweGIzNDUsXG4gIFNLRUlONTEyXzMwNDogMHhiMzQ2LFxuICBTS0VJTjUxMl8zMTI6IDB4YjM0NyxcbiAgU0tFSU41MTJfMzIwOiAweGIzNDgsXG4gIFNLRUlONTEyXzMyODogMHhiMzQ5LFxuICBTS0VJTjUxMl8zMzY6IDB4YjM0YSxcbiAgU0tFSU41MTJfMzQ0OiAweGIzNGIsXG4gIFNLRUlONTEyXzM1MjogMHhiMzRjLFxuICBTS0VJTjUxMl8zNjA6IDB4YjM0ZCxcbiAgU0tFSU41MTJfMzY4OiAweGIzNGUsXG4gIFNLRUlONTEyXzM3NjogMHhiMzRmLFxuICBTS0VJTjUxMl8zODQ6IDB4YjM1MCxcbiAgU0tFSU41MTJfMzkyOiAweGIzNTEsXG4gIFNLRUlONTEyXzQwMDogMHhiMzUyLFxuICBTS0VJTjUxMl80MDg6IDB4YjM1MyxcbiAgU0tFSU41MTJfNDE2OiAweGIzNTQsXG4gIFNLRUlONTEyXzQyNDogMHhiMzU1LFxuICBTS0VJTjUxMl80MzI6IDB4YjM1NixcbiAgU0tFSU41MTJfNDQwOiAweGIzNTcsXG4gIFNLRUlONTEyXzQ0ODogMHhiMzU4LFxuICBTS0VJTjUxMl80NTY6IDB4YjM1OSxcbiAgU0tFSU41MTJfNDY0OiAweGIzNWEsXG4gIFNLRUlONTEyXzQ3MjogMHhiMzViLFxuICBTS0VJTjUxMl80ODA6IDB4YjM1YyxcbiAgU0tFSU41MTJfNDg4OiAweGIzNWQsXG4gIFNLRUlONTEyXzQ5NjogMHhiMzVlLFxuICBTS0VJTjUxMl81MDQ6IDB4YjM1ZixcbiAgU0tFSU41MTJfNTEyOiAweGIzNjAsXG4gIFNLRUlOMTAyNF84OiAweGIzNjEsXG4gIFNLRUlOMTAyNF8xNjogMHhiMzYyLFxuICBTS0VJTjEwMjRfMjQ6IDB4YjM2MyxcbiAgU0tFSU4xMDI0XzMyOiAweGIzNjQsXG4gIFNLRUlOMTAyNF80MDogMHhiMzY1LFxuICBTS0VJTjEwMjRfNDg6IDB4YjM2NixcbiAgU0tFSU4xMDI0XzU2OiAweGIzNjcsXG4gIFNLRUlOMTAyNF82NDogMHhiMzY4LFxuICBTS0VJTjEwMjRfNzI6IDB4YjM2OSxcbiAgU0tFSU4xMDI0XzgwOiAweGIzNmEsXG4gIFNLRUlOMTAyNF84ODogMHhiMzZiLFxuICBTS0VJTjEwMjRfOTY6IDB4YjM2YyxcbiAgU0tFSU4xMDI0XzEwNDogMHhiMzZkLFxuICBTS0VJTjEwMjRfMTEyOiAweGIzNmUsXG4gIFNLRUlOMTAyNF8xMjA6IDB4YjM2ZixcbiAgU0tFSU4xMDI0XzEyODogMHhiMzcwLFxuICBTS0VJTjEwMjRfMTM2OiAweGIzNzEsXG4gIFNLRUlOMTAyNF8xNDQ6IDB4YjM3MixcbiAgU0tFSU4xMDI0XzE1MjogMHhiMzczLFxuICBTS0VJTjEwMjRfMTYwOiAweGIzNzQsXG4gIFNLRUlOMTAyNF8xNjg6IDB4YjM3NSxcbiAgU0tFSU4xMDI0XzE3NjogMHhiMzc2LFxuICBTS0VJTjEwMjRfMTg0OiAweGIzNzcsXG4gIFNLRUlOMTAyNF8xOTI6IDB4YjM3OCxcbiAgU0tFSU4xMDI0XzIwMDogMHhiMzc5LFxuICBTS0VJTjEwMjRfMjA4OiAweGIzN2EsXG4gIFNLRUlOMTAyNF8yMTY6IDB4YjM3YixcbiAgU0tFSU4xMDI0XzIyNDogMHhiMzdjLFxuICBTS0VJTjEwMjRfMjMyOiAweGIzN2QsXG4gIFNLRUlOMTAyNF8yNDA6IDB4YjM3ZSxcbiAgU0tFSU4xMDI0XzI0ODogMHhiMzdmLFxuICBTS0VJTjEwMjRfMjU2OiAweGIzODAsXG4gIFNLRUlOMTAyNF8yNjQ6IDB4YjM4MSxcbiAgU0tFSU4xMDI0XzI3MjogMHhiMzgyLFxuICBTS0VJTjEwMjRfMjgwOiAweGIzODMsXG4gIFNLRUlOMTAyNF8yODg6IDB4YjM4NCxcbiAgU0tFSU4xMDI0XzI5NjogMHhiMzg1LFxuICBTS0VJTjEwMjRfMzA0OiAweGIzODYsXG4gIFNLRUlOMTAyNF8zMTI6IDB4YjM4NyxcbiAgU0tFSU4xMDI0XzMyMDogMHhiMzg4LFxuICBTS0VJTjEwMjRfMzI4OiAweGIzODksXG4gIFNLRUlOMTAyNF8zMzY6IDB4YjM4YSxcbiAgU0tFSU4xMDI0XzM0NDogMHhiMzhiLFxuICBTS0VJTjEwMjRfMzUyOiAweGIzOGMsXG4gIFNLRUlOMTAyNF8zNjA6IDB4YjM4ZCxcbiAgU0tFSU4xMDI0XzM2ODogMHhiMzhlLFxuICBTS0VJTjEwMjRfMzc2OiAweGIzOGYsXG4gIFNLRUlOMTAyNF8zODQ6IDB4YjM5MCxcbiAgU0tFSU4xMDI0XzM5MjogMHhiMzkxLFxuICBTS0VJTjEwMjRfNDAwOiAweGIzOTIsXG4gIFNLRUlOMTAyNF80MDg6IDB4YjM5MyxcbiAgU0tFSU4xMDI0XzQxNjogMHhiMzk0LFxuICBTS0VJTjEwMjRfNDI0OiAweGIzOTUsXG4gIFNLRUlOMTAyNF80MzI6IDB4YjM5NixcbiAgU0tFSU4xMDI0XzQ0MDogMHhiMzk3LFxuICBTS0VJTjEwMjRfNDQ4OiAweGIzOTgsXG4gIFNLRUlOMTAyNF80NTY6IDB4YjM5OSxcbiAgU0tFSU4xMDI0XzQ2NDogMHhiMzlhLFxuICBTS0VJTjEwMjRfNDcyOiAweGIzOWIsXG4gIFNLRUlOMTAyNF80ODA6IDB4YjM5YyxcbiAgU0tFSU4xMDI0XzQ4ODogMHhiMzlkLFxuICBTS0VJTjEwMjRfNDk2OiAweGIzOWUsXG4gIFNLRUlOMTAyNF81MDQ6IDB4YjM5ZixcbiAgU0tFSU4xMDI0XzUxMjogMHhiM2EwLFxuICBTS0VJTjEwMjRfNTIwOiAweGIzYTEsXG4gIFNLRUlOMTAyNF81Mjg6IDB4YjNhMixcbiAgU0tFSU4xMDI0XzUzNjogMHhiM2EzLFxuICBTS0VJTjEwMjRfNTQ0OiAweGIzYTQsXG4gIFNLRUlOMTAyNF81NTI6IDB4YjNhNSxcbiAgU0tFSU4xMDI0XzU2MDogMHhiM2E2LFxuICBTS0VJTjEwMjRfNTY4OiAweGIzYTcsXG4gIFNLRUlOMTAyNF81NzY6IDB4YjNhOCxcbiAgU0tFSU4xMDI0XzU4NDogMHhiM2E5LFxuICBTS0VJTjEwMjRfNTkyOiAweGIzYWEsXG4gIFNLRUlOMTAyNF82MDA6IDB4YjNhYixcbiAgU0tFSU4xMDI0XzYwODogMHhiM2FjLFxuICBTS0VJTjEwMjRfNjE2OiAweGIzYWQsXG4gIFNLRUlOMTAyNF82MjQ6IDB4YjNhZSxcbiAgU0tFSU4xMDI0XzYzMjogMHhiM2FmLFxuICBTS0VJTjEwMjRfNjQwOiAweGIzYjAsXG4gIFNLRUlOMTAyNF82NDg6IDB4YjNiMSxcbiAgU0tFSU4xMDI0XzY1NjogMHhiM2IyLFxuICBTS0VJTjEwMjRfNjY0OiAweGIzYjMsXG4gIFNLRUlOMTAyNF82NzI6IDB4YjNiNCxcbiAgU0tFSU4xMDI0XzY4MDogMHhiM2I1LFxuICBTS0VJTjEwMjRfNjg4OiAweGIzYjYsXG4gIFNLRUlOMTAyNF82OTY6IDB4YjNiNyxcbiAgU0tFSU4xMDI0XzcwNDogMHhiM2I4LFxuICBTS0VJTjEwMjRfNzEyOiAweGIzYjksXG4gIFNLRUlOMTAyNF83MjA6IDB4YjNiYSxcbiAgU0tFSU4xMDI0XzcyODogMHhiM2JiLFxuICBTS0VJTjEwMjRfNzM2OiAweGIzYmMsXG4gIFNLRUlOMTAyNF83NDQ6IDB4YjNiZCxcbiAgU0tFSU4xMDI0Xzc1MjogMHhiM2JlLFxuICBTS0VJTjEwMjRfNzYwOiAweGIzYmYsXG4gIFNLRUlOMTAyNF83Njg6IDB4YjNjMCxcbiAgU0tFSU4xMDI0Xzc3NjogMHhiM2MxLFxuICBTS0VJTjEwMjRfNzg0OiAweGIzYzIsXG4gIFNLRUlOMTAyNF83OTI6IDB4YjNjMyxcbiAgU0tFSU4xMDI0XzgwMDogMHhiM2M0LFxuICBTS0VJTjEwMjRfODA4OiAweGIzYzUsXG4gIFNLRUlOMTAyNF84MTY6IDB4YjNjNixcbiAgU0tFSU4xMDI0XzgyNDogMHhiM2M3LFxuICBTS0VJTjEwMjRfODMyOiAweGIzYzgsXG4gIFNLRUlOMTAyNF84NDA6IDB4YjNjOSxcbiAgU0tFSU4xMDI0Xzg0ODogMHhiM2NhLFxuICBTS0VJTjEwMjRfODU2OiAweGIzY2IsXG4gIFNLRUlOMTAyNF84NjQ6IDB4YjNjYyxcbiAgU0tFSU4xMDI0Xzg3MjogMHhiM2NkLFxuICBTS0VJTjEwMjRfODgwOiAweGIzY2UsXG4gIFNLRUlOMTAyNF84ODg6IDB4YjNjZixcbiAgU0tFSU4xMDI0Xzg5NjogMHhiM2QwLFxuICBTS0VJTjEwMjRfOTA0OiAweGIzZDEsXG4gIFNLRUlOMTAyNF85MTI6IDB4YjNkMixcbiAgU0tFSU4xMDI0XzkyMDogMHhiM2QzLFxuICBTS0VJTjEwMjRfOTI4OiAweGIzZDQsXG4gIFNLRUlOMTAyNF85MzY6IDB4YjNkNSxcbiAgU0tFSU4xMDI0Xzk0NDogMHhiM2Q2LFxuICBTS0VJTjEwMjRfOTUyOiAweGIzZDcsXG4gIFNLRUlOMTAyNF85NjA6IDB4YjNkOCxcbiAgU0tFSU4xMDI0Xzk2ODogMHhiM2Q5LFxuICBTS0VJTjEwMjRfOTc2OiAweGIzZGEsXG4gIFNLRUlOMTAyNF85ODQ6IDB4YjNkYixcbiAgU0tFSU4xMDI0Xzk5MjogMHhiM2RjLFxuICBTS0VJTjEwMjRfMTAwMDogMHhiM2RkLFxuICBTS0VJTjEwMjRfMTAwODogMHhiM2RlLFxuICBTS0VJTjEwMjRfMTAxNjogMHhiM2RmLFxuICBTS0VJTjEwMjRfMTAyNDogMHhiM2UwLFxuXG4gIC8vIG11bHRpYWRkclxuICBJUDQ6IDB4MDQsXG4gIFRDUDogMHgwNixcbiAgRENDUDogMHgyMSxcbiAgSVA2OiAweDI5LFxuICBJUDZaT05FOiAweDJhLFxuICBETlM6IDB4MzUsXG4gIEROUzQ6IDB4MzYsXG4gIEROUzY6IDB4MzcsXG4gIEROU0FERFI6IDB4MzgsXG4gIFNDVFA6IDB4ODQsXG4gIFVEUDogMHgwMTExLFxuICBQMlBfV0VCUlRDX1NUQVI6IDB4MDExMyxcbiAgUDJQX1dFQlJUQ19ESVJFQ1Q6IDB4MDExNCxcbiAgUDJQX1NUQVJEVVNUOiAweDAxMTUsXG4gIFAyUF9DSVJDVUlUOiAweDAxMjIsXG4gIFVEVDogMHgwMTJkLFxuICBVVFA6IDB4MDEyZSxcbiAgVU5JWDogMHgwMTkwLFxuICBQMlA6IDB4MDFhNSxcbiAgSVBGUzogMHgwMWE1LFxuICBIVFRQUzogMHgwMWJiLFxuICBPTklPTjogMHgwMWJjLFxuICBPTklPTjM6IDB4MDFiZCxcbiAgR0FSTElDNjQ6IDB4MDFiZSxcbiAgR0FSTElDMzI6IDB4MDFiZixcbiAgUVVJQzogMHgwMWNjLFxuICBXUzogMHgwMWRkLFxuICBXU1M6IDB4MDFkZSxcbiAgUDJQX1dFQlNPQ0tFVF9TVEFSOiAweDAxZGYsXG4gIEhUVFA6IDB4MDFlMCxcblxuICAvLyBpcGxkXG4gIFJBVzogMHg1NSxcbiAgREFHX1BCOiAweDcwLFxuICBEQUdfQ0JPUjogMHg3MSxcbiAgTElCUDJQX0tFWTogMHg3MixcbiAgR0lUX1JBVzogMHg3OCxcbiAgVE9SUkVOVF9JTkZPOiAweDdiLFxuICBUT1JSRU5UX0ZJTEU6IDB4N2MsXG4gIExFT0ZDT0lOX0JMT0NLOiAweDgxLFxuICBMRU9GQ09JTl9UWDogMHg4MixcbiAgTEVPRkNPSU5fUFI6IDB4ODMsXG4gIEVUSF9CTE9DSzogMHg5MCxcbiAgRVRIX0JMT0NLX0xJU1Q6IDB4OTEsXG4gIEVUSF9UWF9UUklFOiAweDkyLFxuICBFVEhfVFg6IDB4OTMsXG4gIEVUSF9UWF9SRUNFSVBUX1RSSUU6IDB4OTQsXG4gIEVUSF9UWF9SRUNFSVBUOiAweDk1LFxuICBFVEhfU1RBVEVfVFJJRTogMHg5NixcbiAgRVRIX0FDQ09VTlRfU05BUFNIT1Q6IDB4OTcsXG4gIEVUSF9TVE9SQUdFX1RSSUU6IDB4OTgsXG4gIEJJVENPSU5fQkxPQ0s6IDB4YjAsXG4gIEJJVENPSU5fVFg6IDB4YjEsXG4gIFpDQVNIX0JMT0NLOiAweGMwLFxuICBaQ0FTSF9UWDogMHhjMSxcbiAgU1RFTExBUl9CTE9DSzogMHhkMCxcbiAgU1RFTExBUl9UWDogMHhkMSxcbiAgREVDUkVEX0JMT0NLOiAweGUwLFxuICBERUNSRURfVFg6IDB4ZTEsXG4gIERBU0hfQkxPQ0s6IDB4ZjAsXG4gIERBU0hfVFg6IDB4ZjEsXG4gIFNXQVJNX01BTklGRVNUOiAweGZhLFxuICBTV0FSTV9GRUVEOiAweGZiLFxuICBEQUdfSlNPTjogMHgwMTI5LFxuXG4gIC8vIG5hbWVzcGFjZVxuICBQQVRIOiAweDJmLFxuICBJUExEX05TOiAweGUyLFxuICBJUEZTX05TOiAweGUzLFxuICBTV0FSTV9OUzogMHhlNCxcbiAgSVBOU19OUzogMHhlNSxcbiAgWkVST05FVDogMHhlNixcblxuICAvLyBrZXlcbiAgRUQyNTUxOV9QVUI6IDB4ZWQsXG5cbiAgLy8gaG9sb2NoYWluXG4gIEhPTE9DSEFJTl9BRFJfVjA6IDB4ODA3MTI0LFxuICBIT0xPQ0hBSU5fQURSX1YxOiAweDgxNzEyNCxcbiAgSE9MT0NIQUlOX0tFWV9WMDogMHg5NDcxMjQsXG4gIEhPTE9DSEFJTl9LRVlfVjE6IDB4OTU3MTI0LFxuICBIT0xPQ0hBSU5fU0lHX1YwOiAweGEyNzEyNCxcbiAgSE9MT0NIQUlOX1NJR19WMTogMHhhMzcxMjRcbn0pXG4iLCIvLyBUSElTIEZJTEUgSVMgR0VORVJBVEVELCBETyBOTyBFRElUIE1BTlVBTExZXG4vLyBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgdGhlIFJFQURNRS5tZFxuLyogZXNsaW50LWRpc2FibGUgZG90LW5vdGF0aW9uICovXG4ndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZSh7XG5cbiAgLy8gc2VyaWFsaXphdGlvblxuICAweDUwOiAncHJvdG9idWYnLFxuICAweDUxOiAnY2JvcicsXG4gIDB4NjA6ICdybHAnLFxuICAweDYzOiAnYmVuY29kZScsXG4gIDB4MDIwMDogJ2pzb24nLFxuICAweDAyMDE6ICdtZXNzYWdlcGFjaycsXG5cbiAgLy8gbXVsdGlmb3JtYXRcbiAgMHgzMDogJ211bHRpY29kZWMnLFxuICAweDMxOiAnbXVsdGloYXNoJyxcbiAgMHgzMjogJ211bHRpYWRkcicsXG4gIDB4MzM6ICdtdWx0aWJhc2UnLFxuXG4gIC8vIG11bHRpaGFzaFxuICAweDAwOiAnaWRlbnRpdHknLFxuICAweDExOiAnc2hhMScsXG4gIDB4MTI6ICdzaGEyLTI1NicsXG4gIDB4MTM6ICdzaGEyLTUxMicsXG4gIDB4MTQ6ICdzaGEzLTUxMicsXG4gIDB4MTU6ICdzaGEzLTM4NCcsXG4gIDB4MTY6ICdzaGEzLTI1NicsXG4gIDB4MTc6ICdzaGEzLTIyNCcsXG4gIDB4MTg6ICdzaGFrZS0xMjgnLFxuICAweDE5OiAnc2hha2UtMjU2JyxcbiAgMHgxYTogJ2tlY2Nhay0yMjQnLFxuICAweDFiOiAna2VjY2FrLTI1NicsXG4gIDB4MWM6ICdrZWNjYWstMzg0JyxcbiAgMHgxZDogJ2tlY2Nhay01MTInLFxuICAweDIyOiAnbXVybXVyMy0xMjgnLFxuICAweDIzOiAnbXVybXVyMy0zMicsXG4gIDB4NTY6ICdkYmwtc2hhMi0yNTYnLFxuICAweGQ0OiAnbWQ0JyxcbiAgMHhkNTogJ21kNScsXG4gIDB4ZDY6ICdibXQnLFxuICAweDExMDA6ICd4MTEnLFxuICAweGIyMDE6ICdibGFrZTJiLTgnLFxuICAweGIyMDI6ICdibGFrZTJiLTE2JyxcbiAgMHhiMjAzOiAnYmxha2UyYi0yNCcsXG4gIDB4YjIwNDogJ2JsYWtlMmItMzInLFxuICAweGIyMDU6ICdibGFrZTJiLTQwJyxcbiAgMHhiMjA2OiAnYmxha2UyYi00OCcsXG4gIDB4YjIwNzogJ2JsYWtlMmItNTYnLFxuICAweGIyMDg6ICdibGFrZTJiLTY0JyxcbiAgMHhiMjA5OiAnYmxha2UyYi03MicsXG4gIDB4YjIwYTogJ2JsYWtlMmItODAnLFxuICAweGIyMGI6ICdibGFrZTJiLTg4JyxcbiAgMHhiMjBjOiAnYmxha2UyYi05NicsXG4gIDB4YjIwZDogJ2JsYWtlMmItMTA0JyxcbiAgMHhiMjBlOiAnYmxha2UyYi0xMTInLFxuICAweGIyMGY6ICdibGFrZTJiLTEyMCcsXG4gIDB4YjIxMDogJ2JsYWtlMmItMTI4JyxcbiAgMHhiMjExOiAnYmxha2UyYi0xMzYnLFxuICAweGIyMTI6ICdibGFrZTJiLTE0NCcsXG4gIDB4YjIxMzogJ2JsYWtlMmItMTUyJyxcbiAgMHhiMjE0OiAnYmxha2UyYi0xNjAnLFxuICAweGIyMTU6ICdibGFrZTJiLTE2OCcsXG4gIDB4YjIxNjogJ2JsYWtlMmItMTc2JyxcbiAgMHhiMjE3OiAnYmxha2UyYi0xODQnLFxuICAweGIyMTg6ICdibGFrZTJiLTE5MicsXG4gIDB4YjIxOTogJ2JsYWtlMmItMjAwJyxcbiAgMHhiMjFhOiAnYmxha2UyYi0yMDgnLFxuICAweGIyMWI6ICdibGFrZTJiLTIxNicsXG4gIDB4YjIxYzogJ2JsYWtlMmItMjI0JyxcbiAgMHhiMjFkOiAnYmxha2UyYi0yMzInLFxuICAweGIyMWU6ICdibGFrZTJiLTI0MCcsXG4gIDB4YjIxZjogJ2JsYWtlMmItMjQ4JyxcbiAgMHhiMjIwOiAnYmxha2UyYi0yNTYnLFxuICAweGIyMjE6ICdibGFrZTJiLTI2NCcsXG4gIDB4YjIyMjogJ2JsYWtlMmItMjcyJyxcbiAgMHhiMjIzOiAnYmxha2UyYi0yODAnLFxuICAweGIyMjQ6ICdibGFrZTJiLTI4OCcsXG4gIDB4YjIyNTogJ2JsYWtlMmItMjk2JyxcbiAgMHhiMjI2OiAnYmxha2UyYi0zMDQnLFxuICAweGIyMjc6ICdibGFrZTJiLTMxMicsXG4gIDB4YjIyODogJ2JsYWtlMmItMzIwJyxcbiAgMHhiMjI5OiAnYmxha2UyYi0zMjgnLFxuICAweGIyMmE6ICdibGFrZTJiLTMzNicsXG4gIDB4YjIyYjogJ2JsYWtlMmItMzQ0JyxcbiAgMHhiMjJjOiAnYmxha2UyYi0zNTInLFxuICAweGIyMmQ6ICdibGFrZTJiLTM2MCcsXG4gIDB4YjIyZTogJ2JsYWtlMmItMzY4JyxcbiAgMHhiMjJmOiAnYmxha2UyYi0zNzYnLFxuICAweGIyMzA6ICdibGFrZTJiLTM4NCcsXG4gIDB4YjIzMTogJ2JsYWtlMmItMzkyJyxcbiAgMHhiMjMyOiAnYmxha2UyYi00MDAnLFxuICAweGIyMzM6ICdibGFrZTJiLTQwOCcsXG4gIDB4YjIzNDogJ2JsYWtlMmItNDE2JyxcbiAgMHhiMjM1OiAnYmxha2UyYi00MjQnLFxuICAweGIyMzY6ICdibGFrZTJiLTQzMicsXG4gIDB4YjIzNzogJ2JsYWtlMmItNDQwJyxcbiAgMHhiMjM4OiAnYmxha2UyYi00NDgnLFxuICAweGIyMzk6ICdibGFrZTJiLTQ1NicsXG4gIDB4YjIzYTogJ2JsYWtlMmItNDY0JyxcbiAgMHhiMjNiOiAnYmxha2UyYi00NzInLFxuICAweGIyM2M6ICdibGFrZTJiLTQ4MCcsXG4gIDB4YjIzZDogJ2JsYWtlMmItNDg4JyxcbiAgMHhiMjNlOiAnYmxha2UyYi00OTYnLFxuICAweGIyM2Y6ICdibGFrZTJiLTUwNCcsXG4gIDB4YjI0MDogJ2JsYWtlMmItNTEyJyxcbiAgMHhiMjQxOiAnYmxha2Uycy04JyxcbiAgMHhiMjQyOiAnYmxha2Uycy0xNicsXG4gIDB4YjI0MzogJ2JsYWtlMnMtMjQnLFxuICAweGIyNDQ6ICdibGFrZTJzLTMyJyxcbiAgMHhiMjQ1OiAnYmxha2Uycy00MCcsXG4gIDB4YjI0NjogJ2JsYWtlMnMtNDgnLFxuICAweGIyNDc6ICdibGFrZTJzLTU2JyxcbiAgMHhiMjQ4OiAnYmxha2Uycy02NCcsXG4gIDB4YjI0OTogJ2JsYWtlMnMtNzInLFxuICAweGIyNGE6ICdibGFrZTJzLTgwJyxcbiAgMHhiMjRiOiAnYmxha2Uycy04OCcsXG4gIDB4YjI0YzogJ2JsYWtlMnMtOTYnLFxuICAweGIyNGQ6ICdibGFrZTJzLTEwNCcsXG4gIDB4YjI0ZTogJ2JsYWtlMnMtMTEyJyxcbiAgMHhiMjRmOiAnYmxha2Uycy0xMjAnLFxuICAweGIyNTA6ICdibGFrZTJzLTEyOCcsXG4gIDB4YjI1MTogJ2JsYWtlMnMtMTM2JyxcbiAgMHhiMjUyOiAnYmxha2Uycy0xNDQnLFxuICAweGIyNTM6ICdibGFrZTJzLTE1MicsXG4gIDB4YjI1NDogJ2JsYWtlMnMtMTYwJyxcbiAgMHhiMjU1OiAnYmxha2Uycy0xNjgnLFxuICAweGIyNTY6ICdibGFrZTJzLTE3NicsXG4gIDB4YjI1NzogJ2JsYWtlMnMtMTg0JyxcbiAgMHhiMjU4OiAnYmxha2Uycy0xOTInLFxuICAweGIyNTk6ICdibGFrZTJzLTIwMCcsXG4gIDB4YjI1YTogJ2JsYWtlMnMtMjA4JyxcbiAgMHhiMjViOiAnYmxha2Uycy0yMTYnLFxuICAweGIyNWM6ICdibGFrZTJzLTIyNCcsXG4gIDB4YjI1ZDogJ2JsYWtlMnMtMjMyJyxcbiAgMHhiMjVlOiAnYmxha2Uycy0yNDAnLFxuICAweGIyNWY6ICdibGFrZTJzLTI0OCcsXG4gIDB4YjI2MDogJ2JsYWtlMnMtMjU2JyxcbiAgMHhiMzAxOiAnc2tlaW4yNTYtOCcsXG4gIDB4YjMwMjogJ3NrZWluMjU2LTE2JyxcbiAgMHhiMzAzOiAnc2tlaW4yNTYtMjQnLFxuICAweGIzMDQ6ICdza2VpbjI1Ni0zMicsXG4gIDB4YjMwNTogJ3NrZWluMjU2LTQwJyxcbiAgMHhiMzA2OiAnc2tlaW4yNTYtNDgnLFxuICAweGIzMDc6ICdza2VpbjI1Ni01NicsXG4gIDB4YjMwODogJ3NrZWluMjU2LTY0JyxcbiAgMHhiMzA5OiAnc2tlaW4yNTYtNzInLFxuICAweGIzMGE6ICdza2VpbjI1Ni04MCcsXG4gIDB4YjMwYjogJ3NrZWluMjU2LTg4JyxcbiAgMHhiMzBjOiAnc2tlaW4yNTYtOTYnLFxuICAweGIzMGQ6ICdza2VpbjI1Ni0xMDQnLFxuICAweGIzMGU6ICdza2VpbjI1Ni0xMTInLFxuICAweGIzMGY6ICdza2VpbjI1Ni0xMjAnLFxuICAweGIzMTA6ICdza2VpbjI1Ni0xMjgnLFxuICAweGIzMTE6ICdza2VpbjI1Ni0xMzYnLFxuICAweGIzMTI6ICdza2VpbjI1Ni0xNDQnLFxuICAweGIzMTM6ICdza2VpbjI1Ni0xNTInLFxuICAweGIzMTQ6ICdza2VpbjI1Ni0xNjAnLFxuICAweGIzMTU6ICdza2VpbjI1Ni0xNjgnLFxuICAweGIzMTY6ICdza2VpbjI1Ni0xNzYnLFxuICAweGIzMTc6ICdza2VpbjI1Ni0xODQnLFxuICAweGIzMTg6ICdza2VpbjI1Ni0xOTInLFxuICAweGIzMTk6ICdza2VpbjI1Ni0yMDAnLFxuICAweGIzMWE6ICdza2VpbjI1Ni0yMDgnLFxuICAweGIzMWI6ICdza2VpbjI1Ni0yMTYnLFxuICAweGIzMWM6ICdza2VpbjI1Ni0yMjQnLFxuICAweGIzMWQ6ICdza2VpbjI1Ni0yMzInLFxuICAweGIzMWU6ICdza2VpbjI1Ni0yNDAnLFxuICAweGIzMWY6ICdza2VpbjI1Ni0yNDgnLFxuICAweGIzMjA6ICdza2VpbjI1Ni0yNTYnLFxuICAweGIzMjE6ICdza2VpbjUxMi04JyxcbiAgMHhiMzIyOiAnc2tlaW41MTItMTYnLFxuICAweGIzMjM6ICdza2VpbjUxMi0yNCcsXG4gIDB4YjMyNDogJ3NrZWluNTEyLTMyJyxcbiAgMHhiMzI1OiAnc2tlaW41MTItNDAnLFxuICAweGIzMjY6ICdza2VpbjUxMi00OCcsXG4gIDB4YjMyNzogJ3NrZWluNTEyLTU2JyxcbiAgMHhiMzI4OiAnc2tlaW41MTItNjQnLFxuICAweGIzMjk6ICdza2VpbjUxMi03MicsXG4gIDB4YjMyYTogJ3NrZWluNTEyLTgwJyxcbiAgMHhiMzJiOiAnc2tlaW41MTItODgnLFxuICAweGIzMmM6ICdza2VpbjUxMi05NicsXG4gIDB4YjMyZDogJ3NrZWluNTEyLTEwNCcsXG4gIDB4YjMyZTogJ3NrZWluNTEyLTExMicsXG4gIDB4YjMyZjogJ3NrZWluNTEyLTEyMCcsXG4gIDB4YjMzMDogJ3NrZWluNTEyLTEyOCcsXG4gIDB4YjMzMTogJ3NrZWluNTEyLTEzNicsXG4gIDB4YjMzMjogJ3NrZWluNTEyLTE0NCcsXG4gIDB4YjMzMzogJ3NrZWluNTEyLTE1MicsXG4gIDB4YjMzNDogJ3NrZWluNTEyLTE2MCcsXG4gIDB4YjMzNTogJ3NrZWluNTEyLTE2OCcsXG4gIDB4YjMzNjogJ3NrZWluNTEyLTE3NicsXG4gIDB4YjMzNzogJ3NrZWluNTEyLTE4NCcsXG4gIDB4YjMzODogJ3NrZWluNTEyLTE5MicsXG4gIDB4YjMzOTogJ3NrZWluNTEyLTIwMCcsXG4gIDB4YjMzYTogJ3NrZWluNTEyLTIwOCcsXG4gIDB4YjMzYjogJ3NrZWluNTEyLTIxNicsXG4gIDB4YjMzYzogJ3NrZWluNTEyLTIyNCcsXG4gIDB4YjMzZDogJ3NrZWluNTEyLTIzMicsXG4gIDB4YjMzZTogJ3NrZWluNTEyLTI0MCcsXG4gIDB4YjMzZjogJ3NrZWluNTEyLTI0OCcsXG4gIDB4YjM0MDogJ3NrZWluNTEyLTI1NicsXG4gIDB4YjM0MTogJ3NrZWluNTEyLTI2NCcsXG4gIDB4YjM0MjogJ3NrZWluNTEyLTI3MicsXG4gIDB4YjM0MzogJ3NrZWluNTEyLTI4MCcsXG4gIDB4YjM0NDogJ3NrZWluNTEyLTI4OCcsXG4gIDB4YjM0NTogJ3NrZWluNTEyLTI5NicsXG4gIDB4YjM0NjogJ3NrZWluNTEyLTMwNCcsXG4gIDB4YjM0NzogJ3NrZWluNTEyLTMxMicsXG4gIDB4YjM0ODogJ3NrZWluNTEyLTMyMCcsXG4gIDB4YjM0OTogJ3NrZWluNTEyLTMyOCcsXG4gIDB4YjM0YTogJ3NrZWluNTEyLTMzNicsXG4gIDB4YjM0YjogJ3NrZWluNTEyLTM0NCcsXG4gIDB4YjM0YzogJ3NrZWluNTEyLTM1MicsXG4gIDB4YjM0ZDogJ3NrZWluNTEyLTM2MCcsXG4gIDB4YjM0ZTogJ3NrZWluNTEyLTM2OCcsXG4gIDB4YjM0ZjogJ3NrZWluNTEyLTM3NicsXG4gIDB4YjM1MDogJ3NrZWluNTEyLTM4NCcsXG4gIDB4YjM1MTogJ3NrZWluNTEyLTM5MicsXG4gIDB4YjM1MjogJ3NrZWluNTEyLTQwMCcsXG4gIDB4YjM1MzogJ3NrZWluNTEyLTQwOCcsXG4gIDB4YjM1NDogJ3NrZWluNTEyLTQxNicsXG4gIDB4YjM1NTogJ3NrZWluNTEyLTQyNCcsXG4gIDB4YjM1NjogJ3NrZWluNTEyLTQzMicsXG4gIDB4YjM1NzogJ3NrZWluNTEyLTQ0MCcsXG4gIDB4YjM1ODogJ3NrZWluNTEyLTQ0OCcsXG4gIDB4YjM1OTogJ3NrZWluNTEyLTQ1NicsXG4gIDB4YjM1YTogJ3NrZWluNTEyLTQ2NCcsXG4gIDB4YjM1YjogJ3NrZWluNTEyLTQ3MicsXG4gIDB4YjM1YzogJ3NrZWluNTEyLTQ4MCcsXG4gIDB4YjM1ZDogJ3NrZWluNTEyLTQ4OCcsXG4gIDB4YjM1ZTogJ3NrZWluNTEyLTQ5NicsXG4gIDB4YjM1ZjogJ3NrZWluNTEyLTUwNCcsXG4gIDB4YjM2MDogJ3NrZWluNTEyLTUxMicsXG4gIDB4YjM2MTogJ3NrZWluMTAyNC04JyxcbiAgMHhiMzYyOiAnc2tlaW4xMDI0LTE2JyxcbiAgMHhiMzYzOiAnc2tlaW4xMDI0LTI0JyxcbiAgMHhiMzY0OiAnc2tlaW4xMDI0LTMyJyxcbiAgMHhiMzY1OiAnc2tlaW4xMDI0LTQwJyxcbiAgMHhiMzY2OiAnc2tlaW4xMDI0LTQ4JyxcbiAgMHhiMzY3OiAnc2tlaW4xMDI0LTU2JyxcbiAgMHhiMzY4OiAnc2tlaW4xMDI0LTY0JyxcbiAgMHhiMzY5OiAnc2tlaW4xMDI0LTcyJyxcbiAgMHhiMzZhOiAnc2tlaW4xMDI0LTgwJyxcbiAgMHhiMzZiOiAnc2tlaW4xMDI0LTg4JyxcbiAgMHhiMzZjOiAnc2tlaW4xMDI0LTk2JyxcbiAgMHhiMzZkOiAnc2tlaW4xMDI0LTEwNCcsXG4gIDB4YjM2ZTogJ3NrZWluMTAyNC0xMTInLFxuICAweGIzNmY6ICdza2VpbjEwMjQtMTIwJyxcbiAgMHhiMzcwOiAnc2tlaW4xMDI0LTEyOCcsXG4gIDB4YjM3MTogJ3NrZWluMTAyNC0xMzYnLFxuICAweGIzNzI6ICdza2VpbjEwMjQtMTQ0JyxcbiAgMHhiMzczOiAnc2tlaW4xMDI0LTE1MicsXG4gIDB4YjM3NDogJ3NrZWluMTAyNC0xNjAnLFxuICAweGIzNzU6ICdza2VpbjEwMjQtMTY4JyxcbiAgMHhiMzc2OiAnc2tlaW4xMDI0LTE3NicsXG4gIDB4YjM3NzogJ3NrZWluMTAyNC0xODQnLFxuICAweGIzNzg6ICdza2VpbjEwMjQtMTkyJyxcbiAgMHhiMzc5OiAnc2tlaW4xMDI0LTIwMCcsXG4gIDB4YjM3YTogJ3NrZWluMTAyNC0yMDgnLFxuICAweGIzN2I6ICdza2VpbjEwMjQtMjE2JyxcbiAgMHhiMzdjOiAnc2tlaW4xMDI0LTIyNCcsXG4gIDB4YjM3ZDogJ3NrZWluMTAyNC0yMzInLFxuICAweGIzN2U6ICdza2VpbjEwMjQtMjQwJyxcbiAgMHhiMzdmOiAnc2tlaW4xMDI0LTI0OCcsXG4gIDB4YjM4MDogJ3NrZWluMTAyNC0yNTYnLFxuICAweGIzODE6ICdza2VpbjEwMjQtMjY0JyxcbiAgMHhiMzgyOiAnc2tlaW4xMDI0LTI3MicsXG4gIDB4YjM4MzogJ3NrZWluMTAyNC0yODAnLFxuICAweGIzODQ6ICdza2VpbjEwMjQtMjg4JyxcbiAgMHhiMzg1OiAnc2tlaW4xMDI0LTI5NicsXG4gIDB4YjM4NjogJ3NrZWluMTAyNC0zMDQnLFxuICAweGIzODc6ICdza2VpbjEwMjQtMzEyJyxcbiAgMHhiMzg4OiAnc2tlaW4xMDI0LTMyMCcsXG4gIDB4YjM4OTogJ3NrZWluMTAyNC0zMjgnLFxuICAweGIzOGE6ICdza2VpbjEwMjQtMzM2JyxcbiAgMHhiMzhiOiAnc2tlaW4xMDI0LTM0NCcsXG4gIDB4YjM4YzogJ3NrZWluMTAyNC0zNTInLFxuICAweGIzOGQ6ICdza2VpbjEwMjQtMzYwJyxcbiAgMHhiMzhlOiAnc2tlaW4xMDI0LTM2OCcsXG4gIDB4YjM4ZjogJ3NrZWluMTAyNC0zNzYnLFxuICAweGIzOTA6ICdza2VpbjEwMjQtMzg0JyxcbiAgMHhiMzkxOiAnc2tlaW4xMDI0LTM5MicsXG4gIDB4YjM5MjogJ3NrZWluMTAyNC00MDAnLFxuICAweGIzOTM6ICdza2VpbjEwMjQtNDA4JyxcbiAgMHhiMzk0OiAnc2tlaW4xMDI0LTQxNicsXG4gIDB4YjM5NTogJ3NrZWluMTAyNC00MjQnLFxuICAweGIzOTY6ICdza2VpbjEwMjQtNDMyJyxcbiAgMHhiMzk3OiAnc2tlaW4xMDI0LTQ0MCcsXG4gIDB4YjM5ODogJ3NrZWluMTAyNC00NDgnLFxuICAweGIzOTk6ICdza2VpbjEwMjQtNDU2JyxcbiAgMHhiMzlhOiAnc2tlaW4xMDI0LTQ2NCcsXG4gIDB4YjM5YjogJ3NrZWluMTAyNC00NzInLFxuICAweGIzOWM6ICdza2VpbjEwMjQtNDgwJyxcbiAgMHhiMzlkOiAnc2tlaW4xMDI0LTQ4OCcsXG4gIDB4YjM5ZTogJ3NrZWluMTAyNC00OTYnLFxuICAweGIzOWY6ICdza2VpbjEwMjQtNTA0JyxcbiAgMHhiM2EwOiAnc2tlaW4xMDI0LTUxMicsXG4gIDB4YjNhMTogJ3NrZWluMTAyNC01MjAnLFxuICAweGIzYTI6ICdza2VpbjEwMjQtNTI4JyxcbiAgMHhiM2EzOiAnc2tlaW4xMDI0LTUzNicsXG4gIDB4YjNhNDogJ3NrZWluMTAyNC01NDQnLFxuICAweGIzYTU6ICdza2VpbjEwMjQtNTUyJyxcbiAgMHhiM2E2OiAnc2tlaW4xMDI0LTU2MCcsXG4gIDB4YjNhNzogJ3NrZWluMTAyNC01NjgnLFxuICAweGIzYTg6ICdza2VpbjEwMjQtNTc2JyxcbiAgMHhiM2E5OiAnc2tlaW4xMDI0LTU4NCcsXG4gIDB4YjNhYTogJ3NrZWluMTAyNC01OTInLFxuICAweGIzYWI6ICdza2VpbjEwMjQtNjAwJyxcbiAgMHhiM2FjOiAnc2tlaW4xMDI0LTYwOCcsXG4gIDB4YjNhZDogJ3NrZWluMTAyNC02MTYnLFxuICAweGIzYWU6ICdza2VpbjEwMjQtNjI0JyxcbiAgMHhiM2FmOiAnc2tlaW4xMDI0LTYzMicsXG4gIDB4YjNiMDogJ3NrZWluMTAyNC02NDAnLFxuICAweGIzYjE6ICdza2VpbjEwMjQtNjQ4JyxcbiAgMHhiM2IyOiAnc2tlaW4xMDI0LTY1NicsXG4gIDB4YjNiMzogJ3NrZWluMTAyNC02NjQnLFxuICAweGIzYjQ6ICdza2VpbjEwMjQtNjcyJyxcbiAgMHhiM2I1OiAnc2tlaW4xMDI0LTY4MCcsXG4gIDB4YjNiNjogJ3NrZWluMTAyNC02ODgnLFxuICAweGIzYjc6ICdza2VpbjEwMjQtNjk2JyxcbiAgMHhiM2I4OiAnc2tlaW4xMDI0LTcwNCcsXG4gIDB4YjNiOTogJ3NrZWluMTAyNC03MTInLFxuICAweGIzYmE6ICdza2VpbjEwMjQtNzIwJyxcbiAgMHhiM2JiOiAnc2tlaW4xMDI0LTcyOCcsXG4gIDB4YjNiYzogJ3NrZWluMTAyNC03MzYnLFxuICAweGIzYmQ6ICdza2VpbjEwMjQtNzQ0JyxcbiAgMHhiM2JlOiAnc2tlaW4xMDI0LTc1MicsXG4gIDB4YjNiZjogJ3NrZWluMTAyNC03NjAnLFxuICAweGIzYzA6ICdza2VpbjEwMjQtNzY4JyxcbiAgMHhiM2MxOiAnc2tlaW4xMDI0LTc3NicsXG4gIDB4YjNjMjogJ3NrZWluMTAyNC03ODQnLFxuICAweGIzYzM6ICdza2VpbjEwMjQtNzkyJyxcbiAgMHhiM2M0OiAnc2tlaW4xMDI0LTgwMCcsXG4gIDB4YjNjNTogJ3NrZWluMTAyNC04MDgnLFxuICAweGIzYzY6ICdza2VpbjEwMjQtODE2JyxcbiAgMHhiM2M3OiAnc2tlaW4xMDI0LTgyNCcsXG4gIDB4YjNjODogJ3NrZWluMTAyNC04MzInLFxuICAweGIzYzk6ICdza2VpbjEwMjQtODQwJyxcbiAgMHhiM2NhOiAnc2tlaW4xMDI0LTg0OCcsXG4gIDB4YjNjYjogJ3NrZWluMTAyNC04NTYnLFxuICAweGIzY2M6ICdza2VpbjEwMjQtODY0JyxcbiAgMHhiM2NkOiAnc2tlaW4xMDI0LTg3MicsXG4gIDB4YjNjZTogJ3NrZWluMTAyNC04ODAnLFxuICAweGIzY2Y6ICdza2VpbjEwMjQtODg4JyxcbiAgMHhiM2QwOiAnc2tlaW4xMDI0LTg5NicsXG4gIDB4YjNkMTogJ3NrZWluMTAyNC05MDQnLFxuICAweGIzZDI6ICdza2VpbjEwMjQtOTEyJyxcbiAgMHhiM2QzOiAnc2tlaW4xMDI0LTkyMCcsXG4gIDB4YjNkNDogJ3NrZWluMTAyNC05MjgnLFxuICAweGIzZDU6ICdza2VpbjEwMjQtOTM2JyxcbiAgMHhiM2Q2OiAnc2tlaW4xMDI0LTk0NCcsXG4gIDB4YjNkNzogJ3NrZWluMTAyNC05NTInLFxuICAweGIzZDg6ICdza2VpbjEwMjQtOTYwJyxcbiAgMHhiM2Q5OiAnc2tlaW4xMDI0LTk2OCcsXG4gIDB4YjNkYTogJ3NrZWluMTAyNC05NzYnLFxuICAweGIzZGI6ICdza2VpbjEwMjQtOTg0JyxcbiAgMHhiM2RjOiAnc2tlaW4xMDI0LTk5MicsXG4gIDB4YjNkZDogJ3NrZWluMTAyNC0xMDAwJyxcbiAgMHhiM2RlOiAnc2tlaW4xMDI0LTEwMDgnLFxuICAweGIzZGY6ICdza2VpbjEwMjQtMTAxNicsXG4gIDB4YjNlMDogJ3NrZWluMTAyNC0xMDI0JyxcblxuICAvLyBtdWx0aWFkZHJcbiAgMHgwNDogJ2lwNCcsXG4gIDB4MDY6ICd0Y3AnLFxuICAweDIxOiAnZGNjcCcsXG4gIDB4Mjk6ICdpcDYnLFxuICAweDJhOiAnaXA2em9uZScsXG4gIDB4MzU6ICdkbnMnLFxuICAweDM2OiAnZG5zNCcsXG4gIDB4Mzc6ICdkbnM2JyxcbiAgMHgzODogJ2Ruc2FkZHInLFxuICAweDg0OiAnc2N0cCcsXG4gIDB4MDExMTogJ3VkcCcsXG4gIDB4MDExMzogJ3AycC13ZWJydGMtc3RhcicsXG4gIDB4MDExNDogJ3AycC13ZWJydGMtZGlyZWN0JyxcbiAgMHgwMTE1OiAncDJwLXN0YXJkdXN0JyxcbiAgMHgwMTIyOiAncDJwLWNpcmN1aXQnLFxuICAweDAxMmQ6ICd1ZHQnLFxuICAweDAxMmU6ICd1dHAnLFxuICAweDAxOTA6ICd1bml4JyxcbiAgMHgwMWE1OiAncDJwJyxcbiAgMHgwMWJiOiAnaHR0cHMnLFxuICAweDAxYmM6ICdvbmlvbicsXG4gIDB4MDFiZDogJ29uaW9uMycsXG4gIDB4MDFiZTogJ2dhcmxpYzY0JyxcbiAgMHgwMWJmOiAnZ2FybGljMzInLFxuICAweDAxY2M6ICdxdWljJyxcbiAgMHgwMWRkOiAnd3MnLFxuICAweDAxZGU6ICd3c3MnLFxuICAweDAxZGY6ICdwMnAtd2Vic29ja2V0LXN0YXInLFxuICAweDAxZTA6ICdodHRwJyxcblxuICAvLyBpcGxkXG4gIDB4NTU6ICdyYXcnLFxuICAweDcwOiAnZGFnLXBiJyxcbiAgMHg3MTogJ2RhZy1jYm9yJyxcbiAgMHg3MjogJ2xpYnAycC1rZXknLFxuICAweDc4OiAnZ2l0LXJhdycsXG4gIDB4N2I6ICd0b3JyZW50LWluZm8nLFxuICAweDdjOiAndG9ycmVudC1maWxlJyxcbiAgMHg4MTogJ2xlb2Zjb2luLWJsb2NrJyxcbiAgMHg4MjogJ2xlb2Zjb2luLXR4JyxcbiAgMHg4MzogJ2xlb2Zjb2luLXByJyxcbiAgMHg5MDogJ2V0aC1ibG9jaycsXG4gIDB4OTE6ICdldGgtYmxvY2stbGlzdCcsXG4gIDB4OTI6ICdldGgtdHgtdHJpZScsXG4gIDB4OTM6ICdldGgtdHgnLFxuICAweDk0OiAnZXRoLXR4LXJlY2VpcHQtdHJpZScsXG4gIDB4OTU6ICdldGgtdHgtcmVjZWlwdCcsXG4gIDB4OTY6ICdldGgtc3RhdGUtdHJpZScsXG4gIDB4OTc6ICdldGgtYWNjb3VudC1zbmFwc2hvdCcsXG4gIDB4OTg6ICdldGgtc3RvcmFnZS10cmllJyxcbiAgMHhiMDogJ2JpdGNvaW4tYmxvY2snLFxuICAweGIxOiAnYml0Y29pbi10eCcsXG4gIDB4YzA6ICd6Y2FzaC1ibG9jaycsXG4gIDB4YzE6ICd6Y2FzaC10eCcsXG4gIDB4ZDA6ICdzdGVsbGFyLWJsb2NrJyxcbiAgMHhkMTogJ3N0ZWxsYXItdHgnLFxuICAweGUwOiAnZGVjcmVkLWJsb2NrJyxcbiAgMHhlMTogJ2RlY3JlZC10eCcsXG4gIDB4ZjA6ICdkYXNoLWJsb2NrJyxcbiAgMHhmMTogJ2Rhc2gtdHgnLFxuICAweGZhOiAnc3dhcm0tbWFuaWZlc3QnLFxuICAweGZiOiAnc3dhcm0tZmVlZCcsXG4gIDB4MDEyOTogJ2RhZy1qc29uJyxcblxuICAvLyBuYW1lc3BhY2VcbiAgMHgyZjogJ3BhdGgnLFxuICAweGUyOiAnaXBsZC1ucycsXG4gIDB4ZTM6ICdpcGZzLW5zJyxcbiAgMHhlNDogJ3N3YXJtLW5zJyxcbiAgMHhlNTogJ2lwbnMtbnMnLFxuICAweGU2OiAnemVyb25ldCcsXG5cbiAgLy8ga2V5XG4gIDB4ZWQ6ICdlZDI1NTE5LXB1YicsXG5cbiAgLy8gaG9sb2NoYWluXG4gIDB4ODA3MTI0OiAnaG9sb2NoYWluLWFkci12MCcsXG4gIDB4ODE3MTI0OiAnaG9sb2NoYWluLWFkci12MScsXG4gIDB4OTQ3MTI0OiAnaG9sb2NoYWluLWtleS12MCcsXG4gIDB4OTU3MTI0OiAnaG9sb2NoYWluLWtleS12MScsXG4gIDB4YTI3MTI0OiAnaG9sb2NoYWluLXNpZy12MCcsXG4gIDB4YTM3MTI0OiAnaG9sb2NoYWluLXNpZy12MSdcbn0pXG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IGJhc2VUYWJsZSA9IHJlcXVpcmUoJy4vYmFzZS10YWJsZScpXG5cbi8vIHRoaXMgY3JlYXRlcyBhIG1hcCBmb3IgY29kZSBhcyBoZXhTdHJpbmcgLT4gY29kZWNOYW1lXG5cbmNvbnN0IG5hbWVUYWJsZSA9IHt9XG5tb2R1bGUuZXhwb3J0cyA9IG5hbWVUYWJsZVxuXG5mb3IgKGxldCBlbmNvZGluZ05hbWUgaW4gYmFzZVRhYmxlKSB7XG4gIGxldCBjb2RlID0gYmFzZVRhYmxlW2VuY29kaW5nTmFtZV1cbiAgbmFtZVRhYmxlW2NvZGUudG9TdHJpbmcoJ2hleCcpXSA9IGVuY29kaW5nTmFtZVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCBiYXNlVGFibGUgPSByZXF1aXJlKCcuL2Jhc2UtdGFibGUnKVxuY29uc3QgdmFyaW50QnVmZmVyRW5jb2RlID0gcmVxdWlyZSgnLi91dGlsJykudmFyaW50QnVmZmVyRW5jb2RlXG5cbi8vIHRoaXMgY3JlYXRlcyBhIG1hcCBmb3IgY29kZWNOYW1lIC0+IGNvZGVWYXJpbnRCdWZmZXJcblxuY29uc3QgdmFyaW50VGFibGUgPSB7fVxubW9kdWxlLmV4cG9ydHMgPSB2YXJpbnRUYWJsZVxuXG5mb3IgKGxldCBlbmNvZGluZ05hbWUgaW4gYmFzZVRhYmxlKSB7XG4gIGxldCBjb2RlID0gYmFzZVRhYmxlW2VuY29kaW5nTmFtZV1cbiAgdmFyaW50VGFibGVbZW5jb2RpbmdOYW1lXSA9IHZhcmludEJ1ZmZlckVuY29kZShjb2RlKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbnVtYmVyVG9CdWZmZXIsXG4gIGJ1ZmZlclRvTnVtYmVyLFxuICB2YXJpbnRCdWZmZXJFbmNvZGUsXG4gIHZhcmludEJ1ZmZlckRlY29kZVxufVxuXG5mdW5jdGlvbiBidWZmZXJUb051bWJlciAoYnVmKSB7XG4gIHJldHVybiBwYXJzZUludChidWYudG9TdHJpbmcoJ2hleCcpLCAxNilcbn1cblxuZnVuY3Rpb24gbnVtYmVyVG9CdWZmZXIgKG51bSkge1xuICBsZXQgaGV4U3RyaW5nID0gbnVtLnRvU3RyaW5nKDE2KVxuICBpZiAoaGV4U3RyaW5nLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICBoZXhTdHJpbmcgPSAnMCcgKyBoZXhTdHJpbmdcbiAgfVxuICByZXR1cm4gQnVmZmVyLmZyb20oaGV4U3RyaW5nLCAnaGV4Jylcbn1cblxuZnVuY3Rpb24gdmFyaW50QnVmZmVyRW5jb2RlIChpbnB1dCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20odmFyaW50LmVuY29kZShidWZmZXJUb051bWJlcihpbnB1dCkpKVxufVxuXG5mdW5jdGlvbiB2YXJpbnRCdWZmZXJEZWNvZGUgKGlucHV0KSB7XG4gIHJldHVybiBudW1iZXJUb0J1ZmZlcih2YXJpbnQuZGVjb2RlKGlucHV0KSlcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gd2l0aElzKENsYXNzLCB7IGNsYXNzTmFtZSwgc3ltYm9sTmFtZSB9KSB7XG4gICAgY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcihzeW1ib2xOYW1lKTtcblxuICAgIGNvbnN0IENsYXNzSXNXcmFwcGVyID0ge1xuICAgICAgICAvLyBUaGUgY29kZSBiZWxvdyBhc3NpZ25zIHRoZSBjbGFzcyB3cmFwcGVyIHRvIGFuIG9iamVjdCB0byB0cmlja1xuICAgICAgICAvLyBKYXZhU2NyaXB0IGVuZ2luZXMgdG8gc2hvdyB0aGUgbmFtZSBvZiB0aGUgZXh0ZW5kZWQgY2xhc3Mgd2hlblxuICAgICAgICAvLyBsb2dnaW5nIGFuIGluc3RhbmNlcy5cbiAgICAgICAgLy8gV2UgYXJlIGFzc2lnbmluZyBhbiBhbm9ueW1vdXMgY2xhc3MgKGNsYXNzIHdyYXBwZXIpIHRvIHRoZSBvYmplY3RcbiAgICAgICAgLy8gd2l0aCBrZXkgYGNsYXNzTmFtZWAgdG8ga2VlcCB0aGUgY29ycmVjdCBuYW1lLlxuICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQgaXQgZmFsbHMgYmFjayB0byBsb2dnaW5nIGBDbGFzc0lzV3JhcHBlcmAuXG4gICAgICAgIFtjbGFzc05hbWVdOiBjbGFzcyBleHRlbmRzIENsYXNzIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgc3ltYm9sLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9W2NsYXNzTmFtZV07XG5cbiAgICBDbGFzc0lzV3JhcHBlcltgaXMke2NsYXNzTmFtZX1gXSA9IChvYmopID0+ICEhKG9iaiAmJiBvYmpbc3ltYm9sXSk7XG5cbiAgICByZXR1cm4gQ2xhc3NJc1dyYXBwZXI7XG59XG5cbmZ1bmN0aW9uIHdpdGhJc1Byb3RvKENsYXNzLCB7IGNsYXNzTmFtZSwgc3ltYm9sTmFtZSwgd2l0aG91dE5ldyB9KSB7XG4gICAgY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcihzeW1ib2xOYW1lKTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG9iamVjdC1zaG9ydGhhbmQgKi9cbiAgICBjb25zdCBDbGFzc0lzV3JhcHBlciA9IHtcbiAgICAgICAgW2NsYXNzTmFtZV06IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICBpZiAod2l0aG91dE5ldyAmJiAhKHRoaXMgaW5zdGFuY2VvZiBDbGFzc0lzV3JhcHBlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENsYXNzSXNXcmFwcGVyKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBfdGhpcyA9IENsYXNzLmNhbGwodGhpcywgLi4uYXJncykgfHwgdGhpcztcblxuICAgICAgICAgICAgaWYgKF90aGlzICYmICFfdGhpc1tzeW1ib2xdKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBzeW1ib2wsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfSxcbiAgICB9W2NsYXNzTmFtZV07XG4gICAgLyogZXNsaW50LWVuYWJsZSBvYmplY3Qtc2hvcnRoYW5kICovXG5cbiAgICBDbGFzc0lzV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSk7XG4gICAgQ2xhc3NJc1dyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3NJc1dyYXBwZXI7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3NJc1dyYXBwZXIucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIENsYXNzSXNXcmFwcGVyW2BpcyR7Y2xhc3NOYW1lfWBdID0gKG9iaikgPT4gISEob2JqICYmIG9ialtzeW1ib2xdKTtcblxuICAgIHJldHVybiBDbGFzc0lzV3JhcHBlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aXRoSXM7XG5tb2R1bGUuZXhwb3J0cy5wcm90byA9IHdpdGhJc1Byb3RvO1xuIiwiLy8gVEhJUyBGSUxFIElTIEdFTkVSQVRFRCwgRE8gTk8gRURJVCBNQU5VQUxMWVxuLy8gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIHRoZSBSRUFETUUubWRcbi8qIGVzbGludC1kaXNhYmxlIGRvdC1ub3RhdGlvbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbi8vIHNlcmlhbGl6YXRpb25cbmV4cG9ydHNbJ3Byb3RvYnVmJ10gPSBCdWZmZXIuZnJvbSgnNTAnLCAnaGV4JylcbmV4cG9ydHNbJ2Nib3InXSA9IEJ1ZmZlci5mcm9tKCc1MScsICdoZXgnKVxuZXhwb3J0c1sncmxwJ10gPSBCdWZmZXIuZnJvbSgnNjAnLCAnaGV4JylcbmV4cG9ydHNbJ2JlbmNvZGUnXSA9IEJ1ZmZlci5mcm9tKCc2MycsICdoZXgnKVxuZXhwb3J0c1snanNvbiddID0gQnVmZmVyLmZyb20oJzAyMDAnLCAnaGV4JylcbmV4cG9ydHNbJ21lc3NhZ2VwYWNrJ10gPSBCdWZmZXIuZnJvbSgnMDIwMScsICdoZXgnKVxuXG4vLyBtdWx0aWZvcm1hdFxuZXhwb3J0c1snbXVsdGljb2RlYyddID0gQnVmZmVyLmZyb20oJzMwJywgJ2hleCcpXG5leHBvcnRzWydtdWx0aWhhc2gnXSA9IEJ1ZmZlci5mcm9tKCczMScsICdoZXgnKVxuZXhwb3J0c1snbXVsdGlhZGRyJ10gPSBCdWZmZXIuZnJvbSgnMzInLCAnaGV4JylcbmV4cG9ydHNbJ211bHRpYmFzZSddID0gQnVmZmVyLmZyb20oJzMzJywgJ2hleCcpXG5cbi8vIG11bHRpaGFzaFxuZXhwb3J0c1snaWRlbnRpdHknXSA9IEJ1ZmZlci5mcm9tKCcwMCcsICdoZXgnKVxuZXhwb3J0c1snc2hhMSddID0gQnVmZmVyLmZyb20oJzExJywgJ2hleCcpXG5leHBvcnRzWydzaGEyLTI1NiddID0gQnVmZmVyLmZyb20oJzEyJywgJ2hleCcpXG5leHBvcnRzWydzaGEyLTUxMiddID0gQnVmZmVyLmZyb20oJzEzJywgJ2hleCcpXG5leHBvcnRzWydzaGEzLTUxMiddID0gQnVmZmVyLmZyb20oJzE0JywgJ2hleCcpXG5leHBvcnRzWydzaGEzLTM4NCddID0gQnVmZmVyLmZyb20oJzE1JywgJ2hleCcpXG5leHBvcnRzWydzaGEzLTI1NiddID0gQnVmZmVyLmZyb20oJzE2JywgJ2hleCcpXG5leHBvcnRzWydzaGEzLTIyNCddID0gQnVmZmVyLmZyb20oJzE3JywgJ2hleCcpXG5leHBvcnRzWydzaGFrZS0xMjgnXSA9IEJ1ZmZlci5mcm9tKCcxOCcsICdoZXgnKVxuZXhwb3J0c1snc2hha2UtMjU2J10gPSBCdWZmZXIuZnJvbSgnMTknLCAnaGV4JylcbmV4cG9ydHNbJ2tlY2Nhay0yMjQnXSA9IEJ1ZmZlci5mcm9tKCcxYScsICdoZXgnKVxuZXhwb3J0c1sna2VjY2FrLTI1NiddID0gQnVmZmVyLmZyb20oJzFiJywgJ2hleCcpXG5leHBvcnRzWydrZWNjYWstMzg0J10gPSBCdWZmZXIuZnJvbSgnMWMnLCAnaGV4JylcbmV4cG9ydHNbJ2tlY2Nhay01MTInXSA9IEJ1ZmZlci5mcm9tKCcxZCcsICdoZXgnKVxuZXhwb3J0c1snbXVybXVyMy0xMjgnXSA9IEJ1ZmZlci5mcm9tKCcyMicsICdoZXgnKVxuZXhwb3J0c1snbXVybXVyMy0zMiddID0gQnVmZmVyLmZyb20oJzIzJywgJ2hleCcpXG5leHBvcnRzWydkYmwtc2hhMi0yNTYnXSA9IEJ1ZmZlci5mcm9tKCc1NicsICdoZXgnKVxuZXhwb3J0c1snbWQ0J10gPSBCdWZmZXIuZnJvbSgnZDQnLCAnaGV4JylcbmV4cG9ydHNbJ21kNSddID0gQnVmZmVyLmZyb20oJ2Q1JywgJ2hleCcpXG5leHBvcnRzWydibXQnXSA9IEJ1ZmZlci5mcm9tKCdkNicsICdoZXgnKVxuZXhwb3J0c1sneDExJ10gPSBCdWZmZXIuZnJvbSgnMTEwMCcsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi04J10gPSBCdWZmZXIuZnJvbSgnYjIwMScsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0xNiddID0gQnVmZmVyLmZyb20oJ2IyMDInLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMjQnXSA9IEJ1ZmZlci5mcm9tKCdiMjAzJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTMyJ10gPSBCdWZmZXIuZnJvbSgnYjIwNCcsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi00MCddID0gQnVmZmVyLmZyb20oJ2IyMDUnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItNDgnXSA9IEJ1ZmZlci5mcm9tKCdiMjA2JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTU2J10gPSBCdWZmZXIuZnJvbSgnYjIwNycsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi02NCddID0gQnVmZmVyLmZyb20oJ2IyMDgnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItNzInXSA9IEJ1ZmZlci5mcm9tKCdiMjA5JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTgwJ10gPSBCdWZmZXIuZnJvbSgnYjIwYScsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi04OCddID0gQnVmZmVyLmZyb20oJ2IyMGInLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItOTYnXSA9IEJ1ZmZlci5mcm9tKCdiMjBjJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTEwNCddID0gQnVmZmVyLmZyb20oJ2IyMGQnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMTEyJ10gPSBCdWZmZXIuZnJvbSgnYjIwZScsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0xMjAnXSA9IEJ1ZmZlci5mcm9tKCdiMjBmJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTEyOCddID0gQnVmZmVyLmZyb20oJ2IyMTAnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMTM2J10gPSBCdWZmZXIuZnJvbSgnYjIxMScsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0xNDQnXSA9IEJ1ZmZlci5mcm9tKCdiMjEyJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTE1MiddID0gQnVmZmVyLmZyb20oJ2IyMTMnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMTYwJ10gPSBCdWZmZXIuZnJvbSgnYjIxNCcsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0xNjgnXSA9IEJ1ZmZlci5mcm9tKCdiMjE1JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTE3NiddID0gQnVmZmVyLmZyb20oJ2IyMTYnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMTg0J10gPSBCdWZmZXIuZnJvbSgnYjIxNycsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0xOTInXSA9IEJ1ZmZlci5mcm9tKCdiMjE4JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTIwMCddID0gQnVmZmVyLmZyb20oJ2IyMTknLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMjA4J10gPSBCdWZmZXIuZnJvbSgnYjIxYScsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0yMTYnXSA9IEJ1ZmZlci5mcm9tKCdiMjFiJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTIyNCddID0gQnVmZmVyLmZyb20oJ2IyMWMnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMjMyJ10gPSBCdWZmZXIuZnJvbSgnYjIxZCcsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0yNDAnXSA9IEJ1ZmZlci5mcm9tKCdiMjFlJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTI0OCddID0gQnVmZmVyLmZyb20oJ2IyMWYnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMjU2J10gPSBCdWZmZXIuZnJvbSgnYjIyMCcsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0yNjQnXSA9IEJ1ZmZlci5mcm9tKCdiMjIxJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTI3MiddID0gQnVmZmVyLmZyb20oJ2IyMjInLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMjgwJ10gPSBCdWZmZXIuZnJvbSgnYjIyMycsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0yODgnXSA9IEJ1ZmZlci5mcm9tKCdiMjI0JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTI5NiddID0gQnVmZmVyLmZyb20oJ2IyMjUnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMzA0J10gPSBCdWZmZXIuZnJvbSgnYjIyNicsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0zMTInXSA9IEJ1ZmZlci5mcm9tKCdiMjI3JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTMyMCddID0gQnVmZmVyLmZyb20oJ2IyMjgnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMzI4J10gPSBCdWZmZXIuZnJvbSgnYjIyOScsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0zMzYnXSA9IEJ1ZmZlci5mcm9tKCdiMjJhJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTM0NCddID0gQnVmZmVyLmZyb20oJ2IyMmInLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMzUyJ10gPSBCdWZmZXIuZnJvbSgnYjIyYycsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0zNjAnXSA9IEJ1ZmZlci5mcm9tKCdiMjJkJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTM2OCddID0gQnVmZmVyLmZyb20oJ2IyMmUnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMzc2J10gPSBCdWZmZXIuZnJvbSgnYjIyZicsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0zODQnXSA9IEJ1ZmZlci5mcm9tKCdiMjMwJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTM5MiddID0gQnVmZmVyLmZyb20oJ2IyMzEnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItNDAwJ10gPSBCdWZmZXIuZnJvbSgnYjIzMicsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi00MDgnXSA9IEJ1ZmZlci5mcm9tKCdiMjMzJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTQxNiddID0gQnVmZmVyLmZyb20oJ2IyMzQnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItNDI0J10gPSBCdWZmZXIuZnJvbSgnYjIzNScsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi00MzInXSA9IEJ1ZmZlci5mcm9tKCdiMjM2JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTQ0MCddID0gQnVmZmVyLmZyb20oJ2IyMzcnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItNDQ4J10gPSBCdWZmZXIuZnJvbSgnYjIzOCcsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi00NTYnXSA9IEJ1ZmZlci5mcm9tKCdiMjM5JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTQ2NCddID0gQnVmZmVyLmZyb20oJ2IyM2EnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItNDcyJ10gPSBCdWZmZXIuZnJvbSgnYjIzYicsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi00ODAnXSA9IEJ1ZmZlci5mcm9tKCdiMjNjJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTQ4OCddID0gQnVmZmVyLmZyb20oJ2IyM2QnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItNDk2J10gPSBCdWZmZXIuZnJvbSgnYjIzZScsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi01MDQnXSA9IEJ1ZmZlci5mcm9tKCdiMjNmJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTUxMiddID0gQnVmZmVyLmZyb20oJ2IyNDAnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtOCddID0gQnVmZmVyLmZyb20oJ2IyNDEnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtMTYnXSA9IEJ1ZmZlci5mcm9tKCdiMjQyJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTI0J10gPSBCdWZmZXIuZnJvbSgnYjI0MycsICdoZXgnKVxuZXhwb3J0c1snYmxha2Uycy0zMiddID0gQnVmZmVyLmZyb20oJ2IyNDQnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtNDAnXSA9IEJ1ZmZlci5mcm9tKCdiMjQ1JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTQ4J10gPSBCdWZmZXIuZnJvbSgnYjI0NicsICdoZXgnKVxuZXhwb3J0c1snYmxha2Uycy01NiddID0gQnVmZmVyLmZyb20oJ2IyNDcnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtNjQnXSA9IEJ1ZmZlci5mcm9tKCdiMjQ4JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTcyJ10gPSBCdWZmZXIuZnJvbSgnYjI0OScsICdoZXgnKVxuZXhwb3J0c1snYmxha2Uycy04MCddID0gQnVmZmVyLmZyb20oJ2IyNGEnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtODgnXSA9IEJ1ZmZlci5mcm9tKCdiMjRiJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTk2J10gPSBCdWZmZXIuZnJvbSgnYjI0YycsICdoZXgnKVxuZXhwb3J0c1snYmxha2Uycy0xMDQnXSA9IEJ1ZmZlci5mcm9tKCdiMjRkJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTExMiddID0gQnVmZmVyLmZyb20oJ2IyNGUnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtMTIwJ10gPSBCdWZmZXIuZnJvbSgnYjI0ZicsICdoZXgnKVxuZXhwb3J0c1snYmxha2Uycy0xMjgnXSA9IEJ1ZmZlci5mcm9tKCdiMjUwJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTEzNiddID0gQnVmZmVyLmZyb20oJ2IyNTEnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtMTQ0J10gPSBCdWZmZXIuZnJvbSgnYjI1MicsICdoZXgnKVxuZXhwb3J0c1snYmxha2Uycy0xNTInXSA9IEJ1ZmZlci5mcm9tKCdiMjUzJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTE2MCddID0gQnVmZmVyLmZyb20oJ2IyNTQnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtMTY4J10gPSBCdWZmZXIuZnJvbSgnYjI1NScsICdoZXgnKVxuZXhwb3J0c1snYmxha2Uycy0xNzYnXSA9IEJ1ZmZlci5mcm9tKCdiMjU2JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTE4NCddID0gQnVmZmVyLmZyb20oJ2IyNTcnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtMTkyJ10gPSBCdWZmZXIuZnJvbSgnYjI1OCcsICdoZXgnKVxuZXhwb3J0c1snYmxha2Uycy0yMDAnXSA9IEJ1ZmZlci5mcm9tKCdiMjU5JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTIwOCddID0gQnVmZmVyLmZyb20oJ2IyNWEnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtMjE2J10gPSBCdWZmZXIuZnJvbSgnYjI1YicsICdoZXgnKVxuZXhwb3J0c1snYmxha2Uycy0yMjQnXSA9IEJ1ZmZlci5mcm9tKCdiMjVjJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTIzMiddID0gQnVmZmVyLmZyb20oJ2IyNWQnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtMjQwJ10gPSBCdWZmZXIuZnJvbSgnYjI1ZScsICdoZXgnKVxuZXhwb3J0c1snYmxha2Uycy0yNDgnXSA9IEJ1ZmZlci5mcm9tKCdiMjVmJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTI1NiddID0gQnVmZmVyLmZyb20oJ2IyNjAnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMjU2LTgnXSA9IEJ1ZmZlci5mcm9tKCdiMzAxJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjI1Ni0xNiddID0gQnVmZmVyLmZyb20oJ2IzMDInLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMjU2LTI0J10gPSBCdWZmZXIuZnJvbSgnYjMwMycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMzInXSA9IEJ1ZmZlci5mcm9tKCdiMzA0JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjI1Ni00MCddID0gQnVmZmVyLmZyb20oJ2IzMDUnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMjU2LTQ4J10gPSBCdWZmZXIuZnJvbSgnYjMwNicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtNTYnXSA9IEJ1ZmZlci5mcm9tKCdiMzA3JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjI1Ni02NCddID0gQnVmZmVyLmZyb20oJ2IzMDgnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMjU2LTcyJ10gPSBCdWZmZXIuZnJvbSgnYjMwOScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtODAnXSA9IEJ1ZmZlci5mcm9tKCdiMzBhJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjI1Ni04OCddID0gQnVmZmVyLmZyb20oJ2IzMGInLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMjU2LTk2J10gPSBCdWZmZXIuZnJvbSgnYjMwYycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTA0J10gPSBCdWZmZXIuZnJvbSgnYjMwZCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTEyJ10gPSBCdWZmZXIuZnJvbSgnYjMwZScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTIwJ10gPSBCdWZmZXIuZnJvbSgnYjMwZicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTI4J10gPSBCdWZmZXIuZnJvbSgnYjMxMCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTM2J10gPSBCdWZmZXIuZnJvbSgnYjMxMScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTQ0J10gPSBCdWZmZXIuZnJvbSgnYjMxMicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTUyJ10gPSBCdWZmZXIuZnJvbSgnYjMxMycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTYwJ10gPSBCdWZmZXIuZnJvbSgnYjMxNCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTY4J10gPSBCdWZmZXIuZnJvbSgnYjMxNScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTc2J10gPSBCdWZmZXIuZnJvbSgnYjMxNicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTg0J10gPSBCdWZmZXIuZnJvbSgnYjMxNycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTkyJ10gPSBCdWZmZXIuZnJvbSgnYjMxOCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMjAwJ10gPSBCdWZmZXIuZnJvbSgnYjMxOScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMjA4J10gPSBCdWZmZXIuZnJvbSgnYjMxYScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMjE2J10gPSBCdWZmZXIuZnJvbSgnYjMxYicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMjI0J10gPSBCdWZmZXIuZnJvbSgnYjMxYycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMjMyJ10gPSBCdWZmZXIuZnJvbSgnYjMxZCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMjQwJ10gPSBCdWZmZXIuZnJvbSgnYjMxZScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMjQ4J10gPSBCdWZmZXIuZnJvbSgnYjMxZicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMjU2J10gPSBCdWZmZXIuZnJvbSgnYjMyMCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW41MTItOCddID0gQnVmZmVyLmZyb20oJ2IzMjEnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluNTEyLTE2J10gPSBCdWZmZXIuZnJvbSgnYjMyMicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW41MTItMjQnXSA9IEJ1ZmZlci5mcm9tKCdiMzIzJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zMiddID0gQnVmZmVyLmZyb20oJ2IzMjQnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluNTEyLTQwJ10gPSBCdWZmZXIuZnJvbSgnYjMyNScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW41MTItNDgnXSA9IEJ1ZmZlci5mcm9tKCdiMzI2JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi01NiddID0gQnVmZmVyLmZyb20oJ2IzMjcnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluNTEyLTY0J10gPSBCdWZmZXIuZnJvbSgnYjMyOCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW41MTItNzInXSA9IEJ1ZmZlci5mcm9tKCdiMzI5JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi04MCddID0gQnVmZmVyLmZyb20oJ2IzMmEnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluNTEyLTg4J10gPSBCdWZmZXIuZnJvbSgnYjMyYicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW41MTItOTYnXSA9IEJ1ZmZlci5mcm9tKCdiMzJjJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xMDQnXSA9IEJ1ZmZlci5mcm9tKCdiMzJkJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xMTInXSA9IEJ1ZmZlci5mcm9tKCdiMzJlJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xMjAnXSA9IEJ1ZmZlci5mcm9tKCdiMzJmJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xMjgnXSA9IEJ1ZmZlci5mcm9tKCdiMzMwJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xMzYnXSA9IEJ1ZmZlci5mcm9tKCdiMzMxJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xNDQnXSA9IEJ1ZmZlci5mcm9tKCdiMzMyJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xNTInXSA9IEJ1ZmZlci5mcm9tKCdiMzMzJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xNjAnXSA9IEJ1ZmZlci5mcm9tKCdiMzM0JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xNjgnXSA9IEJ1ZmZlci5mcm9tKCdiMzM1JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xNzYnXSA9IEJ1ZmZlci5mcm9tKCdiMzM2JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xODQnXSA9IEJ1ZmZlci5mcm9tKCdiMzM3JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xOTInXSA9IEJ1ZmZlci5mcm9tKCdiMzM4JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yMDAnXSA9IEJ1ZmZlci5mcm9tKCdiMzM5JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yMDgnXSA9IEJ1ZmZlci5mcm9tKCdiMzNhJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yMTYnXSA9IEJ1ZmZlci5mcm9tKCdiMzNiJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yMjQnXSA9IEJ1ZmZlci5mcm9tKCdiMzNjJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yMzInXSA9IEJ1ZmZlci5mcm9tKCdiMzNkJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yNDAnXSA9IEJ1ZmZlci5mcm9tKCdiMzNlJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yNDgnXSA9IEJ1ZmZlci5mcm9tKCdiMzNmJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yNTYnXSA9IEJ1ZmZlci5mcm9tKCdiMzQwJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yNjQnXSA9IEJ1ZmZlci5mcm9tKCdiMzQxJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yNzInXSA9IEJ1ZmZlci5mcm9tKCdiMzQyJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yODAnXSA9IEJ1ZmZlci5mcm9tKCdiMzQzJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yODgnXSA9IEJ1ZmZlci5mcm9tKCdiMzQ0JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yOTYnXSA9IEJ1ZmZlci5mcm9tKCdiMzQ1JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zMDQnXSA9IEJ1ZmZlci5mcm9tKCdiMzQ2JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zMTInXSA9IEJ1ZmZlci5mcm9tKCdiMzQ3JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zMjAnXSA9IEJ1ZmZlci5mcm9tKCdiMzQ4JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zMjgnXSA9IEJ1ZmZlci5mcm9tKCdiMzQ5JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zMzYnXSA9IEJ1ZmZlci5mcm9tKCdiMzRhJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zNDQnXSA9IEJ1ZmZlci5mcm9tKCdiMzRiJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zNTInXSA9IEJ1ZmZlci5mcm9tKCdiMzRjJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zNjAnXSA9IEJ1ZmZlci5mcm9tKCdiMzRkJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zNjgnXSA9IEJ1ZmZlci5mcm9tKCdiMzRlJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zNzYnXSA9IEJ1ZmZlci5mcm9tKCdiMzRmJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zODQnXSA9IEJ1ZmZlci5mcm9tKCdiMzUwJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zOTInXSA9IEJ1ZmZlci5mcm9tKCdiMzUxJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00MDAnXSA9IEJ1ZmZlci5mcm9tKCdiMzUyJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00MDgnXSA9IEJ1ZmZlci5mcm9tKCdiMzUzJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00MTYnXSA9IEJ1ZmZlci5mcm9tKCdiMzU0JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00MjQnXSA9IEJ1ZmZlci5mcm9tKCdiMzU1JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00MzInXSA9IEJ1ZmZlci5mcm9tKCdiMzU2JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00NDAnXSA9IEJ1ZmZlci5mcm9tKCdiMzU3JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00NDgnXSA9IEJ1ZmZlci5mcm9tKCdiMzU4JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00NTYnXSA9IEJ1ZmZlci5mcm9tKCdiMzU5JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00NjQnXSA9IEJ1ZmZlci5mcm9tKCdiMzVhJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00NzInXSA9IEJ1ZmZlci5mcm9tKCdiMzViJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00ODAnXSA9IEJ1ZmZlci5mcm9tKCdiMzVjJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00ODgnXSA9IEJ1ZmZlci5mcm9tKCdiMzVkJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00OTYnXSA9IEJ1ZmZlci5mcm9tKCdiMzVlJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi01MDQnXSA9IEJ1ZmZlci5mcm9tKCdiMzVmJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi01MTInXSA9IEJ1ZmZlci5mcm9tKCdiMzYwJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtOCddID0gQnVmZmVyLmZyb20oJ2IzNjEnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0xNiddID0gQnVmZmVyLmZyb20oJ2IzNjInLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0yNCddID0gQnVmZmVyLmZyb20oJ2IzNjMnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0zMiddID0gQnVmZmVyLmZyb20oJ2IzNjQnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC00MCddID0gQnVmZmVyLmZyb20oJ2IzNjUnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC00OCddID0gQnVmZmVyLmZyb20oJ2IzNjYnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC01NiddID0gQnVmZmVyLmZyb20oJ2IzNjcnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC02NCddID0gQnVmZmVyLmZyb20oJ2IzNjgnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC03MiddID0gQnVmZmVyLmZyb20oJ2IzNjknLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC04MCddID0gQnVmZmVyLmZyb20oJ2IzNmEnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC04OCddID0gQnVmZmVyLmZyb20oJ2IzNmInLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC05NiddID0gQnVmZmVyLmZyb20oJ2IzNmMnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0xMDQnXSA9IEJ1ZmZlci5mcm9tKCdiMzZkJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMTEyJ10gPSBCdWZmZXIuZnJvbSgnYjM2ZScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTEyMCddID0gQnVmZmVyLmZyb20oJ2IzNmYnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0xMjgnXSA9IEJ1ZmZlci5mcm9tKCdiMzcwJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMTM2J10gPSBCdWZmZXIuZnJvbSgnYjM3MScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTE0NCddID0gQnVmZmVyLmZyb20oJ2IzNzInLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0xNTInXSA9IEJ1ZmZlci5mcm9tKCdiMzczJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMTYwJ10gPSBCdWZmZXIuZnJvbSgnYjM3NCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTE2OCddID0gQnVmZmVyLmZyb20oJ2IzNzUnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0xNzYnXSA9IEJ1ZmZlci5mcm9tKCdiMzc2JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMTg0J10gPSBCdWZmZXIuZnJvbSgnYjM3NycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTE5MiddID0gQnVmZmVyLmZyb20oJ2IzNzgnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0yMDAnXSA9IEJ1ZmZlci5mcm9tKCdiMzc5JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMjA4J10gPSBCdWZmZXIuZnJvbSgnYjM3YScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTIxNiddID0gQnVmZmVyLmZyb20oJ2IzN2InLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0yMjQnXSA9IEJ1ZmZlci5mcm9tKCdiMzdjJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMjMyJ10gPSBCdWZmZXIuZnJvbSgnYjM3ZCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTI0MCddID0gQnVmZmVyLmZyb20oJ2IzN2UnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0yNDgnXSA9IEJ1ZmZlci5mcm9tKCdiMzdmJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMjU2J10gPSBCdWZmZXIuZnJvbSgnYjM4MCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTI2NCddID0gQnVmZmVyLmZyb20oJ2IzODEnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0yNzInXSA9IEJ1ZmZlci5mcm9tKCdiMzgyJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMjgwJ10gPSBCdWZmZXIuZnJvbSgnYjM4MycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTI4OCddID0gQnVmZmVyLmZyb20oJ2IzODQnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0yOTYnXSA9IEJ1ZmZlci5mcm9tKCdiMzg1JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMzA0J10gPSBCdWZmZXIuZnJvbSgnYjM4NicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTMxMiddID0gQnVmZmVyLmZyb20oJ2IzODcnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0zMjAnXSA9IEJ1ZmZlci5mcm9tKCdiMzg4JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMzI4J10gPSBCdWZmZXIuZnJvbSgnYjM4OScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTMzNiddID0gQnVmZmVyLmZyb20oJ2IzOGEnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0zNDQnXSA9IEJ1ZmZlci5mcm9tKCdiMzhiJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMzUyJ10gPSBCdWZmZXIuZnJvbSgnYjM4YycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTM2MCddID0gQnVmZmVyLmZyb20oJ2IzOGQnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0zNjgnXSA9IEJ1ZmZlci5mcm9tKCdiMzhlJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMzc2J10gPSBCdWZmZXIuZnJvbSgnYjM4ZicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTM4NCddID0gQnVmZmVyLmZyb20oJ2IzOTAnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0zOTInXSA9IEJ1ZmZlci5mcm9tKCdiMzkxJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNDAwJ10gPSBCdWZmZXIuZnJvbSgnYjM5MicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTQwOCddID0gQnVmZmVyLmZyb20oJ2IzOTMnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC00MTYnXSA9IEJ1ZmZlci5mcm9tKCdiMzk0JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNDI0J10gPSBCdWZmZXIuZnJvbSgnYjM5NScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTQzMiddID0gQnVmZmVyLmZyb20oJ2IzOTYnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC00NDAnXSA9IEJ1ZmZlci5mcm9tKCdiMzk3JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNDQ4J10gPSBCdWZmZXIuZnJvbSgnYjM5OCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTQ1NiddID0gQnVmZmVyLmZyb20oJ2IzOTknLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC00NjQnXSA9IEJ1ZmZlci5mcm9tKCdiMzlhJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNDcyJ10gPSBCdWZmZXIuZnJvbSgnYjM5YicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTQ4MCddID0gQnVmZmVyLmZyb20oJ2IzOWMnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC00ODgnXSA9IEJ1ZmZlci5mcm9tKCdiMzlkJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNDk2J10gPSBCdWZmZXIuZnJvbSgnYjM5ZScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTUwNCddID0gQnVmZmVyLmZyb20oJ2IzOWYnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC01MTInXSA9IEJ1ZmZlci5mcm9tKCdiM2EwJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNTIwJ10gPSBCdWZmZXIuZnJvbSgnYjNhMScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTUyOCddID0gQnVmZmVyLmZyb20oJ2IzYTInLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC01MzYnXSA9IEJ1ZmZlci5mcm9tKCdiM2EzJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNTQ0J10gPSBCdWZmZXIuZnJvbSgnYjNhNCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTU1MiddID0gQnVmZmVyLmZyb20oJ2IzYTUnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC01NjAnXSA9IEJ1ZmZlci5mcm9tKCdiM2E2JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNTY4J10gPSBCdWZmZXIuZnJvbSgnYjNhNycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTU3NiddID0gQnVmZmVyLmZyb20oJ2IzYTgnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC01ODQnXSA9IEJ1ZmZlci5mcm9tKCdiM2E5JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNTkyJ10gPSBCdWZmZXIuZnJvbSgnYjNhYScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTYwMCddID0gQnVmZmVyLmZyb20oJ2IzYWInLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC02MDgnXSA9IEJ1ZmZlci5mcm9tKCdiM2FjJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNjE2J10gPSBCdWZmZXIuZnJvbSgnYjNhZCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTYyNCddID0gQnVmZmVyLmZyb20oJ2IzYWUnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC02MzInXSA9IEJ1ZmZlci5mcm9tKCdiM2FmJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNjQwJ10gPSBCdWZmZXIuZnJvbSgnYjNiMCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTY0OCddID0gQnVmZmVyLmZyb20oJ2IzYjEnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC02NTYnXSA9IEJ1ZmZlci5mcm9tKCdiM2IyJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNjY0J10gPSBCdWZmZXIuZnJvbSgnYjNiMycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTY3MiddID0gQnVmZmVyLmZyb20oJ2IzYjQnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC02ODAnXSA9IEJ1ZmZlci5mcm9tKCdiM2I1JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNjg4J10gPSBCdWZmZXIuZnJvbSgnYjNiNicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTY5NiddID0gQnVmZmVyLmZyb20oJ2IzYjcnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC03MDQnXSA9IEJ1ZmZlci5mcm9tKCdiM2I4JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNzEyJ10gPSBCdWZmZXIuZnJvbSgnYjNiOScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTcyMCddID0gQnVmZmVyLmZyb20oJ2IzYmEnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC03MjgnXSA9IEJ1ZmZlci5mcm9tKCdiM2JiJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNzM2J10gPSBCdWZmZXIuZnJvbSgnYjNiYycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTc0NCddID0gQnVmZmVyLmZyb20oJ2IzYmQnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC03NTInXSA9IEJ1ZmZlci5mcm9tKCdiM2JlJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNzYwJ10gPSBCdWZmZXIuZnJvbSgnYjNiZicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTc2OCddID0gQnVmZmVyLmZyb20oJ2IzYzAnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC03NzYnXSA9IEJ1ZmZlci5mcm9tKCdiM2MxJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNzg0J10gPSBCdWZmZXIuZnJvbSgnYjNjMicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTc5MiddID0gQnVmZmVyLmZyb20oJ2IzYzMnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC04MDAnXSA9IEJ1ZmZlci5mcm9tKCdiM2M0JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtODA4J10gPSBCdWZmZXIuZnJvbSgnYjNjNScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTgxNiddID0gQnVmZmVyLmZyb20oJ2IzYzYnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC04MjQnXSA9IEJ1ZmZlci5mcm9tKCdiM2M3JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtODMyJ10gPSBCdWZmZXIuZnJvbSgnYjNjOCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTg0MCddID0gQnVmZmVyLmZyb20oJ2IzYzknLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC04NDgnXSA9IEJ1ZmZlci5mcm9tKCdiM2NhJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtODU2J10gPSBCdWZmZXIuZnJvbSgnYjNjYicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTg2NCddID0gQnVmZmVyLmZyb20oJ2IzY2MnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC04NzInXSA9IEJ1ZmZlci5mcm9tKCdiM2NkJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtODgwJ10gPSBCdWZmZXIuZnJvbSgnYjNjZScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTg4OCddID0gQnVmZmVyLmZyb20oJ2IzY2YnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC04OTYnXSA9IEJ1ZmZlci5mcm9tKCdiM2QwJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtOTA0J10gPSBCdWZmZXIuZnJvbSgnYjNkMScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTkxMiddID0gQnVmZmVyLmZyb20oJ2IzZDInLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC05MjAnXSA9IEJ1ZmZlci5mcm9tKCdiM2QzJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtOTI4J10gPSBCdWZmZXIuZnJvbSgnYjNkNCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTkzNiddID0gQnVmZmVyLmZyb20oJ2IzZDUnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC05NDQnXSA9IEJ1ZmZlci5mcm9tKCdiM2Q2JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtOTUyJ10gPSBCdWZmZXIuZnJvbSgnYjNkNycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTk2MCddID0gQnVmZmVyLmZyb20oJ2IzZDgnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC05NjgnXSA9IEJ1ZmZlci5mcm9tKCdiM2Q5JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtOTc2J10gPSBCdWZmZXIuZnJvbSgnYjNkYScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTk4NCddID0gQnVmZmVyLmZyb20oJ2IzZGInLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC05OTInXSA9IEJ1ZmZlci5mcm9tKCdiM2RjJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMTAwMCddID0gQnVmZmVyLmZyb20oJ2IzZGQnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0xMDA4J10gPSBCdWZmZXIuZnJvbSgnYjNkZScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTEwMTYnXSA9IEJ1ZmZlci5mcm9tKCdiM2RmJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMTAyNCddID0gQnVmZmVyLmZyb20oJ2IzZTAnLCAnaGV4JylcblxuLy8gbXVsdGlhZGRyXG5leHBvcnRzWydpcDQnXSA9IEJ1ZmZlci5mcm9tKCcwNCcsICdoZXgnKVxuZXhwb3J0c1sndGNwJ10gPSBCdWZmZXIuZnJvbSgnMDYnLCAnaGV4JylcbmV4cG9ydHNbJ2RjY3AnXSA9IEJ1ZmZlci5mcm9tKCcyMScsICdoZXgnKVxuZXhwb3J0c1snaXA2J10gPSBCdWZmZXIuZnJvbSgnMjknLCAnaGV4JylcbmV4cG9ydHNbJ2lwNnpvbmUnXSA9IEJ1ZmZlci5mcm9tKCcyYScsICdoZXgnKVxuZXhwb3J0c1snZG5zJ10gPSBCdWZmZXIuZnJvbSgnMzUnLCAnaGV4JylcbmV4cG9ydHNbJ2RuczQnXSA9IEJ1ZmZlci5mcm9tKCczNicsICdoZXgnKVxuZXhwb3J0c1snZG5zNiddID0gQnVmZmVyLmZyb20oJzM3JywgJ2hleCcpXG5leHBvcnRzWydkbnNhZGRyJ10gPSBCdWZmZXIuZnJvbSgnMzgnLCAnaGV4JylcbmV4cG9ydHNbJ3NjdHAnXSA9IEJ1ZmZlci5mcm9tKCc4NCcsICdoZXgnKVxuZXhwb3J0c1sndWRwJ10gPSBCdWZmZXIuZnJvbSgnMDExMScsICdoZXgnKVxuZXhwb3J0c1sncDJwLXdlYnJ0Yy1zdGFyJ10gPSBCdWZmZXIuZnJvbSgnMDExMycsICdoZXgnKVxuZXhwb3J0c1sncDJwLXdlYnJ0Yy1kaXJlY3QnXSA9IEJ1ZmZlci5mcm9tKCcwMTE0JywgJ2hleCcpXG5leHBvcnRzWydwMnAtc3RhcmR1c3QnXSA9IEJ1ZmZlci5mcm9tKCcwMTE1JywgJ2hleCcpXG5leHBvcnRzWydwMnAtY2lyY3VpdCddID0gQnVmZmVyLmZyb20oJzAxMjInLCAnaGV4JylcbmV4cG9ydHNbJ3VkdCddID0gQnVmZmVyLmZyb20oJzAxMmQnLCAnaGV4JylcbmV4cG9ydHNbJ3V0cCddID0gQnVmZmVyLmZyb20oJzAxMmUnLCAnaGV4JylcbmV4cG9ydHNbJ3VuaXgnXSA9IEJ1ZmZlci5mcm9tKCcwMTkwJywgJ2hleCcpXG5leHBvcnRzWydwMnAnXSA9IEJ1ZmZlci5mcm9tKCcwMWE1JywgJ2hleCcpXG5leHBvcnRzWydpcGZzJ10gPSBCdWZmZXIuZnJvbSgnMDFhNScsICdoZXgnKVxuZXhwb3J0c1snaHR0cHMnXSA9IEJ1ZmZlci5mcm9tKCcwMWJiJywgJ2hleCcpXG5leHBvcnRzWydvbmlvbiddID0gQnVmZmVyLmZyb20oJzAxYmMnLCAnaGV4JylcbmV4cG9ydHNbJ29uaW9uMyddID0gQnVmZmVyLmZyb20oJzAxYmQnLCAnaGV4JylcbmV4cG9ydHNbJ2dhcmxpYzY0J10gPSBCdWZmZXIuZnJvbSgnMDFiZScsICdoZXgnKVxuZXhwb3J0c1snZ2FybGljMzInXSA9IEJ1ZmZlci5mcm9tKCcwMWJmJywgJ2hleCcpXG5leHBvcnRzWydxdWljJ10gPSBCdWZmZXIuZnJvbSgnMDFjYycsICdoZXgnKVxuZXhwb3J0c1snd3MnXSA9IEJ1ZmZlci5mcm9tKCcwMWRkJywgJ2hleCcpXG5leHBvcnRzWyd3c3MnXSA9IEJ1ZmZlci5mcm9tKCcwMWRlJywgJ2hleCcpXG5leHBvcnRzWydwMnAtd2Vic29ja2V0LXN0YXInXSA9IEJ1ZmZlci5mcm9tKCcwMWRmJywgJ2hleCcpXG5leHBvcnRzWydodHRwJ10gPSBCdWZmZXIuZnJvbSgnMDFlMCcsICdoZXgnKVxuXG4vLyBpcGxkXG5leHBvcnRzWydyYXcnXSA9IEJ1ZmZlci5mcm9tKCc1NScsICdoZXgnKVxuZXhwb3J0c1snZGFnLXBiJ10gPSBCdWZmZXIuZnJvbSgnNzAnLCAnaGV4JylcbmV4cG9ydHNbJ2RhZy1jYm9yJ10gPSBCdWZmZXIuZnJvbSgnNzEnLCAnaGV4JylcbmV4cG9ydHNbJ2xpYnAycC1rZXknXSA9IEJ1ZmZlci5mcm9tKCc3MicsICdoZXgnKVxuZXhwb3J0c1snZ2l0LXJhdyddID0gQnVmZmVyLmZyb20oJzc4JywgJ2hleCcpXG5leHBvcnRzWyd0b3JyZW50LWluZm8nXSA9IEJ1ZmZlci5mcm9tKCc3YicsICdoZXgnKVxuZXhwb3J0c1sndG9ycmVudC1maWxlJ10gPSBCdWZmZXIuZnJvbSgnN2MnLCAnaGV4JylcbmV4cG9ydHNbJ2xlb2Zjb2luLWJsb2NrJ10gPSBCdWZmZXIuZnJvbSgnODEnLCAnaGV4JylcbmV4cG9ydHNbJ2xlb2Zjb2luLXR4J10gPSBCdWZmZXIuZnJvbSgnODInLCAnaGV4JylcbmV4cG9ydHNbJ2xlb2Zjb2luLXByJ10gPSBCdWZmZXIuZnJvbSgnODMnLCAnaGV4JylcbmV4cG9ydHNbJ2V0aC1ibG9jayddID0gQnVmZmVyLmZyb20oJzkwJywgJ2hleCcpXG5leHBvcnRzWydldGgtYmxvY2stbGlzdCddID0gQnVmZmVyLmZyb20oJzkxJywgJ2hleCcpXG5leHBvcnRzWydldGgtdHgtdHJpZSddID0gQnVmZmVyLmZyb20oJzkyJywgJ2hleCcpXG5leHBvcnRzWydldGgtdHgnXSA9IEJ1ZmZlci5mcm9tKCc5MycsICdoZXgnKVxuZXhwb3J0c1snZXRoLXR4LXJlY2VpcHQtdHJpZSddID0gQnVmZmVyLmZyb20oJzk0JywgJ2hleCcpXG5leHBvcnRzWydldGgtdHgtcmVjZWlwdCddID0gQnVmZmVyLmZyb20oJzk1JywgJ2hleCcpXG5leHBvcnRzWydldGgtc3RhdGUtdHJpZSddID0gQnVmZmVyLmZyb20oJzk2JywgJ2hleCcpXG5leHBvcnRzWydldGgtYWNjb3VudC1zbmFwc2hvdCddID0gQnVmZmVyLmZyb20oJzk3JywgJ2hleCcpXG5leHBvcnRzWydldGgtc3RvcmFnZS10cmllJ10gPSBCdWZmZXIuZnJvbSgnOTgnLCAnaGV4JylcbmV4cG9ydHNbJ2JpdGNvaW4tYmxvY2snXSA9IEJ1ZmZlci5mcm9tKCdiMCcsICdoZXgnKVxuZXhwb3J0c1snYml0Y29pbi10eCddID0gQnVmZmVyLmZyb20oJ2IxJywgJ2hleCcpXG5leHBvcnRzWyd6Y2FzaC1ibG9jayddID0gQnVmZmVyLmZyb20oJ2MwJywgJ2hleCcpXG5leHBvcnRzWyd6Y2FzaC10eCddID0gQnVmZmVyLmZyb20oJ2MxJywgJ2hleCcpXG5leHBvcnRzWydzdGVsbGFyLWJsb2NrJ10gPSBCdWZmZXIuZnJvbSgnZDAnLCAnaGV4JylcbmV4cG9ydHNbJ3N0ZWxsYXItdHgnXSA9IEJ1ZmZlci5mcm9tKCdkMScsICdoZXgnKVxuZXhwb3J0c1snZGVjcmVkLWJsb2NrJ10gPSBCdWZmZXIuZnJvbSgnZTAnLCAnaGV4JylcbmV4cG9ydHNbJ2RlY3JlZC10eCddID0gQnVmZmVyLmZyb20oJ2UxJywgJ2hleCcpXG5leHBvcnRzWydkYXNoLWJsb2NrJ10gPSBCdWZmZXIuZnJvbSgnZjAnLCAnaGV4JylcbmV4cG9ydHNbJ2Rhc2gtdHgnXSA9IEJ1ZmZlci5mcm9tKCdmMScsICdoZXgnKVxuZXhwb3J0c1snc3dhcm0tbWFuaWZlc3QnXSA9IEJ1ZmZlci5mcm9tKCdmYScsICdoZXgnKVxuZXhwb3J0c1snc3dhcm0tZmVlZCddID0gQnVmZmVyLmZyb20oJ2ZiJywgJ2hleCcpXG5leHBvcnRzWydkYWctanNvbiddID0gQnVmZmVyLmZyb20oJzAxMjknLCAnaGV4JylcblxuLy8gbmFtZXNwYWNlXG5leHBvcnRzWydwYXRoJ10gPSBCdWZmZXIuZnJvbSgnMmYnLCAnaGV4JylcbmV4cG9ydHNbJ2lwbGQtbnMnXSA9IEJ1ZmZlci5mcm9tKCdlMicsICdoZXgnKVxuZXhwb3J0c1snaXBmcy1ucyddID0gQnVmZmVyLmZyb20oJ2UzJywgJ2hleCcpXG5leHBvcnRzWydzd2FybS1ucyddID0gQnVmZmVyLmZyb20oJ2U0JywgJ2hleCcpXG5leHBvcnRzWydpcG5zLW5zJ10gPSBCdWZmZXIuZnJvbSgnZTUnLCAnaGV4JylcbmV4cG9ydHNbJ3plcm9uZXQnXSA9IEJ1ZmZlci5mcm9tKCdlNicsICdoZXgnKVxuXG4vLyBrZXlcbmV4cG9ydHNbJ2VkMjU1MTktcHViJ10gPSBCdWZmZXIuZnJvbSgnZWQnLCAnaGV4JylcblxuLy8gaG9sb2NoYWluXG5leHBvcnRzWydob2xvY2hhaW4tYWRyLXYwJ10gPSBCdWZmZXIuZnJvbSgnODA3MTI0JywgJ2hleCcpXG5leHBvcnRzWydob2xvY2hhaW4tYWRyLXYxJ10gPSBCdWZmZXIuZnJvbSgnODE3MTI0JywgJ2hleCcpXG5leHBvcnRzWydob2xvY2hhaW4ta2V5LXYwJ10gPSBCdWZmZXIuZnJvbSgnOTQ3MTI0JywgJ2hleCcpXG5leHBvcnRzWydob2xvY2hhaW4ta2V5LXYxJ10gPSBCdWZmZXIuZnJvbSgnOTU3MTI0JywgJ2hleCcpXG5leHBvcnRzWydob2xvY2hhaW4tc2lnLXYwJ10gPSBCdWZmZXIuZnJvbSgnYTI3MTI0JywgJ2hleCcpXG5leHBvcnRzWydob2xvY2hhaW4tc2lnLXYxJ10gPSBCdWZmZXIuZnJvbSgnYTM3MTI0JywgJ2hleCcpXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgbWggPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpXG5cbnZhciBDSURVdGlsID0ge1xuICAvKipcbiAgICogVGVzdCBpZiB0aGUgZ2l2ZW4gaW5wdXQgaXMgYSB2YWxpZCBDSUQgb2JqZWN0LlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIG1lc3NhZ2UgaWYgaXQgaXMgbm90LlxuICAgKiBSZXR1cm5zIHVuZGVmaW5lZCBpZiBpdCBpcyBhIHZhbGlkIENJRC5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IG90aGVyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBjaGVja0NJRENvbXBvbmVudHM6IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIGlmIChvdGhlciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJ251bGwgdmFsdWVzIGFyZSBub3QgdmFsaWQgQ0lEcydcbiAgICB9XG5cbiAgICBpZiAoIShvdGhlci52ZXJzaW9uID09PSAwIHx8IG90aGVyLnZlcnNpb24gPT09IDEpKSB7XG4gICAgICByZXR1cm4gJ0ludmFsaWQgdmVyc2lvbiwgbXVzdCBiZSBhIG51bWJlciBlcXVhbCB0byAxIG9yIDAnXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvdGhlci5jb2RlYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiAnY29kZWMgbXVzdCBiZSBzdHJpbmcnXG4gICAgfVxuXG4gICAgaWYgKG90aGVyLnZlcnNpb24gPT09IDApIHtcbiAgICAgIGlmIChvdGhlci5jb2RlYyAhPT0gJ2RhZy1wYicpIHtcbiAgICAgICAgcmV0dXJuIGBjb2RlYyBtdXN0IGJlICdkYWctcGInIGZvciBDSUR2MGBcbiAgICAgIH1cbiAgICAgIGlmIChvdGhlci5tdWx0aWJhc2VOYW1lICE9PSAnYmFzZTU4YnRjJykge1xuICAgICAgICByZXR1cm4gYG11bHRpYmFzZU5hbWUgbXVzdCBiZSAnYmFzZTU4YnRjJyBmb3IgQ0lEdjBgXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIob3RoZXIubXVsdGloYXNoKSkge1xuICAgICAgcmV0dXJuICdtdWx0aWhhc2ggbXVzdCBiZSBhIEJ1ZmZlcidcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgbWgudmFsaWRhdGUob3RoZXIubXVsdGloYXNoKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbGV0IGVycm9yTXNnID0gZXJyLm1lc3NhZ2VcbiAgICAgIGlmICghZXJyb3JNc2cpIHsgLy8gSnVzdCBpbiBjYXNlIG1oLnZhbGlkYXRlKCkgdGhyb3dzIGFuIGVycm9yIHdpdGggZW1wdHkgZXJyb3IgbWVzc2FnZVxuICAgICAgICBlcnJvck1zZyA9ICdNdWx0aWhhc2ggdmFsaWRhdGlvbiBmYWlsZWQnXG4gICAgICB9XG4gICAgICByZXR1cm4gZXJyb3JNc2dcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDSURVdGlsXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgbXVsdGlhZGRyID0gcmVxdWlyZSgnbXVsdGlhZGRyJylcblxuZnVuY3Rpb24gZW5zdXJlTXVsdGlhZGRyIChtYSkge1xuICBpZiAobXVsdGlhZGRyLmlzTXVsdGlhZGRyKG1hKSkge1xuICAgIHJldHVybiBtYVxuICB9XG5cbiAgcmV0dXJuIG11bHRpYWRkcihtYSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVuc3VyZU11bHRpYWRkcjogZW5zdXJlTXVsdGlhZGRyXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBlbnN1cmVNdWx0aWFkZHIgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgdW5pcUJ5ID0gcmVxdWlyZSgndW5pcXVlLWJ5JylcblxuLy8gQmVjYXVzZSBKYXZhU2NyaXB0IGRvZXNuJ3QgbGV0IHlvdSBvdmVybG9hZCB0aGUgY29tcGFyZSBpbiBTZXQoKS4uXG5jbGFzcyBNdWx0aWFkZHJTZXQge1xuICBjb25zdHJ1Y3RvciAobXVsdGlhZGRycykge1xuICAgIHRoaXMuX211bHRpYWRkcnMgPSBtdWx0aWFkZHJzIHx8IFtdXG4gICAgdGhpcy5fb2JzZXJ2ZWRNdWx0aWFkZHJzID0gW11cbiAgfVxuXG4gIGFkZCAobWEpIHtcbiAgICBtYSA9IGVuc3VyZU11bHRpYWRkcihtYSlcblxuICAgIGlmICghdGhpcy5oYXMobWEpKSB7XG4gICAgICB0aGlzLl9tdWx0aWFkZHJzLnB1c2gobWEpXG4gICAgfVxuICB9XG5cbiAgLy8gYWRkU2FmZSAtIHByZXZlbnQgbXVsdGlhZGRyIGV4cGxvc2lvbuKEolxuICAvLyBNdWx0aWFkZHIgZXhwbG9zaW9uIGlzIHdoZW4geW91IGRpYWwgdG8gYSBidW5jaCBvZiBub2RlcyBhbmQgZXZlcnkgbm9kZVxuICAvLyBnaXZlcyB5b3UgYSBkaWZmZXJlbnQgb2JzZXJ2ZWQgYWRkcmVzcyBhbmQgeW91IHN0YXJ0IHN0b3JpbmcgdGhlbSBhbGwgdG9cbiAgLy8gc2hhcmUgd2l0aCBvdGhlciBwZWVycy4gVGhpcyBzZWVtcyBsaWtlIGEgZ29vZCBpZGVhIHVudGlsIHlvdSByZWFsaXplIHRoYXRcbiAgLy8gbW9zdCBvZiB0aG9zZSBhZGRyZXNzZXMgYXJlIHVuaXF1ZSB0byB0aGUgc3VibmV0IHRoYXQgcGVlciBpcyBpbiBhbmQgc28sXG4gIC8vIHRoZXkgYXJlIGNvbXBsZXRlbHkgd29ydGhsZXNzIGZvciBhbGwgdGhlIG90aGVyIHBlZXJzLiBUaGlzIG1ldGhvZCBpc1xuICAvLyBleGNsdXNpdmVseSB1c2VkIGJ5IGlkZW50aWZ5LlxuICBhZGRTYWZlIChtYSkge1xuICAgIG1hID0gZW5zdXJlTXVsdGlhZGRyKG1hKVxuXG4gICAgY29uc3QgY2hlY2sgPSB0aGlzLl9vYnNlcnZlZE11bHRpYWRkcnMuc29tZSgobSwgaSkgPT4ge1xuICAgICAgaWYgKG0uZXF1YWxzKG1hKSkge1xuICAgICAgICB0aGlzLmFkZChtYSlcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZWRNdWx0aWFkZHJzLnNwbGljZShpLCAxKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKCFjaGVjaykge1xuICAgICAgdGhpcy5fb2JzZXJ2ZWRNdWx0aWFkZHJzLnB1c2gobWEpXG4gICAgfVxuICB9XG5cbiAgdG9BcnJheSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX211bHRpYWRkcnMuc2xpY2UoKVxuICB9XG5cbiAgZ2V0IHNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLl9tdWx0aWFkZHJzLmxlbmd0aFxuICB9XG5cbiAgZm9yRWFjaCAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5fbXVsdGlhZGRycy5mb3JFYWNoKGZuKVxuICB9XG5cbiAgZmlsdGVyQnkgKG1hRm10KSB7XG4gICAgaWYgKHR5cGVvZiBtYUZtdCAhPT0gJ29iamVjdCcgfHxcbiAgICAgIHR5cGVvZiBtYUZtdC5tYXRjaGVzICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgbWFGbXQucGFydGlhbE1hdGNoICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgbWFGbXQudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHJldHVybiBbXVxuXG4gICAgcmV0dXJuIHRoaXMuX211bHRpYWRkcnMuZmlsdGVyKChtYSkgPT4gbWFGbXQubWF0Y2hlcyhtYSkpXG4gIH1cblxuICBoYXMgKG1hKSB7XG4gICAgbWEgPSBlbnN1cmVNdWx0aWFkZHIobWEpXG4gICAgcmV0dXJuIHRoaXMuX211bHRpYWRkcnMuc29tZSgobSkgPT4gbS5lcXVhbHMobWEpKVxuICB9XG5cbiAgZGVsZXRlIChtYSkge1xuICAgIG1hID0gZW5zdXJlTXVsdGlhZGRyKG1hKVxuXG4gICAgdGhpcy5fbXVsdGlhZGRycy5zb21lKChtLCBpKSA9PiB7XG4gICAgICBpZiAobS5lcXVhbHMobWEpKSB7XG4gICAgICAgIHRoaXMuX211bHRpYWRkcnMuc3BsaWNlKGksIDEpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIHJlcGxhY2VzIHNlbGVjdGVkIGV4aXN0aW5nIG11bHRpYWRkcnMgd2l0aCBuZXcgb25lc1xuICByZXBsYWNlIChleGlzdGluZywgZnJlc2gpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhpc3RpbmcpKSB7XG4gICAgICBleGlzdGluZyA9IFtleGlzdGluZ11cbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZyZXNoKSkge1xuICAgICAgZnJlc2ggPSBbZnJlc2hdXG4gICAgfVxuICAgIGV4aXN0aW5nLmZvckVhY2goKG0pID0+IHRoaXMuZGVsZXRlKG0pKVxuICAgIGZyZXNoLmZvckVhY2goKG0pID0+IHRoaXMuYWRkKG0pKVxuICB9XG5cbiAgY2xlYXIgKCkge1xuICAgIHRoaXMuX211bHRpYWRkcnMgPSBbXVxuICB9XG5cbiAgLy8gdGhpcyBvbmx5IHJlYWxseSBoZWxwcyBtYWtlIGlwNiBhbmQgaXA0IG11bHRpYWRkcnMgZGlzdGluY3QgaWYgdGhleSBhcmVcbiAgLy8gZGlmZmVyZW50XG4gIC8vIFRPRE8gdGhpcyBpcyBub3QgYW4gaWRlYWwgc29sdXRpb24sIHByb2JhYmx5IHRoaXMgY29kZSBzaG91bGQganVzdCBiZVxuICAvLyBpbiBsaWJwMnAtdGNwXG4gIGRpc3RpbmN0ICgpIHtcbiAgICByZXR1cm4gdW5pcUJ5KHRoaXMuX211bHRpYWRkcnMsIChtYSkgPT4ge1xuICAgICAgcmV0dXJuIFttYS50b09wdGlvbnMoKS5wb3J0LCBtYS50b09wdGlvbnMoKS50cmFuc3BvcnRdLmpvaW4oKVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNdWx0aWFkZHJTZXRcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBEZWZpbmUgYSBzdHJ1Y3QgZXJyb3IuXG4gKlxuICogQHR5cGUge1N0cnVjdEVycm9yfVxuICovXG5cbmNsYXNzIFN0cnVjdEVycm9yIGV4dGVuZHMgVHlwZUVycm9yIHtcbiAgc3RhdGljIGZvcm1hdChhdHRycykge1xuICAgIGNvbnN0IHsgdHlwZSwgcGF0aCwgdmFsdWUgfSA9IGF0dHJzO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgRXhwZWN0ZWQgYSB2YWx1ZSBvZiB0eXBlIFxcYCR7dHlwZX1cXGAke3BhdGgubGVuZ3RoID8gYCBmb3IgXFxgJHtwYXRoLmpvaW4oJy4nKX1cXGBgIDogJyd9IGJ1dCByZWNlaXZlZCBcXGAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cXGAuYDtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGF0dHJzKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IFN0cnVjdEVycm9yLmZvcm1hdChhdHRycyk7XG4gICAgc3VwZXIobWVzc2FnZSk7XG5cbiAgICBjb25zdCB7IGRhdGEsIHBhdGgsIHZhbHVlLCByZWFzb24sIHR5cGUsIGVycm9ycyA9IFtdIH0gPSBhdHRycztcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG5cbiAgICBpZiAoIWVycm9ycy5sZW5ndGgpIHtcbiAgICAgIGVycm9ycy5wdXNoKHRoaXMpO1xuICAgIH1cblxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICB9XG4gIH1cbn1cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxudmFyIGtpbmRPZiA9IGZ1bmN0aW9uIGtpbmRPZih2YWwpIHtcbiAgaWYgKHZhbCA9PT0gdm9pZCAwKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gJ2Jvb2xlYW4nO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHJldHVybiAnc3RyaW5nJztcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKSByZXR1cm4gJ251bWJlcic7XG4gIGlmICh0eXBlID09PSAnc3ltYm9sJykgcmV0dXJuICdzeW1ib2wnO1xuICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpc0dlbmVyYXRvckZuKHZhbCkgPyAnZ2VuZXJhdG9yZnVuY3Rpb24nIDogJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmIChpc0FycmF5KHZhbCkpIHJldHVybiAnYXJyYXknO1xuICBpZiAoaXNCdWZmZXIodmFsKSkgcmV0dXJuICdidWZmZXInO1xuICBpZiAoaXNBcmd1bWVudHModmFsKSkgcmV0dXJuICdhcmd1bWVudHMnO1xuICBpZiAoaXNEYXRlKHZhbCkpIHJldHVybiAnZGF0ZSc7XG4gIGlmIChpc0Vycm9yKHZhbCkpIHJldHVybiAnZXJyb3InO1xuICBpZiAoaXNSZWdleHAodmFsKSkgcmV0dXJuICdyZWdleHAnO1xuXG4gIHN3aXRjaCAoY3Rvck5hbWUodmFsKSkge1xuICAgIGNhc2UgJ1N5bWJvbCc6IHJldHVybiAnc3ltYm9sJztcbiAgICBjYXNlICdQcm9taXNlJzogcmV0dXJuICdwcm9taXNlJztcblxuICAgIC8vIFNldCwgTWFwLCBXZWFrU2V0LCBXZWFrTWFwXG4gICAgY2FzZSAnV2Vha01hcCc6IHJldHVybiAnd2Vha21hcCc7XG4gICAgY2FzZSAnV2Vha1NldCc6IHJldHVybiAnd2Vha3NldCc7XG4gICAgY2FzZSAnTWFwJzogcmV0dXJuICdtYXAnO1xuICAgIGNhc2UgJ1NldCc6IHJldHVybiAnc2V0JztcblxuICAgIC8vIDgtYml0IHR5cGVkIGFycmF5c1xuICAgIGNhc2UgJ0ludDhBcnJheSc6IHJldHVybiAnaW50OGFycmF5JztcbiAgICBjYXNlICdVaW50OEFycmF5JzogcmV0dXJuICd1aW50OGFycmF5JztcbiAgICBjYXNlICdVaW50OENsYW1wZWRBcnJheSc6IHJldHVybiAndWludDhjbGFtcGVkYXJyYXknO1xuXG4gICAgLy8gMTYtYml0IHR5cGVkIGFycmF5c1xuICAgIGNhc2UgJ0ludDE2QXJyYXknOiByZXR1cm4gJ2ludDE2YXJyYXknO1xuICAgIGNhc2UgJ1VpbnQxNkFycmF5JzogcmV0dXJuICd1aW50MTZhcnJheSc7XG5cbiAgICAvLyAzMi1iaXQgdHlwZWQgYXJyYXlzXG4gICAgY2FzZSAnSW50MzJBcnJheSc6IHJldHVybiAnaW50MzJhcnJheSc7XG4gICAgY2FzZSAnVWludDMyQXJyYXknOiByZXR1cm4gJ3VpbnQzMmFycmF5JztcbiAgICBjYXNlICdGbG9hdDMyQXJyYXknOiByZXR1cm4gJ2Zsb2F0MzJhcnJheSc7XG4gICAgY2FzZSAnRmxvYXQ2NEFycmF5JzogcmV0dXJuICdmbG9hdDY0YXJyYXknO1xuICB9XG5cbiAgaWYgKGlzR2VuZXJhdG9yT2JqKHZhbCkpIHtcbiAgICByZXR1cm4gJ2dlbmVyYXRvcic7XG4gIH1cblxuICAvLyBOb24tcGxhaW4gb2JqZWN0c1xuICB0eXBlID0gdG9TdHJpbmcuY2FsbCh2YWwpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdbb2JqZWN0IE9iamVjdF0nOiByZXR1cm4gJ29iamVjdCc7XG4gICAgLy8gaXRlcmF0b3JzXG4gICAgY2FzZSAnW29iamVjdCBNYXAgSXRlcmF0b3JdJzogcmV0dXJuICdtYXBpdGVyYXRvcic7XG4gICAgY2FzZSAnW29iamVjdCBTZXQgSXRlcmF0b3JdJzogcmV0dXJuICdzZXRpdGVyYXRvcic7XG4gICAgY2FzZSAnW29iamVjdCBTdHJpbmcgSXRlcmF0b3JdJzogcmV0dXJuICdzdHJpbmdpdGVyYXRvcic7XG4gICAgY2FzZSAnW29iamVjdCBBcnJheSBJdGVyYXRvcl0nOiByZXR1cm4gJ2FycmF5aXRlcmF0b3InO1xuICB9XG5cbiAgLy8gb3RoZXJcbiAgcmV0dXJuIHR5cGUuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzL2csICcnKTtcbn07XG5cbmZ1bmN0aW9uIGN0b3JOYW1lKHZhbCkge1xuICByZXR1cm4gdmFsLmNvbnN0cnVjdG9yID8gdmFsLmNvbnN0cnVjdG9yLm5hbWUgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSkgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKTtcbiAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIEFycmF5O1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yKHZhbCkge1xuICByZXR1cm4gdmFsIGluc3RhbmNlb2YgRXJyb3IgfHwgKHR5cGVvZiB2YWwubWVzc2FnZSA9PT0gJ3N0cmluZycgJiYgdmFsLmNvbnN0cnVjdG9yICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3Iuc3RhY2tUcmFjZUxpbWl0ID09PSAnbnVtYmVyJyk7XG59XG5cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHJldHVybiB0cnVlO1xuICByZXR1cm4gdHlwZW9mIHZhbC50b0RhdGVTdHJpbmcgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgdmFsLmdldERhdGUgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgdmFsLnNldERhdGUgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzUmVnZXhwKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgUmVnRXhwKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHR5cGVvZiB2YWwuZmxhZ3MgPT09ICdzdHJpbmcnXG4gICAgJiYgdHlwZW9mIHZhbC5pZ25vcmVDYXNlID09PSAnYm9vbGVhbidcbiAgICAmJiB0eXBlb2YgdmFsLm11bHRpbGluZSA9PT0gJ2Jvb2xlYW4nXG4gICAgJiYgdHlwZW9mIHZhbC5nbG9iYWwgPT09ICdib29sZWFuJztcbn1cblxuZnVuY3Rpb24gaXNHZW5lcmF0b3JGbihuYW1lLCB2YWwpIHtcbiAgcmV0dXJuIGN0b3JOYW1lKG5hbWUpID09PSAnR2VuZXJhdG9yRnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc0dlbmVyYXRvck9iaih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwudGhyb3cgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgdmFsLnJldHVybiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiB2YWwubmV4dCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsKSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiB2YWwubGVuZ3RoID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsLmNhbGxlZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLm1lc3NhZ2UuaW5kZXhPZignY2FsbGVlJykgIT09IC0xKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIElmIHlvdSBuZWVkIHRvIHN1cHBvcnQgU2FmYXJpIDUtNyAoOC0xMCB5ci1vbGQgYnJvd3NlciksXG4gKiB0YWtlIGEgbG9vayBhdCBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2lzLWJ1ZmZlclxuICovXG5cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICBpZiAodmFsLmNvbnN0cnVjdG9yICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgcHJpdmF0ZSBzdHJpbmcgdG8gaWRlbnRpZnkgc3RydWN0cyBieS5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5cbmNvbnN0IElTX1NUUlVDVCA9ICdAQF9fU1RSVUNUX19AQCc7XG5cbi8qKlxuICogQSBwcml2YXRlIHN0cmluZyB0byByZWZlciB0byBhIHN0cnVjdCdzIGtpbmQuXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuXG5jb25zdCBLSU5EID0gJ0BAX19LSU5EX19AQCc7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBgdmFsdWVgIGlzIGEgc3RydWN0LlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc1N0cnVjdCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbSVNfU1RSVUNUXSk7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBgZGVmYXVsdHNgLCBmb3IgYW4gb3B0aW9uYWwgYHZhbHVlYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufEFueX0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHJldHVybiB7QW55fVxuICovXG5cbmZ1bmN0aW9uIHJlc29sdmVEZWZhdWx0cyhkZWZhdWx0cywgdmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiBkZWZhdWx0cyA9PT0gJ2Z1bmN0aW9uJyA/IGRlZmF1bHRzKHZhbHVlKSA6IGRlZmF1bHRzO1xufVxuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBLaW5kLlxuICpcbiAqIEB0eXBlIHtLaW5kfVxuICovXG5cbmNsYXNzIEtpbmQge1xuICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCB2YWxpZGF0ZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4gIH1cbn1cblxuLyoqXG4gKiBBbnkuXG4gKlxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxPYmplY3R8U3RyaW5nfSBzY2hlbWFcbiAqIEBwYXJhbSB7QW55fSBkZWZhdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBhbnkoc2NoZW1hLCBkZWZhdWx0cyQkMSwgb3B0aW9ucykge1xuICBpZiAoaXNTdHJ1Y3Qoc2NoZW1hKSkge1xuICAgIHJldHVybiBzY2hlbWFbS0lORF07XG4gIH1cblxuICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgS2luZCkge1xuICAgIHJldHVybiBzY2hlbWE7XG4gIH1cblxuICBzd2l0Y2ggKGtpbmRPZihzY2hlbWEpKSB7XG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmxlbmd0aCA+IDEgPyB0dXBsZShzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSA6IGxpc3Qoc2NoZW1hLCBkZWZhdWx0cyQkMSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBmdW5jKHNjaGVtYSwgZGVmYXVsdHMkJDEsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdChzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICB7XG4gICAgICAgIGxldCByZXF1aXJlZCA9IHRydWU7XG4gICAgICAgIGxldCB0eXBlO1xuXG4gICAgICAgIGlmIChzY2hlbWEuZW5kc1dpdGgoJz8nKSkge1xuICAgICAgICAgIHJlcXVpcmVkID0gZmFsc2U7XG4gICAgICAgICAgc2NoZW1hID0gc2NoZW1hLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2hlbWEuaW5jbHVkZXMoJ3wnKSkge1xuICAgICAgICAgIGNvbnN0IHNjYWxhcnMgPSBzY2hlbWEuc3BsaXQoL1xccypcXHxcXHMqL2cpO1xuICAgICAgICAgIHR5cGUgPSB1bmlvbihzY2FsYXJzLCBkZWZhdWx0cyQkMSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2NoZW1hLmluY2x1ZGVzKCcmJykpIHtcbiAgICAgICAgICBjb25zdCBzY2FsYXJzID0gc2NoZW1hLnNwbGl0KC9cXHMqJlxccyovZyk7XG4gICAgICAgICAgdHlwZSA9IGludGVyc2VjdGlvbihzY2FsYXJzLCBkZWZhdWx0cyQkMSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHlwZSA9IHNjYWxhcihzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVxdWlyZWQpIHtcbiAgICAgICAgICB0eXBlID0gb3B0aW9uYWwodHlwZSwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBIHNjaGVtYSBkZWZpbml0aW9uIG11c3QgYmUgYW4gb2JqZWN0LCBhcnJheSwgc3RyaW5nIG9yIGZ1bmN0aW9uLCBidXQgeW91IHBhc3NlZDogJHtzY2hlbWF9YCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVtYTogJHtzY2hlbWF9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaWN0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNjaGVtYVxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGRpY3Qoc2NoZW1hLCBkZWZhdWx0cyQkMSwgb3B0aW9ucykge1xuICBpZiAoa2luZE9mKHNjaGVtYSkgIT09ICdhcnJheScgfHwgc2NoZW1hLmxlbmd0aCAhPT0gMikge1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaWN0IHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGFuIGFycmF5IHdpdGggdHdvIGVsZW1lbnRzLCBidXQgeW91IHBhc3NlZDogJHtzY2hlbWF9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzY2hlbWE6ICR7c2NoZW1hfWApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9iaiA9IHNjYWxhcignb2JqZWN0JywgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgY29uc3Qga2V5cyA9IGFueShzY2hlbWFbMF0sIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gIGNvbnN0IHZhbHVlcyA9IGFueShzY2hlbWFbMV0sIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gIGNvbnN0IG5hbWUgPSAnZGljdCc7XG4gIGNvbnN0IHR5cGUgPSBgZGljdDwke2tleXMudHlwZX0sJHt2YWx1ZXMudHlwZX0+YDtcbiAgY29uc3QgdmFsaWRhdGUgPSB2YWx1ZSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlRGVmYXVsdHMoZGVmYXVsdHMkJDEpO1xuICAgIHZhbHVlID0gcmVzb2x2ZWQgPyBfZXh0ZW5kcyh7fSwgcmVzb2x2ZWQsIHZhbHVlKSA6IHZhbHVlO1xuICAgIGNvbnN0IFtlcnJvcl0gPSBvYmoudmFsaWRhdGUodmFsdWUpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBlcnJvci50eXBlID0gdHlwZTtcbiAgICAgIHJldHVybiBbZXJyb3JdO1xuICAgIH1cblxuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuXG4gICAgZm9yIChsZXQgayBpbiB2YWx1ZSkge1xuICAgICAgY29uc3QgdiA9IHZhbHVlW2tdO1xuICAgICAgY29uc3QgW2UsIHJdID0ga2V5cy52YWxpZGF0ZShrKTtcblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgY29uc3QgYWxsRSA9IGUuZXJyb3JzIHx8IFtlXTtcbiAgICAgICAgYWxsRS5mb3JFYWNoKHNpbmdsZUUgPT4ge1xuICAgICAgICAgIHNpbmdsZUUucGF0aCA9IFtrXS5jb25jYXQoc2luZ2xlRS5wYXRoKTtcbiAgICAgICAgICBzaW5nbGVFLmRhdGEgPSB2YWx1ZTtcbiAgICAgICAgICBlcnJvcnMucHVzaChzaW5nbGVFKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBrID0gcjtcbiAgICAgIGNvbnN0IFtlMiwgcjJdID0gdmFsdWVzLnZhbGlkYXRlKHYpO1xuXG4gICAgICBpZiAoZTIpIHtcbiAgICAgICAgY29uc3QgYWxsRTIgPSBlMi5lcnJvcnMgfHwgW2UyXTtcbiAgICAgICAgYWxsRTIuZm9yRWFjaChzaW5nbGVFID0+IHtcbiAgICAgICAgICBzaW5nbGVFLnBhdGggPSBba10uY29uY2F0KHNpbmdsZUUucGF0aCk7XG4gICAgICAgICAgc2luZ2xlRS5kYXRhID0gdmFsdWU7XG4gICAgICAgICAgZXJyb3JzLnB1c2goc2luZ2xlRSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcmV0W2tdID0gcjI7XG4gICAgfVxuXG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gZXJyb3JzWzBdO1xuICAgICAgZmlyc3QuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgcmV0dXJuIFtmaXJzdF07XG4gICAgfVxuXG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHJldF07XG4gIH07XG5cbiAgcmV0dXJuIG5ldyBLaW5kKG5hbWUsIHR5cGUsIHZhbGlkYXRlKTtcbn1cblxuLyoqXG4gKiBFbnVtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNjaGVtYVxuICogQHBhcmFtIHtBbnl9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGVuKHNjaGVtYSwgZGVmYXVsdHMkJDEsIG9wdGlvbnMpIHtcbiAgaWYgKGtpbmRPZihzY2hlbWEpICE9PSAnYXJyYXknKSB7XG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVudW0gc3RydWN0cyBtdXN0IGJlIGRlZmluZWQgYXMgYW4gYXJyYXksIGJ1dCB5b3UgcGFzc2VkOiAke3NjaGVtYX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVtYTogJHtzY2hlbWF9YCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbmFtZSA9ICdlbnVtJztcbiAgY29uc3QgdHlwZSA9IHNjaGVtYS5tYXAocyA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHMpO1xuICAgIH1cbiAgfSkuam9pbignIHwgJyk7XG5cbiAgY29uc3QgdmFsaWRhdGUgPSAodmFsdWUgPSByZXNvbHZlRGVmYXVsdHMoZGVmYXVsdHMkJDEpKSA9PiB7XG4gICAgcmV0dXJuIHNjaGVtYS5pbmNsdWRlcyh2YWx1ZSkgPyBbdW5kZWZpbmVkLCB2YWx1ZV0gOiBbeyBkYXRhOiB2YWx1ZSwgcGF0aDogW10sIHZhbHVlLCB0eXBlIH1dO1xuICB9O1xuXG4gIHJldHVybiBuZXcgS2luZChuYW1lLCB0eXBlLCB2YWxpZGF0ZSk7XG59XG5cbi8qKlxuICogRW51bXMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2NoZW1hXG4gKiBAcGFyYW0ge0FueX0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gZW51bXMoc2NoZW1hLCBkZWZhdWx0cyQkMSwgb3B0aW9ucykge1xuICBjb25zdCBlID0gZW4oc2NoZW1hLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICBjb25zdCBsID0gbGlzdChbZV0sIGRlZmF1bHRzJCQxLCBvcHRpb25zKTtcbiAgcmV0dXJuIGw7XG59XG5cbi8qKlxuICogRnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2NoZW1hXG4gKiBAcGFyYW0ge0FueX0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gZnVuYyhzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGdW5jdGlvbiBzdHJ1Y3RzIG11c3QgYmUgZGVmaW5lZCBhcyBhIGZ1bmN0aW9uLCBidXQgeW91IHBhc3NlZDogJHtzY2hlbWF9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzY2hlbWE6ICR7c2NoZW1hfWApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG5hbWUgPSAnZnVuY3Rpb24nO1xuICBjb25zdCB0eXBlID0gJzxmdW5jdGlvbj4nO1xuICBjb25zdCB2YWxpZGF0ZSA9ICh2YWx1ZSA9IHJlc29sdmVEZWZhdWx0cyhkZWZhdWx0cyQkMSksIGRhdGEpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEodmFsdWUsIGRhdGEpO1xuICAgIGxldCBmYWlsdXJlID0geyBwYXRoOiBbXSwgcmVhc29uOiBudWxsIH07XG4gICAgbGV0IGlzVmFsaWQ7XG5cbiAgICBzd2l0Y2ggKGtpbmRPZihyZXN1bHQpKSB7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAge1xuICAgICAgICAgIGlzVmFsaWQgPSByZXN1bHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHtcbiAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgZmFpbHVyZS5yZWFzb24gPSByZXN1bHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHtcbiAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgZmFpbHVyZSA9IF9leHRlbmRzKHt9LCBmYWlsdXJlLCByZXN1bHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbGlkYXRvciBmdW5jdGlvbnMgbXVzdCByZXR1cm4gYSBib29sZWFuLCBhbiBlcnJvciByZWFzb24gc3RyaW5nIG9yIGFuIGVycm9yIHJlYXNvbiBvYmplY3QsIGJ1dCB5b3UgcGFzc2VkOiAke3NjaGVtYX1gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJlc3VsdDogJHtyZXN1bHR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzVmFsaWQgPyBbdW5kZWZpbmVkLCB2YWx1ZV0gOiBbX2V4dGVuZHMoeyB0eXBlLCB2YWx1ZSwgZGF0YTogdmFsdWUgfSwgZmFpbHVyZSldO1xuICB9O1xuXG4gIHJldHVybiBuZXcgS2luZChuYW1lLCB0eXBlLCB2YWxpZGF0ZSk7XG59XG5cbi8qKlxuICogSW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2NoZW1hXG4gKiBAcGFyYW0ge0FueX0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gaW5zdGFuY2Uoc2NoZW1hLCBkZWZhdWx0cyQkMSwgb3B0aW9ucykge1xuICBjb25zdCBuYW1lID0gJ2luc3RhbmNlJztcbiAgY29uc3QgdHlwZSA9IGBpbnN0YW5jZTwke3NjaGVtYS5uYW1lfT5gO1xuICBjb25zdCB2YWxpZGF0ZSA9ICh2YWx1ZSA9IHJlc29sdmVEZWZhdWx0cyhkZWZhdWx0cyQkMSkpID0+IHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBzY2hlbWEgPyBbdW5kZWZpbmVkLCB2YWx1ZV0gOiBbeyBkYXRhOiB2YWx1ZSwgcGF0aDogW10sIHZhbHVlLCB0eXBlIH1dO1xuICB9O1xuXG4gIHJldHVybiBuZXcgS2luZChuYW1lLCB0eXBlLCB2YWxpZGF0ZSk7XG59XG5cbi8qKlxuICogSW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBpbnRlcihzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJmYWNlIHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGFuIG9iamVjdCwgYnV0IHlvdSBwYXNzZWQ6ICR7c2NoZW1hfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2NoZW1hOiAke3NjaGVtYX1gKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBrcyA9IFtdO1xuICBjb25zdCBwcm9wZXJ0aWVzID0ge307XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAga3MucHVzaChrZXkpO1xuICAgIGNvbnN0IHMgPSBzY2hlbWFba2V5XTtcbiAgICBjb25zdCBraW5kID0gYW55KHMsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgcHJvcGVydGllc1trZXldID0ga2luZDtcbiAgfVxuXG4gIGNvbnN0IG5hbWUgPSAnaW50ZXJmYWNlJztcbiAgY29uc3QgdHlwZSA9IGB7JHtrcy5qb2luKCl9fWA7XG4gIGNvbnN0IHZhbGlkYXRlID0gdmFsdWUgPT4ge1xuICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZURlZmF1bHRzKGRlZmF1bHRzJCQxKTtcbiAgICB2YWx1ZSA9IHJlc29sdmVkID8gX2V4dGVuZHMoe30sIHJlc29sdmVkLCB2YWx1ZSkgOiB2YWx1ZTtcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCByZXQgPSB2YWx1ZTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgIGxldCB2ID0gdmFsdWVba2V5XTtcbiAgICAgIGNvbnN0IGtpbmQgPSBwcm9wZXJ0aWVzW2tleV07XG5cbiAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZCA9IGRlZmF1bHRzJCQxICYmIGRlZmF1bHRzJCQxW2tleV07XG4gICAgICAgIHYgPSByZXNvbHZlRGVmYXVsdHMoZCwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBbZSwgcl0gPSBraW5kLnZhbGlkYXRlKHYsIHZhbHVlKTtcblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgY29uc3QgYWxsRSA9IGUuZXJyb3JzIHx8IFtlXTtcbiAgICAgICAgYWxsRS5mb3JFYWNoKHNpbmdsZUUgPT4ge1xuICAgICAgICAgIHNpbmdsZUUucGF0aCA9IFtrZXldLmNvbmNhdChzaW5nbGVFLnBhdGgpO1xuICAgICAgICAgIHNpbmdsZUUuZGF0YSA9IHZhbHVlO1xuICAgICAgICAgIGVycm9ycy5wdXNoKHNpbmdsZUUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgaW4gdmFsdWUgfHwgciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldFtrZXldID0gcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgY29uc3QgZmlyc3QgPSBlcnJvcnNbMF07XG4gICAgICBmaXJzdC5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICByZXR1cm4gW2ZpcnN0XTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgcmV0XTtcbiAgfTtcblxuICByZXR1cm4gbmV3IEtpbmQobmFtZSwgdHlwZSwgdmFsaWRhdGUpO1xufVxuXG4vKipcbiAqIExhenkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2NoZW1hXG4gKiBAcGFyYW0ge0FueX0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gbGF6eShzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBMYXp5IHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGFuIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNjaGVtYSwgYnV0IHlvdSBwYXNzZWQ6ICR7c2NoZW1hfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2NoZW1hOiAke3NjaGVtYX1gKTtcbiAgICB9XG4gIH1cblxuICBsZXQga2luZDtcbiAgbGV0IHN0cnVjdDtcbiAgY29uc3QgbmFtZSA9ICdsYXp5JztcbiAgY29uc3QgdHlwZSA9IGBsYXp5Li4uYDtcbiAgY29uc3QgY29tcGlsZSA9IHZhbHVlID0+IHtcbiAgICBzdHJ1Y3QgPSBzY2hlbWEoKTtcbiAgICBraW5kLm5hbWUgPSBzdHJ1Y3Qua2luZDtcbiAgICBraW5kLnR5cGUgPSBzdHJ1Y3QudHlwZTtcbiAgICBraW5kLnZhbGlkYXRlID0gc3RydWN0LnZhbGlkYXRlO1xuICAgIHJldHVybiBraW5kLnZhbGlkYXRlKHZhbHVlKTtcbiAgfTtcblxuICBraW5kID0gbmV3IEtpbmQobmFtZSwgdHlwZSwgY29tcGlsZSk7XG4gIHJldHVybiBraW5kO1xufVxuXG4vKipcbiAqIER5bmFtaWMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3JlYXRlU2NoZW1hXG4gKiBAcGFyYW0ge0FueX0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gZHluYW1pYyhjcmVhdGVTY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2YoY3JlYXRlU2NoZW1hKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEeW5hbWljIHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGEgZnVuY3Rpb24sIGJ1dCB5b3UgcGFzc2VkOiAke2NyZWF0ZVNjaGVtYX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVtYTogJHtjcmVhdGVTY2hlbWF9YCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbmFtZSA9ICdkeW5hbWljJztcbiAgY29uc3QgdHlwZSA9ICdkeW5hbWljLi4uJztcbiAgY29uc3QgdmFsaWRhdGUgPSAodmFsdWUgPSByZXNvbHZlRGVmYXVsdHMoZGVmYXVsdHMkJDEpLCBkYXRhKSA9PiB7XG4gICAgY29uc3Qgc2NoZW1hID0gY3JlYXRlU2NoZW1hKHZhbHVlLCBkYXRhKTtcblxuICAgIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRHluYW1pYyBzdHJ1Y3RzIG11c3QgcmV0dXJuIGEgc2NoZW1hLCBidXQgeW91IHBhc3NlZDogJHtzY2hlbWF9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2NoZW1hOiAke3NjaGVtYX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBbZXJyb3IsIHJlc3VsdF0gPSBzY2hlbWEudmFsaWRhdGUodmFsdWUpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gW2Vycm9yXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgcmVzdWx0XTtcbiAgfTtcblxuICByZXR1cm4gbmV3IEtpbmQobmFtZSwgdHlwZSwgdmFsaWRhdGUpO1xufVxuXG4vKipcbiAqIExpc3QuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2NoZW1hXG4gKiBAcGFyYW0ge0FycmF5fSBkZWZhdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBsaXN0KHNjaGVtYSwgZGVmYXVsdHMkJDEsIG9wdGlvbnMpIHtcbiAgaWYgKGtpbmRPZihzY2hlbWEpICE9PSAnYXJyYXknIHx8IHNjaGVtYS5sZW5ndGggIT09IDEpIHtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTGlzdCBzdHJ1Y3RzIG11c3QgYmUgZGVmaW5lZCBhcyBhbiBhcnJheSB3aXRoIGEgc2luZ2xlIGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkOiAke3NjaGVtYX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVtYTogJHtzY2hlbWF9YCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYXJyYXkgPSBzY2FsYXIoJ2FycmF5JywgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgY29uc3QgZWxlbWVudCA9IGFueShzY2hlbWFbMF0sIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gIGNvbnN0IG5hbWUgPSAnbGlzdCc7XG4gIGNvbnN0IHR5cGUgPSBgWyR7ZWxlbWVudC50eXBlfV1gO1xuICBjb25zdCB2YWxpZGF0ZSA9ICh2YWx1ZSA9IHJlc29sdmVEZWZhdWx0cyhkZWZhdWx0cyQkMSkpID0+IHtcbiAgICBjb25zdCBbZXJyb3IsIHJlc3VsdF0gPSBhcnJheS52YWxpZGF0ZSh2YWx1ZSk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGVycm9yLnR5cGUgPSB0eXBlO1xuICAgICAgcmV0dXJuIFtlcnJvcl07XG4gICAgfVxuXG4gICAgdmFsdWUgPSByZXN1bHQ7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3QgcmV0ID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2ID0gdmFsdWVbaV07XG4gICAgICBjb25zdCBbZSwgcl0gPSBlbGVtZW50LnZhbGlkYXRlKHYpO1xuXG4gICAgICBpZiAoZSkge1xuICAgICAgICBjb25zdCBhbGxFID0gZS5lcnJvcnMgfHwgW2VdO1xuICAgICAgICBhbGxFLmZvckVhY2goc2luZ2xlRSA9PiB7XG4gICAgICAgICAgc2luZ2xlRS5wYXRoID0gW2ldLmNvbmNhdChzaW5nbGVFLnBhdGgpO1xuICAgICAgICAgIHNpbmdsZUUuZGF0YSA9IHZhbHVlO1xuICAgICAgICAgIGVycm9ycy5wdXNoKHNpbmdsZUUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJldFtpXSA9IHI7XG4gICAgfVxuXG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gZXJyb3JzWzBdO1xuICAgICAgZmlyc3QuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgcmV0dXJuIFtmaXJzdF07XG4gICAgfVxuXG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHJldF07XG4gIH07XG5cbiAgcmV0dXJuIG5ldyBLaW5kKG5hbWUsIHR5cGUsIHZhbGlkYXRlKTtcbn1cblxuLyoqXG4gKiBMaXRlcmFsLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNjaGVtYVxuICogQHBhcmFtIHtBbnl9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGxpdGVyYWwoc2NoZW1hLCBkZWZhdWx0cyQkMSwgb3B0aW9ucykge1xuICBjb25zdCBuYW1lID0gJ2xpdGVyYWwnO1xuICBjb25zdCB0eXBlID0gYGxpdGVyYWw6ICR7SlNPTi5zdHJpbmdpZnkoc2NoZW1hKX1gO1xuICBjb25zdCB2YWxpZGF0ZSA9ICh2YWx1ZSA9IHJlc29sdmVEZWZhdWx0cyhkZWZhdWx0cyQkMSkpID0+IHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHNjaGVtYSA/IFt1bmRlZmluZWQsIHZhbHVlXSA6IFt7IGRhdGE6IHZhbHVlLCBwYXRoOiBbXSwgdmFsdWUsIHR5cGUgfV07XG4gIH07XG5cbiAgcmV0dXJuIG5ldyBLaW5kKG5hbWUsIHR5cGUsIHZhbGlkYXRlKTtcbn1cblxuLyoqXG4gKiBPYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNjaGVtYVxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIG9iamVjdChzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGFuIG9iamVjdCwgYnV0IHlvdSBwYXNzZWQ6ICR7c2NoZW1hfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2NoZW1hOiAke3NjaGVtYX1gKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBvYmogPSBzY2FsYXIoJ29iamVjdCcsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gIGNvbnN0IGtzID0gW107XG4gIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICBrcy5wdXNoKGtleSk7XG4gICAgY29uc3QgcyA9IHNjaGVtYVtrZXldO1xuICAgIGNvbnN0IGtpbmQgPSBhbnkocywgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICBwcm9wZXJ0aWVzW2tleV0gPSBraW5kO1xuICB9XG5cbiAgY29uc3QgbmFtZSA9ICdvYmplY3QnO1xuICBjb25zdCB0eXBlID0gYHske2tzLmpvaW4oKX19YDtcbiAgY29uc3QgdmFsaWRhdGUgPSAodmFsdWUgPSByZXNvbHZlRGVmYXVsdHMoZGVmYXVsdHMkJDEpKSA9PiB7XG4gICAgY29uc3QgW2Vycm9yXSA9IG9iai52YWxpZGF0ZSh2YWx1ZSk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGVycm9yLnR5cGUgPSB0eXBlO1xuICAgICAgcmV0dXJuIFtlcnJvcl07XG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgY29uc3QgdmFsdWVLZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgIGNvbnN0IHByb3BlcnRpZXNLZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyk7XG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQodmFsdWVLZXlzLmNvbmNhdChwcm9wZXJ0aWVzS2V5cykpO1xuXG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBsZXQgdiA9IHZhbHVlW2tleV07XG4gICAgICBjb25zdCBraW5kID0gcHJvcGVydGllc1trZXldO1xuXG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGQgPSBkZWZhdWx0cyQkMSAmJiBkZWZhdWx0cyQkMVtrZXldO1xuICAgICAgICB2ID0gcmVzb2x2ZURlZmF1bHRzKGQsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFraW5kKSB7XG4gICAgICAgIGNvbnN0IGUgPSB7IGRhdGE6IHZhbHVlLCBwYXRoOiBba2V5XSwgdmFsdWU6IHYgfTtcbiAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgW2UsIHJdID0ga2luZC52YWxpZGF0ZSh2LCB2YWx1ZSk7XG5cbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGNvbnN0IGFsbEUgPSBlLmVycm9ycyB8fCBbZV07XG4gICAgICAgIGFsbEUuZm9yRWFjaChzaW5nbGVFID0+IHtcbiAgICAgICAgICBzaW5nbGVFLnBhdGggPSBba2V5XS5jb25jYXQoc2luZ2xlRS5wYXRoKTtcbiAgICAgICAgICBzaW5nbGVFLmRhdGEgPSB2YWx1ZTtcbiAgICAgICAgICBlcnJvcnMucHVzaChzaW5nbGVFKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSBpbiB2YWx1ZSB8fCByICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0W2tleV0gPSByO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gZXJyb3JzWzBdO1xuICAgICAgZmlyc3QuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgcmV0dXJuIFtmaXJzdF07XG4gICAgfVxuXG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHJldF07XG4gIH07XG5cbiAgcmV0dXJuIG5ldyBLaW5kKG5hbWUsIHR5cGUsIHZhbGlkYXRlKTtcbn1cblxuLyoqXG4gKiBPcHRpb25hbC5cbiAqXG4gKiBAcGFyYW0ge0FueX0gc2NoZW1hXG4gKiBAcGFyYW0ge0FueX0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gb3B0aW9uYWwoc2NoZW1hLCBkZWZhdWx0cyQkMSwgb3B0aW9ucykge1xuICByZXR1cm4gdW5pb24oW3NjaGVtYSwgJ3VuZGVmaW5lZCddLCBkZWZhdWx0cyQkMSwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogUGFydGlhbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gcGFydGlhbChzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUGFydGlhbCBzdHJ1Y3RzIG11c3QgYmUgZGVmaW5lZCBhcyBhbiBvYmplY3QsIGJ1dCB5b3UgcGFzc2VkOiAke3NjaGVtYX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVtYTogJHtzY2hlbWF9YCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgb2JqID0gc2NhbGFyKCdvYmplY3QnLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICBjb25zdCBrcyA9IFtdO1xuICBjb25zdCBwcm9wZXJ0aWVzID0ge307XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAga3MucHVzaChrZXkpO1xuICAgIGNvbnN0IHMgPSBzY2hlbWFba2V5XTtcbiAgICBjb25zdCBraW5kID0gYW55KHMsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgcHJvcGVydGllc1trZXldID0ga2luZDtcbiAgfVxuXG4gIGNvbnN0IG5hbWUgPSAncGFydGlhbCc7XG4gIGNvbnN0IHR5cGUgPSBgeyR7a3Muam9pbigpfSwuLi59YDtcbiAgY29uc3QgdmFsaWRhdGUgPSAodmFsdWUgPSByZXNvbHZlRGVmYXVsdHMoZGVmYXVsdHMkJDEpKSA9PiB7XG4gICAgY29uc3QgW2Vycm9yXSA9IG9iai52YWxpZGF0ZSh2YWx1ZSk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGVycm9yLnR5cGUgPSB0eXBlO1xuICAgICAgcmV0dXJuIFtlcnJvcl07XG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3QgcmV0ID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBsZXQgdiA9IHZhbHVlW2tleV07XG4gICAgICBjb25zdCBraW5kID0gcHJvcGVydGllc1trZXldO1xuXG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGQgPSBkZWZhdWx0cyQkMSAmJiBkZWZhdWx0cyQkMVtrZXldO1xuICAgICAgICB2ID0gcmVzb2x2ZURlZmF1bHRzKGQsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgW2UsIHJdID0ga2luZC52YWxpZGF0ZSh2LCB2YWx1ZSk7XG5cbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGNvbnN0IGFsbEUgPSBlLmVycm9ycyB8fCBbZV07XG4gICAgICAgIGFsbEUuZm9yRWFjaChzaW5nbGVFID0+IHtcbiAgICAgICAgICBzaW5nbGVFLnBhdGggPSBba2V5XS5jb25jYXQoc2luZ2xlRS5wYXRoKTtcbiAgICAgICAgICBzaW5nbGVFLmRhdGEgPSB2YWx1ZTtcbiAgICAgICAgICBlcnJvcnMucHVzaChzaW5nbGVFKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5IGluIHZhbHVlIHx8IHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXRba2V5XSA9IHI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gZXJyb3JzWzBdO1xuICAgICAgZmlyc3QuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgcmV0dXJuIFtmaXJzdF07XG4gICAgfVxuXG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHJldF07XG4gIH07XG5cbiAgcmV0dXJuIG5ldyBLaW5kKG5hbWUsIHR5cGUsIHZhbGlkYXRlKTtcbn1cblxuLyoqXG4gKiBTY2FsYXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNjaGVtYVxuICogQHBhcmFtIHtBbnl9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIHNjYWxhcihzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ3N0cmluZycpIHtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU2NhbGFyIHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGEgc3RyaW5nLCBidXQgeW91IHBhc3NlZDogJHtzY2hlbWF9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzY2hlbWE6ICR7c2NoZW1hfWApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHsgdHlwZXMgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGZuID0gdHlwZXNbc2NoZW1hXTtcblxuICBpZiAoa2luZE9mKGZuKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdHJ1Y3QgdmFsaWRhdG9yIGZ1bmN0aW9uIGZvdW5kIGZvciB0eXBlIFwiJHtzY2hlbWF9XCIuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0eXBlOiAke3NjaGVtYX1gKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBraW5kID0gZnVuYyhmbiwgZGVmYXVsdHMkJDEsIG9wdGlvbnMpO1xuICBjb25zdCBuYW1lID0gJ3NjYWxhcic7XG4gIGNvbnN0IHR5cGUgPSBzY2hlbWE7XG4gIGNvbnN0IHZhbGlkYXRlID0gdmFsdWUgPT4ge1xuICAgIGNvbnN0IFtlcnJvciwgcmVzdWx0XSA9IGtpbmQudmFsaWRhdGUodmFsdWUpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBlcnJvci50eXBlID0gdHlwZTtcbiAgICAgIHJldHVybiBbZXJyb3JdO1xuICAgIH1cblxuICAgIHJldHVybiBbdW5kZWZpbmVkLCByZXN1bHRdO1xuICB9O1xuXG4gIHJldHVybiBuZXcgS2luZChuYW1lLCB0eXBlLCB2YWxpZGF0ZSk7XG59XG5cbi8qKlxuICogVHVwbGUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2NoZW1hXG4gKiBAcGFyYW0ge0FycmF5fSBkZWZhdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiB0dXBsZShzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ2FycmF5Jykge1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUdXBsZSBzdHJ1Y3RzIG11c3QgYmUgZGVmaW5lZCBhcyBhbiBhcnJheSwgYnV0IHlvdSBwYXNzZWQ6ICR7c2NoZW1hfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2NoZW1hOiAke3NjaGVtYX1gKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBraW5kcyA9IHNjaGVtYS5tYXAocyA9PiBhbnkocywgdW5kZWZpbmVkLCBvcHRpb25zKSk7XG4gIGNvbnN0IGFycmF5ID0gc2NhbGFyKCdhcnJheScsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gIGNvbnN0IG5hbWUgPSAndHVwbGUnO1xuICBjb25zdCB0eXBlID0gYFske2tpbmRzLm1hcChrID0+IGsudHlwZSkuam9pbigpfV1gO1xuICBjb25zdCB2YWxpZGF0ZSA9ICh2YWx1ZSA9IHJlc29sdmVEZWZhdWx0cyhkZWZhdWx0cyQkMSkpID0+IHtcbiAgICBjb25zdCBbZXJyb3JdID0gYXJyYXkudmFsaWRhdGUodmFsdWUpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBlcnJvci50eXBlID0gdHlwZTtcbiAgICAgIHJldHVybiBbZXJyb3JdO1xuICAgIH1cblxuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KHZhbHVlLmxlbmd0aCwga2luZHMubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtpbmQgPSBraW5kc1tpXTtcbiAgICAgIGNvbnN0IHYgPSB2YWx1ZVtpXTtcblxuICAgICAgaWYgKCFraW5kKSB7XG4gICAgICAgIGNvbnN0IGUgPSB7IGRhdGE6IHZhbHVlLCBwYXRoOiBbaV0sIHZhbHVlOiB2IH07XG4gICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgW2UsIHJdID0ga2luZC52YWxpZGF0ZSh2KTtcblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgY29uc3QgYWxsRSA9IGUuZXJyb3JzIHx8IFtlXTtcbiAgICAgICAgYWxsRS5mb3JFYWNoKHNpbmdsZUUgPT4ge1xuICAgICAgICAgIHNpbmdsZUUucGF0aCA9IFtpXS5jb25jYXQoc2luZ2xlRS5wYXRoKTtcbiAgICAgICAgICBzaW5nbGVFLmRhdGEgPSB2YWx1ZTtcbiAgICAgICAgICBlcnJvcnMucHVzaChzaW5nbGVFKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZXRbaV0gPSByO1xuICAgIH1cblxuICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBmaXJzdCA9IGVycm9yc1swXTtcbiAgICAgIGZpcnN0LmVycm9ycyA9IGVycm9ycztcbiAgICAgIHJldHVybiBbZmlyc3RdO1xuICAgIH1cblxuICAgIHJldHVybiBbdW5kZWZpbmVkLCByZXRdO1xuICB9O1xuXG4gIHJldHVybiBuZXcgS2luZChuYW1lLCB0eXBlLCB2YWxpZGF0ZSk7XG59XG5cbi8qKlxuICogVW5pb24uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2NoZW1hXG4gKiBAcGFyYW0ge0FueX0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gdW5pb24oc2NoZW1hLCBkZWZhdWx0cyQkMSwgb3B0aW9ucykge1xuICBpZiAoa2luZE9mKHNjaGVtYSkgIT09ICdhcnJheScpIHtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5pb24gc3RydWN0cyBtdXN0IGJlIGRlZmluZWQgYXMgYW4gYXJyYXksIGJ1dCB5b3UgcGFzc2VkOiAke3NjaGVtYX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVtYTogJHtzY2hlbWF9YCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qga2luZHMgPSBzY2hlbWEubWFwKHMgPT4gYW55KHMsIHVuZGVmaW5lZCwgb3B0aW9ucykpO1xuICBjb25zdCBuYW1lID0gJ3VuaW9uJztcbiAgY29uc3QgdHlwZSA9IGtpbmRzLm1hcChrID0+IGsudHlwZSkuam9pbignIHwgJyk7XG4gIGNvbnN0IHZhbGlkYXRlID0gKHZhbHVlID0gcmVzb2x2ZURlZmF1bHRzKGRlZmF1bHRzJCQxKSkgPT4ge1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBrIG9mIGtpbmRzKSB7XG4gICAgICBjb25zdCBbZSwgcl0gPSBrLnZhbGlkYXRlKHZhbHVlKTtcblxuICAgICAgaWYgKCFlKSB7XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCByXTtcbiAgICAgIH1cblxuICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgfVxuICAgIGVycm9yc1swXS50eXBlID0gdHlwZTtcbiAgICByZXR1cm4gZXJyb3JzO1xuICB9O1xuXG4gIHJldHVybiBuZXcgS2luZChuYW1lLCB0eXBlLCB2YWxpZGF0ZSk7XG59XG5cbi8qKlxuICogSW50ZXJzZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNjaGVtYVxuICogQHBhcmFtIHtBbnl9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvbihzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ2FycmF5Jykge1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcnNlY3Rpb24gc3RydWN0cyBtdXN0IGJlIGRlZmluZWQgYXMgYW4gYXJyYXksIGJ1dCB5b3UgcGFzc2VkOiAke3NjaGVtYX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVtYTogJHtzY2hlbWF9YCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdHlwZXMgPSBzY2hlbWEubWFwKHMgPT4gYW55KHMsIHVuZGVmaW5lZCwgb3B0aW9ucykpO1xuICBjb25zdCBuYW1lID0gJ2ludGVyc2VjdGlvbic7XG4gIGNvbnN0IHR5cGUgPSB0eXBlcy5tYXAodCA9PiB0LnR5cGUpLmpvaW4oJyAmICcpO1xuICBjb25zdCB2YWxpZGF0ZSA9ICh2YWx1ZSA9IHJlc29sdmVEZWZhdWx0cyhkZWZhdWx0cyQkMSkpID0+IHtcbiAgICBsZXQgdiA9IHZhbHVlO1xuXG4gICAgZm9yIChjb25zdCB0IG9mIHR5cGVzKSB7XG4gICAgICBjb25zdCBbZSwgcl0gPSB0LnZhbGlkYXRlKHYpO1xuXG4gICAgICBpZiAoZSkge1xuICAgICAgICBlLnR5cGUgPSB0eXBlO1xuICAgICAgICByZXR1cm4gW2VdO1xuICAgICAgfVxuXG4gICAgICB2ID0gcjtcbiAgICB9XG5cbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgdl07XG4gIH07XG5cbiAgcmV0dXJuIG5ldyBLaW5kKG5hbWUsIHR5cGUsIHZhbGlkYXRlKTtcbn1cblxuLyoqXG4gKiBLaW5kcy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbmNvbnN0IEtpbmRzID0ge1xuICBhbnksXG4gIGRpY3QsXG4gIGVudW06IGVuLFxuICBlbnVtcyxcbiAgZnVuY3Rpb246IGZ1bmMsXG4gIGluc3RhbmNlLFxuICBpbnRlcmZhY2U6IGludGVyLFxuICBsYXp5LFxuICBsaXN0LFxuICBsaXRlcmFsLFxuICBvYmplY3QsXG4gIG9wdGlvbmFsLFxuICBwYXJ0aWFsLFxuICBzY2FsYXIsXG4gIHR1cGxlLFxuICB1bmlvbixcbiAgaW50ZXJzZWN0aW9uLFxuICBkeW5hbWljXG5cbiAgLyoqXG4gICAqIEV4cG9ydC5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbn07XG5cbi8qKlxuICogVGhlIHR5cGVzIHRoYXQgYGtpbmQtb2ZgIHN1cHBvcnRzLlxuICpcbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuXG5jb25zdCBUWVBFUyA9IFsnYXJndW1lbnRzJywgJ2FycmF5JywgJ2Jvb2xlYW4nLCAnYnVmZmVyJywgJ2Vycm9yJywgJ2Zsb2F0MzJhcnJheScsICdmbG9hdDY0YXJyYXknLCAnZnVuY3Rpb24nLCAnZ2VuZXJhdG9yZnVuY3Rpb24nLCAnaW50MTZhcnJheScsICdpbnQzMmFycmF5JywgJ2ludDhhcnJheScsICdtYXAnLCAnbnVsbCcsICdudW1iZXInLCAnb2JqZWN0JywgJ3Byb21pc2UnLCAncmVnZXhwJywgJ3NldCcsICdzdHJpbmcnLCAnc3ltYm9sJywgJ3VpbnQxNmFycmF5JywgJ3VpbnQzMmFycmF5JywgJ3VpbnQ4YXJyYXknLCAndWludDhjbGFtcGVkYXJyYXknLCAndW5kZWZpbmVkJywgJ3dlYWttYXAnLCAnd2Vha3NldCddO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHR5cGVzIHRoYXQgU3VwZXJzdHJ1Y3Qgc2hpcHMgd2l0aC5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbmNvbnN0IFR5cGVzID0ge1xuICBhbnk6IHZhbHVlID0+IHZhbHVlICE9PSB1bmRlZmluZWRcbn07XG5cblRZUEVTLmZvckVhY2godHlwZSA9PiB7XG4gIFR5cGVzW3R5cGVdID0gdmFsdWUgPT4ga2luZE9mKHZhbHVlKSA9PT0gdHlwZTtcbn0pO1xuXG4vKipcbiAqIEhhbmRsZSB0aGUgJ2RhdGUnIGNhc2Ugc3BlY2lhbGx5LCB0byB0aHJvdyBvdXQgaW52YWxpZCBgRGF0ZWAgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5UeXBlcy5kYXRlID0gdmFsdWUgPT4ga2luZE9mKHZhbHVlKSA9PT0gJ2RhdGUnICYmICFpc05hTih2YWx1ZSk7XG5cbi8qKlxuICogQ3JlYXRlIGEgc3RydWN0IGZhY3Rvcnkgd2l0aCBhIGBjb25maWdgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIHN1cGVyc3RydWN0KGNvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IHR5cGVzID0gX2V4dGVuZHMoe30sIFR5cGVzLCBjb25maWcudHlwZXMgfHwge30pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBga2luZGAgc3RydWN0IHdpdGggYHNjaGVtYWAsIGBkZWZhdWx0c2AgYW5kIGBvcHRpb25zYC5cbiAgICpcbiAgICogQHBhcmFtIHtBbnl9IHNjaGVtYVxuICAgKiBAcGFyYW0ge0FueX0gZGVmYXVsdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHN0cnVjdChzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoaXNTdHJ1Y3Qoc2NoZW1hKSkge1xuICAgICAgc2NoZW1hID0gc2NoZW1hLnNjaGVtYTtcbiAgICB9XG5cbiAgICBjb25zdCBraW5kID0gS2luZHMuYW55KHNjaGVtYSwgZGVmYXVsdHMkJDEsIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7IHR5cGVzIH0pKTtcblxuICAgIGZ1bmN0aW9uIFN0cnVjdChkYXRhKSB7XG4gICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFN0cnVjdCkge1xuICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgU3RydWN0YCBjcmVhdGlvbiBmdW5jdGlvbiBzaG91bGQgbm90IGJlIHVzZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYG5ld2Aga2V5d29yZCEnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gU3RydWN0LmFzc2VydChkYXRhKTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RydWN0LCBJU19TVFJVQ1QsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cnVjdCwgS0lORCwgeyB2YWx1ZToga2luZCB9KTtcblxuICAgIFN0cnVjdC5raW5kID0ga2luZC5uYW1lO1xuICAgIFN0cnVjdC50eXBlID0ga2luZC50eXBlO1xuICAgIFN0cnVjdC5zY2hlbWEgPSBzY2hlbWE7XG4gICAgU3RydWN0LmRlZmF1bHRzID0gZGVmYXVsdHMkJDE7XG4gICAgU3RydWN0Lm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgU3RydWN0LmFzc2VydCA9IHZhbHVlID0+IHtcbiAgICAgIGNvbnN0IFtlcnJvciwgcmVzdWx0XSA9IGtpbmQudmFsaWRhdGUodmFsdWUpO1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0cnVjdEVycm9yKGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgU3RydWN0LnRlc3QgPSB2YWx1ZSA9PiB7XG4gICAgICBjb25zdCBbZXJyb3JdID0ga2luZC52YWxpZGF0ZSh2YWx1ZSk7XG4gICAgICByZXR1cm4gIWVycm9yO1xuICAgIH07XG5cbiAgICBTdHJ1Y3QudmFsaWRhdGUgPSB2YWx1ZSA9PiB7XG4gICAgICBjb25zdCBbZXJyb3IsIHJlc3VsdF0gPSBraW5kLnZhbGlkYXRlKHZhbHVlKTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFN0cnVjdEVycm9yKGVycm9yKV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbdW5kZWZpbmVkLCByZXN1bHRdO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3RydWN0O1xuICB9XG5cbiAgLyoqXG4gICAqIE1peCBpbiBhIGZhY3RvcnkgZm9yIGVhY2ggc3BlY2lmaWMga2luZCBvZiBzdHJ1Y3QuXG4gICAqL1xuXG4gIE9iamVjdC5rZXlzKEtpbmRzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIGNvbnN0IGtpbmQgPSBLaW5kc1tuYW1lXTtcblxuICAgIHN0cnVjdFtuYW1lXSA9IChzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCB0eXBlID0ga2luZChzY2hlbWEsIGRlZmF1bHRzJCQxLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywgeyB0eXBlcyB9KSk7XG4gICAgICBjb25zdCBzID0gc3RydWN0KHR5cGUsIGRlZmF1bHRzJCQxLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBzO1xuICAgIH07XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHN0cnVjdCBmYWN0b3J5LlxuICAgKi9cblxuICByZXR1cm4gc3RydWN0O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNvbnZlbmllbmNlIGBzdHJ1Y3RgIGZhY3RvcnkgZm9yIHRoZSBkZWZhdWx0IHR5cGVzLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xuXG5jb25zdCBzdHJ1Y3QgPSBzdXBlcnN0cnVjdCgpO1xuXG5leHBvcnRzLnN0cnVjdCA9IHN0cnVjdDtcbmV4cG9ydHMuc3VwZXJzdHJ1Y3QgPSBzdXBlcnN0cnVjdDtcbmV4cG9ydHMuaXNTdHJ1Y3QgPSBpc1N0cnVjdDtcbmV4cG9ydHMuU3RydWN0RXJyb3IgPSBTdHJ1Y3RFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHByb3RvYnVmID0gcmVxdWlyZSgncHJvdG9ucycpXG5jb25zdCBrZXlzUEJNID0gcHJvdG9idWYocmVxdWlyZSgnLi9rZXlzLnByb3RvJykpXG5yZXF1aXJlKCdub2RlLWZvcmdlL2xpYi9hc24xJylcbnJlcXVpcmUoJ25vZGUtZm9yZ2UvbGliL3JzYScpXG5yZXF1aXJlKCdub2RlLWZvcmdlL2xpYi9wYmUnKVxuY29uc3QgZm9yZ2UgPSByZXF1aXJlKCdub2RlLWZvcmdlL2xpYi9mb3JnZScpXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0c1xuXG5jb25zdCBzdXBwb3J0ZWRLZXlzID0ge1xuICByc2E6IHJlcXVpcmUoJy4vcnNhLWNsYXNzJyksXG4gIGVkMjU1MTk6IHJlcXVpcmUoJy4vZWQyNTUxOS1jbGFzcycpLFxuICBzZWNwMjU2azE6IHJlcXVpcmUoJ2xpYnAycC1jcnlwdG8tc2VjcDI1NmsxJykoa2V5c1BCTSwgcmVxdWlyZSgnLi4vcmFuZG9tLWJ5dGVzJykpXG59XG5cbmV4cG9ydHMuc3VwcG9ydGVkS2V5cyA9IHN1cHBvcnRlZEtleXNcbmV4cG9ydHMua2V5c1BCTSA9IGtleXNQQk1cblxuZnVuY3Rpb24gaXNWYWxpZEtleVR5cGUgKGtleVR5cGUpIHtcbiAgY29uc3Qga2V5ID0gc3VwcG9ydGVkS2V5c1trZXlUeXBlLnRvTG93ZXJDYXNlKCldXG4gIHJldHVybiBrZXkgIT09IHVuZGVmaW5lZFxufVxuXG5leHBvcnRzLmtleVN0cmV0Y2hlciA9IHJlcXVpcmUoJy4va2V5LXN0cmV0Y2hlcicpXG5leHBvcnRzLmdlbmVyYXRlRXBoZW1lcmFsS2V5UGFpciA9IHJlcXVpcmUoJy4vZXBoZW1lcmFsLWtleXMnKVxuXG4vLyBHZW5lcmF0ZXMgYSBrZXlwYWlyIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCBiaXRzaXplXG5leHBvcnRzLmdlbmVyYXRlS2V5UGFpciA9ICh0eXBlLCBiaXRzLCBjYikgPT4ge1xuICBsZXQga2V5ID0gc3VwcG9ydGVkS2V5c1t0eXBlLnRvTG93ZXJDYXNlKCldXG5cbiAgaWYgKCFrZXkpIHtcbiAgICByZXR1cm4gY2IobmV3IEVycm9yKCdpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGtleSB0eXBlJykpXG4gIH1cblxuICBrZXkuZ2VuZXJhdGVLZXlQYWlyKGJpdHMsIGNiKVxufVxuXG4vLyBHZW5lcmF0ZXMgYSBrZXlwYWlyIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCBiaXRzaXplXG4vLyBzZWVkIGlzIGEgMzIgYnl0ZSB1aW50OGFycmF5XG5leHBvcnRzLmdlbmVyYXRlS2V5UGFpckZyb21TZWVkID0gKHR5cGUsIHNlZWQsIGJpdHMsIGNiKSA9PiB7XG4gIGxldCBrZXkgPSBzdXBwb3J0ZWRLZXlzW3R5cGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFrZXkpIHtcbiAgICByZXR1cm4gY2IobmV3IEVycm9yKCdpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGtleSB0eXBlJykpXG4gIH1cbiAgaWYgKHR5cGUudG9Mb3dlckNhc2UoKSAhPT0gJ2VkMjU1MTknKSB7XG4gICAgcmV0dXJuIGNiKG5ldyBFcnJvcignU2VlZCBrZXkgZGVyaXZhdGlvbiBpcyB1bmltcGxlbWVudGVkIGZvciBSU0Egb3Igc2VjcDI1NmsxJykpXG4gIH1cbiAga2V5LmdlbmVyYXRlS2V5UGFpckZyb21TZWVkKHNlZWQsIGJpdHMsIGNiKVxufVxuXG4vLyBDb252ZXJ0cyBhIHByb3RvYnVmIHNlcmlhbGl6ZWQgcHVibGljIGtleSBpbnRvIGl0c1xuLy8gcmVwcmVzZW50YXRpdmUgb2JqZWN0XG5leHBvcnRzLnVubWFyc2hhbFB1YmxpY0tleSA9IChidWYpID0+IHtcbiAgY29uc3QgZGVjb2RlZCA9IGtleXNQQk0uUHVibGljS2V5LmRlY29kZShidWYpXG4gIGNvbnN0IGRhdGEgPSBkZWNvZGVkLkRhdGFcblxuICBzd2l0Y2ggKGRlY29kZWQuVHlwZSkge1xuICAgIGNhc2Uga2V5c1BCTS5LZXlUeXBlLlJTQTpcbiAgICAgIHJldHVybiBzdXBwb3J0ZWRLZXlzLnJzYS51bm1hcnNoYWxSc2FQdWJsaWNLZXkoZGF0YSlcbiAgICBjYXNlIGtleXNQQk0uS2V5VHlwZS5FZDI1NTE5OlxuICAgICAgcmV0dXJuIHN1cHBvcnRlZEtleXMuZWQyNTUxOS51bm1hcnNoYWxFZDI1NTE5UHVibGljS2V5KGRhdGEpXG4gICAgY2FzZSBrZXlzUEJNLktleVR5cGUuU2VjcDI1NmsxOlxuICAgICAgaWYgKHN1cHBvcnRlZEtleXMuc2VjcDI1NmsxKSB7XG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWRLZXlzLnNlY3AyNTZrMS51bm1hcnNoYWxTZWNwMjU2azFQdWJsaWNLZXkoZGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2VjcDI1NmsxIHN1cHBvcnQgcmVxdWlyZXMgbGlicDJwLWNyeXB0by1zZWNwMjU2azEgcGFja2FnZScpXG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBvciB1bnN1cHBvcnRlZCBrZXkgdHlwZScpXG4gIH1cbn1cblxuLy8gQ29udmVydHMgYSBwdWJsaWMga2V5IG9iamVjdCBpbnRvIGEgcHJvdG9idWYgc2VyaWFsaXplZCBwdWJsaWMga2V5XG5leHBvcnRzLm1hcnNoYWxQdWJsaWNLZXkgPSAoa2V5LCB0eXBlKSA9PiB7XG4gIHR5cGUgPSAodHlwZSB8fCAncnNhJykudG9Mb3dlckNhc2UoKVxuICBpZiAoIWlzVmFsaWRLZXlUeXBlKHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGtleSB0eXBlJylcbiAgfVxuXG4gIHJldHVybiBrZXkuYnl0ZXNcbn1cblxuLy8gQ29udmVydHMgYSBwcm90b2J1ZiBzZXJpYWxpemVkIHByaXZhdGUga2V5IGludG8gaXRzXG4vLyByZXByZXNlbnRhdGl2ZSBvYmplY3RcbmV4cG9ydHMudW5tYXJzaGFsUHJpdmF0ZUtleSA9IChidWYsIGNhbGxiYWNrKSA9PiB7XG4gIGxldCBkZWNvZGVkXG4gIHRyeSB7XG4gICAgZGVjb2RlZCA9IGtleXNQQk0uUHJpdmF0ZUtleS5kZWNvZGUoYnVmKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICB9XG5cbiAgY29uc3QgZGF0YSA9IGRlY29kZWQuRGF0YVxuXG4gIHN3aXRjaCAoZGVjb2RlZC5UeXBlKSB7XG4gICAgY2FzZSBrZXlzUEJNLktleVR5cGUuUlNBOlxuICAgICAgcmV0dXJuIHN1cHBvcnRlZEtleXMucnNhLnVubWFyc2hhbFJzYVByaXZhdGVLZXkoZGF0YSwgY2FsbGJhY2spXG4gICAgY2FzZSBrZXlzUEJNLktleVR5cGUuRWQyNTUxOTpcbiAgICAgIHJldHVybiBzdXBwb3J0ZWRLZXlzLmVkMjU1MTkudW5tYXJzaGFsRWQyNTUxOVByaXZhdGVLZXkoZGF0YSwgY2FsbGJhY2spXG4gICAgY2FzZSBrZXlzUEJNLktleVR5cGUuU2VjcDI1NmsxOlxuICAgICAgaWYgKHN1cHBvcnRlZEtleXMuc2VjcDI1NmsxKSB7XG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWRLZXlzLnNlY3AyNTZrMS51bm1hcnNoYWxTZWNwMjU2azFQcml2YXRlS2V5KGRhdGEsIGNhbGxiYWNrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignc2VjcDI1NmsxIHN1cHBvcnQgcmVxdWlyZXMgbGlicDJwLWNyeXB0by1zZWNwMjU2azEgcGFja2FnZScpKVxuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ2ludmFsaWQgb3IgdW5zdXBwb3J0ZWQga2V5IHR5cGUnKSlcbiAgfVxufVxuXG4vLyBDb252ZXJ0cyBhIHByaXZhdGUga2V5IG9iamVjdCBpbnRvIGEgcHJvdG9idWYgc2VyaWFsaXplZCBwcml2YXRlIGtleVxuZXhwb3J0cy5tYXJzaGFsUHJpdmF0ZUtleSA9IChrZXksIHR5cGUpID0+IHtcbiAgdHlwZSA9ICh0eXBlIHx8ICdyc2EnKS50b0xvd2VyQ2FzZSgpXG4gIGlmICghaXNWYWxpZEtleVR5cGUodHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgb3IgdW5zdXBwb3J0ZWQga2V5IHR5cGUnKVxuICB9XG5cbiAgcmV0dXJuIGtleS5ieXRlc1xufVxuXG5leHBvcnRzLmltcG9ydCA9IChwZW0sIHBhc3N3b3JkLCBjYWxsYmFjaykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGtleSA9IGZvcmdlLnBraS5kZWNyeXB0UnNhUHJpdmF0ZUtleShwZW0sIHBhc3N3b3JkKVxuICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgdGhlIGtleSwgbW9zdCBsaWtlbHkgdGhlIHBhc3N3b3JkIGlzIHdyb25nIG9yIG5vdCBhIFJTQSBrZXknKVxuICAgIH1cbiAgICBsZXQgZGVyID0gZm9yZ2UuYXNuMS50b0Rlcihmb3JnZS5wa2kucHJpdmF0ZUtleVRvQXNuMShrZXkpKVxuICAgIGRlciA9IEJ1ZmZlci5mcm9tKGRlci5nZXRCeXRlcygpLCAnYmluYXJ5JylcbiAgICByZXR1cm4gc3VwcG9ydGVkS2V5cy5yc2EudW5tYXJzaGFsUnNhUHJpdmF0ZUtleShkZXIsIGNhbGxiYWNrKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYWxsYmFjayhlcnIpXG4gIH1cbn1cbiIsImNvbnN0IE11bHRpYWRkciA9IHJlcXVpcmUoJ211bHRpYWRkcicpXG5jb25zdCByZWR1Y2VWYWx1ZSA9IChfLCB2KSA9PiB2XG5cbmNvbnN0IFJlZHVjZXJzID0ge1xuICBpcDQ6IHJlZHVjZVZhbHVlLFxuICBpcDY6IChzdHIsIGNvbnRlbnQsIGksIHBhcnRzKSA9PiAoXG4gICAgcGFydHMubGVuZ3RoID09PSAxICYmIHBhcnRzWzBdLnByb3RvY29sID09PSAnaXA2J1xuICAgICAgPyBjb250ZW50XG4gICAgICA6IGBbJHtjb250ZW50fV1gXG4gICksXG4gIHRjcDogKHN0ciwgY29udGVudCwgaSwgcGFydHMpID0+IChcbiAgICBwYXJ0cy5zb21lKHAgPT4gWydodHRwJywgJ2h0dHBzJywgJ3dzJywgJ3dzcyddLmluY2x1ZGVzKHAucHJvdG9jb2wpKVxuICAgICAgPyBgJHtzdHJ9OiR7Y29udGVudH1gXG4gICAgICA6IGB0Y3A6Ly8ke3N0cn06JHtjb250ZW50fWBcbiAgKSxcbiAgdWRwOiAoc3RyLCBjb250ZW50KSA9PiBgdWRwOi8vJHtzdHJ9OiR7Y29udGVudH1gLFxuICBkbnNhZGRyOiByZWR1Y2VWYWx1ZSxcbiAgZG5zNDogcmVkdWNlVmFsdWUsXG4gIGRuczY6IHJlZHVjZVZhbHVlLFxuICBpcGZzOiAoc3RyLCBjb250ZW50KSA9PiBgJHtzdHJ9L2lwZnMvJHtjb250ZW50fWAsXG4gIHAycDogKHN0ciwgY29udGVudCkgPT4gYCR7c3RyfS9wMnAvJHtjb250ZW50fWAsXG4gIGh0dHA6IHN0ciA9PiBgaHR0cDovLyR7c3RyfWAsXG4gIGh0dHBzOiBzdHIgPT4gYGh0dHBzOi8vJHtzdHJ9YCxcbiAgd3M6IHN0ciA9PiBgd3M6Ly8ke3N0cn1gLFxuICB3c3M6IHN0ciA9PiBgd3NzOi8vJHtzdHJ9YCxcbiAgJ3AycC13ZWJzb2NrZXQtc3Rhcic6IHN0ciA9PiBgJHtzdHJ9L3AycC13ZWJzb2NrZXQtc3RhcmAsXG4gICdwMnAtd2VicnRjLXN0YXInOiBzdHIgPT4gYCR7c3RyfS9wMnAtd2VicnRjLXN0YXJgLFxuICAncDJwLXdlYnJ0Yy1kaXJlY3QnOiBzdHIgPT4gYCR7c3RyfS9wMnAtd2VicnRjLWRpcmVjdGBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAobXVsdGlhZGRyKSA9PiAoXG4gIE11bHRpYWRkcihtdWx0aWFkZHIpXG4gICAgLnN0cmluZ1R1cGxlcygpXG4gICAgLm1hcCh0dXBsZSA9PiAoe1xuICAgICAgcHJvdG9jb2w6IE11bHRpYWRkci5wcm90b2NvbHMuY29kZXNbdHVwbGVbMF1dLm5hbWUsXG4gICAgICBjb250ZW50OiB0dXBsZVsxXVxuICAgIH0pKVxuICAgIC5yZWR1Y2UoKHN0ciwgcGFydCwgaSwgcGFydHMpID0+IHtcbiAgICAgIGNvbnN0IHJlZHVjZSA9IFJlZHVjZXJzW3BhcnQucHJvdG9jb2xdXG4gICAgICBpZiAoIXJlZHVjZSkgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwcm90b2NvbCAke3BhcnQucHJvdG9jb2x9YClcbiAgICAgIHJldHVybiByZWR1Y2Uoc3RyLCBwYXJ0LmNvbnRlbnQsIGksIHBhcnRzKVxuICAgIH0sICcnKVxuKVxuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG4ndXNlIHN0cmljdCdcblxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpXG5cbmNvbnN0IGxvZyA9IGRlYnVnKCdpcGZzOnByZWxvYWQnKVxubG9nLmVycm9yID0gZGVidWcoJ2lwZnM6cHJlbG9hZDplcnJvcicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHJlbG9hZCAodXJsLCBjYWxsYmFjaykge1xuICBsb2codXJsKVxuXG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgY29uc3Qgc2lnbmFsID0gY29udHJvbGxlci5zaWduYWxcblxuICBmZXRjaCh1cmwsIHsgc2lnbmFsIH0pXG4gICAgLnRoZW4ocmVzID0+IHtcbiAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgIGxvZy5lcnJvcignZmFpbGVkIHRvIHByZWxvYWQnLCB1cmwsIHJlcy5zdGF0dXMsIHJlcy5zdGF0dXNUZXh0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBwcmVsb2FkICR7dXJsfWApXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzLnRleHQoKVxuICAgIH0pXG4gICAgLnRoZW4oKCkgPT4gY2FsbGJhY2soKSlcbiAgICAuY2F0Y2goY2FsbGJhY2spXG5cbiAgcmV0dXJuIHtcbiAgICBjYW5jZWw6ICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJldHJ5O1xuXG52YXIgX25vb3AgPSByZXF1aXJlKCdsb2Rhc2gvbm9vcCcpO1xuXG52YXIgX25vb3AyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbm9vcCk7XG5cbnZhciBfY29uc3RhbnQgPSByZXF1aXJlKCdsb2Rhc2gvY29uc3RhbnQnKTtcblxudmFyIF9jb25zdGFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb25zdGFudCk7XG5cbnZhciBfd3JhcEFzeW5jID0gcmVxdWlyZSgnLi9pbnRlcm5hbC93cmFwQXN5bmMnKTtcblxudmFyIF93cmFwQXN5bmMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd3JhcEFzeW5jKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBnZXQgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIGZyb20gYHRhc2tgIG5vIG1vcmUgdGhhbiBgdGltZXNgIHRpbWVzXG4gKiBiZWZvcmUgcmV0dXJuaW5nIGFuIGVycm9yLiBJZiB0aGUgdGFzayBpcyBzdWNjZXNzZnVsLCB0aGUgYGNhbGxiYWNrYCB3aWxsIGJlXG4gKiBwYXNzZWQgdGhlIHJlc3VsdCBvZiB0aGUgc3VjY2Vzc2Z1bCB0YXNrLiBJZiBhbGwgYXR0ZW1wdHMgZmFpbCwgdGhlIGNhbGxiYWNrXG4gKiB3aWxsIGJlIHBhc3NlZCB0aGUgZXJyb3IgYW5kIHJlc3VsdCAoaWYgYW55KSBvZiB0aGUgZmluYWwgYXR0ZW1wdC5cbiAqXG4gKiBAbmFtZSByZXRyeVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHNlZSBbYXN5bmMucmV0cnlhYmxlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucmV0cnlhYmxlfVxuICogQHBhcmFtIHtPYmplY3R8bnVtYmVyfSBbb3B0cyA9IHt0aW1lczogNSwgaW50ZXJ2YWw6IDB9fCA1XSAtIENhbiBiZSBlaXRoZXIgYW5cbiAqIG9iamVjdCB3aXRoIGB0aW1lc2AgYW5kIGBpbnRlcnZhbGAgb3IgYSBudW1iZXIuXG4gKiAqIGB0aW1lc2AgLSBUaGUgbnVtYmVyIG9mIGF0dGVtcHRzIHRvIG1ha2UgYmVmb3JlIGdpdmluZyB1cC4gIFRoZSBkZWZhdWx0XG4gKiAgIGlzIGA1YC5cbiAqICogYGludGVydmFsYCAtIFRoZSB0aW1lIHRvIHdhaXQgYmV0d2VlbiByZXRyaWVzLCBpbiBtaWxsaXNlY29uZHMuICBUaGVcbiAqICAgZGVmYXVsdCBpcyBgMGAuIFRoZSBpbnRlcnZhbCBtYXkgYWxzbyBiZSBzcGVjaWZpZWQgYXMgYSBmdW5jdGlvbiBvZiB0aGVcbiAqICAgcmV0cnkgY291bnQgKHNlZSBleGFtcGxlKS5cbiAqICogYGVycm9yRmlsdGVyYCAtIEFuIG9wdGlvbmFsIHN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCBvblxuICogICBlcnJvbmVvdXMgcmVzdWx0LiBJZiBpdCByZXR1cm5zIGB0cnVlYCB0aGUgcmV0cnkgYXR0ZW1wdHMgd2lsbCBjb250aW51ZTtcbiAqICAgaWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCB0aGUgcmV0cnkgZmxvdyBpcyBhYm9ydGVkIHdpdGggdGhlIGN1cnJlbnRcbiAqICAgYXR0ZW1wdCdzIGVycm9yIGFuZCByZXN1bHQgYmVpbmcgcmV0dXJuZWQgdG8gdGhlIGZpbmFsIGNhbGxiYWNrLlxuICogICBJbnZva2VkIHdpdGggKGVycikuXG4gKiAqIElmIGBvcHRzYCBpcyBhIG51bWJlciwgdGhlIG51bWJlciBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiB0aW1lcyB0byByZXRyeSxcbiAqICAgd2l0aCB0aGUgZGVmYXVsdCBpbnRlcnZhbCBvZiBgMGAuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHRhc2sgLSBBbiBhc3luYyBmdW5jdGlvbiB0byByZXRyeS5cbiAqIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHRoZVxuICogdGFzayBoYXMgc3VjY2VlZGVkLCBvciBhZnRlciB0aGUgZmluYWwgZmFpbGVkIGF0dGVtcHQuIEl0IHJlY2VpdmVzIHRoZSBgZXJyYFxuICogYW5kIGByZXN1bHRgIGFyZ3VtZW50cyBvZiB0aGUgbGFzdCBhdHRlbXB0IGF0IGNvbXBsZXRpbmcgdGhlIGB0YXNrYC4gSW52b2tlZFxuICogd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFRoZSBgcmV0cnlgIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIGFzIGEgc3RhbmQtYWxvbmUgY29udHJvbCBmbG93IGJ5IHBhc3NpbmdcbiAqIC8vIGEgY2FsbGJhY2ssIGFzIHNob3duIGJlbG93OlxuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCAzIHRpbWVzXG4gKiBhc3luYy5yZXRyeSgzLCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIDMgdGltZXMsIHdhaXRpbmcgMjAwIG1zIGJldHdlZW4gZWFjaCByZXRyeVxuICogYXN5bmMucmV0cnkoe3RpbWVzOiAzLCBpbnRlcnZhbDogMjAwfSwgYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRcbiAqIH0pO1xuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCAxMCB0aW1lcyB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAqIC8vIChpLmUuIGludGVydmFscyBvZiAxMDAsIDIwMCwgNDAwLCA4MDAsIDE2MDAsIC4uLiBtaWxsaXNlY29uZHMpXG4gKiBhc3luYy5yZXRyeSh7XG4gKiAgIHRpbWVzOiAxMCxcbiAqICAgaW50ZXJ2YWw6IGZ1bmN0aW9uKHJldHJ5Q291bnQpIHtcbiAqICAgICByZXR1cm4gNTAgKiBNYXRoLnBvdygyLCByZXRyeUNvdW50KTtcbiAqICAgfVxuICogfSwgYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRcbiAqIH0pO1xuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCB0aGUgZGVmYXVsdCA1IHRpbWVzIG5vIGRlbGF5IGJldHdlZW4gZWFjaCByZXRyeVxuICogYXN5bmMucmV0cnkoYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRcbiAqIH0pO1xuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCBvbmx5IHdoZW4gZXJyb3IgY29uZGl0aW9uIHNhdGlzZmllcywgYWxsIG90aGVyXG4gKiAvLyBlcnJvcnMgd2lsbCBhYm9ydCB0aGUgcmV0cnkgY29udHJvbCBmbG93IGFuZCByZXR1cm4gdG8gZmluYWwgY2FsbGJhY2tcbiAqIGFzeW5jLnJldHJ5KHtcbiAqICAgZXJyb3JGaWx0ZXI6IGZ1bmN0aW9uKGVycikge1xuICogICAgIHJldHVybiBlcnIubWVzc2FnZSA9PT0gJ1RlbXBvcmFyeSBlcnJvcic7IC8vIG9ubHkgcmV0cnkgb24gYSBzcGVjaWZpYyBlcnJvclxuICogICB9XG4gKiB9LCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdG8gcmV0cnkgaW5kaXZpZHVhbCBtZXRob2RzIHRoYXQgYXJlIG5vdCBhcyByZWxpYWJsZSB3aXRoaW4gb3RoZXJcbiAqIC8vIGNvbnRyb2wgZmxvdyBmdW5jdGlvbnMsIHVzZSB0aGUgYHJldHJ5YWJsZWAgd3JhcHBlcjpcbiAqIGFzeW5jLmF1dG8oe1xuICogICAgIHVzZXJzOiBhcGkuZ2V0VXNlcnMuYmluZChhcGkpLFxuICogICAgIHBheW1lbnRzOiBhc3luYy5yZXRyeWFibGUoMywgYXBpLmdldFBheW1lbnRzLmJpbmQoYXBpKSlcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRzXG4gKiB9KTtcbiAqXG4gKi9cbmZ1bmN0aW9uIHJldHJ5KG9wdHMsIHRhc2ssIGNhbGxiYWNrKSB7XG4gICAgdmFyIERFRkFVTFRfVElNRVMgPSA1O1xuICAgIHZhciBERUZBVUxUX0lOVEVSVkFMID0gMDtcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICB0aW1lczogREVGQVVMVF9USU1FUyxcbiAgICAgICAgaW50ZXJ2YWxGdW5jOiAoMCwgX2NvbnN0YW50Mi5kZWZhdWx0KShERUZBVUxUX0lOVEVSVkFMKVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwYXJzZVRpbWVzKGFjYywgdCkge1xuICAgICAgICBpZiAodHlwZW9mIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBhY2MudGltZXMgPSArdC50aW1lcyB8fCBERUZBVUxUX1RJTUVTO1xuXG4gICAgICAgICAgICBhY2MuaW50ZXJ2YWxGdW5jID0gdHlwZW9mIHQuaW50ZXJ2YWwgPT09ICdmdW5jdGlvbicgPyB0LmludGVydmFsIDogKDAsIF9jb25zdGFudDIuZGVmYXVsdCkoK3QuaW50ZXJ2YWwgfHwgREVGQVVMVF9JTlRFUlZBTCk7XG5cbiAgICAgICAgICAgIGFjYy5lcnJvckZpbHRlciA9IHQuZXJyb3JGaWx0ZXI7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHQgPT09ICdudW1iZXInIHx8IHR5cGVvZiB0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYWNjLnRpbWVzID0gK3QgfHwgREVGQVVMVF9USU1FUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRzIGZvciBhc3luYy5yZXRyeVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMyAmJiB0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IHRhc2sgfHwgX25vb3AyLmRlZmF1bHQ7XG4gICAgICAgIHRhc2sgPSBvcHRzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlVGltZXMob3B0aW9ucywgb3B0cyk7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgX25vb3AyLmRlZmF1bHQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0YXNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRzIGZvciBhc3luYy5yZXRyeVwiKTtcbiAgICB9XG5cbiAgICB2YXIgX3Rhc2sgPSAoMCwgX3dyYXBBc3luYzIuZGVmYXVsdCkodGFzayk7XG5cbiAgICB2YXIgYXR0ZW1wdCA9IDE7XG4gICAgZnVuY3Rpb24gcmV0cnlBdHRlbXB0KCkge1xuICAgICAgICBfdGFzayhmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyICYmIGF0dGVtcHQrKyA8IG9wdGlvbnMudGltZXMgJiYgKHR5cGVvZiBvcHRpb25zLmVycm9yRmlsdGVyICE9ICdmdW5jdGlvbicgfHwgb3B0aW9ucy5lcnJvckZpbHRlcihlcnIpKSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocmV0cnlBdHRlbXB0LCBvcHRpb25zLmludGVydmFsRnVuYyhhdHRlbXB0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHJ5QXR0ZW1wdCgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuZmlyc3QgPSBhc3luYyAoaXRlcmF0b3IpID0+IHtcbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBpdGVyYXRvcikge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG59XG5cbmV4cG9ydHMubGFzdCA9IGFzeW5jIChpdGVyYXRvcikgPT4ge1xuICBsZXQgdmFsdWVcbiAgZm9yIGF3YWl0ICh2YWx1ZSBvZiBpdGVyYXRvcikge1xuICAgIC8vIEludGVudGlvbmFsbHkgZW1wdHlcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuZXhwb3J0cy5hbGwgPSBhc3luYyAoaXRlcmF0b3IpID0+IHtcbiAgY29uc3QgdmFsdWVzID0gW11cbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBpdGVyYXRvcikge1xuICAgIHZhbHVlcy5wdXNoKHZhbHVlKVxuICB9XG4gIHJldHVybiB2YWx1ZXNcbn1cblxuZXhwb3J0cy5leHRlbmRJdGVyYXRvciA9IChpdGVyYXRvcikgPT4ge1xuICBpdGVyYXRvci5maXJzdCA9ICgpID0+IGV4cG9ydHMuZmlyc3QoaXRlcmF0b3IpXG4gIGl0ZXJhdG9yLmxhc3QgPSAoKSA9PiBleHBvcnRzLmxhc3QoaXRlcmF0b3IpXG4gIGl0ZXJhdG9yLmFsbCA9ICgpID0+IGV4cG9ydHMuYWxsKGl0ZXJhdG9yKVxuICByZXR1cm4gaXRlcmF0b3Jcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLnV0aWwgPSByZXF1aXJlKCcuL3V0aWwuanMnKVxuZXhwb3J0cy5yZXNvbHZlciA9IHJlcXVpcmUoJy4vcmVzb2x2ZXIuanMnKVxuZXhwb3J0cy5jb2RlYyA9IGV4cG9ydHMudXRpbC5jb2RlY1xuZXhwb3J0cy5kZWZhdWx0SGFzaEFsZyA9IGV4cG9ydHMudXRpbC5kZWZhdWx0SGFzaEFsZ1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuREFHTm9kZSA9IHJlcXVpcmUoJy4vZGFnLW5vZGUnKVxuZXhwb3J0cy5EQUdMaW5rID0gcmVxdWlyZSgnLi9kYWctbGluaycpXG5cbi8qXG4gKiBGdW5jdGlvbnMgdG8gZnVsZmlsIElQTEQgRm9ybWF0IGludGVyZmFjZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2lwbGQvaW50ZXJmYWNlLWlwbGQtZm9ybWF0XG4gKi9cbmV4cG9ydHMucmVzb2x2ZXIgPSByZXF1aXJlKCcuL3Jlc29sdmVyJylcbmV4cG9ydHMudXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG5leHBvcnRzLmNvZGVjID0gZXhwb3J0cy51dGlsLmNvZGVjXG5leHBvcnRzLmRlZmF1bHRIYXNoQWxnID0gZXhwb3J0cy51dGlsLmRlZmF1bHRIYXNoQWxnXG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IENJRCA9IHJlcXVpcmUoJ2NpZHMnKVxuY29uc3QgbXVsdGloYXNoaW5nID0gcmVxdWlyZSgnbXVsdGloYXNoaW5nLWFzeW5jJylcbmNvbnN0IG11bHRpY29kZWMgPSByZXF1aXJlKCdtdWx0aWNvZGVjJylcblxuLy8gYmluYXJ5IHJlc29sdmVyXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29kZWM6IG11bHRpY29kZWMuUkFXLFxuICBkZWZhdWx0SGFzaEFsZzogbXVsdGljb2RlYy5TSEEyXzI1NixcbiAgcmVzb2x2ZXI6IHtcbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyBhIHBhdGggd2l0aGluIGEgUmF3IGJsb2NrLlxuICAgICAqXG4gICAgICogQWx3YXlzIHJldHVybnMgdGhlIHJhdyBkYXRhIGFzIHZhbHVlIHdpdGhvdXQgYW55IHJlbWFpbmRlclBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gYmluYXJ5QmxvYiAtIEJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiBhIFBCIGJsb2NrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXRoPScvJ10gLSBQYXRoIHRoYXQgc2hvdWxkIGJlIHJlc29sdmVkICh0aGF0IHZhbHVlIGlzIGlnbm9yZWQpXG4gICAgICogQHJldHVybnMge09iamVjdH0gcmVzdWx0IC0gUmVzdWx0IG9mIHRoZSBwYXRoIGl0IGl0IHdhcyByZXNvbHZlZCBzdWNjZXNzZnVsbHlcbiAgICAgKiBAcmV0dXJucyB7Kn0gcmVzdWx0LnZhbHVlIC0gVGhlIHJhdyBkYXRhXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcmVzdWx0LnJlbWFpbmRlclBhdGggLSBBbiBlbXB0eSBzdHJpbmdcbiAgICAgKi9cbiAgICByZXNvbHZlOiAoYmluYXJ5QmxvYiwgcGF0aCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGJpbmFyeUJsb2IsXG4gICAgICAgIHJlbWFpbmRlclBhdGg6ICcnXG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWxsIGF2YWlsYWJsZSBwYXRocyBvZiBhIGJsb2NrLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRvclxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBiaW5hcnlCbG9iIC0gVGhlIHJhdyBkYXRhXG4gICAgICogQHJldHVybnMge09iamVjdH0gLSBGaW5pc2hlZCBnZW5lcmF0b3Igd2l0aCBgZG9uZTogdHJ1ZWBcbiAgICAgKi9cbiAgICB0cmVlOiAoYmluYXJ5QmxvYikgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgdXRpbDoge1xuICAgIGRlc2VyaWFsaXplOiAoZGF0YSkgPT4ge1xuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogKGRhdGEpID0+IHtcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIENJRCBvZiB0aGUgYmluYXJ5IGJsb2IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYmluYXJ5QmxvYiAtIEVuY29kZWQgSVBMRCBOb2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFt1c2VyT3B0aW9uc10gLSBPcHRpb25zIHRvIGNyZWF0ZSB0aGUgQ0lEXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt1c2VyT3B0aW9ucy5jaWRWZXJzaW9uPTFdIC0gQ0lEIHZlcnNpb24gbnVtYmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtVc2VyT3B0aW9ucy5oYXNoQWxnXSAtIERlZmF1bHRzIHRvIHRoZSBkZWZhdWx0SGFzaEFsZyBvZiB0aGUgZm9ybWF0XG4gICAgICogQHJldHVybnMge1Byb21pc2UuPENJRD59XG4gICAgICovXG4gICAgY2lkOiBhc3luYyAoYmluYXJ5QmxvYiwgdXNlck9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0geyBjaWRWZXJzaW9uOiAxLCBoYXNoQWxnOiBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0SGFzaEFsZyB9XG4gICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0T3B0aW9ucywgdXNlck9wdGlvbnMpXG5cbiAgICAgIGNvbnN0IG11bHRpaGFzaCA9IGF3YWl0IG11bHRpaGFzaGluZyhiaW5hcnlCbG9iLCBvcHRpb25zLmhhc2hBbGcpXG4gICAgICBjb25zdCBjb2RlY05hbWUgPSBtdWx0aWNvZGVjLnByaW50W21vZHVsZS5leHBvcnRzLmNvZGVjXVxuICAgICAgY29uc3QgY2lkID0gbmV3IENJRChvcHRpb25zLmNpZFZlcnNpb24sIGNvZGVjTmFtZSwgbXVsdGloYXNoKVxuXG4gICAgICByZXR1cm4gY2lkXG4gICAgfVxuICB9XG59XG4iLCIvKiogUFJPTUlTSUZZIENBTExCQUNLLVNUWUxFIEZVTkNUSU9OUyBUTyBFUzYgUFJPTUlTRVNcclxuKlxyXG4qIEVYQU1QTEU6XHJcbiogY29uc3QgZm4gPSBwcm9taXNpZnkoIChjYWxsYmFjaykgPT4gY2FsbGJhY2sobnVsbCwgXCJIZWxsbyB3b3JsZCFcIikgKTtcclxuKiBmbigoZXJyLCBzdHIpID0+IGNvbnNvbGUubG9nKHN0cikpO1xyXG4qIGZuKCkudGhlbigoc3RyKSA9PiBjb25zb2xlLmxvZyhzdHIpKTtcclxuKiAvL0JvdGggZnVuY3Rpb25zLCB3aWxsIGxvZyAnSGVsbG8gd29ybGQhJ1xyXG4qXHJcbiogTm90ZTogVGhlIGZ1bmN0aW9uIHlvdSBwYXNzLCBtYXkgaGF2ZSBhbnkgYXJndW1lbnRzIHlvdSB3YW50LCBidXQgdGhlIGxhdGVzdFxyXG4qIGhhdmUgdG8gYmUgdGhlIGNhbGxiYWNrLCB3aGljaCB5b3Ugd2lsbCBjYWxsIHdpdGg6IG5leHQoZXJyLCB2YWx1ZSlcclxuKlxyXG4qIEBwYXJhbSBtZXRob2Q6IEZ1bmN0aW9uL0FycmF5L01hcCA9IFRoZSBmdW5jdGlvbihzKSB0byBwcm9taXNpZnlcclxuKiBAcGFyYW0gb3B0aW9uczogTWFwID1cclxuKiAgXCJjb250ZXh0XCIgKGRlZmF1bHQgaXMgZnVuY3Rpb24pOiBUaGUgY29udGV4dCB3aGljaCB0byBhcHBseSB0aGUgY2FsbGVkIGZ1bmN0aW9uXHJcbiogIFwicmVwbGFjZVwiIChkZWZhdWx0IGlzIGZhbHN5KTogV2hlbiBwYXNzZWQgYW4gYXJyYXkvbWFwLCBpZiB0byByZXBsYWNlIHRoZSBvcmlnaW5hbCBvYmplY3RcclxuKlxyXG4qIEByZXR1cm46IEEgcHJvbWlzZSBpZiBwYXNzZWQgYSBmdW5jdGlvbiwgb3RoZXJ3aXNlIHRoZSBvYmplY3Qgd2l0aCB0aGUgcHJvbWlzZXNcclxuKlxyXG4qIEBsaWNlbnNlOiBNSVRcclxuKiBAdmVyc2lvbjogMS4wLjNcclxuKiBAYXV0aG9yOiBNYW51ZWwgRGkgSW9yaW9cclxuKiovXHJcblxyXG52YXIgY3JlYXRlQ2FsbGJhY2sgPSBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICB2YXIgbGFzdEluZGV4ID0gYXJncy5sZW5ndGggLSAxO1xyXG4gICAgICAgIHZhciBsYXN0QXJnID0gYXJncyAmJiBhcmdzLmxlbmd0aCA+IDAgPyBhcmdzW2xhc3RJbmRleF0gOiBudWxsO1xyXG4gICAgICAgIHZhciBjYiA9IHR5cGVvZiBsYXN0QXJnID09PSAnZnVuY3Rpb24nID8gbGFzdEFyZyA6IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChjYikge1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHZhbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWwpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIG1ldGhvZC5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn07XHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJ1bmRlZmluZWRcIikgbW9kdWxlID0ge307IC8vIEJyb3dzZXJpZnkgdGhpcyBtb2R1bGVcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGhvZHMsIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgdmFyIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWV0aG9kcyk7XHJcblxyXG4gICAgaWYgKHR5cGUgPT09IFwiW29iamVjdCBPYmplY3RdXCIgfHwgdHlwZSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XHJcbiAgICAgICAgdmFyIG9iaiA9IG9wdGlvbnMucmVwbGFjZSA/IG1ldGhvZHMgOiB7fTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcclxuICAgICAgICAgICAgaWYgKG1ldGhvZHMuaGFzT3duUHJvcGVydHkoa2V5KSkgb2JqW2tleV0gPSBjcmVhdGVDYWxsYmFjayhtZXRob2RzW2tleV0pO1xyXG4gICAgICAgIH1yZXR1cm4gb2JqO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjcmVhdGVDYWxsYmFjayhtZXRob2RzLCBvcHRpb25zLmNvbnRleHQgfHwgbWV0aG9kcyk7XHJcbn07XHJcblxyXG4vLyBCcm93c2VyaWZ5IHRoaXMgbW9kdWxlXHJcbmlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgdGhpc1tcInByb21pc2lmeVwiXSA9IG1vZHVsZS5leHBvcnRzO1xyXG59XHJcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC50eXBpY2FsID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBGb3IgdHlwZS1jaGVja2luZyBKYXZhc2NyaXB0IHZhbHVlcy5cbiAgICogQG1vZHVsZSB0eXBpY2FsXG4gICAqIEB0eXBpY2FsbmFtZSB0XG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHQgPSByZXF1aXJlKCd0eXBpY2FsJylcbiAgICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBpbnB1dCBpcyBhIG51bWJlclxuICAgKiBAcGFyYW0geyp9IC0gdGhlIGlucHV0IHRvIHRlc3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBzdGF0aWNcbiAgICogQGV4YW1wbGVcbiAgICogPiB0LmlzTnVtYmVyKDApXG4gICAqIHRydWVcbiAgICogPiB0LmlzTnVtYmVyKDEpXG4gICAqIHRydWVcbiAgICogPiB0LmlzTnVtYmVyKDEuMSlcbiAgICogdHJ1ZVxuICAgKiA+IHQuaXNOdW1iZXIoMHhmZilcbiAgICogdHJ1ZVxuICAgKiA+IHQuaXNOdW1iZXIoMDY0NClcbiAgICogdHJ1ZVxuICAgKiA+IHQuaXNOdW1iZXIoNi4yZTUpXG4gICAqIHRydWVcbiAgICogPiB0LmlzTnVtYmVyKE5hTilcbiAgICogZmFsc2VcbiAgICogPiB0LmlzTnVtYmVyKEluZmluaXR5KVxuICAgKiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNOdW1iZXIgKG4pIHtcbiAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pXG4gIH1cblxuICAvKipcbiAgICogQSBwbGFpbiBvYmplY3QgaXMgYSBzaW1wbGUgb2JqZWN0IGxpdGVyYWwsIGl0IGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBhIGNsYXNzLiBSZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IGB0eXBlb2ZgIGlzIGBvYmplY3RgIGFuZCBkaXJlY3RseSBkZWNlbmRzIGZyb20gYE9iamVjdGAuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gLSB0aGUgaW5wdXQgdG8gdGVzdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICogQHN0YXRpY1xuICAgKiBAZXhhbXBsZVxuICAgKiA+IHQuaXNQbGFpbk9iamVjdCh7IHNvbWV0aGluZzogJ29uZScgfSlcbiAgICogdHJ1ZVxuICAgKiA+IHQuaXNQbGFpbk9iamVjdChuZXcgRGF0ZSgpKVxuICAgKiBmYWxzZVxuICAgKiA+IHQuaXNQbGFpbk9iamVjdChbIDAsIDEgXSlcbiAgICogZmFsc2VcbiAgICogPiB0LmlzUGxhaW5PYmplY3QoL3Rlc3QvKVxuICAgKiBmYWxzZVxuICAgKiA+IHQuaXNQbGFpbk9iamVjdCgxKVxuICAgKiBmYWxzZVxuICAgKiA+IHQuaXNQbGFpbk9iamVjdCgnb25lJylcbiAgICogZmFsc2VcbiAgICogPiB0LmlzUGxhaW5PYmplY3QobnVsbClcbiAgICogZmFsc2VcbiAgICogPiB0LmlzUGxhaW5PYmplY3QoKGZ1bmN0aW9uICogKCkge30pKCkpXG4gICAqIGZhbHNlXG4gICAqID4gdC5pc1BsYWluT2JqZWN0KGZ1bmN0aW9uICogKCkge30pXG4gICAqIGZhbHNlXG4gICAqL1xuICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0IChpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCAhPT0gbnVsbCAmJiB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0LmNvbnN0cnVjdG9yID09PSBPYmplY3RcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBhcnJheS1saWtlIHZhbHVlIGhhcyBhbGwgdGhlIHByb3BlcnRpZXMgb2YgYW4gYXJyYXksIGJ1dCBpcyBub3QgYW4gYXJyYXkgaW5zdGFuY2UuIEV4YW1wbGVzIGluIHRoZSBgYXJndW1lbnRzYCBvYmplY3QuIFJldHVybnMgdHJ1ZSBpZiB0aGUgaW5wdXQgdmFsdWUgaXMgYW4gb2JqZWN0LCBub3QgbnVsbCBhbmQgaGFzIGEgYGxlbmd0aGAgcHJvcGVydHkgd2l0aCBhIG51bWVyaWMgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gLSB0aGUgaW5wdXQgdG8gdGVzdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICogQHN0YXRpY1xuICAgKiBAZXhhbXBsZVxuICAgKiBmdW5jdGlvbiBzdW0oeCwgeSl7XG4gICAqICAgY29uc29sZS5sb2codC5pc0FycmF5TGlrZShhcmd1bWVudHMpKVxuICAgKiAgIC8vIHByaW50cyBgdHJ1ZWBcbiAgICogfVxuICAgKi9cbiAgZnVuY3Rpb24gaXNBcnJheUxpa2UgKGlucHV0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGlucHV0KSAmJiB0eXBlb2YgaW5wdXQubGVuZ3RoID09PSAnbnVtYmVyJ1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHlwZW9mIGlucHV0IGlzIGAnb2JqZWN0J2AgYnV0IG5vdCBudWxsLlxuICAgKiBAcGFyYW0geyp9IC0gdGhlIGlucHV0IHRvIHRlc3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIGZ1bmN0aW9uIGlzT2JqZWN0IChpbnB1dCkge1xuICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0ICE9PSBudWxsXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBpbnB1dCB2YWx1ZSBpcyBkZWZpbmVkLlxuICAgKiBAcGFyYW0geyp9IC0gdGhlIGlucHV0IHRvIHRlc3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIGZ1bmN0aW9uIGlzRGVmaW5lZCAoaW5wdXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0ICE9PSAndW5kZWZpbmVkJ1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgaW5wdXQgdmFsdWUgaXMgYW4gRVMyMDE1IGBjbGFzc2AuXG4gICAqIEBwYXJhbSB7Kn0gLSB0aGUgaW5wdXQgdG8gdGVzdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgZnVuY3Rpb24gaXNDbGFzcyAoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gL15jbGFzcyAvLnRlc3QoRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBpbnB1dCBpcyBhIHN0cmluZywgbnVtYmVyLCBzeW1ib2wsIGJvb2xlYW4sIG51bGwgb3IgdW5kZWZpbmVkIHZhbHVlLlxuICAgKiBAcGFyYW0geyp9IC0gdGhlIGlucHV0IHRvIHRlc3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIGZ1bmN0aW9uIGlzUHJpbWl0aXZlIChpbnB1dCkge1xuICAgIGlmIChpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIHRydWVcbiAgICBzd2l0Y2ggKHR5cGVvZiBpbnB1dCkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgaW5wdXQgaXMgYSBQcm9taXNlLlxuICAgKiBAcGFyYW0geyp9IC0gdGhlIGlucHV0IHRvIHRlc3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIGZ1bmN0aW9uIGlzUHJvbWlzZSAoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQpIHtcbiAgICAgIGNvbnN0IGlzUHJvbWlzZSA9IGlzRGVmaW5lZChQcm9taXNlKSAmJiBpbnB1dCBpbnN0YW5jZW9mIFByb21pc2U7XG4gICAgICBjb25zdCBpc1RoZW5hYmxlID0gaW5wdXQudGhlbiAmJiB0eXBlb2YgaW5wdXQudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIHJldHVybiAhIShpc1Byb21pc2UgfHwgaXNUaGVuYWJsZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgaW5wdXQgaXMgYW4gaXRlcmFibGUgKGBNYXBgLCBgU2V0YCwgYEFycmF5YCwgR2VuZXJhdG9yIGV0Yy4pLlxuICAgKiBAcGFyYW0geyp9IC0gdGhlIGlucHV0IHRvIHRlc3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBzdGF0aWNcbiAgICogQGV4YW1wbGVcbiAgICogPiB0LmlzSXRlcmFibGUoJ3N0cmluZycpXG4gICAqIHRydWVcbiAgICogPiB0LmlzSXRlcmFibGUobmV3IE1hcCgpKVxuICAgKiB0cnVlXG4gICAqID4gdC5pc0l0ZXJhYmxlKFtdKVxuICAgKiB0cnVlXG4gICAqID4gdC5pc0l0ZXJhYmxlKChmdW5jdGlvbiAqICgpIHt9KSgpKVxuICAgKiB0cnVlXG4gICAqID4gdC5pc0l0ZXJhYmxlKFByb21pc2UucmVzb2x2ZSgpKVxuICAgKiBmYWxzZVxuICAgKiA+IHQuaXNJdGVyYWJsZShQcm9taXNlKVxuICAgKiBmYWxzZVxuICAgKiA+IHQuaXNJdGVyYWJsZSh0cnVlKVxuICAgKiBmYWxzZVxuICAgKiA+IHQuaXNJdGVyYWJsZSh7fSlcbiAgICogZmFsc2VcbiAgICogPiB0LmlzSXRlcmFibGUoMClcbiAgICogZmFsc2VcbiAgICogPiB0LmlzSXRlcmFibGUoMS4xKVxuICAgKiBmYWxzZVxuICAgKiA+IHQuaXNJdGVyYWJsZShOYU4pXG4gICAqIGZhbHNlXG4gICAqID4gdC5pc0l0ZXJhYmxlKEluZmluaXR5KVxuICAgKiBmYWxzZVxuICAgKiA+IHQuaXNJdGVyYWJsZShmdW5jdGlvbiAoKSB7fSlcbiAgICogZmFsc2VcbiAgICogPiB0LmlzSXRlcmFibGUoRGF0ZSlcbiAgICogZmFsc2VcbiAgICogPiB0LmlzSXRlcmFibGUoKVxuICAgKiBmYWxzZVxuICAgKiA+IHQuaXNJdGVyYWJsZSh7IHRoZW46IGZ1bmN0aW9uICgpIHt9IH0pXG4gICAqIGZhbHNlXG4gICAqL1xuICBmdW5jdGlvbiBpc0l0ZXJhYmxlIChpbnB1dCkge1xuICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAhaXNEZWZpbmVkKGlucHV0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHR5cGVvZiBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIHR5cGVvZiBpbnB1dFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbidcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBpbnB1dCB2YWx1ZSBpcyBhIHN0cmluZy4gVGhlIGVxdWl2YWxlbnQgb2YgYHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZydgYCBmb3IgdXNlIGluIGZ1bmNpdG9uYWwgY29udGV4dHMuXG4gICAqIEBwYXJhbSB7Kn0gLSB0aGUgaW5wdXQgdG8gdGVzdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgZnVuY3Rpb24gaXNTdHJpbmcgKGlucHV0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZydcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IHZhbHVlIGlzIGEgZnVuY3Rpb24uIFRoZSBlcXVpdmFsZW50IG9mIGB0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbidgYCBmb3IgdXNlIGluIGZ1bmNpdG9uYWwgY29udGV4dHMuXG4gICAqIEBwYXJhbSB7Kn0gLSB0aGUgaW5wdXQgdG8gdGVzdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgZnVuY3Rpb24gaXNGdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nXG4gIH1cblxuICB2YXIgaW5kZXggPSB7XG4gICAgaXNOdW1iZXIsXG4gICAgaXNQbGFpbk9iamVjdCxcbiAgICBpc0FycmF5TGlrZSxcbiAgICBpc09iamVjdCxcbiAgICBpc0RlZmluZWQsXG4gICAgaXNDbGFzcyxcbiAgICBpc1ByaW1pdGl2ZSxcbiAgICBpc1Byb21pc2UsXG4gICAgaXNJdGVyYWJsZSxcbiAgICBpc1N0cmluZyxcbiAgICBpc0Z1bmN0aW9uXG4gIH07XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gaW5kZXg7XG4gIGV4cG9ydHMuaXNBcnJheUxpa2UgPSBpc0FycmF5TGlrZTtcbiAgZXhwb3J0cy5pc0NsYXNzID0gaXNDbGFzcztcbiAgZXhwb3J0cy5pc0RlZmluZWQgPSBpc0RlZmluZWQ7XG4gIGV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gIGV4cG9ydHMuaXNJdGVyYWJsZSA9IGlzSXRlcmFibGU7XG4gIGV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcbiAgZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuICBleHBvcnRzLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuICBleHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG4gIGV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuICBleHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IENJRCA9IHJlcXVpcmUoJ2NpZHMnKVxuY29uc3Qgd2l0aElzID0gcmVxdWlyZSgnY2xhc3MtaXMnKVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gaW1tdXRhYmxlIGJsb2NrIG9mIGRhdGEgdGhhdCBpcyB1bmlxdWVseSByZWZlcmVuY2VkIHdpdGggYSBjaWQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSAtIFRoZSBkYXRhIHRvIGJlIHN0b3JlZCBpbiB0aGUgYmxvY2sgYXMgYSBidWZmZXIuXG4gKiBAcGFyYW0ge0NJRH0gY2lkIC0gVGhlIGNpZCBvZiB0aGUgZGF0YVxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBibG9jayA9IG5ldyBCbG9jayhuZXcgQnVmZmVyKCdhMDEyZDgzYjIwZjkzNzEuLi4nKSlcbiAqL1xuY2xhc3MgQmxvY2sge1xuICBjb25zdHJ1Y3RvciAoZGF0YSwgY2lkKSB7XG4gICAgaWYgKCFkYXRhIHx8ICFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgIG11c3QgYmUgYSBidWZmZXInKVxuICAgIH1cblxuICAgIGlmICghY2lkIHx8ICFDSUQuaXNDSUQoY2lkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIENJRCcpXG4gICAgfVxuXG4gICAgdGhpcy5fZGF0YSA9IGRhdGFcbiAgICB0aGlzLl9jaWQgPSBjaWRcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZGF0YSBvZiB0aGlzIGJsb2NrLlxuICAgKlxuICAgKiBAdHlwZSB7QnVmZmVyfVxuICAgKi9cbiAgZ2V0IGRhdGEgKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhXG4gIH1cblxuICBzZXQgZGF0YSAodmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmllZCB0byBjaGFuZ2UgYW4gaW1tdXRhYmxlIGJsb2NrJylcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY2lkIG9mIHRoZSBkYXRhIHRoaXMgYmxvY2sgcmVwcmVzZW50cy5cbiAgICpcbiAgICogQHR5cGUge0NJRH1cbiAgICovXG4gIGdldCBjaWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9jaWRcbiAgfVxuXG4gIHNldCBjaWQgKHZhbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgdG8gY2hhbmdlIGFuIGltbXV0YWJsZSBibG9jaycpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aXRoSXMoQmxvY2ssIHsgY2xhc3NOYW1lOiAnQmxvY2snLCBzeW1ib2xOYW1lOiAnQGlwZnMvanMtaXBmcy1ibG9jay9ibG9jaycgfSlcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi9iYXNlLmpzJylcbmNvbnN0IGJhc2VYID0gcmVxdWlyZSgnYmFzZS14JylcbmNvbnN0IGJhc2UxNiA9IHJlcXVpcmUoJy4vYmFzZTE2JylcbmNvbnN0IGJhc2UzMiA9IHJlcXVpcmUoJy4vYmFzZTMyJylcbmNvbnN0IGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0JylcblxuLy8gbmFtZSwgY29kZSwgaW1wbGVtZW50YXRpb24sIGFscGhhYmV0XG5jb25zdCBjb25zdGFudHMgPSBbXG4gIFsnYmFzZTEnLCAnMScsICcnLCAnMSddLFxuICBbJ2Jhc2UyJywgJzAnLCBiYXNlWCwgJzAxJ10sXG4gIFsnYmFzZTgnLCAnNycsIGJhc2VYLCAnMDEyMzQ1NjcnXSxcbiAgWydiYXNlMTAnLCAnOScsIGJhc2VYLCAnMDEyMzQ1Njc4OSddLFxuICBbJ2Jhc2UxNicsICdmJywgYmFzZTE2LCAnMDEyMzQ1Njc4OWFiY2RlZiddLFxuICBbJ2Jhc2UzMicsICdiJywgYmFzZTMyLCAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjcnXSxcbiAgWydiYXNlMzJwYWQnLCAnYycsIGJhc2UzMiwgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3PSddLFxuICBbJ2Jhc2UzMmhleCcsICd2JywgYmFzZTMyLCAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXYnXSxcbiAgWydiYXNlMzJoZXhwYWQnLCAndCcsIGJhc2UzMiwgJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2PSddLFxuICBbJ2Jhc2UzMnonLCAnaCcsIGJhc2UzMiwgJ3libmRyZmc4ZWprbWNwcXhvdDF1d2lzemEzNDVoNzY5J10sXG4gIFsnYmFzZTU4ZmxpY2tyJywgJ1onLCBiYXNlWCwgJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonXSxcbiAgWydiYXNlNThidGMnLCAneicsIGJhc2VYLCAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eiddLFxuICBbJ2Jhc2U2NCcsICdtJywgYmFzZTY0LCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyddLFxuICBbJ2Jhc2U2NHBhZCcsICdNJywgYmFzZTY0LCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nXSxcbiAgWydiYXNlNjR1cmwnLCAndScsIGJhc2U2NCwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nXSxcbiAgWydiYXNlNjR1cmxwYWQnLCAnVScsIGJhc2U2NCwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV89J11cbl1cblxuY29uc3QgbmFtZXMgPSBjb25zdGFudHMucmVkdWNlKChwcmV2LCB0dXBwbGUpID0+IHtcbiAgcHJldlt0dXBwbGVbMF1dID0gbmV3IEJhc2UodHVwcGxlWzBdLCB0dXBwbGVbMV0sIHR1cHBsZVsyXSwgdHVwcGxlWzNdKVxuICByZXR1cm4gcHJldlxufSwge30pXG5cbmNvbnN0IGNvZGVzID0gY29uc3RhbnRzLnJlZHVjZSgocHJldiwgdHVwcGxlKSA9PiB7XG4gIHByZXZbdHVwcGxlWzFdXSA9IG5hbWVzW3R1cHBsZVswXV1cbiAgcmV0dXJuIHByZXZcbn0sIHt9KVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZXM6IG5hbWVzLFxuICBjb2RlczogY29kZXNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBQcm90b2NvbHMgKHByb3RvKSB7XG4gIGlmICh0eXBlb2YgKHByb3RvKSA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoUHJvdG9jb2xzLmNvZGVzW3Byb3RvXSkge1xuICAgICAgcmV0dXJuIFByb3RvY29scy5jb2Rlc1twcm90b11cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHByb3RvY29sIHdpdGggY29kZTogJyArIHByb3RvKVxuICB9IGVsc2UgaWYgKHR5cGVvZiAocHJvdG8pID09PSAnc3RyaW5nJyB8fCBwcm90byBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgIGlmIChQcm90b2NvbHMubmFtZXNbcHJvdG9dKSB7XG4gICAgICByZXR1cm4gUHJvdG9jb2xzLm5hbWVzW3Byb3RvXVxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignbm8gcHJvdG9jb2wgd2l0aCBuYW1lOiAnICsgcHJvdG8pXG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJvdG9jb2wgaWQgdHlwZTogJyArIHByb3RvKVxufVxuXG5jb25zdCBWID0gLTFcblByb3RvY29scy5sZW5ndGhQcmVmaXhlZFZhclNpemUgPSBWXG5Qcm90b2NvbHMuViA9IFZcblxuUHJvdG9jb2xzLnRhYmxlID0gW1xuICBbNCwgMzIsICdpcDQnXSxcbiAgWzYsIDE2LCAndGNwJ10sXG4gIFszMywgMTYsICdkY2NwJ10sXG4gIFs0MSwgMTI4LCAnaXA2J10sXG4gIFs0MiwgViwgJ2lwNnpvbmUnXSxcbiAgWzUzLCBWLCAnZG5zJywgJ3Jlc29sdmFibGUnXSxcbiAgWzU0LCBWLCAnZG5zNCcsICdyZXNvbHZhYmxlJ10sXG4gIFs1NSwgViwgJ2RuczYnLCAncmVzb2x2YWJsZSddLFxuICBbNTYsIFYsICdkbnNhZGRyJywgJ3Jlc29sdmFibGUnXSxcbiAgWzEzMiwgMTYsICdzY3RwJ10sXG4gIFsyNzMsIDE2LCAndWRwJ10sXG4gIFsyNzUsIDAsICdwMnAtd2VicnRjLXN0YXInXSxcbiAgWzI3NiwgMCwgJ3AycC13ZWJydGMtZGlyZWN0J10sXG4gIFsyNzcsIDAsICdwMnAtc3RhcmR1c3QnXSxcbiAgWzI5MCwgMCwgJ3AycC1jaXJjdWl0J10sXG4gIFszMDEsIDAsICd1ZHQnXSxcbiAgWzMwMiwgMCwgJ3V0cCddLFxuICBbNDAwLCBWLCAndW5peCcsIGZhbHNlLCAncGF0aCddLFxuICAvLyBgcDJwYCBpcyB0aGUgcHJlZmVycmVkIG5hbWUgZm9yIDQyMVxuICBbNDIxLCBWLCAncDJwJ10sXG4gIC8vIGBpcGZzYCBoYXMgYmVlbiBhZGRlZCBhZnRlciBgcDJwYCBzbyB0aGF0IGl0IGlzIHVzZWQgYnkgZGVmYXVsdC5cbiAgLy8gVGhlIHJlYXNvbiBmb3IgdGhpcyBpcyB0byBwcm92aWRlIGJldHRlciBiYWNrd2FyZHMgc3VwcG9ydCBmb3JcbiAgLy8gY29kZSBiYXNlcyB0aGF0IGRvIG5vdCB5ZXQgc3VwcG9ydCB0aGUgYHAycGAgcHJvdG8gbmFtZS4gRXZlbnR1YWxseVxuICAvLyBgcDJwYCBzaG91bGQgYmVjb21lIHRoZSBkZWZhdWx0LlxuICBbNDIxLCBWLCAnaXBmcyddLFxuICBbNDQzLCAwLCAnaHR0cHMnXSxcbiAgWzQ0NCwgOTYsICdvbmlvbiddLFxuICBbNDQ1LCAyOTYsICdvbmlvbjMnXSxcbiAgWzQ0NiwgViwgJ2dhcmxpYzY0J10sXG4gIFs0NjAsIDAsICdxdWljJ10sXG4gIFs0NzcsIDAsICd3cyddLFxuICBbNDc4LCAwLCAnd3NzJ10sXG4gIFs0NzksIDAsICdwMnAtd2Vic29ja2V0LXN0YXInXSxcbiAgWzQ4MCwgMCwgJ2h0dHAnXVxuXVxuXG5Qcm90b2NvbHMubmFtZXMgPSB7fVxuUHJvdG9jb2xzLmNvZGVzID0ge31cblxuLy8gcG9wdWxhdGUgdGFibGVzXG5Qcm90b2NvbHMudGFibGUubWFwKHJvdyA9PiB7XG4gIGNvbnN0IHByb3RvID0gcC5hcHBseShudWxsLCByb3cpXG4gIFByb3RvY29scy5jb2Rlc1twcm90by5jb2RlXSA9IHByb3RvXG4gIFByb3RvY29scy5uYW1lc1twcm90by5uYW1lXSA9IHByb3RvXG59KVxuXG5Qcm90b2NvbHMub2JqZWN0ID0gcFxuXG5mdW5jdGlvbiBwIChjb2RlLCBzaXplLCBuYW1lLCByZXNvbHZhYmxlLCBwYXRoKSB7XG4gIHJldHVybiB7XG4gICAgY29kZTogY29kZSxcbiAgICBzaXplOiBzaXplLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcmVzb2x2YWJsZTogQm9vbGVhbihyZXNvbHZhYmxlKSxcbiAgICBwYXRoOiBCb29sZWFuKHBhdGgpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcm90b2NvbHNcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb252ZXJ0ID0gcmVxdWlyZSgnLi9jb252ZXJ0JylcbmNvbnN0IHByb3RvY29scyA9IHJlcXVpcmUoJy4vcHJvdG9jb2xzLXRhYmxlJylcbmNvbnN0IHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG5cbi8vIGV4cG9ydCBjb2RlY1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0cmluZ1RvU3RyaW5nVHVwbGVzOiBzdHJpbmdUb1N0cmluZ1R1cGxlcyxcbiAgc3RyaW5nVHVwbGVzVG9TdHJpbmc6IHN0cmluZ1R1cGxlc1RvU3RyaW5nLFxuXG4gIHR1cGxlc1RvU3RyaW5nVHVwbGVzOiB0dXBsZXNUb1N0cmluZ1R1cGxlcyxcbiAgc3RyaW5nVHVwbGVzVG9UdXBsZXM6IHN0cmluZ1R1cGxlc1RvVHVwbGVzLFxuXG4gIGJ1ZmZlclRvVHVwbGVzOiBidWZmZXJUb1R1cGxlcyxcbiAgdHVwbGVzVG9CdWZmZXI6IHR1cGxlc1RvQnVmZmVyLFxuXG4gIGJ1ZmZlclRvU3RyaW5nOiBidWZmZXJUb1N0cmluZyxcbiAgc3RyaW5nVG9CdWZmZXI6IHN0cmluZ1RvQnVmZmVyLFxuXG4gIGZyb21TdHJpbmc6IGZyb21TdHJpbmcsXG4gIGZyb21CdWZmZXI6IGZyb21CdWZmZXIsXG4gIHZhbGlkYXRlQnVmZmVyOiB2YWxpZGF0ZUJ1ZmZlcixcbiAgaXNWYWxpZEJ1ZmZlcjogaXNWYWxpZEJ1ZmZlcixcbiAgY2xlYW5QYXRoOiBjbGVhblBhdGgsXG5cbiAgUGFyc2VFcnJvcjogUGFyc2VFcnJvcixcbiAgcHJvdG9Gcm9tVHVwbGU6IHByb3RvRnJvbVR1cGxlLFxuXG4gIHNpemVGb3JBZGRyOiBzaXplRm9yQWRkclxufVxuXG4vLyBzdHJpbmcgLT4gW1tzdHIgbmFtZSwgc3RyIGFkZHJdLi4uIF1cbmZ1bmN0aW9uIHN0cmluZ1RvU3RyaW5nVHVwbGVzIChzdHIpIHtcbiAgY29uc3QgdHVwbGVzID0gW11cbiAgY29uc3QgcGFydHMgPSBzdHIuc3BsaXQoJy8nKS5zbGljZSgxKSAvLyBza2lwIGZpcnN0IGVtcHR5IGVsZW1cbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSAmJiBwYXJ0c1swXSA9PT0gJycpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIGZvciAobGV0IHAgPSAwOyBwIDwgcGFydHMubGVuZ3RoOyBwKyspIHtcbiAgICBjb25zdCBwYXJ0ID0gcGFydHNbcF1cbiAgICBjb25zdCBwcm90byA9IHByb3RvY29scyhwYXJ0KVxuXG4gICAgaWYgKHByb3RvLnNpemUgPT09IDApIHtcbiAgICAgIHR1cGxlcy5wdXNoKFtwYXJ0XSlcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgcCsrIC8vIGFkdmFuY2UgYWRkciBwYXJ0XG4gICAgaWYgKHAgPj0gcGFydHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBQYXJzZUVycm9yKCdpbnZhbGlkIGFkZHJlc3M6ICcgKyBzdHIpXG4gICAgfVxuXG4gICAgLy8gaWYgaXQncyBhIHBhdGggcHJvdG8sIHRha2UgdGhlIHJlc3RcbiAgICBpZiAocHJvdG8ucGF0aCkge1xuICAgICAgdHVwbGVzLnB1c2goW1xuICAgICAgICBwYXJ0LFxuICAgICAgICAvLyBUT0RPOiBzaG91bGQgd2UgbmVlZCB0byBjaGVjayBlYWNoIHBhdGggcGFydCB0byBzZWUgaWYgaXQncyBhIHByb3RvP1xuICAgICAgICAvLyBUaGlzIHdvdWxkIGFsbG93IGZvciBvdGhlciBwcm90b2NvbHMgdG8gYmUgYWRkZWQgYWZ0ZXIgYSB1bml4IHBhdGgsXG4gICAgICAgIC8vIGhvd2V2ZXIgaXQgd291bGQgaGF2ZSBpc3N1ZXMgaWYgdGhlIHBhdGggaGFkIGEgcHJvdG9jb2wgbmFtZSBpbiB0aGUgcGF0aFxuICAgICAgICBjbGVhblBhdGgocGFydHMuc2xpY2UocCkuam9pbignLycpKVxuICAgICAgXSlcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgdHVwbGVzLnB1c2goW3BhcnQsIHBhcnRzW3BdXSlcbiAgfVxuXG4gIHJldHVybiB0dXBsZXNcbn1cblxuLy8gW1tzdHIgbmFtZSwgc3RyIGFkZHJdLi4uIF0gLT4gc3RyaW5nXG5mdW5jdGlvbiBzdHJpbmdUdXBsZXNUb1N0cmluZyAodHVwbGVzKSB7XG4gIGNvbnN0IHBhcnRzID0gW11cbiAgdHVwbGVzLm1hcCh0dXAgPT4ge1xuICAgIGNvbnN0IHByb3RvID0gcHJvdG9Gcm9tVHVwbGUodHVwKVxuICAgIHBhcnRzLnB1c2gocHJvdG8ubmFtZSlcbiAgICBpZiAodHVwLmxlbmd0aCA+IDEpIHtcbiAgICAgIHBhcnRzLnB1c2godHVwWzFdKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gY2xlYW5QYXRoKHBhcnRzLmpvaW4oJy8nKSlcbn1cblxuLy8gW1tzdHIgbmFtZSwgc3RyIGFkZHJdLi4uIF0gLT4gW1tpbnQgY29kZSwgQnVmZmVyXS4uLiBdXG5mdW5jdGlvbiBzdHJpbmdUdXBsZXNUb1R1cGxlcyAodHVwbGVzKSB7XG4gIHJldHVybiB0dXBsZXMubWFwKHR1cCA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR1cCkpIHtcbiAgICAgIHR1cCA9IFt0dXBdXG4gICAgfVxuICAgIGNvbnN0IHByb3RvID0gcHJvdG9Gcm9tVHVwbGUodHVwKVxuICAgIGlmICh0dXAubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIFtwcm90by5jb2RlLCBjb252ZXJ0LnRvQnVmZmVyKHByb3RvLmNvZGUsIHR1cFsxXSldXG4gICAgfVxuICAgIHJldHVybiBbcHJvdG8uY29kZV1cbiAgfSlcbn1cblxuLy8gW1tpbnQgY29kZSwgQnVmZmVyXS4uLiBdIC0+IFtbc3RyIG5hbWUsIHN0ciBhZGRyXS4uLiBdXG5mdW5jdGlvbiB0dXBsZXNUb1N0cmluZ1R1cGxlcyAodHVwbGVzKSB7XG4gIHJldHVybiB0dXBsZXMubWFwKHR1cCA9PiB7XG4gICAgY29uc3QgcHJvdG8gPSBwcm90b0Zyb21UdXBsZSh0dXApXG4gICAgaWYgKHR1cC5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gW3Byb3RvLmNvZGUsIGNvbnZlcnQudG9TdHJpbmcocHJvdG8uY29kZSwgdHVwWzFdKV1cbiAgICB9XG4gICAgcmV0dXJuIFtwcm90by5jb2RlXVxuICB9KVxufVxuXG4vLyBbW2ludCBjb2RlLCBCdWZmZXIgXS4uLiBdIC0+IEJ1ZmZlclxuZnVuY3Rpb24gdHVwbGVzVG9CdWZmZXIgKHR1cGxlcykge1xuICByZXR1cm4gZnJvbUJ1ZmZlcihCdWZmZXIuY29uY2F0KHR1cGxlcy5tYXAodHVwID0+IHtcbiAgICBjb25zdCBwcm90byA9IHByb3RvRnJvbVR1cGxlKHR1cClcbiAgICBsZXQgYnVmID0gQnVmZmVyLmZyb20odmFyaW50LmVuY29kZShwcm90by5jb2RlKSlcblxuICAgIGlmICh0dXAubGVuZ3RoID4gMSkge1xuICAgICAgYnVmID0gQnVmZmVyLmNvbmNhdChbYnVmLCB0dXBbMV1dKSAvLyBhZGQgYWRkcmVzcyBidWZmZXJcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmXG4gIH0pKSlcbn1cblxuZnVuY3Rpb24gc2l6ZUZvckFkZHIgKHAsIGFkZHIpIHtcbiAgaWYgKHAuc2l6ZSA+IDApIHtcbiAgICByZXR1cm4gcC5zaXplIC8gOFxuICB9IGVsc2UgaWYgKHAuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiAwXG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc2l6ZSA9IHZhcmludC5kZWNvZGUoYWRkcilcbiAgICByZXR1cm4gc2l6ZSArIHZhcmludC5kZWNvZGUuYnl0ZXNcbiAgfVxufVxuXG4vLyBCdWZmZXIgLT4gW1tpbnQgY29kZSwgQnVmZmVyIF0uLi4gXVxuZnVuY3Rpb24gYnVmZmVyVG9UdXBsZXMgKGJ1Zikge1xuICBjb25zdCB0dXBsZXMgPSBbXVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKGkgPCBidWYubGVuZ3RoKSB7XG4gICAgY29uc3QgY29kZSA9IHZhcmludC5kZWNvZGUoYnVmLCBpKVxuICAgIGNvbnN0IG4gPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG5cbiAgICBjb25zdCBwID0gcHJvdG9jb2xzKGNvZGUpXG5cbiAgICBjb25zdCBzaXplID0gc2l6ZUZvckFkZHIocCwgYnVmLnNsaWNlKGkgKyBuKSlcblxuICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICB0dXBsZXMucHVzaChbY29kZV0pXG4gICAgICBpICs9IG5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgY29uc3QgYWRkciA9IGJ1Zi5zbGljZShpICsgbiwgaSArIG4gKyBzaXplKVxuXG4gICAgaSArPSAoc2l6ZSArIG4pXG5cbiAgICBpZiAoaSA+IGJ1Zi5sZW5ndGgpIHsgLy8gZGlkIG5vdCBlbmQgX2V4YWN0bHlfIGF0IGJ1ZmZlci5sZW5ndGhcbiAgICAgIHRocm93IFBhcnNlRXJyb3IoJ0ludmFsaWQgYWRkcmVzcyBidWZmZXI6ICcgKyBidWYudG9TdHJpbmcoJ2hleCcpKVxuICAgIH1cblxuICAgIC8vIG9rLCB0dXBsZSBzZWVtcyBnb29kLlxuICAgIHR1cGxlcy5wdXNoKFtjb2RlLCBhZGRyXSlcbiAgfVxuXG4gIHJldHVybiB0dXBsZXNcbn1cblxuLy8gQnVmZmVyIC0+IFN0cmluZ1xuZnVuY3Rpb24gYnVmZmVyVG9TdHJpbmcgKGJ1Zikge1xuICBjb25zdCBhID0gYnVmZmVyVG9UdXBsZXMoYnVmKVxuICBjb25zdCBiID0gdHVwbGVzVG9TdHJpbmdUdXBsZXMoYSlcbiAgcmV0dXJuIHN0cmluZ1R1cGxlc1RvU3RyaW5nKGIpXG59XG5cbi8vIFN0cmluZyAtPiBCdWZmZXJcbmZ1bmN0aW9uIHN0cmluZ1RvQnVmZmVyIChzdHIpIHtcbiAgc3RyID0gY2xlYW5QYXRoKHN0cilcbiAgY29uc3QgYSA9IHN0cmluZ1RvU3RyaW5nVHVwbGVzKHN0cilcbiAgY29uc3QgYiA9IHN0cmluZ1R1cGxlc1RvVHVwbGVzKGEpXG5cbiAgcmV0dXJuIHR1cGxlc1RvQnVmZmVyKGIpXG59XG5cbi8vIFN0cmluZyAtPiBCdWZmZXJcbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cikge1xuICByZXR1cm4gc3RyaW5nVG9CdWZmZXIoc3RyKVxufVxuXG4vLyBCdWZmZXIgLT4gQnVmZmVyXG5mdW5jdGlvbiBmcm9tQnVmZmVyIChidWYpIHtcbiAgY29uc3QgZXJyID0gdmFsaWRhdGVCdWZmZXIoYnVmKVxuICBpZiAoZXJyKSB0aHJvdyBlcnJcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ1ZikgLy8gY29weVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUJ1ZmZlciAoYnVmKSB7XG4gIHRyeSB7XG4gICAgYnVmZmVyVG9UdXBsZXMoYnVmKSAvLyB0cnkgdG8gcGFyc2UuIHdpbGwgdGhyb3cgaWYgYnJlYWtzXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBlcnJcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkQnVmZmVyIChidWYpIHtcbiAgcmV0dXJuIHZhbGlkYXRlQnVmZmVyKGJ1ZikgPT09IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBjbGVhblBhdGggKHN0cikge1xuICByZXR1cm4gJy8nICsgc3RyLnRyaW0oKS5zcGxpdCgnLycpLmZpbHRlcihhID0+IGEpLmpvaW4oJy8nKVxufVxuXG5mdW5jdGlvbiBQYXJzZUVycm9yIChzdHIpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcignRXJyb3IgcGFyc2luZyBhZGRyZXNzOiAnICsgc3RyKVxufVxuXG5mdW5jdGlvbiBwcm90b0Zyb21UdXBsZSAodHVwKSB7XG4gIGNvbnN0IHByb3RvID0gcHJvdG9jb2xzKHR1cFswXSlcbiAgcmV0dXJuIHByb3RvXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3Qgc2hhMyA9IHJlcXVpcmUoJ2pzLXNoYTMnKVxuY29uc3QgbXVybXVyMyA9IHJlcXVpcmUoJ211cm11cmhhc2gzanMnKVxuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3Qgc2hhID0gcmVxdWlyZSgnLi9jcnlwdG8tc2hhMS0yJylcblxuY29uc3QgdG9DYWxsYmFjayA9IHV0aWxzLnRvQ2FsbGJhY2tcbmNvbnN0IHRvQnVmID0gdXRpbHMudG9CdWZcbmNvbnN0IGZyb21TdHJpbmcgPSB1dGlscy5mcm9tU3RyaW5nXG5jb25zdCBmcm9tTnVtYmVyVG8zMkJpdEJ1ZiA9IHV0aWxzLmZyb21OdW1iZXJUbzMyQml0QnVmXG5cbmNvbnN0IGRibFNoYTIyNTYgPSAoYnVmLCBjYikgPT4ge1xuICBzaGEuc2hhMjI1NihidWYsIChlcnIsIGZpcnN0SGFzaCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNiKGVycilcbiAgICB9XG4gICAgc2hhLnNoYTIyNTYoKEJ1ZmZlci5mcm9tKGZpcnN0SGFzaCkpLCBjYilcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNoYTE6IHNoYS5zaGExLFxuICBzaGEyMjU2OiBzaGEuc2hhMjI1NixcbiAgc2hhMjUxMjogc2hhLnNoYTI1MTIsXG4gIHNoYTM1MTI6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5zaGEzXzUxMikpLFxuICBzaGEzMzg0OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMuc2hhM18zODQpKSxcbiAgc2hhMzI1NjogdG9DYWxsYmFjayh0b0J1ZihzaGEzLnNoYTNfMjU2KSksXG4gIHNoYTMyMjQ6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5zaGEzXzIyNCkpLFxuICBzaGFrZTEyODogdG9DYWxsYmFjayh0b0J1ZihzaGEzLnNoYWtlXzEyOCwgMTI4KSksXG4gIHNoYWtlMjU2OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMuc2hha2VfMjU2LCAyNTYpKSxcbiAga2VjY2FrMjI0OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMua2VjY2FrXzIyNCkpLFxuICBrZWNjYWsyNTY6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5rZWNjYWtfMjU2KSksXG4gIGtlY2NhazM4NDogdG9DYWxsYmFjayh0b0J1ZihzaGEzLmtlY2Nha18zODQpKSxcbiAga2VjY2FrNTEyOiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMua2VjY2FrXzUxMikpLFxuICBtdXJtdXIzMTI4OiB0b0NhbGxiYWNrKHRvQnVmKGZyb21TdHJpbmcobXVybXVyMy54NjQuaGFzaDEyOCkpKSxcbiAgbXVybXVyMzMyOiB0b0NhbGxiYWNrKGZyb21OdW1iZXJUbzMyQml0QnVmKGZyb21TdHJpbmcobXVybXVyMy54ODYuaGFzaDMyKSkpLFxuICBhZGRCbGFrZTogcmVxdWlyZSgnLi9ibGFrZScpLFxuICBkYmxTaGEyMjU2OiBkYmxTaGEyMjU2XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3Qgbm9kZWlmeSA9IHJlcXVpcmUoJy4uL25vZGVpZnknKVxuXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCcuLi93ZWJjcnlwdG8nKVxuY29uc3QgbGVuZ3RocyA9IHJlcXVpcmUoJy4vbGVuZ3RocycpXG5cbmNvbnN0IGhhc2hUeXBlcyA9IHtcbiAgU0hBMTogJ1NIQS0xJyxcbiAgU0hBMjU2OiAnU0hBLTI1NicsXG4gIFNIQTUxMjogJ1NIQS01MTInXG59XG5cbmNvbnN0IHNpZ24gPSAoa2V5LCBkYXRhLCBjYikgPT4ge1xuICBub2RlaWZ5KGNyeXB0by5zdWJ0bGUuc2lnbih7IG5hbWU6ICdITUFDJyB9LCBrZXksIGRhdGEpXG4gICAgLnRoZW4oKHJhdykgPT4gQnVmZmVyLmZyb20ocmF3KSksIGNiKVxufVxuXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIChoYXNoVHlwZSwgc2VjcmV0LCBjYWxsYmFjaykge1xuICBjb25zdCBoYXNoID0gaGFzaFR5cGVzW2hhc2hUeXBlXVxuXG4gIG5vZGVpZnkoY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXG4gICAgJ3JhdycsXG4gICAgc2VjcmV0LFxuICAgIHtcbiAgICAgIG5hbWU6ICdITUFDJyxcbiAgICAgIGhhc2g6IHsgbmFtZTogaGFzaCB9XG4gICAgfSxcbiAgICBmYWxzZSxcbiAgICBbJ3NpZ24nXVxuICApLnRoZW4oKGtleSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBkaWdlc3QgKGRhdGEsIGNiKSB7XG4gICAgICAgIHNpZ24oa2V5LCBkYXRhLCBjYilcbiAgICAgIH0sXG4gICAgICBsZW5ndGg6IGxlbmd0aHNbaGFzaFR5cGVdXG4gICAgfVxuICB9KSwgY2FsbGJhY2spXG59XG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IHJhbmRvbUJ5dGVzID0gcmVxdWlyZSgnaXNvLXJhbmRvbS1zdHJlYW0vc3JjL3JhbmRvbScpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG51bWJlcikge1xuICBpZiAoIW51bWJlciB8fCB0eXBlb2YgbnVtYmVyICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIE51bWJlciBiaWdnZXIgdGhhbiAwJylcbiAgfVxuICByZXR1cm4gcmFuZG9tQnl0ZXMobnVtYmVyKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNpcGhlcnMgPSByZXF1aXJlKCcuL2NpcGhlcnMnKVxuXG5jb25zdCBDSVBIRVJfTU9ERVMgPSB7XG4gIDE2OiAnYWVzLTEyOC1jdHInLFxuICAzMjogJ2Flcy0yNTYtY3RyJ1xufVxuXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIChrZXksIGl2LCBjYWxsYmFjaykge1xuICBjb25zdCBtb2RlID0gQ0lQSEVSX01PREVTW2tleS5sZW5ndGhdXG4gIGlmICghbW9kZSkge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0ludmFsaWQga2V5IGxlbmd0aCcpKVxuICB9XG5cbiAgY29uc3QgY2lwaGVyID0gY2lwaGVycy5jcmVhdGVDaXBoZXJpdihtb2RlLCBrZXksIGl2KVxuICBjb25zdCBkZWNpcGhlciA9IGNpcGhlcnMuY3JlYXRlRGVjaXBoZXJpdihtb2RlLCBrZXksIGl2KVxuXG4gIGNvbnN0IHJlcyA9IHtcbiAgICBlbmNyeXB0IChkYXRhLCBjYikge1xuICAgICAgY2IobnVsbCwgY2lwaGVyLnVwZGF0ZShkYXRhKSlcbiAgICB9LFxuXG4gICAgZGVjcnlwdCAoZGF0YSwgY2IpIHtcbiAgICAgIGNiKG51bGwsIGRlY2lwaGVyLnVwZGF0ZShkYXRhKSlcbiAgICB9XG4gIH1cblxuICBjYWxsYmFjayhudWxsLCByZXMpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZm9yZ2VQYmtkZjIgPSByZXF1aXJlKCdub2RlLWZvcmdlL2xpYi9wYmtkZjInKVxuY29uc3QgZm9yZ2VVdGlsID0gcmVxdWlyZSgnbm9kZS1mb3JnZS9saWIvdXRpbCcpXG5cbi8qKlxuICogTWFwcyBhbiBJUEZTIGhhc2ggbmFtZSB0byBpdHMgbm9kZS1mb3JnZSBlcXVpdmFsZW50LlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL211bHRpaGFzaC9ibG9iL21hc3Rlci9oYXNodGFibGUuY3N2XG4gKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaGFzaE5hbWUgPSB7XG4gIHNoYTE6ICdzaGExJyxcbiAgJ3NoYTItMjU2JzogJ3NoYTI1NicsXG4gICdzaGEyLTUxMic6ICdzaGE1MTInXG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFBhc3N3b3JkLUJhc2VkIEtleSBEZXJpdmF0aW9uIEZ1bmN0aW9uIDIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gKiBAcGFyYW0ge3N0cmluZ30gc2FsdFxuICogQHBhcmFtIHtudW1iZXJ9IGl0ZXJhdGlvbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBrZXlTaXplIChpbiBieXRlcylcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIC0gVGhlIGhhc2ggbmFtZSAoJ3NoYTEnLCAnc2hhMi01MTIsIC4uLilcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gQSBuZXcgcGFzc3dvcmRcbiAqL1xuZnVuY3Rpb24gcGJrZGYyIChwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5U2l6ZSwgaGFzaCkge1xuICBjb25zdCBoYXNoZXIgPSBoYXNoTmFtZVtoYXNoXVxuICBpZiAoIWhhc2hlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgSGFzaCAnJHtoYXNofScgaXMgdW5rbm93biBvciBub3Qgc3VwcG9ydGVkYClcbiAgfVxuICBjb25zdCBkZWsgPSBmb3JnZVBia2RmMihcbiAgICBwYXNzd29yZCxcbiAgICBzYWx0LFxuICAgIGl0ZXJhdGlvbnMsXG4gICAga2V5U2l6ZSxcbiAgICBoYXNoZXIpXG4gIHJldHVybiBmb3JnZVV0aWwuZW5jb2RlNjQoZGVrKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBia2RmMlxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNPbmxpbmUgKHNlbGYpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByZXR1cm4gQm9vbGVhbihzZWxmLl9iaXRzd2FwICYmIHNlbGYubGlicDJwICYmIHNlbGYubGlicDJwLmlzU3RhcnRlZCgpKVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcGtnID0gcmVxdWlyZSgnLi4vLi4vLi4vcGFja2FnZS5qc29uJylcbmNvbnN0IHByb21pc2lmeSA9IHJlcXVpcmUoJ3Byb21pc2lmeS1lczYnKVxuXG4vLyBUT0RPIGFkZCB0aGUgY29tbWl0IGhhc2ggb2YgdGhlIGN1cnJlbnQgaXBmcyB2ZXJzaW9uIHRvIHRoZSByZXNwb25zZS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmVyc2lvbiAoc2VsZikge1xuICByZXR1cm4gcHJvbWlzaWZ5KChvcHRzLCBjYWxsYmFjaykgPT4ge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRzXG4gICAgICBvcHRzID0ge31cbiAgICB9XG5cbiAgICBzZWxmLnJlcG8udmVyc2lvbigoZXJyLCByZXBvVmVyc2lvbikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgIHZlcnNpb246IHBrZy52ZXJzaW9uLFxuICAgICAgICByZXBvOiByZXBvVmVyc2lvbixcbiAgICAgICAgY29tbWl0OiAnJ1xuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHByb21pc2lmeSA9IHJlcXVpcmUoJ3Byb21pc2lmeS1lczYnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbmZpZyAoc2VsZikge1xuICByZXR1cm4ge1xuICAgIGdldDogcHJvbWlzaWZ5KChrZXksIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IGtleVxuICAgICAgICBrZXkgPSB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuX3JlcG8uY29uZmlnLmdldChrZXksIGNhbGxiYWNrKVxuICAgIH0pLFxuICAgIHNldDogcHJvbWlzaWZ5KChrZXksIHZhbHVlLCBjYWxsYmFjaykgPT4ge1xuICAgICAgc2VsZi5fcmVwby5jb25maWcuc2V0KGtleSwgdmFsdWUsIGNhbGxiYWNrKVxuICAgIH0pLFxuICAgIHJlcGxhY2U6IHByb21pc2lmeSgoY29uZmlnLCBjYWxsYmFjaykgPT4ge1xuICAgICAgc2VsZi5fcmVwby5jb25maWcuc2V0KGNvbmZpZywgY2FsbGJhY2spXG4gICAgfSlcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8vIGRucy1ub2RlanMgZ2V0cyByZXBsYWNlZCBieSBkbnMtYnJvd3NlciB3aGVuIHdlYnBhY2tlZC9icm93c2VyaWZpZWRcbmNvbnN0IGRucyA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvZG5zLW5vZGVqcycpXG5jb25zdCBwcm9taXNpZnkgPSByZXF1aXJlKCdwcm9taXNpZnktZXM2JylcblxubW9kdWxlLmV4cG9ydHMgPSAoKSA9PiB7XG4gIHJldHVybiBwcm9taXNpZnkoKGRvbWFpbiwgb3B0cywgY2FsbGJhY2spID0+IHtcbiAgICBpZiAodHlwZW9mIGRvbWFpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzLCBkb21haW4gbXVzdCBiZSBhIHN0cmluZycpKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRzXG4gICAgICBvcHRzID0ge31cbiAgICB9XG5cbiAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgZG5zKGRvbWFpbiwgb3B0cywgY2FsbGJhY2spXG4gIH0pXG59XG4iLCIndXNlIHN0cmljdCdcblxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9pcGZzL3NwZWNzL3RyZWUvbWFzdGVyL2tleXN0b3JlXG5cbmNvbnN0IHByb21pc2lmeSA9IHJlcXVpcmUoJ3Byb21pc2lmeS1lczYnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGtleSAoc2VsZikge1xuICByZXR1cm4ge1xuICAgIGdlbjogcHJvbWlzaWZ5KChuYW1lLCBvcHRzLCBjYWxsYmFjaykgPT4ge1xuICAgICAgb3B0cyA9IG9wdHMgfHwge31cbiAgICAgIHNlbGYuX2tleWNoYWluLmNyZWF0ZUtleShuYW1lLCBvcHRzLnR5cGUsIG9wdHMuc2l6ZSwgY2FsbGJhY2spXG4gICAgfSksXG5cbiAgICBpbmZvOiBwcm9taXNpZnkoKG5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBzZWxmLl9rZXljaGFpbi5maW5kS2V5QnlOYW1lKG5hbWUsIGNhbGxiYWNrKVxuICAgIH0pLFxuXG4gICAgbGlzdDogcHJvbWlzaWZ5KChjYWxsYmFjaykgPT4ge1xuICAgICAgc2VsZi5fa2V5Y2hhaW4ubGlzdEtleXMoY2FsbGJhY2spXG4gICAgfSksXG5cbiAgICBybTogcHJvbWlzaWZ5KChuYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgc2VsZi5fa2V5Y2hhaW4ucmVtb3ZlS2V5KG5hbWUsIGNhbGxiYWNrKVxuICAgIH0pLFxuXG4gICAgcmVuYW1lOiBwcm9taXNpZnkoKG9sZE5hbWUsIG5ld05hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBzZWxmLl9rZXljaGFpbi5yZW5hbWVLZXkob2xkTmFtZSwgbmV3TmFtZSwgKGVyciwga2V5KSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICB3YXM6IG9sZE5hbWUsXG4gICAgICAgICAgbm93OiBrZXkubmFtZSxcbiAgICAgICAgICBpZDoga2V5LmlkLFxuICAgICAgICAgIG92ZXJ3cml0ZTogZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpXG4gICAgICB9KVxuICAgIH0pLFxuXG4gICAgaW1wb3J0OiBwcm9taXNpZnkoKG5hbWUsIHBlbSwgcGFzc3dvcmQsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBzZWxmLl9rZXljaGFpbi5pbXBvcnRLZXkobmFtZSwgcGVtLCBwYXNzd29yZCwgY2FsbGJhY2spXG4gICAgfSksXG5cbiAgICBleHBvcnQ6IHByb21pc2lmeSgobmFtZSwgcGFzc3dvcmQsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBzZWxmLl9rZXljaGFpbi5leHBvcnRLZXkobmFtZSwgcGFzc3dvcmQsIGNhbGxiYWNrKVxuICAgIH0pXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwcm9taXNpZnkgPSByZXF1aXJlKCdwcm9taXNpZnktZXM2JylcbmNvbnN0IHJlcG9WZXJzaW9uID0gcmVxdWlyZSgnaXBmcy1yZXBvJykucmVwb1ZlcnNpb25cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXBvIChzZWxmKSB7XG4gIHJldHVybiB7XG4gICAgaW5pdDogKGJpdHMsIGVtcHR5LCBjYWxsYmFjaykgPT4ge1xuICAgICAgLy8gMS4gY2hlY2sgaWYgcmVwbyBhbHJlYWR5IGV4aXN0c1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgcmVwbyBoYXMgYmVlbiBpbml0aWFsaXplZCwgcmVwb3J0IHRoZSBjdXJyZW50IHZlcnNpb24uXG4gICAgICogT3RoZXJ3aXNlIHJlcG9ydCB0aGUgdmVyc2lvbiB0aGF0IHdvdWxkIGJlIGluaXRpYWxpemVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgTnVtYmVyKX0gW2NhbGxiYWNrXVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgdmVyc2lvbjogcHJvbWlzaWZ5KChjYWxsYmFjaykgPT4ge1xuICAgICAgc2VsZi5fcmVwby5faXNJbml0aWFsaXplZChlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gVE9ETzogKGRyeWFqb3YpIFRoaXMgaXMgcmVhbGx5IGhhY2t5LCB0aGVyZSBtdXN0IGJlIGEgYmV0dGVyIHdheVxuICAgICAgICAgIGNvbnN0IG1hdGNoID0gW1xuICAgICAgICAgICAgL0tleSBub3QgZm91bmQgaW4gZGF0YWJhc2UgXFxbXFwvdmVyc2lvblxcXS8sXG4gICAgICAgICAgICAvRU5PRU5ULyxcbiAgICAgICAgICAgIC9yZXBvIGlzIG5vdCBpbml0aWFsaXplZCB5ZXQvXG4gICAgICAgICAgXS5zb21lKChtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbS50ZXN0KGVyci5tZXNzYWdlKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAvLyB0aGlzIHJlcG8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVwb1ZlcnNpb24pXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLl9yZXBvLnZlcnNpb24uZ2V0KGNhbGxiYWNrKVxuICAgICAgfSlcbiAgICB9KSxcblxuICAgIGdjOiBwcm9taXNpZnkoKG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICAgIG9wdGlvbnMgPSB7fVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpKVxuICAgIH0pLFxuXG4gICAgc3RhdDogcHJvbWlzaWZ5KChvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgICAgICBvcHRpb25zID0ge31cbiAgICAgIH1cblxuICAgICAgc2VsZi5fcmVwby5zdGF0KG9wdGlvbnMsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG5cbiAgICAgICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgIG51bU9iamVjdHM6IHN0YXRzLm51bU9iamVjdHMsXG4gICAgICAgICAgcmVwb1NpemU6IHN0YXRzLnJlcG9TaXplLFxuICAgICAgICAgIHJlcG9QYXRoOiBzdGF0cy5yZXBvUGF0aCxcbiAgICAgICAgICB2ZXJzaW9uOiBzdGF0cy52ZXJzaW9uLnRvU3RyaW5nKCksXG4gICAgICAgICAgc3RvcmFnZU1heDogc3RhdHMuc3RvcmFnZU1heFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KSxcblxuICAgIHBhdGg6ICgpID0+IHNlbGYuX3JlcG8ucGF0aFxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZGVmYXVsdENvbmZpZyA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvY29uZmlnLW5vZGVqcy5qcycpXG5jb25zdCBpc011bHRpYWRkciA9IHJlcXVpcmUoJ21hZm10JykuSVBGUy5tYXRjaGVzXG5jb25zdCBwcm9taXNpZnkgPSByZXF1aXJlKCdwcm9taXNpZnktZXM2JylcblxuZnVuY3Rpb24gaXNWYWxpZE11bHRpYWRkciAobWEpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXNNdWx0aWFkZHIobWEpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGludmFsaWRNdWx0aWFkZHJFcnJvciAobWEpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihgJHttYX0gaXMgbm90IGEgdmFsaWQgTXVsdGlhZGRyYClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBib290c3RyYXAgKHNlbGYpIHtcbiAgcmV0dXJuIHtcbiAgICBsaXN0OiBwcm9taXNpZnkoKGNhbGxiYWNrKSA9PiB7XG4gICAgICBzZWxmLl9yZXBvLmNvbmZpZy5nZXQoKGVyciwgY29uZmlnKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHsgUGVlcnM6IGNvbmZpZy5Cb290c3RyYXAgfSlcbiAgICAgIH0pXG4gICAgfSksXG4gICAgYWRkOiBwcm9taXNpZnkoKG11bHRpYWRkciwgYXJncywgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICh0eXBlb2YgYXJncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IGFyZ3NcbiAgICAgICAgYXJncyA9IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgICAgfVxuXG4gICAgICBpZiAobXVsdGlhZGRyICYmICFpc1ZhbGlkTXVsdGlhZGRyKG11bHRpYWRkcikpIHtcbiAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhpbnZhbGlkTXVsdGlhZGRyRXJyb3IobXVsdGlhZGRyKSkpXG4gICAgICB9XG5cbiAgICAgIHNlbGYuX3JlcG8uY29uZmlnLmdldCgoZXJyLCBjb25maWcpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3MuZGVmYXVsdCkge1xuICAgICAgICAgIGNvbmZpZy5Cb290c3RyYXAgPSBkZWZhdWx0Q29uZmlnKCkuQm9vdHN0cmFwXG4gICAgICAgIH0gZWxzZSBpZiAobXVsdGlhZGRyICYmIGNvbmZpZy5Cb290c3RyYXAuaW5kZXhPZihtdWx0aWFkZHIpID09PSAtMSkge1xuICAgICAgICAgIGNvbmZpZy5Cb290c3RyYXAucHVzaChtdWx0aWFkZHIpXG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5fcmVwby5jb25maWcuc2V0KGNvbmZpZywgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICAgUGVlcnM6IGFyZ3MuZGVmYXVsdCA/IGRlZmF1bHRDb25maWcoKS5Cb290c3RyYXAgOiBbbXVsdGlhZGRyXVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pLFxuICAgIHJtOiBwcm9taXNpZnkoKG11bHRpYWRkciwgYXJncywgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICh0eXBlb2YgYXJncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IGFyZ3NcbiAgICAgICAgYXJncyA9IHsgYWxsOiBmYWxzZSB9XG4gICAgICB9XG4gICAgICBpZiAobXVsdGlhZGRyICYmICFpc1ZhbGlkTXVsdGlhZGRyKG11bHRpYWRkcikpIHtcbiAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhpbnZhbGlkTXVsdGlhZGRyRXJyb3IobXVsdGlhZGRyKSkpXG4gICAgICB9XG5cbiAgICAgIHNlbGYuX3JlcG8uY29uZmlnLmdldCgoZXJyLCBjb25maWcpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3MuYWxsKSB7XG4gICAgICAgICAgY29uZmlnLkJvb3RzdHJhcCA9IFtdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uZmlnLkJvb3RzdHJhcCA9IGNvbmZpZy5Cb290c3RyYXAuZmlsdGVyKChtaCkgPT4gbWggIT09IG11bHRpYWRkcilcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuX3JlcG8uY29uZmlnLnNldChjb25maWcsIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlcyA9IFtdXG4gICAgICAgICAgaWYgKCFhcmdzLmFsbCAmJiBtdWx0aWFkZHIpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKG11bHRpYWRkcilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCB7IFBlZXJzOiByZXMgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgT0ZGTElORV9FUlJPUiA9IHJlcXVpcmUoJy4uL3V0aWxzJykuT0ZGTElORV9FUlJPUlxuY29uc3QgUGVlcklkID0gcmVxdWlyZSgncGVlci1pZCcpXG5jb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0nKVxuY29uc3QgUHVzaGFibGUgPSByZXF1aXJlKCdwdWxsLXB1c2hhYmxlJylcblxuY29uc3QgbG9nID0gZGVidWcoJ2lwZnM6cGluZ1B1bGxTdHJlYW0nKVxubG9nLmVycm9yID0gZGVidWcoJ2lwZnM6cGluZ1B1bGxTdHJlYW06ZXJyb3InKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBpbmdQdWxsU3RyZWFtIChzZWxmKSB7XG4gIHJldHVybiAocGVlcklkLCBvcHRzKSA9PiB7XG4gICAgaWYgKCFzZWxmLmlzT25saW5lKCkpIHtcbiAgICAgIHJldHVybiBwdWxsLmVycm9yKG5ldyBFcnJvcihPRkZMSU5FX0VSUk9SKSlcbiAgICB9XG5cbiAgICBvcHRzID0gT2JqZWN0LmFzc2lnbih7IGNvdW50OiAxMCB9LCBvcHRzKVxuXG4gICAgY29uc3Qgc291cmNlID0gUHVzaGFibGUoKVxuXG4gICAgZ2V0UGVlcihzZWxmLmxpYnAycCwgc291cmNlLCBwZWVySWQsIChlcnIsIHBlZXIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgbG9nLmVycm9yKGVycilcbiAgICAgICAgc291cmNlLmVuZChlcnIpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBydW5QaW5nKHNlbGYubGlicDJwLCBzb3VyY2UsIG9wdHMuY291bnQsIHBlZXIsIChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGxvZy5lcnJvcihlcnIpXG4gICAgICAgICAgc291cmNlLnB1c2goZ2V0UGFja2V0KHsgc3VjY2VzczogZmFsc2UsIHRleHQ6IGVyci50b1N0cmluZygpIH0pKVxuICAgICAgICAgIHNvdXJjZS5lbmQoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG5cbiAgICByZXR1cm4gc291cmNlXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UGFja2V0IChtc2cpIHtcbiAgLy8gRGVmYXVsdCBtc2dcbiAgY29uc3QgYmFzZVBhY2tldCA9IHsgc3VjY2VzczogdHJ1ZSwgdGltZTogMCwgdGV4dDogJycgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihiYXNlUGFja2V0LCBtc2cpXG59XG5cbmZ1bmN0aW9uIGdldFBlZXIgKGxpYnAycE5vZGUsIHN0YXR1c1N0cmVhbSwgcGVlcklkU3RyLCBjYikge1xuICBsZXQgcGVlcklkXG5cbiAgdHJ5IHtcbiAgICBwZWVySWQgPSBQZWVySWQuY3JlYXRlRnJvbUI1OFN0cmluZyhwZWVySWRTdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBjYihlcnIpXG4gIH1cblxuICBsZXQgcGVlckluZm9cblxuICB0cnkge1xuICAgIHBlZXJJbmZvID0gbGlicDJwTm9kZS5wZWVyQm9vay5nZXQocGVlcklkKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2coJ1BlZXIgbm90IGZvdW5kIGluIHBlZXIgYm9vaywgdHJ5aW5nIHBlZXIgcm91dGluZycpXG5cbiAgICAvLyBTaGFyZSBsb29rdXAgc3RhdHVzIGp1c3QgYXMgaW4gdGhlIGdvIGltcGxlbW1lbnRhdGlvblxuICAgIHN0YXR1c1N0cmVhbS5wdXNoKGdldFBhY2tldCh7IHRleHQ6IGBMb29raW5nIHVwIHBlZXIgJHtwZWVySWRTdHJ9YCB9KSlcbiAgICByZXR1cm4gbGlicDJwTm9kZS5wZWVyUm91dGluZy5maW5kUGVlcihwZWVySWQsIGNiKVxuICB9XG5cbiAgY2IobnVsbCwgcGVlckluZm8pXG59XG5cbmZ1bmN0aW9uIHJ1blBpbmcgKGxpYnAycE5vZGUsIHN0YXR1c1N0cmVhbSwgY291bnQsIHBlZXIsIGNiKSB7XG4gIGxpYnAycE5vZGUucGluZyhwZWVyLCAoZXJyLCBwKSA9PiB7XG4gICAgaWYgKGVycikgeyByZXR1cm4gY2IoZXJyKSB9XG5cbiAgICBsZXQgcGFja2V0Q291bnQgPSAwXG4gICAgbGV0IHRvdGFsVGltZSA9IDBcbiAgICBzdGF0dXNTdHJlYW0ucHVzaChnZXRQYWNrZXQoeyB0ZXh0OiBgUElORyAke3BlZXIuaWQudG9CNThTdHJpbmcoKX1gIH0pKVxuXG4gICAgcC5vbigncGluZycsICh0aW1lKSA9PiB7XG4gICAgICBzdGF0dXNTdHJlYW0ucHVzaChnZXRQYWNrZXQoeyB0aW1lIH0pKVxuICAgICAgdG90YWxUaW1lICs9IHRpbWVcbiAgICAgIHBhY2tldENvdW50KytcbiAgICAgIGlmIChwYWNrZXRDb3VudCA+PSBjb3VudCkge1xuICAgICAgICBjb25zdCBhdmVyYWdlID0gdG90YWxUaW1lIC8gY291bnRcbiAgICAgICAgcC5zdG9wKClcbiAgICAgICAgc3RhdHVzU3RyZWFtLnB1c2goZ2V0UGFja2V0KHsgdGV4dDogYEF2ZXJhZ2UgbGF0ZW5jeTogJHthdmVyYWdlfW1zYCB9KSlcbiAgICAgICAgc3RhdHVzU3RyZWFtLmVuZCgpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHAub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgbG9nLmVycm9yKGVycilcbiAgICAgIHAuc3RvcCgpXG4gICAgICBjYihlcnIpXG4gICAgfSlcblxuICAgIHAuc3RhcnQoKVxuICB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHRvU3RyZWFtID0gcmVxdWlyZSgncHVsbC1zdHJlYW0tdG8tc3RyZWFtJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwaW5nUmVhZGFibGVTdHJlYW0gKHNlbGYpIHtcbiAgcmV0dXJuIChwZWVySWQsIG9wdHMpID0+IHRvU3RyZWFtLnNvdXJjZShzZWxmLnBpbmdQdWxsU3RyZWFtKHBlZXJJZCwgb3B0cykpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcGFyYWxsZWwgPSByZXF1aXJlKCdhc3luYy9wYXJhbGxlbCcpXG5jb25zdCBwcm9taXNpZnkgPSByZXF1aXJlKCdwcm9taXNpZnktZXM2JylcblxubW9kdWxlLmV4cG9ydHMgPSAoc2VsZikgPT4ge1xuICByZXR1cm4gcHJvbWlzaWZ5KChjYWxsYmFjaykgPT4ge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG4gICAgc2VsZi5sb2coJ3N0b3AnKVxuXG4gICAgaWYgKHNlbGYuc3RhdGUuc3RhdGUoKSA9PT0gJ3N0b3BwZWQnKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdBbHJlYWR5IHN0b3BwZWQnKSlcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5zdGF0ZS5zdGF0ZSgpICE9PSAncnVubmluZycpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ05vdCBhYmxlIHRvIHN0b3AgZnJvbSBzdGF0ZTogJyArIHNlbGYuc3RhdGUuc3RhdGUoKSkpXG4gICAgfVxuXG4gICAgc2VsZi5zdGF0ZS5zdG9wKClcbiAgICBzZWxmLl9ibG9ja1NlcnZpY2UudW5zZXRFeGNoYW5nZSgpXG4gICAgc2VsZi5fYml0c3dhcC5zdG9wKClcbiAgICBzZWxmLl9wcmVsb2FkLnN0b3AoKVxuXG4gICAgcGFyYWxsZWwoW1xuICAgICAgY2IgPT4gc2VsZi5faXBucy5yZXB1Ymxpc2hlci5zdG9wKGNiKSxcbiAgICAgIGNiID0+IHNlbGYuX21mc1ByZWxvYWQuc3RvcChjYiksXG4gICAgICBjYiA9PiB7XG4gICAgICAgIGNvbnN0IGxpYnAycCA9IHNlbGYubGlicDJwXG4gICAgICAgIHNlbGYubGlicDJwID0gbnVsbFxuICAgICAgICBsaWJwMnAuc3RvcChjYilcbiAgICAgIH1cbiAgICBdLCBlcnIgPT4ge1xuICAgICAgc2VsZi5fcmVwby5jbG9zZShjbG9zZUVyciA9PiB7XG4gICAgICAgIGlmIChlcnIgfHwgY2xvc2VFcnIpIHtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyIHx8IGNsb3NlRXJyKVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIgfHwgY2xvc2VFcnIpXG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnN0YXRlLnN0b3BwZWQoKVxuICAgICAgICBzZWxmLmVtaXQoJ3N0b3AnKVxuICAgICAgICBjYWxsYmFjaygpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHJvbWlzaWZ5ID0gcmVxdWlyZSgncHJvbWlzaWZ5LWVzNicpXG5jb25zdCBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdhc3luYy9zZXRJbW1lZGlhdGUnKVxuY29uc3QgcGtndmVyc2lvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpZCAoc2VsZikge1xuICByZXR1cm4gcHJvbWlzaWZ5KChvcHRzLCBjYWxsYmFjaykgPT4ge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRzXG4gICAgICBvcHRzID0ge31cbiAgICB9XG5cbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2sobnVsbCwge1xuICAgICAgaWQ6IHNlbGYuX3BlZXJJbmZvLmlkLnRvQjU4U3RyaW5nKCksXG4gICAgICBwdWJsaWNLZXk6IHNlbGYuX3BlZXJJbmZvLmlkLnB1YktleS5ieXRlcy50b1N0cmluZygnYmFzZTY0JyksXG4gICAgICBhZGRyZXNzZXM6IHNlbGYuX3BlZXJJbmZvLm11bHRpYWRkcnNcbiAgICAgICAgLnRvQXJyYXkoKVxuICAgICAgICAubWFwKChtYSkgPT4gbWEudG9TdHJpbmcoKSlcbiAgICAgICAgLmZpbHRlcigobWEpID0+IG1hLmluZGV4T2YoJ2lwZnMnKSA+PSAwKVxuICAgICAgICAuc29ydCgpLFxuICAgICAgYWdlbnRWZXJzaW9uOiBganMtaXBmcy8ke3BrZ3ZlcnNpb259YCxcbiAgICAgIHByb3RvY29sVmVyc2lvbjogJzkwMDAnXG4gICAgfSkpXG4gIH0pXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQmxvY2sgPSByZXF1aXJlKCdpcGZzLWJsb2NrJylcbmNvbnN0IG11bHRpaGFzaGluZyA9IHJlcXVpcmUoJ211bHRpaGFzaGluZy1hc3luYycpXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcbmNvbnN0IHdhdGVyZmFsbCA9IHJlcXVpcmUoJ2FzeW5jL3dhdGVyZmFsbCcpXG5jb25zdCBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdhc3luYy9zZXRJbW1lZGlhdGUnKVxuY29uc3QgcHJvbWlzaWZ5ID0gcmVxdWlyZSgncHJvbWlzaWZ5LWVzNicpXG5jb25zdCBlcnJDb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJsb2NrIChzZWxmKSB7XG4gIHJldHVybiB7XG4gICAgZ2V0OiBwcm9taXNpZnkoKGNpZCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IHt9XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNpZCA9IGNsZWFuQ2lkKGNpZClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKGVyckNvZGUoZXJyLCAnRVJSX0lOVkFMSURfQ0lEJykpKVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5wcmVsb2FkICE9PSBmYWxzZSkge1xuICAgICAgICBzZWxmLl9wcmVsb2FkKGNpZClcbiAgICAgIH1cblxuICAgICAgc2VsZi5fYmxvY2tTZXJ2aWNlLmdldChjaWQsIGNhbGxiYWNrKVxuICAgIH0pLFxuICAgIHB1dDogcHJvbWlzaWZ5KChibG9jaywgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICAgIG9wdGlvbnMgPSB7fVxuICAgICAgfVxuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShibG9jaykpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignQXJyYXkgaXMgbm90IHN1cHBvcnRlZCcpKVxuICAgICAgfVxuXG4gICAgICB3YXRlcmZhbGwoW1xuICAgICAgICAoY2IpID0+IHtcbiAgICAgICAgICBpZiAoQmxvY2suaXNCbG9jayhibG9jaykpIHtcbiAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBibG9jaylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5jaWQgJiYgQ0lELmlzQ0lEKG9wdGlvbnMuY2lkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIG5ldyBCbG9jayhibG9jaywgb3B0aW9ucy5jaWQpKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG1odHlwZSA9IG9wdGlvbnMubWh0eXBlIHx8ICdzaGEyLTI1NidcbiAgICAgICAgICBjb25zdCBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCB8fCAnZGFnLXBiJ1xuICAgICAgICAgIGxldCBjaWRWZXJzaW9uXG4gICAgICAgICAgLy8gY29uc3QgbWhsZW4gPSBvcHRpb25zLm1obGVuIHx8IDBcblxuICAgICAgICAgIGlmIChvcHRpb25zLnZlcnNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUGljayBhcHByb3ByaWF0ZSBDSUQgdmVyc2lvblxuICAgICAgICAgICAgY2lkVmVyc2lvbiA9IG1odHlwZSA9PT0gJ3NoYTItMjU2JyAmJiBmb3JtYXQgPT09ICdkYWctcGInID8gMCA6IDFcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2lkVmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvblxuICAgICAgICAgIH1cblxuICAgICAgICAgIG11bHRpaGFzaGluZyhibG9jaywgbWh0eXBlLCAoZXJyLCBtdWx0aWhhc2gpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGNpZFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY2lkID0gbmV3IENJRChjaWRWZXJzaW9uLCBmb3JtYXQsIG11bHRpaGFzaClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYihudWxsLCBuZXcgQmxvY2soYmxvY2ssIGNpZCkpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgKGJsb2NrLCBjYikgPT4gc2VsZi5fYmxvY2tTZXJ2aWNlLnB1dChibG9jaywgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMucHJlbG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHNlbGYuX3ByZWxvYWQoYmxvY2suY2lkKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNiKG51bGwsIGJsb2NrKVxuICAgICAgICB9KVxuICAgICAgXSwgY2FsbGJhY2spXG4gICAgfSksXG4gICAgcm06IHByb21pc2lmeSgoY2lkLCBjYWxsYmFjaykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2lkID0gY2xlYW5DaWQoY2lkKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2soZXJyQ29kZShlcnIsICdFUlJfSU5WQUxJRF9DSUQnKSkpXG4gICAgICB9XG4gICAgICBzZWxmLl9ibG9ja1NlcnZpY2UuZGVsZXRlKGNpZCwgY2FsbGJhY2spXG4gICAgfSksXG4gICAgc3RhdDogcHJvbWlzaWZ5KChjaWQsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICAgIG9wdGlvbnMgPSB7fVxuICAgICAgfVxuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgICB0cnkge1xuICAgICAgICBjaWQgPSBjbGVhbkNpZChjaWQpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhlcnJDb2RlKGVyciwgJ0VSUl9JTlZBTElEX0NJRCcpKSlcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucHJlbG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgc2VsZi5fcHJlbG9hZChjaWQpXG4gICAgICB9XG5cbiAgICAgIHNlbGYuX2Jsb2NrU2VydmljZS5nZXQoY2lkLCAoZXJyLCBibG9jaykgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAga2V5OiBjaWQudG9TdHJpbmcoKSxcbiAgICAgICAgICBzaXplOiBibG9jay5kYXRhLmxlbmd0aFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuQ2lkIChjaWQpIHtcbiAgaWYgKENJRC5pc0NJRChjaWQpKSB7XG4gICAgcmV0dXJuIGNpZFxuICB9XG5cbiAgLy8gQ0lEIGNvbnN0cnVjdG9yIGtub3dzIGhvdyB0byBkbyB0aGUgY2xlYW5pbmcgOilcbiAgcmV0dXJuIG5ldyBDSUQoY2lkKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHdhdGVyZmFsbCA9IHJlcXVpcmUoJ2FzeW5jL3dhdGVyZmFsbCcpXG5jb25zdCBwYXJhbGxlbCA9IHJlcXVpcmUoJ2FzeW5jL3BhcmFsbGVsJylcbmNvbnN0IHNldEltbWVkaWF0ZSA9IHJlcXVpcmUoJ2FzeW5jL3NldEltbWVkaWF0ZScpXG5jb25zdCBwcm9taXNpZnkgPSByZXF1aXJlKCdwcm9taXNpZnktZXM2JylcbmNvbnN0IGRhZ1BCID0gcmVxdWlyZSgnaXBsZC1kYWctcGInKVxuY29uc3QgREFHTm9kZSA9IGRhZ1BCLkRBR05vZGVcbmNvbnN0IERBR0xpbmsgPSBkYWdQQi5EQUdMaW5rXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcbmNvbnN0IG1oID0gcmVxdWlyZSgnbXVsdGloYXNoZXMnKVxuY29uc3QgbXVsdGljb2RlYyA9IHJlcXVpcmUoJ211bHRpY29kZWMnKVxuY29uc3QgVW5peGZzID0gcmVxdWlyZSgnaXBmcy11bml4ZnMnKVxuY29uc3QgZXJyQ29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxuZnVuY3Rpb24gbm9ybWFsaXplTXVsdGloYXNoIChtdWx0aWhhc2gsIGVuYykge1xuICBpZiAodHlwZW9mIG11bHRpaGFzaCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoZW5jID09PSAnYmFzZTU4JyB8fCAhZW5jKSB7XG4gICAgICByZXR1cm4gbXVsdGloYXNoXG4gICAgfVxuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG11bHRpaGFzaCwgZW5jKVxuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihtdWx0aWhhc2gpKSB7XG4gICAgcmV0dXJuIG11bHRpaGFzaFxuICB9IGVsc2UgaWYgKENJRC5pc0NJRChtdWx0aWhhc2gpKSB7XG4gICAgcmV0dXJuIG11bHRpaGFzaC5idWZmZXJcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIG11bHRpaGFzaCcpXG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VCdWZmZXIgKGJ1ZiwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdqc29uJzpcbiAgICAgIHJldHVybiBwYXJzZUpTT05CdWZmZXIoYnVmLCBjYWxsYmFjaylcbiAgICBjYXNlICdwcm90b2J1Zic6XG4gICAgICByZXR1cm4gcGFyc2VQcm90b0J1ZmZlcihidWYsIGNhbGxiYWNrKVxuICAgIGRlZmF1bHQ6XG4gICAgICBjYWxsYmFjayhuZXcgRXJyb3IoYHVua293biBlbmNvZGluZzogJHtlbmNvZGluZ31gKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUpTT05CdWZmZXIgKGJ1ZiwgY2FsbGJhY2spIHtcbiAgbGV0IGRhdGFcbiAgbGV0IGxpbmtzXG5cbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGJ1Zi50b1N0cmluZygpKVxuXG4gICAgbGlua3MgPSAocGFyc2VkLkxpbmtzIHx8IFtdKS5tYXAoKGxpbmspID0+IHtcbiAgICAgIHJldHVybiBuZXcgREFHTGluayhcbiAgICAgICAgbGluay5OYW1lIHx8IGxpbmsubmFtZSxcbiAgICAgICAgbGluay5TaXplIHx8IGxpbmsuc2l6ZSxcbiAgICAgICAgbWguZnJvbUI1OFN0cmluZyhsaW5rLkhhc2ggfHwgbGluay5oYXNoIHx8IGxpbmsubXVsdGloYXNoKVxuICAgICAgKVxuICAgIH0pXG4gICAgZGF0YSA9IEJ1ZmZlci5mcm9tKHBhcnNlZC5EYXRhKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdmYWlsZWQgdG8gcGFyc2UgSlNPTjogJyArIGVycikpXG4gIH1cblxuICB0cnkge1xuICAgIGNhbGxiYWNrKG51bGwsIERBR05vZGUuY3JlYXRlKGRhdGEsIGxpbmtzKSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FsbGJhY2soZXJyKVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlUHJvdG9CdWZmZXIgKGJ1ZiwgY2FsbGJhY2spIHtcbiAgbGV0IG9ialxuICB0cnkge1xuICAgIG9iaiA9IGRhZ1BCLnV0aWwuZGVzZXJpYWxpemUoYnVmKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICB9XG4gIGNhbGxiYWNrKG51bGwsIG9iailcbn1cblxuZnVuY3Rpb24gZmluZExpbmtzIChub2RlLCBsaW5rcyA9IFtdKSB7XG4gIGZvciAobGV0IGtleSBpbiBub2RlKSB7XG4gICAgY29uc3QgdmFsID0gbm9kZVtrZXldXG5cbiAgICBpZiAoa2V5ID09PSAnLycgJiYgT2JqZWN0LmtleXMobm9kZSkubGVuZ3RoID09PSAxKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsaW5rcy5wdXNoKG5ldyBEQUdMaW5rKCcnLCAwLCBuZXcgQ0lEKHZhbCkpKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAvLyBub3QgYSBDSURcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoQ0lELmlzQ0lEKHZhbCkpIHtcbiAgICAgIGxpbmtzLnB1c2gobmV3IERBR0xpbmsoJycsIDAsIHZhbCkpXG5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZmluZExpbmtzKHZhbCwgbGlua3MpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICEodmFsIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgZmluZExpbmtzKHZhbCwgbGlua3MpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxpbmtzXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gb2JqZWN0IChzZWxmKSB7XG4gIGZ1bmN0aW9uIGVkaXRBbmRTYXZlIChlZGl0KSB7XG4gICAgcmV0dXJuIChtdWx0aWhhc2gsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICAgIG9wdGlvbnMgPSB7fVxuICAgICAgfVxuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgICB3YXRlcmZhbGwoW1xuICAgICAgICAoY2IpID0+IHtcbiAgICAgICAgICBzZWxmLm9iamVjdC5nZXQobXVsdGloYXNoLCBvcHRpb25zLCBjYilcbiAgICAgICAgfSxcbiAgICAgICAgKG5vZGUsIGNiKSA9PiB7XG4gICAgICAgICAgLy8gZWRpdCBhcHBsaWVzIHRoZSBlZGl0IGZ1bmMgcGFzc2VkIHRvXG4gICAgICAgICAgLy8gZWRpdEFuZFNhdmVcbiAgICAgICAgICBlZGl0KG5vZGUsIChlcnIsIG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5faXBsZC5wdXQobm9kZSwgbXVsdGljb2RlYy5EQUdfUEIsIHtcbiAgICAgICAgICAgICAgY2lkVmVyc2lvbjogMCxcbiAgICAgICAgICAgICAgaGFzaEFsZzogbXVsdGljb2RlYy5TSEEyXzI1NlxuICAgICAgICAgICAgfSkudGhlbihcbiAgICAgICAgICAgICAgKGNpZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnByZWxvYWQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLl9wcmVsb2FkKGNpZClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYihudWxsLCBjaWQpXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIChlcnJvcikgPT4gY2IoZXJyb3IpXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgXSwgY2FsbGJhY2spXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuZXc6IHByb21pc2lmeSgodGVtcGxhdGUsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdGVtcGxhdGVcbiAgICAgICAgdGVtcGxhdGUgPSB1bmRlZmluZWRcbiAgICAgICAgb3B0aW9ucyA9IHt9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IHt9XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgICAgIGxldCBkYXRhXG5cbiAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAodGVtcGxhdGUgIT09ICd1bml4ZnMtZGlyJykge1xuICAgICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2sobmV3IEVycm9yKCd1bmtub3duIHRlbXBsYXRlJykpKVxuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSAobmV3IFVuaXhmcygnZGlyZWN0b3J5JykpLm1hcnNoYWwoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5hbGxvYygwKVxuICAgICAgfVxuXG4gICAgICBsZXQgbm9kZVxuXG4gICAgICB0cnkge1xuICAgICAgICBub2RlID0gREFHTm9kZS5jcmVhdGUoZGF0YSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBzZWxmLl9pcGxkLnB1dChub2RlLCBtdWx0aWNvZGVjLkRBR19QQiwge1xuICAgICAgICBjaWRWZXJzaW9uOiAwLFxuICAgICAgICBoYXNoQWxnOiBtdWx0aWNvZGVjLlNIQTJfMjU2XG4gICAgICB9KS50aGVuKFxuICAgICAgICAoY2lkKSA9PiB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMucHJlbG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHNlbGYuX3ByZWxvYWQoY2lkKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGNpZClcbiAgICAgICAgfSxcbiAgICAgICAgKGVycm9yKSA9PiBjYWxsYmFjayhlcnJvcilcbiAgICAgIClcbiAgICB9KSxcbiAgICBwdXQ6IHByb21pc2lmeSgob2JqLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgICAgICBvcHRpb25zID0ge31cbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICAgICAgY29uc3QgZW5jb2RpbmcgPSBvcHRpb25zLmVuY1xuICAgICAgbGV0IG5vZGVcblxuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgICAgIGlmIChlbmNvZGluZykge1xuICAgICAgICAgIHBhcnNlQnVmZmVyKG9iaiwgZW5jb2RpbmcsIChlcnIsIF9ub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gX25vZGVcbiAgICAgICAgICAgIG5leHQoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5vZGUgPSBEQUdOb2RlLmNyZWF0ZShvYmopXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQoKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKERBR05vZGUuaXNEQUdOb2RlKG9iaikpIHtcbiAgICAgICAgLy8gYWxyZWFkeSBhIGRhZyBub2RlXG4gICAgICAgIG5vZGUgPSBvYmpcbiAgICAgICAgbmV4dCgpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbm9kZSA9IERBR05vZGUuY3JlYXRlKG9iai5EYXRhLCBvYmouTGlua3MpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ29iaiBub3QgcmVjb2duaXplZCcpKVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBuZXh0ICgpIHtcbiAgICAgICAgc2VsZi5faXBsZC5wdXQobm9kZSwgbXVsdGljb2RlYy5EQUdfUEIsIHtcbiAgICAgICAgICBjaWRWZXJzaW9uOiAwLFxuICAgICAgICAgIGhhc2hBbGc6IG11bHRpY29kZWMuU0hBMl8yNTZcbiAgICAgICAgfSkudGhlbihcbiAgICAgICAgICAoY2lkKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wcmVsb2FkICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBzZWxmLl9wcmVsb2FkKGNpZClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgY2lkKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgKGVycm9yKSA9PiBjYWxsYmFjayhlcnJvcilcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0pLFxuXG4gICAgZ2V0OiBwcm9taXNpZnkoKG11bHRpaGFzaCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IHt9XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgICAgIGxldCBtaCwgY2lkXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG1oID0gbm9ybWFsaXplTXVsdGloYXNoKG11bHRpaGFzaCwgb3B0aW9ucy5lbmMpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhlcnJDb2RlKGVyciwgJ0VSUl9JTlZBTElEX01VTFRJSEFTSCcpKSlcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY2lkID0gbmV3IENJRChtaClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKGVyckNvZGUoZXJyLCAnRVJSX0lOVkFMSURfQ0lEJykpKVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jaWRWZXJzaW9uID09PSAxKSB7XG4gICAgICAgIGNpZCA9IGNpZC50b1YxKClcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucHJlbG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgc2VsZi5fcHJlbG9hZChjaWQpXG4gICAgICB9XG5cbiAgICAgIHNlbGYuX2lwbGQuZ2V0KGNpZCkudGhlbihcbiAgICAgICAgKG5vZGUpID0+IGNhbGxiYWNrKG51bGwsIG5vZGUpLFxuICAgICAgICAoZXJyb3IpID0+IGNhbGxiYWNrKGVycm9yKVxuICAgICAgKVxuICAgIH0pLFxuXG4gICAgZGF0YTogcHJvbWlzaWZ5KChtdWx0aWhhc2gsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICAgIG9wdGlvbnMgPSB7fVxuICAgICAgfVxuXG4gICAgICBzZWxmLm9iamVjdC5nZXQobXVsdGloYXNoLCBvcHRpb25zLCAoZXJyLCBub2RlKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgbm9kZS5EYXRhKVxuICAgICAgfSlcbiAgICB9KSxcblxuICAgIGxpbmtzOiBwcm9taXNpZnkoKG11bHRpaGFzaCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IHt9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNpZCA9IG5ldyBDSUQobXVsdGloYXNoKVxuXG4gICAgICBzZWxmLmRhZy5nZXQoY2lkLCBvcHRpb25zLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2lkLmNvZGVjID09PSAncmF3Jykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBbXSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaWQuY29kZWMgPT09ICdkYWctcGInKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdC52YWx1ZS5MaW5rcylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaWQuY29kZWMgPT09ICdkYWctY2JvcicpIHtcbiAgICAgICAgICBjb25zdCBsaW5rcyA9IGZpbmRMaW5rcyhyZXN1bHQpXG5cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbGlua3MpXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoYENhbm5vdCByZXNvbHZlIGxpbmtzIGZyb20gY29kZWMgJHtjaWQuY29kZWN9YCkpXG4gICAgICB9KVxuICAgIH0pLFxuXG4gICAgc3RhdDogcHJvbWlzaWZ5KChtdWx0aWhhc2gsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICAgIG9wdGlvbnMgPSB7fVxuICAgICAgfVxuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgICB3YXRlcmZhbGwoW1xuICAgICAgICAoY2IpID0+IHNlbGYub2JqZWN0LmdldChtdWx0aWhhc2gsIG9wdGlvbnMsIGNiKSxcbiAgICAgICAgKG5vZGUsIGNiKSA9PiB7XG4gICAgICAgICAgY2IobnVsbCwge1xuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IGRhZ1BCLnV0aWwuc2VyaWFsaXplKG5vZGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgKHsgbm9kZSwgc2VyaWFsaXplZCB9LCBjYikgPT4ge1xuICAgICAgICAgIHBhcmFsbGVsKHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IChuZXh0KSA9PiBuZXh0KG51bGwsIHNlcmlhbGl6ZWQpLFxuICAgICAgICAgICAgY2lkOiAobmV4dCkgPT4gZGFnUEIudXRpbC5jaWQoc2VyaWFsaXplZCwge1xuICAgICAgICAgICAgICBjaWRWZXJzaW9uOiAwXG4gICAgICAgICAgICB9KS50aGVuKChjaWQpID0+IG5leHQobnVsbCwgY2lkKSwgbmV4dCksXG4gICAgICAgICAgICBub2RlOiAobmV4dCkgPT4gbmV4dChudWxsLCBub2RlKVxuICAgICAgICAgIH0sIGNiKVxuICAgICAgICB9XG4gICAgICBdLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBibG9ja1NpemUgPSByZXN1bHQuc2VyaWFsaXplZC5sZW5ndGhcbiAgICAgICAgY29uc3QgbGlua0xlbmd0aCA9IHJlc3VsdC5ub2RlLkxpbmtzLnJlZHVjZSgoYSwgbCkgPT4gYSArIGwuVHNpemUsIDApXG5cbiAgICAgICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgIEhhc2g6IHJlc3VsdC5jaWQudG9CYXNlRW5jb2RlZFN0cmluZygpLFxuICAgICAgICAgIE51bUxpbmtzOiByZXN1bHQubm9kZS5MaW5rcy5sZW5ndGgsXG4gICAgICAgICAgQmxvY2tTaXplOiBibG9ja1NpemUsXG4gICAgICAgICAgTGlua3NTaXplOiBibG9ja1NpemUgLSByZXN1bHQubm9kZS5EYXRhLmxlbmd0aCxcbiAgICAgICAgICBEYXRhU2l6ZTogcmVzdWx0Lm5vZGUuRGF0YS5sZW5ndGgsXG4gICAgICAgICAgQ3VtdWxhdGl2ZVNpemU6IGJsb2NrU2l6ZSArIGxpbmtMZW5ndGhcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSksXG5cbiAgICBwYXRjaDogcHJvbWlzaWZ5KHtcbiAgICAgIGFkZExpbmsgKG11bHRpaGFzaCwgbGluaywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgZWRpdEFuZFNhdmUoKG5vZGUsIGNiKSA9PiB7XG4gICAgICAgICAgREFHTm9kZS5hZGRMaW5rKG5vZGUsIGxpbmspLnRoZW4oKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGNiKG51bGwsIG5vZGUpXG4gICAgICAgICAgfSwgY2IpXG4gICAgICAgIH0pKG11bHRpaGFzaCwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgICB9LFxuXG4gICAgICBybUxpbmsgKG11bHRpaGFzaCwgbGlua1JlZiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgZWRpdEFuZFNhdmUoKG5vZGUsIGNiKSA9PiB7XG4gICAgICAgICAgbGlua1JlZiA9IGxpbmtSZWYuTmFtZSB8fCBsaW5rUmVmLm5hbWVcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBub2RlID0gREFHTm9kZS5ybUxpbmsobm9kZSwgbGlua1JlZilcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2IobnVsbCwgbm9kZSlcbiAgICAgICAgfSkobXVsdGloYXNoLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICAgIH0sXG5cbiAgICAgIGFwcGVuZERhdGEgKG11bHRpaGFzaCwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgZWRpdEFuZFNhdmUoKG5vZGUsIGNiKSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3RGF0YSA9IEJ1ZmZlci5jb25jYXQoW25vZGUuRGF0YSwgZGF0YV0pXG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9kZSA9IERBR05vZGUuY3JlYXRlKG5ld0RhdGEsIG5vZGUuTGlua3MpXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNiKG51bGwsIG5vZGUpXG4gICAgICAgIH0pKG11bHRpaGFzaCwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgICB9LFxuXG4gICAgICBzZXREYXRhIChtdWx0aWhhc2gsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGVkaXRBbmRTYXZlKChub2RlLCBjYikgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBub2RlID0gREFHTm9kZS5jcmVhdGUoZGF0YSwgbm9kZS5MaW5rcylcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2IobnVsbCwgbm9kZSlcbiAgICAgICAgfSkobXVsdGloYXNoLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHJvbWlzaWZ5ID0gcmVxdWlyZSgncHJvbWlzaWZ5LWVzNicpXG5jb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vcHVsbCcpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGluZyAoc2VsZikge1xuICByZXR1cm4gcHJvbWlzaWZ5KChwZWVySWQsIG9wdHMsIGNhbGxiYWNrKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdHNcbiAgICAgIG9wdHMgPSB7fVxuICAgIH1cblxuICAgIHB1bGwoXG4gICAgICBzZWxmLnBpbmdQdWxsU3RyZWFtKHBlZXJJZCwgb3B0cyksXG4gICAgICBwdWxsLmNvbGxlY3QoY2FsbGJhY2spXG4gICAgKVxuICB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IE9GRkxJTkVfRVJST1IgPSByZXF1aXJlKCcuLi91dGlscycpLk9GRkxJTkVfRVJST1JcbmNvbnN0IHByb21pc2lmeSA9IHJlcXVpcmUoJ3Byb21pc2lmeS1lczYnKVxuY29uc3Qgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgnYXN5bmMvc2V0SW1tZWRpYXRlJylcbmNvbnN0IEJpZyA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcbmNvbnN0IFBlZXJJZCA9IHJlcXVpcmUoJ3BlZXItaWQnKVxuY29uc3QgZXJyQ29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxuZnVuY3Rpb24gZm9ybWF0V2FudGxpc3QgKGxpc3QsIGNpZEJhc2UpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20obGlzdCkubWFwKChlKSA9PiAoeyAnLyc6IGVbMV0uY2lkLnRvQmFzZUVuY29kZWRTdHJpbmcoY2lkQmFzZSkgfSkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYml0c3dhcCAoc2VsZikge1xuICByZXR1cm4ge1xuICAgIHdhbnRsaXN0OiBwcm9taXNpZnkoKHBlZXJJZCwgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcGVlcklkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gcGVlcklkXG4gICAgICAgIHBlZXJJZCA9IG51bGxcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZWxmLmlzT25saW5lKCkpIHtcbiAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhuZXcgRXJyb3IoT0ZGTElORV9FUlJPUikpKVxuICAgICAgfVxuXG4gICAgICBsZXQgbGlzdFxuICAgICAgaWYgKHBlZXJJZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHBlZXJJZCA9IFBlZXJJZC5jcmVhdGVGcm9tQjU4U3RyaW5nKHBlZXJJZClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHBlZXJJZCA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBlZXJJZCkge1xuICAgICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2sobmV3IEVycm9yKCdJbnZhbGlkIHBlZXJJZCcpKSlcbiAgICAgICAgfVxuICAgICAgICBsaXN0ID0gc2VsZi5fYml0c3dhcC53YW50bGlzdEZvclBlZXIocGVlcklkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdCA9IHNlbGYuX2JpdHN3YXAuZ2V0V2FudGxpc3QoKVxuICAgICAgfVxuXG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2sobnVsbCwgeyBLZXlzOiBmb3JtYXRXYW50bGlzdChsaXN0KSB9KSlcbiAgICB9KSxcblxuICAgIHN0YXQ6IHByb21pc2lmeSgoY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICghc2VsZi5pc09ubGluZSgpKSB7XG4gICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2sobmV3IEVycm9yKE9GRkxJTkVfRVJST1IpKSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc25hcHNob3QgPSBzZWxmLl9iaXRzd2FwLnN0YXQoKS5zbmFwc2hvdFxuXG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgcHJvdmlkZUJ1ZkxlbjogcGFyc2VJbnQoc25hcHNob3QucHJvdmlkZXNCdWZmZXJMZW5ndGgudG9TdHJpbmcoKSksXG4gICAgICAgICAgYmxvY2tzUmVjZWl2ZWQ6IG5ldyBCaWcoc25hcHNob3QuYmxvY2tzUmVjZWl2ZWQpLFxuICAgICAgICAgIHdhbnRsaXN0OiBmb3JtYXRXYW50bGlzdChzZWxmLl9iaXRzd2FwLmdldFdhbnRsaXN0KCkpLFxuICAgICAgICAgIHBlZXJzOiBzZWxmLl9iaXRzd2FwLnBlZXJzKCkubWFwKChpZCkgPT4gaWQudG9CNThTdHJpbmcoKSksXG4gICAgICAgICAgZHVwQmxrc1JlY2VpdmVkOiBuZXcgQmlnKHNuYXBzaG90LmR1cEJsa3NSZWNlaXZlZCksXG4gICAgICAgICAgZHVwRGF0YVJlY2VpdmVkOiBuZXcgQmlnKHNuYXBzaG90LmR1cERhdGFSZWNlaXZlZCksXG4gICAgICAgICAgZGF0YVJlY2VpdmVkOiBuZXcgQmlnKHNuYXBzaG90LmRhdGFSZWNlaXZlZCksXG4gICAgICAgICAgYmxvY2tzU2VudDogbmV3IEJpZyhzbmFwc2hvdC5ibG9ja3NTZW50KSxcbiAgICAgICAgICBkYXRhU2VudDogbmV3IEJpZyhzbmFwc2hvdC5kYXRhU2VudClcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSksXG5cbiAgICB1bndhbnQ6IHByb21pc2lmeSgoa2V5cywgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICghc2VsZi5pc09ubGluZSgpKSB7XG4gICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2sobmV3IEVycm9yKE9GRkxJTkVfRVJST1IpKSlcbiAgICAgIH1cblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgIGtleXMgPSBba2V5c11cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAga2V5cyA9IGtleXMubWFwKChrZXkpID0+IHtcbiAgICAgICAgICBpZiAoQ0lELmlzQ0lEKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBDSUQoa2V5KVxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2soZXJyQ29kZShlcnIsICdFUlJfSU5WQUxJRF9DSUQnKSkpXG4gICAgICB9XG5cbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhudWxsLCBzZWxmLl9iaXRzd2FwLnVud2FudChrZXlzKSkpXG4gICAgfSlcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHByb21pc2lmeSA9IHJlcXVpcmUoJ3Byb21pc2lmeS1lczYnKVxuY29uc3Qgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgnYXN5bmMvc2V0SW1tZWRpYXRlJylcbmNvbnN0IGVyckNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5cbmNvbnN0IGVyclB1YnN1YkRpc2FibGVkID0gKCkgPT4ge1xuICByZXR1cm4gZXJyQ29kZShuZXcgRXJyb3IoJ3B1YnN1YiBleHBlcmltZW50IGlzIG5vdCBlbmFibGVkJyksICdFUlJfUFVCU1VCX0RJU0FCTEVEJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwdWJzdWIgKHNlbGYpIHtcbiAgcmV0dXJuIHtcbiAgICBzdWJzY3JpYmU6ICh0b3BpYywgaGFuZGxlciwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IHt9XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZi5fb3B0aW9ucy5FWFBFUklNRU5UQUwucHVic3ViKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFja1xuICAgICAgICAgID8gc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKGVyclB1YnN1YkRpc2FibGVkKCkpKVxuICAgICAgICAgIDogUHJvbWlzZS5yZWplY3QoZXJyUHVic3ViRGlzYWJsZWQoKSlcbiAgICAgIH1cblxuICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHNlbGYubGlicDJwLnB1YnN1Yi5zdWJzY3JpYmUodG9waWMsIG9wdGlvbnMsIGhhbmRsZXIsIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBzZWxmLmxpYnAycC5wdWJzdWIuc3Vic2NyaWJlKHRvcGljLCBvcHRpb25zLCBoYW5kbGVyLCBjYWxsYmFjaylcbiAgICB9LFxuXG4gICAgdW5zdWJzY3JpYmU6ICh0b3BpYywgaGFuZGxlciwgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICghc2VsZi5fb3B0aW9ucy5FWFBFUklNRU5UQUwucHVic3ViKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFja1xuICAgICAgICAgID8gc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKGVyclB1YnN1YkRpc2FibGVkKCkpKVxuICAgICAgICAgIDogUHJvbWlzZS5yZWplY3QoZXJyUHVic3ViRGlzYWJsZWQoKSlcbiAgICAgIH1cblxuICAgICAgc2VsZi5saWJwMnAucHVic3ViLnVuc3Vic2NyaWJlKHRvcGljLCBoYW5kbGVyKVxuXG4gICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuXG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2soKSlcbiAgICB9LFxuXG4gICAgcHVibGlzaDogcHJvbWlzaWZ5KCh0b3BpYywgZGF0YSwgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICghc2VsZi5fb3B0aW9ucy5FWFBFUklNRU5UQUwucHVic3ViKSB7XG4gICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2soZXJyUHVic3ViRGlzYWJsZWQoKSkpXG4gICAgICB9XG4gICAgICBzZWxmLmxpYnAycC5wdWJzdWIucHVibGlzaCh0b3BpYywgZGF0YSwgY2FsbGJhY2spXG4gICAgfSksXG5cbiAgICBsczogcHJvbWlzaWZ5KChjYWxsYmFjaykgPT4ge1xuICAgICAgaWYgKCFzZWxmLl9vcHRpb25zLkVYUEVSSU1FTlRBTC5wdWJzdWIpIHtcbiAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhlcnJQdWJzdWJEaXNhYmxlZCgpKSlcbiAgICAgIH1cbiAgICAgIHNlbGYubGlicDJwLnB1YnN1Yi5scyhjYWxsYmFjaylcbiAgICB9KSxcblxuICAgIHBlZXJzOiBwcm9taXNpZnkoKHRvcGljLCBjYWxsYmFjaykgPT4ge1xuICAgICAgaWYgKCFzZWxmLl9vcHRpb25zLkVYUEVSSU1FTlRBTC5wdWJzdWIpIHtcbiAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhlcnJQdWJzdWJEaXNhYmxlZCgpKSlcbiAgICAgIH1cbiAgICAgIHNlbGYubGlicDJwLnB1YnN1Yi5wZWVycyh0b3BpYywgY2FsbGJhY2spXG4gICAgfSksXG5cbiAgICBzZXRNYXhMaXN0ZW5lcnMgKG4pIHtcbiAgICAgIGlmICghc2VsZi5fb3B0aW9ucy5FWFBFUklNRU5UQUwucHVic3ViKSB7XG4gICAgICAgIHRocm93IGVyclB1YnN1YkRpc2FibGVkKClcbiAgICAgIH1cbiAgICAgIHNlbGYubGlicDJwLnB1YnN1Yi5zZXRNYXhMaXN0ZW5lcnMobilcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwcm9taXNpZnkgPSByZXF1aXJlKCdwcm9taXNpZnktZXM2JylcbmNvbnN0IGlzSXBmcyA9IHJlcXVpcmUoJ2lzLWlwZnMnKVxuY29uc3Qgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgnYXN5bmMvc2V0SW1tZWRpYXRlJylcbmNvbnN0IENJRCA9IHJlcXVpcmUoJ2NpZHMnKVxuY29uc3QgeyBjaWRUb1N0cmluZyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY2lkJylcblxubW9kdWxlLmV4cG9ydHMgPSAoc2VsZikgPT4ge1xuICByZXR1cm4gcHJvbWlzaWZ5KGFzeW5jIChuYW1lLCBvcHRzLCBjYikgPT4ge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBvcHRzXG4gICAgICBvcHRzID0ge31cbiAgICB9XG5cbiAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgaWYgKCFpc0lwZnMucGF0aChuYW1lKSkge1xuICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSgoKSA9PiBjYihuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgJyArIG5hbWUpKSlcbiAgICB9XG5cbiAgICAvLyBUT0RPIHJlbW92ZSB0aGlzIGFuZCB1cGRhdGUgc3Vic2VxdWVudCBjb2RlIHdoZW4gSVBOUyBpcyBpbXBsZW1lbnRlZFxuICAgIGlmICghaXNJcGZzLmlwZnNQYXRoKG5hbWUpKSB7XG4gICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKCgpID0+IGNiKG5ldyBFcnJvcigncmVzb2x2ZSBub24tSVBGUyBuYW1lcyBpcyBub3QgaW1wbGVtZW50ZWQnKSkpXG4gICAgfVxuXG4gICAgY29uc3Qgc3BsaXQgPSBuYW1lLnNwbGl0KCcvJykgLy8gWycnLCAnaXBmcycsICdoYXNoJywgLi4ucGF0aF1cbiAgICBjb25zdCBjaWQgPSBuZXcgQ0lEKHNwbGl0WzJdKVxuXG4gICAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSgoKSA9PiBjYihudWxsLCBgL2lwZnMvJHtjaWRUb1N0cmluZyhjaWQsIHsgYmFzZTogb3B0cy5jaWRCYXNlIH0pfWApKVxuICAgIH1cblxuICAgIGNvbnN0IHBhdGggPSBzcGxpdC5zbGljZSgzKS5qb2luKCcvJylcblxuICAgIGNvbnN0IHJlc3VsdHMgPSBzZWxmLl9pcGxkLnJlc29sdmUoY2lkLCBwYXRoKVxuICAgIGxldCB2YWx1ZSA9IGNpZFxuICAgIGxldCByZW1haW5kZXJQYXRoID0gcGF0aFxuICAgIHRyeSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgIGlmIChyZXN1bHQucmVtYWluZGVyUGF0aCA9PT0gJycpIHtcbiAgICAgICAgICAvLyBVc2UgdmFsdWVzIGZyb20gcHJldmlvdXMgaXRlcmF0aW9uIGlmIHRoZSB2YWx1ZSBpc24ndCBhIENJRFxuICAgICAgICAgIGlmIChDSUQuaXNDSUQocmVzdWx0LnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQudmFsdWVcbiAgICAgICAgICAgIHJlbWFpbmRlclBhdGggPSAnJ1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZXN1bHQudmFsdWUgJiYgQ0lELmlzQ0lEKHJlc3VsdC52YWx1ZS5IYXNoKSkge1xuICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQudmFsdWUuSGFzaFxuICAgICAgICAgICAgcmVtYWluZGVyUGF0aCA9ICcnXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gcmVzdWx0LnZhbHVlXG4gICAgICAgIHJlbWFpbmRlclBhdGggPSByZXN1bHQucmVtYWluZGVyUGF0aFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gY2IoZXJyb3IpXG4gICAgfVxuICAgIHJldHVybiBjYihudWxsLCBgL2lwZnMvJHtjaWRUb1N0cmluZyh2YWx1ZSwgeyBiYXNlOiBvcHRzLmNpZEJhc2UgfSl9JHtyZW1haW5kZXJQYXRoID8gJy8nICsgcmVtYWluZGVyUGF0aCA6ICcnfWApXG4gIH0pXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHJvbWlzaWZ5ID0gcmVxdWlyZSgncHJvbWlzaWZ5LWVzNicpXG5cbmNvbnN0IE9GRkxJTkVfRVJST1IgPSByZXF1aXJlKCcuLi91dGlscycpLk9GRkxJTkVfRVJST1JcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzd2FybSAoc2VsZikge1xuICByZXR1cm4ge1xuICAgIHBlZXJzOiBwcm9taXNpZnkoKG9wdHMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRzXG4gICAgICAgIG9wdHMgPSB7fVxuICAgICAgfVxuXG4gICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICBpZiAoIXNlbGYuaXNPbmxpbmUoKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKE9GRkxJTkVfRVJST1IpKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB2ZXJib3NlID0gb3B0cy52IHx8IG9wdHMudmVyYm9zZVxuICAgICAgLy8gVE9ETzogcmV0dXJuIGxhdGVuY3kgYW5kIHN0cmVhbXMgd2hlbiB2ZXJib3NlIGlzIHNldFxuICAgICAgLy8gd2UgY3VycmVudGx5IGRvbid0IGhhdmUgdGhpcyBpbmZvcm1hdGlvblxuXG4gICAgICBjb25zdCBwZWVycyA9IFtdXG5cbiAgICAgIE9iamVjdC52YWx1ZXMoc2VsZi5fcGVlckluZm9Cb29rLmdldEFsbCgpKS5mb3JFYWNoKChwZWVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RlZEFkZHIgPSBwZWVyLmlzQ29ubmVjdGVkKClcblxuICAgICAgICBpZiAoIWNvbm5lY3RlZEFkZHIpIHsgcmV0dXJuIH1cblxuICAgICAgICBjb25zdCB0dXBwbGUgPSB7XG4gICAgICAgICAgYWRkcjogY29ubmVjdGVkQWRkcixcbiAgICAgICAgICBwZWVyOiBwZWVyLmlkXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgICAgICB0dXBwbGUubGF0ZW5jeSA9ICd1bmtub3duJ1xuICAgICAgICB9XG5cbiAgICAgICAgcGVlcnMucHVzaCh0dXBwbGUpXG4gICAgICB9KVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBwZWVycylcbiAgICB9KSxcblxuICAgIC8vIGFsbCB0aGUgYWRkcnMgd2Uga25vd1xuICAgIGFkZHJzOiBwcm9taXNpZnkoKGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAoIXNlbGYuaXNPbmxpbmUoKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKE9GRkxJTkVfRVJST1IpKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwZWVycyA9IE9iamVjdC52YWx1ZXMoc2VsZi5fcGVlckluZm9Cb29rLmdldEFsbCgpKVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBwZWVycylcbiAgICB9KSxcblxuICAgIGxvY2FsQWRkcnM6IHByb21pc2lmeSgoY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICghc2VsZi5pc09ubGluZSgpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoT0ZGTElORV9FUlJPUikpXG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIHNlbGYubGlicDJwLnBlZXJJbmZvLm11bHRpYWRkcnMudG9BcnJheSgpKVxuICAgIH0pLFxuXG4gICAgY29ubmVjdDogcHJvbWlzaWZ5KChtYWRkciwgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICghc2VsZi5pc09ubGluZSgpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoT0ZGTElORV9FUlJPUikpXG4gICAgICB9XG5cbiAgICAgIHNlbGYubGlicDJwLmRpYWwobWFkZHIsIGNhbGxiYWNrKVxuICAgIH0pLFxuXG4gICAgZGlzY29ubmVjdDogcHJvbWlzaWZ5KChtYWRkciwgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICghc2VsZi5pc09ubGluZSgpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoT0ZGTElORV9FUlJPUikpXG4gICAgICB9XG5cbiAgICAgIHNlbGYubGlicDJwLmhhbmdVcChtYWRkciwgY2FsbGJhY2spXG4gICAgfSksXG5cbiAgICBmaWx0ZXJzOiBwcm9taXNpZnkoKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpKSlcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHByb21pc2lmeSA9IHJlcXVpcmUoJ3Byb21pc2lmeS1lczYnKVxuY29uc3QgQmlnID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJylcbmNvbnN0IFB1c2hhYmxlID0gcmVxdWlyZSgncHVsbC1wdXNoYWJsZScpXG5jb25zdCBodW1hbiA9IHJlcXVpcmUoJ2h1bWFuLXRvLW1pbGxpc2Vjb25kcycpXG5jb25zdCB0b1N0cmVhbSA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtLXRvLXN0cmVhbScpXG5jb25zdCBlcnJDb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuXG5mdW5jdGlvbiBiYW5kd2lkdGhTdGF0cyAoc2VsZiwgb3B0cykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBzdGF0c1xuXG4gICAgaWYgKG9wdHMucGVlcikge1xuICAgICAgc3RhdHMgPSBzZWxmLmxpYnAycC5zdGF0cy5mb3JQZWVyKG9wdHMucGVlcilcbiAgICB9IGVsc2UgaWYgKG9wdHMucHJvdG8pIHtcbiAgICAgIHN0YXRzID0gc2VsZi5saWJwMnAuc3RhdHMuZm9yUHJvdG9jb2wob3B0cy5wcm90bylcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdHMgPSBzZWxmLmxpYnAycC5zdGF0cy5nbG9iYWxcbiAgICB9XG5cbiAgICBpZiAoIXN0YXRzKSB7XG4gICAgICByZXNvbHZlKHtcbiAgICAgICAgdG90YWxJbjogbmV3IEJpZygwKSxcbiAgICAgICAgdG90YWxPdXQ6IG5ldyBCaWcoMCksXG4gICAgICAgIHJhdGVJbjogbmV3IEJpZygwKSxcbiAgICAgICAgcmF0ZU91dDogbmV3IEJpZygwKVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHJlc29sdmUoe1xuICAgICAgdG90YWxJbjogc3RhdHMuc25hcHNob3QuZGF0YVJlY2VpdmVkLFxuICAgICAgdG90YWxPdXQ6IHN0YXRzLnNuYXBzaG90LmRhdGFTZW50LFxuICAgICAgcmF0ZUluOiBuZXcgQmlnKHN0YXRzLm1vdmluZ0F2ZXJhZ2VzLmRhdGFSZWNlaXZlZFsnNjAwMDAnXS5tb3ZpbmdBdmVyYWdlKCkgLyA2MCksXG4gICAgICByYXRlT3V0OiBuZXcgQmlnKHN0YXRzLm1vdmluZ0F2ZXJhZ2VzLmRhdGFTZW50Wyc2MDAwMCddLm1vdmluZ0F2ZXJhZ2UoKSAvIDYwKVxuICAgIH0pXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RhdHMgKHNlbGYpIHtcbiAgY29uc3QgX2J3UHVsbFN0cmVhbSA9IChvcHRzKSA9PiB7XG4gICAgb3B0cyA9IG9wdHMgfHwge31cbiAgICBsZXQgaW50ZXJ2YWwgPSBudWxsXG4gICAgbGV0IHN0cmVhbSA9IFB1c2hhYmxlKHRydWUsICgpID0+IHtcbiAgICAgIGlmIChpbnRlcnZhbCkge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBpZiAob3B0cy5wb2xsKSB7XG4gICAgICBodW1hbihvcHRzLmludGVydmFsIHx8ICcxcycsIChlcnIsIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtLmVuZChlcnJDb2RlKGVyciwgJ0VSUl9JTlZBTElEX1BPTExfSU5URVJWQUwnKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgIGJhbmR3aWR0aFN0YXRzKHNlbGYsIG9wdHMpXG4gICAgICAgICAgICAudGhlbigoc3RhdHMpID0+IHN0cmVhbS5wdXNoKHN0YXRzKSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiBzdHJlYW0uZW5kKGVycikpXG4gICAgICAgIH0sIHZhbHVlKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgYmFuZHdpZHRoU3RhdHMoc2VsZiwgb3B0cylcbiAgICAgICAgLnRoZW4oKHN0YXRzKSA9PiB7XG4gICAgICAgICAgc3RyZWFtLnB1c2goc3RhdHMpXG4gICAgICAgICAgc3RyZWFtLmVuZCgpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiBzdHJlYW0uZW5kKGVycikpXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmVhbS5zb3VyY2VcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYml0c3dhcDogcmVxdWlyZSgnLi9iaXRzd2FwJykoc2VsZikuc3RhdCxcbiAgICByZXBvOiByZXF1aXJlKCcuL3JlcG8nKShzZWxmKS5zdGF0LFxuICAgIGJ3OiBwcm9taXNpZnkoKG9wdHMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRzXG4gICAgICAgIG9wdHMgPSB7fVxuICAgICAgfVxuXG4gICAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgICBiYW5kd2lkdGhTdGF0cyhzZWxmLCBvcHRzKVxuICAgICAgICAudGhlbigoc3RhdHMpID0+IGNhbGxiYWNrKG51bGwsIHN0YXRzKSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IGNhbGxiYWNrKGVycikpXG4gICAgfSksXG4gICAgYndSZWFkYWJsZVN0cmVhbTogKG9wdHMpID0+IHRvU3RyZWFtLnNvdXJjZShfYndQdWxsU3RyZWFtKG9wdHMpKSxcbiAgICBid1B1bGxTdHJlYW06IF9id1B1bGxTdHJlYW1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHByb21pc2lmeSA9IHJlcXVpcmUoJ3Byb21pc2lmeS1lczYnKVxuY29uc3QgZXZlcnkgPSByZXF1aXJlKCdhc3luYy9ldmVyeScpXG5jb25zdCBQZWVySWQgPSByZXF1aXJlKCdwZWVyLWlkJylcbmNvbnN0IFBlZXJJbmZvID0gcmVxdWlyZSgncGVlci1pbmZvJylcbmNvbnN0IENJRCA9IHJlcXVpcmUoJ2NpZHMnKVxuY29uc3QgZWFjaCA9IHJlcXVpcmUoJ2FzeW5jL2VhY2gnKVxuY29uc3QgbmV4dFRpY2sgPSByZXF1aXJlKCdhc3luYy9uZXh0VGljaycpXG5cbmNvbnN0IGVycmNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5cbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgbG9nID0gZGVidWcoJ2lwZnM6ZGh0JylcbmxvZy5lcnJvciA9IGRlYnVnKCdpcGZzOmRodDplcnJvcicpXG5cbm1vZHVsZS5leHBvcnRzID0gKHNlbGYpID0+IHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGtleSwgcXVlcnkgdGhlIERIVCBmb3IgaXRzIGJlc3QgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0ga2V5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBnZXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRpbWVvdXQgLSBvcHRpb25hbCB0aW1lb3V0XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IFtjYWxsYmFja11cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZXx2b2lkfVxuICAgICAqL1xuICAgIGdldDogcHJvbWlzaWZ5KChrZXksIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICAgIG9wdGlvbnMgPSB7fVxuICAgICAgfVxuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihrZXkpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAga2V5ID0gKG5ldyBDSUQoa2V5KSkuYnVmZmVyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZy5lcnJvcihlcnIpXG5cbiAgICAgICAgICByZXR1cm4gbmV4dFRpY2soKCkgPT4gY2FsbGJhY2soZXJyY29kZShlcnIsICdFUlJfSU5WQUxJRF9DSUQnKSkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi5saWJwMnAuZGh0LmdldChrZXksIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIH0pLFxuXG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBrZXkvdmFsdWUgcGFpciB0byB0aGUgREhULlxuICAgICAqXG4gICAgICogR2l2ZW4gYSBrZXkgb2YgdGhlIGZvcm0gL2Zvby9iYXIgYW5kIGEgdmFsdWUgb2YgYW55XG4gICAgICogZm9ybSwgdGhpcyB3aWxsIHdyaXRlIHRoYXQgdmFsdWUgdG8gdGhlIERIVCB3aXRoXG4gICAgICogdGhhdCBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0ga2V5XG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IFtjYWxsYmFja11cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZXx2b2lkfVxuICAgICAqL1xuICAgIHB1dDogcHJvbWlzaWZ5KChrZXksIHZhbHVlLCBjYWxsYmFjaykgPT4ge1xuICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoa2V5KSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGtleSA9IChuZXcgQ0lEKGtleSkpLmJ1ZmZlclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBsb2cuZXJyb3IoZXJyKVxuXG4gICAgICAgICAgcmV0dXJuIG5leHRUaWNrKCgpID0+IGNhbGxiYWNrKGVycmNvZGUoZXJyLCAnRVJSX0lOVkFMSURfQ0lEJykpKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYubGlicDJwLmRodC5wdXQoa2V5LCB2YWx1ZSwgY2FsbGJhY2spXG4gICAgfSksXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHBlZXJzIGluIHRoZSBESFQgdGhhdCBjYW4gcHJvdmlkZSBhIHNwZWNpZmljIHZhbHVlLCBnaXZlbiBhIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q0lEfSBrZXkgLSBUaGV5IGtleSB0byBmaW5kIHByb3ZpZGVycyBmb3IuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBmaW5kUHJvdmlkZXJzIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50aW1lb3V0IC0gaG93IGxvbmcgdGhlIHF1ZXJ5IHNob3VsZCBtYXhpbWFsbHkgcnVuLCBpbiBtaWxsaXNlY29uZHMgKGRlZmF1bHQ6IDYwMDAwKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1heE51bVByb3ZpZGVycyAtIG1heGltdW0gbnVtYmVyIG9mIHByb3ZpZGVycyB0byBmaW5kXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQXJyYXk8UGVlckluZm8+KX0gW2NhbGxiYWNrXVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFBlZXJJbmZvPnx2b2lkfVxuICAgICAqL1xuICAgIGZpbmRQcm92czogcHJvbWlzaWZ5KChrZXksIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICAgIG9wdGlvbnMgPSB7fVxuICAgICAgfVxuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBrZXkgPSBuZXcgQ0lEKGtleSlcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbG9nLmVycm9yKGVycilcblxuICAgICAgICAgIHJldHVybiBuZXh0VGljaygoKSA9PiBjYWxsYmFjayhlcnJjb2RlKGVyciwgJ0VSUl9JTlZBTElEX0NJRCcpKSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmLmxpYnAycC5jb250ZW50Um91dGluZy5maW5kUHJvdmlkZXJzKGtleSwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgfSksXG5cbiAgICAvKipcbiAgICAgKiBRdWVyeSB0aGUgREhUIGZvciBhbGwgbXVsdGlhZGRyZXNzZXMgYXNzb2NpYXRlZCB3aXRoIGEgYFBlZXJJZGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BlZXJJZH0gcGVlciAtIFRoZSBpZCBvZiB0aGUgcGVlciB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIFBlZXJJbmZvKX0gW2NhbGxiYWNrXVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFBlZXJJbmZvPnx2b2lkfVxuICAgICAqL1xuICAgIGZpbmRQZWVyOiBwcm9taXNpZnkoKHBlZXIsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHBlZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBlZXIgPSBQZWVySWQuY3JlYXRlRnJvbUI1OFN0cmluZyhwZWVyKVxuICAgICAgfVxuXG4gICAgICBzZWxmLmxpYnAycC5wZWVyUm91dGluZy5maW5kUGVlcihwZWVyLCBjYWxsYmFjaylcbiAgICB9KSxcblxuICAgIC8qKlxuICAgICAqIEFubm91bmNlIHRvIHRoZSBuZXR3b3JrIHRoYXQgd2UgYXJlIHByb3ZpZGluZyBnaXZlbiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NJRHxBcnJheTxDSUQ+fSBrZXlzIC0gVGhlIGtleXMgdGhhdCBzaG91bGQgYmUgYW5ub3VuY2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gcHJvdmlkZSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sfSBbb3B0aW9ucy5yZWN1cnNpdmU9ZmFsc2VdIC0gUHJvdmlkZSBub3Qgb25seSB0aGUgZ2l2ZW4gb2JqZWN0IGJ1dCBhbHNvIGFsbCBvYmplY3RzIGxpbmtlZCBmcm9tIGl0LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBbY2FsbGJhY2tdXG4gICAgICogQHJldHVybnMge1Byb21pc2V8dm9pZH1cbiAgICAgKi9cbiAgICBwcm92aWRlOiBwcm9taXNpZnkoKGtleXMsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAga2V5cyA9IFtrZXlzXVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgICAgICBvcHRpb25zID0ge31cbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICAgICAgLy8gZW5zdXJlIGJsb2NrcyBhcmUgYWN0dWFsbHkgbG9jYWxcbiAgICAgIGV2ZXJ5KGtleXMsIChrZXksIGNiKSA9PiB7XG4gICAgICAgIHNlbGYuX3JlcG8uYmxvY2tzLmhhcyhrZXksIGNiKVxuICAgICAgfSwgKGVyciwgaGFzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXMpIHtcbiAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnYmxvY2socykgbm90IGZvdW5kIGxvY2FsbHksIGNhbm5vdCBwcm92aWRlJ1xuXG4gICAgICAgICAgbG9nLmVycm9yKGVyck1zZylcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShlcnJNc2csICdFUlJfQkxPQ0tfTk9UX0ZPVU5EJykpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5yZWN1cnNpdmUpIHtcbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgcmVjdXJzaXZlIHByb3ZpZGluZ1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJjb2RlKCdub3QgaW1wbGVtZW50ZWQgeWV0JywgJ0VSUl9OT1RfSU1QTEVNRU5URURfWUVUJykpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWFjaChrZXlzLCAoY2lkLCBjYikgPT4ge1xuICAgICAgICAgICAgc2VsZi5saWJwMnAuY29udGVudFJvdXRpbmcucHJvdmlkZShjaWQsIGNiKVxuICAgICAgICAgIH0sIGNhbGxiYWNrKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pLFxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgY2xvc2VzdCBwZWVycyB0byBhIGdpdmVuIGBQZWVySWRgLCBieSBxdWVyeWluZyB0aGUgREhULlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQZWVySWR9IHBlZXIgLSBUaGUgYFBlZXJJZGAgdG8gcnVuIHRoZSBxdWVyeSBhZ2FpbnMuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQXJyYXk8UGVlckluZm8+KX0gW2NhbGxiYWNrXVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PFBlZXJJbmZvPj58dm9pZH1cbiAgICAgKi9cbiAgICBxdWVyeTogcHJvbWlzaWZ5KChwZWVySWQsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHBlZXJJZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwZWVySWQgPSBQZWVySWQuY3JlYXRlRnJvbUI1OFN0cmluZyhwZWVySWQpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZy5lcnJvcihlcnIpXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUT0RPIGV4cG9zZSB0aGlzIG1ldGhvZCBpbiBwZWVyUm91dGluZ1xuICAgICAgc2VsZi5saWJwMnAuX2RodC5nZXRDbG9zZXN0UGVlcnMocGVlcklkLnRvQnl0ZXMoKSwgKGVyciwgcGVlcklkcykgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgbG9nLmVycm9yKGVycilcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcGVlcklkcy5tYXAoKGlkKSA9PiBuZXcgUGVlckluZm8oaWQpKSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHByb21pc2lmeSA9IHJlcXVpcmUoJ3Byb21pc2lmeS1lczYnKVxuY29uc3QgQ0lEID0gcmVxdWlyZSgnY2lkcycpXG5jb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0nKVxuY29uc3QgaXRlclRvUHVsbCA9IHJlcXVpcmUoJ2FzeW5jLWl0ZXJhdG9yLXRvLXB1bGwtc3RyZWFtJylcbmNvbnN0IG1hcEFzeW5jID0gcmVxdWlyZSgnYXN5bmMvbWFwJylcbmNvbnN0IHNldEltbWVkaWF0ZSA9IHJlcXVpcmUoJ2FzeW5jL3NldEltbWVkaWF0ZScpXG5jb25zdCBmbGF0dGVuRGVlcCA9IHJlcXVpcmUoJ2p1c3QtZmxhdHRlbi1pdCcpXG5jb25zdCBlcnJDb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuY29uc3QgbXVsdGljb2RlYyA9IHJlcXVpcmUoJ211bHRpY29kZWMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRhZyAoc2VsZikge1xuICByZXR1cm4ge1xuICAgIHB1dDogcHJvbWlzaWZ5KChkYWdOb2RlLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgICAgICBvcHRpb25zID0ge31cbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICAgICAgaWYgKG9wdGlvbnMuY2lkICYmIChvcHRpb25zLmZvcm1hdCB8fCBvcHRpb25zLmhhc2hBbGcpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0NhblxcJ3QgcHV0IGRhZyBub2RlLiBQbGVhc2UgcHJvdmlkZSBlaXRoZXIgYGNpZGAgT1IgYGZvcm1hdGAgYW5kIGBoYXNoQWxnYCBvcHRpb25zLicpKVxuICAgICAgfSBlbHNlIGlmICgoKG9wdGlvbnMuZm9ybWF0ICYmICFvcHRpb25zLmhhc2hBbGcpIHx8ICghb3B0aW9ucy5mb3JtYXQgJiYgb3B0aW9ucy5oYXNoQWxnKSkpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignQ2FuXFwndCBwdXQgZGFnIG5vZGUuIFBsZWFzZSBwcm92aWRlIGBmb3JtYXRgIEFORCBgaGFzaEFsZ2Agb3B0aW9ucy4nKSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3B0aW9uRGVmYXVsdHMgPSB7XG4gICAgICAgIGZvcm1hdDogbXVsdGljb2RlYy5EQUdfQ0JPUixcbiAgICAgICAgaGFzaEFsZzogbXVsdGljb2RlYy5TSEEyXzI1NlxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgSVBMRCBleHBlY3RzIHRoZSBmb3JtYXQgYW5kIGhhc2hBbGcgYXMgY29uc3RhbnRzXG4gICAgICBpZiAob3B0aW9ucy5mb3JtYXQgJiYgdHlwZW9mIG9wdGlvbnMuZm9ybWF0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBjb25zdGFudE5hbWUgPSBvcHRpb25zLmZvcm1hdC50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLy0vZywgJ18nKVxuICAgICAgICBvcHRpb25zLmZvcm1hdCA9IG11bHRpY29kZWNbY29uc3RhbnROYW1lXVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuaGFzaEFsZyAmJiB0eXBlb2Ygb3B0aW9ucy5oYXNoQWxnID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBjb25zdGFudE5hbWUgPSBvcHRpb25zLmhhc2hBbGcudG9VcHBlckNhc2UoKS5yZXBsYWNlKC8tL2csICdfJylcbiAgICAgICAgb3B0aW9ucy5oYXNoQWxnID0gbXVsdGljb2RlY1tjb25zdGFudE5hbWVdXG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zLmNpZCA/IG9wdGlvbnMgOiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25EZWZhdWx0cywgb3B0aW9ucylcblxuICAgICAgLy8ganMtaXBsZCBkZWZhdWx0cyB0byB2ZXJpb24gMSBDSURzLiBIZW5jZSBzZXQgdmVyc2lvbiAwIGV4cGxpY2l0bHkgZm9yXG4gICAgICAvLyBkYWctcGIgbm9kZXNcbiAgICAgIGlmIChvcHRpb25zLnZlcnNpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5mb3JtYXQgPT09IG11bHRpY29kZWMuREFHX1BCICYmIG9wdGlvbnMuaGFzaEFsZyA9PT0gbXVsdGljb2RlYy5TSEEyXzI1Nikge1xuICAgICAgICAgIG9wdGlvbnMudmVyc2lvbiA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLnZlcnNpb24gPSAxXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi5faXBsZC5wdXQoZGFnTm9kZSwgb3B0aW9ucy5mb3JtYXQsIHtcbiAgICAgICAgaGFzaEFsZzogb3B0aW9ucy5oYXNoQWxnLFxuICAgICAgICBjaWRWZXJzaW9uOiBvcHRpb25zLnZlcnNpb25cbiAgICAgIH0pLnRoZW4oXG4gICAgICAgIChjaWQpID0+IHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5wcmVsb2FkICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgc2VsZi5fcHJlbG9hZChjaWQpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBjaWQpXG4gICAgICAgIH0sXG4gICAgICAgIChlcnJvcikgPT4gY2FsbGJhY2soZXJyb3IpXG4gICAgICApXG4gICAgfSksXG5cbiAgICBnZXQ6IHByb21pc2lmeSgoY2lkLCBwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gcGF0aFxuICAgICAgICBwYXRoID0gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNcblxuICAgICAgICAvLyBBbGxvdyBvcHRpb25zIGluIHBhdGggcG9zaXRpb25cbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIG9wdGlvbnMgPSBwYXRoXG4gICAgICAgICAgcGF0aCA9IHVuZGVmaW5lZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMgPSB7fVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgICAgIGlmICh0eXBlb2YgY2lkID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBzcGxpdCA9IGNpZC5zcGxpdCgnLycpXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjaWQgPSBuZXcgQ0lEKHNwbGl0WzBdKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKGVyckNvZGUoZXJyLCAnRVJSX0lOVkFMSURfQ0lEJykpKVxuICAgICAgICB9XG5cbiAgICAgICAgc3BsaXQuc2hpZnQoKVxuXG4gICAgICAgIGlmIChzcGxpdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcGF0aCA9IHNwbGl0LmpvaW4oJy8nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGggPSAnLydcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoY2lkKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNpZCA9IG5ldyBDSUQoY2lkKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKGVyckNvZGUoZXJyLCAnRVJSX0lOVkFMSURfQ0lEJykpKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnByZWxvYWQgIT09IGZhbHNlKSB7XG4gICAgICAgIHNlbGYuX3ByZWxvYWQoY2lkKVxuICAgICAgfVxuXG4gICAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkIHx8IHBhdGggPT09ICcvJykge1xuICAgICAgICBzZWxmLl9pcGxkLmdldChjaWQpLnRoZW4oXG4gICAgICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICByZW1haW5kZXJQYXRoOiAnJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIChlcnJvcikgPT4gY2FsbGJhY2soZXJyb3IpXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHNlbGYuX2lwbGQucmVzb2x2ZShjaWQsIHBhdGgpXG4gICAgICAgIGNvbnN0IHByb21pc2VkVmFsdWUgPSBvcHRpb25zLmxvY2FsUmVzb2x2ZSA/IHJlc3VsdC5maXJzdCgpIDogcmVzdWx0Lmxhc3QoKVxuICAgICAgICBwcm9taXNlZFZhbHVlLnRoZW4oXG4gICAgICAgICAgKHZhbHVlKSA9PiBjYWxsYmFjayhudWxsLCB2YWx1ZSksXG4gICAgICAgICAgKGVycm9yKSA9PiBjYWxsYmFjayhlcnJvcilcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0pLFxuXG4gICAgdHJlZTogcHJvbWlzaWZ5KChjaWQsIHBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgICAgICBvcHRpb25zID0gcGF0aFxuICAgICAgICBwYXRoID0gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IHBhdGhcbiAgICAgICAgcGF0aCA9IHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICAgIG9wdGlvbnMgPSB7fVxuICAgICAgfVxuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgICBpZiAodHlwZW9mIGNpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBjaWQuc3BsaXQoJy8nKVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2lkID0gbmV3IENJRChzcGxpdFswXSlcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhlcnJDb2RlKGVyciwgJ0VSUl9JTlZBTElEX0NJRCcpKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHNwbGl0LnNoaWZ0KClcblxuICAgICAgICBpZiAoc3BsaXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBhdGggPSBzcGxpdC5qb2luKCcvJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoID0gdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucHJlbG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgc2VsZi5fcHJlbG9hZChjaWQpXG4gICAgICB9XG5cbiAgICAgIHB1bGwoXG4gICAgICAgIGl0ZXJUb1B1bGwoc2VsZi5faXBsZC50cmVlKGNpZCwgcGF0aCwgb3B0aW9ucykpLFxuICAgICAgICBwdWxsLmNvbGxlY3QoY2FsbGJhY2spXG4gICAgICApXG4gICAgfSksXG5cbiAgICAvLyBUT0RPIC0gdXNlIElQTEQgc2VsZWN0b3JzIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWRcbiAgICBfZ2V0UmVjdXJzaXZlOiBwcm9taXNpZnkoKG11bHRpaGFzaCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgICAgIC8vIGdldHMgZmxhdCBhcnJheSBvZiBhbGwgREFHTm9kZXMgaW4gdHJlZSBnaXZlbiBieSBtdWx0aWhhc2hcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgICAgICBvcHRpb25zID0ge31cbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICAgICAgbGV0IGNpZFxuXG4gICAgICB0cnkge1xuICAgICAgICBjaWQgPSBuZXcgQ0lEKG11bHRpaGFzaClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKGVyckNvZGUoZXJyLCAnRVJSX0lOVkFMSURfQ0lEJykpKVxuICAgICAgfVxuXG4gICAgICBzZWxmLmRhZy5nZXQoY2lkLCAnJywgb3B0aW9ucywgKGVyciwgcmVzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycikgfVxuXG4gICAgICAgIG1hcEFzeW5jKHJlcy52YWx1ZS5MaW5rcywgKGxpbmssIGNiKSA9PiB7XG4gICAgICAgICAgc2VsZi5kYWcuX2dldFJlY3Vyc2l2ZShsaW5rLkhhc2gsIG9wdGlvbnMsIGNiKVxuICAgICAgICB9LCAoZXJyLCBub2RlcykgPT4ge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdub2RlczonLCBub2RlcylcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGZsYXR0ZW5EZWVwKFtyZXMudmFsdWUsIG5vZGVzXSkpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbiIsIi8qIGVzbGludCBtYXgtbmVzdGVkLWNhbGxiYWNrczogW1wiZXJyb3JcIiwgOF0gKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwcm9taXNpZnkgPSByZXF1aXJlKCdwcm9taXNpZnktZXM2JylcbmNvbnN0IHsgREFHTm9kZSwgREFHTGluaywgdXRpbCB9ID0gcmVxdWlyZSgnaXBsZC1kYWctcGInKVxuY29uc3QgQ0lEID0gcmVxdWlyZSgnY2lkcycpXG5jb25zdCBtYXAgPSByZXF1aXJlKCdhc3luYy9tYXAnKVxuY29uc3QgbWFwU2VyaWVzID0gcmVxdWlyZSgnYXN5bmMvbWFwU2VyaWVzJylcbmNvbnN0IHNlcmllcyA9IHJlcXVpcmUoJ2FzeW5jL3NlcmllcycpXG5jb25zdCBwYXJhbGxlbCA9IHJlcXVpcmUoJ2FzeW5jL3BhcmFsbGVsJylcbmNvbnN0IGVhY2hMaW1pdCA9IHJlcXVpcmUoJ2FzeW5jL2VhY2hMaW1pdCcpXG5jb25zdCB3YXRlcmZhbGwgPSByZXF1aXJlKCdhc3luYy93YXRlcmZhbGwnKVxuY29uc3QgZGV0ZWN0TGltaXQgPSByZXF1aXJlKCdhc3luYy9kZXRlY3RMaW1pdCcpXG5jb25zdCBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdhc3luYy9zZXRJbW1lZGlhdGUnKVxuY29uc3QgeyBLZXkgfSA9IHJlcXVpcmUoJ2ludGVyZmFjZS1kYXRhc3RvcmUnKVxuY29uc3QgZXJyQ29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcbmNvbnN0IG11bHRpYmFzZSA9IHJlcXVpcmUoJ211bHRpYmFzZScpXG5jb25zdCBtdWx0aWNvZGVjID0gcmVxdWlyZSgnbXVsdGljb2RlYycpXG5cbmNvbnN0IGNyZWF0ZVBpblNldCA9IHJlcXVpcmUoJy4vcGluLXNldCcpXG5jb25zdCB7IHJlc29sdmVQYXRoIH0gPSByZXF1aXJlKCcuLi91dGlscycpXG5cbi8vIGFyYml0cmFyeSBsaW1pdCB0byB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgZGFnIG9wZXJhdGlvbnNcbmNvbnN0IGNvbmN1cnJlbmN5TGltaXQgPSAzMDBcbmNvbnN0IHBpbkRhdGFTdG9yZUtleSA9IG5ldyBLZXkoJy9sb2NhbC9waW5zJylcblxuZnVuY3Rpb24gdG9CNThTdHJpbmcgKGhhc2gpIHtcbiAgcmV0dXJuIG5ldyBDSUQoaGFzaCkudG9CYXNlRW5jb2RlZFN0cmluZygpXG59XG5cbmZ1bmN0aW9uIGludmFsaWRQaW5UeXBlRXJyICh0eXBlKSB7XG4gIGNvbnN0IGVyck1zZyA9IGBJbnZhbGlkIHR5cGUgJyR7dHlwZX0nLCBtdXN0IGJlIG9uZSBvZiB7ZGlyZWN0LCBpbmRpcmVjdCwgcmVjdXJzaXZlLCBhbGx9YFxuICByZXR1cm4gZXJyQ29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9JTlZBTElEX1BJTl9UWVBFJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoc2VsZikgPT4ge1xuICBjb25zdCByZXBvID0gc2VsZi5fcmVwb1xuICBjb25zdCBkYWcgPSBzZWxmLmRhZ1xuICBjb25zdCBwaW5zZXQgPSBjcmVhdGVQaW5TZXQoZGFnKVxuICBjb25zdCB0eXBlcyA9IHtcbiAgICBkaXJlY3Q6ICdkaXJlY3QnLFxuICAgIHJlY3Vyc2l2ZTogJ3JlY3Vyc2l2ZScsXG4gICAgaW5kaXJlY3Q6ICdpbmRpcmVjdCcsXG4gICAgYWxsOiAnYWxsJ1xuICB9XG5cbiAgbGV0IGRpcmVjdFBpbnMgPSBuZXcgU2V0KClcbiAgbGV0IHJlY3Vyc2l2ZVBpbnMgPSBuZXcgU2V0KClcblxuICBjb25zdCBkaXJlY3RLZXlzID0gKCkgPT5cbiAgICBBcnJheS5mcm9tKGRpcmVjdFBpbnMpLm1hcChrZXkgPT4gbmV3IENJRChrZXkpLmJ1ZmZlcilcbiAgY29uc3QgcmVjdXJzaXZlS2V5cyA9ICgpID0+XG4gICAgQXJyYXkuZnJvbShyZWN1cnNpdmVQaW5zKS5tYXAoa2V5ID0+IG5ldyBDSUQoa2V5KS5idWZmZXIpXG5cbiAgZnVuY3Rpb24gZ2V0SW5kaXJlY3RLZXlzIChjYWxsYmFjaykge1xuICAgIGNvbnN0IGluZGlyZWN0S2V5cyA9IG5ldyBTZXQoKVxuICAgIGVhY2hMaW1pdChyZWN1cnNpdmVLZXlzKCksIGNvbmN1cnJlbmN5TGltaXQsIChtdWx0aWhhc2gsIGNiKSA9PiB7XG4gICAgICBkYWcuX2dldFJlY3Vyc2l2ZShtdWx0aWhhc2gsIChlcnIsIG5vZGVzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgbWFwKG5vZGVzLCAobm9kZSwgY2IpID0+IHV0aWwuY2lkKHV0aWwuc2VyaWFsaXplKG5vZGUpLCB7XG4gICAgICAgICAgY2lkVmVyc2lvbjogMFxuICAgICAgICB9KS50aGVuKGNpZCA9PiBjYihudWxsLCBjaWQpLCBjYiksIChlcnIsIGNpZHMpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNpZHNcbiAgICAgICAgICAgIC5tYXAoY2lkID0+IGNpZC50b1N0cmluZygpKVxuICAgICAgICAgICAgLy8gcmVjdXJzaXZlIHBpbnMgcHJlLWVtcHQgaW5kaXJlY3QgcGluc1xuICAgICAgICAgICAgLmZpbHRlcihrZXkgPT4gIXJlY3Vyc2l2ZVBpbnMuaGFzKGtleSkpXG4gICAgICAgICAgICAuZm9yRWFjaChrZXkgPT4gaW5kaXJlY3RLZXlzLmFkZChrZXkpKVxuXG4gICAgICAgICAgY2IoKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9LCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIEFycmF5LmZyb20oaW5kaXJlY3RLZXlzKSlcbiAgICB9KVxuICB9XG5cbiAgLy8gRW5jb2RlIGFuZCB3cml0ZSBwaW4ga2V5IHNldHMgdG8gdGhlIGRhdGFzdG9yZTpcbiAgLy8gYSBEQUdMaW5rIGZvciBlYWNoIG9mIHRoZSByZWN1cnNpdmUgYW5kIGRpcmVjdCBwaW5zZXRzXG4gIC8vIGEgREFHTm9kZSBob2xkaW5nIHRob3NlIGFzIERBR0xpbmtzLCBhIGtpbmQgb2Ygcm9vdCBwaW5cbiAgZnVuY3Rpb24gZmx1c2hQaW5zIChjYWxsYmFjaykge1xuICAgIGxldCBkTGluaywgckxpbmssIHJvb3RcbiAgICBzZXJpZXMoW1xuICAgICAgLy8gY3JlYXRlIGEgREFHTGluayB0byB0aGUgbm9kZSB3aXRoIGRpcmVjdCBwaW5zXG4gICAgICBjYiA9PiB3YXRlcmZhbGwoW1xuICAgICAgICBjYiA9PiBwaW5zZXQuc3RvcmVTZXQoZGlyZWN0S2V5cygpLCBjYiksXG4gICAgICAgICh7IG5vZGUsIGNpZCB9LCBjYikgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYihudWxsLCBuZXcgREFHTGluayh0eXBlcy5kaXJlY3QsIG5vZGUuc2l6ZSwgY2lkKSlcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNiKGVycilcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIChsaW5rLCBjYikgPT4geyBkTGluayA9IGxpbms7IGNiKG51bGwpIH1cbiAgICAgIF0sIGNiKSxcblxuICAgICAgLy8gY3JlYXRlIGEgREFHTGluayB0byB0aGUgbm9kZSB3aXRoIHJlY3Vyc2l2ZSBwaW5zXG4gICAgICBjYiA9PiB3YXRlcmZhbGwoW1xuICAgICAgICBjYiA9PiBwaW5zZXQuc3RvcmVTZXQocmVjdXJzaXZlS2V5cygpLCBjYiksXG4gICAgICAgICh7IG5vZGUsIGNpZCB9LCBjYikgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYihudWxsLCBuZXcgREFHTGluayh0eXBlcy5yZWN1cnNpdmUsIG5vZGUuc2l6ZSwgY2lkKSlcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNiKGVycilcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIChsaW5rLCBjYikgPT4geyByTGluayA9IGxpbms7IGNiKG51bGwpIH1cbiAgICAgIF0sIGNiKSxcblxuICAgICAgLy8gdGhlIHBpbi1zZXQgbm9kZXMgbGluayB0byBhIHNwZWNpYWwgJ2VtcHR5JyBub2RlLCBzbyBtYWtlIHN1cmUgaXQgZXhpc3RzXG4gICAgICBjYiA9PiB7XG4gICAgICAgIGxldCBlbXB0eVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZW1wdHkgPSBEQUdOb2RlLmNyZWF0ZShCdWZmZXIuYWxsb2MoMCkpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBkYWcucHV0KGVtcHR5LCB7XG4gICAgICAgICAgdmVyc2lvbjogMCxcbiAgICAgICAgICBmb3JtYXQ6IG11bHRpY29kZWMuREFHX1BCLFxuICAgICAgICAgIGhhc2hBbGc6IG11bHRpY29kZWMuU0hBMl8yNTYsXG4gICAgICAgICAgcHJlbG9hZDogZmFsc2VcbiAgICAgICAgfSwgY2IpXG4gICAgICB9LFxuXG4gICAgICAvLyBjcmVhdGUgYSByb290IG5vZGUgd2l0aCBEQUdMaW5rcyB0byB0aGUgZGlyZWN0IGFuZCByZWN1cnNpdmUgREFHc1xuICAgICAgY2IgPT4ge1xuICAgICAgICBsZXQgbm9kZVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbm9kZSA9IERBR05vZGUuY3JlYXRlKEJ1ZmZlci5hbGxvYygwKSwgW2RMaW5rLCByTGlua10pXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cblxuICAgICAgICByb290ID0gbm9kZVxuICAgICAgICBkYWcucHV0KHJvb3QsIHtcbiAgICAgICAgICB2ZXJzaW9uOiAwLFxuICAgICAgICAgIGZvcm1hdDogbXVsdGljb2RlYy5EQUdfUEIsXG4gICAgICAgICAgaGFzaEFsZzogbXVsdGljb2RlYy5TSEEyXzI1NixcbiAgICAgICAgICBwcmVsb2FkOiBmYWxzZVxuICAgICAgICB9LCAoZXJyLCBjaWQpID0+IHtcbiAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgcm9vdC5tdWx0aWhhc2ggPSBjaWQuYnVmZmVyXG4gICAgICAgICAgfVxuICAgICAgICAgIGNiKGVycilcbiAgICAgICAgfSlcbiAgICAgIH0sXG5cbiAgICAgIC8vIGhhY2sgZm9yIENMSSB0ZXN0c1xuICAgICAgY2IgPT4gcmVwby5jbG9zZWQgPyByZXBvLm9wZW4oY2IpIDogY2IobnVsbCwgbnVsbCksXG5cbiAgICAgIC8vIHNhdmUgcm9vdCB0byBkYXRhc3RvcmUgdW5kZXIgYSBjb25zaXN0ZW50IGtleVxuICAgICAgY2IgPT4gcmVwby5kYXRhc3RvcmUucHV0KHBpbkRhdGFTdG9yZUtleSwgcm9vdC5tdWx0aWhhc2gsIGNiKVxuICAgIF0sIChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKSB9XG4gICAgICBzZWxmLmxvZyhgRmx1c2hlZCBwaW5zIHdpdGggcm9vdDogJHtyb290fWApXG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcm9vdClcbiAgICB9KVxuICB9XG5cbiAgY29uc3QgcGluID0ge1xuICAgIGFkZDogcHJvbWlzaWZ5KChwYXRocywgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IHt9XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgICAgIGNvbnN0IHJlY3Vyc2l2ZSA9IG9wdGlvbnMucmVjdXJzaXZlID09IG51bGwgPyB0cnVlIDogb3B0aW9ucy5yZWN1cnNpdmVcblxuICAgICAgcmVzb2x2ZVBhdGgoc2VsZi5vYmplY3QsIHBhdGhzLCAoZXJyLCBtaHMpID0+IHtcbiAgICAgICAgaWYgKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKSB9XG5cbiAgICAgICAgLy8gdmVyaWZ5IHRoYXQgZWFjaCBoYXNoIGNhbiBiZSBwaW5uZWRcbiAgICAgICAgbWFwKG1ocywgKG11bHRpaGFzaCwgY2IpID0+IHtcbiAgICAgICAgICBjb25zdCBrZXkgPSB0b0I1OFN0cmluZyhtdWx0aWhhc2gpXG4gICAgICAgICAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgaWYgKHJlY3Vyc2l2ZVBpbnMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgLy8gaXQncyBhbHJlYWR5IHBpbm5lZCByZWN1cnNpdmVseVxuICAgICAgICAgICAgICByZXR1cm4gY2IobnVsbCwga2V5KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBlbnRpcmUgZ3JhcGggb2YgbmVzdGVkIGxpbmtzIHNob3VsZCBiZSBwaW5uZWQsXG4gICAgICAgICAgICAvLyBzbyBtYWtlIHN1cmUgd2UgaGF2ZSBhbGwgdGhlIG9iamVjdHNcbiAgICAgICAgICAgIGRhZy5fZ2V0UmVjdXJzaXZlKGtleSwgeyBwcmVsb2FkOiBvcHRpb25zLnByZWxvYWQgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7IHJldHVybiBjYihlcnIpIH1cbiAgICAgICAgICAgICAgLy8gZm91bmQgYWxsIG9iamVjdHMsIHdlIGNhbiBhZGQgdGhlIHBpblxuICAgICAgICAgICAgICByZXR1cm4gY2IobnVsbCwga2V5KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlY3Vyc2l2ZVBpbnMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlIHN1cGVyc2VkZXMgZGlyZWN0LCBjYW4ndCBoYXZlIGJvdGhcbiAgICAgICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgJHtrZXl9IGFscmVhZHkgcGlubmVkIHJlY3Vyc2l2ZWx5YCkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlyZWN0UGlucy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAvLyBhbHJlYWR5IGRpcmVjdGx5IHBpbm5lZFxuICAgICAgICAgICAgICByZXR1cm4gY2IobnVsbCwga2V5KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgaGF2ZSB0aGUgb2JqZWN0XG4gICAgICAgICAgICBkYWcuZ2V0KG5ldyBDSUQobXVsdGloYXNoKSwgeyBwcmVsb2FkOiBvcHRpb25zLnByZWxvYWQgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7IHJldHVybiBjYihlcnIpIH1cbiAgICAgICAgICAgICAgLy8gZm91bmQgdGhlIG9iamVjdCwgd2UgY2FuIGFkZCB0aGUgcGluXG4gICAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBrZXkpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgKGVyciwgcmVzdWx0cykgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycikgfVxuXG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSBwaW4gc2V0cyBpbiBtZW1vcnlcbiAgICAgICAgICBjb25zdCBwaW5zZXQgPSByZWN1cnNpdmUgPyByZWN1cnNpdmVQaW5zIDogZGlyZWN0UGluc1xuICAgICAgICAgIHJlc3VsdHMuZm9yRWFjaChrZXkgPT4gcGluc2V0LmFkZChrZXkpKVxuXG4gICAgICAgICAgLy8gcGVyc2lzdCB1cGRhdGVkIHBpbiBzZXRzIHRvIGRhdGFzdG9yZVxuICAgICAgICAgIGZsdXNoUGlucygoZXJyLCByb290KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMubWFwKGhhc2ggPT4gKHsgaGFzaCB9KSkpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSksXG5cbiAgICBybTogcHJvbWlzaWZ5KChwYXRocywgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICAgICAgY29uc3QgcmVjdXJzaXZlID0gb3B0aW9ucy5yZWN1cnNpdmUgPT0gbnVsbCA/IHRydWUgOiBvcHRpb25zLnJlY3Vyc2l2ZVxuXG4gICAgICBpZiAob3B0aW9ucy5jaWRCYXNlICYmICFtdWx0aWJhc2UubmFtZXMuaW5jbHVkZXMob3B0aW9ucy5jaWRCYXNlKSkge1xuICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJDb2RlKG5ldyBFcnJvcignaW52YWxpZCBtdWx0aWJhc2UnKSwgJ0VSUl9JTlZBTElEX01VTFRJQkFTRScpKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICByZXNvbHZlUGF0aChzZWxmLm9iamVjdCwgcGF0aHMsIChlcnIsIG1ocykgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpIH1cblxuICAgICAgICAvLyB2ZXJpZnkgdGhhdCBlYWNoIGhhc2ggY2FuIGJlIHVucGlubmVkXG4gICAgICAgIG1hcChtaHMsIChtdWx0aWhhc2gsIGNiKSA9PiB7XG4gICAgICAgICAgcGluLl9pc1Bpbm5lZFdpdGhUeXBlKG11bHRpaGFzaCwgdHlwZXMuYWxsLCAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNiKGVycikgfVxuICAgICAgICAgICAgY29uc3QgeyBwaW5uZWQsIHJlYXNvbiB9ID0gcmVzXG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0b0I1OFN0cmluZyhtdWx0aWhhc2gpXG4gICAgICAgICAgICBpZiAoIXBpbm5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKGAke2tleX0gaXMgbm90IHBpbm5lZGApKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKHJlYXNvbikge1xuICAgICAgICAgICAgICBjYXNlICh0eXBlcy5yZWN1cnNpdmUpOlxuICAgICAgICAgICAgICAgIGlmIChyZWN1cnNpdmUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBrZXkpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoYCR7a2V5fSBpcyBwaW5uZWQgcmVjdXJzaXZlbHlgKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgKHR5cGVzLmRpcmVjdCk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIGtleSlcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgYCR7a2V5fSBpcyBwaW5uZWQgaW5kaXJlY3RseSB1bmRlciAke3JlYXNvbn1gXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9LCAoZXJyLCByZXN1bHRzKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKSB9XG5cbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIHBpbiBzZXRzIGluIG1lbW9yeVxuICAgICAgICAgIHJlc3VsdHMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlY3Vyc2l2ZSAmJiByZWN1cnNpdmVQaW5zLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZVBpbnMuZGVsZXRlKGtleSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRpcmVjdFBpbnMuZGVsZXRlKGtleSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgLy8gcGVyc2lzdCB1cGRhdGVkIHBpbiBzZXRzIHRvIGRhdGFzdG9yZVxuICAgICAgICAgIGZsdXNoUGlucygoZXJyLCByb290KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpIH1cbiAgICAgICAgICAgIHNlbGYubG9nKGBSZW1vdmVkIHBpbnM6ICR7cmVzdWx0c31gKVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0cy5tYXAoaGFzaCA9PiAoeyBoYXNoIH0pKSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KSxcblxuICAgIGxzOiBwcm9taXNpZnkoKHBhdGhzLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgbGV0IHR5cGUgPSB0eXBlcy5hbGxcbiAgICAgIGlmICh0eXBlb2YgcGF0aHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBwYXRoc1xuICAgICAgICBvcHRpb25zID0ge31cbiAgICAgICAgcGF0aHMgPSBudWxsXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICB9XG4gICAgICBpZiAocGF0aHMgJiYgcGF0aHMudHlwZSkge1xuICAgICAgICBvcHRpb25zID0gcGF0aHNcbiAgICAgICAgcGF0aHMgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgICAgIGlmIChvcHRpb25zLnR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhpbnZhbGlkUGluVHlwZUVycihvcHRpb25zLnR5cGUpKSlcbiAgICAgICAgfVxuICAgICAgICB0eXBlID0gb3B0aW9ucy50eXBlLnRvTG93ZXJDYXNlKClcbiAgICAgIH1cbiAgICAgIGlmICghT2JqZWN0LmtleXModHlwZXMpLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2soaW52YWxpZFBpblR5cGVFcnIodHlwZSkpKVxuICAgICAgfVxuXG4gICAgICBpZiAocGF0aHMpIHtcbiAgICAgICAgLy8gY2hlY2sgdGhlIHBpbm5lZCBzdGF0ZSBvZiBzcGVjaWZpYyBoYXNoZXNcbiAgICAgICAgd2F0ZXJmYWxsKFtcbiAgICAgICAgICAoY2IpID0+IHJlc29sdmVQYXRoKHNlbGYub2JqZWN0LCBwYXRocywgY2IpLFxuICAgICAgICAgIChoYXNoZXMsIGNiKSA9PiBtYXBTZXJpZXMoaGFzaGVzLCAoaGFzaCwgZG9uZSkgPT4gcGluLl9pc1Bpbm5lZFdpdGhUeXBlKGhhc2gsIHR5cGVzLmFsbCwgZG9uZSksIGNiKSxcbiAgICAgICAgICAocmVzdWx0cywgY2IpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzXG4gICAgICAgICAgICAgIC5maWx0ZXIocmVzdWx0ID0+IHJlc3VsdC5waW5uZWQpXG4gICAgICAgICAgICAgIC5tYXAoKHsga2V5LCByZWFzb24gfSkgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzLmRpcmVjdDpcbiAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMucmVjdXJzaXZlOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiByZWFzb25cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICBoYXNoOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogYCR7dHlwZXMuaW5kaXJlY3R9IHRocm91Z2ggJHtyZWFzb259YFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBpZiAoIXJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoYFBhdGggaXMgbm90IHBpbm5lZGApKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYihudWxsLCByZXN1bHRzKVxuICAgICAgICAgIH1cbiAgICAgICAgXSwgY2FsbGJhY2spXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzaG93IGFsbCBwaW5uZWQgaXRlbXMgb2YgdHlwZVxuICAgICAgICBsZXQgcGlucyA9IFtdXG4gICAgICAgIGlmICh0eXBlID09PSB0eXBlcy5kaXJlY3QgfHwgdHlwZSA9PT0gdHlwZXMuYWxsKSB7XG4gICAgICAgICAgcGlucyA9IHBpbnMuY29uY2F0KFxuICAgICAgICAgICAgQXJyYXkuZnJvbShkaXJlY3RQaW5zKS5tYXAoaGFzaCA9PiAoe1xuICAgICAgICAgICAgICB0eXBlOiB0eXBlcy5kaXJlY3QsXG4gICAgICAgICAgICAgIGhhc2hcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gdHlwZXMucmVjdXJzaXZlIHx8IHR5cGUgPT09IHR5cGVzLmFsbCkge1xuICAgICAgICAgIHBpbnMgPSBwaW5zLmNvbmNhdChcbiAgICAgICAgICAgIEFycmF5LmZyb20ocmVjdXJzaXZlUGlucykubWFwKGhhc2ggPT4gKHtcbiAgICAgICAgICAgICAgdHlwZTogdHlwZXMucmVjdXJzaXZlLFxuICAgICAgICAgICAgICBoYXNoXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IHR5cGVzLmluZGlyZWN0IHx8IHR5cGUgPT09IHR5cGVzLmFsbCkge1xuICAgICAgICAgIGdldEluZGlyZWN0S2V5cygoZXJyLCBpbmRpcmVjdHMpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycikgfVxuICAgICAgICAgICAgcGlucyA9IHBpbnNcbiAgICAgICAgICAgICAgLy8gaWYgc29tZXRoaW5nIGlzIHBpbm5lZCBib3RoIGRpcmVjdGx5IGFuZCBpbmRpcmVjdGx5LFxuICAgICAgICAgICAgICAvLyByZXBvcnQgdGhlIGluZGlyZWN0IGVudHJ5XG4gICAgICAgICAgICAgIC5maWx0ZXIoKHsgaGFzaCB9KSA9PlxuICAgICAgICAgICAgICAgICFpbmRpcmVjdHMuaW5jbHVkZXMoaGFzaCkgfHxcbiAgICAgICAgICAgICAgICAoaW5kaXJlY3RzLmluY2x1ZGVzKGhhc2gpICYmICFkaXJlY3RQaW5zLmhhcyhoYXNoKSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAuY29uY2F0KGluZGlyZWN0cy5tYXAoaGFzaCA9PiAoe1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVzLmluZGlyZWN0LFxuICAgICAgICAgICAgICAgIGhhc2hcbiAgICAgICAgICAgICAgfSkpKVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHBpbnMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBwaW5zKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG5cbiAgICBfaXNQaW5uZWRXaXRoVHlwZTogcHJvbWlzaWZ5KChtdWx0aWhhc2gsIHR5cGUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSB0b0I1OFN0cmluZyhtdWx0aWhhc2gpXG4gICAgICBjb25zdCB7IHJlY3Vyc2l2ZSwgZGlyZWN0LCBhbGwgfSA9IHR5cGVzXG5cbiAgICAgIC8vIHJlY3Vyc2l2ZVxuICAgICAgaWYgKCh0eXBlID09PSByZWN1cnNpdmUgfHwgdHlwZSA9PT0gYWxsKSAmJiByZWN1cnNpdmVQaW5zLmhhcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHBpbm5lZDogdHJ1ZSxcbiAgICAgICAgICByZWFzb246IHJlY3Vyc2l2ZVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSA9PT0gcmVjdXJzaXZlKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHBpbm5lZDogZmFsc2VcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gZGlyZWN0XG4gICAgICBpZiAoKHR5cGUgPT09IGRpcmVjdCB8fCB0eXBlID09PSBhbGwpICYmIGRpcmVjdFBpbnMuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgcGlubmVkOiB0cnVlLFxuICAgICAgICAgIHJlYXNvbjogZGlyZWN0XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSBkaXJlY3QpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgcGlubmVkOiBmYWxzZVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyBpbmRpcmVjdCAoZGVmYXVsdClcbiAgICAgIC8vIGNoZWNrIGVhY2ggcmVjdXJzaXZlIGtleSB0byBzZWUgaWYgbXVsdGloYXNoIGlzIHVuZGVyIGl0XG4gICAgICAvLyBhcmJpdHJhcnkgbGltaXQsIGVuYWJsZXMgaGFuZGxpbmcgMTAwMHMgb2YgcGlucy5cbiAgICAgIGRldGVjdExpbWl0KHJlY3Vyc2l2ZUtleXMoKS5tYXAoa2V5ID0+IG5ldyBDSUQoa2V5KSksIGNvbmN1cnJlbmN5TGltaXQsIChjaWQsIGNiKSA9PiB7XG4gICAgICAgIHdhdGVyZmFsbChbXG4gICAgICAgICAgKGRvbmUpID0+IGRhZy5nZXQoY2lkLCAnJywgeyBwcmVsb2FkOiBmYWxzZSB9LCBkb25lKSxcbiAgICAgICAgICAocmVzdWx0LCBkb25lKSA9PiBkb25lKG51bGwsIHJlc3VsdC52YWx1ZSksXG4gICAgICAgICAgKG5vZGUsIGRvbmUpID0+IHBpbnNldC5oYXNEZXNjZW5kYW50KG5vZGUsIGtleSwgZG9uZSlcbiAgICAgICAgXSwgY2IpXG4gICAgICB9LCAoZXJyLCBjaWQpID0+IGNhbGxiYWNrKGVyciwge1xuICAgICAgICBrZXksXG4gICAgICAgIHBpbm5lZDogQm9vbGVhbihjaWQpLFxuICAgICAgICByZWFzb246IGNpZFxuICAgICAgfSkpXG4gICAgfSksXG5cbiAgICBfbG9hZDogcHJvbWlzaWZ5KGNhbGxiYWNrID0+IHtcbiAgICAgIHdhdGVyZmFsbChbXG4gICAgICAgIC8vIGhhY2sgZm9yIENMSSB0ZXN0c1xuICAgICAgICAoY2IpID0+IHJlcG8uY2xvc2VkID8gcmVwby5kYXRhc3RvcmUub3BlbihjYikgOiBjYihudWxsLCBudWxsKSxcbiAgICAgICAgKF8sIGNiKSA9PiByZXBvLmRhdGFzdG9yZS5oYXMocGluRGF0YVN0b3JlS2V5LCBjYiksXG4gICAgICAgIChoYXMsIGNiKSA9PiBoYXMgPyBjYigpIDogY2IobmV3IEVycm9yKCdObyBwaW5zIHRvIGxvYWQnKSksXG4gICAgICAgIChjYikgPT4gcmVwby5kYXRhc3RvcmUuZ2V0KHBpbkRhdGFTdG9yZUtleSwgY2IpLFxuICAgICAgICAobWgsIGNiKSA9PiB7XG4gICAgICAgICAgZGFnLmdldChuZXcgQ0lEKG1oKSwgJycsIHsgcHJlbG9hZDogZmFsc2UgfSwgY2IpXG4gICAgICAgIH1cbiAgICAgIF0sIChlcnIsIHBpblJvb3QpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGlmIChlcnIubWVzc2FnZSA9PT0gJ05vIHBpbnMgdG8gbG9hZCcpIHtcbiAgICAgICAgICAgIHNlbGYubG9nKCdObyBwaW5zIHRvIGxvYWQnKVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbGxlbChbXG4gICAgICAgICAgY2IgPT4gcGluc2V0LmxvYWRTZXQocGluUm9vdC52YWx1ZSwgdHlwZXMucmVjdXJzaXZlLCBjYiksXG4gICAgICAgICAgY2IgPT4gcGluc2V0LmxvYWRTZXQocGluUm9vdC52YWx1ZSwgdHlwZXMuZGlyZWN0LCBjYilcbiAgICAgICAgXSwgKGVyciwga2V5cykgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycikgfVxuICAgICAgICAgIGNvbnN0IFsgcktleXMsIGRLZXlzIF0gPSBrZXlzXG5cbiAgICAgICAgICBkaXJlY3RQaW5zID0gbmV3IFNldChkS2V5cy5tYXAodG9CNThTdHJpbmcpKVxuICAgICAgICAgIHJlY3Vyc2l2ZVBpbnMgPSBuZXcgU2V0KHJLZXlzLm1hcCh0b0I1OFN0cmluZykpXG5cbiAgICAgICAgICBzZWxmLmxvZygnTG9hZGVkIHBpbnMgZnJvbSB0aGUgZGF0YXN0b3JlJylcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbClcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBwaW5cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcbmNvbnN0IHByb21pc2lmeSA9IHJlcXVpcmUoJ3Byb21pc2lmeS1lczYnKVxuY29uc3Qgd2F0ZXJmYWxsID0gcmVxdWlyZSgnYXN5bmMvd2F0ZXJmYWxsJylcbmNvbnN0IHBhcmFsbGVsID0gcmVxdWlyZSgnYXN5bmMvcGFyYWxsZWwnKVxuY29uc3QgaHVtYW4gPSByZXF1aXJlKCdodW1hbi10by1taWxsaXNlY29uZHMnKVxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnbGlicDJwLWNyeXB0bycpXG5jb25zdCBlcnJjb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuXG5jb25zdCBsb2cgPSBkZWJ1ZygnaXBmczpuYW1lJylcbmxvZy5lcnJvciA9IGRlYnVnKCdpcGZzOm5hbWU6ZXJyb3InKVxuXG5jb25zdCBuYW1lUHVic3ViID0gcmVxdWlyZSgnLi9uYW1lLXB1YnN1YicpXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCcuLi9pcG5zL3BhdGgnKVxuXG5jb25zdCBrZXlMb29rdXAgPSAoaXBmc05vZGUsIGtuYW1lLCBjYWxsYmFjaykgPT4ge1xuICBpZiAoa25hbWUgPT09ICdzZWxmJykge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBpcGZzTm9kZS5fcGVlckluZm8uaWQucHJpdktleSlcbiAgfVxuXG4gIGNvbnN0IHBhc3MgPSBpcGZzTm9kZS5fb3B0aW9ucy5wYXNzXG5cbiAgd2F0ZXJmYWxsKFtcbiAgICAoY2IpID0+IGlwZnNOb2RlLl9rZXljaGFpbi5leHBvcnRLZXkoa25hbWUsIHBhc3MsIGNiKSxcbiAgICAocGVtLCBjYikgPT4gY3J5cHRvLmtleXMuX19pbXBvcnRfXyhwZW0sIHBhc3MsIGNiKVxuICBdLCAoZXJyLCBwcml2YXRlS2V5KSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgbG9nLmVycm9yKGVycilcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnJjb2RlKGVyciwgJ0VSUl9DQU5OT1RfR0VUX0tFWScpKVxuICAgIH1cblxuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBwcml2YXRlS2V5KVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5hbWUgKHNlbGYpIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBJUE5TIGlzIGEgUEtJIG5hbWVzcGFjZSwgd2hlcmUgbmFtZXMgYXJlIHRoZSBoYXNoZXMgb2YgcHVibGljIGtleXMsIGFuZFxuICAgICAqIHRoZSBwcml2YXRlIGtleSBlbmFibGVzIHB1Ymxpc2hpbmcgbmV3IChzaWduZWQpIHZhbHVlcy4gSW4gYm90aCBwdWJsaXNoXG4gICAgICogYW5kIHJlc29sdmUsIHRoZSBkZWZhdWx0IG5hbWUgdXNlZCBpcyB0aGUgbm9kZSdzIG93biBQZWVySUQsXG4gICAgICogd2hpY2ggaXMgdGhlIGhhc2ggb2YgaXRzIHB1YmxpYyBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgaXBmcyBwYXRoIG9mIHRoZSBvYmplY3QgdG8gYmUgcHVibGlzaGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGlwZnMgcHVibGlzaCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5yZXNvbHZlIHJlc29sdmUgZ2l2ZW4gcGF0aCBiZWZvcmUgcHVibGlzaGluZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5saWZldGltZSB0aW1lIGR1cmF0aW9uIHRoYXQgdGhlIHJlY29yZCB3aWxsIGJlIHZhbGlkIGZvci5cbiAgICBUaGlzIGFjY2VwdHMgZHVyYXRpb25zIHN1Y2ggYXMgXCIzMDBzXCIsIFwiMS41aFwiIG9yIFwiMmg0NW1cIi4gVmFsaWQgdGltZSB1bml0cyBhcmVcbiAgICBcIm5zXCIsIFwibXNcIiwgXCJzXCIsIFwibVwiLCBcImhcIi4gRGVmYXVsdCBpcyAyNGguXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudHRsIHRpbWUgZHVyYXRpb24gdGhpcyByZWNvcmQgc2hvdWxkIGJlIGNhY2hlZCBmb3IgKE5PVCBJTVBMRU1FTlRFRCBZRVQpLlxuICAgICAqIFRoaXMgYWNjZXB0cyBkdXJhdGlvbnMgc3VjaCBhcyBcIjMwMHNcIiwgXCIxLjVoXCIgb3IgXCIyaDQ1bVwiLiBWYWxpZCB0aW1lIHVuaXRzIGFyZVxuICAgICBcIm5zXCIsIFwibXNcIiwgXCJzXCIsIFwibVwiLCBcImhcIiAoY2F1dGlvbjogZXhwZXJpbWVudGFsKS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5rZXkgbmFtZSBvZiB0aGUga2V5IHRvIGJlIHVzZWQsIGFzIGxpc3RlZCBieSAnaXBmcyBrZXkgbGlzdCAtbCcuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IFtjYWxsYmFja11cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZXx2b2lkfVxuICAgICAqL1xuICAgIHB1Ymxpc2g6IHByb21pc2lmeSgodmFsdWUsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICAgIG9wdGlvbnMgPSB7fVxuICAgICAgfVxuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgICAgY29uc3QgcmVzb2x2ZSA9ICEob3B0aW9ucy5yZXNvbHZlID09PSBmYWxzZSlcbiAgICAgIGNvbnN0IGxpZmV0aW1lID0gb3B0aW9ucy5saWZldGltZSB8fCAnMjRoJ1xuICAgICAgY29uc3Qga2V5ID0gb3B0aW9ucy5rZXkgfHwgJ3NlbGYnXG5cbiAgICAgIGlmICghc2VsZi5pc09ubGluZSgpKSB7XG4gICAgICAgIGNvbnN0IGVyck1zZyA9IHV0aWxzLk9GRkxJTkVfRVJST1JcblxuICAgICAgICBsb2cuZXJyb3IoZXJyTXNnKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShlcnJNc2csICdPRkZMSU5FX0VSUk9SJykpXG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IHBhcmFtcyByZWxhdGVkIGxvZ2ljIHNob3VsZCBiZSBpbiB0aGUgY29yZSBpbXBsZW1lbnRhdGlvblxuXG4gICAgICAvLyBOb3JtYWxpemUgcGF0aCB2YWx1ZVxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWUgPSB1dGlscy5ub3JtYWxpemVQYXRoKHZhbHVlKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5lcnJvcihlcnIpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIHBhcmFsbGVsKFtcbiAgICAgICAgKGNiKSA9PiBodW1hbihsaWZldGltZSwgY2IpLFxuICAgICAgICAvLyAoY2IpID0+IHR0bCA/IGh1bWFuKHR0bCwgY2IpIDogY2IoKSxcbiAgICAgICAgKGNiKSA9PiBrZXlMb29rdXAoc2VsZiwga2V5LCBjYiksXG4gICAgICAgIC8vIHZlcmlmeSBpZiB0aGUgcGF0aCBleGlzdHMsIGlmIG5vdCwgYW4gZXJyb3Igd2lsbCBzdG9wIHRoZSBleGVjdXRpb25cbiAgICAgICAgKGNiKSA9PiByZXNvbHZlLnRvU3RyaW5nKCkgPT09ICd0cnVlJyA/IHBhdGgucmVzb2x2ZVBhdGgoc2VsZiwgdmFsdWUsIGNiKSA6IGNiKClcbiAgICAgIF0sIChlcnIsIHJlc3VsdHMpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGxvZy5lcnJvcihlcnIpXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBsaWZldGltZSB3aXRoIG5hbm9zZWNvbmRzIHByZWNpc2lvblxuICAgICAgICBjb25zdCBwdWJMaWZldGltZSA9IHJlc3VsdHNbMF0udG9GaXhlZCg2KVxuICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gcmVzdWx0c1sxXVxuXG4gICAgICAgIC8vIFRPRE8gSU1QUk9WRU1FTlQgLSBIYW5kbGUgdHRsIGZvciBjYWNoZVxuICAgICAgICAvLyBjb25zdCB0dGwgPSByZXN1bHRzWzFdXG4gICAgICAgIC8vIGNvbnN0IHByaXZhdGVLZXkgPSByZXN1bHRzWzJdXG5cbiAgICAgICAgLy8gU3RhcnQgcHVibGlzaGluZyBwcm9jZXNzXG4gICAgICAgIHNlbGYuX2lwbnMucHVibGlzaChwcml2YXRlS2V5LCB2YWx1ZSwgcHViTGlmZXRpbWUsIGNhbGxiYWNrKVxuICAgICAgfSlcbiAgICB9KSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEga2V5LCBxdWVyeSB0aGUgREhUIGZvciBpdHMgYmVzdCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGlwbnMgbmFtZSB0byByZXNvbHZlLiBEZWZhdWx0cyB0byB5b3VyIG5vZGUncyBwZWVySUQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgaXBmcyByZXNvbHZlIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLm5vY2FjaGUgZG8gbm90IHVzZSBjYWNoZWQgZW50cmllcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMucmVjdXJzaXZlIHJlc29sdmUgdW50aWwgdGhlIHJlc3VsdCBpcyBub3QgYW4gSVBOUyBuYW1lLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBbY2FsbGJhY2tdXG4gICAgICogQHJldHVybnMge1Byb21pc2V8dm9pZH1cbiAgICAgKi9cbiAgICByZXNvbHZlOiBwcm9taXNpZnkoKG5hbWUsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICAgIG9wdGlvbnMgPSB7fVxuICAgICAgfVxuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgICAgY29uc3Qgbm9jYWNoZSA9IG9wdGlvbnMubm9jYWNoZSAmJiBvcHRpb25zLm5vY2FjaGUudG9TdHJpbmcoKSA9PT0gJ3RydWUnXG4gICAgICBjb25zdCByZWN1cnNpdmUgPSBvcHRpb25zLnJlY3Vyc2l2ZSAmJiBvcHRpb25zLnJlY3Vyc2l2ZS50b1N0cmluZygpID09PSAndHJ1ZSdcblxuICAgICAgY29uc3Qgb2ZmbGluZSA9IHNlbGYuX29wdGlvbnMub2ZmbGluZVxuXG4gICAgICBpZiAoIXNlbGYuaXNPbmxpbmUoKSAmJiAhb2ZmbGluZSkge1xuICAgICAgICBjb25zdCBlcnJNc2cgPSB1dGlscy5PRkZMSU5FX0VSUk9SXG5cbiAgICAgICAgbG9nLmVycm9yKGVyck1zZylcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUoZXJyTXNnLCAnT0ZGTElORV9FUlJPUicpKVxuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBwYXJhbXMgcmVsYXRlZCBsb2dpYyBzaG91bGQgYmUgaW4gdGhlIGNvcmUgaW1wbGVtZW50YXRpb25cblxuICAgICAgaWYgKG9mZmxpbmUgJiYgbm9jYWNoZSkge1xuICAgICAgICBjb25zdCBlcnJvciA9ICdjYW5ub3Qgc3BlY2lmeSBib3RoIG9mZmxpbmUgYW5kIG5vY2FjaGUnXG5cbiAgICAgICAgbG9nLmVycm9yKGVycm9yKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyb3IpLCAnRVJSX05PQ0FDSEVfQU5EX09GRkxJTkUnKSlcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IG5vZGUgaWQgYXMgbmFtZSBmb3IgYmVpbmcgcmVzb2x2ZWQsIGlmIGl0IGlzIG5vdCByZWNlaXZlZFxuICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBzZWxmLl9wZWVySW5mby5pZC50b0I1OFN0cmluZygpXG4gICAgICB9XG5cbiAgICAgIGlmICghbmFtZS5zdGFydHNXaXRoKCcvaXBucy8nKSkge1xuICAgICAgICBuYW1lID0gYC9pcG5zLyR7bmFtZX1gXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc29sdmVPcHRpb25zID0ge1xuICAgICAgICBub2NhY2hlLFxuICAgICAgICByZWN1cnNpdmVcbiAgICAgIH1cblxuICAgICAgc2VsZi5faXBucy5yZXNvbHZlKG5hbWUsIHJlc29sdmVPcHRpb25zLCBjYWxsYmFjaylcbiAgICB9KSxcbiAgICBwdWJzdWI6IG5hbWVQdWJzdWIoc2VsZilcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBlZXJJZCA9IHJlcXVpcmUoJ3BlZXItaWQnKVxuY29uc3QgUGVlckluZm8gPSByZXF1aXJlKCdwZWVyLWluZm8nKVxuY29uc3QgbXVsdGlhZGRyID0gcmVxdWlyZSgnbXVsdGlhZGRyJylcbmNvbnN0IHdhdGVyZmFsbCA9IHJlcXVpcmUoJ2FzeW5jL3dhdGVyZmFsbCcpXG5jb25zdCBLZXljaGFpbiA9IHJlcXVpcmUoJ2xpYnAycC1rZXljaGFpbicpXG5jb25zdCBtZXJnZU9wdGlvbnMgPSByZXF1aXJlKCdtZXJnZS1vcHRpb25zJylcbmNvbnN0IE5vS2V5Y2hhaW4gPSByZXF1aXJlKCcuL25vLWtleWNoYWluJylcbi8qXG4gKiBMb2FkIHN0dWZmIGZyb20gUmVwbyBpbnRvIG1lbW9yeVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHByZVN0YXJ0IChzZWxmKSB7XG4gIHJldHVybiAoY2FsbGJhY2spID0+IHtcbiAgICBzZWxmLmxvZygncHJlLXN0YXJ0JylcblxuICAgIGNvbnN0IHBhc3MgPSBzZWxmLl9vcHRpb25zLnBhc3NcbiAgICB3YXRlcmZhbGwoW1xuICAgICAgKGNiKSA9PiBzZWxmLl9yZXBvLmNvbmZpZy5nZXQoY2IpLFxuICAgICAgKGNvbmZpZywgY2IpID0+IHtcbiAgICAgICAgaWYgKCFzZWxmLl9vcHRpb25zLmNvbmZpZykge1xuICAgICAgICAgIHJldHVybiBjYihudWxsLCBjb25maWcpXG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcgPSBtZXJnZU9wdGlvbnMoY29uZmlnLCBzZWxmLl9vcHRpb25zLmNvbmZpZylcblxuICAgICAgICBzZWxmLmNvbmZpZy5yZXBsYWNlKGNvbmZpZywgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2IobnVsbCwgY29uZmlnKVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIChjb25maWcsIGNiKSA9PiB7XG4gICAgICAgIC8vIENyZWF0ZSBrZXljaGFpbiBjb25maWd1cmF0aW9uLCBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChjb25maWcuS2V5Y2hhaW4pIHtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbCwgY29uZmlnKVxuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5LZXljaGFpbiA9IEtleWNoYWluLmdlbmVyYXRlT3B0aW9ucygpXG4gICAgICAgIHNlbGYuY29uZmlnLnNldCgnS2V5Y2hhaW4nLCBjb25maWcuS2V5Y2hhaW4sIChlcnIpID0+IHtcbiAgICAgICAgICBzZWxmLmxvZygndXNpbmcgZGVmYXVsdCBrZXljaGFpbiBvcHRpb25zJylcbiAgICAgICAgICBjYihlcnIsIGNvbmZpZylcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICAoY29uZmlnLCBjYikgPT4ge1xuICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIGtleWNoYWluXG4gICAgICAgIGlmIChzZWxmLl9rZXljaGFpbikge1xuICAgICAgICAgIC8vIG1vc3QgbGlrZWx5IGFuIGluaXQgb3IgdXBncmFkZSBoYXMgaGFwcGVuZWRcbiAgICAgICAgfSBlbHNlIGlmIChwYXNzKSB7XG4gICAgICAgICAgY29uc3Qga2V5Y2hhaW5PcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHBhc3NQaHJhc2U6IHBhc3MgfSwgY29uZmlnLktleWNoYWluKVxuICAgICAgICAgIHNlbGYuX2tleWNoYWluID0gbmV3IEtleWNoYWluKHNlbGYuX3JlcG8ua2V5cywga2V5Y2hhaW5PcHRpb25zKVxuICAgICAgICAgIHNlbGYubG9nKCdrZXljaGFpbiBjb25zdHJ1Y3RlZCcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5fa2V5Y2hhaW4gPSBuZXcgTm9LZXljaGFpbigpXG4gICAgICAgICAgc2VsZi5sb2coJ25vIGtleWNoYWluLCB1c2UgLS1wYXNzJylcbiAgICAgICAgfVxuICAgICAgICBjYihudWxsLCBjb25maWcpXG4gICAgICB9LFxuICAgICAgKGNvbmZpZywgY2IpID0+IHtcbiAgICAgICAgY29uc3QgcHJpdktleSA9IGNvbmZpZy5JZGVudGl0eS5Qcml2S2V5XG5cbiAgICAgICAgcGVlcklkLmNyZWF0ZUZyb21Qcml2S2V5KHByaXZLZXksIChlcnIsIGlkKSA9PiB7XG4gICAgICAgICAgY2IoZXJyLCBjb25maWcsIGlkKVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIChjb25maWcsIGlkLCBjYikgPT4ge1xuICAgICAgICAvLyBJbXBvcnQgdGhlIHByaXZhdGUga2V5IGFzICdzZWxmJywgaWYgbmVlZGVkLlxuICAgICAgICBpZiAoIXBhc3MpIHtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbCwgY29uZmlnLCBpZClcbiAgICAgICAgfVxuICAgICAgICBzZWxmLl9rZXljaGFpbi5maW5kS2V5QnlOYW1lKCdzZWxmJywgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHNlbGYubG9nKCdDcmVhdGluZyBcInNlbGZcIiBrZXknKVxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2tleWNoYWluLmltcG9ydFBlZXIoJ3NlbGYnLCBpZCwgKGVycikgPT4gY2IoZXJyLCBjb25maWcsIGlkKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgY2IobnVsbCwgY29uZmlnLCBpZClcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICAoY29uZmlnLCBpZCwgY2IpID0+IHtcbiAgICAgICAgc2VsZi5sb2coJ3BlZXIgY3JlYXRlZCcpXG4gICAgICAgIHNlbGYuX3BlZXJJbmZvID0gbmV3IFBlZXJJbmZvKGlkKVxuXG4gICAgICAgIGlmIChjb25maWcuQWRkcmVzc2VzICYmIGNvbmZpZy5BZGRyZXNzZXMuU3dhcm0pIHtcbiAgICAgICAgICBjb25maWcuQWRkcmVzc2VzLlN3YXJtLmZvckVhY2goKGFkZHIpID0+IHtcbiAgICAgICAgICAgIGxldCBtYSA9IG11bHRpYWRkcihhZGRyKVxuXG4gICAgICAgICAgICBpZiAobWEuZ2V0UGVlcklkKCkpIHtcbiAgICAgICAgICAgICAgbWEgPSBtYS5lbmNhcHN1bGF0ZSgnL2lwZnMvJyArIHNlbGYuX3BlZXJJbmZvLmlkLnRvQjU4U3RyaW5nKCkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuX3BlZXJJbmZvLm11bHRpYWRkcnMuYWRkKG1hKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBjYigpXG4gICAgICB9LFxuICAgICAgKGNiKSA9PiBzZWxmLnBpbi5fbG9hZChjYilcbiAgICBdLCBjYWxsYmFjaylcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHNlcmllcyA9IHJlcXVpcmUoJ2FzeW5jL3NlcmllcycpXG5jb25zdCBCaXRzd2FwID0gcmVxdWlyZSgnaXBmcy1iaXRzd2FwJylcbmNvbnN0IHNldEltbWVkaWF0ZSA9IHJlcXVpcmUoJ2FzeW5jL3NldEltbWVkaWF0ZScpXG5jb25zdCBwcm9taXNpZnkgPSByZXF1aXJlKCdwcm9taXNpZnktZXM2JylcblxuY29uc3QgSVBOUyA9IHJlcXVpcmUoJy4uL2lwbnMnKVxuY29uc3Qgcm91dGluZ0NvbmZpZyA9IHJlcXVpcmUoJy4uL2lwbnMvcm91dGluZy9jb25maWcnKVxuY29uc3QgY3JlYXRlTGlicDJwQnVuZGxlID0gcmVxdWlyZSgnLi9saWJwMnAnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChzZWxmKSA9PiB7XG4gIHJldHVybiBwcm9taXNpZnkoKGNhbGxiYWNrKSA9PiB7XG4gICAgY29uc3QgZG9uZSA9IChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBzZWxmLnN0YXRlLnN0YXJ0ZWQoKVxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHNlbGYuZW1pdCgnc3RhcnQnKSlcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5zdGF0ZS5zdGF0ZSgpICE9PSAnc3RvcHBlZCcpIHtcbiAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcihgTm90IGFibGUgdG8gc3RhcnQgZnJvbSBzdGF0ZTogJHtzZWxmLnN0YXRlLnN0YXRlKCl9YCkpXG4gICAgfVxuXG4gICAgc2VsZi5sb2coJ3N0YXJ0aW5nJylcbiAgICBzZWxmLnN0YXRlLnN0YXJ0KClcblxuICAgIHNlcmllcyhbXG4gICAgICAoY2IpID0+IHtcbiAgICAgICAgLy8gVGhlIHJlcG8gbWF5IGJlIGNsb3NlZCBpZiBwcmV2aW91c2x5IHN0b3BwZWRcbiAgICAgICAgc2VsZi5fcmVwby5jbG9zZWRcbiAgICAgICAgICA/IHNlbGYuX3JlcG8ub3BlbihjYilcbiAgICAgICAgICA6IGNiKClcbiAgICAgIH0sXG4gICAgICAoY2IpID0+IHtcbiAgICAgICAgc2VsZi5fcmVwby5jb25maWcuZ2V0KChlcnIsIGNvbmZpZykgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICAgICAgICBjb25zdCBsaWJwMnAgPSBjcmVhdGVMaWJwMnBCdW5kbGUoc2VsZiwgY29uZmlnKVxuXG4gICAgICAgICAgbGlicDJwLnN0YXJ0KGVyciA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgICAgICAgc2VsZi5saWJwMnAgPSBsaWJwMnBcbiAgICAgICAgICAgIGNiKClcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIChjYikgPT4ge1xuICAgICAgICBjb25zdCBpcG5zUm91dGluZyA9IHJvdXRpbmdDb25maWcoc2VsZilcbiAgICAgICAgc2VsZi5faXBucyA9IG5ldyBJUE5TKGlwbnNSb3V0aW5nLCBzZWxmLl9yZXBvLmRhdGFzdG9yZSwgc2VsZi5fcGVlckluZm8sIHNlbGYuX2tleWNoYWluLCBzZWxmLl9vcHRpb25zKVxuXG4gICAgICAgIHNlbGYuX2JpdHN3YXAgPSBuZXcgQml0c3dhcChcbiAgICAgICAgICBzZWxmLmxpYnAycCxcbiAgICAgICAgICBzZWxmLl9yZXBvLmJsb2NrcyxcbiAgICAgICAgICB7IHN0YXRzRW5hYmxlZDogdHJ1ZSB9XG4gICAgICAgIClcblxuICAgICAgICBzZWxmLl9iaXRzd2FwLnN0YXJ0KClcbiAgICAgICAgc2VsZi5fYmxvY2tTZXJ2aWNlLnNldEV4Y2hhbmdlKHNlbGYuX2JpdHN3YXApXG5cbiAgICAgICAgc2VsZi5fcHJlbG9hZC5zdGFydCgpXG4gICAgICAgIHNlbGYuX2lwbnMucmVwdWJsaXNoZXIuc3RhcnQoKVxuICAgICAgICBzZWxmLl9tZnNQcmVsb2FkLnN0YXJ0KGNiKVxuICAgICAgfVxuICAgIF0sIGRvbmUpXG4gIH0pXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcGVlcklkID0gcmVxdWlyZSgncGVlci1pZCcpXG5jb25zdCBtZXJnZU9wdGlvbnMgPSByZXF1aXJlKCdtZXJnZS1vcHRpb25zJylcbmNvbnN0IHdhdGVyZmFsbCA9IHJlcXVpcmUoJ2FzeW5jL3dhdGVyZmFsbCcpXG5jb25zdCBwYXJhbGxlbCA9IHJlcXVpcmUoJ2FzeW5jL3BhcmFsbGVsJylcbmNvbnN0IHByb21pc2lmeSA9IHJlcXVpcmUoJ3Byb21pc2lmeS1lczYnKVxuY29uc3QgZGVmYXVsdENvbmZpZyA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvY29uZmlnLW5vZGVqcy5qcycpXG5jb25zdCBLZXljaGFpbiA9IHJlcXVpcmUoJ2xpYnAycC1rZXljaGFpbicpXG5jb25zdCB7XG4gIERBR05vZGVcbn0gPSByZXF1aXJlKCdpcGxkLWRhZy1wYicpXG5jb25zdCBVbml4RnMgPSByZXF1aXJlKCdpcGZzLXVuaXhmcycpXG5jb25zdCBtdWx0aWNvZGVjID0gcmVxdWlyZSgnbXVsdGljb2RlYycpXG5cbmNvbnN0IElQTlMgPSByZXF1aXJlKCcuLi9pcG5zJylcbmNvbnN0IE9mZmxpbmVEYXRhc3RvcmUgPSByZXF1aXJlKCcuLi9pcG5zL3JvdXRpbmcvb2ZmbGluZS1kYXRhc3RvcmUnKVxuXG5jb25zdCBhZGREZWZhdWx0QXNzZXRzID0gcmVxdWlyZSgnLi9pbml0LWFzc2V0cycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5pdCAoc2VsZikge1xuICByZXR1cm4gcHJvbWlzaWZ5KChvcHRzLCBjYWxsYmFjaykgPT4ge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRzXG4gICAgICBvcHRzID0ge31cbiAgICB9XG5cbiAgICBjb25zdCBkb25lID0gKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIHNlbGYucHJlU3RhcnQoKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zdGF0ZS5pbml0aWFsaXplZCgpXG4gICAgICAgIHNlbGYuZW1pdCgnaW5pdCcpXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHNlbGYuc3RhdGUuc3RhdGUoKSAhPT0gJ3VuaW5pdGlhbGl6ZWQnKSB7XG4gICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ05vdCBhYmxlIHRvIGluaXQgZnJvbSBzdGF0ZTogJyArIHNlbGYuc3RhdGUuc3RhdGUoKSkpXG4gICAgfVxuXG4gICAgc2VsZi5zdGF0ZS5pbml0KClcbiAgICBzZWxmLmxvZygnaW5pdCcpXG5cbiAgICAvLyBBbiBpbml0aWFsaXplZCwgb3BlbiByZXBvIHdhcyBwYXNzZWQsIHVzZSB0aGlzIG9uZSFcbiAgICBpZiAob3B0cy5yZXBvKSB7XG4gICAgICBzZWxmLl9yZXBvID0gb3B0cy5yZXBvXG4gICAgICByZXR1cm4gZG9uZShudWxsLCB0cnVlKVxuICAgIH1cblxuICAgIG9wdHMuZW1wdHlSZXBvID0gb3B0cy5lbXB0eVJlcG8gfHwgZmFsc2VcbiAgICBvcHRzLmJpdHMgPSBOdW1iZXIob3B0cy5iaXRzKSB8fCAyMDQ4XG4gICAgb3B0cy5sb2cgPSBvcHRzLmxvZyB8fCBmdW5jdGlvbiAoKSB7fVxuXG4gICAgY29uc3QgY29uZmlnID0gbWVyZ2VPcHRpb25zKGRlZmF1bHRDb25maWcoKSwgc2VsZi5fb3B0aW9ucy5jb25maWcpXG4gICAgbGV0IHByaXZhdGVLZXlcblxuICAgIHdhdGVyZmFsbChbXG4gICAgICAvLyBWZXJpZnkgcmVwbyBkb2VzIG5vdCB5ZXQgZXhpc3QuXG4gICAgICAoY2IpID0+IHNlbGYuX3JlcG8uZXhpc3RzKGNiKSxcbiAgICAgIChleGlzdHMsIGNiKSA9PiB7XG4gICAgICAgIHNlbGYubG9nKCdyZXBvIGV4aXN0cz8nLCBleGlzdHMpXG4gICAgICAgIGlmIChleGlzdHMgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdyZXBvIGFscmVhZHkgZXhpc3RzJykpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5wcml2YXRlS2V5KSB7XG4gICAgICAgICAgc2VsZi5sb2coJ3VzaW5nIHVzZXItc3VwcGxpZWQgcHJpdmF0ZS1rZXknKVxuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cy5wcml2YXRlS2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY2IobnVsbCwgb3B0cy5wcml2YXRlS2V5KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWVySWQuY3JlYXRlRnJvbVByaXZLZXkoQnVmZmVyLmZyb20ob3B0cy5wcml2YXRlS2V5LCAnYmFzZTY0JyksIGNiKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBHZW5lcmF0ZSBwZWVyIGlkZW50aXR5IGtleXBhaXIgKyB0cmFuc2Zvcm0gdG8gZGVzaXJlZCBmb3JtYXQgKyBhZGQgdG8gY29uZmlnLlxuICAgICAgICAgIG9wdHMubG9nKGBnZW5lcmF0aW5nICR7b3B0cy5iaXRzfS1iaXQgUlNBIGtleXBhaXIuLi5gLCBmYWxzZSlcbiAgICAgICAgICBzZWxmLmxvZygnZ2VuZXJhdGluZyBwZWVyIGlkOiAlcyBiaXRzJywgb3B0cy5iaXRzKVxuICAgICAgICAgIHBlZXJJZC5jcmVhdGUoeyBiaXRzOiBvcHRzLmJpdHMgfSwgY2IpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAocGVlcklkLCBjYikgPT4ge1xuICAgICAgICBzZWxmLmxvZygnaWRlbnRpdHkgZ2VuZXJhdGVkJylcbiAgICAgICAgY29uZmlnLklkZW50aXR5ID0ge1xuICAgICAgICAgIFBlZXJJRDogcGVlcklkLnRvQjU4U3RyaW5nKCksXG4gICAgICAgICAgUHJpdktleTogcGVlcklkLnByaXZLZXkuYnl0ZXMudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICAgIH1cbiAgICAgICAgcHJpdmF0ZUtleSA9IHBlZXJJZC5wcml2S2V5XG4gICAgICAgIGlmIChvcHRzLnBhc3MpIHtcbiAgICAgICAgICBjb25maWcuS2V5Y2hhaW4gPSBLZXljaGFpbi5nZW5lcmF0ZU9wdGlvbnMoKVxuICAgICAgICB9XG4gICAgICAgIG9wdHMubG9nKCdkb25lJylcbiAgICAgICAgb3B0cy5sb2coJ3BlZXIgaWRlbnRpdHk6ICcgKyBjb25maWcuSWRlbnRpdHkuUGVlcklEKVxuXG4gICAgICAgIHNlbGYuX3JlcG8uaW5pdChjb25maWcsIGNiKVxuICAgICAgfSxcbiAgICAgIChfLCBjYikgPT4gc2VsZi5fcmVwby5vcGVuKGNiKSxcbiAgICAgIChjYikgPT4ge1xuICAgICAgICBzZWxmLmxvZygncmVwbyBvcGVuZWQnKVxuICAgICAgICBpZiAob3B0cy5wYXNzKSB7XG4gICAgICAgICAgc2VsZi5sb2coJ2NyZWF0aW5nIGtleWNoYWluJylcbiAgICAgICAgICBjb25zdCBrZXljaGFpbk9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgcGFzc1BocmFzZTogb3B0cy5wYXNzIH0sIGNvbmZpZy5LZXljaGFpbilcbiAgICAgICAgICBzZWxmLl9rZXljaGFpbiA9IG5ldyBLZXljaGFpbihzZWxmLl9yZXBvLmtleXMsIGtleWNoYWluT3B0aW9ucylcbiAgICAgICAgICBzZWxmLl9rZXljaGFpbi5pbXBvcnRQZWVyKCdzZWxmJywgeyBwcml2S2V5OiBwcml2YXRlS2V5IH0sIGNiKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKG51bGwsIHRydWUpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBTZXR1cCB0aGUgb2ZmbGluZSByb3V0aW5nIGZvciBJUE5TLlxuICAgICAgLy8gVGhpcyBpcyBwcmltYXJpbHkgdXNlZCBmb3Igb2ZmbGluZSBpcG5zIG1vZGlmaWNhdGlvbnMsIHN1Y2ggYXMgdGhlIGluaXRpYWxpemVLZXlzcGFjZSBmZWF0dXJlLlxuICAgICAgKF8sIGNiKSA9PiB7XG4gICAgICAgIGNvbnN0IG9mZmxpbmVEYXRhc3RvcmUgPSBuZXcgT2ZmbGluZURhdGFzdG9yZShzZWxmLl9yZXBvKVxuXG4gICAgICAgIHNlbGYuX2lwbnMgPSBuZXcgSVBOUyhvZmZsaW5lRGF0YXN0b3JlLCBzZWxmLl9yZXBvLmRhdGFzdG9yZSwgc2VsZi5fcGVlckluZm8sIHNlbGYuX2tleWNoYWluLCBzZWxmLl9vcHRpb25zKVxuICAgICAgICBjYihudWxsLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIC8vIGFkZCBlbXB0eSB1bml4ZnMgZGlyIG9iamVjdCAoZ28taXBmcyBhc3N1bWVzIHRoaXMgZXhpc3RzKVxuICAgICAgKF8sIGNiKSA9PiB7XG4gICAgICAgIGlmIChvcHRzLmVtcHR5UmVwbykge1xuICAgICAgICAgIHJldHVybiBjYihudWxsLCB0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGFza3MgPSBbXG4gICAgICAgICAgKGNiKSA9PiB7XG4gICAgICAgICAgICB3YXRlcmZhbGwoW1xuICAgICAgICAgICAgICAoY2IpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY2IobnVsbCwgREFHTm9kZS5jcmVhdGUobmV3IFVuaXhGcygnZGlyZWN0b3J5JykubWFyc2hhbCgpKSlcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgIGNiKGVycilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIChub2RlLCBjYikgPT4gc2VsZi5kYWcucHV0KG5vZGUsIHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAwLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogbXVsdGljb2RlYy5EQUdfUEIsXG4gICAgICAgICAgICAgICAgaGFzaEFsZzogbXVsdGljb2RlYy5TSEEyXzI1NlxuICAgICAgICAgICAgICB9KS50aGVuKFxuICAgICAgICAgICAgICAgIChjaWQpID0+IGNiKG51bGwsIGNpZCksXG4gICAgICAgICAgICAgICAgKGVycm9yKSA9PiBjYihlcnJvcilcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGNpZCwgY2IpID0+IHNlbGYuX2lwbnMuaW5pdGlhbGl6ZUtleXNwYWNlKHByaXZhdGVLZXksIGNpZC50b0Jhc2VFbmNvZGVkU3RyaW5nKCksIGNiKVxuICAgICAgICAgICAgXSwgY2IpXG4gICAgICAgICAgfVxuICAgICAgICBdXG5cbiAgICAgICAgaWYgKHR5cGVvZiBhZGREZWZhdWx0QXNzZXRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gYWRkRGVmYXVsdEFzc2V0cyBpcyB1bmRlZmluZWQgb24gYnJvd3NlcnMuXG4gICAgICAgICAgLy8gU2VlIHBhY2thZ2UuanNvbiBicm93c2VyIGNvbmZpZ1xuICAgICAgICAgIHRhc2tzLnB1c2goKGNiKSA9PiBhZGREZWZhdWx0QXNzZXRzKHNlbGYsIG9wdHMubG9nLCBjYikpXG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmxvZygnYWRkaW5nIGFzc2V0cycpXG4gICAgICAgIHBhcmFsbGVsKHRhc2tzLCAoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY2IoZXJyKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYihudWxsLCB0cnVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICBdLCBkb25lKVxuICB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGdldCA9IHJlcXVpcmUoJ2RsdicpXG5jb25zdCBtZXJnZU9wdGlvbnMgPSByZXF1aXJlKCdtZXJnZS1vcHRpb25zJylcbmNvbnN0IGlwbnNVdGlscyA9IHJlcXVpcmUoJy4uL2lwbnMvcm91dGluZy91dGlscycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlicDJwIChzZWxmLCBjb25maWcpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHNlbGYuX29wdGlvbnMgfHwge31cbiAgY29uZmlnID0gY29uZmlnIHx8IHt9XG5cbiAgLy8gQWx3YXlzIGNyZWF0ZSBsaWJwMnAgdmlhIGEgYnVuZGxlIGZ1bmN0aW9uXG4gIGNvbnN0IGNyZWF0ZUJ1bmRsZSA9IHR5cGVvZiBvcHRpb25zLmxpYnAycCA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gb3B0aW9ucy5saWJwMnBcbiAgICA6IGRlZmF1bHRCdW5kbGVcblxuICBjb25zdCB7IGRhdGFzdG9yZSB9ID0gc2VsZi5fcmVwb1xuICBjb25zdCBwZWVySW5mbyA9IHNlbGYuX3BlZXJJbmZvXG4gIGNvbnN0IHBlZXJCb29rID0gc2VsZi5fcGVlckluZm9Cb29rXG4gIGNvbnN0IGxpYnAycCA9IGNyZWF0ZUJ1bmRsZSh7IG9wdGlvbnMsIGNvbmZpZywgZGF0YXN0b3JlLCBwZWVySW5mbywgcGVlckJvb2sgfSlcblxuICBsaWJwMnAub24oJ3N0b3AnLCAoKSA9PiB7XG4gICAgLy8gQ2xlYXIgb3VyIGFkZHJlc3NlcyBzbyB3ZSBjYW4gc3RhcnQgY2xlYW5cbiAgICBwZWVySW5mby5tdWx0aWFkZHJzLmNsZWFyKClcbiAgfSlcblxuICBsaWJwMnAub24oJ3N0YXJ0JywgKCkgPT4ge1xuICAgIHBlZXJJbmZvLm11bHRpYWRkcnMuZm9yRWFjaCgobWEpID0+IHtcbiAgICAgIHNlbGYuX3ByaW50KCdTd2FybSBsaXN0ZW5pbmcgb24nLCBtYS50b1N0cmluZygpKVxuICAgIH0pXG4gIH0pXG5cbiAgbGlicDJwLm9uKCdwZWVyOmNvbm5lY3QnLCBwZWVySW5mbyA9PiBwZWVyQm9vay5wdXQocGVlckluZm8pKVxuXG4gIHJldHVybiBsaWJwMnBcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEJ1bmRsZSAoeyBkYXRhc3RvcmUsIHBlZXJJbmZvLCBwZWVyQm9vaywgb3B0aW9ucywgY29uZmlnIH0pIHtcbiAgY29uc3QgbGlicDJwRGVmYXVsdHMgPSB7XG4gICAgZGF0YXN0b3JlLFxuICAgIHBlZXJJbmZvLFxuICAgIHBlZXJCb29rLFxuICAgIGNvbmZpZzoge1xuICAgICAgcGVlckRpc2NvdmVyeToge1xuICAgICAgICBtZG5zOiB7XG4gICAgICAgICAgZW5hYmxlZDogZ2V0KG9wdGlvbnMsICdjb25maWcuRGlzY292ZXJ5Lk1ETlMuRW5hYmxlZCcsXG4gICAgICAgICAgICBnZXQoY29uZmlnLCAnRGlzY292ZXJ5Lk1ETlMuRW5hYmxlZCcsIHRydWUpKVxuICAgICAgICB9LFxuICAgICAgICB3ZWJSVENTdGFyOiB7XG4gICAgICAgICAgZW5hYmxlZDogZ2V0KG9wdGlvbnMsICdjb25maWcuRGlzY292ZXJ5LndlYlJUQ1N0YXIuRW5hYmxlZCcsXG4gICAgICAgICAgICBnZXQoY29uZmlnLCAnRGlzY292ZXJ5LndlYlJUQ1N0YXIuRW5hYmxlZCcsIHRydWUpKVxuICAgICAgICB9LFxuICAgICAgICBib290c3RyYXA6IHtcbiAgICAgICAgICBsaXN0OiBnZXQob3B0aW9ucywgJ2NvbmZpZy5Cb290c3RyYXAnLFxuICAgICAgICAgICAgZ2V0KGNvbmZpZywgJ0Jvb3RzdHJhcCcsIFtdKSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlbGF5OiB7XG4gICAgICAgIGVuYWJsZWQ6IGdldChvcHRpb25zLCAncmVsYXkuZW5hYmxlZCcsXG4gICAgICAgICAgZ2V0KGNvbmZpZywgJ3JlbGF5LmVuYWJsZWQnLCB0cnVlKSksXG4gICAgICAgIGhvcDoge1xuICAgICAgICAgIGVuYWJsZWQ6IGdldChvcHRpb25zLCAncmVsYXkuaG9wLmVuYWJsZWQnLFxuICAgICAgICAgICAgZ2V0KGNvbmZpZywgJ3JlbGF5LmhvcC5lbmFibGVkJywgZmFsc2UpKSxcbiAgICAgICAgICBhY3RpdmU6IGdldChvcHRpb25zLCAncmVsYXkuaG9wLmFjdGl2ZScsXG4gICAgICAgICAgICBnZXQoY29uZmlnLCAncmVsYXkuaG9wLmFjdGl2ZScsIGZhbHNlKSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRodDoge1xuICAgICAgICBrQnVja2V0U2l6ZTogZ2V0KG9wdGlvbnMsICdkaHQua0J1Y2tldFNpemUnLCAyMCksXG4gICAgICAgIC8vIGVuYWJsZWQ6ICFnZXQob3B0aW9ucywgJ29mZmxpbmUnLCBmYWxzZSksIC8vIGRpc2FibGUgaWYgb2ZmbGluZSwgb24gYnkgZGVmYXVsdFxuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgcmFuZG9tV2Fsazoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlIC8vIGRpc2FibGVkIHdhaXRpbmcgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9saWJwMnAvanMtbGlicDJwLWthZC1kaHQvaXNzdWVzLzg2XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRvcnM6IHtcbiAgICAgICAgICBpcG5zOiBpcG5zVXRpbHMudmFsaWRhdG9yXG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdG9yczoge1xuICAgICAgICAgIGlwbnM6IGlwbnNVdGlscy5zZWxlY3RvclxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgRVhQRVJJTUVOVEFMOiB7XG4gICAgICAgIHB1YnN1YjogZ2V0KG9wdGlvbnMsICdFWFBFUklNRU5UQUwucHVic3ViJywgZmFsc2UpXG4gICAgICB9XG4gICAgfSxcbiAgICBjb25uZWN0aW9uTWFuYWdlcjogZ2V0KG9wdGlvbnMsICdjb25uZWN0aW9uTWFuYWdlcicsXG4gICAgICB7XG4gICAgICAgIG1heFBlZXJzOiBnZXQoY29uZmlnLCAnU3dhcm0uQ29ubk1nci5IaWdoV2F0ZXInKSxcbiAgICAgICAgbWluUGVlcnM6IGdldChjb25maWcsICdTd2FybS5Db25uTWdyLkxvd1dhdGVyJylcbiAgICAgIH0pXG4gIH1cblxuICBjb25zdCBsaWJwMnBPcHRpb25zID0gbWVyZ2VPcHRpb25zKGxpYnAycERlZmF1bHRzLCBnZXQob3B0aW9ucywgJ2xpYnAycCcsIHt9KSlcbiAgLy8gUmVxdWlyZWQgaW5saW5lIHRvIHJlZHVjZSBzdGFydHVwIHRpbWVcbiAgLy8gTm90ZTogbGlicDJwLW5vZGVqcyBnZXRzIHJlcGxhY2VkIGJ5IGxpYnAycC1icm93c2VyIHdoZW4gd2VicGFja2VkL2Jyb3dzZXJpZmllZFxuICBjb25zdCBOb2RlID0gcmVxdWlyZSgnLi4vcnVudGltZS9saWJwMnAtbm9kZWpzJylcbiAgcmV0dXJuIG5ldyBOb2RlKGxpYnAycE9wdGlvbnMpXG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSAoc2VsZikgPT4ge1xuICBjb25zdCBmaWxlc1JlZ3VsYXIgPSB7XG4gICAgYWRkOiByZXF1aXJlKCcuL2FkZCcpKHNlbGYpLFxuICAgIGFkZEZyb21GczogcmVxdWlyZSgnLi9hZGQtZnJvbS1mcycpKHNlbGYpLFxuICAgIGFkZEZyb21TdHJlYW06IHJlcXVpcmUoJy4vYWRkLWZyb20tc3RyZWFtJykoc2VsZiksXG4gICAgYWRkRnJvbVVSTDogcmVxdWlyZSgnLi9hZGQtZnJvbS11cmwnKShzZWxmKSxcbiAgICBhZGRQdWxsU3RyZWFtOiByZXF1aXJlKCcuL2FkZC1wdWxsLXN0cmVhbScpKHNlbGYpLFxuICAgIGFkZFJlYWRhYmxlU3RyZWFtOiByZXF1aXJlKCcuL2FkZC1yZWFkYWJsZS1zdHJlYW0nKShzZWxmKSxcbiAgICBjYXQ6IHJlcXVpcmUoJy4vY2F0Jykoc2VsZiksXG4gICAgY2F0UHVsbFN0cmVhbTogcmVxdWlyZSgnLi9jYXQtcHVsbC1zdHJlYW0nKShzZWxmKSxcbiAgICBjYXRSZWFkYWJsZVN0cmVhbTogcmVxdWlyZSgnLi9jYXQtcmVhZGFibGUtc3RyZWFtJykoc2VsZiksXG4gICAgZ2V0OiByZXF1aXJlKCcuL2dldCcpKHNlbGYpLFxuICAgIGdldFB1bGxTdHJlYW06IHJlcXVpcmUoJy4vZ2V0LXB1bGwtc3RyZWFtJykoc2VsZiksXG4gICAgZ2V0UmVhZGFibGVTdHJlYW06IHJlcXVpcmUoJy4vZ2V0LXJlYWRhYmxlLXN0cmVhbScpKHNlbGYpLFxuICAgIGxzOiByZXF1aXJlKCcuL2xzJykoc2VsZiksXG4gICAgbHNQdWxsU3RyZWFtOiByZXF1aXJlKCcuL2xzLXB1bGwtc3RyZWFtJykoc2VsZiksXG4gICAgbHNSZWFkYWJsZVN0cmVhbTogcmVxdWlyZSgnLi9scy1yZWFkYWJsZS1zdHJlYW0nKShzZWxmKSxcbiAgICByZWZzOiByZXF1aXJlKCcuL3JlZnMnKShzZWxmKSxcbiAgICByZWZzUmVhZGFibGVTdHJlYW06IHJlcXVpcmUoJy4vcmVmcy1yZWFkYWJsZS1zdHJlYW0nKShzZWxmKSxcbiAgICByZWZzUHVsbFN0cmVhbTogcmVxdWlyZSgnLi9yZWZzLXB1bGwtc3RyZWFtJykoc2VsZilcbiAgfVxuICBmaWxlc1JlZ3VsYXIucmVmcy5sb2NhbCA9IHJlcXVpcmUoJy4vcmVmcy1sb2NhbCcpKHNlbGYpXG4gIGZpbGVzUmVndWxhci5yZWZzLmxvY2FsUmVhZGFibGVTdHJlYW0gPSByZXF1aXJlKCcuL3JlZnMtbG9jYWwtcmVhZGFibGUtc3RyZWFtJykoc2VsZilcbiAgZmlsZXNSZWd1bGFyLnJlZnMubG9jYWxQdWxsU3RyZWFtID0gcmVxdWlyZSgnLi9yZWZzLWxvY2FsLXB1bGwtc3RyZWFtJykoc2VsZilcbiAgcmV0dXJuIGZpbGVzUmVndWxhclxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG1mcyA9IHJlcXVpcmUoJ2lwZnMtbWZzL2NvcmUnKVxuY29uc3QgaXNQdWxsU3RyZWFtID0gcmVxdWlyZSgnaXMtcHVsbC1zdHJlYW0nKVxuY29uc3QgdG9QdWxsU3RyZWFtID0gcmVxdWlyZSgnYXN5bmMtaXRlcmF0b3ItdG8tcHVsbC1zdHJlYW0nKVxuY29uc3QgdG9SZWFkYWJsZVN0cmVhbSA9IHJlcXVpcmUoJ2FzeW5jLWl0ZXJhdG9yLXRvLXN0cmVhbScpXG5jb25zdCBwdWxsU3RyZWFtVG9Bc3luY0l0ZXJhdG9yID0gcmVxdWlyZSgncHVsbC1zdHJlYW0tdG8tYXN5bmMtaXRlcmF0b3InKVxuY29uc3QgYWxsID0gcmVxdWlyZSgnYXN5bmMtaXRlcmF0b3ItYWxsJylcbmNvbnN0IGNhbGxiYWNraWZ5ID0gcmVxdWlyZSgnY2FsbGJhY2tpZnknKVxuY29uc3QgUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdzdHJlYW0nKS5QYXNzVGhyb3VnaFxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3B1bGwnKVxuY29uc3QgbWFwID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vdGhyb3VnaHMvbWFwJylcblxuY29uc3QgbWFwTHNGaWxlID0gKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBsb25nID0gb3B0aW9ucy5sb25nIHx8IG9wdGlvbnMubFxuXG4gIHJldHVybiAoZmlsZSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBoYXNoOiBsb25nID8gZmlsZS5jaWQudG9CYXNlRW5jb2RlZFN0cmluZyhvcHRpb25zLmNpZEJhc2UpIDogJycsXG4gICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICB0eXBlOiBsb25nID8gZmlsZS50eXBlIDogMCxcbiAgICAgIHNpemU6IGxvbmcgPyBmaWxlLnNpemUgfHwgMCA6IDBcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZWxmID0+IHtcbiAgY29uc3QgbWV0aG9kcyA9IG1mcyh7XG4gICAgaXBsZDogc2VsZi5faXBsZCxcbiAgICBibG9ja3M6IHNlbGYuX2Jsb2NrU2VydmljZSxcbiAgICBkYXRhc3RvcmU6IHNlbGYuX3JlcG8ucm9vdCxcbiAgICByZXBvT3duZXI6IHNlbGYuX29wdGlvbnMucmVwb093bmVyXG4gIH0pXG5cbiAgcmV0dXJuIHtcbiAgICBjcDogY2FsbGJhY2tpZnkudmFyaWFkaWMobWV0aG9kcy5jcCksXG4gICAgZmx1c2g6IGNhbGxiYWNraWZ5LnZhcmlhZGljKG1ldGhvZHMuZmx1c2gpLFxuICAgIGxzOiBjYWxsYmFja2lmeS52YXJpYWRpYyhhc3luYyAocGF0aCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBmaWxlcyA9IGF3YWl0IGFsbChtZXRob2RzLmxzKHBhdGgsIG9wdGlvbnMpKVxuXG4gICAgICByZXR1cm4gZmlsZXMubWFwKG1hcExzRmlsZShvcHRpb25zKSlcbiAgICB9KSxcbiAgICBsc1JlYWRhYmxlU3RyZWFtOiAocGF0aCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBzdHJlYW0gPSB0b1JlYWRhYmxlU3RyZWFtLm9iaihtZXRob2RzLmxzKHBhdGgsIG9wdGlvbnMpKVxuICAgICAgY29uc3QgdGhyb3VnaCA9IG5ldyBQYXNzVGhyb3VnaCh7XG4gICAgICAgIG9iamVjdE1vZGU6IHRydWVcbiAgICAgIH0pXG4gICAgICBzdHJlYW0ub24oJ2RhdGEnLCAoZmlsZSkgPT4ge1xuICAgICAgICB0aHJvdWdoLndyaXRlKG1hcExzRmlsZShvcHRpb25zKShmaWxlKSlcbiAgICAgIH0pXG4gICAgICBzdHJlYW0ub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICB0aHJvdWdoLmRlc3Ryb3koZXJyKVxuICAgICAgfSlcbiAgICAgIHN0cmVhbS5vbignZW5kJywgKGZpbGUsIGVuYywgY2IpID0+IHtcbiAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICBmaWxlID0gbWFwTHNGaWxlKG9wdGlvbnMpKGZpbGUpXG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdWdoLmVuZChmaWxlLCBlbmMsIGNiKVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHRocm91Z2hcbiAgICB9LFxuICAgIGxzUHVsbFN0cmVhbTogKHBhdGgsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgcmV0dXJuIHB1bGwoXG4gICAgICAgIHRvUHVsbFN0cmVhbS5zb3VyY2UobWV0aG9kcy5scyhwYXRoLCBvcHRpb25zKSksXG4gICAgICAgIG1hcChtYXBMc0ZpbGUob3B0aW9ucykpXG4gICAgICApXG4gICAgfSxcbiAgICBta2RpcjogY2FsbGJhY2tpZnkudmFyaWFkaWMobWV0aG9kcy5ta2RpciksXG4gICAgbXY6IGNhbGxiYWNraWZ5LnZhcmlhZGljKG1ldGhvZHMubXYpLFxuICAgIHJlYWQ6IGNhbGxiYWNraWZ5KGFzeW5jIChwYXRoLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGF3YWl0IGFsbChtZXRob2RzLnJlYWQocGF0aCwgb3B0aW9ucykpKVxuICAgIH0pLFxuICAgIHJlYWRQdWxsU3RyZWFtOiAocGF0aCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICByZXR1cm4gdG9QdWxsU3RyZWFtLnNvdXJjZShtZXRob2RzLnJlYWQocGF0aCwgb3B0aW9ucykpXG4gICAgfSxcbiAgICByZWFkUmVhZGFibGVTdHJlYW06IChwYXRoLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIHJldHVybiB0b1JlYWRhYmxlU3RyZWFtKG1ldGhvZHMucmVhZChwYXRoLCBvcHRpb25zKSlcbiAgICB9LFxuICAgIHJtOiBjYWxsYmFja2lmeS52YXJpYWRpYyhtZXRob2RzLnJtKSxcbiAgICBzdGF0OiBjYWxsYmFja2lmeShhc3luYyAocGF0aCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IG1ldGhvZHMuc3RhdChwYXRoLCBvcHRpb25zKVxuXG4gICAgICBzdGF0cy5oYXNoID0gc3RhdHMuY2lkLnRvQmFzZUVuY29kZWRTdHJpbmcob3B0aW9ucyAmJiBvcHRpb25zLmNpZEJhc2UpXG4gICAgICBkZWxldGUgc3RhdHMuY2lkXG5cbiAgICAgIHJldHVybiBzdGF0c1xuICAgIH0pLFxuICAgIHdyaXRlOiBjYWxsYmFja2lmeS52YXJpYWRpYyhhc3luYyAocGF0aCwgY29udGVudCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBpZiAoaXNQdWxsU3RyZWFtLmlzU291cmNlKGNvbnRlbnQpKSB7XG4gICAgICAgIGNvbnRlbnQgPSBwdWxsU3RyZWFtVG9Bc3luY0l0ZXJhdG9yKGNvbnRlbnQpXG4gICAgICB9XG5cbiAgICAgIGF3YWl0IG1ldGhvZHMud3JpdGUocGF0aCwgY29udGVudCwgb3B0aW9ucylcbiAgICB9KVxuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29uZmlybUJ1aWxkZXIgPSB2b2lkIDA7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuY29uc3QgbWV0aG9kTmFtZSA9ICdzbmFwX2NvbmZpcm0nO1xuLyoqXG4gKiBgc25hcF9jb25maXJtYCBsZXRzIHRoZSBTbmFwIGRpc3BsYXkgYSBjb25maXJtYXRpb24gZGlhbG9nIHRvIHRoZSB1c2VyLlxuICovXG5jb25zdCBzcGVjaWZpY2F0aW9uQnVpbGRlciA9ICh7IGFsbG93ZWRDYXZlYXRzID0gbnVsbCwgbWV0aG9kSG9va3MsIH0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXRLZXk6IG1ldGhvZE5hbWUsXG4gICAgICAgIGFsbG93ZWRDYXZlYXRzLFxuICAgICAgICBtZXRob2RJbXBsZW1lbnRhdGlvbjogZ2V0Q29uZmlybUltcGxlbWVudGF0aW9uKG1ldGhvZEhvb2tzKSxcbiAgICB9O1xufTtcbmV4cG9ydHMuY29uZmlybUJ1aWxkZXIgPSBPYmplY3QuZnJlZXplKHtcbiAgICB0YXJnZXRLZXk6IG1ldGhvZE5hbWUsXG4gICAgc3BlY2lmaWNhdGlvbkJ1aWxkZXIsXG4gICAgbWV0aG9kSG9va3M6IHtcbiAgICAgICAgc2hvd0NvbmZpcm1hdGlvbjogdHJ1ZSxcbiAgICB9LFxufSk7XG5mdW5jdGlvbiBnZXRDb25maXJtSW1wbGVtZW50YXRpb24oeyBzaG93Q29uZmlybWF0aW9uIH0pIHtcbiAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gY29uZmlybUltcGxlbWVudGF0aW9uKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgeyBwYXJhbXMgPSBbXSB9ID0gYXJncztcbiAgICAgICAgY29uc3QgW3Byb21wdCwgdGl0bGUsIHN1YnRpdGxlXSA9IHBhcmFtcztcbiAgICAgICAgaWYgKCFwcm9tcHQgfHwgdHlwZW9mIHByb21wdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnTXVzdCBzcGVjaWZ5IGEgbm9uLWVtcHR5IHN0cmluZyBwcm9tcHQuJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgc2hvd0NvbmZpcm1hdGlvbihwcm9tcHQsIHRpdGxlIHx8ICcnLCBzdWJ0aXRsZSB8fCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25maXJtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbnZva2VTbmFwQnVpbGRlciA9IHZvaWQgMDtcbmNvbnN0IHNuYXBfY29udHJvbGxlcnNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc25hcC1jb250cm9sbGVyc1wiKTtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgbWV0aG9kUHJlZml4ID0gc25hcF9jb250cm9sbGVyc18xLlNOQVBfUFJFRklYO1xuY29uc3QgdGFyZ2V0S2V5ID0gYCR7bWV0aG9kUHJlZml4fSpgO1xuLyoqXG4gKiBgd2FsbGV0X3NuYXBfKmAgYXR0ZW1wdHMgdG8gaW52b2tlIGFuIFJQQyBtZXRob2Qgb2YgdGhlIHNwZWNpZmllZCBTbmFwLlxuICogUmVxdWVzdGluZyBpdHMgY29ycmVzcG9uZGluZyBwZXJtaXNzaW9uIHdpbGwgYXR0ZW1wdCB0byBjb25uZWN0IHRvIHRoZSBTbmFwLFxuICogYW5kIGluc3RhbGwgaXQgaWYgaXQncyBub3QgYXZhaWFsYmxlIHlldC5cbiAqL1xuY29uc3Qgc3BlY2lmaWNhdGlvbkJ1aWxkZXIgPSAoeyBhbGxvd2VkQ2F2ZWF0cyA9IG51bGwsIG1ldGhvZEhvb2tzLCB9KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0S2V5LFxuICAgICAgICBhbGxvd2VkQ2F2ZWF0cyxcbiAgICAgICAgbWV0aG9kSW1wbGVtZW50YXRpb246IGdldEludm9rZVNuYXBJbXBsZW1lbnRhdGlvbihtZXRob2RIb29rcyksXG4gICAgfTtcbn07XG5leHBvcnRzLmludm9rZVNuYXBCdWlsZGVyID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgdGFyZ2V0S2V5LFxuICAgIHNwZWNpZmljYXRpb25CdWlsZGVyLFxuICAgIG1ldGhvZEhvb2tzOiB7XG4gICAgICAgIGdldFNuYXA6IHRydWUsXG4gICAgICAgIGFkZFNuYXA6IHRydWUsXG4gICAgICAgIGdldFNuYXBScGNIYW5kbGVyOiB0cnVlLFxuICAgIH0sXG59KTtcbmZ1bmN0aW9uIGdldEludm9rZVNuYXBJbXBsZW1lbnRhdGlvbih7IGdldFNuYXAsIGFkZFNuYXAsIGdldFNuYXBScGNIYW5kbGVyLCB9KSB7XG4gICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIGludm9rZVNuYXAob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHBhcmFtcyA9IFtdLCBtZXRob2QsIGNvbnRleHQgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHNuYXBScGNSZXF1ZXN0ID0gcGFyYW1zWzBdO1xuICAgICAgICBpZiAoIXV0aWxzXzEuaXNQbGFpbk9iamVjdChzbmFwUnBjUmVxdWVzdCkpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnTXVzdCBzcGVjaWZ5IHNuYXAgUlBDIHJlcXVlc3Qgb2JqZWN0IGFzIHNpbmdsZSBwYXJhbWV0ZXIuJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNuYXBPcmlnaW5TdHJpbmcgPSBtZXRob2Quc3Vic3RyKHNuYXBfY29udHJvbGxlcnNfMS5TTkFQX1BSRUZJWC5sZW5ndGgpO1xuICAgICAgICBpZiAoIWdldFNuYXAoc25hcE9yaWdpblN0cmluZykpIHtcbiAgICAgICAgICAgIGF3YWl0IGFkZFNuYXAoe1xuICAgICAgICAgICAgICAgIG5hbWU6IHNuYXBPcmlnaW5TdHJpbmcsXG4gICAgICAgICAgICAgICAgbWFuaWZlc3RVcmw6IHNuYXBPcmlnaW5TdHJpbmcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYW5kbGVyID0gYXdhaXQgZ2V0U25hcFJwY0hhbmRsZXIoc25hcE9yaWdpblN0cmluZyk7XG4gICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdEZvdW5kKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgU25hcCBSUEMgbWVzc2FnZSBoYW5kbGVyIG5vdCBmb3VuZCBmb3Igc25hcCBcIiR7c25hcE9yaWdpblN0cmluZ31cIi5gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJvbVN1YmplY3QgPSBjb250ZXh0Lm9yaWdpbjtcbiAgICAgICAgLy8gSGFuZGxlciBpcyBhbiBhc3luYyBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHNuYXBPcmlnaW5TdHJpbmcgc3RyaW5nIGFuZCBhIHJlcXVlc3Qgb2JqZWN0LlxuICAgICAgICAvLyBJdCBzaG91bGQgcmV0dXJuIHRoZSByZXN1bHQgaXQgd291bGQgbGlrZSByZXR1cm5lZCB0byB0aGUgZnJvbURvbWFpbiBhcyBwYXJ0IG9mIHJlc3BvbnNlLnJlc3VsdFxuICAgICAgICByZXR1cm4gKGF3YWl0IGhhbmRsZXIoZnJvbVN1YmplY3QsIHNuYXBScGNSZXF1ZXN0KSk7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludm9rZVNuYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1hbmFnZVN0YXRlT3BlcmF0aW9uID0gZXhwb3J0cy5tYW5hZ2VTdGF0ZUJ1aWxkZXIgPSB2b2lkIDA7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IG1ldGhvZE5hbWUgPSAnc25hcF9tYW5hZ2VTdGF0ZSc7XG4vKipcbiAqIGBzbmFwX21hbmFnZVN0YXRlYCBsZXQncyB0aGUgU25hcCBzdG9yZSBhbmQgbWFuYWdlIHNvbWUgb2YgaXRzIHN0YXRlIG9uXG4gKiB5b3VyIGRldmljZS5cbiAqL1xuY29uc3Qgc3BlY2lmaWNhdGlvbkJ1aWxkZXIgPSAoeyBhbGxvd2VkQ2F2ZWF0cyA9IG51bGwsIG1ldGhvZEhvb2tzLCB9KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0S2V5OiBtZXRob2ROYW1lLFxuICAgICAgICBhbGxvd2VkQ2F2ZWF0cyxcbiAgICAgICAgbWV0aG9kSW1wbGVtZW50YXRpb246IGdldE1hbmFnZVN0YXRlSW1wbGVtZW50YXRpb24obWV0aG9kSG9va3MpLFxuICAgIH07XG59O1xuZXhwb3J0cy5tYW5hZ2VTdGF0ZUJ1aWxkZXIgPSBPYmplY3QuZnJlZXplKHtcbiAgICB0YXJnZXRLZXk6IG1ldGhvZE5hbWUsXG4gICAgc3BlY2lmaWNhdGlvbkJ1aWxkZXIsXG4gICAgbWV0aG9kSG9va3M6IHtcbiAgICAgICAgY2xlYXJTbmFwU3RhdGU6IHRydWUsXG4gICAgICAgIGdldFNuYXBTdGF0ZTogdHJ1ZSxcbiAgICAgICAgdXBkYXRlU25hcFN0YXRlOiB0cnVlLFxuICAgIH0sXG59KTtcbnZhciBNYW5hZ2VTdGF0ZU9wZXJhdGlvbjtcbihmdW5jdGlvbiAoTWFuYWdlU3RhdGVPcGVyYXRpb24pIHtcbiAgICBNYW5hZ2VTdGF0ZU9wZXJhdGlvbltcImNsZWFyU3RhdGVcIl0gPSBcImNsZWFyXCI7XG4gICAgTWFuYWdlU3RhdGVPcGVyYXRpb25bXCJnZXRTdGF0ZVwiXSA9IFwiZ2V0XCI7XG4gICAgTWFuYWdlU3RhdGVPcGVyYXRpb25bXCJ1cGRhdGVTdGF0ZVwiXSA9IFwidXBkYXRlXCI7XG59KShNYW5hZ2VTdGF0ZU9wZXJhdGlvbiA9IGV4cG9ydHMuTWFuYWdlU3RhdGVPcGVyYXRpb24gfHwgKGV4cG9ydHMuTWFuYWdlU3RhdGVPcGVyYXRpb24gPSB7fSkpO1xuZnVuY3Rpb24gZ2V0TWFuYWdlU3RhdGVJbXBsZW1lbnRhdGlvbih7IGNsZWFyU25hcFN0YXRlLCBnZXRTbmFwU3RhdGUsIHVwZGF0ZVNuYXBTdGF0ZSwgfSkge1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiBtYW5hZ2VTdGF0ZShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgcGFyYW1zID0gW10sIG1ldGhvZCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgW29wZXJhdGlvbiwgbmV3U3RhdGVdID0gcGFyYW1zO1xuICAgICAgICBzd2l0Y2ggKG9wZXJhdGlvbikge1xuICAgICAgICAgICAgY2FzZSBNYW5hZ2VTdGF0ZU9wZXJhdGlvbi5jbGVhclN0YXRlOlxuICAgICAgICAgICAgICAgIGF3YWl0IGNsZWFyU25hcFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjYXNlIE1hbmFnZVN0YXRlT3BlcmF0aW9uLmdldFN0YXRlOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBnZXRTbmFwU3RhdGUoKTtcbiAgICAgICAgICAgIGNhc2UgTWFuYWdlU3RhdGVPcGVyYXRpb24udXBkYXRlU3RhdGU6XG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsc18xLmlzUGxhaW5PYmplY3QobmV3U3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkICR7bWV0aG9kfSBcInVwZGF0ZVN0YXRlXCIgcGFyYW1ldGVyOiBUaGUgbmV3IHN0YXRlIG11c3QgYmUgYSBwbGFpbiBvYmplY3QuYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlZE5ld1N0YXRlOiB0eXBlb2YgbmV3U3RhdGUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCB1cGRhdGVTbmFwU3RhdGUobmV3U3RhdGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhgSW52YWxpZCAke21ldGhvZH0gb3BlcmF0aW9uOiBcIiR7b3BlcmF0aW9ufVwiYCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFuYWdlU3RhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEJpcDQ0RW50cm9weUJ1aWxkZXIgPSB2b2lkIDA7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuY29uc3Qga2V5X3RyZWVfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2sva2V5LXRyZWVcIik7XG5jb25zdCBtZXRob2RQcmVmaXggPSAnc25hcF9nZXRCaXA0NEVudHJvcHlfJztcbmNvbnN0IHRhcmdldEtleSA9IGAke21ldGhvZFByZWZpeH0qYDtcbi8qKlxuICogYHNuYXBfZ2V0QmlwNDRFbnRyb3B5XypgIGxldHMgdGhlIFNuYXAgY29udHJvbCBwcml2YXRlIGtleXMgZm9yIGEgcGFydGljdWxhclxuICogQklQLTMyIGNvaW4gdHlwZS5cbiAqL1xuY29uc3Qgc3BlY2lmaWNhdGlvbkJ1aWxkZXIgPSAoeyBhbGxvd2VkQ2F2ZWF0cyA9IG51bGwsIG1ldGhvZEhvb2tzLCB9KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0S2V5LFxuICAgICAgICBhbGxvd2VkQ2F2ZWF0cyxcbiAgICAgICAgbWV0aG9kSW1wbGVtZW50YXRpb246IGdldEJpcDQ0RW50cm9weUltcGxlbWVudGF0aW9uKG1ldGhvZEhvb2tzKSxcbiAgICB9O1xufTtcbmV4cG9ydHMuZ2V0QmlwNDRFbnRyb3B5QnVpbGRlciA9IE9iamVjdC5mcmVlemUoe1xuICAgIHRhcmdldEtleSxcbiAgICBzcGVjaWZpY2F0aW9uQnVpbGRlcixcbiAgICBtZXRob2RIb29rczoge1xuICAgICAgICBnZXRNbmVtb25pYzogdHJ1ZSxcbiAgICB9LFxufSk7XG5jb25zdCBBTExfRElHSVRfUkVHRVggPSAvXlxcZCskL3U7XG5mdW5jdGlvbiBnZXRCaXA0NEVudHJvcHlJbXBsZW1lbnRhdGlvbih7IGdldE1uZW1vbmljLCB9KSB7XG4gICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIGdldEJpcDQ0RW50cm9weShhcmdzKSB7XG4gICAgICAgIGNvbnN0IGJpcDQ0Q29kZSA9IGFyZ3MubWV0aG9kLnN1YnN0cihtZXRob2RQcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgaWYgKCFBTExfRElHSVRfUkVHRVgudGVzdChiaXA0NENvZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90Rm91bmQoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIEJJUC00NCBjb2RlOiAke2JpcDQ0Q29kZX1gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBrZXlfdHJlZV8xLkJJUDQ0Q29pblR5cGVOb2RlKFtcbiAgICAgICAgICAgIGBiaXAzOToke2F3YWl0IGdldE1uZW1vbmljKCl9YCxcbiAgICAgICAgICAgIGBiaXAzMjo0NCdgLFxuICAgICAgICAgICAgYGJpcDMyOiR7TnVtYmVyKGJpcDQ0Q29kZSl9J2AsXG4gICAgICAgIF0pLnRvSlNPTigpO1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRCaXA0NEVudHJvcHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFNuYXBzSGFuZGxlciA9IHZvaWQgMDtcbi8qKlxuICogYHdhbGxldF9nZXRTbmFwc2AgZ2V0cyB0aGUgcmVxdWVzdGVyJ3MgcGVybWl0dGVkIGFuZCBpbnN0YWxsZWQgU25hcHMuXG4gKi9cbmV4cG9ydHMuZ2V0U25hcHNIYW5kbGVyID0ge1xuICAgIG1ldGhvZE5hbWVzOiBbJ3dhbGxldF9nZXRTbmFwcyddLFxuICAgIGltcGxlbWVudGF0aW9uOiBnZXRTbmFwc0ltcGxlbWVudGF0aW9uLFxuICAgIGhvb2tOYW1lczoge1xuICAgICAgICBnZXRTbmFwczogdHJ1ZSxcbiAgICB9LFxufTtcbmFzeW5jIGZ1bmN0aW9uIGdldFNuYXBzSW1wbGVtZW50YXRpb24oX3JlcSwgcmVzLCBfbmV4dCwgZW5kLCB7IGdldFNuYXBzIH0pIHtcbiAgICAvLyBnZXRTbmFwcyBpcyBhbHJlYWR5IGJvdW5kIHRvIHRoZSBvcmlnaW5cbiAgICByZXMucmVzdWx0ID0gZ2V0U25hcHMoKTtcbiAgICByZXR1cm4gZW5kKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRTbmFwcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0QXBwS2V5SGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG4vKipcbiAqIGBzbmFwX2dldEFwcEtleWAgZ2V0cyB0aGUgU25hcCdzIGFwcCBrZXkuXG4gKi9cbmV4cG9ydHMuZ2V0QXBwS2V5SGFuZGxlciA9IHtcbiAgICBtZXRob2ROYW1lczogWydzbmFwX2dldEFwcEtleSddLFxuICAgIGltcGxlbWVudGF0aW9uOiBnZXRBcHBLZXlJbXBsZW1lbnRhdGlvbixcbiAgICBob29rTmFtZXM6IHtcbiAgICAgICAgZ2V0QXBwS2V5OiB0cnVlLFxuICAgIH0sXG59O1xuYXN5bmMgZnVuY3Rpb24gZ2V0QXBwS2V5SW1wbGVtZW50YXRpb24ocmVxLCByZXMsIF9uZXh0LCBlbmQsIHsgZ2V0QXBwS2V5IH0pIHtcbiAgICBjb25zdCBbcmVxdWVzdGVkQWNjb3VudF0gPSAocmVxID09PSBudWxsIHx8IHJlcSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVxLnBhcmFtcykgfHwgW107XG4gICAgaWYgKHJlcXVlc3RlZEFjY291bnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAoIXJlcXVlc3RlZEFjY291bnQgfHwgdHlwZW9mIHJlcXVlc3RlZEFjY291bnQgIT09ICdzdHJpbmcnKSkge1xuICAgICAgICByZXR1cm4gZW5kKGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdNdXN0IG9taXQgcGFyYW1zIGNvbXBsZXRlbHkgb3Igc3BlY2lmeSBhIHNpbmdsZSBoZXhhZGVjaW1hbCBzdHJpbmcgRXRoZXJldW0gYWNjb3VudC4nLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBnZXRBcHBLZXkocmVxdWVzdGVkQWNjb3VudCk7XG4gICAgICAgIHJldHVybiBlbmQoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlbmQoZXJyb3IpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEFwcEtleS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW5zdGFsbFNuYXBzSGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG5jb25zdCBzbmFwSW5zdGFsbGF0aW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb24vc25hcEluc3RhbGxhdGlvblwiKTtcbi8qKlxuICogYHdhbGxldF9pbnN0YWxsU25hcHNgIGluc3RhbGxzIHRoZSByZXF1ZXN0ZWQgU25hcHMsIGlmIHRoZXkgYXJlIHBlcm1pdHRlZC5cbiAqL1xuZXhwb3J0cy5pbnN0YWxsU25hcHNIYW5kbGVyID0ge1xuICAgIG1ldGhvZE5hbWVzOiBbJ3dhbGxldF9pbnN0YWxsU25hcHMnXSxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW5zdGFsbFNuYXBzSW1wbGVtZW50YXRpb24sXG4gICAgaG9va05hbWVzOiB7XG4gICAgICAgIGluc3RhbGxTbmFwczogdHJ1ZSxcbiAgICB9LFxufTtcbmFzeW5jIGZ1bmN0aW9uIGluc3RhbGxTbmFwc0ltcGxlbWVudGF0aW9uKHJlcSwgcmVzLCBfbmV4dCwgZW5kLCB7IGluc3RhbGxTbmFwcyB9KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlcS5wYXJhbXMpKSB7XG4gICAgICAgIHJldHVybiBlbmQoZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICAgICAgbWVzc2FnZTogJ1wicGFyYW1zXCIgbXVzdCBiZSBhbiBhcnJheS4nLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBzbmFwSW5zdGFsbGF0aW9uXzEuaGFuZGxlSW5zdGFsbFNuYXBzKHJlcS5wYXJhbXNbMF0sIGluc3RhbGxTbmFwcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVzLmVycm9yID0gZXJyO1xuICAgIH1cbiAgICByZXR1cm4gZW5kKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnN0YWxsU25hcHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmludm9rZVNuYXBTdWdhckhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuY29uc3Qgc25hcF9jb250cm9sbGVyc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbi8qKlxuICogYHdhbGxldF9pbnZva2VTbmFwYCBhdHRlbXB0cyB0byBpbnZva2UgYW4gUlBDIG1ldGhvZCBvZiB0aGUgc3BlY2lmaWVkIFNuYXAuXG4gKi9cbmV4cG9ydHMuaW52b2tlU25hcFN1Z2FySGFuZGxlciA9IHtcbiAgICBtZXRob2ROYW1lczogWyd3YWxsZXRfaW52b2tlU25hcCddLFxuICAgIGltcGxlbWVudGF0aW9uOiBpbnZva2VTbmFwU3VnYXIsXG4gICAgaG9va05hbWVzOiB1bmRlZmluZWQsXG59O1xuYXN5bmMgZnVuY3Rpb24gaW52b2tlU25hcFN1Z2FyKHJlcSwgX3JlcywgbmV4dCwgZW5kKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlcS5wYXJhbXMpIHx8XG4gICAgICAgIHR5cGVvZiByZXEucGFyYW1zWzBdICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAhdXRpbHNfMS5pc1BsYWluT2JqZWN0KHJlcS5wYXJhbXNbMV0pKSB7XG4gICAgICAgIHJldHVybiBlbmQoZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICAgICAgbWVzc2FnZTogJ011c3Qgc3BlY2lmeSBhIHN0cmluZyBzbmFwIElEIGFuZCBhIHBsYWluIHJlcXVlc3Qgb2JqZWN0LicsXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmVxLm1ldGhvZCA9IHNuYXBfY29udHJvbGxlcnNfMS5TTkFQX1BSRUZJWCArIHJlcS5wYXJhbXNbMF07XG4gICAgcmVxLnBhcmFtcyA9IFtyZXEucGFyYW1zWzFdXTtcbiAgICByZXR1cm4gbmV4dCgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW52b2tlU25hcFN1Z2FyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbmFibGVXYWxsZXRIYW5kbGVyID0gdm9pZCAwO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbmNvbnN0IHNuYXBfY29udHJvbGxlcnNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc25hcC1jb250cm9sbGVyc1wiKTtcbmNvbnN0IHNuYXBJbnN0YWxsYXRpb25fMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9zbmFwSW5zdGFsbGF0aW9uXCIpO1xuLyoqXG4gKiBgd2FsbGV0X2VuYWJsZWAgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgdGhhdCB0YWtlcyBhIHJlcXVlc3QgcGVybWlzc2lvbnNcbiAqIG9iamVjdCBhcyBpdHMgc2luZ2xlIHBhcmFtZXRlciwgYW5kIHRoZW4gY2FsbHMgYHdhbGxldF9yZXF1ZXN0UGVybWlzc2lvbnNgLFxuICogYHdhbGxldF9pbnN0YWxsU25hcHNgLCBhbmQgYGV0aF9hY2NvdW50c2AgYXMgYXBwcm9wcmlhdGUgYmFzZWQgb24gdGhlXG4gKiByZXF1ZXN0ZWQgcGVybWlzc2lvbnMuIFRoZSBtZXRob2QgcmV0dXJucyBhIHNpbmdsZSBvYmplY3QgcmVzdWx0IHdpdGhcbiAqIHNlcGFyYXRlIHByb3BlcnRpZXMgZm9yIHRoZSByZXR1cm4gdmFsdWVzIG9mIGVhY2ggbWV0aG9kLCBhbmQgYW55IGVycm9yc1xuICogdGhhdCBvY2N1cnJlZDpcbiAqXG4gKiBgeyBhY2NvdW50cywgcGVybWlzc2lvbnMsIHNuYXBzLCBlcnJvcnM/IH1gXG4gKi9cbmV4cG9ydHMuZW5hYmxlV2FsbGV0SGFuZGxlciA9IHtcbiAgICBtZXRob2ROYW1lczogWyd3YWxsZXRfZW5hYmxlJ10sXG4gICAgaW1wbGVtZW50YXRpb246IGVuYWJsZVdhbGxldCxcbiAgICBob29rTmFtZXM6IHtcbiAgICAgICAgZ2V0QWNjb3VudHM6IHRydWUsXG4gICAgICAgIGluc3RhbGxTbmFwczogdHJ1ZSxcbiAgICAgICAgcmVxdWVzdFBlcm1pc3Npb25zOiB0cnVlLFxuICAgIH0sXG59O1xuYXN5bmMgZnVuY3Rpb24gZW5hYmxlV2FsbGV0KHJlcSwgcmVzLCBfbmV4dCwgZW5kLCB7IGdldEFjY291bnRzLCBpbnN0YWxsU25hcHMsIHJlcXVlc3RQZXJtaXNzaW9ucyB9KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlcS5wYXJhbXMpKSB7XG4gICAgICAgIHJldHVybiBlbmQoZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICAgICAgbWVzc2FnZTogJ1wicGFyYW1zXCIgbXVzdCBiZSBhbiBhcnJheS4nLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgYWNjb3VudHM6IFtdLFxuICAgICAgICBwZXJtaXNzaW9uczogW10sXG4gICAgICAgIHNuYXBzOiB7fSxcbiAgICB9O1xuICAgIC8vIHJlcXVlc3QgdGhlIHBlcm1pc3Npb25zXG4gICAgbGV0IHJlcXVlc3RlZFBlcm1pc3Npb25zO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIHdlIGV4cGVjdCB0aGUgcGFyYW1zIHRvIGJlIHRoZSBzYW1lIGFzIHdhbGxldF9yZXF1ZXN0UGVybWlzc2lvbnNcbiAgICAgICAgcmVxdWVzdGVkUGVybWlzc2lvbnMgPSBzbmFwSW5zdGFsbGF0aW9uXzEucHJlcHJvY2Vzc1JlcXVlc3RlZFBlcm1pc3Npb25zKHJlcS5wYXJhbXNbMF0pO1xuICAgICAgICByZXN1bHQucGVybWlzc2lvbnMgPSBhd2FpdCByZXF1ZXN0UGVybWlzc2lvbnMocmVxdWVzdGVkUGVybWlzc2lvbnMpO1xuICAgICAgICBpZiAoIXJlc3VsdC5wZXJtaXNzaW9ucyB8fCAhcmVzdWx0LnBlcm1pc3Npb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdCh7IGRhdGE6IHJlcSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBlbmQoZXJyKTtcbiAgICB9XG4gICAgLy8gaW5zdGFsbCBzbmFwcywgaWYgYW55XG4gICAgLy8gZ2V0IHRoZSBuYW1lcyBvZiB0aGUgYXBwcm92ZWQgc25hcHNcbiAgICBjb25zdCByZXF1ZXN0ZWRTbmFwcyA9IHJlc3VsdC5wZXJtaXNzaW9uc1xuICAgICAgICAvLyByZXF1ZXN0UGVybWlzc2lvbnMgcmV0dXJucyBhbGwgcGVybWlzc2lvbnMgZm9yIHRoZSBkb21haW4sXG4gICAgICAgIC8vIHNvIHdlJ3JlIGZpbHRlcmluZyBvdXQgbm9uLXNuYXAgYW5kIHByZWV4aXN0aW5nIHBlcm1pc3Npb25zXG4gICAgICAgIC5maWx0ZXIoKHBlcm0pID0+IHBlcm0ucGFyZW50Q2FwYWJpbGl0eS5zdGFydHNXaXRoKHNuYXBfY29udHJvbGxlcnNfMS5TTkFQX1BSRUZJWCkgJiZcbiAgICAgICAgcGVybS5wYXJlbnRDYXBhYmlsaXR5IGluIHJlcXVlc3RlZFBlcm1pc3Npb25zKVxuICAgICAgICAvLyBjb252ZXJ0IGZyb20gbmFtZXNwYWNlZCBwZXJtaXNzaW9ucyB0byBzbmFwIG5hbWVzXG4gICAgICAgIC5yZWR1Y2UoKF9yZXF1ZXN0ZWRTbmFwcywgcGVybSkgPT4ge1xuICAgICAgICBjb25zdCBzbmFwSWQgPSBwZXJtLnBhcmVudENhcGFiaWxpdHkucmVwbGFjZShzbmFwX2NvbnRyb2xsZXJzXzEuU05BUF9QUkVGSVhfUkVHRVgsICcnKTtcbiAgICAgICAgX3JlcXVlc3RlZFNuYXBzW3NuYXBJZF0gPSByZXF1ZXN0ZWRQZXJtaXNzaW9uc1twZXJtLnBhcmVudENhcGFiaWxpdHldO1xuICAgICAgICByZXR1cm4gX3JlcXVlc3RlZFNuYXBzO1xuICAgIH0sIHt9KTtcbiAgICB0cnkge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMocmVxdWVzdGVkU25hcHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIHRoaXMgdGhyb3dzIGlmIHJlcXVlc3RlZFNuYXBzIGlzIGVtcHR5XG4gICAgICAgICAgICByZXN1bHQuc25hcHMgPSBhd2FpdCBzbmFwSW5zdGFsbGF0aW9uXzEuaGFuZGxlSW5zdGFsbFNuYXBzKHJlcXVlc3RlZFNuYXBzLCBpbnN0YWxsU25hcHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCFyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmVycm9ycy5wdXNoKGV0aF9ycGNfZXJyb3JzXzEuc2VyaWFsaXplRXJyb3IoZXJyKSk7XG4gICAgfVxuICAgIC8vIGdldCB3aGF0ZXZlciBhY2NvdW50cyB3ZSBoYXZlXG4gICAgcmVzdWx0LmFjY291bnRzID0gYXdhaXQgZ2V0QWNjb3VudHMoKTtcbiAgICAvLyByZXR1cm4gdGhlIHJlc3VsdFxuICAgIHJlcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgcmV0dXJuIGVuZCgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5hYmxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuQ29uc3RhbnRDb2RlTWFwfSBDb25zdGFudENvZGVNYXAgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5OYW1lVWludDhBcnJheU1hcH0gTmFtZVVpbnQ4QXJyYXlNYXAgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5Db2RlTmFtZU1hcH0gQ29kZU5hbWVNYXAgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5Db2RlY05hbWV9IENvZGVjTmFtZSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLkNvZGVjQ29uc3RhbnR9IENvZGVjQ29uc3RhbnQgKi9cblxuY29uc3QgeyBiYXNlVGFibGUgfSA9IHJlcXVpcmUoJy4vZ2VuZXJhdGVkLXRhYmxlJylcbmNvbnN0IHZhcmludEVuY29kZSA9IHJlcXVpcmUoJy4vdXRpbCcpLnZhcmludEVuY29kZVxuXG5jb25zdCBuYW1lVG9WYXJpbnQgPSAvKiogQHR5cGUge05hbWVVaW50OEFycmF5TWFwfSAqLyAoe30pXG5jb25zdCBjb25zdGFudFRvQ29kZSA9IC8qKiBAdHlwZSB7Q29uc3RhbnRDb2RlTWFwfSAqLyh7fSlcbmNvbnN0IGNvZGVUb05hbWUgPSAvKiogQHR5cGUge0NvZGVOYW1lTWFwfSAqLyh7fSlcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuZm9yIChjb25zdCBuYW1lIGluIGJhc2VUYWJsZSkge1xuICBjb25zdCBjb2RlY05hbWUgPSAvKiogQHR5cGUge0NvZGVjTmFtZX0gKi8obmFtZSlcbiAgY29uc3QgY29kZSA9IGJhc2VUYWJsZVtjb2RlY05hbWVdXG4gIG5hbWVUb1ZhcmludFtjb2RlY05hbWVdID0gdmFyaW50RW5jb2RlKGNvZGUpXG5cbiAgY29uc3QgY29uc3RhbnQgPSAvKiogQHR5cGUge0NvZGVjQ29uc3RhbnR9ICovKGNvZGVjTmFtZS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLy0vZywgJ18nKSlcbiAgY29uc3RhbnRUb0NvZGVbY29uc3RhbnRdID0gY29kZVxuXG4gIGlmICghY29kZVRvTmFtZVtjb2RlXSkge1xuICAgIGNvZGVUb05hbWVbY29kZV0gPSBjb2RlY05hbWVcbiAgfVxufVxuXG5PYmplY3QuZnJlZXplKG5hbWVUb1ZhcmludClcbk9iamVjdC5mcmVlemUoY29uc3RhbnRUb0NvZGUpXG5PYmplY3QuZnJlZXplKGNvZGVUb05hbWUpXG5jb25zdCBuYW1lVG9Db2RlID0gT2JqZWN0LmZyZWV6ZShiYXNlVGFibGUpXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZVRvVmFyaW50LFxuICBjb25zdGFudFRvQ29kZSxcbiAgbmFtZVRvQ29kZSxcbiAgY29kZVRvTmFtZVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZW5jb2RlOiByZXF1aXJlKCcuL2VuY29kZS5qcycpXG4gICwgZGVjb2RlOiByZXF1aXJlKCcuL2RlY29kZS5qcycpXG4gICwgZW5jb2RpbmdMZW5ndGg6IHJlcXVpcmUoJy4vbGVuZ3RoLmpzJylcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuY29uc3QgdWludDhBcnJheVRvU3RyaW5nID0gcmVxdWlyZSgndWludDhhcnJheXMvdG8tc3RyaW5nJylcbmNvbnN0IHVpbnQ4QXJyYXlGcm9tU3RyaW5nID0gcmVxdWlyZSgndWludDhhcnJheXMvZnJvbS1zdHJpbmcnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbnVtYmVyVG9VaW50OEFycmF5LFxuICB1aW50OEFycmF5VG9OdW1iZXIsXG4gIHZhcmludFVpbnQ4QXJyYXlFbmNvZGUsXG4gIHZhcmludEVuY29kZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKi9cbmZ1bmN0aW9uIHVpbnQ4QXJyYXlUb051bWJlciAoYnVmKSB7XG4gIHJldHVybiBwYXJzZUludCh1aW50OEFycmF5VG9TdHJpbmcoYnVmLCAnYmFzZTE2JyksIDE2KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1cbiAqL1xuZnVuY3Rpb24gbnVtYmVyVG9VaW50OEFycmF5IChudW0pIHtcbiAgbGV0IGhleFN0cmluZyA9IG51bS50b1N0cmluZygxNilcbiAgaWYgKGhleFN0cmluZy5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgaGV4U3RyaW5nID0gJzAnICsgaGV4U3RyaW5nXG4gIH1cbiAgcmV0dXJuIHVpbnQ4QXJyYXlGcm9tU3RyaW5nKGhleFN0cmluZywgJ2Jhc2UxNicpXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBpbnB1dFxuICovXG5mdW5jdGlvbiB2YXJpbnRVaW50OEFycmF5RW5jb2RlIChpbnB1dCkge1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKHZhcmludC5lbmNvZGUodWludDhBcnJheVRvTnVtYmVyKGlucHV0KSkpXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bVxuICovXG5mdW5jdGlvbiB2YXJpbnRFbmNvZGUgKG51bSkge1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKHZhcmludC5lbmNvZGUobnVtKSlcbn1cbiIsIi8qIGVzbGludCBxdW90ZS1wcm9wczogb2ZmICovXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBOYW1lcyBmb3IgYWxsIGF2YWlsYWJsZSBoYXNoZXNcbiAqXG4gKiBAdHlwZWRlZiB7IFwiaWRlbnRpdHlcIiB8IFwic2hhMVwiIHwgXCJzaGEyLTI1NlwiIHwgXCJzaGEyLTUxMlwiIHwgXCJzaGEzLTUxMlwiIHwgXCJzaGEzLTM4NFwiIHwgXCJzaGEzLTI1NlwiIHwgXCJzaGEzLTIyNFwiIHwgXCJzaGFrZS0xMjhcIiB8IFwic2hha2UtMjU2XCIgfCBcImtlY2Nhay0yMjRcIiB8IFwia2VjY2FrLTI1NlwiIHwgXCJrZWNjYWstMzg0XCIgfCBcImtlY2Nhay01MTJcIiB8IFwiYmxha2UzXCIgfCBcIm11cm11cjMtMTI4XCIgfCBcIm11cm11cjMtMzJcIiB8IFwiZGJsLXNoYTItMjU2XCIgfCBcIm1kNFwiIHwgXCJtZDVcIiB8IFwiYm10XCIgfCBcInNoYTItMjU2LXRydW5jMjU0LXBhZGRlZFwiIHwgXCJyaXBlbWQtMTI4XCIgfCBcInJpcGVtZC0xNjBcIiB8IFwicmlwZW1kLTI1NlwiIHwgXCJyaXBlbWQtMzIwXCIgfCBcIngxMVwiIHwgXCJrYW5nYXJvb3R3ZWx2ZVwiIHwgXCJzbTMtMjU2XCIgfCBcImJsYWtlMmItOFwiIHwgXCJibGFrZTJiLTE2XCIgfCBcImJsYWtlMmItMjRcIiB8IFwiYmxha2UyYi0zMlwiIHwgXCJibGFrZTJiLTQwXCIgfCBcImJsYWtlMmItNDhcIiB8IFwiYmxha2UyYi01NlwiIHwgXCJibGFrZTJiLTY0XCIgfCBcImJsYWtlMmItNzJcIiB8IFwiYmxha2UyYi04MFwiIHwgXCJibGFrZTJiLTg4XCIgfCBcImJsYWtlMmItOTZcIiB8IFwiYmxha2UyYi0xMDRcIiB8IFwiYmxha2UyYi0xMTJcIiB8IFwiYmxha2UyYi0xMjBcIiB8IFwiYmxha2UyYi0xMjhcIiB8IFwiYmxha2UyYi0xMzZcIiB8IFwiYmxha2UyYi0xNDRcIiB8IFwiYmxha2UyYi0xNTJcIiB8IFwiYmxha2UyYi0xNjBcIiB8IFwiYmxha2UyYi0xNjhcIiB8IFwiYmxha2UyYi0xNzZcIiB8IFwiYmxha2UyYi0xODRcIiB8IFwiYmxha2UyYi0xOTJcIiB8IFwiYmxha2UyYi0yMDBcIiB8IFwiYmxha2UyYi0yMDhcIiB8IFwiYmxha2UyYi0yMTZcIiB8IFwiYmxha2UyYi0yMjRcIiB8IFwiYmxha2UyYi0yMzJcIiB8IFwiYmxha2UyYi0yNDBcIiB8IFwiYmxha2UyYi0yNDhcIiB8IFwiYmxha2UyYi0yNTZcIiB8IFwiYmxha2UyYi0yNjRcIiB8IFwiYmxha2UyYi0yNzJcIiB8IFwiYmxha2UyYi0yODBcIiB8IFwiYmxha2UyYi0yODhcIiB8IFwiYmxha2UyYi0yOTZcIiB8IFwiYmxha2UyYi0zMDRcIiB8IFwiYmxha2UyYi0zMTJcIiB8IFwiYmxha2UyYi0zMjBcIiB8IFwiYmxha2UyYi0zMjhcIiB8IFwiYmxha2UyYi0zMzZcIiB8IFwiYmxha2UyYi0zNDRcIiB8IFwiYmxha2UyYi0zNTJcIiB8IFwiYmxha2UyYi0zNjBcIiB8IFwiYmxha2UyYi0zNjhcIiB8IFwiYmxha2UyYi0zNzZcIiB8IFwiYmxha2UyYi0zODRcIiB8IFwiYmxha2UyYi0zOTJcIiB8IFwiYmxha2UyYi00MDBcIiB8IFwiYmxha2UyYi00MDhcIiB8IFwiYmxha2UyYi00MTZcIiB8IFwiYmxha2UyYi00MjRcIiB8IFwiYmxha2UyYi00MzJcIiB8IFwiYmxha2UyYi00NDBcIiB8IFwiYmxha2UyYi00NDhcIiB8IFwiYmxha2UyYi00NTZcIiB8IFwiYmxha2UyYi00NjRcIiB8IFwiYmxha2UyYi00NzJcIiB8IFwiYmxha2UyYi00ODBcIiB8IFwiYmxha2UyYi00ODhcIiB8IFwiYmxha2UyYi00OTZcIiB8IFwiYmxha2UyYi01MDRcIiB8IFwiYmxha2UyYi01MTJcIiB8IFwiYmxha2Uycy04XCIgfCBcImJsYWtlMnMtMTZcIiB8IFwiYmxha2Uycy0yNFwiIHwgXCJibGFrZTJzLTMyXCIgfCBcImJsYWtlMnMtNDBcIiB8IFwiYmxha2Uycy00OFwiIHwgXCJibGFrZTJzLTU2XCIgfCBcImJsYWtlMnMtNjRcIiB8IFwiYmxha2Uycy03MlwiIHwgXCJibGFrZTJzLTgwXCIgfCBcImJsYWtlMnMtODhcIiB8IFwiYmxha2Uycy05NlwiIHwgXCJibGFrZTJzLTEwNFwiIHwgXCJibGFrZTJzLTExMlwiIHwgXCJibGFrZTJzLTEyMFwiIHwgXCJibGFrZTJzLTEyOFwiIHwgXCJibGFrZTJzLTEzNlwiIHwgXCJibGFrZTJzLTE0NFwiIHwgXCJibGFrZTJzLTE1MlwiIHwgXCJibGFrZTJzLTE2MFwiIHwgXCJibGFrZTJzLTE2OFwiIHwgXCJibGFrZTJzLTE3NlwiIHwgXCJibGFrZTJzLTE4NFwiIHwgXCJibGFrZTJzLTE5MlwiIHwgXCJibGFrZTJzLTIwMFwiIHwgXCJibGFrZTJzLTIwOFwiIHwgXCJibGFrZTJzLTIxNlwiIHwgXCJibGFrZTJzLTIyNFwiIHwgXCJibGFrZTJzLTIzMlwiIHwgXCJibGFrZTJzLTI0MFwiIHwgXCJibGFrZTJzLTI0OFwiIHwgXCJibGFrZTJzLTI1NlwiIHwgXCJza2VpbjI1Ni04XCIgfCBcInNrZWluMjU2LTE2XCIgfCBcInNrZWluMjU2LTI0XCIgfCBcInNrZWluMjU2LTMyXCIgfCBcInNrZWluMjU2LTQwXCIgfCBcInNrZWluMjU2LTQ4XCIgfCBcInNrZWluMjU2LTU2XCIgfCBcInNrZWluMjU2LTY0XCIgfCBcInNrZWluMjU2LTcyXCIgfCBcInNrZWluMjU2LTgwXCIgfCBcInNrZWluMjU2LTg4XCIgfCBcInNrZWluMjU2LTk2XCIgfCBcInNrZWluMjU2LTEwNFwiIHwgXCJza2VpbjI1Ni0xMTJcIiB8IFwic2tlaW4yNTYtMTIwXCIgfCBcInNrZWluMjU2LTEyOFwiIHwgXCJza2VpbjI1Ni0xMzZcIiB8IFwic2tlaW4yNTYtMTQ0XCIgfCBcInNrZWluMjU2LTE1MlwiIHwgXCJza2VpbjI1Ni0xNjBcIiB8IFwic2tlaW4yNTYtMTY4XCIgfCBcInNrZWluMjU2LTE3NlwiIHwgXCJza2VpbjI1Ni0xODRcIiB8IFwic2tlaW4yNTYtMTkyXCIgfCBcInNrZWluMjU2LTIwMFwiIHwgXCJza2VpbjI1Ni0yMDhcIiB8IFwic2tlaW4yNTYtMjE2XCIgfCBcInNrZWluMjU2LTIyNFwiIHwgXCJza2VpbjI1Ni0yMzJcIiB8IFwic2tlaW4yNTYtMjQwXCIgfCBcInNrZWluMjU2LTI0OFwiIHwgXCJza2VpbjI1Ni0yNTZcIiB8IFwic2tlaW41MTItOFwiIHwgXCJza2VpbjUxMi0xNlwiIHwgXCJza2VpbjUxMi0yNFwiIHwgXCJza2VpbjUxMi0zMlwiIHwgXCJza2VpbjUxMi00MFwiIHwgXCJza2VpbjUxMi00OFwiIHwgXCJza2VpbjUxMi01NlwiIHwgXCJza2VpbjUxMi02NFwiIHwgXCJza2VpbjUxMi03MlwiIHwgXCJza2VpbjUxMi04MFwiIHwgXCJza2VpbjUxMi04OFwiIHwgXCJza2VpbjUxMi05NlwiIHwgXCJza2VpbjUxMi0xMDRcIiB8IFwic2tlaW41MTItMTEyXCIgfCBcInNrZWluNTEyLTEyMFwiIHwgXCJza2VpbjUxMi0xMjhcIiB8IFwic2tlaW41MTItMTM2XCIgfCBcInNrZWluNTEyLTE0NFwiIHwgXCJza2VpbjUxMi0xNTJcIiB8IFwic2tlaW41MTItMTYwXCIgfCBcInNrZWluNTEyLTE2OFwiIHwgXCJza2VpbjUxMi0xNzZcIiB8IFwic2tlaW41MTItMTg0XCIgfCBcInNrZWluNTEyLTE5MlwiIHwgXCJza2VpbjUxMi0yMDBcIiB8IFwic2tlaW41MTItMjA4XCIgfCBcInNrZWluNTEyLTIxNlwiIHwgXCJza2VpbjUxMi0yMjRcIiB8IFwic2tlaW41MTItMjMyXCIgfCBcInNrZWluNTEyLTI0MFwiIHwgXCJza2VpbjUxMi0yNDhcIiB8IFwic2tlaW41MTItMjU2XCIgfCBcInNrZWluNTEyLTI2NFwiIHwgXCJza2VpbjUxMi0yNzJcIiB8IFwic2tlaW41MTItMjgwXCIgfCBcInNrZWluNTEyLTI4OFwiIHwgXCJza2VpbjUxMi0yOTZcIiB8IFwic2tlaW41MTItMzA0XCIgfCBcInNrZWluNTEyLTMxMlwiIHwgXCJza2VpbjUxMi0zMjBcIiB8IFwic2tlaW41MTItMzI4XCIgfCBcInNrZWluNTEyLTMzNlwiIHwgXCJza2VpbjUxMi0zNDRcIiB8IFwic2tlaW41MTItMzUyXCIgfCBcInNrZWluNTEyLTM2MFwiIHwgXCJza2VpbjUxMi0zNjhcIiB8IFwic2tlaW41MTItMzc2XCIgfCBcInNrZWluNTEyLTM4NFwiIHwgXCJza2VpbjUxMi0zOTJcIiB8IFwic2tlaW41MTItNDAwXCIgfCBcInNrZWluNTEyLTQwOFwiIHwgXCJza2VpbjUxMi00MTZcIiB8IFwic2tlaW41MTItNDI0XCIgfCBcInNrZWluNTEyLTQzMlwiIHwgXCJza2VpbjUxMi00NDBcIiB8IFwic2tlaW41MTItNDQ4XCIgfCBcInNrZWluNTEyLTQ1NlwiIHwgXCJza2VpbjUxMi00NjRcIiB8IFwic2tlaW41MTItNDcyXCIgfCBcInNrZWluNTEyLTQ4MFwiIHwgXCJza2VpbjUxMi00ODhcIiB8IFwic2tlaW41MTItNDk2XCIgfCBcInNrZWluNTEyLTUwNFwiIHwgXCJza2VpbjUxMi01MTJcIiB8IFwic2tlaW4xMDI0LThcIiB8IFwic2tlaW4xMDI0LTE2XCIgfCBcInNrZWluMTAyNC0yNFwiIHwgXCJza2VpbjEwMjQtMzJcIiB8IFwic2tlaW4xMDI0LTQwXCIgfCBcInNrZWluMTAyNC00OFwiIHwgXCJza2VpbjEwMjQtNTZcIiB8IFwic2tlaW4xMDI0LTY0XCIgfCBcInNrZWluMTAyNC03MlwiIHwgXCJza2VpbjEwMjQtODBcIiB8IFwic2tlaW4xMDI0LTg4XCIgfCBcInNrZWluMTAyNC05NlwiIHwgXCJza2VpbjEwMjQtMTA0XCIgfCBcInNrZWluMTAyNC0xMTJcIiB8IFwic2tlaW4xMDI0LTEyMFwiIHwgXCJza2VpbjEwMjQtMTI4XCIgfCBcInNrZWluMTAyNC0xMzZcIiB8IFwic2tlaW4xMDI0LTE0NFwiIHwgXCJza2VpbjEwMjQtMTUyXCIgfCBcInNrZWluMTAyNC0xNjBcIiB8IFwic2tlaW4xMDI0LTE2OFwiIHwgXCJza2VpbjEwMjQtMTc2XCIgfCBcInNrZWluMTAyNC0xODRcIiB8IFwic2tlaW4xMDI0LTE5MlwiIHwgXCJza2VpbjEwMjQtMjAwXCIgfCBcInNrZWluMTAyNC0yMDhcIiB8IFwic2tlaW4xMDI0LTIxNlwiIHwgXCJza2VpbjEwMjQtMjI0XCIgfCBcInNrZWluMTAyNC0yMzJcIiB8IFwic2tlaW4xMDI0LTI0MFwiIHwgXCJza2VpbjEwMjQtMjQ4XCIgfCBcInNrZWluMTAyNC0yNTZcIiB8IFwic2tlaW4xMDI0LTI2NFwiIHwgXCJza2VpbjEwMjQtMjcyXCIgfCBcInNrZWluMTAyNC0yODBcIiB8IFwic2tlaW4xMDI0LTI4OFwiIHwgXCJza2VpbjEwMjQtMjk2XCIgfCBcInNrZWluMTAyNC0zMDRcIiB8IFwic2tlaW4xMDI0LTMxMlwiIHwgXCJza2VpbjEwMjQtMzIwXCIgfCBcInNrZWluMTAyNC0zMjhcIiB8IFwic2tlaW4xMDI0LTMzNlwiIHwgXCJza2VpbjEwMjQtMzQ0XCIgfCBcInNrZWluMTAyNC0zNTJcIiB8IFwic2tlaW4xMDI0LTM2MFwiIHwgXCJza2VpbjEwMjQtMzY4XCIgfCBcInNrZWluMTAyNC0zNzZcIiB8IFwic2tlaW4xMDI0LTM4NFwiIHwgXCJza2VpbjEwMjQtMzkyXCIgfCBcInNrZWluMTAyNC00MDBcIiB8IFwic2tlaW4xMDI0LTQwOFwiIHwgXCJza2VpbjEwMjQtNDE2XCIgfCBcInNrZWluMTAyNC00MjRcIiB8IFwic2tlaW4xMDI0LTQzMlwiIHwgXCJza2VpbjEwMjQtNDQwXCIgfCBcInNrZWluMTAyNC00NDhcIiB8IFwic2tlaW4xMDI0LTQ1NlwiIHwgXCJza2VpbjEwMjQtNDY0XCIgfCBcInNrZWluMTAyNC00NzJcIiB8IFwic2tlaW4xMDI0LTQ4MFwiIHwgXCJza2VpbjEwMjQtNDg4XCIgfCBcInNrZWluMTAyNC00OTZcIiB8IFwic2tlaW4xMDI0LTUwNFwiIHwgXCJza2VpbjEwMjQtNTEyXCIgfCBcInNrZWluMTAyNC01MjBcIiB8IFwic2tlaW4xMDI0LTUyOFwiIHwgXCJza2VpbjEwMjQtNTM2XCIgfCBcInNrZWluMTAyNC01NDRcIiB8IFwic2tlaW4xMDI0LTU1MlwiIHwgXCJza2VpbjEwMjQtNTYwXCIgfCBcInNrZWluMTAyNC01NjhcIiB8IFwic2tlaW4xMDI0LTU3NlwiIHwgXCJza2VpbjEwMjQtNTg0XCIgfCBcInNrZWluMTAyNC01OTJcIiB8IFwic2tlaW4xMDI0LTYwMFwiIHwgXCJza2VpbjEwMjQtNjA4XCIgfCBcInNrZWluMTAyNC02MTZcIiB8IFwic2tlaW4xMDI0LTYyNFwiIHwgXCJza2VpbjEwMjQtNjMyXCIgfCBcInNrZWluMTAyNC02NDBcIiB8IFwic2tlaW4xMDI0LTY0OFwiIHwgXCJza2VpbjEwMjQtNjU2XCIgfCBcInNrZWluMTAyNC02NjRcIiB8IFwic2tlaW4xMDI0LTY3MlwiIHwgXCJza2VpbjEwMjQtNjgwXCIgfCBcInNrZWluMTAyNC02ODhcIiB8IFwic2tlaW4xMDI0LTY5NlwiIHwgXCJza2VpbjEwMjQtNzA0XCIgfCBcInNrZWluMTAyNC03MTJcIiB8IFwic2tlaW4xMDI0LTcyMFwiIHwgXCJza2VpbjEwMjQtNzI4XCIgfCBcInNrZWluMTAyNC03MzZcIiB8IFwic2tlaW4xMDI0LTc0NFwiIHwgXCJza2VpbjEwMjQtNzUyXCIgfCBcInNrZWluMTAyNC03NjBcIiB8IFwic2tlaW4xMDI0LTc2OFwiIHwgXCJza2VpbjEwMjQtNzc2XCIgfCBcInNrZWluMTAyNC03ODRcIiB8IFwic2tlaW4xMDI0LTc5MlwiIHwgXCJza2VpbjEwMjQtODAwXCIgfCBcInNrZWluMTAyNC04MDhcIiB8IFwic2tlaW4xMDI0LTgxNlwiIHwgXCJza2VpbjEwMjQtODI0XCIgfCBcInNrZWluMTAyNC04MzJcIiB8IFwic2tlaW4xMDI0LTg0MFwiIHwgXCJza2VpbjEwMjQtODQ4XCIgfCBcInNrZWluMTAyNC04NTZcIiB8IFwic2tlaW4xMDI0LTg2NFwiIHwgXCJza2VpbjEwMjQtODcyXCIgfCBcInNrZWluMTAyNC04ODBcIiB8IFwic2tlaW4xMDI0LTg4OFwiIHwgXCJza2VpbjEwMjQtODk2XCIgfCBcInNrZWluMTAyNC05MDRcIiB8IFwic2tlaW4xMDI0LTkxMlwiIHwgXCJza2VpbjEwMjQtOTIwXCIgfCBcInNrZWluMTAyNC05MjhcIiB8IFwic2tlaW4xMDI0LTkzNlwiIHwgXCJza2VpbjEwMjQtOTQ0XCIgfCBcInNrZWluMTAyNC05NTJcIiB8IFwic2tlaW4xMDI0LTk2MFwiIHwgXCJza2VpbjEwMjQtOTY4XCIgfCBcInNrZWluMTAyNC05NzZcIiB8IFwic2tlaW4xMDI0LTk4NFwiIHwgXCJza2VpbjEwMjQtOTkyXCIgfCBcInNrZWluMTAyNC0xMDAwXCIgfCBcInNrZWluMTAyNC0xMDA4XCIgfCBcInNrZWluMTAyNC0xMDE2XCIgfCBcInNrZWluMTAyNC0xMDI0XCIgfCBcInBvc2VpZG9uLWJsczEyXzM4MS1hMi1mYzFcIiB8IFwicG9zZWlkb24tYmxzMTJfMzgxLWEyLWZjMS1zY1wiIH0gSGFzaE5hbWVcbiAqL1xuLyoqXG4gKiBDb2RlcyBmb3IgYWxsIGF2YWlsYWJsZSBoYXNoZXNcbiAqXG4gKiBAdHlwZWRlZiB7IDB4MDAgfCAweDExIHwgMHgxMiB8IDB4MTMgfCAweDE0IHwgMHgxNSB8IDB4MTYgfCAweDE3IHwgMHgxOCB8IDB4MTkgfCAweDFhIHwgMHgxYiB8IDB4MWMgfCAweDFkIHwgMHgxZSB8IDB4MjIgfCAweDIzIHwgMHg1NiB8IDB4ZDQgfCAweGQ1IHwgMHhkNiB8IDB4MTAxMiB8IDB4MTA1MiB8IDB4MTA1MyB8IDB4MTA1NCB8IDB4MTA1NSB8IDB4MTEwMCB8IDB4MWQwMSB8IDB4NTM0ZCB8IDB4YjIwMSB8IDB4YjIwMiB8IDB4YjIwMyB8IDB4YjIwNCB8IDB4YjIwNSB8IDB4YjIwNiB8IDB4YjIwNyB8IDB4YjIwOCB8IDB4YjIwOSB8IDB4YjIwYSB8IDB4YjIwYiB8IDB4YjIwYyB8IDB4YjIwZCB8IDB4YjIwZSB8IDB4YjIwZiB8IDB4YjIxMCB8IDB4YjIxMSB8IDB4YjIxMiB8IDB4YjIxMyB8IDB4YjIxNCB8IDB4YjIxNSB8IDB4YjIxNiB8IDB4YjIxNyB8IDB4YjIxOCB8IDB4YjIxOSB8IDB4YjIxYSB8IDB4YjIxYiB8IDB4YjIxYyB8IDB4YjIxZCB8IDB4YjIxZSB8IDB4YjIxZiB8IDB4YjIyMCB8IDB4YjIyMSB8IDB4YjIyMiB8IDB4YjIyMyB8IDB4YjIyNCB8IDB4YjIyNSB8IDB4YjIyNiB8IDB4YjIyNyB8IDB4YjIyOCB8IDB4YjIyOSB8IDB4YjIyYSB8IDB4YjIyYiB8IDB4YjIyYyB8IDB4YjIyZCB8IDB4YjIyZSB8IDB4YjIyZiB8IDB4YjIzMCB8IDB4YjIzMSB8IDB4YjIzMiB8IDB4YjIzMyB8IDB4YjIzNCB8IDB4YjIzNSB8IDB4YjIzNiB8IDB4YjIzNyB8IDB4YjIzOCB8IDB4YjIzOSB8IDB4YjIzYSB8IDB4YjIzYiB8IDB4YjIzYyB8IDB4YjIzZCB8IDB4YjIzZSB8IDB4YjIzZiB8IDB4YjI0MCB8IDB4YjI0MSB8IDB4YjI0MiB8IDB4YjI0MyB8IDB4YjI0NCB8IDB4YjI0NSB8IDB4YjI0NiB8IDB4YjI0NyB8IDB4YjI0OCB8IDB4YjI0OSB8IDB4YjI0YSB8IDB4YjI0YiB8IDB4YjI0YyB8IDB4YjI0ZCB8IDB4YjI0ZSB8IDB4YjI0ZiB8IDB4YjI1MCB8IDB4YjI1MSB8IDB4YjI1MiB8IDB4YjI1MyB8IDB4YjI1NCB8IDB4YjI1NSB8IDB4YjI1NiB8IDB4YjI1NyB8IDB4YjI1OCB8IDB4YjI1OSB8IDB4YjI1YSB8IDB4YjI1YiB8IDB4YjI1YyB8IDB4YjI1ZCB8IDB4YjI1ZSB8IDB4YjI1ZiB8IDB4YjI2MCB8IDB4YjMwMSB8IDB4YjMwMiB8IDB4YjMwMyB8IDB4YjMwNCB8IDB4YjMwNSB8IDB4YjMwNiB8IDB4YjMwNyB8IDB4YjMwOCB8IDB4YjMwOSB8IDB4YjMwYSB8IDB4YjMwYiB8IDB4YjMwYyB8IDB4YjMwZCB8IDB4YjMwZSB8IDB4YjMwZiB8IDB4YjMxMCB8IDB4YjMxMSB8IDB4YjMxMiB8IDB4YjMxMyB8IDB4YjMxNCB8IDB4YjMxNSB8IDB4YjMxNiB8IDB4YjMxNyB8IDB4YjMxOCB8IDB4YjMxOSB8IDB4YjMxYSB8IDB4YjMxYiB8IDB4YjMxYyB8IDB4YjMxZCB8IDB4YjMxZSB8IDB4YjMxZiB8IDB4YjMyMCB8IDB4YjMyMSB8IDB4YjMyMiB8IDB4YjMyMyB8IDB4YjMyNCB8IDB4YjMyNSB8IDB4YjMyNiB8IDB4YjMyNyB8IDB4YjMyOCB8IDB4YjMyOSB8IDB4YjMyYSB8IDB4YjMyYiB8IDB4YjMyYyB8IDB4YjMyZCB8IDB4YjMyZSB8IDB4YjMyZiB8IDB4YjMzMCB8IDB4YjMzMSB8IDB4YjMzMiB8IDB4YjMzMyB8IDB4YjMzNCB8IDB4YjMzNSB8IDB4YjMzNiB8IDB4YjMzNyB8IDB4YjMzOCB8IDB4YjMzOSB8IDB4YjMzYSB8IDB4YjMzYiB8IDB4YjMzYyB8IDB4YjMzZCB8IDB4YjMzZSB8IDB4YjMzZiB8IDB4YjM0MCB8IDB4YjM0MSB8IDB4YjM0MiB8IDB4YjM0MyB8IDB4YjM0NCB8IDB4YjM0NSB8IDB4YjM0NiB8IDB4YjM0NyB8IDB4YjM0OCB8IDB4YjM0OSB8IDB4YjM0YSB8IDB4YjM0YiB8IDB4YjM0YyB8IDB4YjM0ZCB8IDB4YjM0ZSB8IDB4YjM0ZiB8IDB4YjM1MCB8IDB4YjM1MSB8IDB4YjM1MiB8IDB4YjM1MyB8IDB4YjM1NCB8IDB4YjM1NSB8IDB4YjM1NiB8IDB4YjM1NyB8IDB4YjM1OCB8IDB4YjM1OSB8IDB4YjM1YSB8IDB4YjM1YiB8IDB4YjM1YyB8IDB4YjM1ZCB8IDB4YjM1ZSB8IDB4YjM1ZiB8IDB4YjM2MCB8IDB4YjM2MSB8IDB4YjM2MiB8IDB4YjM2MyB8IDB4YjM2NCB8IDB4YjM2NSB8IDB4YjM2NiB8IDB4YjM2NyB8IDB4YjM2OCB8IDB4YjM2OSB8IDB4YjM2YSB8IDB4YjM2YiB8IDB4YjM2YyB8IDB4YjM2ZCB8IDB4YjM2ZSB8IDB4YjM2ZiB8IDB4YjM3MCB8IDB4YjM3MSB8IDB4YjM3MiB8IDB4YjM3MyB8IDB4YjM3NCB8IDB4YjM3NSB8IDB4YjM3NiB8IDB4YjM3NyB8IDB4YjM3OCB8IDB4YjM3OSB8IDB4YjM3YSB8IDB4YjM3YiB8IDB4YjM3YyB8IDB4YjM3ZCB8IDB4YjM3ZSB8IDB4YjM3ZiB8IDB4YjM4MCB8IDB4YjM4MSB8IDB4YjM4MiB8IDB4YjM4MyB8IDB4YjM4NCB8IDB4YjM4NSB8IDB4YjM4NiB8IDB4YjM4NyB8IDB4YjM4OCB8IDB4YjM4OSB8IDB4YjM4YSB8IDB4YjM4YiB8IDB4YjM4YyB8IDB4YjM4ZCB8IDB4YjM4ZSB8IDB4YjM4ZiB8IDB4YjM5MCB8IDB4YjM5MSB8IDB4YjM5MiB8IDB4YjM5MyB8IDB4YjM5NCB8IDB4YjM5NSB8IDB4YjM5NiB8IDB4YjM5NyB8IDB4YjM5OCB8IDB4YjM5OSB8IDB4YjM5YSB8IDB4YjM5YiB8IDB4YjM5YyB8IDB4YjM5ZCB8IDB4YjM5ZSB8IDB4YjM5ZiB8IDB4YjNhMCB8IDB4YjNhMSB8IDB4YjNhMiB8IDB4YjNhMyB8IDB4YjNhNCB8IDB4YjNhNSB8IDB4YjNhNiB8IDB4YjNhNyB8IDB4YjNhOCB8IDB4YjNhOSB8IDB4YjNhYSB8IDB4YjNhYiB8IDB4YjNhYyB8IDB4YjNhZCB8IDB4YjNhZSB8IDB4YjNhZiB8IDB4YjNiMCB8IDB4YjNiMSB8IDB4YjNiMiB8IDB4YjNiMyB8IDB4YjNiNCB8IDB4YjNiNSB8IDB4YjNiNiB8IDB4YjNiNyB8IDB4YjNiOCB8IDB4YjNiOSB8IDB4YjNiYSB8IDB4YjNiYiB8IDB4YjNiYyB8IDB4YjNiZCB8IDB4YjNiZSB8IDB4YjNiZiB8IDB4YjNjMCB8IDB4YjNjMSB8IDB4YjNjMiB8IDB4YjNjMyB8IDB4YjNjNCB8IDB4YjNjNSB8IDB4YjNjNiB8IDB4YjNjNyB8IDB4YjNjOCB8IDB4YjNjOSB8IDB4YjNjYSB8IDB4YjNjYiB8IDB4YjNjYyB8IDB4YjNjZCB8IDB4YjNjZSB8IDB4YjNjZiB8IDB4YjNkMCB8IDB4YjNkMSB8IDB4YjNkMiB8IDB4YjNkMyB8IDB4YjNkNCB8IDB4YjNkNSB8IDB4YjNkNiB8IDB4YjNkNyB8IDB4YjNkOCB8IDB4YjNkOSB8IDB4YjNkYSB8IDB4YjNkYiB8IDB4YjNkYyB8IDB4YjNkZCB8IDB4YjNkZSB8IDB4YjNkZiB8IDB4YjNlMCB8IDB4YjQwMSB8IDB4YjQwMiB9IEhhc2hDb2RlXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7IFJlY29yZDxIYXNoTmFtZSxIYXNoQ29kZT4gfVxuICovXG5jb25zdCBuYW1lcyA9IE9iamVjdC5mcmVlemUoe1xuICAnaWRlbnRpdHknOiAweDAwLFxuICAnc2hhMSc6IDB4MTEsXG4gICdzaGEyLTI1Nic6IDB4MTIsXG4gICdzaGEyLTUxMic6IDB4MTMsXG4gICdzaGEzLTUxMic6IDB4MTQsXG4gICdzaGEzLTM4NCc6IDB4MTUsXG4gICdzaGEzLTI1Nic6IDB4MTYsXG4gICdzaGEzLTIyNCc6IDB4MTcsXG4gICdzaGFrZS0xMjgnOiAweDE4LFxuICAnc2hha2UtMjU2JzogMHgxOSxcbiAgJ2tlY2Nhay0yMjQnOiAweDFhLFxuICAna2VjY2FrLTI1Nic6IDB4MWIsXG4gICdrZWNjYWstMzg0JzogMHgxYyxcbiAgJ2tlY2Nhay01MTInOiAweDFkLFxuICAnYmxha2UzJzogMHgxZSxcbiAgJ211cm11cjMtMTI4JzogMHgyMixcbiAgJ211cm11cjMtMzInOiAweDIzLFxuICAnZGJsLXNoYTItMjU2JzogMHg1NixcbiAgJ21kNCc6IDB4ZDQsXG4gICdtZDUnOiAweGQ1LFxuICAnYm10JzogMHhkNixcbiAgJ3NoYTItMjU2LXRydW5jMjU0LXBhZGRlZCc6IDB4MTAxMixcbiAgJ3JpcGVtZC0xMjgnOiAweDEwNTIsXG4gICdyaXBlbWQtMTYwJzogMHgxMDUzLFxuICAncmlwZW1kLTI1Nic6IDB4MTA1NCxcbiAgJ3JpcGVtZC0zMjAnOiAweDEwNTUsXG4gICd4MTEnOiAweDExMDAsXG4gICdrYW5nYXJvb3R3ZWx2ZSc6IDB4MWQwMSxcbiAgJ3NtMy0yNTYnOiAweDUzNGQsXG4gICdibGFrZTJiLTgnOiAweGIyMDEsXG4gICdibGFrZTJiLTE2JzogMHhiMjAyLFxuICAnYmxha2UyYi0yNCc6IDB4YjIwMyxcbiAgJ2JsYWtlMmItMzInOiAweGIyMDQsXG4gICdibGFrZTJiLTQwJzogMHhiMjA1LFxuICAnYmxha2UyYi00OCc6IDB4YjIwNixcbiAgJ2JsYWtlMmItNTYnOiAweGIyMDcsXG4gICdibGFrZTJiLTY0JzogMHhiMjA4LFxuICAnYmxha2UyYi03Mic6IDB4YjIwOSxcbiAgJ2JsYWtlMmItODAnOiAweGIyMGEsXG4gICdibGFrZTJiLTg4JzogMHhiMjBiLFxuICAnYmxha2UyYi05Nic6IDB4YjIwYyxcbiAgJ2JsYWtlMmItMTA0JzogMHhiMjBkLFxuICAnYmxha2UyYi0xMTInOiAweGIyMGUsXG4gICdibGFrZTJiLTEyMCc6IDB4YjIwZixcbiAgJ2JsYWtlMmItMTI4JzogMHhiMjEwLFxuICAnYmxha2UyYi0xMzYnOiAweGIyMTEsXG4gICdibGFrZTJiLTE0NCc6IDB4YjIxMixcbiAgJ2JsYWtlMmItMTUyJzogMHhiMjEzLFxuICAnYmxha2UyYi0xNjAnOiAweGIyMTQsXG4gICdibGFrZTJiLTE2OCc6IDB4YjIxNSxcbiAgJ2JsYWtlMmItMTc2JzogMHhiMjE2LFxuICAnYmxha2UyYi0xODQnOiAweGIyMTcsXG4gICdibGFrZTJiLTE5Mic6IDB4YjIxOCxcbiAgJ2JsYWtlMmItMjAwJzogMHhiMjE5LFxuICAnYmxha2UyYi0yMDgnOiAweGIyMWEsXG4gICdibGFrZTJiLTIxNic6IDB4YjIxYixcbiAgJ2JsYWtlMmItMjI0JzogMHhiMjFjLFxuICAnYmxha2UyYi0yMzInOiAweGIyMWQsXG4gICdibGFrZTJiLTI0MCc6IDB4YjIxZSxcbiAgJ2JsYWtlMmItMjQ4JzogMHhiMjFmLFxuICAnYmxha2UyYi0yNTYnOiAweGIyMjAsXG4gICdibGFrZTJiLTI2NCc6IDB4YjIyMSxcbiAgJ2JsYWtlMmItMjcyJzogMHhiMjIyLFxuICAnYmxha2UyYi0yODAnOiAweGIyMjMsXG4gICdibGFrZTJiLTI4OCc6IDB4YjIyNCxcbiAgJ2JsYWtlMmItMjk2JzogMHhiMjI1LFxuICAnYmxha2UyYi0zMDQnOiAweGIyMjYsXG4gICdibGFrZTJiLTMxMic6IDB4YjIyNyxcbiAgJ2JsYWtlMmItMzIwJzogMHhiMjI4LFxuICAnYmxha2UyYi0zMjgnOiAweGIyMjksXG4gICdibGFrZTJiLTMzNic6IDB4YjIyYSxcbiAgJ2JsYWtlMmItMzQ0JzogMHhiMjJiLFxuICAnYmxha2UyYi0zNTInOiAweGIyMmMsXG4gICdibGFrZTJiLTM2MCc6IDB4YjIyZCxcbiAgJ2JsYWtlMmItMzY4JzogMHhiMjJlLFxuICAnYmxha2UyYi0zNzYnOiAweGIyMmYsXG4gICdibGFrZTJiLTM4NCc6IDB4YjIzMCxcbiAgJ2JsYWtlMmItMzkyJzogMHhiMjMxLFxuICAnYmxha2UyYi00MDAnOiAweGIyMzIsXG4gICdibGFrZTJiLTQwOCc6IDB4YjIzMyxcbiAgJ2JsYWtlMmItNDE2JzogMHhiMjM0LFxuICAnYmxha2UyYi00MjQnOiAweGIyMzUsXG4gICdibGFrZTJiLTQzMic6IDB4YjIzNixcbiAgJ2JsYWtlMmItNDQwJzogMHhiMjM3LFxuICAnYmxha2UyYi00NDgnOiAweGIyMzgsXG4gICdibGFrZTJiLTQ1Nic6IDB4YjIzOSxcbiAgJ2JsYWtlMmItNDY0JzogMHhiMjNhLFxuICAnYmxha2UyYi00NzInOiAweGIyM2IsXG4gICdibGFrZTJiLTQ4MCc6IDB4YjIzYyxcbiAgJ2JsYWtlMmItNDg4JzogMHhiMjNkLFxuICAnYmxha2UyYi00OTYnOiAweGIyM2UsXG4gICdibGFrZTJiLTUwNCc6IDB4YjIzZixcbiAgJ2JsYWtlMmItNTEyJzogMHhiMjQwLFxuICAnYmxha2Uycy04JzogMHhiMjQxLFxuICAnYmxha2Uycy0xNic6IDB4YjI0MixcbiAgJ2JsYWtlMnMtMjQnOiAweGIyNDMsXG4gICdibGFrZTJzLTMyJzogMHhiMjQ0LFxuICAnYmxha2Uycy00MCc6IDB4YjI0NSxcbiAgJ2JsYWtlMnMtNDgnOiAweGIyNDYsXG4gICdibGFrZTJzLTU2JzogMHhiMjQ3LFxuICAnYmxha2Uycy02NCc6IDB4YjI0OCxcbiAgJ2JsYWtlMnMtNzInOiAweGIyNDksXG4gICdibGFrZTJzLTgwJzogMHhiMjRhLFxuICAnYmxha2Uycy04OCc6IDB4YjI0YixcbiAgJ2JsYWtlMnMtOTYnOiAweGIyNGMsXG4gICdibGFrZTJzLTEwNCc6IDB4YjI0ZCxcbiAgJ2JsYWtlMnMtMTEyJzogMHhiMjRlLFxuICAnYmxha2Uycy0xMjAnOiAweGIyNGYsXG4gICdibGFrZTJzLTEyOCc6IDB4YjI1MCxcbiAgJ2JsYWtlMnMtMTM2JzogMHhiMjUxLFxuICAnYmxha2Uycy0xNDQnOiAweGIyNTIsXG4gICdibGFrZTJzLTE1Mic6IDB4YjI1MyxcbiAgJ2JsYWtlMnMtMTYwJzogMHhiMjU0LFxuICAnYmxha2Uycy0xNjgnOiAweGIyNTUsXG4gICdibGFrZTJzLTE3Nic6IDB4YjI1NixcbiAgJ2JsYWtlMnMtMTg0JzogMHhiMjU3LFxuICAnYmxha2Uycy0xOTInOiAweGIyNTgsXG4gICdibGFrZTJzLTIwMCc6IDB4YjI1OSxcbiAgJ2JsYWtlMnMtMjA4JzogMHhiMjVhLFxuICAnYmxha2Uycy0yMTYnOiAweGIyNWIsXG4gICdibGFrZTJzLTIyNCc6IDB4YjI1YyxcbiAgJ2JsYWtlMnMtMjMyJzogMHhiMjVkLFxuICAnYmxha2Uycy0yNDAnOiAweGIyNWUsXG4gICdibGFrZTJzLTI0OCc6IDB4YjI1ZixcbiAgJ2JsYWtlMnMtMjU2JzogMHhiMjYwLFxuICAnc2tlaW4yNTYtOCc6IDB4YjMwMSxcbiAgJ3NrZWluMjU2LTE2JzogMHhiMzAyLFxuICAnc2tlaW4yNTYtMjQnOiAweGIzMDMsXG4gICdza2VpbjI1Ni0zMic6IDB4YjMwNCxcbiAgJ3NrZWluMjU2LTQwJzogMHhiMzA1LFxuICAnc2tlaW4yNTYtNDgnOiAweGIzMDYsXG4gICdza2VpbjI1Ni01Nic6IDB4YjMwNyxcbiAgJ3NrZWluMjU2LTY0JzogMHhiMzA4LFxuICAnc2tlaW4yNTYtNzInOiAweGIzMDksXG4gICdza2VpbjI1Ni04MCc6IDB4YjMwYSxcbiAgJ3NrZWluMjU2LTg4JzogMHhiMzBiLFxuICAnc2tlaW4yNTYtOTYnOiAweGIzMGMsXG4gICdza2VpbjI1Ni0xMDQnOiAweGIzMGQsXG4gICdza2VpbjI1Ni0xMTInOiAweGIzMGUsXG4gICdza2VpbjI1Ni0xMjAnOiAweGIzMGYsXG4gICdza2VpbjI1Ni0xMjgnOiAweGIzMTAsXG4gICdza2VpbjI1Ni0xMzYnOiAweGIzMTEsXG4gICdza2VpbjI1Ni0xNDQnOiAweGIzMTIsXG4gICdza2VpbjI1Ni0xNTInOiAweGIzMTMsXG4gICdza2VpbjI1Ni0xNjAnOiAweGIzMTQsXG4gICdza2VpbjI1Ni0xNjgnOiAweGIzMTUsXG4gICdza2VpbjI1Ni0xNzYnOiAweGIzMTYsXG4gICdza2VpbjI1Ni0xODQnOiAweGIzMTcsXG4gICdza2VpbjI1Ni0xOTInOiAweGIzMTgsXG4gICdza2VpbjI1Ni0yMDAnOiAweGIzMTksXG4gICdza2VpbjI1Ni0yMDgnOiAweGIzMWEsXG4gICdza2VpbjI1Ni0yMTYnOiAweGIzMWIsXG4gICdza2VpbjI1Ni0yMjQnOiAweGIzMWMsXG4gICdza2VpbjI1Ni0yMzInOiAweGIzMWQsXG4gICdza2VpbjI1Ni0yNDAnOiAweGIzMWUsXG4gICdza2VpbjI1Ni0yNDgnOiAweGIzMWYsXG4gICdza2VpbjI1Ni0yNTYnOiAweGIzMjAsXG4gICdza2VpbjUxMi04JzogMHhiMzIxLFxuICAnc2tlaW41MTItMTYnOiAweGIzMjIsXG4gICdza2VpbjUxMi0yNCc6IDB4YjMyMyxcbiAgJ3NrZWluNTEyLTMyJzogMHhiMzI0LFxuICAnc2tlaW41MTItNDAnOiAweGIzMjUsXG4gICdza2VpbjUxMi00OCc6IDB4YjMyNixcbiAgJ3NrZWluNTEyLTU2JzogMHhiMzI3LFxuICAnc2tlaW41MTItNjQnOiAweGIzMjgsXG4gICdza2VpbjUxMi03Mic6IDB4YjMyOSxcbiAgJ3NrZWluNTEyLTgwJzogMHhiMzJhLFxuICAnc2tlaW41MTItODgnOiAweGIzMmIsXG4gICdza2VpbjUxMi05Nic6IDB4YjMyYyxcbiAgJ3NrZWluNTEyLTEwNCc6IDB4YjMyZCxcbiAgJ3NrZWluNTEyLTExMic6IDB4YjMyZSxcbiAgJ3NrZWluNTEyLTEyMCc6IDB4YjMyZixcbiAgJ3NrZWluNTEyLTEyOCc6IDB4YjMzMCxcbiAgJ3NrZWluNTEyLTEzNic6IDB4YjMzMSxcbiAgJ3NrZWluNTEyLTE0NCc6IDB4YjMzMixcbiAgJ3NrZWluNTEyLTE1Mic6IDB4YjMzMyxcbiAgJ3NrZWluNTEyLTE2MCc6IDB4YjMzNCxcbiAgJ3NrZWluNTEyLTE2OCc6IDB4YjMzNSxcbiAgJ3NrZWluNTEyLTE3Nic6IDB4YjMzNixcbiAgJ3NrZWluNTEyLTE4NCc6IDB4YjMzNyxcbiAgJ3NrZWluNTEyLTE5Mic6IDB4YjMzOCxcbiAgJ3NrZWluNTEyLTIwMCc6IDB4YjMzOSxcbiAgJ3NrZWluNTEyLTIwOCc6IDB4YjMzYSxcbiAgJ3NrZWluNTEyLTIxNic6IDB4YjMzYixcbiAgJ3NrZWluNTEyLTIyNCc6IDB4YjMzYyxcbiAgJ3NrZWluNTEyLTIzMic6IDB4YjMzZCxcbiAgJ3NrZWluNTEyLTI0MCc6IDB4YjMzZSxcbiAgJ3NrZWluNTEyLTI0OCc6IDB4YjMzZixcbiAgJ3NrZWluNTEyLTI1Nic6IDB4YjM0MCxcbiAgJ3NrZWluNTEyLTI2NCc6IDB4YjM0MSxcbiAgJ3NrZWluNTEyLTI3Mic6IDB4YjM0MixcbiAgJ3NrZWluNTEyLTI4MCc6IDB4YjM0MyxcbiAgJ3NrZWluNTEyLTI4OCc6IDB4YjM0NCxcbiAgJ3NrZWluNTEyLTI5Nic6IDB4YjM0NSxcbiAgJ3NrZWluNTEyLTMwNCc6IDB4YjM0NixcbiAgJ3NrZWluNTEyLTMxMic6IDB4YjM0NyxcbiAgJ3NrZWluNTEyLTMyMCc6IDB4YjM0OCxcbiAgJ3NrZWluNTEyLTMyOCc6IDB4YjM0OSxcbiAgJ3NrZWluNTEyLTMzNic6IDB4YjM0YSxcbiAgJ3NrZWluNTEyLTM0NCc6IDB4YjM0YixcbiAgJ3NrZWluNTEyLTM1Mic6IDB4YjM0YyxcbiAgJ3NrZWluNTEyLTM2MCc6IDB4YjM0ZCxcbiAgJ3NrZWluNTEyLTM2OCc6IDB4YjM0ZSxcbiAgJ3NrZWluNTEyLTM3Nic6IDB4YjM0ZixcbiAgJ3NrZWluNTEyLTM4NCc6IDB4YjM1MCxcbiAgJ3NrZWluNTEyLTM5Mic6IDB4YjM1MSxcbiAgJ3NrZWluNTEyLTQwMCc6IDB4YjM1MixcbiAgJ3NrZWluNTEyLTQwOCc6IDB4YjM1MyxcbiAgJ3NrZWluNTEyLTQxNic6IDB4YjM1NCxcbiAgJ3NrZWluNTEyLTQyNCc6IDB4YjM1NSxcbiAgJ3NrZWluNTEyLTQzMic6IDB4YjM1NixcbiAgJ3NrZWluNTEyLTQ0MCc6IDB4YjM1NyxcbiAgJ3NrZWluNTEyLTQ0OCc6IDB4YjM1OCxcbiAgJ3NrZWluNTEyLTQ1Nic6IDB4YjM1OSxcbiAgJ3NrZWluNTEyLTQ2NCc6IDB4YjM1YSxcbiAgJ3NrZWluNTEyLTQ3Mic6IDB4YjM1YixcbiAgJ3NrZWluNTEyLTQ4MCc6IDB4YjM1YyxcbiAgJ3NrZWluNTEyLTQ4OCc6IDB4YjM1ZCxcbiAgJ3NrZWluNTEyLTQ5Nic6IDB4YjM1ZSxcbiAgJ3NrZWluNTEyLTUwNCc6IDB4YjM1ZixcbiAgJ3NrZWluNTEyLTUxMic6IDB4YjM2MCxcbiAgJ3NrZWluMTAyNC04JzogMHhiMzYxLFxuICAnc2tlaW4xMDI0LTE2JzogMHhiMzYyLFxuICAnc2tlaW4xMDI0LTI0JzogMHhiMzYzLFxuICAnc2tlaW4xMDI0LTMyJzogMHhiMzY0LFxuICAnc2tlaW4xMDI0LTQwJzogMHhiMzY1LFxuICAnc2tlaW4xMDI0LTQ4JzogMHhiMzY2LFxuICAnc2tlaW4xMDI0LTU2JzogMHhiMzY3LFxuICAnc2tlaW4xMDI0LTY0JzogMHhiMzY4LFxuICAnc2tlaW4xMDI0LTcyJzogMHhiMzY5LFxuICAnc2tlaW4xMDI0LTgwJzogMHhiMzZhLFxuICAnc2tlaW4xMDI0LTg4JzogMHhiMzZiLFxuICAnc2tlaW4xMDI0LTk2JzogMHhiMzZjLFxuICAnc2tlaW4xMDI0LTEwNCc6IDB4YjM2ZCxcbiAgJ3NrZWluMTAyNC0xMTInOiAweGIzNmUsXG4gICdza2VpbjEwMjQtMTIwJzogMHhiMzZmLFxuICAnc2tlaW4xMDI0LTEyOCc6IDB4YjM3MCxcbiAgJ3NrZWluMTAyNC0xMzYnOiAweGIzNzEsXG4gICdza2VpbjEwMjQtMTQ0JzogMHhiMzcyLFxuICAnc2tlaW4xMDI0LTE1Mic6IDB4YjM3MyxcbiAgJ3NrZWluMTAyNC0xNjAnOiAweGIzNzQsXG4gICdza2VpbjEwMjQtMTY4JzogMHhiMzc1LFxuICAnc2tlaW4xMDI0LTE3Nic6IDB4YjM3NixcbiAgJ3NrZWluMTAyNC0xODQnOiAweGIzNzcsXG4gICdza2VpbjEwMjQtMTkyJzogMHhiMzc4LFxuICAnc2tlaW4xMDI0LTIwMCc6IDB4YjM3OSxcbiAgJ3NrZWluMTAyNC0yMDgnOiAweGIzN2EsXG4gICdza2VpbjEwMjQtMjE2JzogMHhiMzdiLFxuICAnc2tlaW4xMDI0LTIyNCc6IDB4YjM3YyxcbiAgJ3NrZWluMTAyNC0yMzInOiAweGIzN2QsXG4gICdza2VpbjEwMjQtMjQwJzogMHhiMzdlLFxuICAnc2tlaW4xMDI0LTI0OCc6IDB4YjM3ZixcbiAgJ3NrZWluMTAyNC0yNTYnOiAweGIzODAsXG4gICdza2VpbjEwMjQtMjY0JzogMHhiMzgxLFxuICAnc2tlaW4xMDI0LTI3Mic6IDB4YjM4MixcbiAgJ3NrZWluMTAyNC0yODAnOiAweGIzODMsXG4gICdza2VpbjEwMjQtMjg4JzogMHhiMzg0LFxuICAnc2tlaW4xMDI0LTI5Nic6IDB4YjM4NSxcbiAgJ3NrZWluMTAyNC0zMDQnOiAweGIzODYsXG4gICdza2VpbjEwMjQtMzEyJzogMHhiMzg3LFxuICAnc2tlaW4xMDI0LTMyMCc6IDB4YjM4OCxcbiAgJ3NrZWluMTAyNC0zMjgnOiAweGIzODksXG4gICdza2VpbjEwMjQtMzM2JzogMHhiMzhhLFxuICAnc2tlaW4xMDI0LTM0NCc6IDB4YjM4YixcbiAgJ3NrZWluMTAyNC0zNTInOiAweGIzOGMsXG4gICdza2VpbjEwMjQtMzYwJzogMHhiMzhkLFxuICAnc2tlaW4xMDI0LTM2OCc6IDB4YjM4ZSxcbiAgJ3NrZWluMTAyNC0zNzYnOiAweGIzOGYsXG4gICdza2VpbjEwMjQtMzg0JzogMHhiMzkwLFxuICAnc2tlaW4xMDI0LTM5Mic6IDB4YjM5MSxcbiAgJ3NrZWluMTAyNC00MDAnOiAweGIzOTIsXG4gICdza2VpbjEwMjQtNDA4JzogMHhiMzkzLFxuICAnc2tlaW4xMDI0LTQxNic6IDB4YjM5NCxcbiAgJ3NrZWluMTAyNC00MjQnOiAweGIzOTUsXG4gICdza2VpbjEwMjQtNDMyJzogMHhiMzk2LFxuICAnc2tlaW4xMDI0LTQ0MCc6IDB4YjM5NyxcbiAgJ3NrZWluMTAyNC00NDgnOiAweGIzOTgsXG4gICdza2VpbjEwMjQtNDU2JzogMHhiMzk5LFxuICAnc2tlaW4xMDI0LTQ2NCc6IDB4YjM5YSxcbiAgJ3NrZWluMTAyNC00NzInOiAweGIzOWIsXG4gICdza2VpbjEwMjQtNDgwJzogMHhiMzljLFxuICAnc2tlaW4xMDI0LTQ4OCc6IDB4YjM5ZCxcbiAgJ3NrZWluMTAyNC00OTYnOiAweGIzOWUsXG4gICdza2VpbjEwMjQtNTA0JzogMHhiMzlmLFxuICAnc2tlaW4xMDI0LTUxMic6IDB4YjNhMCxcbiAgJ3NrZWluMTAyNC01MjAnOiAweGIzYTEsXG4gICdza2VpbjEwMjQtNTI4JzogMHhiM2EyLFxuICAnc2tlaW4xMDI0LTUzNic6IDB4YjNhMyxcbiAgJ3NrZWluMTAyNC01NDQnOiAweGIzYTQsXG4gICdza2VpbjEwMjQtNTUyJzogMHhiM2E1LFxuICAnc2tlaW4xMDI0LTU2MCc6IDB4YjNhNixcbiAgJ3NrZWluMTAyNC01NjgnOiAweGIzYTcsXG4gICdza2VpbjEwMjQtNTc2JzogMHhiM2E4LFxuICAnc2tlaW4xMDI0LTU4NCc6IDB4YjNhOSxcbiAgJ3NrZWluMTAyNC01OTInOiAweGIzYWEsXG4gICdza2VpbjEwMjQtNjAwJzogMHhiM2FiLFxuICAnc2tlaW4xMDI0LTYwOCc6IDB4YjNhYyxcbiAgJ3NrZWluMTAyNC02MTYnOiAweGIzYWQsXG4gICdza2VpbjEwMjQtNjI0JzogMHhiM2FlLFxuICAnc2tlaW4xMDI0LTYzMic6IDB4YjNhZixcbiAgJ3NrZWluMTAyNC02NDAnOiAweGIzYjAsXG4gICdza2VpbjEwMjQtNjQ4JzogMHhiM2IxLFxuICAnc2tlaW4xMDI0LTY1Nic6IDB4YjNiMixcbiAgJ3NrZWluMTAyNC02NjQnOiAweGIzYjMsXG4gICdza2VpbjEwMjQtNjcyJzogMHhiM2I0LFxuICAnc2tlaW4xMDI0LTY4MCc6IDB4YjNiNSxcbiAgJ3NrZWluMTAyNC02ODgnOiAweGIzYjYsXG4gICdza2VpbjEwMjQtNjk2JzogMHhiM2I3LFxuICAnc2tlaW4xMDI0LTcwNCc6IDB4YjNiOCxcbiAgJ3NrZWluMTAyNC03MTInOiAweGIzYjksXG4gICdza2VpbjEwMjQtNzIwJzogMHhiM2JhLFxuICAnc2tlaW4xMDI0LTcyOCc6IDB4YjNiYixcbiAgJ3NrZWluMTAyNC03MzYnOiAweGIzYmMsXG4gICdza2VpbjEwMjQtNzQ0JzogMHhiM2JkLFxuICAnc2tlaW4xMDI0LTc1Mic6IDB4YjNiZSxcbiAgJ3NrZWluMTAyNC03NjAnOiAweGIzYmYsXG4gICdza2VpbjEwMjQtNzY4JzogMHhiM2MwLFxuICAnc2tlaW4xMDI0LTc3Nic6IDB4YjNjMSxcbiAgJ3NrZWluMTAyNC03ODQnOiAweGIzYzIsXG4gICdza2VpbjEwMjQtNzkyJzogMHhiM2MzLFxuICAnc2tlaW4xMDI0LTgwMCc6IDB4YjNjNCxcbiAgJ3NrZWluMTAyNC04MDgnOiAweGIzYzUsXG4gICdza2VpbjEwMjQtODE2JzogMHhiM2M2LFxuICAnc2tlaW4xMDI0LTgyNCc6IDB4YjNjNyxcbiAgJ3NrZWluMTAyNC04MzInOiAweGIzYzgsXG4gICdza2VpbjEwMjQtODQwJzogMHhiM2M5LFxuICAnc2tlaW4xMDI0LTg0OCc6IDB4YjNjYSxcbiAgJ3NrZWluMTAyNC04NTYnOiAweGIzY2IsXG4gICdza2VpbjEwMjQtODY0JzogMHhiM2NjLFxuICAnc2tlaW4xMDI0LTg3Mic6IDB4YjNjZCxcbiAgJ3NrZWluMTAyNC04ODAnOiAweGIzY2UsXG4gICdza2VpbjEwMjQtODg4JzogMHhiM2NmLFxuICAnc2tlaW4xMDI0LTg5Nic6IDB4YjNkMCxcbiAgJ3NrZWluMTAyNC05MDQnOiAweGIzZDEsXG4gICdza2VpbjEwMjQtOTEyJzogMHhiM2QyLFxuICAnc2tlaW4xMDI0LTkyMCc6IDB4YjNkMyxcbiAgJ3NrZWluMTAyNC05MjgnOiAweGIzZDQsXG4gICdza2VpbjEwMjQtOTM2JzogMHhiM2Q1LFxuICAnc2tlaW4xMDI0LTk0NCc6IDB4YjNkNixcbiAgJ3NrZWluMTAyNC05NTInOiAweGIzZDcsXG4gICdza2VpbjEwMjQtOTYwJzogMHhiM2Q4LFxuICAnc2tlaW4xMDI0LTk2OCc6IDB4YjNkOSxcbiAgJ3NrZWluMTAyNC05NzYnOiAweGIzZGEsXG4gICdza2VpbjEwMjQtOTg0JzogMHhiM2RiLFxuICAnc2tlaW4xMDI0LTk5Mic6IDB4YjNkYyxcbiAgJ3NrZWluMTAyNC0xMDAwJzogMHhiM2RkLFxuICAnc2tlaW4xMDI0LTEwMDgnOiAweGIzZGUsXG4gICdza2VpbjEwMjQtMTAxNic6IDB4YjNkZixcbiAgJ3NrZWluMTAyNC0xMDI0JzogMHhiM2UwLFxuICAncG9zZWlkb24tYmxzMTJfMzgxLWEyLWZjMSc6IDB4YjQwMSxcbiAgJ3Bvc2VpZG9uLWJsczEyXzM4MS1hMi1mYzEtc2MnOiAweGI0MDJcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0geyBuYW1lcyB9XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBlbmNvZGluZzogZ2V0Q29kZWMgfSA9IHJlcXVpcmUoJ211bHRpYmFzZScpXG5jb25zdCB1dGY4RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG5cbi8qKlxuICogQHR5cGVkZWYge19faW1wb3J0X18oJ211bHRpYmFzZS9zcmMvdHlwZXMnKS5CYXNlTmFtZSB8ICd1dGY4JyB8ICd1dGYtOCcgfCAnYXNjaWknIHwgdW5kZWZpbmVkfSBTdXBwb3J0ZWRFbmNvZGluZ3NcbiAqL1xuXG4vKipcbiAqIEludGVycHJldHMgZWFjaCBjaGFyYWN0ZXIgaW4gYSBzdHJpbmcgYXMgYSBieXRlIGFuZFxuICogcmV0dXJucyBhIFVpbnQ4QXJyYXkgb2YgdGhvc2UgYnl0ZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gdHVybiBpbnRvIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGFzY2lpU3RyaW5nVG9VaW50OEFycmF5IChzdHJpbmcpIHtcbiAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShzdHJpbmcubGVuZ3RoKVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXlbaV0gPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuICB9XG5cbiAgcmV0dXJuIGFycmF5XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFVpbnQ4QXJyYXlgIGZyb20gdGhlIHBhc3NlZCBzdHJpbmdcbiAqXG4gKiBTdXBwb3J0cyBgdXRmOGAsIGB1dGYtOGAgYW5kIGFueSBlbmNvZGluZyBzdXBwb3J0ZWQgYnkgdGhlIG11bHRpYmFzZSBtb2R1bGUuXG4gKlxuICogQWxzbyBgYXNjaWlgIHdoaWNoIGlzIHNpbWlsYXIgdG8gbm9kZSdzICdiaW5hcnknIGVuY29kaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7U3VwcG9ydGVkRW5jb2RpbmdzfSBbZW5jb2Rpbmc9dXRmOF0gLSB1dGY4LCBiYXNlMTYsIGJhc2U2NCwgYmFzZTY0dXJscGFkLCBldGNcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nID0gJ3V0ZjgnKSB7XG4gIGlmIChlbmNvZGluZyA9PT0gJ3V0ZjgnIHx8IGVuY29kaW5nID09PSAndXRmLTgnKSB7XG4gICAgcmV0dXJuIHV0ZjhFbmNvZGVyLmVuY29kZShzdHJpbmcpXG4gIH1cblxuICBpZiAoZW5jb2RpbmcgPT09ICdhc2NpaScpIHtcbiAgICByZXR1cm4gYXNjaWlTdHJpbmdUb1VpbnQ4QXJyYXkoc3RyaW5nKVxuICB9XG5cbiAgcmV0dXJuIGdldENvZGVjKGVuY29kaW5nKS5kZWNvZGUoc3RyaW5nKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZyb21TdHJpbmdcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG4vKipcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fEFycmF5QnVmZmVyfSBieXRlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuY29uc3QgZGVjb2RlVGV4dCA9IChieXRlcykgPT4gdGV4dERlY29kZXIuZGVjb2RlKGJ5dGVzKVxuXG5jb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZW5jb2RlVGV4dCA9ICh0ZXh0KSA9PiB0ZXh0RW5jb2Rlci5lbmNvZGUodGV4dClcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IFVpbnQ4QXJyYXkgY3JlYXRlZCBieSBjb25jYXRlbmF0aW5nIHRoZSBwYXNzZWQgQXJyYXlzXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheUxpa2U8bnVtYmVyPj59IGFycnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBjb25jYXQgKGFycnMsIGxlbmd0aCkge1xuICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGxldCBvZmZzZXQgPSAwXG5cbiAgZm9yIChjb25zdCBhcnIgb2YgYXJycykge1xuICAgIG91dHB1dC5zZXQoYXJyLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IGFyci5sZW5ndGhcbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IGRlY29kZVRleHQsIGVuY29kZVRleHQsIGNvbmNhdCB9XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgYmFzZVggPSByZXF1aXJlKCdAbXVsdGlmb3JtYXRzL2Jhc2UteCcpXG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi9iYXNlLmpzJylcbmNvbnN0IHsgcmZjNDY0OCB9ID0gcmVxdWlyZSgnLi9yZmM0NjQ4JylcbmNvbnN0IHsgZGVjb2RlVGV4dCwgZW5jb2RlVGV4dCB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL3R5cGVzJykuQ29kZWNGYWN0b3J5fSBDb2RlY0ZhY3RvcnkgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi90eXBlcycpLkNvZGVjfSBDb2RlYyAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL3R5cGVzJykuQmFzZU5hbWV9IEJhc2VOYW1lICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vdHlwZXMnKS5CYXNlQ29kZX0gQmFzZUNvZGUgKi9cblxuLyoqIEB0eXBlIHtDb2RlY0ZhY3Rvcnl9ICovXG5jb25zdCBpZGVudGl0eSA9ICgpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGRlY29kZVRleHQsXG4gICAgZGVjb2RlOiBlbmNvZGVUZXh0XG4gIH1cbn1cblxuLyoqXG4gKlxuICogbmFtZSwgY29kZSwgaW1wbGVtZW50YXRpb24sIGFscGhhYmV0XG4gKlxuICogQHR5cGUge0FycmF5PFtCYXNlTmFtZSwgQmFzZUNvZGUsIENvZGVjRmFjdG9yeSwgc3RyaW5nXT59XG4gKi9cbmNvbnN0IGNvbnN0YW50cyA9IFtcbiAgWydpZGVudGl0eScsICdcXHgwMCcsIGlkZW50aXR5LCAnJ10sXG4gIFsnYmFzZTInLCAnMCcsIHJmYzQ2NDgoMSksICcwMSddLFxuICBbJ2Jhc2U4JywgJzcnLCByZmM0NjQ4KDMpLCAnMDEyMzQ1NjcnXSxcbiAgWydiYXNlMTAnLCAnOScsIGJhc2VYLCAnMDEyMzQ1Njc4OSddLFxuICBbJ2Jhc2UxNicsICdmJywgcmZjNDY0OCg0KSwgJzAxMjM0NTY3ODlhYmNkZWYnXSxcbiAgWydiYXNlMTZ1cHBlcicsICdGJywgcmZjNDY0OCg0KSwgJzAxMjM0NTY3ODlBQkNERUYnXSxcbiAgWydiYXNlMzJoZXgnLCAndicsIHJmYzQ2NDgoNSksICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1diddLFxuICBbJ2Jhc2UzMmhleHVwcGVyJywgJ1YnLCByZmM0NjQ4KDUpLCAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnXSxcbiAgWydiYXNlMzJoZXhwYWQnLCAndCcsIHJmYzQ2NDgoNSksICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dj0nXSxcbiAgWydiYXNlMzJoZXhwYWR1cHBlcicsICdUJywgcmZjNDY0OCg1KSwgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWPSddLFxuICBbJ2Jhc2UzMicsICdiJywgcmZjNDY0OCg1KSwgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3J10sXG4gIFsnYmFzZTMydXBwZXInLCAnQicsIHJmYzQ2NDgoNSksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NyddLFxuICBbJ2Jhc2UzMnBhZCcsICdjJywgcmZjNDY0OCg1KSwgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3PSddLFxuICBbJ2Jhc2UzMnBhZHVwcGVyJywgJ0MnLCByZmM0NjQ4KDUpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1Njc9J10sXG4gIFsnYmFzZTMyeicsICdoJywgcmZjNDY0OCg1KSwgJ3libmRyZmc4ZWprbWNwcXhvdDF1d2lzemEzNDVoNzY5J10sXG4gIFsnYmFzZTM2JywgJ2snLCBiYXNlWCwgJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eiddLFxuICBbJ2Jhc2UzNnVwcGVyJywgJ0snLCBiYXNlWCwgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiddLFxuICBbJ2Jhc2U1OGJ0YycsICd6JywgYmFzZVgsICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6J10sXG4gIFsnYmFzZTU4ZmxpY2tyJywgJ1onLCBiYXNlWCwgJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonXSxcbiAgWydiYXNlNjQnLCAnbScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ10sXG4gIFsnYmFzZTY0cGFkJywgJ00nLCByZmM0NjQ4KDYpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nXSxcbiAgWydiYXNlNjR1cmwnLCAndScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJ10sXG4gIFsnYmFzZTY0dXJscGFkJywgJ1UnLCByZmM0NjQ4KDYpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXz0nXVxuXVxuXG4vKiogQHR5cGUge1JlY29yZDxCYXNlTmFtZSxCYXNlPn0gKi9cbmNvbnN0IG5hbWVzID0gY29uc3RhbnRzLnJlZHVjZSgocHJldiwgdHVwcGxlKSA9PiB7XG4gIHByZXZbdHVwcGxlWzBdXSA9IG5ldyBCYXNlKHR1cHBsZVswXSwgdHVwcGxlWzFdLCB0dXBwbGVbMl0sIHR1cHBsZVszXSlcbiAgcmV0dXJuIHByZXZcbn0sIC8qKiBAdHlwZSB7UmVjb3JkPEJhc2VOYW1lLEJhc2U+fSAqLyh7fSkpXG5cbi8qKiBAdHlwZSB7UmVjb3JkPEJhc2VDb2RlLEJhc2U+fSAqL1xuY29uc3QgY29kZXMgPSBjb25zdGFudHMucmVkdWNlKChwcmV2LCB0dXBwbGUpID0+IHtcbiAgcHJldlt0dXBwbGVbMV1dID0gbmFtZXNbdHVwcGxlWzBdXVxuICByZXR1cm4gcHJldlxufSwgLyoqIEB0eXBlIHtSZWNvcmQ8QmFzZUNvZGUsQmFzZT59ICovKHt9KSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWVzLFxuICBjb2Rlc1xufVxuIiwiLy8gQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2Jhc2UnKS5Db2RlY0ZhY3Rvcnl9IENvZGVjRmFjdG9yeSAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldFxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHNQZXJDaGFyXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZGVjb2RlID0gKHN0cmluZywgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKSA9PiB7XG4gIC8vIEJ1aWxkIHRoZSBjaGFyYWN0ZXIgbG9va3VwIHRhYmxlOlxuICBjb25zdCBjb2RlcyA9IHt9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYWxwaGFiZXQubGVuZ3RoOyArK2kpIHtcbiAgICBjb2Rlc1thbHBoYWJldFtpXV0gPSBpXG4gIH1cblxuICAvLyBDb3VudCB0aGUgcGFkZGluZyBieXRlczpcbiAgbGV0IGVuZCA9IHN0cmluZy5sZW5ndGhcbiAgd2hpbGUgKHN0cmluZ1tlbmQgLSAxXSA9PT0gJz0nKSB7XG4gICAgLS1lbmRcbiAgfVxuXG4gIC8vIEFsbG9jYXRlIHRoZSBvdXRwdXQ6XG4gIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KChlbmQgKiBiaXRzUGVyQ2hhciAvIDgpIHwgMClcblxuICAvLyBQYXJzZSB0aGUgZGF0YTpcbiAgbGV0IGJpdHMgPSAwIC8vIE51bWJlciBvZiBiaXRzIGN1cnJlbnRseSBpbiB0aGUgYnVmZmVyXG4gIGxldCBidWZmZXIgPSAwIC8vIEJpdHMgd2FpdGluZyB0byBiZSB3cml0dGVuIG91dCwgTVNCIGZpcnN0XG4gIGxldCB3cml0dGVuID0gMCAvLyBOZXh0IGJ5dGUgdG8gd3JpdGVcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmQ7ICsraSkge1xuICAgIC8vIFJlYWQgb25lIGNoYXJhY3RlciBmcm9tIHRoZSBzdHJpbmc6XG4gICAgY29uc3QgdmFsdWUgPSBjb2Rlc1tzdHJpbmdbaV1dXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgJyArIHN0cmluZ1tpXSlcbiAgICB9XG5cbiAgICAvLyBBcHBlbmQgdGhlIGJpdHMgdG8gdGhlIGJ1ZmZlcjpcbiAgICBidWZmZXIgPSAoYnVmZmVyIDw8IGJpdHNQZXJDaGFyKSB8IHZhbHVlXG4gICAgYml0cyArPSBiaXRzUGVyQ2hhclxuXG4gICAgLy8gV3JpdGUgb3V0IHNvbWUgYml0cyBpZiB0aGUgYnVmZmVyIGhhcyBhIGJ5dGUncyB3b3J0aDpcbiAgICBpZiAoYml0cyA+PSA4KSB7XG4gICAgICBiaXRzIC09IDhcbiAgICAgIG91dFt3cml0dGVuKytdID0gMHhmZiAmIChidWZmZXIgPj4gYml0cylcbiAgICB9XG4gIH1cblxuICAvLyBWZXJpZnkgdGhhdCB3ZSBoYXZlIHJlY2VpdmVkIGp1c3QgZW5vdWdoIGJpdHM6XG4gIGlmIChiaXRzID49IGJpdHNQZXJDaGFyIHx8IDB4ZmYgJiAoYnVmZmVyIDw8ICg4IC0gYml0cykpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBkYXRhJylcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldFxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHNQZXJDaGFyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBlbmNvZGUgPSAoZGF0YSwgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKSA9PiB7XG4gIGNvbnN0IHBhZCA9IGFscGhhYmV0W2FscGhhYmV0Lmxlbmd0aCAtIDFdID09PSAnPSdcbiAgY29uc3QgbWFzayA9ICgxIDw8IGJpdHNQZXJDaGFyKSAtIDFcbiAgbGV0IG91dCA9ICcnXG5cbiAgbGV0IGJpdHMgPSAwIC8vIE51bWJlciBvZiBiaXRzIGN1cnJlbnRseSBpbiB0aGUgYnVmZmVyXG4gIGxldCBidWZmZXIgPSAwIC8vIEJpdHMgd2FpdGluZyB0byBiZSB3cml0dGVuIG91dCwgTVNCIGZpcnN0XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIC8vIFNsdXJwIGRhdGEgaW50byB0aGUgYnVmZmVyOlxuICAgIGJ1ZmZlciA9IChidWZmZXIgPDwgOCkgfCBkYXRhW2ldXG4gICAgYml0cyArPSA4XG5cbiAgICAvLyBXcml0ZSBvdXQgYXMgbXVjaCBhcyB3ZSBjYW46XG4gICAgd2hpbGUgKGJpdHMgPiBiaXRzUGVyQ2hhcikge1xuICAgICAgYml0cyAtPSBiaXRzUGVyQ2hhclxuICAgICAgb3V0ICs9IGFscGhhYmV0W21hc2sgJiAoYnVmZmVyID4+IGJpdHMpXVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnRpYWwgY2hhcmFjdGVyOlxuICBpZiAoYml0cykge1xuICAgIG91dCArPSBhbHBoYWJldFttYXNrICYgKGJ1ZmZlciA8PCAoYml0c1BlckNoYXIgLSBiaXRzKSldXG4gIH1cblxuICAvLyBBZGQgcGFkZGluZyBjaGFyYWN0ZXJzIHVudGlsIHdlIGhpdCBhIGJ5dGUgYm91bmRhcnk6XG4gIGlmIChwYWQpIHtcbiAgICB3aGlsZSAoKG91dC5sZW5ndGggKiBiaXRzUGVyQ2hhcikgJiA3KSB7XG4gICAgICBvdXQgKz0gJz0nXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzUGVyQ2hhclxuICogQHJldHVybnMge0NvZGVjRmFjdG9yeX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAoYml0c1BlckNoYXIpID0+IChhbHBoYWJldCkgPT4ge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGVuY29kZSAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBlbmNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcilcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGRlY29kZSAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBkZWNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcilcbiAgICB9XG4gIH1cbn1cbiIsIi8vIEB0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb2RlY1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihVaW50OEFycmF5KTpzdHJpbmd9IGVuY29kZVxuICogQHByb3BlcnR5IHtmdW5jdGlvbihzdHJpbmcpOlVpbnQ4QXJyYXl9IGRlY29kZVxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihzdHJpbmcpOkNvZGVjfSBDb2RlY0ZhY3RvcnlcbiAqL1xuXG5jbGFzcyBCYXNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gICAqIEBwYXJhbSB7Q29kZWNGYWN0b3J5fSBpbXBsZW1lbnRhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWxwaGFiZXRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChuYW1lLCBjb2RlLCBpbXBsZW1lbnRhdGlvbiwgYWxwaGFiZXQpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy5jb2RlID0gY29kZVxuICAgIHRoaXMuY29kZUJ1ZiA9IEJ1ZmZlci5mcm9tKHRoaXMuY29kZSlcbiAgICB0aGlzLmFscGhhYmV0ID0gYWxwaGFiZXRcbiAgICB0aGlzLmVuZ2luZSA9IGltcGxlbWVudGF0aW9uKGFscGhhYmV0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBlbmNvZGUgKGJ1Zikge1xuICAgIHJldHVybiB0aGlzLmVuZ2luZS5lbmNvZGUoYnVmKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAqL1xuICBkZWNvZGUgKHN0cmluZykge1xuICAgIGZvciAoY29uc3QgY2hhciBvZiBzdHJpbmcpIHtcbiAgICAgIGlmICh0aGlzLmFscGhhYmV0ICYmIHRoaXMuYWxwaGFiZXQuaW5kZXhPZihjaGFyKSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGNoYXJhY3RlciAnJHtjaGFyfScgaW4gJyR7c3RyaW5nfSdgKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbmdpbmUuZGVjb2RlKHN0cmluZylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXNlWCA9IHJlcXVpcmUoJ0BtdWx0aWZvcm1hdHMvYmFzZS14JylcbmNvbnN0IEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UuanMnKVxuY29uc3QgeyByZmM0NjQ4IH0gPSByZXF1aXJlKCcuL3JmYzQ2NDgnKVxuY29uc3QgeyBkZWNvZGVUZXh0LCBlbmNvZGVUZXh0IH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vdHlwZXMnKS5Db2RlY0ZhY3Rvcnl9IENvZGVjRmFjdG9yeSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL3R5cGVzJykuQ29kZWN9IENvZGVjICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vdHlwZXMnKS5CYXNlTmFtZX0gQmFzZU5hbWUgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi90eXBlcycpLkJhc2VDb2RlfSBCYXNlQ29kZSAqL1xuXG4vKiogQHR5cGUge0NvZGVjRmFjdG9yeX0gKi9cbmNvbnN0IGlkZW50aXR5ID0gKCkgPT4ge1xuICByZXR1cm4ge1xuICAgIGVuY29kZTogZGVjb2RlVGV4dCxcbiAgICBkZWNvZGU6IGVuY29kZVRleHRcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBuYW1lLCBjb2RlLCBpbXBsZW1lbnRhdGlvbiwgYWxwaGFiZXRcbiAqXG4gKiBAdHlwZSB7QXJyYXk8W0Jhc2VOYW1lLCBCYXNlQ29kZSwgQ29kZWNGYWN0b3J5LCBzdHJpbmddPn1cbiAqL1xuY29uc3QgY29uc3RhbnRzID0gW1xuICBbJ2lkZW50aXR5JywgJ1xceDAwJywgaWRlbnRpdHksICcnXSxcbiAgWydiYXNlMicsICcwJywgcmZjNDY0OCgxKSwgJzAxJ10sXG4gIFsnYmFzZTgnLCAnNycsIHJmYzQ2NDgoMyksICcwMTIzNDU2NyddLFxuICBbJ2Jhc2UxMCcsICc5JywgYmFzZVgsICcwMTIzNDU2Nzg5J10sXG4gIFsnYmFzZTE2JywgJ2YnLCByZmM0NjQ4KDQpLCAnMDEyMzQ1Njc4OWFiY2RlZiddLFxuICBbJ2Jhc2UxNnVwcGVyJywgJ0YnLCByZmM0NjQ4KDQpLCAnMDEyMzQ1Njc4OUFCQ0RFRiddLFxuICBbJ2Jhc2UzMmhleCcsICd2JywgcmZjNDY0OCg1KSwgJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2J10sXG4gIFsnYmFzZTMyaGV4dXBwZXInLCAnVicsIHJmYzQ2NDgoNSksICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVViddLFxuICBbJ2Jhc2UzMmhleHBhZCcsICd0JywgcmZjNDY0OCg1KSwgJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2PSddLFxuICBbJ2Jhc2UzMmhleHBhZHVwcGVyJywgJ1QnLCByZmM0NjQ4KDUpLCAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVY9J10sXG4gIFsnYmFzZTMyJywgJ2InLCByZmM0NjQ4KDUpLCAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjcnXSxcbiAgWydiYXNlMzJ1cHBlcicsICdCJywgcmZjNDY0OCg1KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3J10sXG4gIFsnYmFzZTMycGFkJywgJ2MnLCByZmM0NjQ4KDUpLCAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1Njc9J10sXG4gIFsnYmFzZTMycGFkdXBwZXInLCAnQycsIHJmYzQ2NDgoNSksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2Nz0nXSxcbiAgWydiYXNlMzJ6JywgJ2gnLCByZmM0NjQ4KDUpLCAneWJuZHJmZzhlamttY3BxeG90MXV3aXN6YTM0NWg3NjknXSxcbiAgWydiYXNlMzYnLCAnaycsIGJhc2VYLCAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6J10sXG4gIFsnYmFzZTM2dXBwZXInLCAnSycsIGJhc2VYLCAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJ10sXG4gIFsnYmFzZTU4YnRjJywgJ3onLCBiYXNlWCwgJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXSxcbiAgWydiYXNlNThmbGlja3InLCAnWicsIGJhc2VYLCAnMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWiddLFxuICBbJ2Jhc2U2NCcsICdtJywgcmZjNDY0OCg2KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXSxcbiAgWydiYXNlNjRwYWQnLCAnTScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSddLFxuICBbJ2Jhc2U2NHVybCcsICd1JywgcmZjNDY0OCg2KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nXSxcbiAgWydiYXNlNjR1cmxwYWQnLCAnVScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fPSddXG5dXG5cbi8qKiBAdHlwZSB7UmVjb3JkPEJhc2VOYW1lLEJhc2U+fSAqL1xuY29uc3QgbmFtZXMgPSBjb25zdGFudHMucmVkdWNlKChwcmV2LCB0dXBwbGUpID0+IHtcbiAgcHJldlt0dXBwbGVbMF1dID0gbmV3IEJhc2UodHVwcGxlWzBdLCB0dXBwbGVbMV0sIHR1cHBsZVsyXSwgdHVwcGxlWzNdKVxuICByZXR1cm4gcHJldlxufSwgLyoqIEB0eXBlIHtSZWNvcmQ8QmFzZU5hbWUsQmFzZT59ICovKHt9KSlcblxuLyoqIEB0eXBlIHtSZWNvcmQ8QmFzZUNvZGUsQmFzZT59ICovXG5jb25zdCBjb2RlcyA9IGNvbnN0YW50cy5yZWR1Y2UoKHByZXYsIHR1cHBsZSkgPT4ge1xuICBwcmV2W3R1cHBsZVsxXV0gPSBuYW1lc1t0dXBwbGVbMF1dXG4gIHJldHVybiBwcmV2XG59LCAvKiogQHR5cGUge1JlY29yZDxCYXNlQ29kZSxCYXNlPn0gKi8oe30pKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZXMsXG4gIGNvZGVzXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdmFyIGhhc2htYXJrSW5kZXggPSB1cmwuaW5kZXhPZignIycpO1xuICAgIGlmIChoYXNobWFya0luZGV4ICE9PSAtMSkge1xuICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIGhhc2htYXJrSW5kZXgpO1xuICAgIH1cblxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCwgb3B0aW9ucykge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZCxcbiAgICBzeW5jaHJvbm91czogb3B0aW9ucyA/IG9wdGlvbnMuc3luY2hyb25vdXMgOiBmYWxzZSxcbiAgICBydW5XaGVuOiBvcHRpb25zID8gb3B0aW9ucy5ydW5XaGVuIDogbnVsbFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBrZyA9IHJlcXVpcmUoJy4vLi4vLi4vcGFja2FnZS5qc29uJyk7XG5cbnZhciB2YWxpZGF0b3JzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5bJ29iamVjdCcsICdib29sZWFuJywgJ251bWJlcicsICdmdW5jdGlvbicsICdzdHJpbmcnLCAnc3ltYm9sJ10uZm9yRWFjaChmdW5jdGlvbih0eXBlLCBpKSB7XG4gIHZhbGlkYXRvcnNbdHlwZV0gPSBmdW5jdGlvbiB2YWxpZGF0b3IodGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSB0eXBlIHx8ICdhJyArIChpIDwgMSA/ICduICcgOiAnICcpICsgdHlwZTtcbiAgfTtcbn0pO1xuXG52YXIgZGVwcmVjYXRlZFdhcm5pbmdzID0ge307XG52YXIgY3VycmVudFZlckFyciA9IHBrZy52ZXJzaW9uLnNwbGl0KCcuJyk7XG5cbi8qKlxuICogQ29tcGFyZSBwYWNrYWdlIHZlcnNpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmc/fSB0aGFuVmVyc2lvblxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzT2xkZXJWZXJzaW9uKHZlcnNpb24sIHRoYW5WZXJzaW9uKSB7XG4gIHZhciBwa2dWZXJzaW9uQXJyID0gdGhhblZlcnNpb24gPyB0aGFuVmVyc2lvbi5zcGxpdCgnLicpIDogY3VycmVudFZlckFycjtcbiAgdmFyIGRlc3RWZXIgPSB2ZXJzaW9uLnNwbGl0KCcuJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgaWYgKHBrZ1ZlcnNpb25BcnJbaV0gPiBkZXN0VmVyW2ldKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHBrZ1ZlcnNpb25BcnJbaV0gPCBkZXN0VmVyW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBUcmFuc2l0aW9uYWwgb3B0aW9uIHZhbGlkYXRvclxuICogQHBhcmFtIHtmdW5jdGlvbnxib29sZWFuP30gdmFsaWRhdG9yXG4gKiBAcGFyYW0ge3N0cmluZz99IHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cbnZhbGlkYXRvcnMudHJhbnNpdGlvbmFsID0gZnVuY3Rpb24gdHJhbnNpdGlvbmFsKHZhbGlkYXRvciwgdmVyc2lvbiwgbWVzc2FnZSkge1xuICB2YXIgaXNEZXByZWNhdGVkID0gdmVyc2lvbiAmJiBpc09sZGVyVmVyc2lvbih2ZXJzaW9uKTtcblxuICBmdW5jdGlvbiBmb3JtYXRNZXNzYWdlKG9wdCwgZGVzYykge1xuICAgIHJldHVybiAnW0F4aW9zIHYnICsgcGtnLnZlcnNpb24gKyAnXSBUcmFuc2l0aW9uYWwgb3B0aW9uIFxcJycgKyBvcHQgKyAnXFwnJyArIGRlc2MgKyAobWVzc2FnZSA/ICcuICcgKyBtZXNzYWdlIDogJycpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvcHQsIG9wdHMpIHtcbiAgICBpZiAodmFsaWRhdG9yID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdE1lc3NhZ2Uob3B0LCAnIGhhcyBiZWVuIHJlbW92ZWQgaW4gJyArIHZlcnNpb24pKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZXByZWNhdGVkICYmICFkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSkge1xuICAgICAgZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0gPSB0cnVlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBvcHQsXG4gICAgICAgICAgJyBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYnICsgdmVyc2lvbiArICcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmVhciBmdXR1cmUnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvciA/IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRzKSA6IHRydWU7XG4gIH07XG59O1xuXG4vKipcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gc2NoZW1hXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBhbGxvd1Vua25vd25cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICB2YXIgb3B0ID0ga2V5c1tpXTtcbiAgICB2YXIgdmFsaWRhdG9yID0gc2NoZW1hW29wdF07XG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgdmFyIHZhbHVlID0gb3B0aW9uc1tvcHRdO1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsaWRhdG9yKHZhbHVlLCBvcHQsIG9wdGlvbnMpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gJyArIG9wdCArICcgbXVzdCBiZSAnICsgcmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dVbmtub3duICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc09sZGVyVmVyc2lvbjogaXNPbGRlclZlcnNpb24sXG4gIGFzc2VydE9wdGlvbnM6IGFzc2VydE9wdGlvbnMsXG4gIHZhbGlkYXRvcnM6IHZhbGlkYXRvcnNcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgIGNvbmZpZyxcbiAgICBjb25maWcuZGF0YSxcbiAgICBjb25maWcuaGVhZGVycyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXSB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1xuICApO1xuXG4gIHV0aWxzLmZvckVhY2goXG4gICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgICBkZWxldGUgY29uZmlnLmhlYWRlcnNbbWV0aG9kXTtcbiAgICB9XG4gICk7XG5cbiAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgY29uZmlnLFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIGJ1aWxkRnVsbFBhdGggPSByZXF1aXJlKCcuLi9jb3JlL2J1aWxkRnVsbFBhdGgnKTtcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzJyk7XG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbicpO1xudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi4vY29yZS9jcmVhdGVFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhockFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG4gICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gY29uZmlnLmhlYWRlcnM7XG4gICAgdmFyIHJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkpIHtcbiAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ107IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCA/IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChjb25maWcuYXV0aC5wYXNzd29yZCkpIDogJyc7XG4gICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xuICAgIH1cblxuICAgIHZhciBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIGZ1bmN0aW9uIG9ubG9hZGVuZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFyZXNwb25zZVR5cGUgfHwgcmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgIHJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nID9cbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoJ29ubG9hZGVuZCcgaW4gcmVxdWVzdCkge1xuICAgICAgLy8gVXNlIG9ubG9hZGVuZCBpZiBhdmFpbGFibGVcbiAgICAgIHJlcXVlc3Qub25sb2FkZW5kID0gb25sb2FkZW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlIHRvIGVtdWxhdGUgb25sb2FkZW5kXG4gICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVhZHlzdGF0ZSBoYW5kbGVyIGlzIGNhbGxpbmcgYmVmb3JlIG9uZXJyb3Igb3Igb250aW1lb3V0IGhhbmRsZXJzLFxuICAgICAgICAvLyBzbyB3ZSBzaG91bGQgY2FsbCBvbmxvYWRlbmQgb24gdGhlIG5leHQgJ3RpY2snXG4gICAgICAgIHNldFRpbWVvdXQob25sb2FkZW5kKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHZhciB0aW1lb3V0RXJyb3JNZXNzYWdlID0gJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJztcbiAgICAgIGlmIChjb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlID0gY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgY29uZmlnLnRyYW5zaXRpb25hbCAmJiBjb25maWcudHJhbnNpdGlvbmFsLmNsYXJpZnlUaW1lb3V0RXJyb3IgPyAnRVRJTUVET1VUJyA6ICdFQ09OTkFCT1JURUQnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oZnVsbFBhdGgpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKHJlc3BvbnNlVHlwZSAmJiByZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghcmVxdWVzdERhdGEpIHtcbiAgICAgIHJlcXVlc3REYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlnLCBlcnJvciBjb2RlLCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIGVycm9yLmNvbmZpZyA9IGNvbmZpZztcbiAgaWYgKGNvZGUpIHtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgfVxuXG4gIGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0O1xuICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICBlcnJvci5pc0F4aW9zRXJyb3IgPSB0cnVlO1xuXG4gIGVycm9yLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gU3RhbmRhcmRcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIC8vIE1pY3Jvc29mdFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBudW1iZXI6IHRoaXMubnVtYmVyLFxuICAgICAgLy8gTW96aWxsYVxuICAgICAgZmlsZU5hbWU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG4gICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICAvLyBBeGlvc1xuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIGNvZGU6IHRoaXMuY29kZVxuICAgIH07XG4gIH07XG4gIHJldHVybiBlcnJvcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCBub3JtYWxpemVkTmFtZSkge1xuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIodmFsdWUsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAhPT0gbm9ybWFsaXplZE5hbWUgJiYgbmFtZS50b1VwcGVyQ2FzZSgpID09PSBub3JtYWxpemVkTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWROYW1lXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIGhlYWRlcnNbbmFtZV07XG4gICAgfVxuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHByb2Nlc3NGbiA9IChmbiwgb3B0cykgPT4gZnVuY3Rpb24gKCkge1xuXHRjb25zdCBQID0gb3B0cy5wcm9taXNlTW9kdWxlO1xuXHRjb25zdCBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0YXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0fVxuXG5cdHJldHVybiBuZXcgUCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0aWYgKG9wdHMuZXJyb3JGaXJzdCkge1xuXHRcdFx0YXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuXHRcdFx0XHRpZiAob3B0cy5tdWx0aUFyZ3MpIHtcblx0XHRcdFx0XHRjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzLnVuc2hpZnQoZXJyKTtcblx0XHRcdFx0XHRcdHJlamVjdChyZXN1bHRzKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoZXJyKSB7XG5cdFx0XHRcdFx0cmVqZWN0KGVycik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXJncy5wdXNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRcdFx0aWYgKG9wdHMubXVsdGlBcmdzKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0cmVzdWx0c1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Zm4uYXBwbHkodGhpcywgYXJncyk7XG5cdH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAob2JqLCBvcHRzKSA9PiB7XG5cdG9wdHMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRleGNsdWRlOiBbLy4rKFN5bmN8U3RyZWFtKSQvXSxcblx0XHRlcnJvckZpcnN0OiB0cnVlLFxuXHRcdHByb21pc2VNb2R1bGU6IFByb21pc2Vcblx0fSwgb3B0cyk7XG5cblx0Y29uc3QgZmlsdGVyID0ga2V5ID0+IHtcblx0XHRjb25zdCBtYXRjaCA9IHBhdHRlcm4gPT4gdHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnID8ga2V5ID09PSBwYXR0ZXJuIDogcGF0dGVybi50ZXN0KGtleSk7XG5cdFx0cmV0dXJuIG9wdHMuaW5jbHVkZSA/IG9wdHMuaW5jbHVkZS5zb21lKG1hdGNoKSA6ICFvcHRzLmV4Y2x1ZGUuc29tZShtYXRjaCk7XG5cdH07XG5cblx0bGV0IHJldDtcblx0aWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAob3B0cy5leGNsdWRlTWFpbikge1xuXHRcdFx0XHRyZXR1cm4gb2JqLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9jZXNzRm4ob2JqLCBvcHRzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSk7XG5cdH1cblxuXHRmb3IgKGNvbnN0IGtleSBpbiBvYmopIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBndWFyZC1mb3ItaW5cblx0XHRjb25zdCB4ID0gb2JqW2tleV07XG5cdFx0cmV0W2tleV0gPSB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyAmJiBmaWx0ZXIoa2V5KSA/IHByb2Nlc3NGbih4LCBvcHRzKSA6IHg7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcbiIsIi8vIEFsbCBvZiBNZXRhTWFzaydzIHN1cHBvcnRlZCBicm93c2VycyBpbmNsdWRlIGBSZWZsZWN0LmNvbnN0cnVjdGAgc3VwcG9ydCwgc29cbi8vIHdlIGRvbid0IG5lZWQgdGhpcyBwb2x5ZmlsbC5cblxuLy8gVGhpcyBQcm94eSBwcmVzZXZlcyB0aGUgdHdvIHByb3BlcnRpZXMgdGhhdCB3ZXJlIGFkZGVkIGJ5IGBAYmFiZWwvcnVudGltZWAuXG4vLyBJIGFtIG5vdCBlbnRpcmUgc3VyZSB3aGF0IHRoZXNlIHByb3BlcnRpZXMgYXJlIGZvciAobWF5YmUgRVM1L0VTNlxuLy8gaW50ZXJvcGVyYWJpbGl0eT8pIGJ1dCB0aGV5IGhhdmUgYmVlbiBwcmVzZXJ2ZWQganVzdCBpbiBjYXNlLlxuY29uc3QgcmVmbGVjdFByb3h5ID0gIG5ldyBQcm94eShcbiAgUmVmbGVjdC5jb25zdHJ1Y3QsXG4gIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgICBpZiAocHJvcGVydHkgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJ19fZXNNb2R1bGUnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KC4uLmFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZmxlY3RQcm94eTtcbiIsImZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlRnVuY3Rpb247XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgoZ2xvYmFsLldIQVRXR0ZldGNoID0ge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGdsb2JhbCA9XG4gICAgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzKSB8fFxuICAgICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZikgfHxcbiAgICAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsKTtcblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIGdsb2JhbCxcbiAgICBpdGVyYWJsZTogJ1N5bWJvbCcgaW4gZ2xvYmFsICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICAgIGJsb2I6XG4gICAgICAnRmlsZVJlYWRlcicgaW4gZ2xvYmFsICYmXG4gICAgICAnQmxvYicgaW4gZ2xvYmFsICYmXG4gICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmV3IEJsb2IoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pKCksXG4gICAgZm9ybURhdGE6ICdGb3JtRGF0YScgaW4gZ2xvYmFsLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIGdsb2JhbFxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzRGF0YVZpZXcob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopXG4gIH1cblxuICBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICAgIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAgICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICAgIF07XG5cbiAgICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPVxuICAgICAgQXJyYXlCdWZmZXIuaXNWaWV3IHx8XG4gICAgICBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB2aWV3Q2xhc3Nlcy5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSA+IC0xXG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICB9XG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXl9gfH4hXS9pLnRlc3QobmFtZSkgfHwgbmFtZSA9PT0gJycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXTtcbiAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAnLCAnICsgdmFsdWUgOiB2YWx1ZTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgICAgfTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICAgIGlmIChidWYuc2xpY2UpIHtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKTtcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICAvKlxuICAgICAgICBmZXRjaC1tb2NrIHdyYXBzIHRoZSBSZXNwb25zZSBvYmplY3QgaW4gYW4gRVM2IFByb3h5IHRvXG4gICAgICAgIHByb3ZpZGUgdXNlZnVsIHRlc3QgaGFybmVzcyBmZWF0dXJlcyBzdWNoIGFzIGZsdXNoLiBIb3dldmVyLCBvblxuICAgICAgICBFUzUgYnJvd3NlcnMgd2l0aG91dCBmZXRjaCBvciBQcm94eSBzdXBwb3J0IHBvbGx5ZmlsbHMgbXVzdCBiZSB1c2VkO1xuICAgICAgICB0aGUgcHJveHktcG9sbHlmaWxsIGlzIHVuYWJsZSB0byBwcm94eSBhbiBhdHRyaWJ1dGUgdW5sZXNzIGl0IGV4aXN0c1xuICAgICAgICBvbiB0aGUgb2JqZWN0IGJlZm9yZSB0aGUgUHJveHkgaXMgY3JlYXRlZC4gVGhpcyBjaGFuZ2UgZW5zdXJlc1xuICAgICAgICBSZXNwb25zZS5ib2R5VXNlZCBleGlzdHMgb24gdGhlIGluc3RhbmNlLCB3aGlsZSBtYWludGFpbmluZyB0aGVcbiAgICAgICAgc2VtYW50aWMgb2Ygc2V0dGluZyBSZXF1ZXN0LmJvZHlVc2VkIGluIHRoZSBjb25zdHJ1Y3RvciBiZWZvcmVcbiAgICAgICAgX2luaXRCb2R5IGlzIGNhbGxlZC5cbiAgICAgICovXG4gICAgICB0aGlzLmJvZHlVc2VkID0gdGhpcy5ib2R5VXNlZDtcbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keTtcbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUZvcm1EYXRhID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKTtcbiAgICAgICAgLy8gSUUgMTAtMTEgY2FuJ3QgaGFuZGxlIGEgRGF0YVZpZXcgYm9keS5cbiAgICAgICAgdGhpcy5fYm9keUluaXQgPSBuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChib2R5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSlcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgdmFyIGlzQ29uc3VtZWQgPSBjb25zdW1lZCh0aGlzKTtcbiAgICAgICAgICBpZiAoaXNDb25zdW1lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQ29uc3VtZWRcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnVmZmVyLnNsaWNlKFxuICAgICAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlT2Zmc2V0ICsgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbiAgdmFyIG1ldGhvZHMgPSBbJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BPU1QnLCAnUFVUJ107XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xID8gdXBjYXNlZCA6IG1ldGhvZFxuICB9XG5cbiAgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXF1ZXN0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGxlYXNlIHVzZSB0aGUgXCJuZXdcIiBvcGVyYXRvciwgdGhpcyBET00gb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi4nKVxuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5O1xuXG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IGlucHV0LnVybDtcbiAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFscztcbiAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpO1xuICAgICAgfVxuICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2Q7XG4gICAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlO1xuICAgICAgdGhpcy5zaWduYWwgPSBpbnB1dC5zaWduYWw7XG4gICAgICBpZiAoIWJvZHkgJiYgaW5wdXQuX2JvZHlJbml0ICE9IG51bGwpIHtcbiAgICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdDtcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dCk7XG4gICAgfVxuXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnc2FtZS1vcmlnaW4nO1xuICAgIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICB9XG4gICAgdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5tZXRob2QgfHwgJ0dFVCcpO1xuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbDtcbiAgICB0aGlzLnNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsIHx8IHRoaXMuc2lnbmFsO1xuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsO1xuXG4gICAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICAgIH1cbiAgICB0aGlzLl9pbml0Qm9keShib2R5KTtcblxuICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykge1xuICAgICAgaWYgKG9wdGlvbnMuY2FjaGUgPT09ICduby1zdG9yZScgfHwgb3B0aW9ucy5jYWNoZSA9PT0gJ25vLWNhY2hlJykge1xuICAgICAgICAvLyBTZWFyY2ggZm9yIGEgJ18nIHBhcmFtZXRlciBpbiB0aGUgcXVlcnkgc3RyaW5nXG4gICAgICAgIHZhciByZVBhcmFtU2VhcmNoID0gLyhbPyZdKV89W14mXSovO1xuICAgICAgICBpZiAocmVQYXJhbVNlYXJjaC50ZXN0KHRoaXMudXJsKSkge1xuICAgICAgICAgIC8vIElmIGl0IGFscmVhZHkgZXhpc3RzIHRoZW4gc2V0IHRoZSB2YWx1ZSB3aXRoIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgICB0aGlzLnVybCA9IHRoaXMudXJsLnJlcGxhY2UocmVQYXJhbVNlYXJjaCwgJyQxXz0nICsgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgYSBuZXcgJ18nIHBhcmFtZXRlciB0byB0aGUgZW5kIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICAgIHZhciByZVF1ZXJ5U3RyaW5nID0gL1xcPy87XG4gICAgICAgICAgdGhpcy51cmwgKz0gKHJlUXVlcnlTdHJpbmcudGVzdCh0aGlzLnVybCkgPyAnJicgOiAnPycpICsgJ189JyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywge2JvZHk6IHRoaXMuX2JvZHlJbml0fSlcbiAgfTtcblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgYm9keVxuICAgICAgLnRyaW0oKVxuICAgICAgLnNwbGl0KCcmJylcbiAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICAgIGlmIChieXRlcykge1xuICAgICAgICAgIHZhciBzcGxpdCA9IGJ5dGVzLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgdmFyIG5hbWUgPSBzcGxpdC5zaGlmdCgpLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJz0nKS5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICAgICAgICBmb3JtLmFwcGVuZChkZWNvZGVVUklDb21wb25lbnQobmFtZSksIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICByZXR1cm4gZm9ybVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIHtcbiAgICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgLy8gUmVwbGFjZSBpbnN0YW5jZXMgb2YgXFxyXFxuIGFuZCBcXG4gZm9sbG93ZWQgYnkgYXQgbGVhc3Qgb25lIHNwYWNlIG9yIGhvcml6b250YWwgdGFiIHdpdGggYSBzcGFjZVxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yXG4gICAgdmFyIHByZVByb2Nlc3NlZEhlYWRlcnMgPSByYXdIZWFkZXJzLnJlcGxhY2UoL1xccj9cXG5bXFx0IF0rL2csICcgJyk7XG4gICAgLy8gQXZvaWRpbmcgc3BsaXQgdmlhIHJlZ2V4IHRvIHdvcmsgYXJvdW5kIGEgY29tbW9uIElFMTEgYnVnIHdpdGggdGhlIGNvcmUtanMgMy42LjAgcmVnZXggcG9seWZpbGxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoL2lzc3Vlcy83NDhcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNzUxXG4gICAgcHJlUHJvY2Vzc2VkSGVhZGVyc1xuICAgICAgLnNwbGl0KCdcXHInKVxuICAgICAgLm1hcChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlci5pbmRleE9mKCdcXG4nKSA9PT0gMCA/IGhlYWRlci5zdWJzdHIoMSwgaGVhZGVyLmxlbmd0aCkgOiBoZWFkZXJcbiAgICAgIH0pXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKTtcbiAgICAgICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKTtcbiAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbiAgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgdXNlIHRoZSBcIm5ld1wiIG9wZXJhdG9yLCB0aGlzIERPTSBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLicpXG4gICAgfVxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9ICdkZWZhdWx0JztcbiAgICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzID09PSB1bmRlZmluZWQgPyAyMDAgOiBvcHRpb25zLnN0YXR1cztcbiAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IG9wdGlvbnMuc3RhdHVzVGV4dCA9PT0gdW5kZWZpbmVkID8gJycgOiAnJyArIG9wdGlvbnMuc3RhdHVzVGV4dDtcbiAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpO1xuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJyc7XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpO1xuICB9XG5cbiAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSk7XG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSlcbiAgfTtcblxuICBSZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAwLCBzdGF0dXNUZXh0OiAnJ30pO1xuICAgIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InO1xuICAgIHJldHVybiByZXNwb25zZVxuICB9O1xuXG4gIHZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XTtcblxuICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxuICB9O1xuXG4gIGV4cG9ydHMuRE9NRXhjZXB0aW9uID0gZ2xvYmFsLkRPTUV4Y2VwdGlvbjtcbiAgdHJ5IHtcbiAgICBuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHZhciBlcnJvciA9IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIH07XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGV4cG9ydHMuRE9NRXhjZXB0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KTtcblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBleHBvcnRzLkRPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGZpeFVybCh1cmwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXJsID09PSAnJyAmJiBnbG9iYWwubG9jYXRpb24uaHJlZiA/IGdsb2JhbC5sb2NhdGlvbi5ocmVmIDogdXJsXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gdXJsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIGZpeFVybChyZXF1ZXN0LnVybCksIHRydWUpO1xuXG4gICAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnb21pdCcpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyKSB7XG4gICAgICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHN1cHBvcnQuYXJyYXlCdWZmZXIgJiZcbiAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSAmJlxuICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpLmluZGV4T2YoJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpICE9PSAtMVxuICAgICAgICApIHtcbiAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaW5pdCAmJiB0eXBlb2YgaW5pdC5oZWFkZXJzID09PSAnb2JqZWN0JyAmJiAhKGluaXQuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpKSB7XG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGluaXQuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgbm9ybWFsaXplVmFsdWUoaW5pdC5oZWFkZXJzW25hbWVdKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwpIHtcbiAgICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocik7XG5cbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIERPTkUgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdCk7XG4gICAgfSlcbiAgfVxuXG4gIGZldGNoLnBvbHlmaWxsID0gdHJ1ZTtcblxuICBpZiAoIWdsb2JhbC5mZXRjaCkge1xuICAgIGdsb2JhbC5mZXRjaCA9IGZldGNoO1xuICAgIGdsb2JhbC5IZWFkZXJzID0gSGVhZGVycztcbiAgICBnbG9iYWwuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gICAgZ2xvYmFsLlJlc3BvbnNlID0gUmVzcG9uc2U7XG4gIH1cblxuICBleHBvcnRzLkhlYWRlcnMgPSBIZWFkZXJzO1xuICBleHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICBleHBvcnRzLlJlc3BvbnNlID0gUmVzcG9uc2U7XG4gIGV4cG9ydHMuZmV0Y2ggPSBmZXRjaDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiJ3VzZSBzdHJpY3QnXG52YXIgUDE2MDBfUk9VTkRfQ09OU1RBTlRTID0gWzEsIDAsIDMyODk4LCAwLCAzMjkwNiwgMjE0NzQ4MzY0OCwgMjE0NzUxNjQxNiwgMjE0NzQ4MzY0OCwgMzI5MDcsIDAsIDIxNDc0ODM2NDksIDAsIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyNzc3LCAyMTQ3NDgzNjQ4LCAxMzgsIDAsIDEzNiwgMCwgMjE0NzUxNjQyNSwgMCwgMjE0NzQ4MzY1OCwgMCwgMjE0NzUxNjU1NSwgMCwgMTM5LCAyMTQ3NDgzNjQ4LCAzMjkwNSwgMjE0NzQ4MzY0OCwgMzI3NzEsIDIxNDc0ODM2NDgsIDMyNzcwLCAyMTQ3NDgzNjQ4LCAxMjgsIDIxNDc0ODM2NDgsIDMyNzc4LCAwLCAyMTQ3NDgzNjU4LCAyMTQ3NDgzNjQ4LCAyMTQ3NTE2NTQ1LCAyMTQ3NDgzNjQ4LCAzMjg5NiwgMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0OSwgMCwgMjE0NzUxNjQyNCwgMjE0NzQ4MzY0OF1cblxuZXhwb3J0cy5wMTYwMCA9IGZ1bmN0aW9uIChzKSB7XG4gIGZvciAodmFyIHJvdW5kID0gMDsgcm91bmQgPCAyNDsgKytyb3VuZCkge1xuICAgIC8vIHRoZXRhXG4gICAgdmFyIGxvMCA9IHNbMF0gXiBzWzEwXSBeIHNbMjBdIF4gc1szMF0gXiBzWzQwXVxuICAgIHZhciBoaTAgPSBzWzFdIF4gc1sxMV0gXiBzWzIxXSBeIHNbMzFdIF4gc1s0MV1cbiAgICB2YXIgbG8xID0gc1syXSBeIHNbMTJdIF4gc1syMl0gXiBzWzMyXSBeIHNbNDJdXG4gICAgdmFyIGhpMSA9IHNbM10gXiBzWzEzXSBeIHNbMjNdIF4gc1szM10gXiBzWzQzXVxuICAgIHZhciBsbzIgPSBzWzRdIF4gc1sxNF0gXiBzWzI0XSBeIHNbMzRdIF4gc1s0NF1cbiAgICB2YXIgaGkyID0gc1s1XSBeIHNbMTVdIF4gc1syNV0gXiBzWzM1XSBeIHNbNDVdXG4gICAgdmFyIGxvMyA9IHNbNl0gXiBzWzE2XSBeIHNbMjZdIF4gc1szNl0gXiBzWzQ2XVxuICAgIHZhciBoaTMgPSBzWzddIF4gc1sxN10gXiBzWzI3XSBeIHNbMzddIF4gc1s0N11cbiAgICB2YXIgbG80ID0gc1s4XSBeIHNbMThdIF4gc1syOF0gXiBzWzM4XSBeIHNbNDhdXG4gICAgdmFyIGhpNCA9IHNbOV0gXiBzWzE5XSBeIHNbMjldIF4gc1szOV0gXiBzWzQ5XVxuXG4gICAgdmFyIGxvID0gbG80IF4gKGxvMSA8PCAxIHwgaGkxID4+PiAzMSlcbiAgICB2YXIgaGkgPSBoaTQgXiAoaGkxIDw8IDEgfCBsbzEgPj4+IDMxKVxuICAgIHZhciB0MXNsbzAgPSBzWzBdIF4gbG9cbiAgICB2YXIgdDFzaGkwID0gc1sxXSBeIGhpXG4gICAgdmFyIHQxc2xvNSA9IHNbMTBdIF4gbG9cbiAgICB2YXIgdDFzaGk1ID0gc1sxMV0gXiBoaVxuICAgIHZhciB0MXNsbzEwID0gc1syMF0gXiBsb1xuICAgIHZhciB0MXNoaTEwID0gc1syMV0gXiBoaVxuICAgIHZhciB0MXNsbzE1ID0gc1szMF0gXiBsb1xuICAgIHZhciB0MXNoaTE1ID0gc1szMV0gXiBoaVxuICAgIHZhciB0MXNsbzIwID0gc1s0MF0gXiBsb1xuICAgIHZhciB0MXNoaTIwID0gc1s0MV0gXiBoaVxuICAgIGxvID0gbG8wIF4gKGxvMiA8PCAxIHwgaGkyID4+PiAzMSlcbiAgICBoaSA9IGhpMCBeIChoaTIgPDwgMSB8IGxvMiA+Pj4gMzEpXG4gICAgdmFyIHQxc2xvMSA9IHNbMl0gXiBsb1xuICAgIHZhciB0MXNoaTEgPSBzWzNdIF4gaGlcbiAgICB2YXIgdDFzbG82ID0gc1sxMl0gXiBsb1xuICAgIHZhciB0MXNoaTYgPSBzWzEzXSBeIGhpXG4gICAgdmFyIHQxc2xvMTEgPSBzWzIyXSBeIGxvXG4gICAgdmFyIHQxc2hpMTEgPSBzWzIzXSBeIGhpXG4gICAgdmFyIHQxc2xvMTYgPSBzWzMyXSBeIGxvXG4gICAgdmFyIHQxc2hpMTYgPSBzWzMzXSBeIGhpXG4gICAgdmFyIHQxc2xvMjEgPSBzWzQyXSBeIGxvXG4gICAgdmFyIHQxc2hpMjEgPSBzWzQzXSBeIGhpXG4gICAgbG8gPSBsbzEgXiAobG8zIDw8IDEgfCBoaTMgPj4+IDMxKVxuICAgIGhpID0gaGkxIF4gKGhpMyA8PCAxIHwgbG8zID4+PiAzMSlcbiAgICB2YXIgdDFzbG8yID0gc1s0XSBeIGxvXG4gICAgdmFyIHQxc2hpMiA9IHNbNV0gXiBoaVxuICAgIHZhciB0MXNsbzcgPSBzWzE0XSBeIGxvXG4gICAgdmFyIHQxc2hpNyA9IHNbMTVdIF4gaGlcbiAgICB2YXIgdDFzbG8xMiA9IHNbMjRdIF4gbG9cbiAgICB2YXIgdDFzaGkxMiA9IHNbMjVdIF4gaGlcbiAgICB2YXIgdDFzbG8xNyA9IHNbMzRdIF4gbG9cbiAgICB2YXIgdDFzaGkxNyA9IHNbMzVdIF4gaGlcbiAgICB2YXIgdDFzbG8yMiA9IHNbNDRdIF4gbG9cbiAgICB2YXIgdDFzaGkyMiA9IHNbNDVdIF4gaGlcbiAgICBsbyA9IGxvMiBeIChsbzQgPDwgMSB8IGhpNCA+Pj4gMzEpXG4gICAgaGkgPSBoaTIgXiAoaGk0IDw8IDEgfCBsbzQgPj4+IDMxKVxuICAgIHZhciB0MXNsbzMgPSBzWzZdIF4gbG9cbiAgICB2YXIgdDFzaGkzID0gc1s3XSBeIGhpXG4gICAgdmFyIHQxc2xvOCA9IHNbMTZdIF4gbG9cbiAgICB2YXIgdDFzaGk4ID0gc1sxN10gXiBoaVxuICAgIHZhciB0MXNsbzEzID0gc1syNl0gXiBsb1xuICAgIHZhciB0MXNoaTEzID0gc1syN10gXiBoaVxuICAgIHZhciB0MXNsbzE4ID0gc1szNl0gXiBsb1xuICAgIHZhciB0MXNoaTE4ID0gc1szN10gXiBoaVxuICAgIHZhciB0MXNsbzIzID0gc1s0Nl0gXiBsb1xuICAgIHZhciB0MXNoaTIzID0gc1s0N10gXiBoaVxuICAgIGxvID0gbG8zIF4gKGxvMCA8PCAxIHwgaGkwID4+PiAzMSlcbiAgICBoaSA9IGhpMyBeIChoaTAgPDwgMSB8IGxvMCA+Pj4gMzEpXG4gICAgdmFyIHQxc2xvNCA9IHNbOF0gXiBsb1xuICAgIHZhciB0MXNoaTQgPSBzWzldIF4gaGlcbiAgICB2YXIgdDFzbG85ID0gc1sxOF0gXiBsb1xuICAgIHZhciB0MXNoaTkgPSBzWzE5XSBeIGhpXG4gICAgdmFyIHQxc2xvMTQgPSBzWzI4XSBeIGxvXG4gICAgdmFyIHQxc2hpMTQgPSBzWzI5XSBeIGhpXG4gICAgdmFyIHQxc2xvMTkgPSBzWzM4XSBeIGxvXG4gICAgdmFyIHQxc2hpMTkgPSBzWzM5XSBeIGhpXG4gICAgdmFyIHQxc2xvMjQgPSBzWzQ4XSBeIGxvXG4gICAgdmFyIHQxc2hpMjQgPSBzWzQ5XSBeIGhpXG5cbiAgICAvLyByaG8gJiBwaVxuICAgIHZhciB0MnNsbzAgPSB0MXNsbzBcbiAgICB2YXIgdDJzaGkwID0gdDFzaGkwXG4gICAgdmFyIHQyc2xvMTYgPSAodDFzaGk1IDw8IDQgfCB0MXNsbzUgPj4+IDI4KVxuICAgIHZhciB0MnNoaTE2ID0gKHQxc2xvNSA8PCA0IHwgdDFzaGk1ID4+PiAyOClcbiAgICB2YXIgdDJzbG83ID0gKHQxc2xvMTAgPDwgMyB8IHQxc2hpMTAgPj4+IDI5KVxuICAgIHZhciB0MnNoaTcgPSAodDFzaGkxMCA8PCAzIHwgdDFzbG8xMCA+Pj4gMjkpXG4gICAgdmFyIHQyc2xvMjMgPSAodDFzaGkxNSA8PCA5IHwgdDFzbG8xNSA+Pj4gMjMpXG4gICAgdmFyIHQyc2hpMjMgPSAodDFzbG8xNSA8PCA5IHwgdDFzaGkxNSA+Pj4gMjMpXG4gICAgdmFyIHQyc2xvMTQgPSAodDFzbG8yMCA8PCAxOCB8IHQxc2hpMjAgPj4+IDE0KVxuICAgIHZhciB0MnNoaTE0ID0gKHQxc2hpMjAgPDwgMTggfCB0MXNsbzIwID4+PiAxNClcbiAgICB2YXIgdDJzbG8xMCA9ICh0MXNsbzEgPDwgMSB8IHQxc2hpMSA+Pj4gMzEpXG4gICAgdmFyIHQyc2hpMTAgPSAodDFzaGkxIDw8IDEgfCB0MXNsbzEgPj4+IDMxKVxuICAgIHZhciB0MnNsbzEgPSAodDFzaGk2IDw8IDEyIHwgdDFzbG82ID4+PiAyMClcbiAgICB2YXIgdDJzaGkxID0gKHQxc2xvNiA8PCAxMiB8IHQxc2hpNiA+Pj4gMjApXG4gICAgdmFyIHQyc2xvMTcgPSAodDFzbG8xMSA8PCAxMCB8IHQxc2hpMTEgPj4+IDIyKVxuICAgIHZhciB0MnNoaTE3ID0gKHQxc2hpMTEgPDwgMTAgfCB0MXNsbzExID4+PiAyMilcbiAgICB2YXIgdDJzbG84ID0gKHQxc2hpMTYgPDwgMTMgfCB0MXNsbzE2ID4+PiAxOSlcbiAgICB2YXIgdDJzaGk4ID0gKHQxc2xvMTYgPDwgMTMgfCB0MXNoaTE2ID4+PiAxOSlcbiAgICB2YXIgdDJzbG8yNCA9ICh0MXNsbzIxIDw8IDIgfCB0MXNoaTIxID4+PiAzMClcbiAgICB2YXIgdDJzaGkyNCA9ICh0MXNoaTIxIDw8IDIgfCB0MXNsbzIxID4+PiAzMClcbiAgICB2YXIgdDJzbG8yMCA9ICh0MXNoaTIgPDwgMzAgfCB0MXNsbzIgPj4+IDIpXG4gICAgdmFyIHQyc2hpMjAgPSAodDFzbG8yIDw8IDMwIHwgdDFzaGkyID4+PiAyKVxuICAgIHZhciB0MnNsbzExID0gKHQxc2xvNyA8PCA2IHwgdDFzaGk3ID4+PiAyNilcbiAgICB2YXIgdDJzaGkxMSA9ICh0MXNoaTcgPDwgNiB8IHQxc2xvNyA+Pj4gMjYpXG4gICAgdmFyIHQyc2xvMiA9ICh0MXNoaTEyIDw8IDExIHwgdDFzbG8xMiA+Pj4gMjEpXG4gICAgdmFyIHQyc2hpMiA9ICh0MXNsbzEyIDw8IDExIHwgdDFzaGkxMiA+Pj4gMjEpXG4gICAgdmFyIHQyc2xvMTggPSAodDFzbG8xNyA8PCAxNSB8IHQxc2hpMTcgPj4+IDE3KVxuICAgIHZhciB0MnNoaTE4ID0gKHQxc2hpMTcgPDwgMTUgfCB0MXNsbzE3ID4+PiAxNylcbiAgICB2YXIgdDJzbG85ID0gKHQxc2hpMjIgPDwgMjkgfCB0MXNsbzIyID4+PiAzKVxuICAgIHZhciB0MnNoaTkgPSAodDFzbG8yMiA8PCAyOSB8IHQxc2hpMjIgPj4+IDMpXG4gICAgdmFyIHQyc2xvNSA9ICh0MXNsbzMgPDwgMjggfCB0MXNoaTMgPj4+IDQpXG4gICAgdmFyIHQyc2hpNSA9ICh0MXNoaTMgPDwgMjggfCB0MXNsbzMgPj4+IDQpXG4gICAgdmFyIHQyc2xvMjEgPSAodDFzaGk4IDw8IDIzIHwgdDFzbG84ID4+PiA5KVxuICAgIHZhciB0MnNoaTIxID0gKHQxc2xvOCA8PCAyMyB8IHQxc2hpOCA+Pj4gOSlcbiAgICB2YXIgdDJzbG8xMiA9ICh0MXNsbzEzIDw8IDI1IHwgdDFzaGkxMyA+Pj4gNylcbiAgICB2YXIgdDJzaGkxMiA9ICh0MXNoaTEzIDw8IDI1IHwgdDFzbG8xMyA+Pj4gNylcbiAgICB2YXIgdDJzbG8zID0gKHQxc2xvMTggPDwgMjEgfCB0MXNoaTE4ID4+PiAxMSlcbiAgICB2YXIgdDJzaGkzID0gKHQxc2hpMTggPDwgMjEgfCB0MXNsbzE4ID4+PiAxMSlcbiAgICB2YXIgdDJzbG8xOSA9ICh0MXNoaTIzIDw8IDI0IHwgdDFzbG8yMyA+Pj4gOClcbiAgICB2YXIgdDJzaGkxOSA9ICh0MXNsbzIzIDw8IDI0IHwgdDFzaGkyMyA+Pj4gOClcbiAgICB2YXIgdDJzbG8xNSA9ICh0MXNsbzQgPDwgMjcgfCB0MXNoaTQgPj4+IDUpXG4gICAgdmFyIHQyc2hpMTUgPSAodDFzaGk0IDw8IDI3IHwgdDFzbG80ID4+PiA1KVxuICAgIHZhciB0MnNsbzYgPSAodDFzbG85IDw8IDIwIHwgdDFzaGk5ID4+PiAxMilcbiAgICB2YXIgdDJzaGk2ID0gKHQxc2hpOSA8PCAyMCB8IHQxc2xvOSA+Pj4gMTIpXG4gICAgdmFyIHQyc2xvMjIgPSAodDFzaGkxNCA8PCA3IHwgdDFzbG8xNCA+Pj4gMjUpXG4gICAgdmFyIHQyc2hpMjIgPSAodDFzbG8xNCA8PCA3IHwgdDFzaGkxNCA+Pj4gMjUpXG4gICAgdmFyIHQyc2xvMTMgPSAodDFzbG8xOSA8PCA4IHwgdDFzaGkxOSA+Pj4gMjQpXG4gICAgdmFyIHQyc2hpMTMgPSAodDFzaGkxOSA8PCA4IHwgdDFzbG8xOSA+Pj4gMjQpXG4gICAgdmFyIHQyc2xvNCA9ICh0MXNsbzI0IDw8IDE0IHwgdDFzaGkyNCA+Pj4gMTgpXG4gICAgdmFyIHQyc2hpNCA9ICh0MXNoaTI0IDw8IDE0IHwgdDFzbG8yNCA+Pj4gMTgpXG5cbiAgICAvLyBjaGlcbiAgICBzWzBdID0gdDJzbG8wIF4gKH50MnNsbzEgJiB0MnNsbzIpXG4gICAgc1sxXSA9IHQyc2hpMCBeICh+dDJzaGkxICYgdDJzaGkyKVxuICAgIHNbMTBdID0gdDJzbG81IF4gKH50MnNsbzYgJiB0MnNsbzcpXG4gICAgc1sxMV0gPSB0MnNoaTUgXiAofnQyc2hpNiAmIHQyc2hpNylcbiAgICBzWzIwXSA9IHQyc2xvMTAgXiAofnQyc2xvMTEgJiB0MnNsbzEyKVxuICAgIHNbMjFdID0gdDJzaGkxMCBeICh+dDJzaGkxMSAmIHQyc2hpMTIpXG4gICAgc1szMF0gPSB0MnNsbzE1IF4gKH50MnNsbzE2ICYgdDJzbG8xNylcbiAgICBzWzMxXSA9IHQyc2hpMTUgXiAofnQyc2hpMTYgJiB0MnNoaTE3KVxuICAgIHNbNDBdID0gdDJzbG8yMCBeICh+dDJzbG8yMSAmIHQyc2xvMjIpXG4gICAgc1s0MV0gPSB0MnNoaTIwIF4gKH50MnNoaTIxICYgdDJzaGkyMilcbiAgICBzWzJdID0gdDJzbG8xIF4gKH50MnNsbzIgJiB0MnNsbzMpXG4gICAgc1szXSA9IHQyc2hpMSBeICh+dDJzaGkyICYgdDJzaGkzKVxuICAgIHNbMTJdID0gdDJzbG82IF4gKH50MnNsbzcgJiB0MnNsbzgpXG4gICAgc1sxM10gPSB0MnNoaTYgXiAofnQyc2hpNyAmIHQyc2hpOClcbiAgICBzWzIyXSA9IHQyc2xvMTEgXiAofnQyc2xvMTIgJiB0MnNsbzEzKVxuICAgIHNbMjNdID0gdDJzaGkxMSBeICh+dDJzaGkxMiAmIHQyc2hpMTMpXG4gICAgc1szMl0gPSB0MnNsbzE2IF4gKH50MnNsbzE3ICYgdDJzbG8xOClcbiAgICBzWzMzXSA9IHQyc2hpMTYgXiAofnQyc2hpMTcgJiB0MnNoaTE4KVxuICAgIHNbNDJdID0gdDJzbG8yMSBeICh+dDJzbG8yMiAmIHQyc2xvMjMpXG4gICAgc1s0M10gPSB0MnNoaTIxIF4gKH50MnNoaTIyICYgdDJzaGkyMylcbiAgICBzWzRdID0gdDJzbG8yIF4gKH50MnNsbzMgJiB0MnNsbzQpXG4gICAgc1s1XSA9IHQyc2hpMiBeICh+dDJzaGkzICYgdDJzaGk0KVxuICAgIHNbMTRdID0gdDJzbG83IF4gKH50MnNsbzggJiB0MnNsbzkpXG4gICAgc1sxNV0gPSB0MnNoaTcgXiAofnQyc2hpOCAmIHQyc2hpOSlcbiAgICBzWzI0XSA9IHQyc2xvMTIgXiAofnQyc2xvMTMgJiB0MnNsbzE0KVxuICAgIHNbMjVdID0gdDJzaGkxMiBeICh+dDJzaGkxMyAmIHQyc2hpMTQpXG4gICAgc1szNF0gPSB0MnNsbzE3IF4gKH50MnNsbzE4ICYgdDJzbG8xOSlcbiAgICBzWzM1XSA9IHQyc2hpMTcgXiAofnQyc2hpMTggJiB0MnNoaTE5KVxuICAgIHNbNDRdID0gdDJzbG8yMiBeICh+dDJzbG8yMyAmIHQyc2xvMjQpXG4gICAgc1s0NV0gPSB0MnNoaTIyIF4gKH50MnNoaTIzICYgdDJzaGkyNClcbiAgICBzWzZdID0gdDJzbG8zIF4gKH50MnNsbzQgJiB0MnNsbzApXG4gICAgc1s3XSA9IHQyc2hpMyBeICh+dDJzaGk0ICYgdDJzaGkwKVxuICAgIHNbMTZdID0gdDJzbG84IF4gKH50MnNsbzkgJiB0MnNsbzUpXG4gICAgc1sxN10gPSB0MnNoaTggXiAofnQyc2hpOSAmIHQyc2hpNSlcbiAgICBzWzI2XSA9IHQyc2xvMTMgXiAofnQyc2xvMTQgJiB0MnNsbzEwKVxuICAgIHNbMjddID0gdDJzaGkxMyBeICh+dDJzaGkxNCAmIHQyc2hpMTApXG4gICAgc1szNl0gPSB0MnNsbzE4IF4gKH50MnNsbzE5ICYgdDJzbG8xNSlcbiAgICBzWzM3XSA9IHQyc2hpMTggXiAofnQyc2hpMTkgJiB0MnNoaTE1KVxuICAgIHNbNDZdID0gdDJzbG8yMyBeICh+dDJzbG8yNCAmIHQyc2xvMjApXG4gICAgc1s0N10gPSB0MnNoaTIzIF4gKH50MnNoaTI0ICYgdDJzaGkyMClcbiAgICBzWzhdID0gdDJzbG80IF4gKH50MnNsbzAgJiB0MnNsbzEpXG4gICAgc1s5XSA9IHQyc2hpNCBeICh+dDJzaGkwICYgdDJzaGkxKVxuICAgIHNbMThdID0gdDJzbG85IF4gKH50MnNsbzUgJiB0MnNsbzYpXG4gICAgc1sxOV0gPSB0MnNoaTkgXiAofnQyc2hpNSAmIHQyc2hpNilcbiAgICBzWzI4XSA9IHQyc2xvMTQgXiAofnQyc2xvMTAgJiB0MnNsbzExKVxuICAgIHNbMjldID0gdDJzaGkxNCBeICh+dDJzaGkxMCAmIHQyc2hpMTEpXG4gICAgc1szOF0gPSB0MnNsbzE5IF4gKH50MnNsbzE1ICYgdDJzbG8xNilcbiAgICBzWzM5XSA9IHQyc2hpMTkgXiAofnQyc2hpMTUgJiB0MnNoaTE2KVxuICAgIHNbNDhdID0gdDJzbG8yNCBeICh+dDJzbG8yMCAmIHQyc2xvMjEpXG4gICAgc1s0OV0gPSB0MnNoaTI0IF4gKH50MnNoaTIwICYgdDJzaGkyMSlcblxuICAgIC8vIGlvdGFcbiAgICBzWzBdIF49IFAxNjAwX1JPVU5EX0NPTlNUQU5UU1tyb3VuZCAqIDJdXG4gICAgc1sxXSBePSBQMTYwMF9ST1VORF9DT05TVEFOVFNbcm91bmQgKiAyICsgMV1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm1cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS2VjY2FrU3RhdGUpIHtcbiAgZnVuY3Rpb24gS2VjY2FrIChyYXRlLCBjYXBhY2l0eSwgZGVsaW1pdGVkU3VmZml4LCBoYXNoQml0TGVuZ3RoLCBvcHRpb25zKSB7XG4gICAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucylcblxuICAgIHRoaXMuX3JhdGUgPSByYXRlXG4gICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eVxuICAgIHRoaXMuX2RlbGltaXRlZFN1ZmZpeCA9IGRlbGltaXRlZFN1ZmZpeFxuICAgIHRoaXMuX2hhc2hCaXRMZW5ndGggPSBoYXNoQml0TGVuZ3RoXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnNcblxuICAgIHRoaXMuX3N0YXRlID0gbmV3IEtlY2Nha1N0YXRlKClcbiAgICB0aGlzLl9zdGF0ZS5pbml0aWFsaXplKHJhdGUsIGNhcGFjaXR5KVxuICAgIHRoaXMuX2ZpbmFsaXplZCA9IGZhbHNlXG4gIH1cblxuICBpbmhlcml0cyhLZWNjYWssIFRyYW5zZm9ybSlcblxuICBLZWNjYWsucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIHZhciBlcnJvciA9IG51bGxcbiAgICB0cnkge1xuICAgICAgdGhpcy51cGRhdGUoY2h1bmssIGVuY29kaW5nKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyb3IgPSBlcnJcbiAgICB9XG5cbiAgICBjYWxsYmFjayhlcnJvcilcbiAgfVxuXG4gIEtlY2Nhay5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIGVycm9yID0gbnVsbFxuICAgIHRyeSB7XG4gICAgICB0aGlzLnB1c2godGhpcy5kaWdlc3QoKSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVycm9yID0gZXJyXG4gICAgfVxuXG4gICAgY2FsbGJhY2soZXJyb3IpXG4gIH1cblxuICBLZWNjYWsucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZykge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpICYmIHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YSBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgYnVmZmVyJylcbiAgICBpZiAodGhpcy5fZmluYWxpemVkKSB0aHJvdyBuZXcgRXJyb3IoJ0RpZ2VzdCBhbHJlYWR5IGNhbGxlZCcpXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCBlbmNvZGluZylcblxuICAgIHRoaXMuX3N0YXRlLmFic29yYihkYXRhKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIEtlY2Nhay5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gICAgaWYgKHRoaXMuX2ZpbmFsaXplZCkgdGhyb3cgbmV3IEVycm9yKCdEaWdlc3QgYWxyZWFkeSBjYWxsZWQnKVxuICAgIHRoaXMuX2ZpbmFsaXplZCA9IHRydWVcblxuICAgIGlmICh0aGlzLl9kZWxpbWl0ZWRTdWZmaXgpIHRoaXMuX3N0YXRlLmFic29yYkxhc3RGZXdCaXRzKHRoaXMuX2RlbGltaXRlZFN1ZmZpeClcbiAgICB2YXIgZGlnZXN0ID0gdGhpcy5fc3RhdGUuc3F1ZWV6ZSh0aGlzLl9oYXNoQml0TGVuZ3RoIC8gOClcbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkgZGlnZXN0ID0gZGlnZXN0LnRvU3RyaW5nKGVuY29kaW5nKVxuXG4gICAgdGhpcy5fcmVzZXRTdGF0ZSgpXG5cbiAgICByZXR1cm4gZGlnZXN0XG4gIH1cblxuICAvLyByZW1vdmUgcmVzdWx0IGZyb20gbWVtb3J5XG4gIEtlY2Nhay5wcm90b3R5cGUuX3Jlc2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fc3RhdGUuaW5pdGlhbGl6ZSh0aGlzLl9yYXRlLCB0aGlzLl9jYXBhY2l0eSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gYmVjYXVzZSBzb21ldGltZXMgd2UgbmVlZCBoYXNoIHJpZ2h0IG5vdyBhbmQgbGl0dGxlIGxhdGVyXG4gIEtlY2Nhay5wcm90b3R5cGUuX2Nsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbG9uZSA9IG5ldyBLZWNjYWsodGhpcy5fcmF0ZSwgdGhpcy5fY2FwYWNpdHksIHRoaXMuX2RlbGltaXRlZFN1ZmZpeCwgdGhpcy5faGFzaEJpdExlbmd0aCwgdGhpcy5fb3B0aW9ucylcbiAgICB0aGlzLl9zdGF0ZS5jb3B5KGNsb25lLl9zdGF0ZSlcbiAgICBjbG9uZS5fZmluYWxpemVkID0gdGhpcy5fZmluYWxpemVkXG5cbiAgICByZXR1cm4gY2xvbmVcbiAgfVxuXG4gIHJldHVybiBLZWNjYWtcbn1cbiIsIid1c2Ugc3RyaWN0J1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtlY2Nha1N0YXRlKSB7XG4gIGZ1bmN0aW9uIFNoYWtlIChyYXRlLCBjYXBhY2l0eSwgZGVsaW1pdGVkU3VmZml4LCBvcHRpb25zKSB7XG4gICAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucylcblxuICAgIHRoaXMuX3JhdGUgPSByYXRlXG4gICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eVxuICAgIHRoaXMuX2RlbGltaXRlZFN1ZmZpeCA9IGRlbGltaXRlZFN1ZmZpeFxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG5cbiAgICB0aGlzLl9zdGF0ZSA9IG5ldyBLZWNjYWtTdGF0ZSgpXG4gICAgdGhpcy5fc3RhdGUuaW5pdGlhbGl6ZShyYXRlLCBjYXBhY2l0eSlcbiAgICB0aGlzLl9maW5hbGl6ZWQgPSBmYWxzZVxuICB9XG5cbiAgaW5oZXJpdHMoU2hha2UsIFRyYW5zZm9ybSlcblxuICBTaGFrZS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGVycm9yID0gbnVsbFxuICAgIHRyeSB7XG4gICAgICB0aGlzLnVwZGF0ZShjaHVuaywgZW5jb2RpbmcpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnJvciA9IGVyclxuICAgIH1cblxuICAgIGNhbGxiYWNrKGVycm9yKVxuICB9XG5cbiAgU2hha2UucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uICgpIHt9XG5cbiAgU2hha2UucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICB0aGlzLnB1c2godGhpcy5zcXVlZXplKHNpemUpKVxuICB9XG5cbiAgU2hha2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZykge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpICYmIHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YSBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgYnVmZmVyJylcbiAgICBpZiAodGhpcy5fZmluYWxpemVkKSB0aHJvdyBuZXcgRXJyb3IoJ1NxdWVlemUgYWxyZWFkeSBjYWxsZWQnKVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgZW5jb2RpbmcpXG5cbiAgICB0aGlzLl9zdGF0ZS5hYnNvcmIoZGF0YSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBTaGFrZS5wcm90b3R5cGUuc3F1ZWV6ZSA9IGZ1bmN0aW9uIChkYXRhQnl0ZUxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgICBpZiAoIXRoaXMuX2ZpbmFsaXplZCkge1xuICAgICAgdGhpcy5fZmluYWxpemVkID0gdHJ1ZVxuICAgICAgdGhpcy5fc3RhdGUuYWJzb3JiTGFzdEZld0JpdHModGhpcy5fZGVsaW1pdGVkU3VmZml4KVxuICAgIH1cblxuICAgIHZhciBkYXRhID0gdGhpcy5fc3RhdGUuc3F1ZWV6ZShkYXRhQnl0ZUxlbmd0aClcbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkgZGF0YSA9IGRhdGEudG9TdHJpbmcoZW5jb2RpbmcpXG5cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgU2hha2UucHJvdG90eXBlLl9yZXNldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3N0YXRlLmluaXRpYWxpemUodGhpcy5fcmF0ZSwgdGhpcy5fY2FwYWNpdHkpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIFNoYWtlLnByb3RvdHlwZS5fY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNsb25lID0gbmV3IFNoYWtlKHRoaXMuX3JhdGUsIHRoaXMuX2NhcGFjaXR5LCB0aGlzLl9kZWxpbWl0ZWRTdWZmaXgsIHRoaXMuX29wdGlvbnMpXG4gICAgdGhpcy5fc3RhdGUuY29weShjbG9uZS5fc3RhdGUpXG4gICAgY2xvbmUuX2ZpbmFsaXplZCA9IHRoaXMuX2ZpbmFsaXplZFxuXG4gICAgcmV0dXJuIGNsb25lXG4gIH1cblxuICByZXR1cm4gU2hha2Vcbn1cbiIsIid1c2Ugc3RyaWN0J1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIga2VjY2FrU3RhdGUgPSByZXF1aXJlKCcuL2tlY2Nhay1zdGF0ZS11bnJvbGwnKVxuXG5mdW5jdGlvbiBLZWNjYWsgKCkge1xuICAvLyBtdWNoIGZhc3RlciB0aGFuIGBuZXcgQXJyYXkoNTApYFxuICB0aGlzLnN0YXRlID0gW1xuICAgIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMFxuICBdXG5cbiAgdGhpcy5ibG9ja1NpemUgPSBudWxsXG4gIHRoaXMuY291bnQgPSAwXG4gIHRoaXMuc3F1ZWV6aW5nID0gZmFsc2Vcbn1cblxuS2VjY2FrLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKHJhdGUsIGNhcGFjaXR5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNTA7ICsraSkgdGhpcy5zdGF0ZVtpXSA9IDBcbiAgdGhpcy5ibG9ja1NpemUgPSByYXRlIC8gOFxuICB0aGlzLmNvdW50ID0gMFxuICB0aGlzLnNxdWVlemluZyA9IGZhbHNlXG59XG5cbktlY2Nhay5wcm90b3R5cGUuYWJzb3JiID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgdGhpcy5zdGF0ZVt+fih0aGlzLmNvdW50IC8gNCldIF49IGRhdGFbaV0gPDwgKDggKiAodGhpcy5jb3VudCAlIDQpKVxuICAgIHRoaXMuY291bnQgKz0gMVxuICAgIGlmICh0aGlzLmNvdW50ID09PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAga2VjY2FrU3RhdGUucDE2MDAodGhpcy5zdGF0ZSlcbiAgICAgIHRoaXMuY291bnQgPSAwXG4gICAgfVxuICB9XG59XG5cbktlY2Nhay5wcm90b3R5cGUuYWJzb3JiTGFzdEZld0JpdHMgPSBmdW5jdGlvbiAoYml0cykge1xuICB0aGlzLnN0YXRlW35+KHRoaXMuY291bnQgLyA0KV0gXj0gYml0cyA8PCAoOCAqICh0aGlzLmNvdW50ICUgNCkpXG4gIGlmICgoYml0cyAmIDB4ODApICE9PSAwICYmIHRoaXMuY291bnQgPT09ICh0aGlzLmJsb2NrU2l6ZSAtIDEpKSBrZWNjYWtTdGF0ZS5wMTYwMCh0aGlzLnN0YXRlKVxuICB0aGlzLnN0YXRlW35+KCh0aGlzLmJsb2NrU2l6ZSAtIDEpIC8gNCldIF49IDB4ODAgPDwgKDggKiAoKHRoaXMuYmxvY2tTaXplIC0gMSkgJSA0KSlcbiAga2VjY2FrU3RhdGUucDE2MDAodGhpcy5zdGF0ZSlcbiAgdGhpcy5jb3VudCA9IDBcbiAgdGhpcy5zcXVlZXppbmcgPSB0cnVlXG59XG5cbktlY2Nhay5wcm90b3R5cGUuc3F1ZWV6ZSA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgaWYgKCF0aGlzLnNxdWVlemluZykgdGhpcy5hYnNvcmJMYXN0RmV3Qml0cygweDAxKVxuXG4gIHZhciBvdXRwdXQgPSBCdWZmZXIuYWxsb2MobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgb3V0cHV0W2ldID0gKHRoaXMuc3RhdGVbfn4odGhpcy5jb3VudCAvIDQpXSA+Pj4gKDggKiAodGhpcy5jb3VudCAlIDQpKSkgJiAweGZmXG4gICAgdGhpcy5jb3VudCArPSAxXG4gICAgaWYgKHRoaXMuY291bnQgPT09IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgICBrZWNjYWtTdGF0ZS5wMTYwMCh0aGlzLnN0YXRlKVxuICAgICAgdGhpcy5jb3VudCA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0XG59XG5cbktlY2Nhay5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNTA7ICsraSkgZGVzdC5zdGF0ZVtpXSA9IHRoaXMuc3RhdGVbaV1cbiAgZGVzdC5ibG9ja1NpemUgPSB0aGlzLmJsb2NrU2l6ZVxuICBkZXN0LmNvdW50ID0gdGhpcy5jb3VudFxuICBkZXN0LnNxdWVlemluZyA9IHRoaXMuc3F1ZWV6aW5nXG59XG5cbm1vZHVsZS5leHBvcnRzID0gS2VjY2FrXG4iLCIndXNlIHN0cmljdCdcbnZhciBjcmVhdGVLZWNjYWsgPSByZXF1aXJlKCcuL2tlY2NhaycpXG52YXIgY3JlYXRlU2hha2UgPSByZXF1aXJlKCcuL3NoYWtlJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS2VjY2FrU3RhdGUpIHtcbiAgdmFyIEtlY2NhayA9IGNyZWF0ZUtlY2NhayhLZWNjYWtTdGF0ZSlcbiAgdmFyIFNoYWtlID0gY3JlYXRlU2hha2UoS2VjY2FrU3RhdGUpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChhbGdvcml0aG0sIG9wdGlvbnMpIHtcbiAgICB2YXIgaGFzaCA9IHR5cGVvZiBhbGdvcml0aG0gPT09ICdzdHJpbmcnID8gYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCkgOiBhbGdvcml0aG1cbiAgICBzd2l0Y2ggKGhhc2gpIHtcbiAgICAgIGNhc2UgJ2tlY2NhazIyNCc6IHJldHVybiBuZXcgS2VjY2FrKDExNTIsIDQ0OCwgbnVsbCwgMjI0LCBvcHRpb25zKVxuICAgICAgY2FzZSAna2VjY2FrMjU2JzogcmV0dXJuIG5ldyBLZWNjYWsoMTA4OCwgNTEyLCBudWxsLCAyNTYsIG9wdGlvbnMpXG4gICAgICBjYXNlICdrZWNjYWszODQnOiByZXR1cm4gbmV3IEtlY2Nhayg4MzIsIDc2OCwgbnVsbCwgMzg0LCBvcHRpb25zKVxuICAgICAgY2FzZSAna2VjY2FrNTEyJzogcmV0dXJuIG5ldyBLZWNjYWsoNTc2LCAxMDI0LCBudWxsLCA1MTIsIG9wdGlvbnMpXG5cbiAgICAgIGNhc2UgJ3NoYTMtMjI0JzogcmV0dXJuIG5ldyBLZWNjYWsoMTE1MiwgNDQ4LCAweDA2LCAyMjQsIG9wdGlvbnMpXG4gICAgICBjYXNlICdzaGEzLTI1Nic6IHJldHVybiBuZXcgS2VjY2FrKDEwODgsIDUxMiwgMHgwNiwgMjU2LCBvcHRpb25zKVxuICAgICAgY2FzZSAnc2hhMy0zODQnOiByZXR1cm4gbmV3IEtlY2Nhayg4MzIsIDc2OCwgMHgwNiwgMzg0LCBvcHRpb25zKVxuICAgICAgY2FzZSAnc2hhMy01MTInOiByZXR1cm4gbmV3IEtlY2Nhayg1NzYsIDEwMjQsIDB4MDYsIDUxMiwgb3B0aW9ucylcblxuICAgICAgY2FzZSAnc2hha2UxMjgnOiByZXR1cm4gbmV3IFNoYWtlKDEzNDQsIDI1NiwgMHgxZiwgb3B0aW9ucylcbiAgICAgIGNhc2UgJ3NoYWtlMjU2JzogcmV0dXJuIG5ldyBTaGFrZSgxMDg4LCA1MTIsIDB4MWYsIG9wdGlvbnMpXG5cbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignSW52YWxkIGFsZ29yaXRobTogJyArIGFsZ29yaXRobSlcbiAgICB9XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZWNwMjU2azEgPSBleHBvcnRzLnJscCA9IGV4cG9ydHMuQk4gPSB2b2lkIDA7XG52YXIgc2VjcDI1NmsxID0gcmVxdWlyZSgnLi9zZWNwMjU2azF2My1hZGFwdGVyJyk7XG5leHBvcnRzLnNlY3AyNTZrMSA9IHNlY3AyNTZrMTtcbnZhciBldGhqc1V0aWwgPSByZXF1aXJlKCdldGhqcy11dGlsJyk7XG52YXIgQk4gPSByZXF1aXJlKFwiYm4uanNcIik7XG5leHBvcnRzLkJOID0gQk47XG52YXIgcmxwID0gcmVxdWlyZShcInJscFwiKTtcbmV4cG9ydHMucmxwID0gcmxwO1xuT2JqZWN0LmFzc2lnbihleHBvcnRzLCBldGhqc1V0aWwpO1xuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKSwgZXhwb3J0cyk7XG4vKipcbiAqIFB1YmxpYy1rZXkgY3J5cHRvZ3JhcGh5IChzZWNwMjU2azEpIGFuZCBhZGRyZXNzZXNcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FjY291bnRcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBIYXNoIGZ1bmN0aW9uc1xuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGFzaFwiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEVDRFNBIHNpZ25hdHVyZVxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2lnbmF0dXJlXCIpLCBleHBvcnRzKTtcbi8qKlxuICogVXRpbGl0aWVzIGZvciBtYW5pcHVsYXRpbmcgQnVmZmVycywgYnl0ZSBhcnJheXMsIGV0Yy5cbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2J5dGVzXCIpLCBleHBvcnRzKTtcbi8qKlxuICogRnVuY3Rpb24gZm9yIGRlZmluaW5pbmcgcHJvcGVydGllcyBvbiBhbiBvYmplY3RcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL29iamVjdFwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBtaW1lIHR5cGUgZm9yIHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnNwbGl0KC8gKjsgKi8pLnNoaWZ0KCk7XG59O1xuXG4vKipcbiAqIFJldHVybiBoZWFkZXIgZmllbGQgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnBhcmFtcyA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIuc3BsaXQoLyAqOyAqLykucmVkdWNlKGZ1bmN0aW9uKG9iaiwgc3RyKXtcbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoLyAqPSAqLyk7XG4gICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgdmFyIHZhbCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgICBpZiAoa2V5ICYmIHZhbCkgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBQYXJzZSBMaW5rIGhlYWRlciBmaWVsZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5wYXJzZUxpbmtzID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvICosICovKS5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBzdHIpe1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICo7ICovKTtcbiAgICB2YXIgdXJsID0gcGFydHNbMF0uc2xpY2UoMSwgLTEpO1xuICAgIHZhciByZWwgPSBwYXJ0c1sxXS5zcGxpdCgvICo9ICovKVsxXS5zbGljZSgxLCAtMSk7XG4gICAgb2JqW3JlbF0gPSB1cmw7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBTdHJpcCBjb250ZW50IHJlbGF0ZWQgZmllbGRzIGZyb20gYGhlYWRlcmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuY2xlYW5IZWFkZXIgPSBmdW5jdGlvbihoZWFkZXIsIGNoYW5nZXNPcmlnaW4pe1xuICBkZWxldGUgaGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgZGVsZXRlIGhlYWRlclsnY29udGVudC1sZW5ndGgnXTtcbiAgZGVsZXRlIGhlYWRlclsndHJhbnNmZXItZW5jb2RpbmcnXTtcbiAgZGVsZXRlIGhlYWRlclsnaG9zdCddO1xuICAvLyBzZWN1aXJ0eVxuICBpZiAoY2hhbmdlc09yaWdpbikge1xuICAgIGRlbGV0ZSBoZWFkZXJbJ2F1dGhvcml6YXRpb24nXTtcbiAgICBkZWxldGUgaGVhZGVyWydjb29raWUnXTtcbiAgfVxuICByZXR1cm4gaGVhZGVyO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBDaXJjdWxhciBTaGlmdCBSaWdodFxuICpcbiAqIEBleGFtcGxlXG4gKiBjaXJjdWxhclNoaWZ0UmlnaHQoWzEsMCwxLDEsMCwxXSkgPT4gWzEsMSwwLDEsMSwwXVxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NpcmN1bGFyX3NoaWZ0fVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGJpdHMgaW5wdXQgZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCBob3cgZmFyIHNob3VsZCBpdCBiZSBzaGlmdGVkXG4gKiBAcmV0dXJuIHtBcnJheX0gW1JPUiBiaXRzXVxuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKGJpdHMsIGFtb3VudCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBpZiAoYW1vdW50ID4gYml0cy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2hpZnQgYW1vdW50IGNhbuKAmXQgYmUgbGFyZ2VyIHRoYW4gYml0cyBhcnJheSBsZW5ndGgnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpdHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHJlc3VsdFsoaSArIGFtb3VudCkgJSBiaXRzLmxlbmd0aF0gPSBiaXRzW2ldO1xuICAgIHJldHVybiByZXN1bHQ7XG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBcHBsaWVzIHRoZSBBTkQgb3BlcmF0aW9uLCBleHBlY3RzIHR3byBhcnJheXMgb2YgdGhlIHNhbWUgc2l6ZSBhbmQgcmV0dXJucyBhIG5ldyBvbmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGFuZChbMSwwLDAsMCwxLDEsMCwxXSwgWzAsMSwxLDAsMCwxLDAsMF0pID0+IFswLDAsMCwwLDAsMSwwLDBdXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYml0czEgaW5wdXQgZGF0YVxuICogQHBhcmFtIHtBcnJheX0gYml0czIgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QXJyYXl9IFtiaXRzMSBBTkQgYml0czJdXG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoYml0czEsIGJpdHMyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYml0czEubGVuZ3RoOyBpKyspXG4gICAgICAgIHJlc3VsdFtpXSA9IChiaXRzMVtpXSAmIGJpdHMyW2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQ2lyY3VsYXIgU2hpZnQgTGVmdFxuICpcbiAqIEBleGFtcGxlXG4gKiBjaXJjdWxhclNoaWZ0TGVmdChbMSwwLDEsMSwwLDFdKSA9PiBbMCwxLDEsMCwxLDFdXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2lyY3VsYXJfc2hpZnR9XG4gKlxuICogQHBhcmFtIHtBcnJheX0gYml0cyBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IGhvdyBmYXIgc2hvdWxkIGl0IGJlIHNoaWZ0ZWRcbiAqIEByZXR1cm4ge0FycmF5fSBbUk9MIGJpdHNdXG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoYml0cywgYW1vdW50KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGlmIChhbW91bnQgPiBiaXRzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaGlmdCBhbW91bnQgY2Fu4oCZdCBiZSBsYXJnZXIgdGhhbiBiaXRzIGFycmF5IGxlbmd0aCcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYml0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVzdWx0WyhiaXRzLmxlbmd0aCArIGkgLSBhbW91bnQpICUgYml0cy5sZW5ndGhdID0gYml0c1tpXTtcbiAgICByZXR1cm4gcmVzdWx0O1xufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQXBwbGllcyB0aGUgTkFORCBvcGVyYXRpb24sIGV4cGVjdHMgdHdvIGFycmF5cyBvZiB0aGUgc2FtZSBzaXplIGFuZCByZXR1cm5zIGEgbmV3IG9uZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogbmFuZChbMSwwLDAsMCwxLDEsMCwxXSwgWzAsMSwxLDAsMCwxLDAsMF0pID0+IFsxLDEsMSwxLDEsMCwxLDFdXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYml0czEgaW5wdXQgZGF0YVxuICogQHBhcmFtIHtBcnJheX0gYml0czIgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QXJyYXl9IFtiaXRzMSBOQU5EIGJpdHMyXVxuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKGJpdHMxLCBiaXRzMikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpdHMxLmxlbmd0aDsgaSsrKVxuICAgICAgICByZXN1bHRbaV0gPSAoKGJpdHMxW2ldICYgYml0czJbaV0pIF4gMSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEZsaXBzIGFsbCBnaXZlbiBiaXRzIGFuZCByZXR1cm5zIHRoZSBmbGlwcGVkIGJpdHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIG5vdChbMSwwLDEsMSwwLDFdKSA9PiBbMCwxLDAsMCwxLDBdXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYml0cyBpbnB1dCBkYXRhXG4gKiBAcmV0dXJuIHtBcnJheX0gW05PVCBiaXRzXVxuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKGJpdHMpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaXRzLmxlbmd0aDsgaSsrKVxuICAgICAgICByZXN1bHRbaV0gPSAoYml0c1tpXSBeIDEpO1xuICAgIHJldHVybiByZXN1bHQ7XG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBcHBsaWVzIHRoZSBOT1Igb3BlcmF0aW9uLCBleHBlY3RzIHR3byBhcnJheXMgb2YgdGhlIHNhbWUgc2l6ZSBhbmQgcmV0dXJucyBhIG5ldyBvbmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIG5vcihbMSwwLDAsMCwxLDEsMCwxXSwgWzAsMSwxLDAsMCwxLDAsMF0pID0+IFswLDAsMCwxLDAsMCwxLDBdXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYml0czEgaW5wdXQgZGF0YVxuICogQHBhcmFtIHtBcnJheX0gYml0czIgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QXJyYXl9IFtiaXRzMSBOT1IgYml0czJdXG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoYml0czEsIGJpdHMyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYml0czEubGVuZ3RoOyBpKyspXG4gICAgICAgIHJlc3VsdFtpXSA9ICgoYml0czFbaV0gfCBiaXRzMltpXSkgXiAxKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQXBwbGllcyB0aGUgQU5EIG9wZXJhdGlvbiBvbiB0aGUgZ2l2ZW4gYml0cy4gUmV0dXJucyBvbmUgYml0LlxuICogVGhyb3dzIGlmIGxlc3MgdGhhbiAyIGJpdHMgYXJlIGdpdmVuLlxuICpcbiAqIEBleGFtcGxlXG4gKiByZWR1Y2VBbmQoWzEsIDAsIDAsIDAsIDEsIDEsIDAsIDFdKSA9PiAwXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYml0cyBpbnB1dCBkYXRhXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfSBBTkQgYml0c1xuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKGJpdHMpIHtcbiAgICBpZiAoYml0cy5sZW5ndGggPCAyKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTm90IGVub3VnaCBiaXRzLicpO1xuICAgIHZhciByZXN1bHQgPSBiaXRzWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYml0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVzdWx0ICY9IGJpdHNbaV07XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEFwcGxpZXMgdGhlIE9SIG9wZXJhdGlvbiwgZXhwZWN0cyB0d28gYXJyYXlzIG9mIHRoZSBzYW1lIHNpemUgYW5kIHJldHVybnMgYSBuZXcgb25lLlxuICpcbiAqIEBleGFtcGxlXG4gKiBvcihbMSwwLDAsMCwxLDEsMCwxXSwgWzAsMSwxLDAsMCwxLDAsMF0pID0+IFsxLDEsMSwwLDEsMSwwLDFdXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYml0czEgaW5wdXQgZGF0YVxuICogQHBhcmFtIHtBcnJheX0gYml0czIgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QXJyYXl9IFtiaXRzMSBPUiBiaXRzMl1cbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uIChiaXRzMSwgYml0czIpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaXRzMS5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVzdWx0W2ldID0gKGJpdHMxW2ldIHwgYml0czJbaV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBcHBsaWVzIHRoZSBOQU5EIG9wZXJhdGlvbiBvbiB0aGUgZ2l2ZW4gYml0cy4gUmV0dXJucyBvbmUgYml0LlxuICogVGhyb3dzIGlmIGxlc3MgdGhhbiAyIGJpdHMgYXJlIGdpdmVuLlxuICpcbiAqIEBleGFtcGxlXG4gKiByZWR1Y2VOYW5kKFsxLCAwLCAwLCAwLCAxLCAxLCAwLCAxXSkgPT4gMFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGJpdHMgaW5wdXQgZGF0YVxuICogQHJldHVybiB7SW50ZWdlcn0gTkFORCBiaXRzXG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoYml0cykge1xuICAgIGlmIChiaXRzLmxlbmd0aCA8IDIpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdOb3QgZW5vdWdoIGJpdHMuJyk7XG4gICAgdmFyIHJlc3VsdCA9IGJpdHNbMF07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiaXRzLmxlbmd0aDsgaSsrKVxuICAgICAgICByZXN1bHQgPSAoKHJlc3VsdCAmIGJpdHNbaV0pIF4gMSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEFwcGxpZXMgdGhlIE5PUiBvcGVyYXRpb24gb24gdGhlIGdpdmVuIGJpdHMuIFJldHVybnMgb25lIGJpdC5cbiAqIFRocm93cyBpZiBsZXNzIHRoYW4gMiBiaXRzIGFyZSBnaXZlbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogcmVkdWNlTm9yKFsxLCAwLCAwLCAwLCAxLCAxLCAwLCAxXSkgPT4gMFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGJpdHMgaW5wdXQgZGF0YVxuICogQHJldHVybiB7SW50ZWdlcn0gTk9SIGJpdHNcbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uIChiaXRzKSB7XG4gICAgaWYgKGJpdHMubGVuZ3RoIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ05vdCBlbm91Z2ggYml0cy4nKTtcbiAgICB2YXIgcmVzdWx0ID0gYml0c1swXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGJpdHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHJlc3VsdCA9ICgocmVzdWx0IHwgYml0c1tpXSkgXiAxKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQXBwbGllcyB0aGUgT1Igb3BlcmF0aW9uIG9uIHRoZSBnaXZlbiBiaXRzLiBSZXR1cm5zIG9uZSBiaXQuXG4gKiBUaHJvd3MgaWYgbGVzcyB0aGFuIDIgYml0cyBhcmUgZ2l2ZW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIHJlZHVjZU9yKFsxLCAwLCAwLCAwLCAxLCAxLCAwLCAxXSkgPT4gMVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGJpdHMgaW5wdXQgZGF0YVxuICogQHJldHVybiB7SW50ZWdlcn0gT1IgYml0c1xuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKGJpdHMpIHtcbiAgICBpZiAoYml0cy5sZW5ndGggPCAyKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTm90IGVub3VnaCBiaXRzLicpO1xuICAgIHZhciByZXN1bHQgPSBiaXRzWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYml0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVzdWx0IHw9IGJpdHNbaV07XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEFwcGxpZXMgdGhlIFhOT1Igb3BlcmF0aW9uIG9uIHRoZSBnaXZlbiBiaXRzLiBSZXR1cm5zIG9uZSBiaXQuXG4gKiBUaHJvd3MgaWYgbGVzcyB0aGFuIDIgYml0cyBhcmUgZ2l2ZW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIHJlZHVjZVhub3IoWzEsIDAsIDAsIDAsIDEsIDEsIDAsIDFdKSA9PiAxXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYml0cyBpbnB1dCBkYXRhXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfSBYTk9SIGJpdHNcbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uIChiaXRzKSB7XG4gICAgaWYgKGJpdHMubGVuZ3RoIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ05vdCBlbm91Z2ggYml0cy4nKTtcbiAgICB2YXIgcmVzdWx0ID0gYml0c1swXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGJpdHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHJlc3VsdCBePSBiaXRzW2ldIF4gMTtcbiAgICByZXR1cm4gcmVzdWx0O1xufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQXBwbGllcyB0aGUgWE9SIG9wZXJhdGlvbiBvbiB0aGUgZ2l2ZW4gYml0cy4gUmV0dXJucyBvbmUgYml0LlxuICogVGhyb3dzIGlmIGxlc3MgdGhhbiAyIGJpdHMgYXJlIGdpdmVuLlxuICpcbiAqIEBleGFtcGxlXG4gKiByZWR1Y2VYb3IoWzEsIDAsIDAsIDAsIDEsIDEsIDAsIDFdKSA9PiAwXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYml0cyBpbnB1dCBkYXRhXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfSBYT1IgYml0c1xuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKGJpdHMpIHtcbiAgICBpZiAoYml0cy5sZW5ndGggPCAyKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTm90IGVub3VnaCBiaXRzLicpO1xuICAgIHZhciByZXN1bHQgPSBiaXRzWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYml0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVzdWx0IF49IGJpdHNbaV07XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIENvbnZlcnRzIGEgYml0IGFycmF5IHRvIGEgYm9vbGVhbiBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZSB0b0Jvb2xlYW4oWzAsIDFdKSA9PiBbZmFsc2UsIHRydWVdXG4gKiBAcGFyYW0ge0FycmF5fSBiaXRzIGlucHV0IGRhdGFcbiAqIEByZXR1cm5zIHtBcnJheX0gYm9vbGVhbiBiaXRzXG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoYml0cykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpdHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHJlc3VsdFtpXSA9IGJpdHNbaV0gPT09IDE7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIENvbnZlcnRzIGEgYml0IGFycmF5IHRvIGEgc3RyaW5nLiBJZiBkZWZpbmVkLCBpbnNlcnRzIHNwYWNlciBldmVyeSBzcGFjaW5nIGNoYXJhY3RlcnMsIGJ1dCBuZXZlciBpbnNlcnRzIGl0IGFzIHRoZSBsYXN0IHN1YnN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogdG9TdHJpbmcoWzEsMCwxLDAsMSwwXSwgMiwgJ18nKSA9PiAnMTBfMTBfMTAnXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYml0cyB0aGUgYml0cyB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge051bWJlcn0gc3BhY2luZyB3aGVyZSB0byBwbGFjZSB0aGUgc3BhY2Vyc1xuICogQHBhcmFtIHtOdW1iZXJ9IHNwYWNlciB0aGUgc3RyaW5nIHVzZWQgYXMgYSBzcGFjZXJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uIChiaXRzLCBzcGFjaW5nLCBzcGFjZXIpIHtcbiAgICBpZiAoc3BhY2luZyA9PT0gdm9pZCAwKSB7IHNwYWNpbmcgPSAwOyB9XG4gICAgaWYgKHNwYWNlciA9PT0gdm9pZCAwKSB7IHNwYWNlciA9ICcgJzsgfVxuICAgIGlmICghc3BhY2luZylcbiAgICAgICAgcmV0dXJuIGJpdHMuam9pbignJyk7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYml0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gXCJcIiArIGJpdHNbaV07XG4gICAgICAgIGlmIChpICUgc3BhY2luZyA9PT0gc3BhY2luZyAtIDEgJiYgaSAhPT0gYml0cy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgcmVzdWx0ICs9IHNwYWNlcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEFwcGxpZXMgdGhlIGV4Y2x1c2l2ZSBOT1Igb3BlcmF0aW9uLCBleHBlY3RzIHR3byBhcnJheXMgb2YgdGhlIHNhbWUgc2l6ZSBhbmQgcmV0dXJucyBhIG5ldyBvbmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIHhub3IoWzEsMCwwLDAsMSwxLDAsMV0sIFswLDEsMSwwLDAsMSwwLDBdKSA9PiBbMCwwLDAsMSwwLDEsMSwwXVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGJpdHMxIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7QXJyYXl9IGJpdHMyIGlucHV0IGRhdGFcbiAqIEByZXR1cm4ge0FycmF5fSBbYml0czEgWE5PUiBiaXRzMl1cbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uIChiaXRzMSwgYml0czIpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaXRzMS5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVzdWx0W2ldID0gKGJpdHMxW2ldIF4gYml0czJbaV0gXiAxKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQXBwbGllcyB0aGUgZXhjbHVzaXZlIG9yIG9wZXJhdGlvbiwgZXhwZWN0cyB0d28gYXJyYXlzIG9mIHRoZSBzYW1lIHNpemUgYW5kIHJldHVybnMgYSBuZXcgb25lLlxuICpcbiAqIEBleGFtcGxlXG4gKiB4b3IoWzEsMCwwLDAsMSwxLDAsMV0sIFswLDEsMSwwLDAsMSwwLDBdKSA9PiBbMSwxLDEsMCwxLDAsMCwxXVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGJpdHMxIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7QXJyYXl9IGJpdHMyIGlucHV0IGRhdGFcbiAqIEByZXR1cm4ge0FycmF5fSBbYml0czEgWE9SIGJpdHMyXVxuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKGJpdHMxLCBiaXRzMikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpdHMxLmxlbmd0aDsgaSsrKVxuICAgICAgICByZXN1bHRbaV0gPSAoYml0czFbaV0gXiBiaXRzMltpXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIG9mIGEgc3BlY2lmaWMgYml0LlxuICogQGV4YW1wbGUgYml0d2lzZS5pbnRlZ2VyLmdldEJpdCgxMjgsIDcpID0+IDFcbiAqIEBwYXJhbSB7SW50ZWdlcn0gaW50MzIgaW5wdXQgbnVtYmVyXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHBvc2l0aW9uIGJpdCdzIHBvc2l0aW9uXG4gKiBAcmV0dXJucyB7SW50ZWdlcn0gYml0J3MgdmFsdWVcbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uIChpbnQzMiwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gKChpbnQzMiA+PiBwb3NpdGlvbikgJiAxKTtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIGEgc3BlY2lmaWMgYml0LlxuICogQGV4YW1wbGUgYml0d2lzZS5pbnRlZ2VyLnNldCgxMjgsIDcsIDApID0+IDBcbiAqIEBwYXJhbSB7SW50ZWdlcn0gaW50MzIgaW5wdXQgbnVtYmVyXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHBvc2l0aW9uIGJpdOKAmXMgcG9zaXRpb25cbiAqIEBwYXJhbSB7SW50ZWdlcn0gdmFsdWUgYml04oCZcyBuZXcgdmFsdWVcbiAqIEByZXR1cm5zIHtJbnRlZ2VyfSByZXN1bHRpbmcgbnVtYmVyXG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoaW50MzIsIHBvc2l0aW9uLCB2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgPT09IDEgPyBpbnQzMiB8ICgxIDw8IHBvc2l0aW9uKSA6IGludDMyICYgfigxIDw8IHBvc2l0aW9uKSk7XG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBUb2dnbGVzIGEgc3BlY2lmaWMgYml0LlxuICogQGV4YW1wbGUgYml0d2lzZS5pbnRlZ2VyLmdldEJpdCgxMjgsIDcpID0+IDBcbiAqIEBwYXJhbSB7SW50ZWdlcn0gaW50MzIgaW5wdXQgbnVtYmVyXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHBvc2l0aW9uIGJpdOKAmXMgcG9zaXRpb25cbiAqIEByZXR1cm5zIHtJbnRlZ2VyfSB1cGRhdGVkIG51bWJlclxuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKGludDMyLCBwb3NpdGlvbikgeyByZXR1cm4gaW50MzIgXiAoMSA8PCBwb3NpdGlvbik7IH0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFJldHVybnMgYW4gQXJyYXkgb2YgbGVuZ3RoIDggY29udGFpbmluZyB0aGUgcmVhZCBiaXRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBieXRlLnJlYWQoNDIpID0+IFswLDAsMSwwLDEsMCwxLDBdXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGJ5dGUgb25lIGJ5dGVcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKGJ5dGUpIHtcbiAgICBpZiAoYnl0ZSA+IDI1NSB8fCBieXRlIDwgMCB8fCB+fmJ5dGUgIT09IGJ5dGUpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbnZhbGlkIGJ5dGUnKTtcbiAgICB2YXIgcmVzdWx0ID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKVxuICAgICAgICByZXN1bHRbNyAtIGldID0gKChieXRlID4+IGkpICYgMSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFJldHVybnMgYSBVSW50OCAoMC0yNTUpIHdoaWNoIGVxdWFscyB0aGUgZ2l2ZW4gYml0cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYnl0ZS53cml0ZShbMCwwLDEsMCwxLDAsMSwwXSkgPT4gNDJcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBieXRlIDggYml0c1xuICogQHJldHVybiB7TnVtYmVyfSA4LWJpdCB1bnNpZ25lZCBpbnRlZ2VyXG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoYnl0ZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShieXRlKSB8fCBieXRlLmxlbmd0aCAhPT0gOClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2ludmFsaWQgYXJyYXkgbGVuZ3RoJyk7XG4gICAgdmFyIGRhdGEgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKVxuICAgICAgICBpZiAoYnl0ZVs3IC0gaV0pXG4gICAgICAgICAgICBkYXRhIHw9IDEgPDwgaTtcbiAgICByZXR1cm4gZGF0YTtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgYml0cy4gSWdub3JlcyBhbGwgY2hhcmFjdGVycyBleGNlcHQgMSBhbmQgMC5cbiAqXG4gKiBAZXhhbXBsZVxuICogdG9CaXRzKCcxMCAxMCAxMiQlXy4wJykgPT4gWzEsMCwxLDAsMSwwXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgdGhlIHN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7QXJyYXl9IHJlc3VsdGluZyBhcnJheSBvZiBiaXRzXG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHJpbmdbaV0gPT09ICcxJylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKDEpO1xuICAgICAgICBlbHNlIGlmIChzdHJpbmdbaV0gPT09ICcwJylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKDApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogUmV0dXJucyBhbiBBcnJheSBvZiBsZW5ndGggOCBjb250YWluaW5nIHRoZSByZWFkIGJpdHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIG5pYmJsZS5yZWFkKDE1KSA9PiBbMSwxLDEsMV1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbmliYmxlIG9uZSBuaWJibGVcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKG5pYmJsZSkge1xuICAgIGlmIChuaWJibGUgPCAxNiAmJiBuaWJibGUgPj0gMCAmJiBNYXRoLmZsb29yKG5pYmJsZSkgPT09IG5pYmJsZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdFszIC0gaV0gPSAoKG5pYmJsZSA+PiBpKSAmIDEpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbnZhbGlkIGFycmF5IGxlbmd0aCcpO1xufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogUmV0dXJucyBhIE5pYmJsZSAoMC0xNSkgd2hpY2ggZXF1YWxzIHRoZSBnaXZlbiBiaXRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBieXRlLndyaXRlKFsxLDAsMSwwXSkgPT4gMTBcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBuaWJibGUgNC1iaXQgdW5zaWduZWQgaW50ZWdlclxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKG5pYmJsZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShuaWJibGUpIHx8IG5pYmJsZS5sZW5ndGggIT09IDQpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbnZhbGlkIGFycmF5IGxlbmd0aCcpO1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgICBpZiAobmliYmxlWzMgLSBpXSlcbiAgICAgICAgICAgIHJlc3VsdCB8PSAxIDw8IGk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEFwcGxpZXMgYSBiaXR3aXNlIEFORCB0byB0aGUgY29udGVudHMgb2YgdHdvIGJ1ZmZlcnMuIFJldHVybnMgYSBuZXcgYnVmZmVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBiaXR3aXNlLmJ1ZmZlci5hbmQoYSwgYiwgZmFsc2UpID0+IEJ1ZmZlcihhIEFORCBiKVxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBhIGZpcnN0IGJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ9IGIgc2Vjb25kIGJ1ZmZlclxuICogQHBhcmFtIHtCb29sZWFufSBpc0xvb3BpbmcgbG9vcCB0aHJvdWdoIGZpcnN0IGJ1ZmZlclxuICogQHJldHVybiB7QnVmZmVyfSBhIEFORCBiXG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoYSwgYiwgaXNMb29waW5nKSB7XG4gICAgaWYgKGlzTG9vcGluZyA9PT0gdm9pZCAwKSB7IGlzTG9vcGluZyA9IGZhbHNlOyB9XG4gICAgdmFyIGxlbmd0aCA9IGlzTG9vcGluZyA/IGIubGVuZ3RoIDogYS5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5hbGxvYyhsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGogPSBpc0xvb3BpbmcgPyBpICUgYS5sZW5ndGggOiBpO1xuICAgICAgICByZXN1bHRbaV0gPSBhW2pdICYgYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEFwcGxpZXMgYSBiaXR3aXNlIE5BTkQgdG8gdGhlIGNvbnRlbnRzIG9mIHR3byBidWZmZXJzLiBSZXR1cm5zIGEgbmV3IGJ1ZmZlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYml0d2lzZS5idWZmZXIubmFuZChhLCBiLCBmYWxzZSkgPT4gQnVmZmVyKGEgTkFORCBiKVxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBhIGZpcnN0IGJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ9IGIgc2Vjb25kIGJ1ZmZlclxuICogQHBhcmFtIHtCb29sZWFufSBpc0xvb3BpbmcgbG9vcCB0aHJvdWdoIGZpcnN0IGJ1ZmZlclxuICogQHJldHVybiB7QnVmZmVyfSBhIE5BTkQgYlxuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKGEsIGIsIGlzTG9vcGluZykge1xuICAgIGlmIChpc0xvb3BpbmcgPT09IHZvaWQgMCkgeyBpc0xvb3BpbmcgPSBmYWxzZTsgfVxuICAgIHZhciBsZW5ndGggPSBpc0xvb3BpbmcgPyBiLmxlbmd0aCA6IGEubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBCdWZmZXIuYWxsb2MobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBqID0gaXNMb29waW5nID8gaSAlIGEubGVuZ3RoIDogaTtcbiAgICAgICAgcmVzdWx0W2ldID0gfihhW2pdICYgYltpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBcHBsaWVzIGEgYml0d2lzZSBOT1IgdG8gdGhlIGNvbnRlbnRzIG9mIHR3byBidWZmZXJzLiBSZXR1cm5zIGEgbmV3IGJ1ZmZlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYml0d2lzZS5idWZmZXIubm9yKGEsIGIsIGZhbHNlKSA9PiBCdWZmZXIoYSBOT1IgYilcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYSBmaXJzdCBidWZmZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBiIHNlY29uZCBidWZmZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNMb29waW5nIGxvb3AgdGhyb3VnaCBmaXJzdCBidWZmZXJcbiAqIEByZXR1cm4ge0J1ZmZlcn0gYSBOT1IgYlxuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKGEsIGIsIGlzTG9vcGluZykge1xuICAgIGlmIChpc0xvb3BpbmcgPT09IHZvaWQgMCkgeyBpc0xvb3BpbmcgPSBmYWxzZTsgfVxuICAgIHZhciBsZW5ndGggPSBpc0xvb3BpbmcgPyBiLmxlbmd0aCA6IGEubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBCdWZmZXIuYWxsb2MobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBqID0gaXNMb29waW5nID8gaSAlIGEubGVuZ3RoIDogaTtcbiAgICAgICAgcmVzdWx0W2ldID0gfihhW2pdIHwgYltpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBcHBsaWVzIGEgYml0d2lzZSBOT1QgdG8gdGhlIGNvbnRlbnRzIG9mIGEgYnVmZmVyLiBSZXR1cm5zIGEgbmV3IGJ1ZmZlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYml0d2lzZS5idWZmZXIubm90KGJ1ZmZlcikgPT4gQnVmZmVyKE5PVCBidWZmZXIpXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBpbnB1dCBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9IEJ1ZmZlcihOT1QgYnVmZmVyKVxuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgIHZhciByZXN1bHQgPSBCdWZmZXIuYWxsb2MoYnVmZmVyLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspXG4gICAgICAgIHJlc3VsdFtpXSA9IH5idWZmZXJbaV07XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEFwcGxpZXMgYSBiaXR3aXNlIE9SIHRvIHRoZSBjb250ZW50cyBvZiB0d28gYnVmZmVycy4gUmV0dXJucyBhIG5ldyBidWZmZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGJpdHdpc2UuYnVmZmVyLm9yKGEsIGIsIGZhbHNlKSA9PiBCdWZmZXIoYSBPUiBiKVxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBhIGZpcnN0IGJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ9IGIgc2Vjb25kIGJ1ZmZlclxuICogQHBhcmFtIHtCb29sZWFufSBpc0xvb3BpbmcgbG9vcCB0aHJvdWdoIGZpcnN0IGJ1ZmZlclxuICogQHJldHVybiB7QnVmZmVyfSBhIE9SIGJcbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uIChhLCBiLCBpc0xvb3BpbmcpIHtcbiAgICBpZiAoaXNMb29waW5nID09PSB2b2lkIDApIHsgaXNMb29waW5nID0gZmFsc2U7IH1cbiAgICB2YXIgbGVuZ3RoID0gaXNMb29waW5nID8gYi5sZW5ndGggOiBhLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gQnVmZmVyLmFsbG9jKGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaiA9IGlzTG9vcGluZyA/IGkgJSBhLmxlbmd0aCA6IGk7XG4gICAgICAgIHJlc3VsdFtpXSA9IGFbal0gfCBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQXBwbGllcyBhIGJpdHdpc2UgWE5PUiB0byB0aGUgY29udGVudHMgb2YgdHdvIGJ1ZmZlcnMuIFJldHVybnMgYSBuZXcgYnVmZmVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBiaXR3aXNlLmJ1ZmZlci54bm9yKGEsIGIsIGZhbHNlKSA9PiBCdWZmZXIoYSBYTk9SIGIpXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGEgZmlyc3QgYnVmZmVyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYiBzZWNvbmQgYnVmZmVyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzTG9vcGluZyBsb29wIHRocm91Z2ggZmlyc3QgYnVmZmVyXG4gKiBAcmV0dXJuIHtCdWZmZXJ9IGEgWE5PUiBiXG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoYSwgYiwgaXNMb29waW5nKSB7XG4gICAgaWYgKGlzTG9vcGluZyA9PT0gdm9pZCAwKSB7IGlzTG9vcGluZyA9IGZhbHNlOyB9XG4gICAgdmFyIGxlbmd0aCA9IGlzTG9vcGluZyA/IGIubGVuZ3RoIDogYS5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5hbGxvYyhsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGogPSBpc0xvb3BpbmcgPyBpICUgYS5sZW5ndGggOiBpO1xuICAgICAgICByZXN1bHRbaV0gPSB+KGFbal0gXiBiW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEFwcGxpZXMgYSBiaXR3aXNlIFhPUiB0byB0aGUgY29udGVudHMgb2YgdHdvIGJ1ZmZlcnMuIFJldHVybnMgYSBuZXcgYnVmZmVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBiaXR3aXNlLmJ1ZmZlci54b3IoYSwgYiwgZmFsc2UpID0+IEJ1ZmZlcihhIFhPUiBiKVxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBhIGZpcnN0IGJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ9IGIgc2Vjb25kIGJ1ZmZlclxuICogQHBhcmFtIHtCb29sZWFufSBpc0xvb3BpbmcgbG9vcCB0aHJvdWdoIGZpcnN0IGJ1ZmZlclxuICogQHJldHVybiB7QnVmZmVyfSBhIFhPUiBiXG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoYSwgYiwgaXNMb29waW5nKSB7XG4gICAgaWYgKGlzTG9vcGluZyA9PT0gdm9pZCAwKSB7IGlzTG9vcGluZyA9IGZhbHNlOyB9XG4gICAgdmFyIGxlbmd0aCA9IGlzTG9vcGluZyA/IGIubGVuZ3RoIDogYS5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5hbGxvYyhsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGogPSBpc0xvb3BpbmcgPyBpICUgYS5sZW5ndGggOiBpO1xuICAgICAgICByZXN1bHRbaV0gPSBhW2pdIF4gYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd3JpdGVfMSA9IHJlcXVpcmUoXCIuLi9ieXRlL3dyaXRlXCIpO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGJ1ZmZlciBhbmQgd3JpdGVzIHRoZSBnaXZlbiBiaXRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjcmVhdGVCdWZmZXIoWzEsMSwxLDEsIDAsMCwwLDEsIDEsMCwxLDBdKSA9PiBidWZmZXIgd2l0aCBkYXRhIDExMTEgMDAwMSAxMDEwIDAwMDBcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBiaXRzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGJpdHMgdG8gaW5zZXJ0XG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKGJpdHMpIHtcbiAgICB2YXIgZGF0YSA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKE1hdGguY2VpbChiaXRzLmxlbmd0aCAvIDgpKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xuICAgICAgICAgICAgaWYgKGJpdHNbaSAqIDggKyBqXSlcbiAgICAgICAgICAgICAgICBkYXRhW2pdID0gYml0c1tpICogOCArIGpdO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRhdGFbal0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlcltpXSA9IHdyaXRlXzEuZGVmYXVsdChkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd3JpdGVfMSA9IHJlcXVpcmUoXCIuLi9ieXRlL3dyaXRlXCIpO1xudmFyIHJlYWRfMSA9IHJlcXVpcmUoXCIuL3JlYWRcIik7XG4vKipcbiAqIE1vZGlmaWVzIHRoZSBidWZmZXIncyBiaXRzIHRvIGVxdWFsIG5ld0JpdHMgc3RhcnRpbmcgYXQgYml0T2Zmc2V0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBtb2RpZnlCdWZmZXIoYnVmZmVyLCBbMCwwLDEsMF0sIDApID0+IGJ1ZmZlciB3YXMgbW9kaWZpZWRcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIHRoZSBidWZmZXIgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge0FycmF5fSBiaXRzIHRoZSBiaXRzIHRvIGluc2VydFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCB3aGVyZSB0byBzdGFydCAoaW4gYml0cylcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoYnVmZmVyLCBiaXRzLCBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gMDsgfVxuICAgIHZhciBzdGFydCA9IE1hdGguZmxvb3Iob2Zmc2V0IC8gOCk7XG4gICAgdmFyIGVuZCA9IE1hdGguY2VpbCgob2Zmc2V0ICsgYml0cy5sZW5ndGgpIC8gOCk7XG4gICAgdmFyIHN1YkJ1ZmZlciA9IGJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICB2YXIgYnl0ZURhdGEgPSByZWFkXzEuZGVmYXVsdChzdWJCdWZmZXIpO1xuICAgIHZhciBzdWJPZmZzZXQgPSBvZmZzZXQgJSA4O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYml0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgYnl0ZURhdGFbc3ViT2Zmc2V0KytdID0gYml0c1tpXTtcbiAgICB2YXIgbGVuZ3RoID0gZW5kIC0gc3RhcnQ7XG4gICAgZm9yICh2YXIgaV8xID0gMDsgaV8xIDwgbGVuZ3RoOyBpXzErKylcbiAgICAgICAgc3ViQnVmZmVyW2lfMV0gPSB3cml0ZV8xLmRlZmF1bHQoYnl0ZURhdGEuc2xpY2UoaV8xICogOCwgKGlfMSArIDEpICogOCkpO1xufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciByZWFkXzEgPSByZXF1aXJlKFwiLi4vYnl0ZS9yZWFkXCIpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIEFycmF5IGNvbnRhaW5pbmcgYml0TGVuZ3RoIGJpdHMgc3RhcnRpbmcgYXQgYml0T2Zmc2V0LlxuICpcbiAqIEBleGFtcGxlXG4gKiByZWFkQnVmZmVyKGJ1ZmZlciwgMiwgNCkgPT4gWzAsMCwxLDBdXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciB0aGUgYnVmZmVyIHRvIHJlYWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgd2hlcmUgdG8gc3RhcnQgKGluIGJpdHMpXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIGhvdyBtYW55IGJpdHMgdG8gcmVhZFxuICogQHJldHVybnMge0FycmF5fVxuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gMDsgfVxuICAgIGlmICghbGVuZ3RoKVxuICAgICAgICBsZW5ndGggPSBidWZmZXIubGVuZ3RoICogOCAtIG9mZnNldDtcbiAgICB2YXIgc3RhcnQgPSBNYXRoLmZsb29yKG9mZnNldCAvIDgpO1xuICAgIHZhciBieXRlc1RvUmVhZCA9IE1hdGguZmxvb3IobGVuZ3RoIC8gOCkgKyAyO1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICBhcnIubGVuZ3RoID0gYnl0ZXNUb1JlYWQgKiA4O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXNUb1JlYWQ7IGkrKykge1xuICAgICAgICB2YXIgdG9SZWFkID0gYnVmZmVyW3N0YXJ0ICsgaV07XG4gICAgICAgIGlmICh0b1JlYWQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB2YXIgYml0cyA9IHJlYWRfMS5kZWZhdWx0KGJ1ZmZlcltzdGFydCArIGldKTtcbiAgICAgICAgYXJyW2kgKiA4XSA9IGJpdHNbMF07XG4gICAgICAgIGFycltpICogOCArIDFdID0gYml0c1sxXTtcbiAgICAgICAgYXJyW2kgKiA4ICsgMl0gPSBiaXRzWzJdO1xuICAgICAgICBhcnJbaSAqIDggKyAzXSA9IGJpdHNbM107XG4gICAgICAgIGFycltpICogOCArIDRdID0gYml0c1s0XTtcbiAgICAgICAgYXJyW2kgKiA4ICsgNV0gPSBiaXRzWzVdO1xuICAgICAgICBhcnJbaSAqIDggKyA2XSA9IGJpdHNbNl07XG4gICAgICAgIGFycltpICogOCArIDddID0gYml0c1s3XTtcbiAgICB9XG4gICAgdmFyIHN1Yk9mZnNldCA9IG9mZnNldCAlIDg7XG4gICAgcmV0dXJuIGFyci5zbGljZShzdWJPZmZzZXQsIHN1Yk9mZnNldCArIGxlbmd0aCk7XG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxpdGllc18xID0gcmVxdWlyZShcIi4uL3V0aWxpdGllc1wiKTtcbnZhciByZWFkXzEgPSByZXF1aXJlKFwiLi9yZWFkXCIpO1xuLyoqXG4gKiBDb252ZXJ0cyBhIHNlY3Rpb24gb2YgYSBidWZmZXIgdG8gYW4gdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gYnVmZmVyIDExMTEwMTEwXG4gKiByZWFkVUludChidWZmZXIsIDMsIDUpID0+IDIyXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciB0aGUgYnVmZmVyIHRvIGV4dHJhY3QgaW5mb3JtYXRpb24gZnJvbVxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCB0aGUgbGVuZ3RoIG9mIHRoZSB1bnNpZ25lZCBpbnRlZ2VyIChpbiBiaXRzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCB3aGVyZSB0byBzdGFydCAoaW4gYml0cylcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSAwOyB9XG4gICAgaWYgKGxlbmd0aCA9PT0gdm9pZCAwKSB7IGxlbmd0aCA9IDg7IH1cbiAgICB2YXIgYXJyID0gcmVhZF8xLmRlZmF1bHQoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgcmVzdWx0ICs9IGFycltpXSAqIHV0aWxpdGllc18xLnAyW2xlbmd0aCAtIGkgLSAxXTtcbiAgICByZXR1cm4gcmVzdWx0O1xufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi91dGlsaXRpZXNcIik7XG52YXIgbm90XzEgPSByZXF1aXJlKFwiLi4vYml0cy9ub3RcIik7XG52YXIgcmVhZF8xID0gcmVxdWlyZShcIi4vcmVhZFwiKTtcbi8qKlxuICogQ29udmVydHMgYSBzZWN0aW9uIG9mIGEgYnVmZmVyIHRvIGEgc2lnbmVkIGludGVnZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIGJ1ZmZlciAxMTExMDExMFxuICogcmVhZFVJbnQoYnVmZmVyLCAzLCA1KSA9PiAtMTBcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIHRoZSBidWZmZXIgdG8gZXh0cmFjdCBpbmZvcm1hdGlvbiBmcm9tXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIHRoZSBsZW5ndGggb2YgdGhlIHNpZ25lZCBpbnRlZ2VyIChpbiBiaXRzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCB3aGVyZSB0byBzdGFydCAoaW4gYml0cylcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9IDA7IH1cbiAgICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHsgbGVuZ3RoID0gODsgfVxuICAgIHZhciBiaXRzID0gcmVhZF8xLmRlZmF1bHQoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgaWYgKGJpdHNbMF0gPT09IDApIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoYml0c1tpXSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdXRpbGl0aWVzXzEucDJbbGVuZ3RoIC0gaSAtIDFdO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IC0xO1xuICAgICAgICB2YXIgaW52ZXJ0ZWQgPSBub3RfMS5kZWZhdWx0KGJpdHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGludmVydGVkW2ldKVxuICAgICAgICAgICAgICAgIHJlc3VsdCAtPSB1dGlsaXRpZXNfMS5wMltsZW5ndGggLSBpIC0gMV07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSk7XG4iLCJjb25zdCBlcnJvcnMgPSB7XG4gIElNUE9TU0lCTEVfQ0FTRTogJ0ltcG9zc2libGUgY2FzZS4gUGxlYXNlIGNyZWF0ZSBpc3N1ZS4nLFxuICBUV0VBS19BREQ6XG4gICAgJ1RoZSB0d2VhayB3YXMgb3V0IG9mIHJhbmdlIG9yIHRoZSByZXN1bHRlZCBwcml2YXRlIGtleSBpcyBpbnZhbGlkJyxcbiAgVFdFQUtfTVVMOiAnVGhlIHR3ZWFrIHdhcyBvdXQgb2YgcmFuZ2Ugb3IgZXF1YWwgdG8gemVybycsXG4gIENPTlRFWFRfUkFORE9NSVpFX1VOS05PVzogJ1Vua25vdyBlcnJvciBvbiBjb250ZXh0IHJhbmRvbWl6YXRpb24nLFxuICBTRUNLRVlfSU5WQUxJRDogJ1ByaXZhdGUgS2V5IGlzIGludmFsaWQnLFxuICBQVUJLRVlfUEFSU0U6ICdQdWJsaWMgS2V5IGNvdWxkIG5vdCBiZSBwYXJzZWQnLFxuICBQVUJLRVlfU0VSSUFMSVpFOiAnUHVibGljIEtleSBzZXJpYWxpemF0aW9uIGVycm9yJyxcbiAgUFVCS0VZX0NPTUJJTkU6ICdUaGUgc3VtIG9mIHRoZSBwdWJsaWMga2V5cyBpcyBub3QgdmFsaWQnLFxuICBTSUdfUEFSU0U6ICdTaWduYXR1cmUgY291bGQgbm90IGJlIHBhcnNlZCcsXG4gIFNJR046ICdUaGUgbm9uY2UgZ2VuZXJhdGlvbiBmdW5jdGlvbiBmYWlsZWQsIG9yIHRoZSBwcml2YXRlIGtleSB3YXMgaW52YWxpZCcsXG4gIFJFQ09WRVI6ICdQdWJsaWMga2V5IGNvdWxkIG5vdCBiZSByZWNvdmVyJyxcbiAgRUNESDogJ1NjYWxhciB3YXMgaW52YWxpZCAoemVybyBvciBvdmVyZmxvdyknXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZCwgbXNnKSB7XG4gIGlmICghY29uZCkgdGhyb3cgbmV3IEVycm9yKG1zZylcbn1cblxuZnVuY3Rpb24gaXNVaW50OEFycmF5IChuYW1lLCB2YWx1ZSwgbGVuZ3RoKSB7XG4gIGFzc2VydCh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksIGBFeHBlY3RlZCAke25hbWV9IHRvIGJlIGFuIFVpbnQ4QXJyYXlgKVxuXG4gIGlmIChsZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGxlbmd0aCkpIHtcbiAgICAgIGNvbnN0IG51bWJlcnMgPSBsZW5ndGguam9pbignLCAnKVxuICAgICAgY29uc3QgbXNnID0gYEV4cGVjdGVkICR7bmFtZX0gdG8gYmUgYW4gVWludDhBcnJheSB3aXRoIGxlbmd0aCBbJHtudW1iZXJzfV1gXG4gICAgICBhc3NlcnQobGVuZ3RoLmluY2x1ZGVzKHZhbHVlLmxlbmd0aCksIG1zZylcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbXNnID0gYEV4cGVjdGVkICR7bmFtZX0gdG8gYmUgYW4gVWludDhBcnJheSB3aXRoIGxlbmd0aCAke2xlbmd0aH1gXG4gICAgICBhc3NlcnQodmFsdWUubGVuZ3RoID09PSBsZW5ndGgsIG1zZylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDb21wcmVzc2VkICh2YWx1ZSkge1xuICBhc3NlcnQodG9UeXBlU3RyaW5nKHZhbHVlKSA9PT0gJ0Jvb2xlYW4nLCAnRXhwZWN0ZWQgY29tcHJlc3NlZCB0byBiZSBhIEJvb2xlYW4nKVxufVxuXG5mdW5jdGlvbiBnZXRBc3NlcnRlZE91dHB1dCAob3V0cHV0ID0gKGxlbikgPT4gbmV3IFVpbnQ4QXJyYXkobGVuKSwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2Ygb3V0cHV0ID09PSAnZnVuY3Rpb24nKSBvdXRwdXQgPSBvdXRwdXQobGVuZ3RoKVxuICBpc1VpbnQ4QXJyYXkoJ291dHB1dCcsIG91dHB1dCwgbGVuZ3RoKVxuICByZXR1cm4gb3V0cHV0XG59XG5cbmZ1bmN0aW9uIHRvVHlwZVN0cmluZyAodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKHNlY3AyNTZrMSkgPT4ge1xuICByZXR1cm4ge1xuICAgIGNvbnRleHRSYW5kb21pemUgKHNlZWQpIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgc2VlZCA9PT0gbnVsbCB8fCBzZWVkIGluc3RhbmNlb2YgVWludDhBcnJheSxcbiAgICAgICAgJ0V4cGVjdGVkIHNlZWQgdG8gYmUgYW4gVWludDhBcnJheSBvciBudWxsJ1xuICAgICAgKVxuICAgICAgaWYgKHNlZWQgIT09IG51bGwpIGlzVWludDhBcnJheSgnc2VlZCcsIHNlZWQsIDMyKVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5jb250ZXh0UmFuZG9taXplKHNlZWQpKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLkNPTlRFWFRfUkFORE9NSVpFX1VOS05PVylcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleVZlcmlmeSAoc2Vja2V5KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5VmVyaWZ5KHNlY2tleSkgPT09IDBcbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleU5lZ2F0ZSAoc2Vja2V5KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHJpdmF0ZUtleU5lZ2F0ZShzZWNrZXkpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gc2Vja2V5XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleVR3ZWFrQWRkIChzZWNrZXksIHR3ZWFrKSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcbiAgICAgIGlzVWludDhBcnJheSgndHdlYWsnLCB0d2VhaywgMzIpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnByaXZhdGVLZXlUd2Vha0FkZChzZWNrZXksIHR3ZWFrKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIHNlY2tleVxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5UV0VBS19BREQpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHByaXZhdGVLZXlUd2Vha011bCAoc2Vja2V5LCB0d2Vhaykge1xuICAgICAgaXNVaW50OEFycmF5KCdwcml2YXRlIGtleScsIHNlY2tleSwgMzIpXG4gICAgICBpc1VpbnQ4QXJyYXkoJ3R3ZWFrJywgdHdlYWssIDMyKVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtNdWwoc2Vja2V5LCB0d2VhaykpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBzZWNrZXlcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuVFdFQUtfTVVMKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlWZXJpZnkgKHB1YmtleSkge1xuICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkocHVia2V5KSA9PT0gMFxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlDcmVhdGUgKHNlY2tleSwgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdwcml2YXRlIGtleScsIHNlY2tleSwgMzIpXG4gICAgICBpc0NvbXByZXNzZWQoY29tcHJlc3NlZClcbiAgICAgIG91dHB1dCA9IGdldEFzc2VydGVkT3V0cHV0KG91dHB1dCwgY29tcHJlc3NlZCA/IDMzIDogNjUpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnB1YmxpY0tleUNyZWF0ZShvdXRwdXQsIHNlY2tleSkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuU0VDS0VZX0lOVkFMSUQpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9TRVJJQUxJWkUpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHB1YmxpY0tleUNvbnZlcnQgKHB1YmtleSwgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHVibGljS2V5Q29udmVydChvdXRwdXQsIHB1YmtleSkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfU0VSSUFMSVpFKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlOZWdhdGUgKHB1YmtleSwgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHVibGljS2V5TmVnYXRlKG91dHB1dCwgcHVia2V5KSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1NFUklBTElaRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHVibGljS2V5Q29tYmluZSAocHVia2V5cywgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocHVia2V5cyksICdFeHBlY3RlZCBwdWJsaWMga2V5cyB0byBiZSBhbiBBcnJheScpXG4gICAgICBhc3NlcnQocHVia2V5cy5sZW5ndGggPiAwLCAnRXhwZWN0ZWQgcHVibGljIGtleXMgYXJyYXkgd2lsbCBoYXZlIG1vcmUgdGhhbiB6ZXJvIGl0ZW1zJylcbiAgICAgIGZvciAoY29uc3QgcHVia2V5IG9mIHB1YmtleXMpIHtcbiAgICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcbiAgICAgIH1cbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHVibGljS2V5Q29tYmluZShvdXRwdXQsIHB1YmtleXMpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX0NPTUJJTkUpXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9TRVJJQUxJWkUpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHB1YmxpY0tleVR3ZWFrQWRkIChwdWJrZXksIHR3ZWFrLCBjb21wcmVzc2VkID0gdHJ1ZSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuICAgICAgaXNVaW50OEFycmF5KCd0d2VhaycsIHR3ZWFrLCAzMilcbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHVibGljS2V5VHdlYWtBZGQob3V0cHV0LCBwdWJrZXksIHR3ZWFrKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlRXRUFLX0FERClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHVibGljS2V5VHdlYWtNdWwgKHB1YmtleSwgdHdlYWssIGNvbXByZXNzZWQgPSB0cnVlLCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgncHVibGljIGtleScsIHB1YmtleSwgWzMzLCA2NV0pXG4gICAgICBpc1VpbnQ4QXJyYXkoJ3R3ZWFrJywgdHdlYWssIDMyKVxuICAgICAgaXNDb21wcmVzc2VkKGNvbXByZXNzZWQpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIGNvbXByZXNzZWQgPyAzMyA6IDY1KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha011bChvdXRwdXQsIHB1YmtleSwgdHdlYWspKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuVFdFQUtfTVVMKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzaWduYXR1cmVOb3JtYWxpemUgKHNpZykge1xuICAgICAgaXNVaW50OEFycmF5KCdzaWduYXR1cmUnLCBzaWcsIDY0KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5zaWduYXR1cmVOb3JtYWxpemUoc2lnKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIHNpZ1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdfUEFSU0UpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHNpZ25hdHVyZUV4cG9ydCAoc2lnLCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgnc2lnbmF0dXJlJywgc2lnLCA2NClcbiAgICAgIG91dHB1dCA9IGdldEFzc2VydGVkT3V0cHV0KG91dHB1dCwgNzIpXG5cbiAgICAgIGNvbnN0IG9iaiA9IHsgb3V0cHV0LCBvdXRwdXRsZW46IDcyIH1cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnNpZ25hdHVyZUV4cG9ydChvYmosIHNpZykpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXQuc2xpY2UoMCwgb2JqLm91dHB1dGxlbilcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuU0lHX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5JTVBPU1NJQkxFX0NBU0UpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHNpZ25hdHVyZUltcG9ydCAoc2lnLCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgnc2lnbmF0dXJlJywgc2lnKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCA2NClcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuc2lnbmF0dXJlSW1wb3J0KG91dHB1dCwgc2lnKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZWNkc2FTaWduIChtc2czMiwgc2Vja2V5LCBvcHRpb25zID0ge30sIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdtZXNzYWdlJywgbXNnMzIsIDMyKVxuICAgICAgaXNVaW50OEFycmF5KCdwcml2YXRlIGtleScsIHNlY2tleSwgMzIpXG4gICAgICBhc3NlcnQodG9UeXBlU3RyaW5nKG9wdGlvbnMpID09PSAnT2JqZWN0JywgJ0V4cGVjdGVkIG9wdGlvbnMgdG8gYmUgYW4gT2JqZWN0JylcbiAgICAgIGlmIChvcHRpb25zLmRhdGEgIT09IHVuZGVmaW5lZCkgaXNVaW50OEFycmF5KCdvcHRpb25zLmRhdGEnLCBvcHRpb25zLmRhdGEpXG4gICAgICBpZiAob3B0aW9ucy5ub25jZWZuICE9PSB1bmRlZmluZWQpIGFzc2VydCh0b1R5cGVTdHJpbmcob3B0aW9ucy5ub25jZWZuKSA9PT0gJ0Z1bmN0aW9uJywgJ0V4cGVjdGVkIG9wdGlvbnMubm9uY2VmbiB0byBiZSBhIEZ1bmN0aW9uJylcbiAgICAgIG91dHB1dCA9IGdldEFzc2VydGVkT3V0cHV0KG91dHB1dCwgNjQpXG5cbiAgICAgIGNvbnN0IG9iaiA9IHsgc2lnbmF0dXJlOiBvdXRwdXQsIHJlY2lkOiBudWxsIH1cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLmVjZHNhU2lnbihvYmosIG1zZzMyLCBzZWNrZXksIG9wdGlvbnMuZGF0YSwgb3B0aW9ucy5ub25jZWZuKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdOKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5JTVBPU1NJQkxFX0NBU0UpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGVjZHNhVmVyaWZ5IChzaWcsIG1zZzMyLCBwdWJrZXkpIHtcbiAgICAgIGlzVWludDhBcnJheSgnc2lnbmF0dXJlJywgc2lnLCA2NClcbiAgICAgIGlzVWludDhBcnJheSgnbWVzc2FnZScsIG1zZzMyLCAzMilcbiAgICAgIGlzVWludDhBcnJheSgncHVibGljIGtleScsIHB1YmtleSwgWzMzLCA2NV0pXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLmVjZHNhVmVyaWZ5KHNpZywgbXNnMzIsIHB1YmtleSkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuU0lHX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfUEFSU0UpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGVjZHNhUmVjb3ZlciAoc2lnLCByZWNpZCwgbXNnMzIsIGNvbXByZXNzZWQgPSB0cnVlLCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgnc2lnbmF0dXJlJywgc2lnLCA2NClcbiAgICAgIGFzc2VydChcbiAgICAgICAgdG9UeXBlU3RyaW5nKHJlY2lkKSA9PT0gJ051bWJlcicgJiZcbiAgICAgICAgICByZWNpZCA+PSAwICYmXG4gICAgICAgICAgcmVjaWQgPD0gMyxcbiAgICAgICAgJ0V4cGVjdGVkIHJlY292ZXJ5IGlkIHRvIGJlIGEgTnVtYmVyIHdpdGhpbiBpbnRlcnZhbCBbMCwgM10nXG4gICAgICApXG4gICAgICBpc1VpbnQ4QXJyYXkoJ21lc3NhZ2UnLCBtc2czMiwgMzIpXG4gICAgICBpc0NvbXByZXNzZWQoY29tcHJlc3NlZClcbiAgICAgIG91dHB1dCA9IGdldEFzc2VydGVkT3V0cHV0KG91dHB1dCwgY29tcHJlc3NlZCA/IDMzIDogNjUpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLmVjZHNhUmVjb3ZlcihvdXRwdXQsIHNpZywgcmVjaWQsIG1zZzMyKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlJFQ09WRVIpXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZWNkaCAocHVia2V5LCBzZWNrZXksIG9wdGlvbnMgPSB7fSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuICAgICAgaXNVaW50OEFycmF5KCdwcml2YXRlIGtleScsIHNlY2tleSwgMzIpXG4gICAgICBhc3NlcnQodG9UeXBlU3RyaW5nKG9wdGlvbnMpID09PSAnT2JqZWN0JywgJ0V4cGVjdGVkIG9wdGlvbnMgdG8gYmUgYW4gT2JqZWN0JylcbiAgICAgIGlmIChvcHRpb25zLmRhdGEgIT09IHVuZGVmaW5lZCkgaXNVaW50OEFycmF5KCdvcHRpb25zLmRhdGEnLCBvcHRpb25zLmRhdGEpXG4gICAgICBpZiAob3B0aW9ucy5oYXNoZm4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhc3NlcnQodG9UeXBlU3RyaW5nKG9wdGlvbnMuaGFzaGZuKSA9PT0gJ0Z1bmN0aW9uJywgJ0V4cGVjdGVkIG9wdGlvbnMuaGFzaGZuIHRvIGJlIGEgRnVuY3Rpb24nKVxuICAgICAgICBpZiAob3B0aW9ucy54YnVmICE9PSB1bmRlZmluZWQpIGlzVWludDhBcnJheSgnb3B0aW9ucy54YnVmJywgb3B0aW9ucy54YnVmLCAzMilcbiAgICAgICAgaWYgKG9wdGlvbnMueWJ1ZiAhPT0gdW5kZWZpbmVkKSBpc1VpbnQ4QXJyYXkoJ29wdGlvbnMueWJ1ZicsIG9wdGlvbnMueWJ1ZiwgMzIpXG4gICAgICAgIGlzVWludDhBcnJheSgnb3V0cHV0Jywgb3V0cHV0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCAzMilcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuZWNkaChvdXRwdXQsIHB1YmtleSwgc2Vja2V5LCBvcHRpb25zLmRhdGEsIG9wdGlvbnMuaGFzaGZuLCBvcHRpb25zLnhidWYsIG9wdGlvbnMueWJ1ZikpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5FQ0RIKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiY29uc3QgRUMgPSByZXF1aXJlKCdlbGxpcHRpYycpLmVjXG5cbmNvbnN0IGVjID0gbmV3IEVDKCdzZWNwMjU2azEnKVxuY29uc3QgZWNwYXJhbXMgPSBlYy5jdXJ2ZVxuXG4vLyBIYWNrLCB3ZSBjYW4gbm90IHVzZSBibi5qc0A1LCB3aGlsZSBlbGxpcHRpYyB1c2VzIGJuLmpzQDRcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9lbGxpcHRpYy9pc3N1ZXMvMTkxI2lzc3VlY29tbWVudC01Njk4ODg3NThcbmNvbnN0IEJOID0gZWNwYXJhbXMubi5jb25zdHJ1Y3RvclxuXG5mdW5jdGlvbiBsb2FkQ29tcHJlc3NlZFB1YmxpY0tleSAoZmlyc3QsIHhidWYpIHtcbiAgbGV0IHggPSBuZXcgQk4oeGJ1ZilcblxuICAvLyBvdmVyZmxvd1xuICBpZiAoeC5jbXAoZWNwYXJhbXMucCkgPj0gMCkgcmV0dXJuIG51bGxcbiAgeCA9IHgudG9SZWQoZWNwYXJhbXMucmVkKVxuXG4gIC8vIGNvbXB1dGUgY29ycmVzcG9uZGluZyBZXG4gIGxldCB5ID0geC5yZWRTcXIoKS5yZWRJTXVsKHgpLnJlZElBZGQoZWNwYXJhbXMuYikucmVkU3FydCgpXG4gIGlmICgoZmlyc3QgPT09IDB4MDMpICE9PSB5LmlzT2RkKCkpIHkgPSB5LnJlZE5lZygpXG5cbiAgcmV0dXJuIGVjLmtleVBhaXIoeyBwdWI6IHsgeDogeCwgeTogeSB9IH0pXG59XG5cbmZ1bmN0aW9uIGxvYWRVbmNvbXByZXNzZWRQdWJsaWNLZXkgKGZpcnN0LCB4YnVmLCB5YnVmKSB7XG4gIGxldCB4ID0gbmV3IEJOKHhidWYpXG4gIGxldCB5ID0gbmV3IEJOKHlidWYpXG5cbiAgLy8gb3ZlcmZsb3dcbiAgaWYgKHguY21wKGVjcGFyYW1zLnApID49IDAgfHwgeS5jbXAoZWNwYXJhbXMucCkgPj0gMCkgcmV0dXJuIG51bGxcblxuICB4ID0geC50b1JlZChlY3BhcmFtcy5yZWQpXG4gIHkgPSB5LnRvUmVkKGVjcGFyYW1zLnJlZClcblxuICAvLyBpcyBvZGQgZmxhZ1xuICBpZiAoKGZpcnN0ID09PSAweDA2IHx8IGZpcnN0ID09PSAweDA3KSAmJiB5LmlzT2RkKCkgIT09IChmaXJzdCA9PT0gMHgwNykpIHJldHVybiBudWxsXG5cbiAgLy8geCp4KnggKyBiID0geSp5XG4gIGNvbnN0IHgzID0geC5yZWRTcXIoKS5yZWRJTXVsKHgpXG4gIGlmICgheS5yZWRTcXIoKS5yZWRJU3ViKHgzLnJlZElBZGQoZWNwYXJhbXMuYikpLmlzWmVybygpKSByZXR1cm4gbnVsbFxuXG4gIHJldHVybiBlYy5rZXlQYWlyKHsgcHViOiB7IHg6IHgsIHk6IHkgfSB9KVxufVxuXG5mdW5jdGlvbiBsb2FkUHVibGljS2V5IChwdWJrZXkpIHtcbiAgLy8gbGVuZ3RoIHNob3VsZCBiZSB2YWxpZGF0ZWQgaW4gaW50ZXJmYWNlXG4gIGNvbnN0IGZpcnN0ID0gcHVia2V5WzBdXG4gIHN3aXRjaCAoZmlyc3QpIHtcbiAgICBjYXNlIDB4MDI6XG4gICAgY2FzZSAweDAzOlxuICAgICAgaWYgKHB1YmtleS5sZW5ndGggIT09IDMzKSByZXR1cm4gbnVsbFxuICAgICAgcmV0dXJuIGxvYWRDb21wcmVzc2VkUHVibGljS2V5KGZpcnN0LCBwdWJrZXkuc3ViYXJyYXkoMSwgMzMpKVxuICAgIGNhc2UgMHgwNDpcbiAgICBjYXNlIDB4MDY6XG4gICAgY2FzZSAweDA3OlxuICAgICAgaWYgKHB1YmtleS5sZW5ndGggIT09IDY1KSByZXR1cm4gbnVsbFxuICAgICAgcmV0dXJuIGxvYWRVbmNvbXByZXNzZWRQdWJsaWNLZXkoZmlyc3QsIHB1YmtleS5zdWJhcnJheSgxLCAzMyksIHB1YmtleS5zdWJhcnJheSgzMywgNjUpKVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmZ1bmN0aW9uIHNhdmVQdWJsaWNLZXkgKG91dHB1dCwgcG9pbnQpIHtcbiAgY29uc3QgcHVia2V5ID0gcG9pbnQuZW5jb2RlKG51bGwsIG91dHB1dC5sZW5ndGggPT09IDMzKVxuICAvLyBMb29wIHNob3VsZCBiZSBmYXN0ZXIgYmVjYXVzZSB3ZSBkbyBub3QgbmVlZCBjcmVhdGUgZXh0cmEgVWludDhBcnJheVxuICAvLyBvdXRwdXQuc2V0KG5ldyBVaW50OEFycmF5KHB1YmtleSkpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Lmxlbmd0aDsgKytpKSBvdXRwdXRbaV0gPSBwdWJrZXlbaV1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbnRleHRSYW5kb21pemUgKCkge1xuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHJpdmF0ZUtleVZlcmlmeSAoc2Vja2V5KSB7XG4gICAgY29uc3QgYm4gPSBuZXcgQk4oc2Vja2V5KVxuICAgIHJldHVybiBibi5jbXAoZWNwYXJhbXMubikgPCAwICYmICFibi5pc1plcm8oKSA/IDAgOiAxXG4gIH0sXG5cbiAgcHJpdmF0ZUtleU5lZ2F0ZSAoc2Vja2V5KSB7XG4gICAgY29uc3QgYm4gPSBuZXcgQk4oc2Vja2V5KVxuICAgIGNvbnN0IG5lZ2F0ZSA9IGVjcGFyYW1zLm4uc3ViKGJuKS51bW9kKGVjcGFyYW1zLm4pLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKVxuICAgIHNlY2tleS5zZXQobmVnYXRlKVxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHJpdmF0ZUtleVR3ZWFrQWRkIChzZWNrZXksIHR3ZWFrKSB7XG4gICAgY29uc3QgYm4gPSBuZXcgQk4odHdlYWspXG4gICAgaWYgKGJuLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByZXR1cm4gMVxuXG4gICAgYm4uaWFkZChuZXcgQk4oc2Vja2V5KSlcbiAgICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDApIGJuLmlzdWIoZWNwYXJhbXMubilcbiAgICBpZiAoYm4uaXNaZXJvKCkpIHJldHVybiAxXG5cbiAgICBjb25zdCB0d2Vha2VkID0gYm4udG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpXG4gICAgc2Vja2V5LnNldCh0d2Vha2VkKVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwcml2YXRlS2V5VHdlYWtNdWwgKHNlY2tleSwgdHdlYWspIHtcbiAgICBsZXQgYm4gPSBuZXcgQk4odHdlYWspXG4gICAgaWYgKGJuLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IGJuLmlzWmVybygpKSByZXR1cm4gMVxuXG4gICAgYm4uaW11bChuZXcgQk4oc2Vja2V5KSlcbiAgICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDApIGJuID0gYm4udW1vZChlY3BhcmFtcy5uKVxuXG4gICAgY29uc3QgdHdlYWtlZCA9IGJuLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKVxuICAgIHNlY2tleS5zZXQodHdlYWtlZClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHVibGljS2V5VmVyaWZ5IChwdWJrZXkpIHtcbiAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJrZXkpXG4gICAgcmV0dXJuIHBhaXIgPT09IG51bGwgPyAxIDogMFxuICB9LFxuXG4gIHB1YmxpY0tleUNyZWF0ZSAob3V0cHV0LCBzZWNrZXkpIHtcbiAgICBjb25zdCBibiA9IG5ldyBCTihzZWNrZXkpXG4gICAgaWYgKGJuLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IGJuLmlzWmVybygpKSByZXR1cm4gMVxuXG4gICAgY29uc3QgcG9pbnQgPSBlYy5rZXlGcm9tUHJpdmF0ZShzZWNrZXkpLmdldFB1YmxpYygpXG4gICAgc2F2ZVB1YmxpY0tleShvdXRwdXQsIHBvaW50KVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwdWJsaWNLZXlDb252ZXJ0IChvdXRwdXQsIHB1YmtleSkge1xuICAgIGNvbnN0IHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmtleSlcbiAgICBpZiAocGFpciA9PT0gbnVsbCkgcmV0dXJuIDFcblxuICAgIGNvbnN0IHBvaW50ID0gcGFpci5nZXRQdWJsaWMoKVxuICAgIHNhdmVQdWJsaWNLZXkob3V0cHV0LCBwb2ludClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHVibGljS2V5TmVnYXRlIChvdXRwdXQsIHB1YmtleSkge1xuICAgIGNvbnN0IHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmtleSlcbiAgICBpZiAocGFpciA9PT0gbnVsbCkgcmV0dXJuIDFcblxuICAgIGNvbnN0IHBvaW50ID0gcGFpci5nZXRQdWJsaWMoKVxuICAgIHBvaW50LnkgPSBwb2ludC55LnJlZE5lZygpXG4gICAgc2F2ZVB1YmxpY0tleShvdXRwdXQsIHBvaW50KVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwdWJsaWNLZXlDb21iaW5lIChvdXRwdXQsIHB1YmtleXMpIHtcbiAgICBjb25zdCBwYWlycyA9IG5ldyBBcnJheShwdWJrZXlzLmxlbmd0aClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHB1YmtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHBhaXJzW2ldID0gbG9hZFB1YmxpY0tleShwdWJrZXlzW2ldKVxuICAgICAgaWYgKHBhaXJzW2ldID09PSBudWxsKSByZXR1cm4gMVxuICAgIH1cblxuICAgIGxldCBwb2ludCA9IHBhaXJzWzBdLmdldFB1YmxpYygpXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYWlycy5sZW5ndGg7ICsraSkgcG9pbnQgPSBwb2ludC5hZGQocGFpcnNbaV0ucHViKVxuICAgIGlmIChwb2ludC5pc0luZmluaXR5KCkpIHJldHVybiAyXG5cbiAgICBzYXZlUHVibGljS2V5KG91dHB1dCwgcG9pbnQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHB1YmxpY0tleVR3ZWFrQWRkIChvdXRwdXQsIHB1YmtleSwgdHdlYWspIHtcbiAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJrZXkpXG4gICAgaWYgKHBhaXIgPT09IG51bGwpIHJldHVybiAxXG5cbiAgICB0d2VhayA9IG5ldyBCTih0d2VhaylcbiAgICBpZiAodHdlYWsuY21wKGVjcGFyYW1zLm4pID49IDApIHJldHVybiAyXG5cbiAgICBjb25zdCBwb2ludCA9IHBhaXIuZ2V0UHVibGljKCkuYWRkKGVjcGFyYW1zLmcubXVsKHR3ZWFrKSlcbiAgICBpZiAocG9pbnQuaXNJbmZpbml0eSgpKSByZXR1cm4gMlxuXG4gICAgc2F2ZVB1YmxpY0tleShvdXRwdXQsIHBvaW50KVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwdWJsaWNLZXlUd2Vha011bCAob3V0cHV0LCBwdWJrZXksIHR3ZWFrKSB7XG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KVxuICAgIGlmIChwYWlyID09PSBudWxsKSByZXR1cm4gMVxuXG4gICAgdHdlYWsgPSBuZXcgQk4odHdlYWspXG4gICAgaWYgKHR3ZWFrLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHR3ZWFrLmlzWmVybygpKSByZXR1cm4gMlxuXG4gICAgY29uc3QgcG9pbnQgPSBwYWlyLmdldFB1YmxpYygpLm11bCh0d2VhaylcbiAgICBzYXZlUHVibGljS2V5KG91dHB1dCwgcG9pbnQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHNpZ25hdHVyZU5vcm1hbGl6ZSAoc2lnKSB7XG4gICAgY29uc3QgciA9IG5ldyBCTihzaWcuc3ViYXJyYXkoMCwgMzIpKVxuICAgIGNvbnN0IHMgPSBuZXcgQk4oc2lnLnN1YmFycmF5KDMyLCA2NCkpXG4gICAgaWYgKHIuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgcy5jbXAoZWNwYXJhbXMubikgPj0gMCkgcmV0dXJuIDFcblxuICAgIGlmIChzLmNtcChlYy5uaCkgPT09IDEpIHtcbiAgICAgIHNpZy5zZXQoZWNwYXJhbXMubi5zdWIocykudG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpLCAzMilcbiAgICB9XG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIC8vIENvcGllZCAxLXRvLTEgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbmpzL2JpcDY2L2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gIC8vIEFkYXB0ZWQgZm9yIFVpbnQ4QXJyYXkgaW5zdGVhZCBCdWZmZXJcbiAgc2lnbmF0dXJlRXhwb3J0IChvYmosIHNpZykge1xuICAgIGNvbnN0IHNpZ1IgPSBzaWcuc3ViYXJyYXkoMCwgMzIpXG4gICAgY29uc3Qgc2lnUyA9IHNpZy5zdWJhcnJheSgzMiwgNjQpXG4gICAgaWYgKG5ldyBCTihzaWdSKS5jbXAoZWNwYXJhbXMubikgPj0gMCkgcmV0dXJuIDFcbiAgICBpZiAobmV3IEJOKHNpZ1MpLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByZXR1cm4gMVxuXG4gICAgY29uc3QgeyBvdXRwdXQgfSA9IG9ialxuXG4gICAgLy8gUHJlcGFyZSBSXG4gICAgbGV0IHIgPSBvdXRwdXQuc3ViYXJyYXkoNCwgNCArIDMzKVxuICAgIHJbMF0gPSAweDAwXG4gICAgci5zZXQoc2lnUiwgMSlcblxuICAgIGxldCBsZW5SID0gMzNcbiAgICBsZXQgcG9zUiA9IDBcbiAgICBmb3IgKDsgbGVuUiA+IDEgJiYgcltwb3NSXSA9PT0gMHgwMCAmJiAhKHJbcG9zUiArIDFdICYgMHg4MCk7IC0tbGVuUiwgKytwb3NSKTtcblxuICAgIHIgPSByLnN1YmFycmF5KHBvc1IpXG4gICAgaWYgKHJbMF0gJiAweDgwKSByZXR1cm4gMVxuICAgIGlmIChsZW5SID4gMSAmJiAoclswXSA9PT0gMHgwMCkgJiYgIShyWzFdICYgMHg4MCkpIHJldHVybiAxXG5cbiAgICAvLyBQcmVwYXJlIFNcbiAgICBsZXQgcyA9IG91dHB1dC5zdWJhcnJheSg2ICsgMzMsIDYgKyAzMyArIDMzKVxuICAgIHNbMF0gPSAweDAwXG4gICAgcy5zZXQoc2lnUywgMSlcblxuICAgIGxldCBsZW5TID0gMzNcbiAgICBsZXQgcG9zUyA9IDBcbiAgICBmb3IgKDsgbGVuUyA+IDEgJiYgc1twb3NTXSA9PT0gMHgwMCAmJiAhKHNbcG9zUyArIDFdICYgMHg4MCk7IC0tbGVuUywgKytwb3NTKTtcblxuICAgIHMgPSBzLnN1YmFycmF5KHBvc1MpXG4gICAgaWYgKHNbMF0gJiAweDgwKSByZXR1cm4gMVxuICAgIGlmIChsZW5TID4gMSAmJiAoc1swXSA9PT0gMHgwMCkgJiYgIShzWzFdICYgMHg4MCkpIHJldHVybiAxXG5cbiAgICAvLyBTZXQgb3V0cHV0IGxlbmd0aCBmb3IgcmV0dXJuXG4gICAgb2JqLm91dHB1dGxlbiA9IDYgKyBsZW5SICsgbGVuU1xuXG4gICAgLy8gT3V0cHV0IGluIHNwZWNpZmllZCBmb3JtYXRcbiAgICAvLyAweDMwIFt0b3RhbC1sZW5ndGhdIDB4MDIgW1ItbGVuZ3RoXSBbUl0gMHgwMiBbUy1sZW5ndGhdIFtTXVxuICAgIG91dHB1dFswXSA9IDB4MzBcbiAgICBvdXRwdXRbMV0gPSBvYmoub3V0cHV0bGVuIC0gMlxuICAgIG91dHB1dFsyXSA9IDB4MDJcbiAgICBvdXRwdXRbM10gPSByLmxlbmd0aFxuICAgIG91dHB1dC5zZXQociwgNClcbiAgICBvdXRwdXRbNCArIGxlblJdID0gMHgwMlxuICAgIG91dHB1dFs1ICsgbGVuUl0gPSBzLmxlbmd0aFxuICAgIG91dHB1dC5zZXQocywgNiArIGxlblIpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIC8vIENvcGllZCAxLXRvLTEgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbmpzL2JpcDY2L2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gIC8vIEFkYXB0ZWQgZm9yIFVpbnQ4QXJyYXkgaW5zdGVhZCBCdWZmZXJcbiAgc2lnbmF0dXJlSW1wb3J0IChvdXRwdXQsIHNpZykge1xuICAgIGlmIChzaWcubGVuZ3RoIDwgOCkgcmV0dXJuIDFcbiAgICBpZiAoc2lnLmxlbmd0aCA+IDcyKSByZXR1cm4gMVxuICAgIGlmIChzaWdbMF0gIT09IDB4MzApIHJldHVybiAxXG4gICAgaWYgKHNpZ1sxXSAhPT0gc2lnLmxlbmd0aCAtIDIpIHJldHVybiAxXG4gICAgaWYgKHNpZ1syXSAhPT0gMHgwMikgcmV0dXJuIDFcblxuICAgIGNvbnN0IGxlblIgPSBzaWdbM11cbiAgICBpZiAobGVuUiA9PT0gMCkgcmV0dXJuIDFcbiAgICBpZiAoNSArIGxlblIgPj0gc2lnLmxlbmd0aCkgcmV0dXJuIDFcbiAgICBpZiAoc2lnWzQgKyBsZW5SXSAhPT0gMHgwMikgcmV0dXJuIDFcblxuICAgIGNvbnN0IGxlblMgPSBzaWdbNSArIGxlblJdXG4gICAgaWYgKGxlblMgPT09IDApIHJldHVybiAxXG4gICAgaWYgKCg2ICsgbGVuUiArIGxlblMpICE9PSBzaWcubGVuZ3RoKSByZXR1cm4gMVxuXG4gICAgaWYgKHNpZ1s0XSAmIDB4ODApIHJldHVybiAxXG4gICAgaWYgKGxlblIgPiAxICYmIChzaWdbNF0gPT09IDB4MDApICYmICEoc2lnWzVdICYgMHg4MCkpIHJldHVybiAxXG5cbiAgICBpZiAoc2lnW2xlblIgKyA2XSAmIDB4ODApIHJldHVybiAxXG4gICAgaWYgKGxlblMgPiAxICYmIChzaWdbbGVuUiArIDZdID09PSAweDAwKSAmJiAhKHNpZ1tsZW5SICsgN10gJiAweDgwKSkgcmV0dXJuIDFcblxuICAgIGxldCBzaWdSID0gc2lnLnN1YmFycmF5KDQsIDQgKyBsZW5SKVxuICAgIGlmIChzaWdSLmxlbmd0aCA9PT0gMzMgJiYgc2lnUlswXSA9PT0gMHgwMCkgc2lnUiA9IHNpZ1Iuc3ViYXJyYXkoMSlcbiAgICBpZiAoc2lnUi5sZW5ndGggPiAzMikgcmV0dXJuIDFcblxuICAgIGxldCBzaWdTID0gc2lnLnN1YmFycmF5KDYgKyBsZW5SKVxuICAgIGlmIChzaWdTLmxlbmd0aCA9PT0gMzMgJiYgc2lnU1swXSA9PT0gMHgwMCkgc2lnUyA9IHNpZ1Muc2xpY2UoMSlcbiAgICBpZiAoc2lnUy5sZW5ndGggPiAzMikgdGhyb3cgbmV3IEVycm9yKCdTIGxlbmd0aCBpcyB0b28gbG9uZycpXG5cbiAgICBsZXQgciA9IG5ldyBCTihzaWdSKVxuICAgIGlmIChyLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByID0gbmV3IEJOKDApXG5cbiAgICBsZXQgcyA9IG5ldyBCTihzaWcuc3ViYXJyYXkoNiArIGxlblIpKVxuICAgIGlmIChzLmNtcChlY3BhcmFtcy5uKSA+PSAwKSBzID0gbmV3IEJOKDApXG5cbiAgICBvdXRwdXQuc2V0KHIudG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpLCAwKVxuICAgIG91dHB1dC5zZXQocy50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMiksIDMyKVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBlY2RzYVNpZ24gKG9iaiwgbWVzc2FnZSwgc2Vja2V5LCBkYXRhLCBub25jZWZuKSB7XG4gICAgaWYgKG5vbmNlZm4pIHtcbiAgICAgIGNvbnN0IF9ub25jZWZuID0gbm9uY2VmblxuICAgICAgbm9uY2VmbiA9IChjb3VudGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vbmNlID0gX25vbmNlZm4obWVzc2FnZSwgc2Vja2V5LCBudWxsLCBkYXRhLCBjb3VudGVyKVxuXG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSBub25jZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgbm9uY2UubGVuZ3RoID09PSAzMlxuICAgICAgICBpZiAoIWlzVmFsaWQpIHRocm93IG5ldyBFcnJvcignVGhpcyBpcyB0aGUgd2F5JylcblxuICAgICAgICByZXR1cm4gbmV3IEJOKG5vbmNlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGQgPSBuZXcgQk4oc2Vja2V5KVxuICAgIGlmIChkLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IGQuaXNaZXJvKCkpIHJldHVybiAxXG5cbiAgICBsZXQgc2lnXG4gICAgdHJ5IHtcbiAgICAgIHNpZyA9IGVjLnNpZ24obWVzc2FnZSwgc2Vja2V5LCB7IGNhbm9uaWNhbDogdHJ1ZSwgazogbm9uY2VmbiwgcGVyczogZGF0YSB9KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBvYmouc2lnbmF0dXJlLnNldChzaWcuci50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMiksIDApXG4gICAgb2JqLnNpZ25hdHVyZS5zZXQoc2lnLnMudG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpLCAzMilcbiAgICBvYmoucmVjaWQgPSBzaWcucmVjb3ZlcnlQYXJhbVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBlY2RzYVZlcmlmeSAoc2lnLCBtc2czMiwgcHVia2V5KSB7XG4gICAgY29uc3Qgc2lnT2JqID0geyByOiBzaWcuc3ViYXJyYXkoMCwgMzIpLCBzOiBzaWcuc3ViYXJyYXkoMzIsIDY0KSB9XG5cbiAgICBjb25zdCBzaWdyID0gbmV3IEJOKHNpZ09iai5yKVxuICAgIGNvbnN0IHNpZ3MgPSBuZXcgQk4oc2lnT2JqLnMpXG4gICAgaWYgKHNpZ3IuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgc2lncy5jbXAoZWNwYXJhbXMubikgPj0gMCkgcmV0dXJuIDFcbiAgICBpZiAoc2lncy5jbXAoZWMubmgpID09PSAxIHx8IHNpZ3IuaXNaZXJvKCkgfHwgc2lncy5pc1plcm8oKSkgcmV0dXJuIDNcblxuICAgIGNvbnN0IHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmtleSlcbiAgICBpZiAocGFpciA9PT0gbnVsbCkgcmV0dXJuIDJcblxuICAgIGNvbnN0IHBvaW50ID0gcGFpci5nZXRQdWJsaWMoKVxuICAgIGNvbnN0IGlzVmFsaWQgPSBlYy52ZXJpZnkobXNnMzIsIHNpZ09iaiwgcG9pbnQpXG4gICAgcmV0dXJuIGlzVmFsaWQgPyAwIDogM1xuICB9LFxuXG4gIGVjZHNhUmVjb3ZlciAob3V0cHV0LCBzaWcsIHJlY2lkLCBtc2czMikge1xuICAgIGNvbnN0IHNpZ09iaiA9IHsgcjogc2lnLnNsaWNlKDAsIDMyKSwgczogc2lnLnNsaWNlKDMyLCA2NCkgfVxuXG4gICAgY29uc3Qgc2lnciA9IG5ldyBCTihzaWdPYmoucilcbiAgICBjb25zdCBzaWdzID0gbmV3IEJOKHNpZ09iai5zKVxuICAgIGlmIChzaWdyLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHNpZ3MuY21wKGVjcGFyYW1zLm4pID49IDApIHJldHVybiAxXG5cbiAgICBpZiAoc2lnci5pc1plcm8oKSB8fCBzaWdzLmlzWmVybygpKSByZXR1cm4gMlxuXG4gICAgLy8gQ2FuIHRocm93IGB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHNlbmNvbmQga2V5IGNhbmRpbmF0ZScpO2BcbiAgICBsZXQgcG9pbnRcbiAgICB0cnkge1xuICAgICAgcG9pbnQgPSBlYy5yZWNvdmVyUHViS2V5KG1zZzMyLCBzaWdPYmosIHJlY2lkKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIDJcbiAgICB9XG5cbiAgICBzYXZlUHVibGljS2V5KG91dHB1dCwgcG9pbnQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIGVjZGggKG91dHB1dCwgcHVia2V5LCBzZWNrZXksIGRhdGEsIGhhc2hmbiwgeGJ1ZiwgeWJ1Zikge1xuICAgIGNvbnN0IHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmtleSlcbiAgICBpZiAocGFpciA9PT0gbnVsbCkgcmV0dXJuIDFcblxuICAgIGNvbnN0IHNjYWxhciA9IG5ldyBCTihzZWNrZXkpXG4gICAgaWYgKHNjYWxhci5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBzY2FsYXIuaXNaZXJvKCkpIHJldHVybiAyXG5cbiAgICBjb25zdCBwb2ludCA9IHBhaXIuZ2V0UHVibGljKCkubXVsKHNjYWxhcilcblxuICAgIGlmIChoYXNoZm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZGF0YSA9IHBvaW50LmVuY29kZShudWxsLCB0cnVlKVxuICAgICAgY29uc3Qgc2hhMjU2ID0gZWMuaGFzaCgpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgKytpKSBvdXRwdXRbaV0gPSBzaGEyNTZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF4YnVmKSB4YnVmID0gbmV3IFVpbnQ4QXJyYXkoMzIpXG4gICAgICBjb25zdCB4ID0gcG9pbnQuZ2V0WCgpLnRvQXJyYXkoJ2JlJywgMzIpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyArK2kpIHhidWZbaV0gPSB4W2ldXG5cbiAgICAgIGlmICgheWJ1ZikgeWJ1ZiA9IG5ldyBVaW50OEFycmF5KDMyKVxuICAgICAgY29uc3QgeSA9IHBvaW50LmdldFkoKS50b0FycmF5KCdiZScsIDMyKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgKytpKSB5YnVmW2ldID0geVtpXVxuXG4gICAgICBjb25zdCBoYXNoID0gaGFzaGZuKHhidWYsIHlidWYsIGRhdGEpXG5cbiAgICAgIGNvbnN0IGlzVmFsaWQgPSBoYXNoIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBoYXNoLmxlbmd0aCA9PT0gb3V0cHV0Lmxlbmd0aFxuICAgICAgaWYgKCFpc1ZhbGlkKSByZXR1cm4gMlxuXG4gICAgICBvdXRwdXQuc2V0KGhhc2gpXG4gICAgfVxuXG4gICAgcmV0dXJuIDBcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQSBDQk9SIHRhZ2dlZCBpdGVtLCB3aGVyZSB0aGUgdGFnIGRvZXMgbm90IGhhdmUgc2VtYW50aWNzIHNwZWNpZmllZCBhdCB0aGVcbiAqIG1vbWVudCwgb3IgdGhvc2Ugc2VtYW50aWNzIHRocmV3IGFuIGVycm9yIGR1cmluZyBwYXJzaW5nLiBUeXBpY2FsbHkgdGhpcyB3aWxsXG4gKiBiZSBhbiBleHRlbnNpb24gcG9pbnQgeW91J3JlIG5vdCB5ZXQgZXhwZWN0aW5nLlxuICovXG5jbGFzcyBUYWdnZWQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBUYWdnZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0YWcgLSB0aGUgbnVtYmVyIG9mIHRoZSB0YWdcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlIC0gdGhlIHZhbHVlIGluc2lkZSB0aGUgdGFnXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIHRoZSBlcnJvciB0aGF0IHdhcyB0aHJvd24gcGFyc2luZyB0aGUgdGFnLCBvciBudWxsXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodGFnLCB2YWx1ZSwgZXJyKSB7XG4gICAgdGhpcy50YWcgPSB0YWdcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICB0aGlzLmVyciA9IGVyclxuICAgIGlmICh0eXBlb2YgdGhpcy50YWcgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFnIHR5cGUgKCcgKyAodHlwZW9mIHRoaXMudGFnKSArICcpJylcbiAgICB9XG4gICAgaWYgKCh0aGlzLnRhZyA8IDApIHx8ICgodGhpcy50YWcgfCAwKSAhPT0gdGhpcy50YWcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhZyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcjogJyArIHRoaXMudGFnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRvIGEgU3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyBvZiB0aGUgZm9ybSAnMSgyKSdcbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy50YWd9KCR7SlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZSl9KWBcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIHRoZSBzaW1wbGUgdmFsdWUgb250byB0aGUgQ0JPUiBzdHJlYW1cbiAgICpcbiAgICogQHBhcmFtIHtjYm9yLkVuY29kZXJ9IGdlbiBUaGUgZ2VuZXJhdG9yIHRvIHB1c2ggb250b1xuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZW5jb2RlQ0JPUiAoZ2VuKSB7XG4gICAgZ2VuLl9wdXNoVGFnKHRoaXMudGFnKVxuICAgIHJldHVybiBnZW4ucHVzaEFueSh0aGlzLnZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIElmIHdlIGhhdmUgYSBjb252ZXJ0ZXIgZm9yIHRoaXMgdHlwZSwgZG8gdGhlIGNvbnZlcnNpb24uICBTb21lIGNvbnZlcnRlcnNcbiAgICogYXJlIGJ1aWx0LWluLiAgQWRkaXRpb25hbCBvbmVzIGNhbiBiZSBwYXNzZWQgaW4uICBJZiB5b3Ugd2FudCB0byByZW1vdmVcbiAgICogYSBidWlsdC1pbiBjb252ZXJ0ZXIsIHBhc3MgYSBjb252ZXJ0ZXIgaW4gd2hvc2UgdmFsdWUgaXMgJ251bGwnIGluc3RlYWRcbiAgICogb2YgYSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnZlcnRlcnMgLSBrZXlzIGluIHRoZSBvYmplY3QgYXJlIGEgdGFnIG51bWJlciwgdGhlIHZhbHVlXG4gICAqICAgaXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBkZWNvZGVkIENCT1IgYW5kIHJldHVybnMgYSBKYXZhU2NyaXB0IHZhbHVlXG4gICAqICAgb2YgdGhlIGFwcHJvcHJpYXRlIHR5cGUuICBUaHJvdyBhbiBleGNlcHRpb24gaW4gdGhlIGZ1bmN0aW9uIG9uIGVycm9ycy5cbiAgICogQHJldHVybnMge2FueX0gLSB0aGUgY29udmVydGVkIGl0ZW1cbiAgICovXG4gIGNvbnZlcnQgKGNvbnZlcnRlcnMpIHtcbiAgICB2YXIgZXIsIGZcbiAgICBmID0gY29udmVydGVycyAhPSBudWxsID8gY29udmVydGVyc1t0aGlzLnRhZ10gOiB1bmRlZmluZWRcbiAgICBpZiAodHlwZW9mIGYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGYgPSBUYWdnZWRbJ190YWcnICsgdGhpcy50YWddXG4gICAgICBpZiAodHlwZW9mIGYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmLmNhbGwoVGFnZ2VkLCB0aGlzLnZhbHVlKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlciA9IGVycm9yXG4gICAgICB0aGlzLmVyciA9IGVyXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRhZ2dlZFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IE1UID0gY29uc3RhbnRzLk1UXG5jb25zdCBTSU1QTEUgPSBjb25zdGFudHMuU0lNUExFXG5jb25zdCBTWU1TID0gY29uc3RhbnRzLlNZTVNcblxuLyoqXG4gKiBBIENCT1IgU2ltcGxlIFZhbHVlIHRoYXQgZG9lcyBub3QgbWFwIG9udG8gYSBrbm93biBjb25zdGFudC5cbiAqL1xuY2xhc3MgU2ltcGxlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgU2ltcGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIC0gdGhlIHNpbXBsZSB2YWx1ZSdzIGludGVnZXIgdmFsdWVcbiAgICovXG4gIGNvbnN0cnVjdG9yICh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgU2ltcGxlIHR5cGU6ICcgKyAodHlwZW9mIHZhbHVlKSlcbiAgICB9XG4gICAgaWYgKCh2YWx1ZSA8IDApIHx8ICh2YWx1ZSA+IDI1NSkgfHwgKCh2YWx1ZSB8IDApICE9PSB2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgbXVzdCBiZSBhIHNtYWxsIHBvc2l0aXZlIGludGVnZXI6ICcgKyB2YWx1ZSlcbiAgICB9XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogRGVidWcgc3RyaW5nIGZvciBzaW1wbGUgdmFsdWVcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gc2ltcGxlKHZhbHVlKVxuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiAnc2ltcGxlKCcgKyB0aGlzLnZhbHVlICsgJyknXG4gIH1cblxuICAvKipcbiAgICogRGVidWcgc3RyaW5nIGZvciBzaW1wbGUgdmFsdWVcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gc2ltcGxlKHZhbHVlKVxuICAgKi9cbiAgaW5zcGVjdCAoKSB7XG4gICAgcmV0dXJuICdzaW1wbGUoJyArIHRoaXMudmFsdWUgKyAnKSdcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIHRoZSBzaW1wbGUgdmFsdWUgb250byB0aGUgQ0JPUiBzdHJlYW1cbiAgICpcbiAgICogQHBhcmFtIHtjYm9yLkVuY29kZXJ9IGdlbiBUaGUgZ2VuZXJhdG9yIHRvIHB1c2ggb250b1xuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZW5jb2RlQ0JPUiAoZ2VuKSB7XG4gICAgcmV0dXJuIGdlbi5fcHVzaEludCh0aGlzLnZhbHVlLCBNVC5TSU1QTEVfRkxPQVQpXG4gIH1cblxuICAvKipcbiAgICogSXMgdGhlIGdpdmVuIG9iamVjdCBhIFNpbXBsZT9cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IG9iaiAtIG9iamVjdCB0byB0ZXN0XG4gICAqIEByZXR1cm5zIHtib29sfSAtIGlzIGl0IFNpbXBsZT9cbiAgICovXG4gIHN0YXRpYyBpc1NpbXBsZSAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIFNpbXBsZVxuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBmcm9tIHRoZSBDQk9SIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gaW50byBhIEphdmFTY3JpcHQgdmFsdWUuXG4gICAqIElmIHRoZSBDQk9SIGl0ZW0gaGFzIG5vIHBhcmVudCwgcmV0dXJuIGEgXCJzYWZlXCIgc3ltYm9sIGluc3RlYWQgb2ZcbiAgICogYG51bGxgIG9yIGB1bmRlZmluZWRgLCBzbyB0aGF0IHRoZSB2YWx1ZSBjYW4gYmUgcGFzc2VkIHRocm91Z2ggYVxuICAgKiBzdHJlYW0gaW4gb2JqZWN0IG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWwgLSB0aGUgQ0JPUiBhZGRpdGlvbmFsIGluZm8gdG8gY29udmVydFxuICAgKiBAcGFyYW0ge2Jvb2x9IGhhc1BhcmVudCAtIERvZXMgdGhlIENCT1IgaXRlbSBoYXZlIGEgcGFyZW50P1xuICAgKiBAcmV0dXJucyB7KG51bGx8dW5kZWZpbmVkfEJvb2xlYW58U3ltYm9sKX0gLSB0aGUgZGVjb2RlZCB2YWx1ZVxuICAgKi9cbiAgc3RhdGljIGRlY29kZSAodmFsLCBoYXNQYXJlbnQpIHtcbiAgICBpZiAoaGFzUGFyZW50ID09IG51bGwpIHtcbiAgICAgIGhhc1BhcmVudCA9IHRydWVcbiAgICB9XG4gICAgc3dpdGNoICh2YWwpIHtcbiAgICAgIGNhc2UgU0lNUExFLkZBTFNFOlxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIGNhc2UgU0lNUExFLlRSVUU6XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICBjYXNlIFNJTVBMRS5OVUxMOlxuICAgICAgICBpZiAoaGFzUGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gU1lNUy5OVUxMXG4gICAgICAgIH1cbiAgICAgIGNhc2UgU0lNUExFLlVOREVGSU5FRDpcbiAgICAgICAgaWYgKGhhc1BhcmVudCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gU1lNUy5VTkRFRklORURcbiAgICAgICAgfVxuICAgICAgY2FzZSAtMTpcbiAgICAgICAgaWYgKCFoYXNQYXJlbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQlJFQUsnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTWU1TLkJSRUFLXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZSh2YWwpXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2ltcGxlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5jb25zdCBCaWdudW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKS5CaWdOdW1iZXJcblxuY29uc3QgcGFyc2VyID0gcmVxdWlyZSgnLi9kZWNvZGVyLmFzbScpXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgYyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IFNpbXBsZSA9IHJlcXVpcmUoJy4vc2ltcGxlJylcbmNvbnN0IFRhZ2dlZCA9IHJlcXVpcmUoJy4vdGFnZ2VkJylcbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCdpc28tdXJsJylcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYmluYXJ5IGNib3IgZGF0YSBpbnRvIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuY2xhc3MgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHM9e31dXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5zaXplPTY1NTM2XSAtIFNpemUgb2YgdGhlIGFsbG9jYXRlZCBoZWFwLlxuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgaWYgKCFvcHRzLnNpemUgfHwgb3B0cy5zaXplIDwgMHgxMDAwMCkge1xuICAgICAgb3B0cy5zaXplID0gMHgxMDAwMFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbnN1cmUgdGhlIHNpemUgaXMgYSBwb3dlciBvZiAyXG4gICAgICBvcHRzLnNpemUgPSB1dGlscy5uZXh0UG93ZXJPZjIob3B0cy5zaXplKVxuICAgIH1cblxuICAgIC8vIEhlYXAgdXNlIHRvIHNoYXJlIHRoZSBpbnB1dCB3aXRoIHRoZSBwYXJzZXJcbiAgICB0aGlzLl9oZWFwID0gbmV3IEFycmF5QnVmZmVyKG9wdHMuc2l6ZSlcbiAgICB0aGlzLl9oZWFwOCA9IG5ldyBVaW50OEFycmF5KHRoaXMuX2hlYXApXG4gICAgdGhpcy5fYnVmZmVyID0gQnVmZmVyLmZyb20odGhpcy5faGVhcClcblxuICAgIHRoaXMuX3Jlc2V0KClcblxuICAgIC8vIEtub3duIHRhZ3NcbiAgICB0aGlzLl9rbm93blRhZ3MgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIDA6ICh2YWwpID0+IG5ldyBEYXRlKHZhbCksXG4gICAgICAxOiAodmFsKSA9PiBuZXcgRGF0ZSh2YWwgKiAxMDAwKSxcbiAgICAgIDI6ICh2YWwpID0+IHV0aWxzLmFycmF5QnVmZmVyVG9CaWdudW1iZXIodmFsKSxcbiAgICAgIDM6ICh2YWwpID0+IGMuTkVHX09ORS5taW51cyh1dGlscy5hcnJheUJ1ZmZlclRvQmlnbnVtYmVyKHZhbCkpLFxuICAgICAgNDogKHYpID0+IHtcbiAgICAgICAgLy8gY29uc3QgdiA9IG5ldyBVaW50OEFycmF5KHZhbClcbiAgICAgICAgcmV0dXJuIGMuVEVOLnBvdyh2WzBdKS50aW1lcyh2WzFdKVxuICAgICAgfSxcbiAgICAgIDU6ICh2KSA9PiB7XG4gICAgICAgIC8vIGNvbnN0IHYgPSBuZXcgVWludDhBcnJheSh2YWwpXG4gICAgICAgIHJldHVybiBjLlRXTy5wb3codlswXSkudGltZXModlsxXSlcbiAgICAgIH0sXG4gICAgICAzMjogKHZhbCkgPT4gbmV3IFVSTCh2YWwpLFxuICAgICAgMzU6ICh2YWwpID0+IG5ldyBSZWdFeHAodmFsKVxuICAgIH0sIG9wdHMudGFncylcblxuICAgIC8vIEluaXRpYWxpemUgYXNtIGJhc2VkIHBhcnNlclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyKGdsb2JhbCwge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGxvZzogY29uc29sZS5sb2cuYmluZChjb25zb2xlKSxcbiAgICAgIHB1c2hJbnQ6IHRoaXMucHVzaEludC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEludDMyOiB0aGlzLnB1c2hJbnQzMi5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEludDMyTmVnOiB0aGlzLnB1c2hJbnQzMk5lZy5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEludDY0OiB0aGlzLnB1c2hJbnQ2NC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEludDY0TmVnOiB0aGlzLnB1c2hJbnQ2NE5lZy5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEZsb2F0OiB0aGlzLnB1c2hGbG9hdC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEZsb2F0U2luZ2xlOiB0aGlzLnB1c2hGbG9hdFNpbmdsZS5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEZsb2F0RG91YmxlOiB0aGlzLnB1c2hGbG9hdERvdWJsZS5iaW5kKHRoaXMpLFxuICAgICAgcHVzaFRydWU6IHRoaXMucHVzaFRydWUuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hGYWxzZTogdGhpcy5wdXNoRmFsc2UuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hVbmRlZmluZWQ6IHRoaXMucHVzaFVuZGVmaW5lZC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaE51bGw6IHRoaXMucHVzaE51bGwuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hJbmZpbml0eTogdGhpcy5wdXNoSW5maW5pdHkuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hJbmZpbml0eU5lZzogdGhpcy5wdXNoSW5maW5pdHlOZWcuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hOYU46IHRoaXMucHVzaE5hTi5iaW5kKHRoaXMpLFxuICAgICAgcHVzaE5hTk5lZzogdGhpcy5wdXNoTmFOTmVnLmJpbmQodGhpcyksXG4gICAgICBwdXNoQXJyYXlTdGFydDogdGhpcy5wdXNoQXJyYXlTdGFydC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEFycmF5U3RhcnRGaXhlZDogdGhpcy5wdXNoQXJyYXlTdGFydEZpeGVkLmJpbmQodGhpcyksXG4gICAgICBwdXNoQXJyYXlTdGFydEZpeGVkMzI6IHRoaXMucHVzaEFycmF5U3RhcnRGaXhlZDMyLmJpbmQodGhpcyksXG4gICAgICBwdXNoQXJyYXlTdGFydEZpeGVkNjQ6IHRoaXMucHVzaEFycmF5U3RhcnRGaXhlZDY0LmJpbmQodGhpcyksXG4gICAgICBwdXNoT2JqZWN0U3RhcnQ6IHRoaXMucHVzaE9iamVjdFN0YXJ0LmJpbmQodGhpcyksXG4gICAgICBwdXNoT2JqZWN0U3RhcnRGaXhlZDogdGhpcy5wdXNoT2JqZWN0U3RhcnRGaXhlZC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaE9iamVjdFN0YXJ0Rml4ZWQzMjogdGhpcy5wdXNoT2JqZWN0U3RhcnRGaXhlZDMyLmJpbmQodGhpcyksXG4gICAgICBwdXNoT2JqZWN0U3RhcnRGaXhlZDY0OiB0aGlzLnB1c2hPYmplY3RTdGFydEZpeGVkNjQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hCeXRlU3RyaW5nOiB0aGlzLnB1c2hCeXRlU3RyaW5nLmJpbmQodGhpcyksXG4gICAgICBwdXNoQnl0ZVN0cmluZ1N0YXJ0OiB0aGlzLnB1c2hCeXRlU3RyaW5nU3RhcnQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hVdGY4U3RyaW5nOiB0aGlzLnB1c2hVdGY4U3RyaW5nLmJpbmQodGhpcyksXG4gICAgICBwdXNoVXRmOFN0cmluZ1N0YXJ0OiB0aGlzLnB1c2hVdGY4U3RyaW5nU3RhcnQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hTaW1wbGVVbmFzc2lnbmVkOiB0aGlzLnB1c2hTaW1wbGVVbmFzc2lnbmVkLmJpbmQodGhpcyksXG4gICAgICBwdXNoVGFnVW5hc3NpZ25lZDogdGhpcy5wdXNoVGFnVW5hc3NpZ25lZC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaFRhZ1N0YXJ0OiB0aGlzLnB1c2hUYWdTdGFydC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaFRhZ1N0YXJ0NDogdGhpcy5wdXNoVGFnU3RhcnQ0LmJpbmQodGhpcyksXG4gICAgICBwdXNoVGFnU3RhcnQ4OiB0aGlzLnB1c2hUYWdTdGFydDguYmluZCh0aGlzKSxcbiAgICAgIHB1c2hCcmVhazogdGhpcy5wdXNoQnJlYWsuYmluZCh0aGlzKVxuICAgIH0sIHRoaXMuX2hlYXApXG4gIH1cblxuICBnZXQgX2RlcHRoICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50cy5sZW5ndGhcbiAgfVxuXG4gIGdldCBfY3VycmVudFBhcmVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudHNbdGhpcy5fZGVwdGggLSAxXVxuICB9XG5cbiAgZ2V0IF9yZWYgKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50UGFyZW50LnJlZlxuICB9XG5cbiAgLy8gRmluaXNoIHRoZSBjdXJyZW50IHBhcmVudFxuICBfY2xvc2VQYXJlbnQgKCkge1xuICAgIHZhciBwID0gdGhpcy5fcGFyZW50cy5wb3AoKVxuXG4gICAgaWYgKHAubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nICR7cC5sZW5ndGh9IGVsZW1lbnRzYClcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHAudHlwZSkge1xuICAgICAgY2FzZSBjLlBBUkVOVC5UQUc6XG4gICAgICAgIHRoaXMuX3B1c2goXG4gICAgICAgICAgdGhpcy5jcmVhdGVUYWcocC5yZWZbMF0sIHAucmVmWzFdKVxuICAgICAgICApXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIGMuUEFSRU5ULkJZVEVfU1RSSU5HOlxuICAgICAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlQnl0ZVN0cmluZyhwLnJlZiwgcC5sZW5ndGgpKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBjLlBBUkVOVC5VVEY4X1NUUklORzpcbiAgICAgICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZVV0ZjhTdHJpbmcocC5yZWYsIHAubGVuZ3RoKSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgYy5QQVJFTlQuTUFQOlxuICAgICAgICBpZiAocC52YWx1ZXMgJSAyID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2RkIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgbWFwJylcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlTWFwKHAucmVmLCBwLmxlbmd0aCkpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIGMuUEFSRU5ULk9CSkVDVDpcbiAgICAgICAgaWYgKHAudmFsdWVzICUgMiA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09kZCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIG1hcCcpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZU9iamVjdChwLnJlZiwgcC5sZW5ndGgpKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBjLlBBUkVOVC5BUlJBWTpcbiAgICAgICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZUFycmF5KHAucmVmLCBwLmxlbmd0aCkpXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jdXJyZW50UGFyZW50ICYmIHRoaXMuX2N1cnJlbnRQYXJlbnQudHlwZSA9PT0gYy5QQVJFTlQuVEFHKSB7XG4gICAgICB0aGlzLl9kZWMoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlZHVjZSB0aGUgZXhwZWN0ZWQgbGVuZ3RoIG9mIHRoZSBjdXJyZW50IHBhcmVudCBieSBvbmVcbiAgX2RlYyAoKSB7XG4gICAgY29uc3QgcCA9IHRoaXMuX2N1cnJlbnRQYXJlbnRcbiAgICAvLyBUaGUgY3VycmVudCBwYXJlbnQgZG9lcyBub3Qga25vdyB0aGUgZXB4ZWN0ZWQgY2hpbGQgbGVuZ3RoXG5cbiAgICBpZiAocC5sZW5ndGggPCAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBwLmxlbmd0aC0tXG5cbiAgICAvLyBBbGwgY2hpbGRyZW4gd2VyZSBzZWVuLCB3ZSBjYW4gY2xvc2UgdGhlIGN1cnJlbnQgcGFyZW50XG4gICAgaWYgKHAubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9jbG9zZVBhcmVudCgpXG4gICAgfVxuICB9XG5cbiAgLy8gUHVzaCBhbnkgdmFsdWUgdG8gdGhlIGN1cnJlbnQgcGFyZW50XG4gIF9wdXNoICh2YWwsIGhhc0NoaWxkcmVuKSB7XG4gICAgY29uc3QgcCA9IHRoaXMuX2N1cnJlbnRQYXJlbnRcbiAgICBwLnZhbHVlcysrXG5cbiAgICBzd2l0Y2ggKHAudHlwZSkge1xuICAgICAgY2FzZSBjLlBBUkVOVC5BUlJBWTpcbiAgICAgIGNhc2UgYy5QQVJFTlQuQllURV9TVFJJTkc6XG4gICAgICBjYXNlIGMuUEFSRU5ULlVURjhfU1RSSU5HOlxuICAgICAgICBpZiAocC5sZW5ndGggPiAtMSkge1xuICAgICAgICAgIHRoaXMuX3JlZlt0aGlzLl9yZWYubGVuZ3RoIC0gcC5sZW5ndGhdID0gdmFsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcmVmLnB1c2godmFsKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlYygpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIGMuUEFSRU5ULk9CSkVDVDpcbiAgICAgICAgaWYgKHAudG1wS2V5ICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl9yZWZbcC50bXBLZXldID0gdmFsXG4gICAgICAgICAgcC50bXBLZXkgPSBudWxsXG4gICAgICAgICAgdGhpcy5fZGVjKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwLnRtcEtleSA9IHZhbFxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBwLnRtcEtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIHRvbyBiYWQsIGNvbnZlcnQgdG8gYSBNYXBcbiAgICAgICAgICAgIHAudHlwZSA9IGMuUEFSRU5ULk1BUFxuICAgICAgICAgICAgcC5yZWYgPSB1dGlscy5idWlsZE1hcChwLnJlZilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgYy5QQVJFTlQuTUFQOlxuICAgICAgICBpZiAocC50bXBLZXkgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX3JlZi5zZXQocC50bXBLZXksIHZhbClcbiAgICAgICAgICBwLnRtcEtleSA9IG51bGxcbiAgICAgICAgICB0aGlzLl9kZWMoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHAudG1wS2V5ID0gdmFsXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgYy5QQVJFTlQuVEFHOlxuICAgICAgICB0aGlzLl9yZWYucHVzaCh2YWwpXG4gICAgICAgIGlmICghaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgICB0aGlzLl9kZWMoKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcGFyZW50IHR5cGUnKVxuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSBhIG5ldyBwYXJlbnQgaW4gdGhlIHBhcmVudHMgbGlzdFxuICBfY3JlYXRlUGFyZW50IChvYmosIHR5cGUsIGxlbikge1xuICAgIHRoaXMuX3BhcmVudHNbdGhpcy5fZGVwdGhdID0ge1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGxlbmd0aDogbGVuLFxuICAgICAgcmVmOiBvYmosXG4gICAgICB2YWx1ZXM6IDAsXG4gICAgICB0bXBLZXk6IG51bGxcbiAgICB9XG4gIH1cblxuICAvLyBSZXNldCBhbGwgc3RhdGUgYmFjayB0byB0aGUgYmVnaW5uaW5nLCBhbHNvIHVzZWQgZm9yIGluaXRpYXRsaXphdGlvblxuICBfcmVzZXQgKCkge1xuICAgIHRoaXMuX3JlcyA9IFtdXG4gICAgdGhpcy5fcGFyZW50cyA9IFt7XG4gICAgICB0eXBlOiBjLlBBUkVOVC5BUlJBWSxcbiAgICAgIGxlbmd0aDogLTEsXG4gICAgICByZWY6IHRoaXMuX3JlcyxcbiAgICAgIHZhbHVlczogMCxcbiAgICAgIHRtcEtleTogbnVsbFxuICAgIH1dXG4gIH1cblxuICAvLyAtLSBJbnRlcmZhY2UgdG8gY3VzdG9taXplIGRlb2RpbmcgYmVoYXZpb3VyXG4gIGNyZWF0ZVRhZyAodGFnTnVtYmVyLCB2YWx1ZSkge1xuICAgIGNvbnN0IHR5cCA9IHRoaXMuX2tub3duVGFnc1t0YWdOdW1iZXJdXG5cbiAgICBpZiAoIXR5cCkge1xuICAgICAgcmV0dXJuIG5ldyBUYWdnZWQodGFnTnVtYmVyLCB2YWx1ZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwKHZhbHVlKVxuICB9XG5cbiAgY3JlYXRlTWFwIChvYmosIGxlbikge1xuICAgIHJldHVybiBvYmpcbiAgfVxuXG4gIGNyZWF0ZU9iamVjdCAob2JqLCBsZW4pIHtcbiAgICByZXR1cm4gb2JqXG4gIH1cblxuICBjcmVhdGVBcnJheSAoYXJyLCBsZW4pIHtcbiAgICByZXR1cm4gYXJyXG4gIH1cblxuICBjcmVhdGVCeXRlU3RyaW5nIChyYXcsIGxlbikge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KHJhdylcbiAgfVxuXG4gIGNyZWF0ZUJ5dGVTdHJpbmdGcm9tSGVhcCAoc3RhcnQsIGVuZCkge1xuICAgIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gICAgfVxuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMuX2hlYXAuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cblxuICBjcmVhdGVJbnQgKHZhbCkge1xuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIGNyZWF0ZUludDMyIChmLCBnKSB7XG4gICAgcmV0dXJuIHV0aWxzLmJ1aWxkSW50MzIoZiwgZylcbiAgfVxuXG4gIGNyZWF0ZUludDY0IChmMSwgZjIsIGcxLCBnMikge1xuICAgIHJldHVybiB1dGlscy5idWlsZEludDY0KGYxLCBmMiwgZzEsIGcyKVxuICB9XG5cbiAgY3JlYXRlRmxvYXQgKHZhbCkge1xuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIGNyZWF0ZUZsb2F0U2luZ2xlIChhLCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGllZWU3NTQucmVhZChbYSwgYiwgYywgZF0sIDAsIGZhbHNlLCAyMywgNClcbiAgfVxuXG4gIGNyZWF0ZUZsb2F0RG91YmxlIChhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSB7XG4gICAgcmV0dXJuIGllZWU3NTQucmVhZChbYSwgYiwgYywgZCwgZSwgZiwgZywgaF0sIDAsIGZhbHNlLCA1MiwgOClcbiAgfVxuXG4gIGNyZWF0ZUludDMyTmVnIChmLCBnKSB7XG4gICAgcmV0dXJuIC0xIC0gdXRpbHMuYnVpbGRJbnQzMihmLCBnKVxuICB9XG5cbiAgY3JlYXRlSW50NjROZWcgKGYxLCBmMiwgZzEsIGcyKSB7XG4gICAgY29uc3QgZiA9IHV0aWxzLmJ1aWxkSW50MzIoZjEsIGYyKVxuICAgIGNvbnN0IGcgPSB1dGlscy5idWlsZEludDMyKGcxLCBnMilcblxuICAgIGlmIChmID4gYy5NQVhfU0FGRV9ISUdIKSB7XG4gICAgICByZXR1cm4gYy5ORUdfT05FLm1pbnVzKG5ldyBCaWdudW1iZXIoZikudGltZXMoYy5TSElGVDMyKS5wbHVzKGcpKVxuICAgIH1cblxuICAgIHJldHVybiAtMSAtICgoZiAqIGMuU0hJRlQzMikgKyBnKVxuICB9XG5cbiAgY3JlYXRlVHJ1ZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNyZWF0ZUZhbHNlICgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNyZWF0ZU51bGwgKCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjcmVhdGVVbmRlZmluZWQgKCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGNyZWF0ZUluZmluaXR5ICgpIHtcbiAgICByZXR1cm4gSW5maW5pdHlcbiAgfVxuXG4gIGNyZWF0ZUluZmluaXR5TmVnICgpIHtcbiAgICByZXR1cm4gLUluZmluaXR5XG4gIH1cblxuICBjcmVhdGVOYU4gKCkge1xuICAgIHJldHVybiBOYU5cbiAgfVxuXG4gIGNyZWF0ZU5hTk5lZyAoKSB7XG4gICAgcmV0dXJuIC1OYU5cbiAgfVxuXG4gIGNyZWF0ZVV0ZjhTdHJpbmcgKHJhdywgbGVuKSB7XG4gICAgcmV0dXJuIHJhdy5qb2luKCcnKVxuICB9XG5cbiAgY3JlYXRlVXRmOFN0cmluZ0Zyb21IZWFwIChzdGFydCwgZW5kKSB7XG4gICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9idWZmZXIudG9TdHJpbmcoJ3V0ZjgnLCBzdGFydCwgZW5kKVxuICB9XG5cbiAgY3JlYXRlU2ltcGxlVW5hc3NpZ25lZCAodmFsKSB7XG4gICAgcmV0dXJuIG5ldyBTaW1wbGUodmFsKVxuICB9XG5cbiAgLy8gLS0gSW50ZXJmYWNlIGZvciBkZWNvZGVyLmFzbS5qc1xuXG4gIHB1c2hJbnQgKHZhbCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVJbnQodmFsKSlcbiAgfVxuXG4gIHB1c2hJbnQzMiAoZiwgZykge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVJbnQzMihmLCBnKSlcbiAgfVxuXG4gIHB1c2hJbnQ2NCAoZjEsIGYyLCBnMSwgZzIpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlSW50NjQoZjEsIGYyLCBnMSwgZzIpKVxuICB9XG5cbiAgcHVzaEZsb2F0ICh2YWwpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlRmxvYXQodmFsKSlcbiAgfVxuXG4gIHB1c2hGbG9hdFNpbmdsZSAoYSwgYiwgYywgZCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVGbG9hdFNpbmdsZShhLCBiLCBjLCBkKSlcbiAgfVxuXG4gIHB1c2hGbG9hdERvdWJsZSAoYSwgYiwgYywgZCwgZSwgZiwgZywgaCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVGbG9hdERvdWJsZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSlcbiAgfVxuXG4gIHB1c2hJbnQzMk5lZyAoZiwgZykge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVJbnQzMk5lZyhmLCBnKSlcbiAgfVxuXG4gIHB1c2hJbnQ2NE5lZyAoZjEsIGYyLCBnMSwgZzIpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlSW50NjROZWcoZjEsIGYyLCBnMSwgZzIpKVxuICB9XG5cbiAgcHVzaFRydWUgKCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVUcnVlKCkpXG4gIH1cblxuICBwdXNoRmFsc2UgKCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVGYWxzZSgpKVxuICB9XG5cbiAgcHVzaE51bGwgKCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVOdWxsKCkpXG4gIH1cblxuICBwdXNoVW5kZWZpbmVkICgpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlVW5kZWZpbmVkKCkpXG4gIH1cblxuICBwdXNoSW5maW5pdHkgKCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVJbmZpbml0eSgpKVxuICB9XG5cbiAgcHVzaEluZmluaXR5TmVnICgpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlSW5maW5pdHlOZWcoKSlcbiAgfVxuXG4gIHB1c2hOYU4gKCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVOYU4oKSlcbiAgfVxuXG4gIHB1c2hOYU5OZWcgKCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVOYU5OZWcoKSlcbiAgfVxuXG4gIHB1c2hBcnJheVN0YXJ0ICgpIHtcbiAgICB0aGlzLl9jcmVhdGVQYXJlbnQoW10sIGMuUEFSRU5ULkFSUkFZLCAtMSlcbiAgfVxuXG4gIHB1c2hBcnJheVN0YXJ0Rml4ZWQgKGxlbikge1xuICAgIHRoaXMuX2NyZWF0ZUFycmF5U3RhcnRGaXhlZChsZW4pXG4gIH1cblxuICBwdXNoQXJyYXlTdGFydEZpeGVkMzIgKGxlbjEsIGxlbjIpIHtcbiAgICBjb25zdCBsZW4gPSB1dGlscy5idWlsZEludDMyKGxlbjEsIGxlbjIpXG4gICAgdGhpcy5fY3JlYXRlQXJyYXlTdGFydEZpeGVkKGxlbilcbiAgfVxuXG4gIHB1c2hBcnJheVN0YXJ0Rml4ZWQ2NCAobGVuMSwgbGVuMiwgbGVuMywgbGVuNCkge1xuICAgIGNvbnN0IGxlbiA9IHV0aWxzLmJ1aWxkSW50NjQobGVuMSwgbGVuMiwgbGVuMywgbGVuNClcbiAgICB0aGlzLl9jcmVhdGVBcnJheVN0YXJ0Rml4ZWQobGVuKVxuICB9XG5cbiAgcHVzaE9iamVjdFN0YXJ0ICgpIHtcbiAgICB0aGlzLl9jcmVhdGVPYmplY3RTdGFydEZpeGVkKC0xKVxuICB9XG5cbiAgcHVzaE9iamVjdFN0YXJ0Rml4ZWQgKGxlbikge1xuICAgIHRoaXMuX2NyZWF0ZU9iamVjdFN0YXJ0Rml4ZWQobGVuKVxuICB9XG5cbiAgcHVzaE9iamVjdFN0YXJ0Rml4ZWQzMiAobGVuMSwgbGVuMikge1xuICAgIGNvbnN0IGxlbiA9IHV0aWxzLmJ1aWxkSW50MzIobGVuMSwgbGVuMilcbiAgICB0aGlzLl9jcmVhdGVPYmplY3RTdGFydEZpeGVkKGxlbilcbiAgfVxuXG4gIHB1c2hPYmplY3RTdGFydEZpeGVkNjQgKGxlbjEsIGxlbjIsIGxlbjMsIGxlbjQpIHtcbiAgICBjb25zdCBsZW4gPSB1dGlscy5idWlsZEludDY0KGxlbjEsIGxlbjIsIGxlbjMsIGxlbjQpXG4gICAgdGhpcy5fY3JlYXRlT2JqZWN0U3RhcnRGaXhlZChsZW4pXG4gIH1cblxuICBwdXNoQnl0ZVN0cmluZ1N0YXJ0ICgpIHtcbiAgICB0aGlzLl9wYXJlbnRzW3RoaXMuX2RlcHRoXSA9IHtcbiAgICAgIHR5cGU6IGMuUEFSRU5ULkJZVEVfU1RSSU5HLFxuICAgICAgbGVuZ3RoOiAtMSxcbiAgICAgIHJlZjogW10sXG4gICAgICB2YWx1ZXM6IDAsXG4gICAgICB0bXBLZXk6IG51bGxcbiAgICB9XG4gIH1cblxuICBwdXNoQnl0ZVN0cmluZyAoc3RhcnQsIGVuZCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVCeXRlU3RyaW5nRnJvbUhlYXAoc3RhcnQsIGVuZCkpXG4gIH1cblxuICBwdXNoVXRmOFN0cmluZ1N0YXJ0ICgpIHtcbiAgICB0aGlzLl9wYXJlbnRzW3RoaXMuX2RlcHRoXSA9IHtcbiAgICAgIHR5cGU6IGMuUEFSRU5ULlVURjhfU1RSSU5HLFxuICAgICAgbGVuZ3RoOiAtMSxcbiAgICAgIHJlZjogW10sXG4gICAgICB2YWx1ZXM6IDAsXG4gICAgICB0bXBLZXk6IG51bGxcbiAgICB9XG4gIH1cblxuICBwdXNoVXRmOFN0cmluZyAoc3RhcnQsIGVuZCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVVdGY4U3RyaW5nRnJvbUhlYXAoc3RhcnQsIGVuZCkpXG4gIH1cblxuICBwdXNoU2ltcGxlVW5hc3NpZ25lZCAodmFsKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZVNpbXBsZVVuYXNzaWduZWQodmFsKSlcbiAgfVxuXG4gIHB1c2hUYWdTdGFydCAodGFnKSB7XG4gICAgdGhpcy5fcGFyZW50c1t0aGlzLl9kZXB0aF0gPSB7XG4gICAgICB0eXBlOiBjLlBBUkVOVC5UQUcsXG4gICAgICBsZW5ndGg6IDEsXG4gICAgICByZWY6IFt0YWddXG4gICAgfVxuICB9XG5cbiAgcHVzaFRhZ1N0YXJ0NCAoZiwgZykge1xuICAgIHRoaXMucHVzaFRhZ1N0YXJ0KHV0aWxzLmJ1aWxkSW50MzIoZiwgZykpXG4gIH1cblxuICBwdXNoVGFnU3RhcnQ4IChmMSwgZjIsIGcxLCBnMikge1xuICAgIHRoaXMucHVzaFRhZ1N0YXJ0KHV0aWxzLmJ1aWxkSW50NjQoZjEsIGYyLCBnMSwgZzIpKVxuICB9XG5cbiAgcHVzaFRhZ1VuYXNzaWduZWQgKHRhZ051bWJlcikge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVUYWcodGFnTnVtYmVyKSlcbiAgfVxuXG4gIHB1c2hCcmVhayAoKSB7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRQYXJlbnQubGVuZ3RoID4gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBicmVhaycpXG4gICAgfVxuXG4gICAgdGhpcy5fY2xvc2VQYXJlbnQoKVxuICB9XG5cbiAgX2NyZWF0ZU9iamVjdFN0YXJ0Rml4ZWQgKGxlbikge1xuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVPYmplY3Qoe30pKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fY3JlYXRlUGFyZW50KHt9LCBjLlBBUkVOVC5PQkpFQ1QsIGxlbilcbiAgfVxuXG4gIF9jcmVhdGVBcnJheVN0YXJ0Rml4ZWQgKGxlbikge1xuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVBcnJheShbXSkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9jcmVhdGVQYXJlbnQobmV3IEFycmF5KGxlbiksIGMuUEFSRU5ULkFSUkFZLCBsZW4pXG4gIH1cblxuICBfZGVjb2RlIChpbnB1dCkge1xuICAgIGlmIChpbnB1dC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHRvbyBzaG9ydCcpXG4gICAgfVxuXG4gICAgdGhpcy5fcmVzZXQoKVxuICAgIHRoaXMuX2hlYXA4LnNldChpbnB1dClcbiAgICBjb25zdCBjb2RlID0gdGhpcy5wYXJzZXIucGFyc2UoaW5wdXQuYnl0ZUxlbmd0aClcblxuICAgIGlmICh0aGlzLl9kZXB0aCA+IDEpIHtcbiAgICAgIHdoaWxlICh0aGlzLl9jdXJyZW50UGFyZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9jbG9zZVBhcmVudCgpXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fZGVwdGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5kZXRlcm1pbmF0ZWQgbmVzdGluZycpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZScpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3Jlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgcmVzdWx0JylcbiAgICB9XG4gIH1cblxuICAvLyAtLSBQdWJsaWMgSW50ZXJmYWNlXG5cbiAgZGVjb2RlRmlyc3QgKGlucHV0KSB7XG4gICAgdGhpcy5fZGVjb2RlKGlucHV0KVxuXG4gICAgcmV0dXJuIHRoaXMuX3Jlc1swXVxuICB9XG5cbiAgZGVjb2RlQWxsIChpbnB1dCkge1xuICAgIHRoaXMuX2RlY29kZShpbnB1dClcblxuICAgIHJldHVybiB0aGlzLl9yZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgdGhlIGZpcnN0IGNib3Igb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd9IGlucHV0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jPSdoZXgnXSAtIEVuY29kaW5nIHVzZWQgaWYgYSBzdHJpbmcgaXMgcGFzc2VkLlxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHN0YXRpYyBkZWNvZGUgKGlucHV0LCBlbmMpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgaW5wdXQgPSBCdWZmZXIuZnJvbShpbnB1dCwgZW5jIHx8ICdoZXgnKVxuICAgIH1cblxuICAgIGNvbnN0IGRlYyA9IG5ldyBEZWNvZGVyKHsgc2l6ZTogaW5wdXQubGVuZ3RoIH0pXG4gICAgcmV0dXJuIGRlYy5kZWNvZGVGaXJzdChpbnB1dClcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYWxsIGNib3Igb2JqZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSBpbnB1dFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2VuYz0naGV4J10gLSBFbmNvZGluZyB1c2VkIGlmIGEgc3RyaW5nIGlzIHBhc3NlZC5cbiAgICogQHJldHVybnMge0FycmF5PCo+fVxuICAgKi9cbiAgc3RhdGljIGRlY29kZUFsbCAoaW5wdXQsIGVuYykge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpbnB1dCA9IEJ1ZmZlci5mcm9tKGlucHV0LCBlbmMgfHwgJ2hleCcpXG4gICAgfVxuXG4gICAgY29uc3QgZGVjID0gbmV3IERlY29kZXIoeyBzaXplOiBpbnB1dC5sZW5ndGggfSlcbiAgICByZXR1cm4gZGVjLmRlY29kZUFsbChpbnB1dClcbiAgfVxufVxuXG5EZWNvZGVyLmRlY29kZUZpcnN0ID0gRGVjb2Rlci5kZWNvZGVcblxubW9kdWxlLmV4cG9ydHMgPSBEZWNvZGVyXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBEZWNvZGVyID0gcmVxdWlyZSgnLi9kZWNvZGVyJylcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5cbi8qKlxuICogT3V0cHV0IHRoZSBkaWFnbm9zdGljIGZvcm1hdCBmcm9tIGEgc3RyZWFtIG9mIENCT1IgYnl0ZXMuXG4gKlxuICovXG5jbGFzcyBEaWFnbm9zZSBleHRlbmRzIERlY29kZXIge1xuICBjcmVhdGVUYWcgKHRhZ051bWJlciwgdmFsdWUpIHtcbiAgICByZXR1cm4gYCR7dGFnTnVtYmVyfSgke3ZhbHVlfSlgXG4gIH1cblxuICBjcmVhdGVJbnQgKHZhbCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVJbnQodmFsKS50b1N0cmluZygpXG4gIH1cblxuICBjcmVhdGVJbnQzMiAoZiwgZykge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVJbnQzMihmLCBnKS50b1N0cmluZygpXG4gIH1cblxuICBjcmVhdGVJbnQ2NCAoZjEsIGYyLCBnMSwgZzIpIHtcbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlSW50NjQoZjEsIGYyLCBnMSwgZzIpLnRvU3RyaW5nKClcbiAgfVxuXG4gIGNyZWF0ZUludDMyTmVnIChmLCBnKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUludDMyTmVnKGYsIGcpLnRvU3RyaW5nKClcbiAgfVxuXG4gIGNyZWF0ZUludDY0TmVnIChmMSwgZjIsIGcxLCBnMikge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVJbnQ2NE5lZyhmMSwgZjIsIGcxLCBnMikudG9TdHJpbmcoKVxuICB9XG5cbiAgY3JlYXRlVHJ1ZSAoKSB7XG4gICAgcmV0dXJuICd0cnVlJ1xuICB9XG5cbiAgY3JlYXRlRmFsc2UgKCkge1xuICAgIHJldHVybiAnZmFsc2UnXG4gIH1cblxuICBjcmVhdGVGbG9hdCAodmFsKSB7XG4gICAgY29uc3QgZmwgPSBzdXBlci5jcmVhdGVGbG9hdCh2YWwpXG4gICAgaWYgKHV0aWxzLmlzTmVnYXRpdmVaZXJvKHZhbCkpIHtcbiAgICAgIHJldHVybiAnLTBfMSdcbiAgICB9XG5cbiAgICByZXR1cm4gYCR7Zmx9XzFgXG4gIH1cblxuICBjcmVhdGVGbG9hdFNpbmdsZSAoYSwgYiwgYywgZCkge1xuICAgIGNvbnN0IGZsID0gc3VwZXIuY3JlYXRlRmxvYXRTaW5nbGUoYSwgYiwgYywgZClcbiAgICByZXR1cm4gYCR7Zmx9XzJgXG4gIH1cblxuICBjcmVhdGVGbG9hdERvdWJsZSAoYSwgYiwgYywgZCwgZSwgZiwgZywgaCkge1xuICAgIGNvbnN0IGZsID0gc3VwZXIuY3JlYXRlRmxvYXREb3VibGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaClcbiAgICByZXR1cm4gYCR7Zmx9XzNgXG4gIH1cblxuICBjcmVhdGVCeXRlU3RyaW5nIChyYXcsIGxlbikge1xuICAgIGNvbnN0IHZhbCA9IHJhdy5qb2luKCcsICcpXG5cbiAgICBpZiAobGVuID09PSAtMSkge1xuICAgICAgcmV0dXJuIGAoXyAke3ZhbH0pYFxuICAgIH1cbiAgICByZXR1cm4gYGgnJHt2YWx9YFxuICB9XG5cbiAgY3JlYXRlQnl0ZVN0cmluZ0Zyb21IZWFwIChzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgdmFsID0gKEJ1ZmZlci5mcm9tKFxuICAgICAgc3VwZXIuY3JlYXRlQnl0ZVN0cmluZ0Zyb21IZWFwKHN0YXJ0LCBlbmQpXG4gICAgKSkudG9TdHJpbmcoJ2hleCcpXG5cbiAgICByZXR1cm4gYGgnJHt2YWx9J2BcbiAgfVxuXG4gIGNyZWF0ZUluZmluaXR5ICgpIHtcbiAgICByZXR1cm4gJ0luZmluaXR5XzEnXG4gIH1cblxuICBjcmVhdGVJbmZpbml0eU5lZyAoKSB7XG4gICAgcmV0dXJuICctSW5maW5pdHlfMSdcbiAgfVxuXG4gIGNyZWF0ZU5hTiAoKSB7XG4gICAgcmV0dXJuICdOYU5fMSdcbiAgfVxuXG4gIGNyZWF0ZU5hTk5lZyAoKSB7XG4gICAgcmV0dXJuICctTmFOXzEnXG4gIH1cblxuICBjcmVhdGVOdWxsICgpIHtcbiAgICByZXR1cm4gJ251bGwnXG4gIH1cblxuICBjcmVhdGVVbmRlZmluZWQgKCkge1xuICAgIHJldHVybiAndW5kZWZpbmVkJ1xuICB9XG5cbiAgY3JlYXRlU2ltcGxlVW5hc3NpZ25lZCAodmFsKSB7XG4gICAgcmV0dXJuIGBzaW1wbGUoJHt2YWx9KWBcbiAgfVxuXG4gIGNyZWF0ZUFycmF5IChhcnIsIGxlbikge1xuICAgIGNvbnN0IHZhbCA9IHN1cGVyLmNyZWF0ZUFycmF5KGFyciwgbGVuKVxuXG4gICAgaWYgKGxlbiA9PT0gLTEpIHtcbiAgICAgIC8vIGluZGVmaW5pdGVcbiAgICAgIHJldHVybiBgW18gJHt2YWwuam9pbignLCAnKX1dYFxuICAgIH1cblxuICAgIHJldHVybiBgWyR7dmFsLmpvaW4oJywgJyl9XWBcbiAgfVxuXG4gIGNyZWF0ZU1hcCAobWFwLCBsZW4pIHtcbiAgICBjb25zdCB2YWwgPSBzdXBlci5jcmVhdGVNYXAobWFwKVxuICAgIGNvbnN0IGxpc3QgPSBBcnJheS5mcm9tKHZhbC5rZXlzKCkpXG4gICAgICAucmVkdWNlKGNvbGxlY3RPYmplY3QodmFsKSwgJycpXG5cbiAgICBpZiAobGVuID09PSAtMSkge1xuICAgICAgcmV0dXJuIGB7XyAke2xpc3R9fWBcbiAgICB9XG5cbiAgICByZXR1cm4gYHske2xpc3R9fWBcbiAgfVxuXG4gIGNyZWF0ZU9iamVjdCAob2JqLCBsZW4pIHtcbiAgICBjb25zdCB2YWwgPSBzdXBlci5jcmVhdGVPYmplY3Qob2JqKVxuICAgIGNvbnN0IG1hcCA9IE9iamVjdC5rZXlzKHZhbClcbiAgICAgIC5yZWR1Y2UoY29sbGVjdE9iamVjdCh2YWwpLCAnJylcblxuICAgIGlmIChsZW4gPT09IC0xKSB7XG4gICAgICByZXR1cm4gYHtfICR7bWFwfX1gXG4gICAgfVxuXG4gICAgcmV0dXJuIGB7JHttYXB9fWBcbiAgfVxuXG4gIGNyZWF0ZVV0ZjhTdHJpbmcgKHJhdywgbGVuKSB7XG4gICAgY29uc3QgdmFsID0gcmF3LmpvaW4oJywgJylcblxuICAgIGlmIChsZW4gPT09IC0xKSB7XG4gICAgICByZXR1cm4gYChfICR7dmFsfSlgXG4gICAgfVxuXG4gICAgcmV0dXJuIGBcIiR7dmFsfVwiYFxuICB9XG5cbiAgY3JlYXRlVXRmOFN0cmluZ0Zyb21IZWFwIChzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgdmFsID0gKEJ1ZmZlci5mcm9tKFxuICAgICAgc3VwZXIuY3JlYXRlVXRmOFN0cmluZ0Zyb21IZWFwKHN0YXJ0LCBlbmQpXG4gICAgKSkudG9TdHJpbmcoJ3V0ZjgnKVxuXG4gICAgcmV0dXJuIGBcIiR7dmFsfVwiYFxuICB9XG5cbiAgc3RhdGljIGRpYWdub3NlIChpbnB1dCwgZW5jKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlucHV0ID0gQnVmZmVyLmZyb20oaW5wdXQsIGVuYyB8fCAnaGV4JylcbiAgICB9XG5cbiAgICBjb25zdCBkZWMgPSBuZXcgRGlhZ25vc2UoKVxuICAgIHJldHVybiBkZWMuZGVjb2RlRmlyc3QoaW5wdXQpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaWFnbm9zZVxuXG5mdW5jdGlvbiBjb2xsZWN0T2JqZWN0ICh2YWwpIHtcbiAgcmV0dXJuIChhY2MsIGtleSkgPT4ge1xuICAgIGlmIChhY2MpIHtcbiAgICAgIHJldHVybiBgJHthY2N9LCAke2tleX06ICR7dmFsW2tleV19YFxuICAgIH1cbiAgICByZXR1cm4gYCR7a2V5fTogJHt2YWxba2V5XX1gXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCdpc28tdXJsJylcbmNvbnN0IEJpZ251bWJlciA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpLkJpZ051bWJlclxuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgTVQgPSBjb25zdGFudHMuTVRcbmNvbnN0IE5VTUJZVEVTID0gY29uc3RhbnRzLk5VTUJZVEVTXG5jb25zdCBTSElGVDMyID0gY29uc3RhbnRzLlNISUZUMzJcbmNvbnN0IFNZTVMgPSBjb25zdGFudHMuU1lNU1xuY29uc3QgVEFHID0gY29uc3RhbnRzLlRBR1xuY29uc3QgSEFMRiA9IChjb25zdGFudHMuTVQuU0lNUExFX0ZMT0FUIDw8IDUpIHwgY29uc3RhbnRzLk5VTUJZVEVTLlRXT1xuY29uc3QgRkxPQVQgPSAoY29uc3RhbnRzLk1ULlNJTVBMRV9GTE9BVCA8PCA1KSB8IGNvbnN0YW50cy5OVU1CWVRFUy5GT1VSXG5jb25zdCBET1VCTEUgPSAoY29uc3RhbnRzLk1ULlNJTVBMRV9GTE9BVCA8PCA1KSB8IGNvbnN0YW50cy5OVU1CWVRFUy5FSUdIVFxuY29uc3QgVFJVRSA9IChjb25zdGFudHMuTVQuU0lNUExFX0ZMT0FUIDw8IDUpIHwgY29uc3RhbnRzLlNJTVBMRS5UUlVFXG5jb25zdCBGQUxTRSA9IChjb25zdGFudHMuTVQuU0lNUExFX0ZMT0FUIDw8IDUpIHwgY29uc3RhbnRzLlNJTVBMRS5GQUxTRVxuY29uc3QgVU5ERUZJTkVEID0gKGNvbnN0YW50cy5NVC5TSU1QTEVfRkxPQVQgPDwgNSkgfCBjb25zdGFudHMuU0lNUExFLlVOREVGSU5FRFxuY29uc3QgTlVMTCA9IChjb25zdGFudHMuTVQuU0lNUExFX0ZMT0FUIDw8IDUpIHwgY29uc3RhbnRzLlNJTVBMRS5OVUxMXG5cbmNvbnN0IE1BWElOVF9CTiA9IG5ldyBCaWdudW1iZXIoJzB4MjAwMDAwMDAwMDAwMDAnKVxuY29uc3QgQlVGX05BTiA9IEJ1ZmZlci5mcm9tKCdmOTdlMDAnLCAnaGV4JylcbmNvbnN0IEJVRl9JTkZfTkVHID0gQnVmZmVyLmZyb20oJ2Y5ZmMwMCcsICdoZXgnKVxuY29uc3QgQlVGX0lORl9QT1MgPSBCdWZmZXIuZnJvbSgnZjk3YzAwJywgJ2hleCcpXG5cbmZ1bmN0aW9uIHRvVHlwZSAob2JqKSB7XG4gIC8vIFtvYmplY3QgVHlwZV1cbiAgLy8gLS0tLS0tLS04LS0tMVxuICByZXR1cm4gKHt9KS50b1N0cmluZy5jYWxsKG9iaikuc2xpY2UoOCwgLTEpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIEphdmFTY3JpcHQgdmFsdWVzIGludG8gQ0JPUiBieXRlc1xuICpcbiAqL1xuY2xhc3MgRW5jb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oQnVmZmVyKX0gb3B0aW9ucy5zdHJlYW1cbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICAgIHRoaXMuc3RyZWFtaW5nID0gdHlwZW9mIG9wdGlvbnMuc3RyZWFtID09PSAnZnVuY3Rpb24nXG4gICAgdGhpcy5vbkRhdGEgPSBvcHRpb25zLnN0cmVhbVxuXG4gICAgdGhpcy5zZW1hbnRpY1R5cGVzID0gW1xuICAgICAgW1VSTCwgdGhpcy5fcHVzaFVybF0sXG4gICAgICBbQmlnbnVtYmVyLCB0aGlzLl9wdXNoQmlnTnVtYmVyXVxuICAgIF1cblxuICAgIGNvbnN0IGFkZFR5cGVzID0gb3B0aW9ucy5nZW5UeXBlcyB8fCBbXVxuICAgIGNvbnN0IGxlbiA9IGFkZFR5cGVzLmxlbmd0aFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMuYWRkU2VtYW50aWNUeXBlKFxuICAgICAgICBhZGRUeXBlc1tpXVswXSxcbiAgICAgICAgYWRkVHlwZXNbaV1bMV1cbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLl9yZXNldCgpXG4gIH1cblxuICBhZGRTZW1hbnRpY1R5cGUgKHR5cGUsIGZ1bikge1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuc2VtYW50aWNUeXBlcy5sZW5ndGhcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCB0eXAgPSB0aGlzLnNlbWFudGljVHlwZXNbaV1bMF1cbiAgICAgIGlmICh0eXAgPT09IHR5cGUpIHtcbiAgICAgICAgY29uc3Qgb2xkID0gdGhpcy5zZW1hbnRpY1R5cGVzW2ldWzFdXG4gICAgICAgIHRoaXMuc2VtYW50aWNUeXBlc1tpXVsxXSA9IGZ1blxuICAgICAgICByZXR1cm4gb2xkXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2VtYW50aWNUeXBlcy5wdXNoKFt0eXBlLCBmdW5dKVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBwdXNoICh2YWwpIHtcbiAgICBpZiAoIXZhbCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICB0aGlzLnJlc3VsdFt0aGlzLm9mZnNldF0gPSB2YWxcbiAgICB0aGlzLnJlc3VsdE1ldGhvZFt0aGlzLm9mZnNldF0gPSAwXG4gICAgdGhpcy5yZXN1bHRMZW5ndGhbdGhpcy5vZmZzZXRdID0gdmFsLmxlbmd0aFxuICAgIHRoaXMub2Zmc2V0KytcblxuICAgIGlmICh0aGlzLnN0cmVhbWluZykge1xuICAgICAgdGhpcy5vbkRhdGEodGhpcy5maW5hbGl6ZSgpKVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBwdXNoV3JpdGUgKHZhbCwgbWV0aG9kLCBsZW4pIHtcbiAgICB0aGlzLnJlc3VsdFt0aGlzLm9mZnNldF0gPSB2YWxcbiAgICB0aGlzLnJlc3VsdE1ldGhvZFt0aGlzLm9mZnNldF0gPSBtZXRob2RcbiAgICB0aGlzLnJlc3VsdExlbmd0aFt0aGlzLm9mZnNldF0gPSBsZW5cbiAgICB0aGlzLm9mZnNldCsrXG5cbiAgICBpZiAodGhpcy5zdHJlYW1pbmcpIHtcbiAgICAgIHRoaXMub25EYXRhKHRoaXMuZmluYWxpemUoKSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgX3B1c2hVSW50OCAodmFsKSB7XG4gICAgcmV0dXJuIHRoaXMucHVzaFdyaXRlKHZhbCwgMSwgMSlcbiAgfVxuXG4gIF9wdXNoVUludDE2QkUgKHZhbCkge1xuICAgIHJldHVybiB0aGlzLnB1c2hXcml0ZSh2YWwsIDIsIDIpXG4gIH1cblxuICBfcHVzaFVJbnQzMkJFICh2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5wdXNoV3JpdGUodmFsLCAzLCA0KVxuICB9XG5cbiAgX3B1c2hEb3VibGVCRSAodmFsKSB7XG4gICAgcmV0dXJuIHRoaXMucHVzaFdyaXRlKHZhbCwgNCwgOClcbiAgfVxuXG4gIF9wdXNoTmFOICgpIHtcbiAgICByZXR1cm4gdGhpcy5wdXNoKEJVRl9OQU4pXG4gIH1cblxuICBfcHVzaEluZmluaXR5IChvYmopIHtcbiAgICBjb25zdCBoYWxmID0gKG9iaiA8IDApID8gQlVGX0lORl9ORUcgOiBCVUZfSU5GX1BPU1xuICAgIHJldHVybiB0aGlzLnB1c2goaGFsZilcbiAgfVxuXG4gIF9wdXNoRmxvYXQgKG9iaikge1xuICAgIGNvbnN0IGIyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpXG5cbiAgICBpZiAodXRpbHMud3JpdGVIYWxmKGIyLCBvYmopKSB7XG4gICAgICBpZiAodXRpbHMucGFyc2VIYWxmKGIyKSA9PT0gb2JqKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgoSEFMRikgJiYgdGhpcy5wdXNoKGIyKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGI0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQpXG4gICAgYjQud3JpdGVGbG9hdEJFKG9iaiwgMClcbiAgICBpZiAoYjQucmVhZEZsb2F0QkUoMCkgPT09IG9iaikge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChGTE9BVCkgJiYgdGhpcy5wdXNoKGI0KVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgoRE9VQkxFKSAmJiB0aGlzLl9wdXNoRG91YmxlQkUob2JqKVxuICB9XG5cbiAgX3B1c2hJbnQgKG9iaiwgbXQsIG9yaWcpIHtcbiAgICBjb25zdCBtID0gbXQgPDwgNVxuICAgIGlmIChvYmogPCAyNCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChtIHwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmogPD0gMHhmZikge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChtIHwgTlVNQllURVMuT05FKSAmJiB0aGlzLl9wdXNoVUludDgob2JqKVxuICAgIH1cblxuICAgIGlmIChvYmogPD0gMHhmZmZmKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KG0gfCBOVU1CWVRFUy5UV08pICYmIHRoaXMuX3B1c2hVSW50MTZCRShvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iaiA8PSAweGZmZmZmZmZmKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KG0gfCBOVU1CWVRFUy5GT1VSKSAmJiB0aGlzLl9wdXNoVUludDMyQkUob2JqKVxuICAgIH1cblxuICAgIGlmIChvYmogPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgobSB8IE5VTUJZVEVTLkVJR0hUKSAmJlxuICAgICAgICB0aGlzLl9wdXNoVUludDMyQkUoTWF0aC5mbG9vcihvYmogLyBTSElGVDMyKSkgJiZcbiAgICAgICAgdGhpcy5fcHVzaFVJbnQzMkJFKG9iaiAlIFNISUZUMzIpXG4gICAgfVxuXG4gICAgaWYgKG10ID09PSBNVC5ORUdfSU5UKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaEZsb2F0KG9yaWcpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3B1c2hGbG9hdChvYmopXG4gIH1cblxuICBfcHVzaEludE51bSAob2JqKSB7XG4gICAgaWYgKG9iaiA8IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoSW50KC1vYmogLSAxLCBNVC5ORUdfSU5ULCBvYmopXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoSW50KG9iaiwgTVQuUE9TX0lOVClcbiAgICB9XG4gIH1cblxuICBfcHVzaE51bWJlciAob2JqKSB7XG4gICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgY2FzZSAob2JqID09PSBvYmopOiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoTmFOKG9iailcbiAgICAgIGNhc2UgaXNGaW5pdGUob2JqKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hJbmZpbml0eShvYmopXG4gICAgICBjYXNlICgob2JqICUgMSkgIT09IDApOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEludE51bShvYmopXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEZsb2F0KG9iailcbiAgICB9XG4gIH1cblxuICBfcHVzaFN0cmluZyAob2JqKSB7XG4gICAgY29uc3QgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgob2JqLCAndXRmOCcpXG4gICAgcmV0dXJuIHRoaXMuX3B1c2hJbnQobGVuLCBNVC5VVEY4X1NUUklORykgJiYgdGhpcy5wdXNoV3JpdGUob2JqLCA1LCBsZW4pXG4gIH1cblxuICBfcHVzaEJvb2xlYW4gKG9iaikge1xuICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgob2JqID8gVFJVRSA6IEZBTFNFKVxuICB9XG5cbiAgX3B1c2hVbmRlZmluZWQgKG9iaikge1xuICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgoVU5ERUZJTkVEKVxuICB9XG5cbiAgX3B1c2hBcnJheSAoZ2VuLCBvYmopIHtcbiAgICBjb25zdCBsZW4gPSBvYmoubGVuZ3RoXG4gICAgaWYgKCFnZW4uX3B1c2hJbnQobGVuLCBNVC5BUlJBWSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBpZiAoIWdlbi5wdXNoQW55KG9ialtqXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBfcHVzaFRhZyAodGFnKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2hJbnQodGFnLCBNVC5UQUcpXG4gIH1cblxuICBfcHVzaERhdGUgKGdlbiwgb2JqKSB7XG4gICAgLy8gUm91bmQgZGF0ZSwgdG8gZ2V0IHNlY29uZHMgc2luY2UgMTk3MC0wMS0wMSAwMDowMDowMCBhcyBkZWZpbmVkIGluXG4gICAgLy8gU2VjLiAyLjQuMSBhbmQgZ2V0IGEgcG9zc2libHkgbW9yZSBjb21wYWN0IGVuY29kaW5nLiBOb3RlIHRoYXQgaXQgaXNcbiAgICAvLyBzdGlsbCBhbGxvd2VkIHRvIGVuY29kZSBmcmFjdGlvbnMgb2Ygc2Vjb25kcyB3aGljaCBjYW4gYmUgYWNoaWV2ZWQgYnlcbiAgICAvLyBjaGFuZ2luZyBvdmVyd3JpdGluZyB0aGUgZW5jb2RlIGZ1bmN0aW9uIGZvciBEYXRlIG9iamVjdHMuXG4gICAgcmV0dXJuIGdlbi5fcHVzaFRhZyhUQUcuREFURV9FUE9DSCkgJiYgZ2VuLnB1c2hBbnkoTWF0aC5yb3VuZChvYmogLyAxMDAwKSlcbiAgfVxuXG4gIF9wdXNoQnVmZmVyIChnZW4sIG9iaikge1xuICAgIHJldHVybiBnZW4uX3B1c2hJbnQob2JqLmxlbmd0aCwgTVQuQllURV9TVFJJTkcpICYmIGdlbi5wdXNoKG9iailcbiAgfVxuXG4gIF9wdXNoTm9GaWx0ZXIgKGdlbiwgb2JqKSB7XG4gICAgcmV0dXJuIGdlbi5fcHVzaEJ1ZmZlcihnZW4sIG9iai5zbGljZSgpKVxuICB9XG5cbiAgX3B1c2hSZWdleHAgKGdlbiwgb2JqKSB7XG4gICAgcmV0dXJuIGdlbi5fcHVzaFRhZyhUQUcuUkVHRVhQKSAmJiBnZW4ucHVzaEFueShvYmouc291cmNlKVxuICB9XG5cbiAgX3B1c2hTZXQgKGdlbiwgb2JqKSB7XG4gICAgaWYgKCFnZW4uX3B1c2hJbnQob2JqLnNpemUsIE1ULkFSUkFZKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGZvciAoY29uc3QgeCBvZiBvYmopIHtcbiAgICAgIGlmICghZ2VuLnB1c2hBbnkoeCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBfcHVzaFVybCAoZ2VuLCBvYmopIHtcbiAgICByZXR1cm4gZ2VuLl9wdXNoVGFnKFRBRy5VUkkpICYmIGdlbi5wdXNoQW55KG9iai5mb3JtYXQoKSlcbiAgfVxuXG4gIF9wdXNoQmlnaW50IChvYmopIHtcbiAgICBsZXQgdGFnID0gVEFHLlBPU19CSUdJTlRcbiAgICBpZiAob2JqLmlzTmVnYXRpdmUoKSkge1xuICAgICAgb2JqID0gb2JqLm5lZ2F0ZWQoKS5taW51cygxKVxuICAgICAgdGFnID0gVEFHLk5FR19CSUdJTlRcbiAgICB9XG4gICAgbGV0IHN0ciA9IG9iai50b1N0cmluZygxNilcbiAgICBpZiAoc3RyLmxlbmd0aCAlIDIpIHtcbiAgICAgIHN0ciA9ICcwJyArIHN0clxuICAgIH1cbiAgICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbShzdHIsICdoZXgnKVxuICAgIHJldHVybiB0aGlzLl9wdXNoVGFnKHRhZykgJiYgdGhpcy5fcHVzaEJ1ZmZlcih0aGlzLCBidWYpXG4gIH1cblxuICBfcHVzaEJpZ051bWJlciAoZ2VuLCBvYmopIHtcbiAgICBpZiAob2JqLmlzTmFOKCkpIHtcbiAgICAgIHJldHVybiBnZW4uX3B1c2hOYU4oKVxuICAgIH1cbiAgICBpZiAoIW9iai5pc0Zpbml0ZSgpKSB7XG4gICAgICByZXR1cm4gZ2VuLl9wdXNoSW5maW5pdHkob2JqLmlzTmVnYXRpdmUoKSA/IC1JbmZpbml0eSA6IEluZmluaXR5KVxuICAgIH1cbiAgICBpZiAob2JqLmlzSW50ZWdlcigpKSB7XG4gICAgICByZXR1cm4gZ2VuLl9wdXNoQmlnaW50KG9iailcbiAgICB9XG4gICAgaWYgKCEoZ2VuLl9wdXNoVGFnKFRBRy5ERUNJTUFMX0ZSQUMpICYmXG4gICAgICBnZW4uX3B1c2hJbnQoMiwgTVQuQVJSQVkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgZGVjID0gb2JqLmRlY2ltYWxQbGFjZXMoKVxuICAgIGNvbnN0IHNsaWRlID0gb2JqLm11bHRpcGxpZWRCeShuZXcgQmlnbnVtYmVyKDEwKS5wb3coZGVjKSlcbiAgICBpZiAoIWdlbi5fcHVzaEludE51bSgtZGVjKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChzbGlkZS5hYnMoKS5pc0xlc3NUaGFuKE1BWElOVF9CTikpIHtcbiAgICAgIHJldHVybiBnZW4uX3B1c2hJbnROdW0oc2xpZGUudG9OdW1iZXIoKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdlbi5fcHVzaEJpZ2ludChzbGlkZSlcbiAgICB9XG4gIH1cblxuICBfcHVzaE1hcCAoZ2VuLCBvYmopIHtcbiAgICBpZiAoIWdlbi5fcHVzaEludChvYmouc2l6ZSwgTVQuTUFQKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3B1c2hSYXdNYXAoXG4gICAgICBvYmouc2l6ZSxcbiAgICAgIEFycmF5LmZyb20ob2JqKVxuICAgIClcbiAgfVxuXG4gIF9wdXNoT2JqZWN0IChvYmopIHtcbiAgICBpZiAoIW9iaikge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChOVUxMKVxuICAgIH1cblxuICAgIHZhciBsZW4gPSB0aGlzLnNlbWFudGljVHlwZXMubGVuZ3RoXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIHRoaXMuc2VtYW50aWNUeXBlc1tpXVswXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW1hbnRpY1R5cGVzW2ldWzFdLmNhbGwob2JqLCB0aGlzLCBvYmopXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGYgPSBvYmouZW5jb2RlQ0JPUlxuICAgIGlmICh0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGYuY2FsbChvYmosIHRoaXMpXG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopXG4gICAgdmFyIGtleUxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgaWYgKCF0aGlzLl9wdXNoSW50KGtleUxlbmd0aCwgTVQuTUFQKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3B1c2hSYXdNYXAoXG4gICAgICBrZXlMZW5ndGgsXG4gICAgICBrZXlzLm1hcCgoaykgPT4gW2ssIG9ialtrXV0pXG4gICAgKVxuICB9XG5cbiAgX3B1c2hSYXdNYXAgKGxlbiwgbWFwKSB7XG4gICAgLy8gU29ydCBrZXlzIGZvciBjYW5vbmNpYWxpemF0aW9uXG4gICAgLy8gMS4gZW5jb2RlIGtleVxuICAgIC8vIDIuIHNob3J0ZXIga2V5IGNvbWVzIGJlZm9yZSBsb25nZXIga2V5XG4gICAgLy8gMy4gc2FtZSBsZW5ndGgga2V5cyBhcmUgc29ydGVkIHdpdGggbG93ZXJcbiAgICAvLyAgICBieXRlIHZhbHVlIGJlZm9yZSBoaWdoZXJcblxuICAgIG1hcCA9IG1hcC5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgIGFbMF0gPSBFbmNvZGVyLmVuY29kZShhWzBdKVxuICAgICAgcmV0dXJuIGFcbiAgICB9KS5zb3J0KHV0aWxzLmtleVNvcnRlcilcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIGlmICghdGhpcy5wdXNoKG1hcFtqXVswXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5wdXNoQW55KG1hcFtqXVsxXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgYC5wdXNoQW55YFxuICAgKlxuICAgKiBAcGFyYW0geyp9IG9ialxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBvbiBzdWNjZXNzXG4gICAqL1xuICB3cml0ZSAob2JqKSB7XG4gICAgcmV0dXJuIHRoaXMucHVzaEFueShvYmopXG4gIH1cblxuICAvKipcbiAgICogUHVzaCBhbnkgc3VwcG9ydGVkIHR5cGUgb250byB0aGUgZW5jb2RlZCBzdHJlYW1cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IG9ialxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBvbiBzdWNjZXNzXG4gICAqL1xuICBwdXNoQW55IChvYmopIHtcbiAgICB2YXIgdHlwID0gdG9UeXBlKG9iailcblxuICAgIHN3aXRjaCAodHlwKSB7XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaE51bWJlcihvYmopXG4gICAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaFN0cmluZyhvYmopXG4gICAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hCb29sZWFuKG9iailcbiAgICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoT2JqZWN0KG9iailcbiAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hBcnJheSh0aGlzLCBvYmopXG4gICAgICBjYXNlICdVaW50OEFycmF5JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hCdWZmZXIodGhpcywgQnVmZmVyLmlzQnVmZmVyKG9iaikgPyBvYmogOiBCdWZmZXIuZnJvbShvYmopKVxuICAgICAgY2FzZSAnTnVsbCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgoTlVMTClcbiAgICAgIGNhc2UgJ1VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoVW5kZWZpbmVkKG9iailcbiAgICAgIGNhc2UgJ01hcCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoTWFwKHRoaXMsIG9iailcbiAgICAgIGNhc2UgJ1NldCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoU2V0KHRoaXMsIG9iailcbiAgICAgIGNhc2UgJ1VSTCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoVXJsKHRoaXMsIG9iailcbiAgICAgIGNhc2UgJ0JpZ051bWJlcic6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoQmlnTnVtYmVyKHRoaXMsIG9iailcbiAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaERhdGUodGhpcywgb2JqKVxuICAgICAgY2FzZSAnUmVnRXhwJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hSZWdleHAodGhpcywgb2JqKVxuICAgICAgY2FzZSAnU3ltYm9sJzpcbiAgICAgICAgc3dpdGNoIChvYmopIHtcbiAgICAgICAgICBjYXNlIFNZTVMuTlVMTDpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wdXNoT2JqZWN0KG51bGwpXG4gICAgICAgICAgY2FzZSBTWU1TLlVOREVGSU5FRDpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wdXNoVW5kZWZpbmVkKHVuZGVmaW5lZClcbiAgICAgICAgICAvLyBUT0RPOiBBZGQgcGx1Z2dhYmxlIHN1cHBvcnQgZm9yIG90aGVyIHN5bWJvbHNcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHN5bWJvbDogJyArIG9iai50b1N0cmluZygpKVxuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZTogJyArIHR5cGVvZiBvYmogKyAnLCAnICsgKG9iaiA/IG9iai50b1N0cmluZygpIDogJycpKVxuICAgIH1cbiAgfVxuXG4gIGZpbmFsaXplICgpIHtcbiAgICBpZiAodGhpcy5vZmZzZXQgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0XG4gICAgdmFyIHJlc3VsdExlbmd0aCA9IHRoaXMucmVzdWx0TGVuZ3RoXG4gICAgdmFyIHJlc3VsdE1ldGhvZCA9IHRoaXMucmVzdWx0TWV0aG9kXG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIHNpemUgb2YgdGhlIGJ1ZmZlclxuICAgIHZhciBzaXplID0gMFxuICAgIHZhciBpID0gMFxuXG4gICAgZm9yICg7IGkgPCBvZmZzZXQ7IGkrKykge1xuICAgICAgc2l6ZSArPSByZXN1bHRMZW5ndGhbaV1cbiAgICB9XG5cbiAgICB2YXIgcmVzID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpXG4gICAgdmFyIGluZGV4ID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG5cbiAgICAvLyBXcml0ZSB0aGUgY29udGVudCBpbnRvIHRoZSByZXN1bHQgYnVmZmVyXG4gICAgZm9yIChpID0gMDsgaSA8IG9mZnNldDsgaSsrKSB7XG4gICAgICBsZW5ndGggPSByZXN1bHRMZW5ndGhbaV1cblxuICAgICAgc3dpdGNoIChyZXN1bHRNZXRob2RbaV0pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJlc3VsdFtpXS5jb3B5KHJlcywgaW5kZXgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJlcy53cml0ZVVJbnQ4KHJlc3VsdFtpXSwgaW5kZXgsIHRydWUpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJlcy53cml0ZVVJbnQxNkJFKHJlc3VsdFtpXSwgaW5kZXgsIHRydWUpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJlcy53cml0ZVVJbnQzMkJFKHJlc3VsdFtpXSwgaW5kZXgsIHRydWUpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJlcy53cml0ZURvdWJsZUJFKHJlc3VsdFtpXSwgaW5kZXgsIHRydWUpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJlcy53cml0ZShyZXN1bHRbaV0sIGluZGV4LCBsZW5ndGgsICd1dGY4JylcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rb3duIG1ldGhvZCcpXG4gICAgICB9XG5cbiAgICAgIGluZGV4ICs9IGxlbmd0aFxuICAgIH1cblxuICAgIHZhciB0bXAgPSByZXNcblxuICAgIHRoaXMuX3Jlc2V0KClcblxuICAgIHJldHVybiB0bXBcbiAgfVxuXG4gIF9yZXNldCAoKSB7XG4gICAgdGhpcy5yZXN1bHQgPSBbXVxuICAgIHRoaXMucmVzdWx0TWV0aG9kID0gW11cbiAgICB0aGlzLnJlc3VsdExlbmd0aCA9IFtdXG4gICAgdGhpcy5vZmZzZXQgPSAwXG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIHRoZSBnaXZlbiB2YWx1ZVxuICAgKiBAcGFyYW0geyp9IG9cbiAgICogQHJldHVybnMge0J1ZmZlcn1cbiAgICovXG4gIHN0YXRpYyBlbmNvZGUgKG8pIHtcbiAgICBjb25zdCBlbmMgPSBuZXcgRW5jb2RlcigpXG4gICAgY29uc3QgcmV0ID0gZW5jLnB1c2hBbnkobylcbiAgICBpZiAoIXJldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZW5jb2RlIGlucHV0JylcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jLmZpbmFsaXplKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVuY29kZXJcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GQUxMX0JBQ0tfVlNfQ1VSUkVOQ1kgPSBleHBvcnRzLlJQQyA9IGV4cG9ydHMuTUFJTk5FVCA9IHZvaWQgMDtcbmV4cG9ydHMuTUFJTk5FVCA9ICdtYWlubmV0JztcbmV4cG9ydHMuUlBDID0gJ3JwYyc7XG5leHBvcnRzLkZBTExfQkFDS19WU19DVVJSRU5DWSA9ICdFVEgnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZldGNoRXhjaGFuZ2VSYXRlID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBnZXRQcmljaW5nVVJMKGN1cnJlbnRDdXJyZW5jeSwgbmF0aXZlQ3VycmVuY3ksIGluY2x1ZGVVU0RSYXRlKSB7XG4gICAgcmV0dXJuIChgaHR0cHM6Ly9taW4tYXBpLmNyeXB0b2NvbXBhcmUuY29tL2RhdGEvcHJpY2U/ZnN5bT1gICtcbiAgICAgICAgYCR7bmF0aXZlQ3VycmVuY3kudG9VcHBlckNhc2UoKX0mdHN5bXM9JHtjdXJyZW50Q3VycmVuY3kudG9VcHBlckNhc2UoKX1gICtcbiAgICAgICAgYCR7aW5jbHVkZVVTRFJhdGUgJiYgY3VycmVudEN1cnJlbmN5LnRvVXBwZXJDYXNlKCkgIT09ICdVU0QnID8gJyxVU0QnIDogJyd9YCk7XG59XG4vKipcbiAqIEZldGNoZXMgdGhlIGV4Y2hhbmdlIHJhdGUgZm9yIGEgZ2l2ZW4gY3VycmVuY3lcbiAqXG4gKiBAcGFyYW0gY3VycmVuY3kgLSBJU08gNDIxNyBjdXJyZW5jeSBjb2RlXG4gKiBAcGFyYW0gbmF0aXZlQ3VycmVuY3kgLSBTeW1ib2wgZm9yIGJhc2UgYXNzZXRcbiAqIEBwYXJhbSBpbmNsdWRlVVNEUmF0ZSAtIFdoZXRoZXIgdG8gYWRkIHRoZSBVU0QgcmF0ZSB0byB0aGUgZmV0Y2hcbiAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gZXhjaGFuZ2UgcmF0ZSBmb3IgZ2l2ZW4gY3VycmVuY3lcbiAqL1xuZnVuY3Rpb24gZmV0Y2hFeGNoYW5nZVJhdGUoY3VycmVuY3ksIG5hdGl2ZUN1cnJlbmN5LCBpbmNsdWRlVVNEUmF0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSB5aWVsZCB1dGlsXzEuaGFuZGxlRmV0Y2goZ2V0UHJpY2luZ1VSTChjdXJyZW5jeSwgbmF0aXZlQ3VycmVuY3ksIGluY2x1ZGVVU0RSYXRlKSk7XG4gICAgICAgIC8qXG4gICAgICAgIEV4YW1wbGUgZXhwZWN0ZWQgZXJyb3IgcmVzcG9uc2UgKGlmIHBhaXIgaXMgbm90IGZvdW5kKVxuICAgICAgICB7XG4gICAgICAgICAgUmVzcG9uc2U6IFwiRXJyb3JcIixcbiAgICAgICAgICBNZXNzYWdlOiBcImNjY2FnZ19vcl9leGNoYW5nZSBtYXJrZXQgZG9lcyBub3QgZXhpc3QgZm9yIHRoaXMgY29pbiBwYWlyIChFVEgtPE5PTl9FWElTVEVOVF9UT0tFTj4pXCIsXG4gICAgICAgICAgSGFzV2FybmluZzogZmFsc2UsXG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKGpzb24uUmVzcG9uc2UgPT09ICdFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihqc29uLk1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnZlcnNpb25SYXRlID0gTnVtYmVyKGpzb25bY3VycmVuY3kudG9VcHBlckNhc2UoKV0pO1xuICAgICAgICBjb25zdCB1c2RDb252ZXJzaW9uUmF0ZSA9IE51bWJlcihqc29uLlVTRCk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGNvbnZlcnNpb25SYXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIGZvciAke2N1cnJlbmN5LnRvVXBwZXJDYXNlKCl9OiAke2pzb25bY3VycmVuY3kudG9VcHBlckNhc2UoKV19YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1ZGVVU0RSYXRlICYmICFOdW1iZXIuaXNGaW5pdGUodXNkQ29udmVyc2lvblJhdGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgZm9yIHVzZENvbnZlcnNpb25SYXRlOiAke2pzb24uVVNEfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb252ZXJzaW9uUmF0ZSxcbiAgICAgICAgICAgIHVzZENvbnZlcnNpb25SYXRlLFxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaEV4Y2hhbmdlUmF0ZSA9IGZldGNoRXhjaGFuZ2VSYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLWNvbXBhcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFic3RyYWN0TWVzc2FnZU1hbmFnZXIgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuLyoqXG4gKiBDb250cm9sbGVyIGluIGNoYXJnZSBvZiBtYW5hZ2luZyAtIHN0b3JpbmcsIGFkZGluZywgcmVtb3ZpbmcsIHVwZGF0aW5nIC0gTWVzc2FnZXMuXG4gKi9cbmNsYXNzIEFic3RyYWN0TWVzc2FnZU1hbmFnZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlcl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIEFic3RyYWN0TWVzc2FnZU1hbmFnZXIgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50RW1pdHRlciBpbnN0YW5jZSB1c2VkIHRvIGxpc3RlbiB0byBzcGVjaWZpYyBtZXNzYWdlIGV2ZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5odWIgPSBuZXcgZXZlbnRzXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ0Fic3RyYWN0TWVzc2FnZU1hbmFnZXInO1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHtcbiAgICAgICAgICAgIHVuYXBwcm92ZWRNZXNzYWdlczoge30sXG4gICAgICAgICAgICB1bmFwcHJvdmVkTWVzc2FnZXNDb3VudDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2F2ZXMgdGhlIHVuYXBwcm92ZWQgbWVzc2FnZXMsIGFuZCB0aGVpciBjb3VudCB0byBzdGF0ZVxuICAgICAqXG4gICAgICovXG4gICAgc2F2ZU1lc3NhZ2VMaXN0KCkge1xuICAgICAgICBjb25zdCB1bmFwcHJvdmVkTWVzc2FnZXMgPSB0aGlzLmdldFVuYXBwcm92ZWRNZXNzYWdlcygpO1xuICAgICAgICBjb25zdCB1bmFwcHJvdmVkTWVzc2FnZXNDb3VudCA9IHRoaXMuZ2V0VW5hcHByb3ZlZE1lc3NhZ2VzQ291bnQoKTtcbiAgICAgICAgdGhpcy51cGRhdGUoeyB1bmFwcHJvdmVkTWVzc2FnZXMsIHVuYXBwcm92ZWRNZXNzYWdlc0NvdW50IH0pO1xuICAgICAgICB0aGlzLmh1Yi5lbWl0KCd1cGRhdGVCYWRnZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBzdGF0dXMgb2YgYSBNZXNzYWdlIGluIHRoaXMubWVzc2FnZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlSWQgLSBUaGUgaWQgb2YgdGhlIE1lc3NhZ2UgdG8gdXBkYXRlXG4gICAgICogQHBhcmFtIHN0YXR1cyAtIFRoZSBuZXcgc3RhdHVzIG9mIHRoZSBNZXNzYWdlXG4gICAgICovXG4gICAgc2V0TWVzc2FnZVN0YXR1cyhtZXNzYWdlSWQsIHN0YXR1cykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5nZXRNZXNzYWdlKG1lc3NhZ2VJZCk7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMubmFtZX06IE1lc3NhZ2Ugbm90IGZvdW5kIGZvciBpZDogJHttZXNzYWdlSWR9LmApO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2Uuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLnVwZGF0ZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuaHViLmVtaXQoYCR7bWVzc2FnZUlkfToke3N0YXR1c31gLCBtZXNzYWdlKTtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ3JlamVjdGVkJyB8fCBzdGF0dXMgPT09ICdzaWduZWQnIHx8IHN0YXR1cyA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmh1Yi5lbWl0KGAke21lc3NhZ2VJZH06ZmluaXNoZWRgLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgTWVzc2FnZSBpbiB0aGlzLm1lc3NhZ2VzIHRvIHRoZSBwYXNzZWQgTWVzc2FnZSBpZiB0aGUgaWRzIGFyZSBlcXVhbC5cbiAgICAgKiBUaGVuIHNhdmVzIHRoZSB1bmFwcHJvdmVkTWVzc2FnZSBsaXN0IHRvIHN0b3JhZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gQSBNZXNzYWdlIHRoYXQgd2lsbCByZXBsYWNlIGFuIGV4aXN0aW5nIE1lc3NhZ2UgKHdpdGggdGhlIGlkKSBpbiB0aGlzLm1lc3NhZ2VzXG4gICAgICovXG4gICAgdXBkYXRlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tZXNzYWdlcy5maW5kSW5kZXgoKG1zZykgPT4gbWVzc2FnZS5pZCA9PT0gbXNnLmlkKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlc1tpbmRleF0gPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2F2ZU1lc3NhZ2VMaXN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZ2V0dGVyIGZvciB0aGUgbnVtYmVyIG9mICd1bmFwcHJvdmVkJyBNZXNzYWdlcyBpbiB0aGlzLm1lc3NhZ2VzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBudW1iZXIgb2YgJ3VuYXBwcm92ZWQnIE1lc3NhZ2VzIGluIHRoaXMubWVzc2FnZXNcbiAgICAgKlxuICAgICAqL1xuICAgIGdldFVuYXBwcm92ZWRNZXNzYWdlc0NvdW50KCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5nZXRVbmFwcHJvdmVkTWVzc2FnZXMoKSkubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGdldHRlciBmb3IgdGhlICd1bmFwcHJvdmVkJyBNZXNzYWdlcyBpbiBzdGF0ZSBtZXNzYWdlc1xuICAgICAqXG4gICAgICogQHJldHVybnMgLSBBbiBpbmRleCBvZiBNZXNzYWdlIGlkcyB0byBNZXNzYWdlcywgZm9yIGFsbCAndW5hcHByb3ZlZCcgTWVzc2FnZXMgaW4gdGhpcy5tZXNzYWdlc1xuICAgICAqXG4gICAgICovXG4gICAgZ2V0VW5hcHByb3ZlZE1lc3NhZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlc1xuICAgICAgICAgICAgLmZpbHRlcigobWVzc2FnZSkgPT4gbWVzc2FnZS5zdGF0dXMgPT09ICd1bmFwcHJvdmVkJylcbiAgICAgICAgICAgIC5yZWR1Y2UoKHJlc3VsdCwgbWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0W21lc3NhZ2UuaWRdID0gbWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHBhc3NlZCBNZXNzYWdlIHRvIHRoaXMubWVzc2FnZXMsIGFuZCBjYWxscyB0aGlzLnNhdmVNZXNzYWdlTGlzdCgpIHRvIHNhdmVcbiAgICAgKiB0aGUgdW5hcHByb3ZlZCBNZXNzYWdlcyBmcm9tIHRoYXQgbGlzdCB0byB0aGlzLm1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtNZXNzYWdlfSBtZXNzYWdlIFRoZSBNZXNzYWdlIHRvIGFkZCB0byB0aGlzLm1lc3NhZ2VzXG4gICAgICpcbiAgICAgKi9cbiAgICBhZGRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnNhdmVNZXNzYWdlTGlzdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3BlY2lmaWVkIE1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZUlkIC0gVGhlIGlkIG9mIHRoZSBNZXNzYWdlIHRvIGdldFxuICAgICAqIEByZXR1cm5zIC0gVGhlIE1lc3NhZ2Ugd2l0aCB0aGUgaWQgdGhhdCBtYXRjaGVzIHRoZSBwYXNzZWQgbWVzc2FnZUlkLCBvciB1bmRlZmluZWRcbiAgICAgKiBpZiBubyBNZXNzYWdlIGhhcyB0aGF0IGlkLlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0TWVzc2FnZShtZXNzYWdlSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuZmluZCgobWVzc2FnZSkgPT4gbWVzc2FnZS5pZCA9PT0gbWVzc2FnZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwcm92ZXMgYSBNZXNzYWdlLiBTZXRzIHRoZSBtZXNzYWdlIHN0YXR1cyB2aWEgYSBjYWxsIHRvIHRoaXMuc2V0TWVzc2FnZVN0YXR1c0FwcHJvdmVkLFxuICAgICAqIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB3aXRoIGFueSB0aGUgbWVzc2FnZSBwYXJhbXMgbW9kaWZpZWQgZm9yIHByb3BlciBzaWduaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBUaGUgbWVzc2FnZVBhcmFtcyB0byBiZSB1c2VkIHdoZW4gc2lnbmluZyBtZXRob2QgaXMgY2FsbGVkLFxuICAgICAqIHBsdXMgZGF0YSBhZGRlZCBieSBNZXRhTWFza1xuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIG1lc3NhZ2VQYXJhbXMgd2l0aCB0aGUgbWV0YW1hc2tJZCBwcm9wZXJ0eSByZW1vdmVkXG4gICAgICovXG4gICAgYXBwcm92ZU1lc3NhZ2UobWVzc2FnZVBhcmFtcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5zZXRNZXNzYWdlU3RhdHVzQXBwcm92ZWQobWVzc2FnZVBhcmFtcy5tZXRhbWFza0lkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlcE1lc3NhZ2VGb3JTaWduaW5nKG1lc3NhZ2VQYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgTWVzc2FnZSBzdGF0dXMgdG8gJ2FwcHJvdmVkJyB2aWEgYSBjYWxsIHRvIHRoaXMuc2V0TWVzc2FnZVN0YXR1cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlSWQgLSBUaGUgaWQgb2YgdGhlIE1lc3NhZ2UgdG8gYXBwcm92ZVxuICAgICAqL1xuICAgIHNldE1lc3NhZ2VTdGF0dXNBcHByb3ZlZChtZXNzYWdlSWQpIHtcbiAgICAgICAgdGhpcy5zZXRNZXNzYWdlU3RhdHVzKG1lc3NhZ2VJZCwgJ2FwcHJvdmVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBNZXNzYWdlIHN0YXR1cyB0byAnc2lnbmVkJyB2aWEgYSBjYWxsIHRvIHRoaXMuc2V0TWVzc2FnZVN0YXR1cyBhbmQgdXBkYXRlc1xuICAgICAqIHRoYXQgTWVzc2FnZSBpbiB0aGlzLm1lc3NhZ2VzIGJ5IGFkZGluZyB0aGUgcmF3IHNpZ25hdHVyZSBkYXRhIG9mIHRoZSBzaWduYXR1cmVcbiAgICAgKiByZXF1ZXN0IHRvIHRoZSBNZXNzYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VJZCAtIFRoZSBpZCBvZiB0aGUgTWVzc2FnZSB0byBzaWduXG4gICAgICogQHBhcmFtIHJhd1NpZyAtIFRoZSByYXcgZGF0YSBvZiB0aGUgc2lnbmF0dXJlIHJlcXVlc3RcbiAgICAgKi9cbiAgICBzZXRNZXNzYWdlU3RhdHVzU2lnbmVkKG1lc3NhZ2VJZCwgcmF3U2lnKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmdldE1lc3NhZ2UobWVzc2FnZUlkKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UucmF3U2lnID0gcmF3U2lnO1xuICAgICAgICB0aGlzLnVwZGF0ZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuc2V0TWVzc2FnZVN0YXR1cyhtZXNzYWdlSWQsICdzaWduZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIE1lc3NhZ2Ugc3RhdHVzIHRvICdyZWplY3RlZCcgdmlhIGEgY2FsbCB0byB0aGlzLnNldE1lc3NhZ2VTdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZUlkIC0gVGhlIGlkIG9mIHRoZSBNZXNzYWdlIHRvIHJlamVjdC5cbiAgICAgKi9cbiAgICByZWplY3RNZXNzYWdlKG1lc3NhZ2VJZCkge1xuICAgICAgICB0aGlzLnNldE1lc3NhZ2VTdGF0dXMobWVzc2FnZUlkLCAncmVqZWN0ZWQnKTtcbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0TWVzc2FnZU1hbmFnZXIgPSBBYnN0cmFjdE1lc3NhZ2VNYW5hZ2VyO1xuZXhwb3J0cy5kZWZhdWx0ID0gQWJzdHJhY3RNZXNzYWdlTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFic3RyYWN0TWVzc2FnZU1hbmFnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbXBhcmVDb2xsZWN0aWJsZXNNZXRhZGF0YSA9IHZvaWQgMDtcbi8qKlxuICogQ29tcGFyZXMgY29sbGVjdGlibGUgbWV0YWRhdGEgZW50cmllcyB0byBhbnkgY29sbGVjdGlibGUgZW50cnlcbiAqIFdlIG5lZWQgdGhpcyBtZXRob2Qgd2hlbiBjb21wYXJpbmcgYSBuZXcgZmV0Y2hlZCBjb2xsZWN0aWJsZSBtZXRhZGF0YSwgaW4gY2FzZSBhIGVudHJ5IGNoYW5nZWQgdG8gYSBkZWZpbmVkIHZhbHVlLFxuICogdGhlcmUncyBhIG5lZWQgdG8gdXBkYXRlIHRoZSBjb2xsZWN0aWJsZSBpbiBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0gY29sbGVjdGlibGVNZXRhZGF0YSAtIENvbGxlY3RpYmxlIG1ldGFkYXRhIG9iamVjdFxuICogQHBhcmFtIGNvbGxlY3RpYmxlIC0gQ29sbGVjdGlibGUgb2JqZWN0IHRvIGNvbXBhcmUgd2l0aFxuICogQHJldHVybnMgLSBXaGV0aGVyIHRoZXJlIGFyZSBkaWZmZXJlbmNlc1xuICovXG5mdW5jdGlvbiBjb21wYXJlQ29sbGVjdGlibGVzTWV0YWRhdGEobmV3Q29sbGVjdGlibGVNZXRhZGF0YSwgY29sbGVjdGlibGUpIHtcbiAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAnYmFja2dyb3VuZENvbG9yJyxcbiAgICAgICAgJ2ltYWdlUHJldmlldycsXG4gICAgICAgICdpbWFnZVRodW1ibmFpbCcsXG4gICAgICAgICdpbWFnZU9yaWdpbmFsJyxcbiAgICAgICAgJ2FuaW1hdGlvbicsXG4gICAgICAgICdhbmltYXRpb25PcmlnaW5hbCcsXG4gICAgICAgICdleHRlcm5hbExpbmsnLFxuICAgIF07XG4gICAgY29uc3QgZGlmZmVyZW50VmFsdWVzID0ga2V5cy5yZWR1Y2UoKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKG5ld0NvbGxlY3RpYmxlTWV0YWRhdGFba2V5XSAmJlxuICAgICAgICAgICAgbmV3Q29sbGVjdGlibGVNZXRhZGF0YVtrZXldICE9PSBjb2xsZWN0aWJsZVtrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm4gZGlmZmVyZW50VmFsdWVzID4gMDtcbn1cbmV4cG9ydHMuY29tcGFyZUNvbGxlY3RpYmxlc01ldGFkYXRhID0gY29tcGFyZUNvbGxlY3RpYmxlc01ldGFkYXRhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXRzVXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYWxjdWxhdGVUaW1lRXN0aW1hdGUgPSBleHBvcnRzLmZldGNoRXRoR2FzUHJpY2VFc3RpbWF0ZSA9IGV4cG9ydHMuZmV0Y2hMZWdhY3lHYXNQcmljZUVzdGltYXRlcyA9IGV4cG9ydHMuZmV0Y2hHYXNFc3RpbWF0ZXMgPSBleHBvcnRzLm5vcm1hbGl6ZUdXRUlEZWNpbWFsTnVtYmVycyA9IHZvaWQgMDtcbmNvbnN0IGV0aGVyZXVtanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgbWFrZUNsaWVudElkSGVhZGVyID0gKGNsaWVudElkKSA9PiAoeyAnWC1DbGllbnQtSWQnOiBjbGllbnRJZCB9KTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUdXRUlEZWNpbWFsTnVtYmVycyhuKSB7XG4gICAgY29uc3QgbnVtYmVyQXNXRUlIZXggPSB1dGlsXzEuZ3dlaURlY1RvV0VJQk4obikudG9TdHJpbmcoMTYpO1xuICAgIGNvbnN0IG51bWJlckFzR1dFSSA9IHV0aWxfMS53ZWlIZXhUb0d3ZWlEZWMobnVtYmVyQXNXRUlIZXgpLnRvU3RyaW5nKDEwKTtcbiAgICByZXR1cm4gbnVtYmVyQXNHV0VJO1xufVxuZXhwb3J0cy5ub3JtYWxpemVHV0VJRGVjaW1hbE51bWJlcnMgPSBub3JtYWxpemVHV0VJRGVjaW1hbE51bWJlcnM7XG5mdW5jdGlvbiBmZXRjaEdhc0VzdGltYXRlcyh1cmwsIGNsaWVudElkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgZXN0aW1hdGVzID0geWllbGQgdXRpbF8xLmhhbmRsZUZldGNoKHVybCwgY2xpZW50SWQgPyB7IGhlYWRlcnM6IG1ha2VDbGllbnRJZEhlYWRlcihjbGllbnRJZCkgfSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRFc3RpbWF0ZXMgPSB7XG4gICAgICAgICAgICBlc3RpbWF0ZWRCYXNlRmVlOiBub3JtYWxpemVHV0VJRGVjaW1hbE51bWJlcnMoZXN0aW1hdGVzLmVzdGltYXRlZEJhc2VGZWUpLFxuICAgICAgICAgICAgbG93OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVzdGltYXRlcy5sb3cpLCB7IHN1Z2dlc3RlZE1heFByaW9yaXR5RmVlUGVyR2FzOiBub3JtYWxpemVHV0VJRGVjaW1hbE51bWJlcnMoZXN0aW1hdGVzLmxvdy5zdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhcyksIHN1Z2dlc3RlZE1heEZlZVBlckdhczogbm9ybWFsaXplR1dFSURlY2ltYWxOdW1iZXJzKGVzdGltYXRlcy5sb3cuc3VnZ2VzdGVkTWF4RmVlUGVyR2FzKSB9KSxcbiAgICAgICAgICAgIG1lZGl1bTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlc3RpbWF0ZXMubWVkaXVtKSwgeyBzdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhczogbm9ybWFsaXplR1dFSURlY2ltYWxOdW1iZXJzKGVzdGltYXRlcy5tZWRpdW0uc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMpLCBzdWdnZXN0ZWRNYXhGZWVQZXJHYXM6IG5vcm1hbGl6ZUdXRUlEZWNpbWFsTnVtYmVycyhlc3RpbWF0ZXMubWVkaXVtLnN1Z2dlc3RlZE1heEZlZVBlckdhcykgfSksXG4gICAgICAgICAgICBoaWdoOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVzdGltYXRlcy5oaWdoKSwgeyBzdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhczogbm9ybWFsaXplR1dFSURlY2ltYWxOdW1iZXJzKGVzdGltYXRlcy5oaWdoLnN1Z2dlc3RlZE1heFByaW9yaXR5RmVlUGVyR2FzKSwgc3VnZ2VzdGVkTWF4RmVlUGVyR2FzOiBub3JtYWxpemVHV0VJRGVjaW1hbE51bWJlcnMoZXN0aW1hdGVzLmhpZ2guc3VnZ2VzdGVkTWF4RmVlUGVyR2FzKSB9KSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRFc3RpbWF0ZXM7XG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoR2FzRXN0aW1hdGVzID0gZmV0Y2hHYXNFc3RpbWF0ZXM7XG4vKipcbiAqIEhpdCB0aGUgbGVnYWN5IE1ldGFTd2FwcyBnYXNQcmljZXMgZXN0aW1hdGUgYXBpIGFuZCByZXR1cm4gdGhlIGxvdywgbWVkaXVtXG4gKiBoaWdoIHZhbHVlcyBmcm9tIHRoYXQgQVBJLlxuICovXG5mdW5jdGlvbiBmZXRjaExlZ2FjeUdhc1ByaWNlRXN0aW1hdGVzKHVybCwgY2xpZW50SWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB1dGlsXzEuaGFuZGxlRmV0Y2godXJsLCB7XG4gICAgICAgICAgICByZWZlcnJlcjogdXJsLFxuICAgICAgICAgICAgcmVmZXJyZXJQb2xpY3k6ICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZScsXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgbW9kZTogJ2NvcnMnLFxuICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSwgKGNsaWVudElkICYmIG1ha2VDbGllbnRJZEhlYWRlcihjbGllbnRJZCkpKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb3c6IHJlc3VsdC5TYWZlR2FzUHJpY2UsXG4gICAgICAgICAgICBtZWRpdW06IHJlc3VsdC5Qcm9wb3NlR2FzUHJpY2UsXG4gICAgICAgICAgICBoaWdoOiByZXN1bHQuRmFzdEdhc1ByaWNlLFxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaExlZ2FjeUdhc1ByaWNlRXN0aW1hdGVzID0gZmV0Y2hMZWdhY3lHYXNQcmljZUVzdGltYXRlcztcbmZ1bmN0aW9uIGZldGNoRXRoR2FzUHJpY2VFc3RpbWF0ZShldGhRdWVyeSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGdhc1ByaWNlID0geWllbGQgdXRpbF8xLnF1ZXJ5KGV0aFF1ZXJ5LCAnZ2FzUHJpY2UnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdhc1ByaWNlOiB1dGlsXzEud2VpSGV4VG9Hd2VpRGVjKGdhc1ByaWNlKS50b1N0cmluZygpLFxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaEV0aEdhc1ByaWNlRXN0aW1hdGUgPSBmZXRjaEV0aEdhc1ByaWNlRXN0aW1hdGU7XG5mdW5jdGlvbiBjYWxjdWxhdGVUaW1lRXN0aW1hdGUobWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgZ2FzRmVlRXN0aW1hdGVzKSB7XG4gICAgY29uc3QgeyBsb3csIG1lZGl1bSwgaGlnaCwgZXN0aW1hdGVkQmFzZUZlZSB9ID0gZ2FzRmVlRXN0aW1hdGVzO1xuICAgIGNvbnN0IG1heFByaW9yaXR5RmVlUGVyR2FzSW5XRUkgPSB1dGlsXzEuZ3dlaURlY1RvV0VJQk4obWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgIGNvbnN0IG1heEZlZVBlckdhc0luV0VJID0gdXRpbF8xLmd3ZWlEZWNUb1dFSUJOKG1heEZlZVBlckdhcyk7XG4gICAgY29uc3QgZXN0aW1hdGVkQmFzZUZlZUluV0VJID0gdXRpbF8xLmd3ZWlEZWNUb1dFSUJOKGVzdGltYXRlZEJhc2VGZWUpO1xuICAgIGNvbnN0IGVmZmVjdGl2ZU1heFByaW9yaXR5RmVlID0gZXRoZXJldW1qc191dGlsXzEuQk4ubWluKG1heFByaW9yaXR5RmVlUGVyR2FzSW5XRUksIG1heEZlZVBlckdhc0luV0VJLnN1Yihlc3RpbWF0ZWRCYXNlRmVlSW5XRUkpKTtcbiAgICBjb25zdCBsb3dNYXhQcmlvcml0eUZlZUluV0VJID0gdXRpbF8xLmd3ZWlEZWNUb1dFSUJOKGxvdy5zdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgY29uc3QgbWVkaXVtTWF4UHJpb3JpdHlGZWVJbldFSSA9IHV0aWxfMS5nd2VpRGVjVG9XRUlCTihtZWRpdW0uc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgIGNvbnN0IGhpZ2hNYXhQcmlvcml0eUZlZUluV0VJID0gdXRpbF8xLmd3ZWlEZWNUb1dFSUJOKGhpZ2guc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgIGxldCBsb3dlclRpbWVCb3VuZDtcbiAgICBsZXQgdXBwZXJUaW1lQm91bmQ7XG4gICAgaWYgKGVmZmVjdGl2ZU1heFByaW9yaXR5RmVlLmx0KGxvd01heFByaW9yaXR5RmVlSW5XRUkpKSB7XG4gICAgICAgIGxvd2VyVGltZUJvdW5kID0gbnVsbDtcbiAgICAgICAgdXBwZXJUaW1lQm91bmQgPSAndW5rbm93bic7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVmZmVjdGl2ZU1heFByaW9yaXR5RmVlLmd0ZShsb3dNYXhQcmlvcml0eUZlZUluV0VJKSAmJlxuICAgICAgICBlZmZlY3RpdmVNYXhQcmlvcml0eUZlZS5sdChtZWRpdW1NYXhQcmlvcml0eUZlZUluV0VJKSkge1xuICAgICAgICBsb3dlclRpbWVCb3VuZCA9IGxvdy5taW5XYWl0VGltZUVzdGltYXRlO1xuICAgICAgICB1cHBlclRpbWVCb3VuZCA9IGxvdy5tYXhXYWl0VGltZUVzdGltYXRlO1xuICAgIH1cbiAgICBlbHNlIGlmIChlZmZlY3RpdmVNYXhQcmlvcml0eUZlZS5ndGUobWVkaXVtTWF4UHJpb3JpdHlGZWVJbldFSSkgJiZcbiAgICAgICAgZWZmZWN0aXZlTWF4UHJpb3JpdHlGZWUubHQoaGlnaE1heFByaW9yaXR5RmVlSW5XRUkpKSB7XG4gICAgICAgIGxvd2VyVGltZUJvdW5kID0gbWVkaXVtLm1pbldhaXRUaW1lRXN0aW1hdGU7XG4gICAgICAgIHVwcGVyVGltZUJvdW5kID0gbWVkaXVtLm1heFdhaXRUaW1lRXN0aW1hdGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVmZmVjdGl2ZU1heFByaW9yaXR5RmVlLmVxKGhpZ2hNYXhQcmlvcml0eUZlZUluV0VJKSkge1xuICAgICAgICBsb3dlclRpbWVCb3VuZCA9IGhpZ2gubWluV2FpdFRpbWVFc3RpbWF0ZTtcbiAgICAgICAgdXBwZXJUaW1lQm91bmQgPSBoaWdoLm1heFdhaXRUaW1lRXN0aW1hdGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsb3dlclRpbWVCb3VuZCA9IDA7XG4gICAgICAgIHVwcGVyVGltZUJvdW5kID0gaGlnaC5tYXhXYWl0VGltZUVzdGltYXRlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBsb3dlclRpbWVCb3VuZCxcbiAgICAgICAgdXBwZXJUaW1lQm91bmQsXG4gICAgfTtcbn1cbmV4cG9ydHMuY2FsY3VsYXRlVGltZUVzdGltYXRlID0gY2FsY3VsYXRlVGltZUVzdGltYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2FzLXV0aWwuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNIZXhQcmVmaXhlZCA9IHJlcXVpcmUoJ2lzLWhleC1wcmVmaXhlZCcpO1xudmFyIHN0cmlwSGV4UHJlZml4ID0gcmVxdWlyZSgnc3RyaXAtaGV4LXByZWZpeCcpO1xuXG4vKipcbiAqIFBhZHMgYSBgU3RyaW5nYCB0byBoYXZlIGFuIGV2ZW4gbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ30gb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIHBhZFRvRXZlbih2YWx1ZSkge1xuICB2YXIgYSA9IHZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgaWYgKHR5cGVvZiBhICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIHdoaWxlIHBhZGRpbmcgdG8gZXZlbiwgdmFsdWUgbXVzdCBiZSBzdHJpbmcsIGlzIGN1cnJlbnRseSAnICsgdHlwZW9mIGEgKyAnLCB3aGlsZSBwYWRUb0V2ZW4uJyk7XG4gIH1cblxuICBpZiAoYS5sZW5ndGggJSAyKSB7XG4gICAgYSA9ICcwJyArIGE7XG4gIH1cblxuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBOdW1iZXJgIGludG8gYSBoZXggYFN0cmluZ2BcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGludFRvSGV4KGkpIHtcbiAgdmFyIGhleCA9IGkudG9TdHJpbmcoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgcmV0dXJuICcweCcgKyBoZXg7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gYE51bWJlcmAgdG8gYSBgQnVmZmVyYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gaW50VG9CdWZmZXIoaSkge1xuICB2YXIgaGV4ID0gaW50VG9IZXgoaSk7XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIocGFkVG9FdmVuKGhleC5zbGljZSgyKSksICdoZXgnKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGJpbmFyeSBzaXplIG9mIGEgc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldEJpbmFyeVNpemUoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIHdoaWxlIGdldHRpbmcgYmluYXJ5IHNpemUsIG1ldGhvZCBnZXRCaW5hcnlTaXplIHJlcXVpcmVzIGlucHV0IFxcJ3N0clxcJyB0byBiZSB0eXBlIFN0cmluZywgZ290IFxcJycgKyB0eXBlb2Ygc3RyICsgJ1xcJy4nKTtcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuYnl0ZUxlbmd0aChzdHIsICd1dGY4Jyk7XG59XG5cbi8qKlxuICogUmV0dXJucyBUUlVFIGlmIHRoZSBmaXJzdCBzcGVjaWZpZWQgYXJyYXkgY29udGFpbnMgYWxsIGVsZW1lbnRzXG4gKiBmcm9tIHRoZSBzZWNvbmQgb25lLiBGQUxTRSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHthcnJheX0gc3VwZXJzZXRcbiAqIEBwYXJhbSB7YXJyYXl9IHN1YnNldFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBhcnJheUNvbnRhaW5zQXJyYXkoc3VwZXJzZXQsIHN1YnNldCwgc29tZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzdXBlcnNldCkgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgYXJyYXlDb250YWluc0FycmF5IHJlcXVpcmVzIGlucHV0IFxcJ3N1cGVyc2V0XFwnIHRvIGJlIGFuIGFycmF5IGdvdCB0eXBlIFxcJycgKyB0eXBlb2Ygc3VwZXJzZXQgKyAnXFwnJyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3Vic2V0KSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBhcnJheUNvbnRhaW5zQXJyYXkgcmVxdWlyZXMgaW5wdXQgXFwnc3Vic2V0XFwnIHRvIGJlIGFuIGFycmF5IGdvdCB0eXBlIFxcJycgKyB0eXBlb2Ygc3Vic2V0ICsgJ1xcJycpO1xuICB9XG5cbiAgcmV0dXJuIHN1YnNldFtCb29sZWFuKHNvbWUpICYmICdzb21lJyB8fCAnZXZlcnknXShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gc3VwZXJzZXQuaW5kZXhPZih2YWx1ZSkgPj0gMDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgdXRmOCBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b1V0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvVXRmOChoZXgpIHtcbiAgdmFyIGJ1ZmZlclZhbHVlID0gbmV3IEJ1ZmZlcihwYWRUb0V2ZW4oc3RyaXBIZXhQcmVmaXgoaGV4KS5yZXBsYWNlKC9eMCt8MCskL2csICcnKSksICdoZXgnKTtcblxuICByZXR1cm4gYnVmZmVyVmFsdWUudG9TdHJpbmcoJ3V0ZjgnKTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBhc2NpaSBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b0FzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b0FzY2lpKGhleCkge1xuICB2YXIgc3RyID0gJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdmFyIGkgPSAwLFxuICAgICAgbCA9IGhleC5sZW5ndGg7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAoaGV4LnN1YnN0cmluZygwLCAyKSA9PT0gJzB4Jykge1xuICAgIGkgPSAyO1xuICB9XG5cbiAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICB2YXIgY29kZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgdXRmOCBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tVXRmOChzdHJpbmdWYWx1ZSkge1xuICB2YXIgc3RyID0gbmV3IEJ1ZmZlcihzdHJpbmdWYWx1ZSwgJ3V0ZjgnKTtcblxuICByZXR1cm4gJzB4JyArIHBhZFRvRXZlbihzdHIudG9TdHJpbmcoJ2hleCcpKS5yZXBsYWNlKC9eMCt8MCskL2csICcnKTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiBhc2NpaSBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZnJvbUFzY2lpKHN0cmluZ1ZhbHVlKSB7XG4gIHZhciBoZXggPSAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciBjb2RlID0gc3RyaW5nVmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICB2YXIgbiA9IGNvZGUudG9TdHJpbmcoMTYpO1xuICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyAnMCcgKyBuIDogbjtcbiAgfVxuXG4gIHJldHVybiAnMHgnICsgaGV4O1xufVxuXG4vKipcbiAqIGdldEtleXMoW3thOiAxLCBiOiAyfSwge2E6IDMsIGI6IDR9XSwgJ2EnKSA9PiBbMSwgM11cbiAqXG4gKiBAbWV0aG9kIGdldEtleXMgZ2V0IHNwZWNpZmljIGtleSBmcm9tIGlubmVyIG9iamVjdCBhcnJheSBvZiBvYmplY3RzXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFsbG93RW1wdHlcbiAqIEByZXR1cm5zIHtBcnJheX0gb3V0cHV0IGp1c3QgYSBzaW1wbGUgYXJyYXkgb2Ygb3V0cHV0IGtleXNcbiAqL1xuZnVuY3Rpb24gZ2V0S2V5cyhwYXJhbXMsIGtleSwgYWxsb3dFbXB0eSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBnZXRLZXlzIGV4cGVjdGluZyB0eXBlIEFycmF5IGFzIFxcJ3BhcmFtc1xcJyBpbnB1dCwgZ290IFxcJycgKyB0eXBlb2YgcGFyYW1zICsgJ1xcJycpO1xuICB9XG4gIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBnZXRLZXlzIGV4cGVjdGluZyB0eXBlIFN0cmluZyBmb3IgaW5wdXQgXFwna2V5XFwnIGdvdCBcXCcnICsgdHlwZW9mIGtleSArICdcXCcuJyk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgdmFsdWUgPSBwYXJhbXNbaV1ba2V5XTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGlmIChhbGxvd0VtcHR5ICYmICF2YWx1ZSkge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhYmknKTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBJcyB0aGUgc3RyaW5nIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAbWV0aG9kIGNoZWNrIGlmIHN0cmluZyBpcyBoZXggc3RyaW5nIG9mIHNwZWNpZmljIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gb3V0cHV0IHRoZSBzdHJpbmcgaXMgYSBoZXggc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobGVuZ3RoICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFycmF5Q29udGFpbnNBcnJheTogYXJyYXlDb250YWluc0FycmF5LFxuICBpbnRUb0J1ZmZlcjogaW50VG9CdWZmZXIsXG4gIGdldEJpbmFyeVNpemU6IGdldEJpbmFyeVNpemUsXG4gIGlzSGV4UHJlZml4ZWQ6IGlzSGV4UHJlZml4ZWQsXG4gIHN0cmlwSGV4UHJlZml4OiBzdHJpcEhleFByZWZpeCxcbiAgcGFkVG9FdmVuOiBwYWRUb0V2ZW4sXG4gIGludFRvSGV4OiBpbnRUb0hleCxcbiAgZnJvbUFzY2lpOiBmcm9tQXNjaWksXG4gIGZyb21VdGY4OiBmcm9tVXRmOCxcbiAgdG9Bc2NpaTogdG9Bc2NpaSxcbiAgdG9VdGY4OiB0b1V0ZjgsXG4gIGdldEtleXM6IGdldEtleXMsXG4gIGlzSGV4U3RyaW5nOiBpc0hleFN0cmluZ1xufTsiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mZXRjaFRva2VuTWV0YWRhdGEgPSBleHBvcnRzLmZldGNoVG9rZW5MaXN0ID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBFTkRfUE9JTlQgPSAnaHR0cHM6Ly90b2tlbi1hcGkubWV0YXN3YXAuY29kZWZpLm5ldHdvcmsnO1xuZnVuY3Rpb24gZ2V0VG9rZW5zVVJMKGNoYWluSWQpIHtcbiAgICByZXR1cm4gYCR7RU5EX1BPSU5UfS90b2tlbnMvJHtjaGFpbklkfWA7XG59XG5mdW5jdGlvbiBnZXRUb2tlbk1ldGFkYXRhVVJMKGNoYWluSWQsIHRva2VuQWRkcmVzcykge1xuICAgIHJldHVybiBgJHtFTkRfUE9JTlR9L3Rva2VuLyR7Y2hhaW5JZH0/YWRkcmVzcz0ke3Rva2VuQWRkcmVzc31gO1xufVxuLy8gVG9rZW4gbGlzdCBhdmVyYWdlcyAxLjYgTUIgaW4gc2l6ZVxuLy8gdGltZW91dEZldGNoIGJ5IGRlZmF1bHQgaGFzIGEgNTAwbXMgdGltZW91dCwgd2hpY2ggd2lsbCBhbG1vc3QgYWx3YXlzIHRpbWVvdXQgZ2l2ZW4gdGhlIHJlc3BvbnNlIHNpemUuXG5jb25zdCB0aW1lb3V0ID0gMTAwMDA7XG4vKipcbiAqIEZldGNoZXMgdGhlIGxpc3Qgb2YgdG9rZW4gbWV0YWRhdGEgZm9yIGEgZ2l2ZW4gbmV0d29yayBjaGFpbklkXG4gKlxuICogQHJldHVybnMgLSBQcm9taXNlIHJlc29sdmluZyB0b2tlbiBMaXN0XG4gKi9cbmZ1bmN0aW9uIGZldGNoVG9rZW5MaXN0KGNoYWluSWQsIGFib3J0U2lnbmFsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgdG9rZW5VUkwgPSBnZXRUb2tlbnNVUkwoY2hhaW5JZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcXVlcnlBcGkodG9rZW5VUkwsIGFib3J0U2lnbmFsKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VKc29uUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoVG9rZW5MaXN0ID0gZmV0Y2hUb2tlbkxpc3Q7XG4vKipcbiAqIEZldGNoIG1ldGFkYXRhIGZvciB0aGUgdG9rZW4gYWRkcmVzcyBwcm92aWRlZCBmb3IgYSBnaXZlbiBuZXR3b3JrIGNoYWluSWRcbiAqXG4gKiBAcmV0dXJuIFByb21pc2UgcmVzb2x2aW5nIHRva2VuIG1ldGFkYXRhIGZvciB0aGUgdG9rZW5BZGRyZXNzIHByb3ZpZGVkXG4gKi9cbmZ1bmN0aW9uIGZldGNoVG9rZW5NZXRhZGF0YShjaGFpbklkLCB0b2tlbkFkZHJlc3MsIGFib3J0U2lnbmFsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgdG9rZW5NZXRhZGF0YVVSTCA9IGdldFRva2VuTWV0YWRhdGFVUkwoY2hhaW5JZCwgdG9rZW5BZGRyZXNzKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBxdWVyeUFwaSh0b2tlbk1ldGFkYXRhVVJMLCBhYm9ydFNpZ25hbCk7XG4gICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSnNvblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaFRva2VuTWV0YWRhdGEgPSBmZXRjaFRva2VuTWV0YWRhdGE7XG4vKipcbiAqIFBlcmZvcm0gZmV0Y2ggcmVxdWVzdCBhZ2FpbnN0IHRoZSBhcGlcbiAqXG4gKiBAcmV0dXJuIFByb21pc2UgcmVzb2x2aW5nIHJlcXVlc3QgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gcXVlcnlBcGkoYXBpVVJMLCBhYm9ydFNpZ25hbCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGZldGNoT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHJlZmVycmVyOiBhcGlVUkwsXG4gICAgICAgICAgICByZWZlcnJlclBvbGljeTogJ25vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlJyxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBtb2RlOiAnY29ycycsXG4gICAgICAgICAgICBzaWduYWw6IGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgY2FjaGU6ICdkZWZhdWx0JyxcbiAgICAgICAgfTtcbiAgICAgICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMgPSBuZXcgd2luZG93LkhlYWRlcnMoKTtcbiAgICAgICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMuc2V0KCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHV0aWxfMS50aW1lb3V0RmV0Y2goYXBpVVJMLCBmZXRjaE9wdGlvbnMsIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlcXVlc3QgaXMgYWJvcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG59XG4vKipcbiAqIFBhcnNlIHJlc3BvbnNlXG4gKlxuICogQHJldHVybiBQcm9taXNlIHJlc29sdmluZyByZXF1ZXN0IHJlc3BvbnNlIGpzb24gdmFsdWVcbiAqL1xuZnVuY3Rpb24gcGFyc2VKc29uUmVzcG9uc2UoYXBpUmVzcG9uc2UpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCByZXNwb25zZU9iaiA9IHlpZWxkIGFwaVJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgLy8gYXBpIG1heSByZXR1cm4gZXJyb3JzIGFzIGpzb24gd2l0aG91dCBzZXR0aW5nIGFuIGVycm9yIGh0dHAgc3RhdHVzIGNvZGVcbiAgICAgICAgaWYgKHJlc3BvbnNlT2JqID09PSBudWxsIHx8IHJlc3BvbnNlT2JqID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZU9iai5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb2tlblNlcnZpY2UgRXJyb3I6ICR7cmVzcG9uc2VPYmouZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlT2JqO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9rZW4tc2VydmljZS5qcy5tYXAiXSwicHJlRXhpc3RpbmdDb21tZW50IjoiLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIn0=
